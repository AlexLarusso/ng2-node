/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _platformBrowserDynamic = __webpack_require__(1);

	var _app = __webpack_require__(23);

	var platform = (0, _platformBrowserDynamic.platformBrowserDynamic)();
	platform.bootstrapModule(_app.AppModule);

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/**
	 * @license Angular v2.1.2
	 * (c) 2010-2016 Google, Inc. https://angular.io/
	 * License: MIT
	 */
	(function (global, factory) {
	     true ? factory(exports, __webpack_require__(2), __webpack_require__(3), __webpack_require__(21)) :
	    typeof define === 'function' && define.amd ? define(['exports', '@angular/compiler', '@angular/core', '@angular/platform-browser'], factory) :
	    (factory((global.ng = global.ng || {}, global.ng.platformBrowserDynamic = global.ng.platformBrowserDynamic || {}),global.ng.compiler,global.ng.core,global.ng.platformBrowser));
	}(this, function (exports,_angular_compiler,_angular_core,_angular_platformBrowser) { 'use strict';

	    var INTERNAL_BROWSER_PLATFORM_PROVIDERS = _angular_platformBrowser.__platform_browser_private__.INTERNAL_BROWSER_PLATFORM_PROVIDERS;

	    var __extends = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    var ResourceLoaderImpl = (function (_super) {
	        __extends(ResourceLoaderImpl, _super);
	        function ResourceLoaderImpl() {
	            _super.apply(this, arguments);
	        }
	        ResourceLoaderImpl.prototype.get = function (url) {
	            var resolve;
	            var reject;
	            var promise = new Promise(function (res, rej) {
	                resolve = res;
	                reject = rej;
	            });
	            var xhr = new XMLHttpRequest();
	            xhr.open('GET', url, true);
	            xhr.responseType = 'text';
	            xhr.onload = function () {
	                // responseText is the old-school way of retrieving response (supported by IE8 & 9)
	                // response/responseType properties were introduced in ResourceLoader Level2 spec (supported
	                // by IE10)
	                var response = xhr.response || xhr.responseText;
	                // normalize IE9 bug (http://bugs.jquery.com/ticket/1450)
	                var status = xhr.status === 1223 ? 204 : xhr.status;
	                // fix status code when it is 0 (0 status is undocumented).
	                // Occurs when accessing file resources or on Android 4.1 stock browser
	                // while retrieving files from application cache.
	                if (status === 0) {
	                    status = response ? 200 : 0;
	                }
	                if (200 <= status && status <= 300) {
	                    resolve(response);
	                }
	                else {
	                    reject("Failed to load " + url);
	                }
	            };
	            xhr.onerror = function () { reject("Failed to load " + url); };
	            xhr.send();
	            return promise;
	        };
	        ResourceLoaderImpl.decorators = [
	            { type: _angular_core.Injectable },
	        ];
	        /** @nocollapse */
	        ResourceLoaderImpl.ctorParameters = [];
	        return ResourceLoaderImpl;
	    }(_angular_compiler.ResourceLoader));

	    var INTERNAL_BROWSER_DYNAMIC_PLATFORM_PROVIDERS = [
	        INTERNAL_BROWSER_PLATFORM_PROVIDERS,
	        {
	            provide: _angular_core.COMPILER_OPTIONS,
	            useValue: { providers: [{ provide: _angular_compiler.ResourceLoader, useClass: ResourceLoaderImpl }] },
	            multi: true
	        },
	    ];

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var globalScope;
	    if (typeof window === 'undefined') {
	        if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) {
	            // TODO: Replace any with WorkerGlobalScope from lib.webworker.d.ts #3492
	            globalScope = self;
	        }
	        else {
	            globalScope = global;
	        }
	    }
	    else {
	        globalScope = window;
	    }
	    // Need to declare a new variable for global here since TypeScript
	    // exports the original value of the symbol.
	    var _global = globalScope;
	    // TODO: remove calls to assert in production environment
	    // Note: Can't just export this and import in in other files
	    // as `assert` is a reserved keyword in Dart
	    _global.assert = function assert(condition) {
	        // TODO: to be fixed properly via #2830, noop for now
	    };

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$1 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    /**
	     * An implementation of ResourceLoader that uses a template cache to avoid doing an actual
	     * ResourceLoader.
	     *
	     * The template cache needs to be built and loaded into window.$templateCache
	     * via a separate mechanism.
	     */
	    var CachedResourceLoader = (function (_super) {
	        __extends$1(CachedResourceLoader, _super);
	        function CachedResourceLoader() {
	            _super.call(this);
	            this._cache = _global.$templateCache;
	            if (this._cache == null) {
	                throw new Error('CachedResourceLoader: Template cache was not found in $templateCache.');
	            }
	        }
	        CachedResourceLoader.prototype.get = function (url) {
	            if (this._cache.hasOwnProperty(url)) {
	                return Promise.resolve(this._cache[url]);
	            }
	            else {
	                return Promise.reject('CachedResourceLoader: Did not find cached template for ' + url);
	            }
	        };
	        return CachedResourceLoader;
	    }(_angular_compiler.ResourceLoader));

	    var __platform_browser_dynamic_private__ = {
	        INTERNAL_BROWSER_DYNAMIC_PLATFORM_PROVIDERS: INTERNAL_BROWSER_DYNAMIC_PLATFORM_PROVIDERS,
	        ResourceLoaderImpl: ResourceLoaderImpl
	    };

	    /**
	     * @experimental
	     */
	    var RESOURCE_CACHE_PROVIDER = [{ provide: _angular_compiler.ResourceLoader, useClass: CachedResourceLoader }];
	    /**
	     * @stable
	     */
	    var platformBrowserDynamic = _angular_core.createPlatformFactory(_angular_compiler.platformCoreDynamic, 'browserDynamic', INTERNAL_BROWSER_DYNAMIC_PLATFORM_PROVIDERS);

	    exports.RESOURCE_CACHE_PROVIDER = RESOURCE_CACHE_PROVIDER;
	    exports.platformBrowserDynamic = platformBrowserDynamic;
	    exports.__platform_browser_dynamic_private__ = __platform_browser_dynamic_private__;

	}));

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license Angular v2.1.2
	 * (c) 2010-2016 Google, Inc. https://angular.io/
	 * License: MIT
	 */
	(function (global, factory) {
	   true ? factory(exports, __webpack_require__(3)) :
	  typeof define === 'function' && define.amd ? define(['exports', '@angular/core'], factory) :
	  (factory((global.ng = global.ng || {}, global.ng.compiler = global.ng.compiler || {}),global.ng.core));
	}(this, function (exports,_angular_core) { 'use strict';

	  /**
	   * @license
	   * Copyright Google Inc. All Rights Reserved.
	   *
	   * Use of this source code is governed by an MIT-style license that can be
	   * found in the LICENSE file at https://angular.io/license
	   */
	  /**
	   * A segment of text within the template.
	   */
	  var TextAst = (function () {
	      function TextAst(value, ngContentIndex, sourceSpan) {
	          this.value = value;
	          this.ngContentIndex = ngContentIndex;
	          this.sourceSpan = sourceSpan;
	      }
	      TextAst.prototype.visit = function (visitor, context) { return visitor.visitText(this, context); };
	      return TextAst;
	  }());
	  /**
	   * A bound expression within the text of a template.
	   */
	  var BoundTextAst = (function () {
	      function BoundTextAst(value, ngContentIndex, sourceSpan) {
	          this.value = value;
	          this.ngContentIndex = ngContentIndex;
	          this.sourceSpan = sourceSpan;
	      }
	      BoundTextAst.prototype.visit = function (visitor, context) {
	          return visitor.visitBoundText(this, context);
	      };
	      return BoundTextAst;
	  }());
	  /**
	   * A plain attribute on an element.
	   */
	  var AttrAst = (function () {
	      function AttrAst(name, value, sourceSpan) {
	          this.name = name;
	          this.value = value;
	          this.sourceSpan = sourceSpan;
	      }
	      AttrAst.prototype.visit = function (visitor, context) { return visitor.visitAttr(this, context); };
	      return AttrAst;
	  }());
	  /**
	   * A binding for an element property (e.g. `[property]="expression"`) or an animation trigger (e.g.
	   * `[@trigger]="stateExp"`)
	   */
	  var BoundElementPropertyAst = (function () {
	      function BoundElementPropertyAst(name, type, securityContext, needsRuntimeSecurityContext, value, unit, sourceSpan) {
	          this.name = name;
	          this.type = type;
	          this.securityContext = securityContext;
	          this.needsRuntimeSecurityContext = needsRuntimeSecurityContext;
	          this.value = value;
	          this.unit = unit;
	          this.sourceSpan = sourceSpan;
	      }
	      BoundElementPropertyAst.prototype.visit = function (visitor, context) {
	          return visitor.visitElementProperty(this, context);
	      };
	      Object.defineProperty(BoundElementPropertyAst.prototype, "isAnimation", {
	          get: function () { return this.type === exports.PropertyBindingType.Animation; },
	          enumerable: true,
	          configurable: true
	      });
	      return BoundElementPropertyAst;
	  }());
	  /**
	   * A binding for an element event (e.g. `(event)="handler()"`) or an animation trigger event (e.g.
	   * `(@trigger.phase)="callback($event)"`).
	   */
	  var BoundEventAst = (function () {
	      function BoundEventAst(name, target, phase, handler, sourceSpan) {
	          this.name = name;
	          this.target = target;
	          this.phase = phase;
	          this.handler = handler;
	          this.sourceSpan = sourceSpan;
	      }
	      BoundEventAst.prototype.visit = function (visitor, context) {
	          return visitor.visitEvent(this, context);
	      };
	      Object.defineProperty(BoundEventAst.prototype, "fullName", {
	          get: function () {
	              if (this.target) {
	                  return this.target + ":" + this.name;
	              }
	              else {
	                  return this.name;
	              }
	          },
	          enumerable: true,
	          configurable: true
	      });
	      Object.defineProperty(BoundEventAst.prototype, "isAnimation", {
	          get: function () { return !!this.phase; },
	          enumerable: true,
	          configurable: true
	      });
	      return BoundEventAst;
	  }());
	  /**
	   * A reference declaration on an element (e.g. `let someName="expression"`).
	   */
	  var ReferenceAst = (function () {
	      function ReferenceAst(name, value, sourceSpan) {
	          this.name = name;
	          this.value = value;
	          this.sourceSpan = sourceSpan;
	      }
	      ReferenceAst.prototype.visit = function (visitor, context) {
	          return visitor.visitReference(this, context);
	      };
	      return ReferenceAst;
	  }());
	  /**
	   * A variable declaration on a <template> (e.g. `var-someName="someLocalName"`).
	   */
	  var VariableAst = (function () {
	      function VariableAst(name, value, sourceSpan) {
	          this.name = name;
	          this.value = value;
	          this.sourceSpan = sourceSpan;
	      }
	      VariableAst.prototype.visit = function (visitor, context) {
	          return visitor.visitVariable(this, context);
	      };
	      return VariableAst;
	  }());
	  /**
	   * An element declaration in a template.
	   */
	  var ElementAst = (function () {
	      function ElementAst(name, attrs, inputs, outputs, references, directives, providers, hasViewContainer, children, ngContentIndex, sourceSpan, endSourceSpan) {
	          this.name = name;
	          this.attrs = attrs;
	          this.inputs = inputs;
	          this.outputs = outputs;
	          this.references = references;
	          this.directives = directives;
	          this.providers = providers;
	          this.hasViewContainer = hasViewContainer;
	          this.children = children;
	          this.ngContentIndex = ngContentIndex;
	          this.sourceSpan = sourceSpan;
	          this.endSourceSpan = endSourceSpan;
	      }
	      ElementAst.prototype.visit = function (visitor, context) {
	          return visitor.visitElement(this, context);
	      };
	      return ElementAst;
	  }());
	  /**
	   * A `<template>` element included in an Angular template.
	   */
	  var EmbeddedTemplateAst = (function () {
	      function EmbeddedTemplateAst(attrs, outputs, references, variables, directives, providers, hasViewContainer, children, ngContentIndex, sourceSpan) {
	          this.attrs = attrs;
	          this.outputs = outputs;
	          this.references = references;
	          this.variables = variables;
	          this.directives = directives;
	          this.providers = providers;
	          this.hasViewContainer = hasViewContainer;
	          this.children = children;
	          this.ngContentIndex = ngContentIndex;
	          this.sourceSpan = sourceSpan;
	      }
	      EmbeddedTemplateAst.prototype.visit = function (visitor, context) {
	          return visitor.visitEmbeddedTemplate(this, context);
	      };
	      return EmbeddedTemplateAst;
	  }());
	  /**
	   * A directive property with a bound value (e.g. `*ngIf="condition").
	   */
	  var BoundDirectivePropertyAst = (function () {
	      function BoundDirectivePropertyAst(directiveName, templateName, value, sourceSpan) {
	          this.directiveName = directiveName;
	          this.templateName = templateName;
	          this.value = value;
	          this.sourceSpan = sourceSpan;
	      }
	      BoundDirectivePropertyAst.prototype.visit = function (visitor, context) {
	          return visitor.visitDirectiveProperty(this, context);
	      };
	      return BoundDirectivePropertyAst;
	  }());
	  /**
	   * A directive declared on an element.
	   */
	  var DirectiveAst = (function () {
	      function DirectiveAst(directive, inputs, hostProperties, hostEvents, sourceSpan) {
	          this.directive = directive;
	          this.inputs = inputs;
	          this.hostProperties = hostProperties;
	          this.hostEvents = hostEvents;
	          this.sourceSpan = sourceSpan;
	      }
	      DirectiveAst.prototype.visit = function (visitor, context) {
	          return visitor.visitDirective(this, context);
	      };
	      return DirectiveAst;
	  }());
	  /**
	   * A provider declared on an element
	   */
	  var ProviderAst = (function () {
	      function ProviderAst(token, multiProvider, eager, providers, providerType, lifecycleHooks, sourceSpan) {
	          this.token = token;
	          this.multiProvider = multiProvider;
	          this.eager = eager;
	          this.providers = providers;
	          this.providerType = providerType;
	          this.lifecycleHooks = lifecycleHooks;
	          this.sourceSpan = sourceSpan;
	      }
	      ProviderAst.prototype.visit = function (visitor, context) {
	          // No visit method in the visitor for now...
	          return null;
	      };
	      return ProviderAst;
	  }());
	  exports.ProviderAstType;
	  (function (ProviderAstType) {
	      ProviderAstType[ProviderAstType["PublicService"] = 0] = "PublicService";
	      ProviderAstType[ProviderAstType["PrivateService"] = 1] = "PrivateService";
	      ProviderAstType[ProviderAstType["Component"] = 2] = "Component";
	      ProviderAstType[ProviderAstType["Directive"] = 3] = "Directive";
	      ProviderAstType[ProviderAstType["Builtin"] = 4] = "Builtin";
	  })(exports.ProviderAstType || (exports.ProviderAstType = {}));
	  /**
	   * Position where content is to be projected (instance of `<ng-content>` in a template).
	   */
	  var NgContentAst = (function () {
	      function NgContentAst(index, ngContentIndex, sourceSpan) {
	          this.index = index;
	          this.ngContentIndex = ngContentIndex;
	          this.sourceSpan = sourceSpan;
	      }
	      NgContentAst.prototype.visit = function (visitor, context) {
	          return visitor.visitNgContent(this, context);
	      };
	      return NgContentAst;
	  }());
	  /**
	   * Enumeration of types of property bindings.
	   */
	  exports.PropertyBindingType;
	  (function (PropertyBindingType) {
	      /**
	       * A normal binding to a property (e.g. `[property]="expression"`).
	       */
	      PropertyBindingType[PropertyBindingType["Property"] = 0] = "Property";
	      /**
	       * A binding to an element attribute (e.g. `[attr.name]="expression"`).
	       */
	      PropertyBindingType[PropertyBindingType["Attribute"] = 1] = "Attribute";
	      /**
	       * A binding to a CSS class (e.g. `[class.name]="condition"`).
	       */
	      PropertyBindingType[PropertyBindingType["Class"] = 2] = "Class";
	      /**
	       * A binding to a style rule (e.g. `[style.rule]="expression"`).
	       */
	      PropertyBindingType[PropertyBindingType["Style"] = 3] = "Style";
	      /**
	       * A binding to an animation reference (e.g. `[animate.key]="expression"`).
	       */
	      PropertyBindingType[PropertyBindingType["Animation"] = 4] = "Animation";
	  })(exports.PropertyBindingType || (exports.PropertyBindingType = {}));
	  /**
	   * Visit every node in a list of {@link TemplateAst}s with the given {@link TemplateAstVisitor}.
	   */
	  function templateVisitAll(visitor, asts, context) {
	      if (context === void 0) { context = null; }
	      var result = [];
	      var visit = visitor.visit ?
	          function (ast) { return visitor.visit(ast, context) || ast.visit(visitor, context); } :
	          function (ast) { return ast.visit(visitor, context); };
	      asts.forEach(function (ast) {
	          var astResult = visit(ast);
	          if (astResult) {
	              result.push(astResult);
	          }
	      });
	      return result;
	  }

	  function isPresent(obj) {
	      return obj != null;
	  }
	  function isBlank(obj) {
	      return obj == null;
	  }
	  var STRING_MAP_PROTO = Object.getPrototypeOf({});
	  function isStrictStringMap(obj) {
	      return typeof obj === 'object' && obj !== null && Object.getPrototypeOf(obj) === STRING_MAP_PROTO;
	  }
	  function stringify(token) {
	      if (typeof token === 'string') {
	          return token;
	      }
	      if (token === undefined || token === null) {
	          return '' + token;
	      }
	      if (token.overriddenName) {
	          return token.overriddenName;
	      }
	      if (token.name) {
	          return token.name;
	      }
	      var res = token.toString();
	      var newLineIndex = res.indexOf('\n');
	      return newLineIndex === -1 ? res : res.substring(0, newLineIndex);
	  }
	  var NumberWrapper = (function () {
	      function NumberWrapper() {
	      }
	      NumberWrapper.parseIntAutoRadix = function (text) {
	          var result = parseInt(text);
	          if (isNaN(result)) {
	              throw new Error('Invalid integer literal when parsing ' + text);
	          }
	          return result;
	      };
	      NumberWrapper.parseInt = function (text, radix) {
	          if (radix == 10) {
	              if (/^(\-|\+)?[0-9]+$/.test(text)) {
	                  return parseInt(text, radix);
	              }
	          }
	          else if (radix == 16) {
	              if (/^(\-|\+)?[0-9ABCDEFabcdef]+$/.test(text)) {
	                  return parseInt(text, radix);
	              }
	          }
	          else {
	              var result = parseInt(text, radix);
	              if (!isNaN(result)) {
	                  return result;
	              }
	          }
	          throw new Error('Invalid integer literal when parsing ' + text + ' in base ' + radix);
	      };
	      NumberWrapper.isNumeric = function (value) { return !isNaN(value - parseFloat(value)); };
	      return NumberWrapper;
	  }());
	  function isJsObject(o) {
	      return o !== null && (typeof o === 'function' || typeof o === 'object');
	  }
	  function isPrimitive(obj) {
	      return !isJsObject(obj);
	  }
	  function escapeRegExp(s) {
	      return s.replace(/([.*+?^=!:${}()|[\]\/\\])/g, '\\$1');
	  }

	  // Safari doesn't implement MapIterator.next(), which is used is Traceur's polyfill of Array.from
	  // TODO(mlaval): remove the work around once we have a working polyfill of Array.from
	  var _arrayFromMap = (function () {
	      try {
	          if ((new Map()).values().next) {
	              return function createArrayFromMap(m, getValues) {
	                  return getValues ? Array.from(m.values()) : Array.from(m.keys());
	              };
	          }
	      }
	      catch (e) {
	      }
	      return function createArrayFromMapWithForeach(m, getValues) {
	          var res = new Array(m.size), i = 0;
	          m.forEach(function (v, k) {
	              res[i] = getValues ? v : k;
	              i++;
	          });
	          return res;
	      };
	  })();
	  var MapWrapper = (function () {
	      function MapWrapper() {
	      }
	      MapWrapper.createFromStringMap = function (stringMap) {
	          var result = new Map();
	          for (var prop in stringMap) {
	              result.set(prop, stringMap[prop]);
	          }
	          return result;
	      };
	      MapWrapper.keys = function (m) { return _arrayFromMap(m, false); };
	      MapWrapper.values = function (m) { return _arrayFromMap(m, true); };
	      return MapWrapper;
	  }());
	  /**
	   * Wraps Javascript Objects
	   */
	  var StringMapWrapper = (function () {
	      function StringMapWrapper() {
	      }
	      StringMapWrapper.merge = function (m1, m2) {
	          var m = {};
	          for (var _i = 0, _a = Object.keys(m1); _i < _a.length; _i++) {
	              var k = _a[_i];
	              m[k] = m1[k];
	          }
	          for (var _b = 0, _c = Object.keys(m2); _b < _c.length; _b++) {
	              var k = _c[_b];
	              m[k] = m2[k];
	          }
	          return m;
	      };
	      StringMapWrapper.equals = function (m1, m2) {
	          var k1 = Object.keys(m1);
	          var k2 = Object.keys(m2);
	          if (k1.length != k2.length) {
	              return false;
	          }
	          for (var i = 0; i < k1.length; i++) {
	              var key = k1[i];
	              if (m1[key] !== m2[key]) {
	                  return false;
	              }
	          }
	          return true;
	      };
	      return StringMapWrapper;
	  }());
	  var ListWrapper = (function () {
	      function ListWrapper() {
	      }
	      ListWrapper.removeAll = function (list, items) {
	          for (var i = 0; i < items.length; ++i) {
	              var index = list.indexOf(items[i]);
	              list.splice(index, 1);
	          }
	      };
	      ListWrapper.remove = function (list, el) {
	          var index = list.indexOf(el);
	          if (index > -1) {
	              list.splice(index, 1);
	              return true;
	          }
	          return false;
	      };
	      ListWrapper.equals = function (a, b) {
	          if (a.length != b.length)
	              return false;
	          for (var i = 0; i < a.length; ++i) {
	              if (a[i] !== b[i])
	                  return false;
	          }
	          return true;
	      };
	      ListWrapper.maximum = function (list, predicate) {
	          if (list.length == 0) {
	              return null;
	          }
	          var solution = null;
	          var maxValue = -Infinity;
	          for (var index = 0; index < list.length; index++) {
	              var candidate = list[index];
	              if (candidate == null) {
	                  continue;
	              }
	              var candidateValue = predicate(candidate);
	              if (candidateValue > maxValue) {
	                  solution = candidate;
	                  maxValue = candidateValue;
	              }
	          }
	          return solution;
	      };
	      ListWrapper.flatten = function (list) {
	          var target = [];
	          _flattenArray(list, target);
	          return target;
	      };
	      return ListWrapper;
	  }());
	  function _flattenArray(source, target) {
	      if (isPresent(source)) {
	          for (var i = 0; i < source.length; i++) {
	              var item = source[i];
	              if (Array.isArray(item)) {
	                  _flattenArray(item, target);
	              }
	              else {
	                  target.push(item);
	              }
	          }
	      }
	      return target;
	  }

	  /**
	   * @license
	   * Copyright Google Inc. All Rights Reserved.
	   *
	   * Use of this source code is governed by an MIT-style license that can be
	   * found in the LICENSE file at https://angular.io/license
	   */
	  var TagContentType;
	  (function (TagContentType) {
	      TagContentType[TagContentType["RAW_TEXT"] = 0] = "RAW_TEXT";
	      TagContentType[TagContentType["ESCAPABLE_RAW_TEXT"] = 1] = "ESCAPABLE_RAW_TEXT";
	      TagContentType[TagContentType["PARSABLE_DATA"] = 2] = "PARSABLE_DATA";
	  })(TagContentType || (TagContentType = {}));
	  function splitNsName(elementName) {
	      if (elementName[0] != ':') {
	          return [null, elementName];
	      }
	      var colonIndex = elementName.indexOf(':', 1);
	      if (colonIndex == -1) {
	          throw new Error("Unsupported format \"" + elementName + "\" expecting \":namespace:name\"");
	      }
	      return [elementName.slice(1, colonIndex), elementName.slice(colonIndex + 1)];
	  }
	  function getNsPrefix(fullName) {
	      return fullName === null ? null : splitNsName(fullName)[0];
	  }
	  function mergeNsAndName(prefix, localName) {
	      return prefix ? ":" + prefix + ":" + localName : localName;
	  }
	  // see http://www.w3.org/TR/html51/syntax.html#named-character-references
	  // see https://html.spec.whatwg.org/multipage/entities.json
	  // This list is not exhaustive to keep the compiler footprint low.
	  // The `&#123;` / `&#x1ab;` syntax should be used when the named character reference does not exist.
	  var NAMED_ENTITIES = {
	      'Aacute': '\u00C1',
	      'aacute': '\u00E1',
	      'Acirc': '\u00C2',
	      'acirc': '\u00E2',
	      'acute': '\u00B4',
	      'AElig': '\u00C6',
	      'aelig': '\u00E6',
	      'Agrave': '\u00C0',
	      'agrave': '\u00E0',
	      'alefsym': '\u2135',
	      'Alpha': '\u0391',
	      'alpha': '\u03B1',
	      'amp': '&',
	      'and': '\u2227',
	      'ang': '\u2220',
	      'apos': '\u0027',
	      'Aring': '\u00C5',
	      'aring': '\u00E5',
	      'asymp': '\u2248',
	      'Atilde': '\u00C3',
	      'atilde': '\u00E3',
	      'Auml': '\u00C4',
	      'auml': '\u00E4',
	      'bdquo': '\u201E',
	      'Beta': '\u0392',
	      'beta': '\u03B2',
	      'brvbar': '\u00A6',
	      'bull': '\u2022',
	      'cap': '\u2229',
	      'Ccedil': '\u00C7',
	      'ccedil': '\u00E7',
	      'cedil': '\u00B8',
	      'cent': '\u00A2',
	      'Chi': '\u03A7',
	      'chi': '\u03C7',
	      'circ': '\u02C6',
	      'clubs': '\u2663',
	      'cong': '\u2245',
	      'copy': '\u00A9',
	      'crarr': '\u21B5',
	      'cup': '\u222A',
	      'curren': '\u00A4',
	      'dagger': '\u2020',
	      'Dagger': '\u2021',
	      'darr': '\u2193',
	      'dArr': '\u21D3',
	      'deg': '\u00B0',
	      'Delta': '\u0394',
	      'delta': '\u03B4',
	      'diams': '\u2666',
	      'divide': '\u00F7',
	      'Eacute': '\u00C9',
	      'eacute': '\u00E9',
	      'Ecirc': '\u00CA',
	      'ecirc': '\u00EA',
	      'Egrave': '\u00C8',
	      'egrave': '\u00E8',
	      'empty': '\u2205',
	      'emsp': '\u2003',
	      'ensp': '\u2002',
	      'Epsilon': '\u0395',
	      'epsilon': '\u03B5',
	      'equiv': '\u2261',
	      'Eta': '\u0397',
	      'eta': '\u03B7',
	      'ETH': '\u00D0',
	      'eth': '\u00F0',
	      'Euml': '\u00CB',
	      'euml': '\u00EB',
	      'euro': '\u20AC',
	      'exist': '\u2203',
	      'fnof': '\u0192',
	      'forall': '\u2200',
	      'frac12': '\u00BD',
	      'frac14': '\u00BC',
	      'frac34': '\u00BE',
	      'frasl': '\u2044',
	      'Gamma': '\u0393',
	      'gamma': '\u03B3',
	      'ge': '\u2265',
	      'gt': '>',
	      'harr': '\u2194',
	      'hArr': '\u21D4',
	      'hearts': '\u2665',
	      'hellip': '\u2026',
	      'Iacute': '\u00CD',
	      'iacute': '\u00ED',
	      'Icirc': '\u00CE',
	      'icirc': '\u00EE',
	      'iexcl': '\u00A1',
	      'Igrave': '\u00CC',
	      'igrave': '\u00EC',
	      'image': '\u2111',
	      'infin': '\u221E',
	      'int': '\u222B',
	      'Iota': '\u0399',
	      'iota': '\u03B9',
	      'iquest': '\u00BF',
	      'isin': '\u2208',
	      'Iuml': '\u00CF',
	      'iuml': '\u00EF',
	      'Kappa': '\u039A',
	      'kappa': '\u03BA',
	      'Lambda': '\u039B',
	      'lambda': '\u03BB',
	      'lang': '\u27E8',
	      'laquo': '\u00AB',
	      'larr': '\u2190',
	      'lArr': '\u21D0',
	      'lceil': '\u2308',
	      'ldquo': '\u201C',
	      'le': '\u2264',
	      'lfloor': '\u230A',
	      'lowast': '\u2217',
	      'loz': '\u25CA',
	      'lrm': '\u200E',
	      'lsaquo': '\u2039',
	      'lsquo': '\u2018',
	      'lt': '<',
	      'macr': '\u00AF',
	      'mdash': '\u2014',
	      'micro': '\u00B5',
	      'middot': '\u00B7',
	      'minus': '\u2212',
	      'Mu': '\u039C',
	      'mu': '\u03BC',
	      'nabla': '\u2207',
	      'nbsp': '\u00A0',
	      'ndash': '\u2013',
	      'ne': '\u2260',
	      'ni': '\u220B',
	      'not': '\u00AC',
	      'notin': '\u2209',
	      'nsub': '\u2284',
	      'Ntilde': '\u00D1',
	      'ntilde': '\u00F1',
	      'Nu': '\u039D',
	      'nu': '\u03BD',
	      'Oacute': '\u00D3',
	      'oacute': '\u00F3',
	      'Ocirc': '\u00D4',
	      'ocirc': '\u00F4',
	      'OElig': '\u0152',
	      'oelig': '\u0153',
	      'Ograve': '\u00D2',
	      'ograve': '\u00F2',
	      'oline': '\u203E',
	      'Omega': '\u03A9',
	      'omega': '\u03C9',
	      'Omicron': '\u039F',
	      'omicron': '\u03BF',
	      'oplus': '\u2295',
	      'or': '\u2228',
	      'ordf': '\u00AA',
	      'ordm': '\u00BA',
	      'Oslash': '\u00D8',
	      'oslash': '\u00F8',
	      'Otilde': '\u00D5',
	      'otilde': '\u00F5',
	      'otimes': '\u2297',
	      'Ouml': '\u00D6',
	      'ouml': '\u00F6',
	      'para': '\u00B6',
	      'permil': '\u2030',
	      'perp': '\u22A5',
	      'Phi': '\u03A6',
	      'phi': '\u03C6',
	      'Pi': '\u03A0',
	      'pi': '\u03C0',
	      'piv': '\u03D6',
	      'plusmn': '\u00B1',
	      'pound': '\u00A3',
	      'prime': '\u2032',
	      'Prime': '\u2033',
	      'prod': '\u220F',
	      'prop': '\u221D',
	      'Psi': '\u03A8',
	      'psi': '\u03C8',
	      'quot': '\u0022',
	      'radic': '\u221A',
	      'rang': '\u27E9',
	      'raquo': '\u00BB',
	      'rarr': '\u2192',
	      'rArr': '\u21D2',
	      'rceil': '\u2309',
	      'rdquo': '\u201D',
	      'real': '\u211C',
	      'reg': '\u00AE',
	      'rfloor': '\u230B',
	      'Rho': '\u03A1',
	      'rho': '\u03C1',
	      'rlm': '\u200F',
	      'rsaquo': '\u203A',
	      'rsquo': '\u2019',
	      'sbquo': '\u201A',
	      'Scaron': '\u0160',
	      'scaron': '\u0161',
	      'sdot': '\u22C5',
	      'sect': '\u00A7',
	      'shy': '\u00AD',
	      'Sigma': '\u03A3',
	      'sigma': '\u03C3',
	      'sigmaf': '\u03C2',
	      'sim': '\u223C',
	      'spades': '\u2660',
	      'sub': '\u2282',
	      'sube': '\u2286',
	      'sum': '\u2211',
	      'sup': '\u2283',
	      'sup1': '\u00B9',
	      'sup2': '\u00B2',
	      'sup3': '\u00B3',
	      'supe': '\u2287',
	      'szlig': '\u00DF',
	      'Tau': '\u03A4',
	      'tau': '\u03C4',
	      'there4': '\u2234',
	      'Theta': '\u0398',
	      'theta': '\u03B8',
	      'thetasym': '\u03D1',
	      'thinsp': '\u2009',
	      'THORN': '\u00DE',
	      'thorn': '\u00FE',
	      'tilde': '\u02DC',
	      'times': '\u00D7',
	      'trade': '\u2122',
	      'Uacute': '\u00DA',
	      'uacute': '\u00FA',
	      'uarr': '\u2191',
	      'uArr': '\u21D1',
	      'Ucirc': '\u00DB',
	      'ucirc': '\u00FB',
	      'Ugrave': '\u00D9',
	      'ugrave': '\u00F9',
	      'uml': '\u00A8',
	      'upsih': '\u03D2',
	      'Upsilon': '\u03A5',
	      'upsilon': '\u03C5',
	      'Uuml': '\u00DC',
	      'uuml': '\u00FC',
	      'weierp': '\u2118',
	      'Xi': '\u039E',
	      'xi': '\u03BE',
	      'Yacute': '\u00DD',
	      'yacute': '\u00FD',
	      'yen': '\u00A5',
	      'yuml': '\u00FF',
	      'Yuml': '\u0178',
	      'Zeta': '\u0396',
	      'zeta': '\u03B6',
	      'zwj': '\u200D',
	      'zwnj': '\u200C',
	  };

	  var HtmlTagDefinition = (function () {
	      function HtmlTagDefinition(_a) {
	          var _this = this;
	          var _b = _a === void 0 ? {} : _a, closedByChildren = _b.closedByChildren, requiredParents = _b.requiredParents, implicitNamespacePrefix = _b.implicitNamespacePrefix, _c = _b.contentType, contentType = _c === void 0 ? TagContentType.PARSABLE_DATA : _c, _d = _b.closedByParent, closedByParent = _d === void 0 ? false : _d, _e = _b.isVoid, isVoid = _e === void 0 ? false : _e, _f = _b.ignoreFirstLf, ignoreFirstLf = _f === void 0 ? false : _f;
	          this.closedByChildren = {};
	          this.closedByParent = false;
	          this.canSelfClose = false;
	          if (closedByChildren && closedByChildren.length > 0) {
	              closedByChildren.forEach(function (tagName) { return _this.closedByChildren[tagName] = true; });
	          }
	          this.isVoid = isVoid;
	          this.closedByParent = closedByParent || isVoid;
	          if (requiredParents && requiredParents.length > 0) {
	              this.requiredParents = {};
	              // The first parent is the list is automatically when none of the listed parents are present
	              this.parentToAdd = requiredParents[0];
	              requiredParents.forEach(function (tagName) { return _this.requiredParents[tagName] = true; });
	          }
	          this.implicitNamespacePrefix = implicitNamespacePrefix;
	          this.contentType = contentType;
	          this.ignoreFirstLf = ignoreFirstLf;
	      }
	      HtmlTagDefinition.prototype.requireExtraParent = function (currentParent) {
	          if (!this.requiredParents) {
	              return false;
	          }
	          if (!currentParent) {
	              return true;
	          }
	          var lcParent = currentParent.toLowerCase();
	          return this.requiredParents[lcParent] != true && lcParent != 'template';
	      };
	      HtmlTagDefinition.prototype.isClosedByChild = function (name) {
	          return this.isVoid || name.toLowerCase() in this.closedByChildren;
	      };
	      return HtmlTagDefinition;
	  }());
	  // see http://www.w3.org/TR/html51/syntax.html#optional-tags
	  // This implementation does not fully conform to the HTML5 spec.
	  var TAG_DEFINITIONS = {
	      'base': new HtmlTagDefinition({ isVoid: true }),
	      'meta': new HtmlTagDefinition({ isVoid: true }),
	      'area': new HtmlTagDefinition({ isVoid: true }),
	      'embed': new HtmlTagDefinition({ isVoid: true }),
	      'link': new HtmlTagDefinition({ isVoid: true }),
	      'img': new HtmlTagDefinition({ isVoid: true }),
	      'input': new HtmlTagDefinition({ isVoid: true }),
	      'param': new HtmlTagDefinition({ isVoid: true }),
	      'hr': new HtmlTagDefinition({ isVoid: true }),
	      'br': new HtmlTagDefinition({ isVoid: true }),
	      'source': new HtmlTagDefinition({ isVoid: true }),
	      'track': new HtmlTagDefinition({ isVoid: true }),
	      'wbr': new HtmlTagDefinition({ isVoid: true }),
	      'p': new HtmlTagDefinition({
	          closedByChildren: [
	              'address', 'article', 'aside', 'blockquote', 'div', 'dl', 'fieldset', 'footer', 'form',
	              'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'header', 'hgroup', 'hr',
	              'main', 'nav', 'ol', 'p', 'pre', 'section', 'table', 'ul'
	          ],
	          closedByParent: true
	      }),
	      'thead': new HtmlTagDefinition({ closedByChildren: ['tbody', 'tfoot'] }),
	      'tbody': new HtmlTagDefinition({ closedByChildren: ['tbody', 'tfoot'], closedByParent: true }),
	      'tfoot': new HtmlTagDefinition({ closedByChildren: ['tbody'], closedByParent: true }),
	      'tr': new HtmlTagDefinition({
	          closedByChildren: ['tr'],
	          requiredParents: ['tbody', 'tfoot', 'thead'],
	          closedByParent: true
	      }),
	      'td': new HtmlTagDefinition({ closedByChildren: ['td', 'th'], closedByParent: true }),
	      'th': new HtmlTagDefinition({ closedByChildren: ['td', 'th'], closedByParent: true }),
	      'col': new HtmlTagDefinition({ requiredParents: ['colgroup'], isVoid: true }),
	      'svg': new HtmlTagDefinition({ implicitNamespacePrefix: 'svg' }),
	      'math': new HtmlTagDefinition({ implicitNamespacePrefix: 'math' }),
	      'li': new HtmlTagDefinition({ closedByChildren: ['li'], closedByParent: true }),
	      'dt': new HtmlTagDefinition({ closedByChildren: ['dt', 'dd'] }),
	      'dd': new HtmlTagDefinition({ closedByChildren: ['dt', 'dd'], closedByParent: true }),
	      'rb': new HtmlTagDefinition({ closedByChildren: ['rb', 'rt', 'rtc', 'rp'], closedByParent: true }),
	      'rt': new HtmlTagDefinition({ closedByChildren: ['rb', 'rt', 'rtc', 'rp'], closedByParent: true }),
	      'rtc': new HtmlTagDefinition({ closedByChildren: ['rb', 'rtc', 'rp'], closedByParent: true }),
	      'rp': new HtmlTagDefinition({ closedByChildren: ['rb', 'rt', 'rtc', 'rp'], closedByParent: true }),
	      'optgroup': new HtmlTagDefinition({ closedByChildren: ['optgroup'], closedByParent: true }),
	      'option': new HtmlTagDefinition({ closedByChildren: ['option', 'optgroup'], closedByParent: true }),
	      'pre': new HtmlTagDefinition({ ignoreFirstLf: true }),
	      'listing': new HtmlTagDefinition({ ignoreFirstLf: true }),
	      'style': new HtmlTagDefinition({ contentType: TagContentType.RAW_TEXT }),
	      'script': new HtmlTagDefinition({ contentType: TagContentType.RAW_TEXT }),
	      'title': new HtmlTagDefinition({ contentType: TagContentType.ESCAPABLE_RAW_TEXT }),
	      'textarea': new HtmlTagDefinition({ contentType: TagContentType.ESCAPABLE_RAW_TEXT, ignoreFirstLf: true }),
	  };
	  var _DEFAULT_TAG_DEFINITION = new HtmlTagDefinition();
	  function getHtmlTagDefinition(tagName) {
	      return TAG_DEFINITIONS[tagName.toLowerCase()] || _DEFAULT_TAG_DEFINITION;
	  }

	  var _SELECTOR_REGEXP = new RegExp('(\\:not\\()|' +
	      '([-\\w]+)|' +
	      '(?:\\.([-\\w]+))|' +
	      '(?:\\[([-\\w*]+)(?:=([^\\]]*))?\\])|' +
	      '(\\))|' +
	      '(\\s*,\\s*)', // ","
	  'g');
	  /**
	   * A css selector contains an element name,
	   * css classes and attribute/value pairs with the purpose
	   * of selecting subsets out of them.
	   */
	  var CssSelector = (function () {
	      function CssSelector() {
	          this.element = null;
	          this.classNames = [];
	          this.attrs = [];
	          this.notSelectors = [];
	      }
	      CssSelector.parse = function (selector) {
	          var results = [];
	          var _addResult = function (res, cssSel) {
	              if (cssSel.notSelectors.length > 0 && !cssSel.element && cssSel.classNames.length == 0 &&
	                  cssSel.attrs.length == 0) {
	                  cssSel.element = '*';
	              }
	              res.push(cssSel);
	          };
	          var cssSelector = new CssSelector();
	          var match;
	          var current = cssSelector;
	          var inNot = false;
	          _SELECTOR_REGEXP.lastIndex = 0;
	          while (match = _SELECTOR_REGEXP.exec(selector)) {
	              if (match[1]) {
	                  if (inNot) {
	                      throw new Error('Nesting :not is not allowed in a selector');
	                  }
	                  inNot = true;
	                  current = new CssSelector();
	                  cssSelector.notSelectors.push(current);
	              }
	              if (match[2]) {
	                  current.setElement(match[2]);
	              }
	              if (match[3]) {
	                  current.addClassName(match[3]);
	              }
	              if (match[4]) {
	                  current.addAttribute(match[4], match[5]);
	              }
	              if (match[6]) {
	                  inNot = false;
	                  current = cssSelector;
	              }
	              if (match[7]) {
	                  if (inNot) {
	                      throw new Error('Multiple selectors in :not are not supported');
	                  }
	                  _addResult(results, cssSelector);
	                  cssSelector = current = new CssSelector();
	              }
	          }
	          _addResult(results, cssSelector);
	          return results;
	      };
	      CssSelector.prototype.isElementSelector = function () {
	          return this.hasElementSelector() && this.classNames.length == 0 && this.attrs.length == 0 &&
	              this.notSelectors.length === 0;
	      };
	      CssSelector.prototype.hasElementSelector = function () { return !!this.element; };
	      CssSelector.prototype.setElement = function (element) {
	          if (element === void 0) { element = null; }
	          this.element = element;
	      };
	      /** Gets a template string for an element that matches the selector. */
	      CssSelector.prototype.getMatchingElementTemplate = function () {
	          var tagName = this.element || 'div';
	          var classAttr = this.classNames.length > 0 ? " class=\"" + this.classNames.join(' ') + "\"" : '';
	          var attrs = '';
	          for (var i = 0; i < this.attrs.length; i += 2) {
	              var attrName = this.attrs[i];
	              var attrValue = this.attrs[i + 1] !== '' ? "=\"" + this.attrs[i + 1] + "\"" : '';
	              attrs += " " + attrName + attrValue;
	          }
	          return getHtmlTagDefinition(tagName).isVoid ? "<" + tagName + classAttr + attrs + "/>" :
	              "<" + tagName + classAttr + attrs + "></" + tagName + ">";
	      };
	      CssSelector.prototype.addAttribute = function (name, value) {
	          if (value === void 0) { value = ''; }
	          this.attrs.push(name, value && value.toLowerCase() || '');
	      };
	      CssSelector.prototype.addClassName = function (name) { this.classNames.push(name.toLowerCase()); };
	      CssSelector.prototype.toString = function () {
	          var res = this.element || '';
	          if (this.classNames) {
	              this.classNames.forEach(function (klass) { return res += "." + klass; });
	          }
	          if (this.attrs) {
	              for (var i = 0; i < this.attrs.length; i += 2) {
	                  var name_1 = this.attrs[i];
	                  var value = this.attrs[i + 1];
	                  res += "[" + name_1 + (value ? '=' + value : '') + "]";
	              }
	          }
	          this.notSelectors.forEach(function (notSelector) { return res += ":not(" + notSelector + ")"; });
	          return res;
	      };
	      return CssSelector;
	  }());
	  /**
	   * Reads a list of CssSelectors and allows to calculate which ones
	   * are contained in a given CssSelector.
	   */
	  var SelectorMatcher = (function () {
	      function SelectorMatcher() {
	          this._elementMap = new Map();
	          this._elementPartialMap = new Map();
	          this._classMap = new Map();
	          this._classPartialMap = new Map();
	          this._attrValueMap = new Map();
	          this._attrValuePartialMap = new Map();
	          this._listContexts = [];
	      }
	      SelectorMatcher.createNotMatcher = function (notSelectors) {
	          var notMatcher = new SelectorMatcher();
	          notMatcher.addSelectables(notSelectors, null);
	          return notMatcher;
	      };
	      SelectorMatcher.prototype.addSelectables = function (cssSelectors, callbackCtxt) {
	          var listContext = null;
	          if (cssSelectors.length > 1) {
	              listContext = new SelectorListContext(cssSelectors);
	              this._listContexts.push(listContext);
	          }
	          for (var i = 0; i < cssSelectors.length; i++) {
	              this._addSelectable(cssSelectors[i], callbackCtxt, listContext);
	          }
	      };
	      /**
	       * Add an object that can be found later on by calling `match`.
	       * @param cssSelector A css selector
	       * @param callbackCtxt An opaque object that will be given to the callback of the `match` function
	       */
	      SelectorMatcher.prototype._addSelectable = function (cssSelector, callbackCtxt, listContext) {
	          var matcher = this;
	          var element = cssSelector.element;
	          var classNames = cssSelector.classNames;
	          var attrs = cssSelector.attrs;
	          var selectable = new SelectorContext(cssSelector, callbackCtxt, listContext);
	          if (element) {
	              var isTerminal = attrs.length === 0 && classNames.length === 0;
	              if (isTerminal) {
	                  this._addTerminal(matcher._elementMap, element, selectable);
	              }
	              else {
	                  matcher = this._addPartial(matcher._elementPartialMap, element);
	              }
	          }
	          if (classNames) {
	              for (var i = 0; i < classNames.length; i++) {
	                  var isTerminal = attrs.length === 0 && i === classNames.length - 1;
	                  var className = classNames[i];
	                  if (isTerminal) {
	                      this._addTerminal(matcher._classMap, className, selectable);
	                  }
	                  else {
	                      matcher = this._addPartial(matcher._classPartialMap, className);
	                  }
	              }
	          }
	          if (attrs) {
	              for (var i = 0; i < attrs.length; i += 2) {
	                  var isTerminal = i === attrs.length - 2;
	                  var name_2 = attrs[i];
	                  var value = attrs[i + 1];
	                  if (isTerminal) {
	                      var terminalMap = matcher._attrValueMap;
	                      var terminalValuesMap = terminalMap.get(name_2);
	                      if (!terminalValuesMap) {
	                          terminalValuesMap = new Map();
	                          terminalMap.set(name_2, terminalValuesMap);
	                      }
	                      this._addTerminal(terminalValuesMap, value, selectable);
	                  }
	                  else {
	                      var partialMap = matcher._attrValuePartialMap;
	                      var partialValuesMap = partialMap.get(name_2);
	                      if (!partialValuesMap) {
	                          partialValuesMap = new Map();
	                          partialMap.set(name_2, partialValuesMap);
	                      }
	                      matcher = this._addPartial(partialValuesMap, value);
	                  }
	              }
	          }
	      };
	      SelectorMatcher.prototype._addTerminal = function (map, name, selectable) {
	          var terminalList = map.get(name);
	          if (!terminalList) {
	              terminalList = [];
	              map.set(name, terminalList);
	          }
	          terminalList.push(selectable);
	      };
	      SelectorMatcher.prototype._addPartial = function (map, name) {
	          var matcher = map.get(name);
	          if (!matcher) {
	              matcher = new SelectorMatcher();
	              map.set(name, matcher);
	          }
	          return matcher;
	      };
	      /**
	       * Find the objects that have been added via `addSelectable`
	       * whose css selector is contained in the given css selector.
	       * @param cssSelector A css selector
	       * @param matchedCallback This callback will be called with the object handed into `addSelectable`
	       * @return boolean true if a match was found
	      */
	      SelectorMatcher.prototype.match = function (cssSelector, matchedCallback) {
	          var result = false;
	          var element = cssSelector.element;
	          var classNames = cssSelector.classNames;
	          var attrs = cssSelector.attrs;
	          for (var i = 0; i < this._listContexts.length; i++) {
	              this._listContexts[i].alreadyMatched = false;
	          }
	          result = this._matchTerminal(this._elementMap, element, cssSelector, matchedCallback) || result;
	          result = this._matchPartial(this._elementPartialMap, element, cssSelector, matchedCallback) ||
	              result;
	          if (classNames) {
	              for (var i = 0; i < classNames.length; i++) {
	                  var className = classNames[i];
	                  result =
	                      this._matchTerminal(this._classMap, className, cssSelector, matchedCallback) || result;
	                  result =
	                      this._matchPartial(this._classPartialMap, className, cssSelector, matchedCallback) ||
	                          result;
	              }
	          }
	          if (attrs) {
	              for (var i = 0; i < attrs.length; i += 2) {
	                  var name_3 = attrs[i];
	                  var value = attrs[i + 1];
	                  var terminalValuesMap = this._attrValueMap.get(name_3);
	                  if (value) {
	                      result =
	                          this._matchTerminal(terminalValuesMap, '', cssSelector, matchedCallback) || result;
	                  }
	                  result =
	                      this._matchTerminal(terminalValuesMap, value, cssSelector, matchedCallback) || result;
	                  var partialValuesMap = this._attrValuePartialMap.get(name_3);
	                  if (value) {
	                      result = this._matchPartial(partialValuesMap, '', cssSelector, matchedCallback) || result;
	                  }
	                  result =
	                      this._matchPartial(partialValuesMap, value, cssSelector, matchedCallback) || result;
	              }
	          }
	          return result;
	      };
	      /** @internal */
	      SelectorMatcher.prototype._matchTerminal = function (map, name, cssSelector, matchedCallback) {
	          if (!map || typeof name !== 'string') {
	              return false;
	          }
	          var selectables = map.get(name);
	          var starSelectables = map.get('*');
	          if (starSelectables) {
	              selectables = selectables.concat(starSelectables);
	          }
	          if (!selectables) {
	              return false;
	          }
	          var selectable;
	          var result = false;
	          for (var i = 0; i < selectables.length; i++) {
	              selectable = selectables[i];
	              result = selectable.finalize(cssSelector, matchedCallback) || result;
	          }
	          return result;
	      };
	      /** @internal */
	      SelectorMatcher.prototype._matchPartial = function (map, name, cssSelector, matchedCallback) {
	          if (!map || typeof name !== 'string') {
	              return false;
	          }
	          var nestedSelector = map.get(name);
	          if (!nestedSelector) {
	              return false;
	          }
	          // TODO(perf): get rid of recursion and measure again
	          // TODO(perf): don't pass the whole selector into the recursion,
	          // but only the not processed parts
	          return nestedSelector.match(cssSelector, matchedCallback);
	      };
	      return SelectorMatcher;
	  }());
	  var SelectorListContext = (function () {
	      function SelectorListContext(selectors) {
	          this.selectors = selectors;
	          this.alreadyMatched = false;
	      }
	      return SelectorListContext;
	  }());
	  // Store context to pass back selector and context when a selector is matched
	  var SelectorContext = (function () {
	      function SelectorContext(selector, cbContext, listContext) {
	          this.selector = selector;
	          this.cbContext = cbContext;
	          this.listContext = listContext;
	          this.notSelectors = selector.notSelectors;
	      }
	      SelectorContext.prototype.finalize = function (cssSelector, callback) {
	          var result = true;
	          if (this.notSelectors.length > 0 && (!this.listContext || !this.listContext.alreadyMatched)) {
	              var notMatcher = SelectorMatcher.createNotMatcher(this.notSelectors);
	              result = !notMatcher.match(cssSelector, null);
	          }
	          if (result && callback && (!this.listContext || !this.listContext.alreadyMatched)) {
	              if (this.listContext) {
	                  this.listContext.alreadyMatched = true;
	              }
	              callback(this.selector, this.cbContext);
	          }
	          return result;
	      };
	      return SelectorContext;
	  }());

	  var MODULE_SUFFIX = '';
	  function splitAtColon(input, defaultValues) {
	      return _splitAt(input, ':', defaultValues);
	  }
	  function splitAtPeriod(input, defaultValues) {
	      return _splitAt(input, '.', defaultValues);
	  }
	  function _splitAt(input, character, defaultValues) {
	      var characterIndex = input.indexOf(character);
	      if (characterIndex == -1)
	          return defaultValues;
	      return [input.slice(0, characterIndex).trim(), input.slice(characterIndex + 1).trim()];
	  }
	  function sanitizeIdentifier(name) {
	      return name.replace(/\W/g, '_');
	  }
	  function visitValue(value, visitor, context) {
	      if (Array.isArray(value)) {
	          return visitor.visitArray(value, context);
	      }
	      if (isStrictStringMap(value)) {
	          return visitor.visitStringMap(value, context);
	      }
	      if (isBlank(value) || isPrimitive(value)) {
	          return visitor.visitPrimitive(value, context);
	      }
	      return visitor.visitOther(value, context);
	  }
	  var ValueTransformer = (function () {
	      function ValueTransformer() {
	      }
	      ValueTransformer.prototype.visitArray = function (arr, context) {
	          var _this = this;
	          return arr.map(function (value) { return visitValue(value, _this, context); });
	      };
	      ValueTransformer.prototype.visitStringMap = function (map, context) {
	          var _this = this;
	          var result = {};
	          Object.keys(map).forEach(function (key) { result[key] = visitValue(map[key], _this, context); });
	          return result;
	      };
	      ValueTransformer.prototype.visitPrimitive = function (value, context) { return value; };
	      ValueTransformer.prototype.visitOther = function (value, context) { return value; };
	      return ValueTransformer;
	  }());
	  var SyncAsyncResult = (function () {
	      function SyncAsyncResult(syncResult, asyncResult) {
	          if (asyncResult === void 0) { asyncResult = null; }
	          this.syncResult = syncResult;
	          this.asyncResult = asyncResult;
	          if (!asyncResult) {
	              this.asyncResult = Promise.resolve(syncResult);
	          }
	      }
	      return SyncAsyncResult;
	  }());

	  /**
	   * @license
	   * Copyright Google Inc. All Rights Reserved.
	   *
	   * Use of this source code is governed by an MIT-style license that can be
	   * found in the LICENSE file at https://angular.io/license
	   */
	  var __extends$1 = (this && this.__extends) || function (d, b) {
	      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	      function __() { this.constructor = d; }
	      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	  };
	  function unimplemented() {
	      throw new Error('unimplemented');
	  }
	  // group 0: "[prop] or (event) or @trigger"
	  // group 1: "prop" from "[prop]"
	  // group 2: "event" from "(event)"
	  // group 3: "@trigger" from "@trigger"
	  var HOST_REG_EXP = /^(?:(?:\[([^\]]+)\])|(?:\(([^\)]+)\)))|(\@[-\w]+)$/;
	  var CompileMetadataWithIdentifier = (function () {
	      function CompileMetadataWithIdentifier() {
	      }
	      Object.defineProperty(CompileMetadataWithIdentifier.prototype, "identifier", {
	          get: function () { return unimplemented(); },
	          enumerable: true,
	          configurable: true
	      });
	      return CompileMetadataWithIdentifier;
	  }());
	  var CompileAnimationEntryMetadata = (function () {
	      function CompileAnimationEntryMetadata(name, definitions) {
	          if (name === void 0) { name = null; }
	          if (definitions === void 0) { definitions = null; }
	          this.name = name;
	          this.definitions = definitions;
	      }
	      return CompileAnimationEntryMetadata;
	  }());
	  var CompileAnimationStateMetadata = (function () {
	      function CompileAnimationStateMetadata() {
	      }
	      return CompileAnimationStateMetadata;
	  }());
	  var CompileAnimationStateDeclarationMetadata = (function (_super) {
	      __extends$1(CompileAnimationStateDeclarationMetadata, _super);
	      function CompileAnimationStateDeclarationMetadata(stateNameExpr, styles) {
	          _super.call(this);
	          this.stateNameExpr = stateNameExpr;
	          this.styles = styles;
	      }
	      return CompileAnimationStateDeclarationMetadata;
	  }(CompileAnimationStateMetadata));
	  var CompileAnimationStateTransitionMetadata = (function (_super) {
	      __extends$1(CompileAnimationStateTransitionMetadata, _super);
	      function CompileAnimationStateTransitionMetadata(stateChangeExpr, steps) {
	          _super.call(this);
	          this.stateChangeExpr = stateChangeExpr;
	          this.steps = steps;
	      }
	      return CompileAnimationStateTransitionMetadata;
	  }(CompileAnimationStateMetadata));
	  var CompileAnimationMetadata = (function () {
	      function CompileAnimationMetadata() {
	      }
	      return CompileAnimationMetadata;
	  }());
	  var CompileAnimationKeyframesSequenceMetadata = (function (_super) {
	      __extends$1(CompileAnimationKeyframesSequenceMetadata, _super);
	      function CompileAnimationKeyframesSequenceMetadata(steps) {
	          if (steps === void 0) { steps = []; }
	          _super.call(this);
	          this.steps = steps;
	      }
	      return CompileAnimationKeyframesSequenceMetadata;
	  }(CompileAnimationMetadata));
	  var CompileAnimationStyleMetadata = (function (_super) {
	      __extends$1(CompileAnimationStyleMetadata, _super);
	      function CompileAnimationStyleMetadata(offset, styles) {
	          if (styles === void 0) { styles = null; }
	          _super.call(this);
	          this.offset = offset;
	          this.styles = styles;
	      }
	      return CompileAnimationStyleMetadata;
	  }(CompileAnimationMetadata));
	  var CompileAnimationAnimateMetadata = (function (_super) {
	      __extends$1(CompileAnimationAnimateMetadata, _super);
	      function CompileAnimationAnimateMetadata(timings, styles) {
	          if (timings === void 0) { timings = 0; }
	          if (styles === void 0) { styles = null; }
	          _super.call(this);
	          this.timings = timings;
	          this.styles = styles;
	      }
	      return CompileAnimationAnimateMetadata;
	  }(CompileAnimationMetadata));
	  var CompileAnimationWithStepsMetadata = (function (_super) {
	      __extends$1(CompileAnimationWithStepsMetadata, _super);
	      function CompileAnimationWithStepsMetadata(steps) {
	          if (steps === void 0) { steps = null; }
	          _super.call(this);
	          this.steps = steps;
	      }
	      return CompileAnimationWithStepsMetadata;
	  }(CompileAnimationMetadata));
	  var CompileAnimationSequenceMetadata = (function (_super) {
	      __extends$1(CompileAnimationSequenceMetadata, _super);
	      function CompileAnimationSequenceMetadata(steps) {
	          if (steps === void 0) { steps = null; }
	          _super.call(this, steps);
	      }
	      return CompileAnimationSequenceMetadata;
	  }(CompileAnimationWithStepsMetadata));
	  var CompileAnimationGroupMetadata = (function (_super) {
	      __extends$1(CompileAnimationGroupMetadata, _super);
	      function CompileAnimationGroupMetadata(steps) {
	          if (steps === void 0) { steps = null; }
	          _super.call(this, steps);
	      }
	      return CompileAnimationGroupMetadata;
	  }(CompileAnimationWithStepsMetadata));
	  var CompileIdentifierMetadata = (function () {
	      function CompileIdentifierMetadata(_a) {
	          var _b = _a === void 0 ? {} : _a, reference = _b.reference, name = _b.name, moduleUrl = _b.moduleUrl, prefix = _b.prefix, value = _b.value;
	          this.reference = reference;
	          this.name = name;
	          this.prefix = prefix;
	          this.moduleUrl = moduleUrl;
	          this.value = value;
	      }
	      Object.defineProperty(CompileIdentifierMetadata.prototype, "identifier", {
	          get: function () { return this; },
	          enumerable: true,
	          configurable: true
	      });
	      return CompileIdentifierMetadata;
	  }());
	  var CompileDiDependencyMetadata = (function () {
	      function CompileDiDependencyMetadata(_a) {
	          var _b = _a === void 0 ? {} : _a, isAttribute = _b.isAttribute, isSelf = _b.isSelf, isHost = _b.isHost, isSkipSelf = _b.isSkipSelf, isOptional = _b.isOptional, isValue = _b.isValue, query = _b.query, viewQuery = _b.viewQuery, token = _b.token, value = _b.value;
	          this.isAttribute = !!isAttribute;
	          this.isSelf = !!isSelf;
	          this.isHost = !!isHost;
	          this.isSkipSelf = !!isSkipSelf;
	          this.isOptional = !!isOptional;
	          this.isValue = !!isValue;
	          this.query = query;
	          this.viewQuery = viewQuery;
	          this.token = token;
	          this.value = value;
	      }
	      return CompileDiDependencyMetadata;
	  }());
	  var CompileProviderMetadata = (function () {
	      function CompileProviderMetadata(_a) {
	          var token = _a.token, useClass = _a.useClass, useValue = _a.useValue, useExisting = _a.useExisting, useFactory = _a.useFactory, deps = _a.deps, multi = _a.multi;
	          this.token = token;
	          this.useClass = useClass;
	          this.useValue = useValue;
	          this.useExisting = useExisting;
	          this.useFactory = useFactory;
	          this.deps = deps || null;
	          this.multi = !!multi;
	      }
	      return CompileProviderMetadata;
	  }());
	  var CompileFactoryMetadata = (function (_super) {
	      __extends$1(CompileFactoryMetadata, _super);
	      function CompileFactoryMetadata(_a) {
	          var reference = _a.reference, name = _a.name, moduleUrl = _a.moduleUrl, prefix = _a.prefix, diDeps = _a.diDeps, value = _a.value;
	          _super.call(this, { reference: reference, name: name, prefix: prefix, moduleUrl: moduleUrl, value: value });
	          this.diDeps = _normalizeArray(diDeps);
	      }
	      return CompileFactoryMetadata;
	  }(CompileIdentifierMetadata));
	  var CompileTokenMetadata = (function () {
	      function CompileTokenMetadata(_a) {
	          var value = _a.value, identifier = _a.identifier, identifierIsInstance = _a.identifierIsInstance;
	          this.value = value;
	          this.identifier = identifier;
	          this.identifierIsInstance = !!identifierIsInstance;
	      }
	      Object.defineProperty(CompileTokenMetadata.prototype, "reference", {
	          get: function () {
	              if (isPresent(this.identifier)) {
	                  return this.identifier.reference;
	              }
	              else {
	                  return this.value;
	              }
	          },
	          enumerable: true,
	          configurable: true
	      });
	      Object.defineProperty(CompileTokenMetadata.prototype, "name", {
	          get: function () {
	              return isPresent(this.value) ? sanitizeIdentifier(this.value) : this.identifier.name;
	          },
	          enumerable: true,
	          configurable: true
	      });
	      return CompileTokenMetadata;
	  }());
	  /**
	   * Metadata regarding compilation of a type.
	   */
	  var CompileTypeMetadata = (function (_super) {
	      __extends$1(CompileTypeMetadata, _super);
	      function CompileTypeMetadata(_a) {
	          var _b = _a === void 0 ? {} : _a, reference = _b.reference, name = _b.name, moduleUrl = _b.moduleUrl, prefix = _b.prefix, isHost = _b.isHost, value = _b.value, diDeps = _b.diDeps, lifecycleHooks = _b.lifecycleHooks;
	          _super.call(this, { reference: reference, name: name, moduleUrl: moduleUrl, prefix: prefix, value: value });
	          this.isHost = !!isHost;
	          this.diDeps = _normalizeArray(diDeps);
	          this.lifecycleHooks = _normalizeArray(lifecycleHooks);
	      }
	      return CompileTypeMetadata;
	  }(CompileIdentifierMetadata));
	  var CompileQueryMetadata = (function () {
	      function CompileQueryMetadata(_a) {
	          var _b = _a === void 0 ? {} : _a, selectors = _b.selectors, descendants = _b.descendants, first = _b.first, propertyName = _b.propertyName, read = _b.read;
	          this.selectors = selectors;
	          this.descendants = !!descendants;
	          this.first = !!first;
	          this.propertyName = propertyName;
	          this.read = read;
	      }
	      return CompileQueryMetadata;
	  }());
	  /**
	   * Metadata about a stylesheet
	   */
	  var CompileStylesheetMetadata = (function () {
	      function CompileStylesheetMetadata(_a) {
	          var _b = _a === void 0 ? {} : _a, moduleUrl = _b.moduleUrl, styles = _b.styles, styleUrls = _b.styleUrls;
	          this.moduleUrl = moduleUrl;
	          this.styles = _normalizeArray(styles);
	          this.styleUrls = _normalizeArray(styleUrls);
	      }
	      return CompileStylesheetMetadata;
	  }());
	  /**
	   * Metadata regarding compilation of a template.
	   */
	  var CompileTemplateMetadata = (function () {
	      function CompileTemplateMetadata(_a) {
	          var _b = _a === void 0 ? {} : _a, encapsulation = _b.encapsulation, template = _b.template, templateUrl = _b.templateUrl, styles = _b.styles, styleUrls = _b.styleUrls, externalStylesheets = _b.externalStylesheets, animations = _b.animations, ngContentSelectors = _b.ngContentSelectors, interpolation = _b.interpolation;
	          this.encapsulation = encapsulation;
	          this.template = template;
	          this.templateUrl = templateUrl;
	          this.styles = _normalizeArray(styles);
	          this.styleUrls = _normalizeArray(styleUrls);
	          this.externalStylesheets = _normalizeArray(externalStylesheets);
	          this.animations = animations ? ListWrapper.flatten(animations) : [];
	          this.ngContentSelectors = ngContentSelectors || [];
	          if (interpolation && interpolation.length != 2) {
	              throw new Error("'interpolation' should have a start and an end symbol.");
	          }
	          this.interpolation = interpolation;
	      }
	      return CompileTemplateMetadata;
	  }());
	  /**
	   * Metadata regarding compilation of a directive.
	   */
	  var CompileDirectiveMetadata = (function () {
	      function CompileDirectiveMetadata(_a) {
	          var _b = _a === void 0 ? {} : _a, type = _b.type, isComponent = _b.isComponent, selector = _b.selector, exportAs = _b.exportAs, changeDetection = _b.changeDetection, inputs = _b.inputs, outputs = _b.outputs, hostListeners = _b.hostListeners, hostProperties = _b.hostProperties, hostAttributes = _b.hostAttributes, providers = _b.providers, viewProviders = _b.viewProviders, queries = _b.queries, viewQueries = _b.viewQueries, entryComponents = _b.entryComponents, template = _b.template;
	          this.type = type;
	          this.isComponent = isComponent;
	          this.selector = selector;
	          this.exportAs = exportAs;
	          this.changeDetection = changeDetection;
	          this.inputs = inputs;
	          this.outputs = outputs;
	          this.hostListeners = hostListeners;
	          this.hostProperties = hostProperties;
	          this.hostAttributes = hostAttributes;
	          this.providers = _normalizeArray(providers);
	          this.viewProviders = _normalizeArray(viewProviders);
	          this.queries = _normalizeArray(queries);
	          this.viewQueries = _normalizeArray(viewQueries);
	          this.entryComponents = _normalizeArray(entryComponents);
	          this.template = template;
	      }
	      CompileDirectiveMetadata.create = function (_a) {
	          var _b = _a === void 0 ? {} : _a, type = _b.type, isComponent = _b.isComponent, selector = _b.selector, exportAs = _b.exportAs, changeDetection = _b.changeDetection, inputs = _b.inputs, outputs = _b.outputs, host = _b.host, providers = _b.providers, viewProviders = _b.viewProviders, queries = _b.queries, viewQueries = _b.viewQueries, entryComponents = _b.entryComponents, template = _b.template;
	          var hostListeners = {};
	          var hostProperties = {};
	          var hostAttributes = {};
	          if (isPresent(host)) {
	              Object.keys(host).forEach(function (key) {
	                  var value = host[key];
	                  var matches = key.match(HOST_REG_EXP);
	                  if (matches === null) {
	                      hostAttributes[key] = value;
	                  }
	                  else if (isPresent(matches[1])) {
	                      hostProperties[matches[1]] = value;
	                  }
	                  else if (isPresent(matches[2])) {
	                      hostListeners[matches[2]] = value;
	                  }
	              });
	          }
	          var inputsMap = {};
	          if (isPresent(inputs)) {
	              inputs.forEach(function (bindConfig) {
	                  // canonical syntax: `dirProp: elProp`
	                  // if there is no `:`, use dirProp = elProp
	                  var parts = splitAtColon(bindConfig, [bindConfig, bindConfig]);
	                  inputsMap[parts[0]] = parts[1];
	              });
	          }
	          var outputsMap = {};
	          if (isPresent(outputs)) {
	              outputs.forEach(function (bindConfig) {
	                  // canonical syntax: `dirProp: elProp`
	                  // if there is no `:`, use dirProp = elProp
	                  var parts = splitAtColon(bindConfig, [bindConfig, bindConfig]);
	                  outputsMap[parts[0]] = parts[1];
	              });
	          }
	          return new CompileDirectiveMetadata({
	              type: type,
	              isComponent: !!isComponent, selector: selector, exportAs: exportAs, changeDetection: changeDetection,
	              inputs: inputsMap,
	              outputs: outputsMap,
	              hostListeners: hostListeners,
	              hostProperties: hostProperties,
	              hostAttributes: hostAttributes,
	              providers: providers,
	              viewProviders: viewProviders,
	              queries: queries,
	              viewQueries: viewQueries,
	              entryComponents: entryComponents,
	              template: template,
	          });
	      };
	      Object.defineProperty(CompileDirectiveMetadata.prototype, "identifier", {
	          get: function () { return this.type; },
	          enumerable: true,
	          configurable: true
	      });
	      return CompileDirectiveMetadata;
	  }());
	  /**
	   * Construct {@link CompileDirectiveMetadata} from {@link ComponentTypeMetadata} and a selector.
	   */
	  function createHostComponentMeta(compMeta) {
	      var template = CssSelector.parse(compMeta.selector)[0].getMatchingElementTemplate();
	      return CompileDirectiveMetadata.create({
	          type: new CompileTypeMetadata({
	              reference: Object,
	              name: compMeta.type.name + "_Host",
	              moduleUrl: compMeta.type.moduleUrl,
	              isHost: true
	          }),
	          template: new CompileTemplateMetadata({
	              encapsulation: _angular_core.ViewEncapsulation.None,
	              template: template,
	              templateUrl: '',
	              styles: [],
	              styleUrls: [],
	              ngContentSelectors: [],
	              animations: []
	          }),
	          changeDetection: _angular_core.ChangeDetectionStrategy.Default,
	          inputs: [],
	          outputs: [],
	          host: {},
	          isComponent: true,
	          selector: '*',
	          providers: [],
	          viewProviders: [],
	          queries: [],
	          viewQueries: []
	      });
	  }
	  var CompilePipeMetadata = (function () {
	      function CompilePipeMetadata(_a) {
	          var _b = _a === void 0 ? {} : _a, type = _b.type, name = _b.name, pure = _b.pure;
	          this.type = type;
	          this.name = name;
	          this.pure = !!pure;
	      }
	      Object.defineProperty(CompilePipeMetadata.prototype, "identifier", {
	          get: function () { return this.type; },
	          enumerable: true,
	          configurable: true
	      });
	      return CompilePipeMetadata;
	  }());
	  /**
	   * Metadata regarding compilation of a module.
	   */
	  var CompileNgModuleMetadata = (function () {
	      function CompileNgModuleMetadata(_a) {
	          var _b = _a === void 0 ? {} : _a, type = _b.type, providers = _b.providers, declaredDirectives = _b.declaredDirectives, exportedDirectives = _b.exportedDirectives, declaredPipes = _b.declaredPipes, exportedPipes = _b.exportedPipes, entryComponents = _b.entryComponents, bootstrapComponents = _b.bootstrapComponents, importedModules = _b.importedModules, exportedModules = _b.exportedModules, schemas = _b.schemas, transitiveModule = _b.transitiveModule, id = _b.id;
	          this.type = type;
	          this.declaredDirectives = _normalizeArray(declaredDirectives);
	          this.exportedDirectives = _normalizeArray(exportedDirectives);
	          this.declaredPipes = _normalizeArray(declaredPipes);
	          this.exportedPipes = _normalizeArray(exportedPipes);
	          this.providers = _normalizeArray(providers);
	          this.entryComponents = _normalizeArray(entryComponents);
	          this.bootstrapComponents = _normalizeArray(bootstrapComponents);
	          this.importedModules = _normalizeArray(importedModules);
	          this.exportedModules = _normalizeArray(exportedModules);
	          this.schemas = _normalizeArray(schemas);
	          this.id = id;
	          this.transitiveModule = transitiveModule;
	      }
	      Object.defineProperty(CompileNgModuleMetadata.prototype, "identifier", {
	          get: function () { return this.type; },
	          enumerable: true,
	          configurable: true
	      });
	      return CompileNgModuleMetadata;
	  }());
	  var TransitiveCompileNgModuleMetadata = (function () {
	      function TransitiveCompileNgModuleMetadata(modules, providers, entryComponents, directives, pipes) {
	          var _this = this;
	          this.modules = modules;
	          this.providers = providers;
	          this.entryComponents = entryComponents;
	          this.directives = directives;
	          this.pipes = pipes;
	          this.directivesSet = new Set();
	          this.pipesSet = new Set();
	          directives.forEach(function (dir) { return _this.directivesSet.add(dir.type.reference); });
	          pipes.forEach(function (pipe) { return _this.pipesSet.add(pipe.type.reference); });
	      }
	      return TransitiveCompileNgModuleMetadata;
	  }());
	  function removeIdentifierDuplicates(items) {
	      var map = new Map();
	      items.forEach(function (item) {
	          if (!map.get(item.identifier.reference)) {
	              map.set(item.identifier.reference, item);
	          }
	      });
	      return MapWrapper.values(map);
	  }
	  function _normalizeArray(obj) {
	      return obj || [];
	  }
	  function isStaticSymbol(value) {
	      return typeof value === 'object' && value !== null && value['name'] && value['filePath'];
	  }
	  var ProviderMeta = (function () {
	      function ProviderMeta(token, _a) {
	          var useClass = _a.useClass, useValue = _a.useValue, useExisting = _a.useExisting, useFactory = _a.useFactory, deps = _a.deps, multi = _a.multi;
	          this.token = token;
	          this.useClass = useClass;
	          this.useValue = useValue;
	          this.useExisting = useExisting;
	          this.useFactory = useFactory;
	          this.dependencies = deps;
	          this.multi = !!multi;
	      }
	      return ProviderMeta;
	  }());

	  /**
	   * @license
	   * Copyright Google Inc. All Rights Reserved.
	   *
	   * Use of this source code is governed by an MIT-style license that can be
	   * found in the LICENSE file at https://angular.io/license
	   */
	  var $EOF = 0;
	  var $TAB = 9;
	  var $LF = 10;
	  var $VTAB = 11;
	  var $FF = 12;
	  var $CR = 13;
	  var $SPACE = 32;
	  var $BANG = 33;
	  var $DQ = 34;
	  var $HASH = 35;
	  var $$ = 36;
	  var $PERCENT = 37;
	  var $AMPERSAND = 38;
	  var $SQ = 39;
	  var $LPAREN = 40;
	  var $RPAREN = 41;
	  var $STAR = 42;
	  var $PLUS = 43;
	  var $COMMA = 44;
	  var $MINUS = 45;
	  var $PERIOD = 46;
	  var $SLASH = 47;
	  var $COLON = 58;
	  var $SEMICOLON = 59;
	  var $LT = 60;
	  var $EQ = 61;
	  var $GT = 62;
	  var $QUESTION = 63;
	  var $0 = 48;
	  var $9 = 57;
	  var $A = 65;
	  var $E = 69;
	  var $F = 70;
	  var $X = 88;
	  var $Z = 90;
	  var $LBRACKET = 91;
	  var $BACKSLASH = 92;
	  var $RBRACKET = 93;
	  var $CARET = 94;
	  var $_ = 95;
	  var $a = 97;
	  var $e = 101;
	  var $f = 102;
	  var $n = 110;
	  var $r = 114;
	  var $t = 116;
	  var $u = 117;
	  var $v = 118;
	  var $x = 120;
	  var $z = 122;
	  var $LBRACE = 123;
	  var $BAR = 124;
	  var $RBRACE = 125;
	  var $NBSP = 160;
	  var $BT = 96;
	  function isWhitespace(code) {
	      return (code >= $TAB && code <= $SPACE) || (code == $NBSP);
	  }
	  function isDigit(code) {
	      return $0 <= code && code <= $9;
	  }
	  function isAsciiLetter(code) {
	      return code >= $a && code <= $z || code >= $A && code <= $Z;
	  }
	  function isAsciiHexDigit(code) {
	      return code >= $a && code <= $f || code >= $A && code <= $F || isDigit(code);
	  }

	  function assertArrayOfStrings(identifier, value) {
	      if (!_angular_core.isDevMode() || isBlank(value)) {
	          return;
	      }
	      if (!Array.isArray(value)) {
	          throw new Error("Expected '" + identifier + "' to be an array of strings.");
	      }
	      for (var i = 0; i < value.length; i += 1) {
	          if (typeof value[i] !== 'string') {
	              throw new Error("Expected '" + identifier + "' to be an array of strings.");
	          }
	      }
	  }
	  var INTERPOLATION_BLACKLIST_REGEXPS = [
	      /^\s*$/,
	      /[<>]/,
	      /^[{}]$/,
	      /&(#|[a-z])/i,
	      /^\/\//,
	  ];
	  function assertInterpolationSymbols(identifier, value) {
	      if (isPresent(value) && !(Array.isArray(value) && value.length == 2)) {
	          throw new Error("Expected '" + identifier + "' to be an array, [start, end].");
	      }
	      else if (_angular_core.isDevMode() && !isBlank(value)) {
	          var start_1 = value[0];
	          var end_1 = value[1];
	          // black list checking
	          INTERPOLATION_BLACKLIST_REGEXPS.forEach(function (regexp) {
	              if (regexp.test(start_1) || regexp.test(end_1)) {
	                  throw new Error("['" + start_1 + "', '" + end_1 + "'] contains unusable interpolation symbol.");
	              }
	          });
	      }
	  }

	  var InterpolationConfig = (function () {
	      function InterpolationConfig(start, end) {
	          this.start = start;
	          this.end = end;
	      }
	      InterpolationConfig.fromArray = function (markers) {
	          if (!markers) {
	              return DEFAULT_INTERPOLATION_CONFIG;
	          }
	          assertInterpolationSymbols('interpolation', markers);
	          return new InterpolationConfig(markers[0], markers[1]);
	      };
	      ;
	      return InterpolationConfig;
	  }());
	  var DEFAULT_INTERPOLATION_CONFIG = new InterpolationConfig('{{', '}}');

	  /**
	   * @license
	   * Copyright Google Inc. All Rights Reserved.
	   *
	   * Use of this source code is governed by an MIT-style license that can be
	   * found in the LICENSE file at https://angular.io/license
	   */
	  var __extends$2 = (this && this.__extends) || function (d, b) {
	      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	      function __() { this.constructor = d; }
	      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	  };
	  var ParserError = (function () {
	      function ParserError(message, input, errLocation, ctxLocation) {
	          this.input = input;
	          this.errLocation = errLocation;
	          this.ctxLocation = ctxLocation;
	          this.message = "Parser Error: " + message + " " + errLocation + " [" + input + "] in " + ctxLocation;
	      }
	      return ParserError;
	  }());
	  var ParseSpan = (function () {
	      function ParseSpan(start, end) {
	          this.start = start;
	          this.end = end;
	      }
	      return ParseSpan;
	  }());
	  var AST = (function () {
	      function AST(span) {
	          this.span = span;
	      }
	      AST.prototype.visit = function (visitor, context) {
	          if (context === void 0) { context = null; }
	          return null;
	      };
	      AST.prototype.toString = function () { return 'AST'; };
	      return AST;
	  }());
	  /**
	   * Represents a quoted expression of the form:
	   *
	   * quote = prefix `:` uninterpretedExpression
	   * prefix = identifier
	   * uninterpretedExpression = arbitrary string
	   *
	   * A quoted expression is meant to be pre-processed by an AST transformer that
	   * converts it into another AST that no longer contains quoted expressions.
	   * It is meant to allow third-party developers to extend Angular template
	   * expression language. The `uninterpretedExpression` part of the quote is
	   * therefore not interpreted by the Angular's own expression parser.
	   */
	  var Quote = (function (_super) {
	      __extends$2(Quote, _super);
	      function Quote(span, prefix, uninterpretedExpression, location) {
	          _super.call(this, span);
	          this.prefix = prefix;
	          this.uninterpretedExpression = uninterpretedExpression;
	          this.location = location;
	      }
	      Quote.prototype.visit = function (visitor, context) {
	          if (context === void 0) { context = null; }
	          return visitor.visitQuote(this, context);
	      };
	      Quote.prototype.toString = function () { return 'Quote'; };
	      return Quote;
	  }(AST));
	  var EmptyExpr = (function (_super) {
	      __extends$2(EmptyExpr, _super);
	      function EmptyExpr() {
	          _super.apply(this, arguments);
	      }
	      EmptyExpr.prototype.visit = function (visitor, context) {
	          if (context === void 0) { context = null; }
	          // do nothing
	      };
	      return EmptyExpr;
	  }(AST));
	  var ImplicitReceiver = (function (_super) {
	      __extends$2(ImplicitReceiver, _super);
	      function ImplicitReceiver() {
	          _super.apply(this, arguments);
	      }
	      ImplicitReceiver.prototype.visit = function (visitor, context) {
	          if (context === void 0) { context = null; }
	          return visitor.visitImplicitReceiver(this, context);
	      };
	      return ImplicitReceiver;
	  }(AST));
	  /**
	   * Multiple expressions separated by a semicolon.
	   */
	  var Chain = (function (_super) {
	      __extends$2(Chain, _super);
	      function Chain(span, expressions) {
	          _super.call(this, span);
	          this.expressions = expressions;
	      }
	      Chain.prototype.visit = function (visitor, context) {
	          if (context === void 0) { context = null; }
	          return visitor.visitChain(this, context);
	      };
	      return Chain;
	  }(AST));
	  var Conditional = (function (_super) {
	      __extends$2(Conditional, _super);
	      function Conditional(span, condition, trueExp, falseExp) {
	          _super.call(this, span);
	          this.condition = condition;
	          this.trueExp = trueExp;
	          this.falseExp = falseExp;
	      }
	      Conditional.prototype.visit = function (visitor, context) {
	          if (context === void 0) { context = null; }
	          return visitor.visitConditional(this, context);
	      };
	      return Conditional;
	  }(AST));
	  var PropertyRead = (function (_super) {
	      __extends$2(PropertyRead, _super);
	      function PropertyRead(span, receiver, name) {
	          _super.call(this, span);
	          this.receiver = receiver;
	          this.name = name;
	      }
	      PropertyRead.prototype.visit = function (visitor, context) {
	          if (context === void 0) { context = null; }
	          return visitor.visitPropertyRead(this, context);
	      };
	      return PropertyRead;
	  }(AST));
	  var PropertyWrite = (function (_super) {
	      __extends$2(PropertyWrite, _super);
	      function PropertyWrite(span, receiver, name, value) {
	          _super.call(this, span);
	          this.receiver = receiver;
	          this.name = name;
	          this.value = value;
	      }
	      PropertyWrite.prototype.visit = function (visitor, context) {
	          if (context === void 0) { context = null; }
	          return visitor.visitPropertyWrite(this, context);
	      };
	      return PropertyWrite;
	  }(AST));
	  var SafePropertyRead = (function (_super) {
	      __extends$2(SafePropertyRead, _super);
	      function SafePropertyRead(span, receiver, name) {
	          _super.call(this, span);
	          this.receiver = receiver;
	          this.name = name;
	      }
	      SafePropertyRead.prototype.visit = function (visitor, context) {
	          if (context === void 0) { context = null; }
	          return visitor.visitSafePropertyRead(this, context);
	      };
	      return SafePropertyRead;
	  }(AST));
	  var KeyedRead = (function (_super) {
	      __extends$2(KeyedRead, _super);
	      function KeyedRead(span, obj, key) {
	          _super.call(this, span);
	          this.obj = obj;
	          this.key = key;
	      }
	      KeyedRead.prototype.visit = function (visitor, context) {
	          if (context === void 0) { context = null; }
	          return visitor.visitKeyedRead(this, context);
	      };
	      return KeyedRead;
	  }(AST));
	  var KeyedWrite = (function (_super) {
	      __extends$2(KeyedWrite, _super);
	      function KeyedWrite(span, obj, key, value) {
	          _super.call(this, span);
	          this.obj = obj;
	          this.key = key;
	          this.value = value;
	      }
	      KeyedWrite.prototype.visit = function (visitor, context) {
	          if (context === void 0) { context = null; }
	          return visitor.visitKeyedWrite(this, context);
	      };
	      return KeyedWrite;
	  }(AST));
	  var BindingPipe = (function (_super) {
	      __extends$2(BindingPipe, _super);
	      function BindingPipe(span, exp, name, args) {
	          _super.call(this, span);
	          this.exp = exp;
	          this.name = name;
	          this.args = args;
	      }
	      BindingPipe.prototype.visit = function (visitor, context) {
	          if (context === void 0) { context = null; }
	          return visitor.visitPipe(this, context);
	      };
	      return BindingPipe;
	  }(AST));
	  var LiteralPrimitive = (function (_super) {
	      __extends$2(LiteralPrimitive, _super);
	      function LiteralPrimitive(span, value) {
	          _super.call(this, span);
	          this.value = value;
	      }
	      LiteralPrimitive.prototype.visit = function (visitor, context) {
	          if (context === void 0) { context = null; }
	          return visitor.visitLiteralPrimitive(this, context);
	      };
	      return LiteralPrimitive;
	  }(AST));
	  var LiteralArray = (function (_super) {
	      __extends$2(LiteralArray, _super);
	      function LiteralArray(span, expressions) {
	          _super.call(this, span);
	          this.expressions = expressions;
	      }
	      LiteralArray.prototype.visit = function (visitor, context) {
	          if (context === void 0) { context = null; }
	          return visitor.visitLiteralArray(this, context);
	      };
	      return LiteralArray;
	  }(AST));
	  var LiteralMap = (function (_super) {
	      __extends$2(LiteralMap, _super);
	      function LiteralMap(span, keys, values) {
	          _super.call(this, span);
	          this.keys = keys;
	          this.values = values;
	      }
	      LiteralMap.prototype.visit = function (visitor, context) {
	          if (context === void 0) { context = null; }
	          return visitor.visitLiteralMap(this, context);
	      };
	      return LiteralMap;
	  }(AST));
	  var Interpolation = (function (_super) {
	      __extends$2(Interpolation, _super);
	      function Interpolation(span, strings, expressions) {
	          _super.call(this, span);
	          this.strings = strings;
	          this.expressions = expressions;
	      }
	      Interpolation.prototype.visit = function (visitor, context) {
	          if (context === void 0) { context = null; }
	          return visitor.visitInterpolation(this, context);
	      };
	      return Interpolation;
	  }(AST));
	  var Binary = (function (_super) {
	      __extends$2(Binary, _super);
	      function Binary(span, operation, left, right) {
	          _super.call(this, span);
	          this.operation = operation;
	          this.left = left;
	          this.right = right;
	      }
	      Binary.prototype.visit = function (visitor, context) {
	          if (context === void 0) { context = null; }
	          return visitor.visitBinary(this, context);
	      };
	      return Binary;
	  }(AST));
	  var PrefixNot = (function (_super) {
	      __extends$2(PrefixNot, _super);
	      function PrefixNot(span, expression) {
	          _super.call(this, span);
	          this.expression = expression;
	      }
	      PrefixNot.prototype.visit = function (visitor, context) {
	          if (context === void 0) { context = null; }
	          return visitor.visitPrefixNot(this, context);
	      };
	      return PrefixNot;
	  }(AST));
	  var MethodCall = (function (_super) {
	      __extends$2(MethodCall, _super);
	      function MethodCall(span, receiver, name, args) {
	          _super.call(this, span);
	          this.receiver = receiver;
	          this.name = name;
	          this.args = args;
	      }
	      MethodCall.prototype.visit = function (visitor, context) {
	          if (context === void 0) { context = null; }
	          return visitor.visitMethodCall(this, context);
	      };
	      return MethodCall;
	  }(AST));
	  var SafeMethodCall = (function (_super) {
	      __extends$2(SafeMethodCall, _super);
	      function SafeMethodCall(span, receiver, name, args) {
	          _super.call(this, span);
	          this.receiver = receiver;
	          this.name = name;
	          this.args = args;
	      }
	      SafeMethodCall.prototype.visit = function (visitor, context) {
	          if (context === void 0) { context = null; }
	          return visitor.visitSafeMethodCall(this, context);
	      };
	      return SafeMethodCall;
	  }(AST));
	  var FunctionCall = (function (_super) {
	      __extends$2(FunctionCall, _super);
	      function FunctionCall(span, target, args) {
	          _super.call(this, span);
	          this.target = target;
	          this.args = args;
	      }
	      FunctionCall.prototype.visit = function (visitor, context) {
	          if (context === void 0) { context = null; }
	          return visitor.visitFunctionCall(this, context);
	      };
	      return FunctionCall;
	  }(AST));
	  var ASTWithSource = (function (_super) {
	      __extends$2(ASTWithSource, _super);
	      function ASTWithSource(ast, source, location, errors) {
	          _super.call(this, new ParseSpan(0, isBlank(source) ? 0 : source.length));
	          this.ast = ast;
	          this.source = source;
	          this.location = location;
	          this.errors = errors;
	      }
	      ASTWithSource.prototype.visit = function (visitor, context) {
	          if (context === void 0) { context = null; }
	          return this.ast.visit(visitor, context);
	      };
	      ASTWithSource.prototype.toString = function () { return this.source + " in " + this.location; };
	      return ASTWithSource;
	  }(AST));
	  var TemplateBinding = (function () {
	      function TemplateBinding(key, keyIsVar, name, expression) {
	          this.key = key;
	          this.keyIsVar = keyIsVar;
	          this.name = name;
	          this.expression = expression;
	      }
	      return TemplateBinding;
	  }());
	  var RecursiveAstVisitor = (function () {
	      function RecursiveAstVisitor() {
	      }
	      RecursiveAstVisitor.prototype.visitBinary = function (ast, context) {
	          ast.left.visit(this);
	          ast.right.visit(this);
	          return null;
	      };
	      RecursiveAstVisitor.prototype.visitChain = function (ast, context) { return this.visitAll(ast.expressions, context); };
	      RecursiveAstVisitor.prototype.visitConditional = function (ast, context) {
	          ast.condition.visit(this);
	          ast.trueExp.visit(this);
	          ast.falseExp.visit(this);
	          return null;
	      };
	      RecursiveAstVisitor.prototype.visitPipe = function (ast, context) {
	          ast.exp.visit(this);
	          this.visitAll(ast.args, context);
	          return null;
	      };
	      RecursiveAstVisitor.prototype.visitFunctionCall = function (ast, context) {
	          ast.target.visit(this);
	          this.visitAll(ast.args, context);
	          return null;
	      };
	      RecursiveAstVisitor.prototype.visitImplicitReceiver = function (ast, context) { return null; };
	      RecursiveAstVisitor.prototype.visitInterpolation = function (ast, context) {
	          return this.visitAll(ast.expressions, context);
	      };
	      RecursiveAstVisitor.prototype.visitKeyedRead = function (ast, context) {
	          ast.obj.visit(this);
	          ast.key.visit(this);
	          return null;
	      };
	      RecursiveAstVisitor.prototype.visitKeyedWrite = function (ast, context) {
	          ast.obj.visit(this);
	          ast.key.visit(this);
	          ast.value.visit(this);
	          return null;
	      };
	      RecursiveAstVisitor.prototype.visitLiteralArray = function (ast, context) {
	          return this.visitAll(ast.expressions, context);
	      };
	      RecursiveAstVisitor.prototype.visitLiteralMap = function (ast, context) { return this.visitAll(ast.values, context); };
	      RecursiveAstVisitor.prototype.visitLiteralPrimitive = function (ast, context) { return null; };
	      RecursiveAstVisitor.prototype.visitMethodCall = function (ast, context) {
	          ast.receiver.visit(this);
	          return this.visitAll(ast.args, context);
	      };
	      RecursiveAstVisitor.prototype.visitPrefixNot = function (ast, context) {
	          ast.expression.visit(this);
	          return null;
	      };
	      RecursiveAstVisitor.prototype.visitPropertyRead = function (ast, context) {
	          ast.receiver.visit(this);
	          return null;
	      };
	      RecursiveAstVisitor.prototype.visitPropertyWrite = function (ast, context) {
	          ast.receiver.visit(this);
	          ast.value.visit(this);
	          return null;
	      };
	      RecursiveAstVisitor.prototype.visitSafePropertyRead = function (ast, context) {
	          ast.receiver.visit(this);
	          return null;
	      };
	      RecursiveAstVisitor.prototype.visitSafeMethodCall = function (ast, context) {
	          ast.receiver.visit(this);
	          return this.visitAll(ast.args, context);
	      };
	      RecursiveAstVisitor.prototype.visitAll = function (asts, context) {
	          var _this = this;
	          asts.forEach(function (ast) { return ast.visit(_this, context); });
	          return null;
	      };
	      RecursiveAstVisitor.prototype.visitQuote = function (ast, context) { return null; };
	      return RecursiveAstVisitor;
	  }());

	  exports.TokenType;
	  (function (TokenType) {
	      TokenType[TokenType["Character"] = 0] = "Character";
	      TokenType[TokenType["Identifier"] = 1] = "Identifier";
	      TokenType[TokenType["Keyword"] = 2] = "Keyword";
	      TokenType[TokenType["String"] = 3] = "String";
	      TokenType[TokenType["Operator"] = 4] = "Operator";
	      TokenType[TokenType["Number"] = 5] = "Number";
	      TokenType[TokenType["Error"] = 6] = "Error";
	  })(exports.TokenType || (exports.TokenType = {}));
	  var KEYWORDS = ['var', 'let', 'null', 'undefined', 'true', 'false', 'if', 'else', 'this'];
	  var Lexer = (function () {
	      function Lexer() {
	      }
	      Lexer.prototype.tokenize = function (text) {
	          var scanner = new _Scanner(text);
	          var tokens = [];
	          var token = scanner.scanToken();
	          while (token != null) {
	              tokens.push(token);
	              token = scanner.scanToken();
	          }
	          return tokens;
	      };
	      Lexer.decorators = [
	          { type: _angular_core.Injectable },
	      ];
	      /** @nocollapse */
	      Lexer.ctorParameters = [];
	      return Lexer;
	  }());
	  var Token = (function () {
	      function Token(index, type, numValue, strValue) {
	          this.index = index;
	          this.type = type;
	          this.numValue = numValue;
	          this.strValue = strValue;
	      }
	      Token.prototype.isCharacter = function (code) {
	          return this.type == exports.TokenType.Character && this.numValue == code;
	      };
	      Token.prototype.isNumber = function () { return this.type == exports.TokenType.Number; };
	      Token.prototype.isString = function () { return this.type == exports.TokenType.String; };
	      Token.prototype.isOperator = function (operater) {
	          return this.type == exports.TokenType.Operator && this.strValue == operater;
	      };
	      Token.prototype.isIdentifier = function () { return this.type == exports.TokenType.Identifier; };
	      Token.prototype.isKeyword = function () { return this.type == exports.TokenType.Keyword; };
	      Token.prototype.isKeywordLet = function () { return this.type == exports.TokenType.Keyword && this.strValue == 'let'; };
	      Token.prototype.isKeywordNull = function () { return this.type == exports.TokenType.Keyword && this.strValue == 'null'; };
	      Token.prototype.isKeywordUndefined = function () {
	          return this.type == exports.TokenType.Keyword && this.strValue == 'undefined';
	      };
	      Token.prototype.isKeywordTrue = function () { return this.type == exports.TokenType.Keyword && this.strValue == 'true'; };
	      Token.prototype.isKeywordFalse = function () { return this.type == exports.TokenType.Keyword && this.strValue == 'false'; };
	      Token.prototype.isKeywordThis = function () { return this.type == exports.TokenType.Keyword && this.strValue == 'this'; };
	      Token.prototype.isError = function () { return this.type == exports.TokenType.Error; };
	      Token.prototype.toNumber = function () { return this.type == exports.TokenType.Number ? this.numValue : -1; };
	      Token.prototype.toString = function () {
	          switch (this.type) {
	              case exports.TokenType.Character:
	              case exports.TokenType.Identifier:
	              case exports.TokenType.Keyword:
	              case exports.TokenType.Operator:
	              case exports.TokenType.String:
	              case exports.TokenType.Error:
	                  return this.strValue;
	              case exports.TokenType.Number:
	                  return this.numValue.toString();
	              default:
	                  return null;
	          }
	      };
	      return Token;
	  }());
	  function newCharacterToken(index, code) {
	      return new Token(index, exports.TokenType.Character, code, String.fromCharCode(code));
	  }
	  function newIdentifierToken(index, text) {
	      return new Token(index, exports.TokenType.Identifier, 0, text);
	  }
	  function newKeywordToken(index, text) {
	      return new Token(index, exports.TokenType.Keyword, 0, text);
	  }
	  function newOperatorToken(index, text) {
	      return new Token(index, exports.TokenType.Operator, 0, text);
	  }
	  function newStringToken(index, text) {
	      return new Token(index, exports.TokenType.String, 0, text);
	  }
	  function newNumberToken(index, n) {
	      return new Token(index, exports.TokenType.Number, n, '');
	  }
	  function newErrorToken(index, message) {
	      return new Token(index, exports.TokenType.Error, 0, message);
	  }
	  var EOF = new Token(-1, exports.TokenType.Character, 0, '');
	  var _Scanner = (function () {
	      function _Scanner(input) {
	          this.input = input;
	          this.peek = 0;
	          this.index = -1;
	          this.length = input.length;
	          this.advance();
	      }
	      _Scanner.prototype.advance = function () {
	          this.peek = ++this.index >= this.length ? $EOF : this.input.charCodeAt(this.index);
	      };
	      _Scanner.prototype.scanToken = function () {
	          var input = this.input, length = this.length, peek = this.peek, index = this.index;
	          // Skip whitespace.
	          while (peek <= $SPACE) {
	              if (++index >= length) {
	                  peek = $EOF;
	                  break;
	              }
	              else {
	                  peek = input.charCodeAt(index);
	              }
	          }
	          this.peek = peek;
	          this.index = index;
	          if (index >= length) {
	              return null;
	          }
	          // Handle identifiers and numbers.
	          if (isIdentifierStart(peek))
	              return this.scanIdentifier();
	          if (isDigit(peek))
	              return this.scanNumber(index);
	          var start = index;
	          switch (peek) {
	              case $PERIOD:
	                  this.advance();
	                  return isDigit(this.peek) ? this.scanNumber(start) :
	                      newCharacterToken(start, $PERIOD);
	              case $LPAREN:
	              case $RPAREN:
	              case $LBRACE:
	              case $RBRACE:
	              case $LBRACKET:
	              case $RBRACKET:
	              case $COMMA:
	              case $COLON:
	              case $SEMICOLON:
	                  return this.scanCharacter(start, peek);
	              case $SQ:
	              case $DQ:
	                  return this.scanString();
	              case $HASH:
	              case $PLUS:
	              case $MINUS:
	              case $STAR:
	              case $SLASH:
	              case $PERCENT:
	              case $CARET:
	                  return this.scanOperator(start, String.fromCharCode(peek));
	              case $QUESTION:
	                  return this.scanComplexOperator(start, '?', $PERIOD, '.');
	              case $LT:
	              case $GT:
	                  return this.scanComplexOperator(start, String.fromCharCode(peek), $EQ, '=');
	              case $BANG:
	              case $EQ:
	                  return this.scanComplexOperator(start, String.fromCharCode(peek), $EQ, '=', $EQ, '=');
	              case $AMPERSAND:
	                  return this.scanComplexOperator(start, '&', $AMPERSAND, '&');
	              case $BAR:
	                  return this.scanComplexOperator(start, '|', $BAR, '|');
	              case $NBSP:
	                  while (isWhitespace(this.peek))
	                      this.advance();
	                  return this.scanToken();
	          }
	          this.advance();
	          return this.error("Unexpected character [" + String.fromCharCode(peek) + "]", 0);
	      };
	      _Scanner.prototype.scanCharacter = function (start, code) {
	          this.advance();
	          return newCharacterToken(start, code);
	      };
	      _Scanner.prototype.scanOperator = function (start, str) {
	          this.advance();
	          return newOperatorToken(start, str);
	      };
	      /**
	       * Tokenize a 2/3 char long operator
	       *
	       * @param start start index in the expression
	       * @param one first symbol (always part of the operator)
	       * @param twoCode code point for the second symbol
	       * @param two second symbol (part of the operator when the second code point matches)
	       * @param threeCode code point for the third symbol
	       * @param three third symbol (part of the operator when provided and matches source expression)
	       * @returns {Token}
	       */
	      _Scanner.prototype.scanComplexOperator = function (start, one, twoCode, two, threeCode, three) {
	          this.advance();
	          var str = one;
	          if (this.peek == twoCode) {
	              this.advance();
	              str += two;
	          }
	          if (isPresent(threeCode) && this.peek == threeCode) {
	              this.advance();
	              str += three;
	          }
	          return newOperatorToken(start, str);
	      };
	      _Scanner.prototype.scanIdentifier = function () {
	          var start = this.index;
	          this.advance();
	          while (isIdentifierPart(this.peek))
	              this.advance();
	          var str = this.input.substring(start, this.index);
	          return KEYWORDS.indexOf(str) > -1 ? newKeywordToken(start, str) :
	              newIdentifierToken(start, str);
	      };
	      _Scanner.prototype.scanNumber = function (start) {
	          var simple = (this.index === start);
	          this.advance(); // Skip initial digit.
	          while (true) {
	              if (isDigit(this.peek)) {
	              }
	              else if (this.peek == $PERIOD) {
	                  simple = false;
	              }
	              else if (isExponentStart(this.peek)) {
	                  this.advance();
	                  if (isExponentSign(this.peek))
	                      this.advance();
	                  if (!isDigit(this.peek))
	                      return this.error('Invalid exponent', -1);
	                  simple = false;
	              }
	              else {
	                  break;
	              }
	              this.advance();
	          }
	          var str = this.input.substring(start, this.index);
	          var value = simple ? NumberWrapper.parseIntAutoRadix(str) : parseFloat(str);
	          return newNumberToken(start, value);
	      };
	      _Scanner.prototype.scanString = function () {
	          var start = this.index;
	          var quote = this.peek;
	          this.advance(); // Skip initial quote.
	          var buffer = '';
	          var marker = this.index;
	          var input = this.input;
	          while (this.peek != quote) {
	              if (this.peek == $BACKSLASH) {
	                  buffer += input.substring(marker, this.index);
	                  this.advance();
	                  var unescapedCode = void 0;
	                  if (this.peek == $u) {
	                      // 4 character hex code for unicode character.
	                      var hex = input.substring(this.index + 1, this.index + 5);
	                      try {
	                          unescapedCode = NumberWrapper.parseInt(hex, 16);
	                      }
	                      catch (e) {
	                          return this.error("Invalid unicode escape [\\u" + hex + "]", 0);
	                      }
	                      for (var i = 0; i < 5; i++) {
	                          this.advance();
	                      }
	                  }
	                  else {
	                      unescapedCode = unescape(this.peek);
	                      this.advance();
	                  }
	                  buffer += String.fromCharCode(unescapedCode);
	                  marker = this.index;
	              }
	              else if (this.peek == $EOF) {
	                  return this.error('Unterminated quote', 0);
	              }
	              else {
	                  this.advance();
	              }
	          }
	          var last = input.substring(marker, this.index);
	          this.advance(); // Skip terminating quote.
	          return newStringToken(start, buffer + last);
	      };
	      _Scanner.prototype.error = function (message, offset) {
	          var position = this.index + offset;
	          return newErrorToken(position, "Lexer Error: " + message + " at column " + position + " in expression [" + this.input + "]");
	      };
	      return _Scanner;
	  }());
	  function isIdentifierStart(code) {
	      return ($a <= code && code <= $z) || ($A <= code && code <= $Z) ||
	          (code == $_) || (code == $$);
	  }
	  function isIdentifier(input) {
	      if (input.length == 0)
	          return false;
	      var scanner = new _Scanner(input);
	      if (!isIdentifierStart(scanner.peek))
	          return false;
	      scanner.advance();
	      while (scanner.peek !== $EOF) {
	          if (!isIdentifierPart(scanner.peek))
	              return false;
	          scanner.advance();
	      }
	      return true;
	  }
	  function isIdentifierPart(code) {
	      return isAsciiLetter(code) || isDigit(code) || (code == $_) ||
	          (code == $$);
	  }
	  function isExponentStart(code) {
	      return code == $e || code == $E;
	  }
	  function isExponentSign(code) {
	      return code == $MINUS || code == $PLUS;
	  }
	  function isQuote(code) {
	      return code === $SQ || code === $DQ || code === $BT;
	  }
	  function unescape(code) {
	      switch (code) {
	          case $n:
	              return $LF;
	          case $f:
	              return $FF;
	          case $r:
	              return $CR;
	          case $t:
	              return $TAB;
	          case $v:
	              return $VTAB;
	          default:
	              return code;
	      }
	  }

	  var SplitInterpolation = (function () {
	      function SplitInterpolation(strings, expressions, offsets) {
	          this.strings = strings;
	          this.expressions = expressions;
	          this.offsets = offsets;
	      }
	      return SplitInterpolation;
	  }());
	  var TemplateBindingParseResult = (function () {
	      function TemplateBindingParseResult(templateBindings, warnings, errors) {
	          this.templateBindings = templateBindings;
	          this.warnings = warnings;
	          this.errors = errors;
	      }
	      return TemplateBindingParseResult;
	  }());
	  function _createInterpolateRegExp(config) {
	      var pattern = escapeRegExp(config.start) + '([\\s\\S]*?)' + escapeRegExp(config.end);
	      return new RegExp(pattern, 'g');
	  }
	  var Parser = (function () {
	      function Parser(_lexer) {
	          this._lexer = _lexer;
	          this.errors = [];
	      }
	      Parser.prototype.parseAction = function (input, location, interpolationConfig) {
	          if (interpolationConfig === void 0) { interpolationConfig = DEFAULT_INTERPOLATION_CONFIG; }
	          this._checkNoInterpolation(input, location, interpolationConfig);
	          var sourceToLex = this._stripComments(input);
	          var tokens = this._lexer.tokenize(this._stripComments(input));
	          var ast = new _ParseAST(input, location, tokens, sourceToLex.length, true, this.errors, input.length - sourceToLex.length)
	              .parseChain();
	          return new ASTWithSource(ast, input, location, this.errors);
	      };
	      Parser.prototype.parseBinding = function (input, location, interpolationConfig) {
	          if (interpolationConfig === void 0) { interpolationConfig = DEFAULT_INTERPOLATION_CONFIG; }
	          var ast = this._parseBindingAst(input, location, interpolationConfig);
	          return new ASTWithSource(ast, input, location, this.errors);
	      };
	      Parser.prototype.parseSimpleBinding = function (input, location, interpolationConfig) {
	          if (interpolationConfig === void 0) { interpolationConfig = DEFAULT_INTERPOLATION_CONFIG; }
	          var ast = this._parseBindingAst(input, location, interpolationConfig);
	          var errors = SimpleExpressionChecker.check(ast);
	          if (errors.length > 0) {
	              this._reportError("Host binding expression cannot contain " + errors.join(' '), input, location);
	          }
	          return new ASTWithSource(ast, input, location, this.errors);
	      };
	      Parser.prototype._reportError = function (message, input, errLocation, ctxLocation) {
	          this.errors.push(new ParserError(message, input, errLocation, ctxLocation));
	      };
	      Parser.prototype._parseBindingAst = function (input, location, interpolationConfig) {
	          // Quotes expressions use 3rd-party expression language. We don't want to use
	          // our lexer or parser for that, so we check for that ahead of time.
	          var quote = this._parseQuote(input, location);
	          if (isPresent(quote)) {
	              return quote;
	          }
	          this._checkNoInterpolation(input, location, interpolationConfig);
	          var sourceToLex = this._stripComments(input);
	          var tokens = this._lexer.tokenize(sourceToLex);
	          return new _ParseAST(input, location, tokens, sourceToLex.length, false, this.errors, input.length - sourceToLex.length)
	              .parseChain();
	      };
	      Parser.prototype._parseQuote = function (input, location) {
	          if (isBlank(input))
	              return null;
	          var prefixSeparatorIndex = input.indexOf(':');
	          if (prefixSeparatorIndex == -1)
	              return null;
	          var prefix = input.substring(0, prefixSeparatorIndex).trim();
	          if (!isIdentifier(prefix))
	              return null;
	          var uninterpretedExpression = input.substring(prefixSeparatorIndex + 1);
	          return new Quote(new ParseSpan(0, input.length), prefix, uninterpretedExpression, location);
	      };
	      Parser.prototype.parseTemplateBindings = function (input, location) {
	          var tokens = this._lexer.tokenize(input);
	          return new _ParseAST(input, location, tokens, input.length, false, this.errors, 0)
	              .parseTemplateBindings();
	      };
	      Parser.prototype.parseInterpolation = function (input, location, interpolationConfig) {
	          if (interpolationConfig === void 0) { interpolationConfig = DEFAULT_INTERPOLATION_CONFIG; }
	          var split = this.splitInterpolation(input, location, interpolationConfig);
	          if (split == null)
	              return null;
	          var expressions = [];
	          for (var i = 0; i < split.expressions.length; ++i) {
	              var expressionText = split.expressions[i];
	              var sourceToLex = this._stripComments(expressionText);
	              var tokens = this._lexer.tokenize(this._stripComments(split.expressions[i]));
	              var ast = new _ParseAST(input, location, tokens, sourceToLex.length, false, this.errors, split.offsets[i] + (expressionText.length - sourceToLex.length))
	                  .parseChain();
	              expressions.push(ast);
	          }
	          return new ASTWithSource(new Interpolation(new ParseSpan(0, isBlank(input) ? 0 : input.length), split.strings, expressions), input, location, this.errors);
	      };
	      Parser.prototype.splitInterpolation = function (input, location, interpolationConfig) {
	          if (interpolationConfig === void 0) { interpolationConfig = DEFAULT_INTERPOLATION_CONFIG; }
	          var regexp = _createInterpolateRegExp(interpolationConfig);
	          var parts = input.split(regexp);
	          if (parts.length <= 1) {
	              return null;
	          }
	          var strings = [];
	          var expressions = [];
	          var offsets = [];
	          var offset = 0;
	          for (var i = 0; i < parts.length; i++) {
	              var part = parts[i];
	              if (i % 2 === 0) {
	                  // fixed string
	                  strings.push(part);
	                  offset += part.length;
	              }
	              else if (part.trim().length > 0) {
	                  offset += interpolationConfig.start.length;
	                  expressions.push(part);
	                  offsets.push(offset);
	                  offset += part.length + interpolationConfig.end.length;
	              }
	              else {
	                  this._reportError('Blank expressions are not allowed in interpolated strings', input, "at column " + this._findInterpolationErrorColumn(parts, i, interpolationConfig) + " in", location);
	              }
	          }
	          return new SplitInterpolation(strings, expressions, offsets);
	      };
	      Parser.prototype.wrapLiteralPrimitive = function (input, location) {
	          return new ASTWithSource(new LiteralPrimitive(new ParseSpan(0, isBlank(input) ? 0 : input.length), input), input, location, this.errors);
	      };
	      Parser.prototype._stripComments = function (input) {
	          var i = this._commentStart(input);
	          return isPresent(i) ? input.substring(0, i).trim() : input;
	      };
	      Parser.prototype._commentStart = function (input) {
	          var outerQuote = null;
	          for (var i = 0; i < input.length - 1; i++) {
	              var char = input.charCodeAt(i);
	              var nextChar = input.charCodeAt(i + 1);
	              if (char === $SLASH && nextChar == $SLASH && isBlank(outerQuote))
	                  return i;
	              if (outerQuote === char) {
	                  outerQuote = null;
	              }
	              else if (isBlank(outerQuote) && isQuote(char)) {
	                  outerQuote = char;
	              }
	          }
	          return null;
	      };
	      Parser.prototype._checkNoInterpolation = function (input, location, interpolationConfig) {
	          var regexp = _createInterpolateRegExp(interpolationConfig);
	          var parts = input.split(regexp);
	          if (parts.length > 1) {
	              this._reportError("Got interpolation (" + interpolationConfig.start + interpolationConfig.end + ") where expression was expected", input, "at column " + this._findInterpolationErrorColumn(parts, 1, interpolationConfig) + " in", location);
	          }
	      };
	      Parser.prototype._findInterpolationErrorColumn = function (parts, partInErrIdx, interpolationConfig) {
	          var errLocation = '';
	          for (var j = 0; j < partInErrIdx; j++) {
	              errLocation += j % 2 === 0 ?
	                  parts[j] :
	                  "" + interpolationConfig.start + parts[j] + interpolationConfig.end;
	          }
	          return errLocation.length;
	      };
	      Parser.decorators = [
	          { type: _angular_core.Injectable },
	      ];
	      /** @nocollapse */
	      Parser.ctorParameters = [
	          { type: Lexer, },
	      ];
	      return Parser;
	  }());
	  var _ParseAST = (function () {
	      function _ParseAST(input, location, tokens, inputLength, parseAction, errors, offset) {
	          this.input = input;
	          this.location = location;
	          this.tokens = tokens;
	          this.inputLength = inputLength;
	          this.parseAction = parseAction;
	          this.errors = errors;
	          this.offset = offset;
	          this.rparensExpected = 0;
	          this.rbracketsExpected = 0;
	          this.rbracesExpected = 0;
	          this.index = 0;
	      }
	      _ParseAST.prototype.peek = function (offset) {
	          var i = this.index + offset;
	          return i < this.tokens.length ? this.tokens[i] : EOF;
	      };
	      Object.defineProperty(_ParseAST.prototype, "next", {
	          get: function () { return this.peek(0); },
	          enumerable: true,
	          configurable: true
	      });
	      Object.defineProperty(_ParseAST.prototype, "inputIndex", {
	          get: function () {
	              return (this.index < this.tokens.length) ? this.next.index + this.offset :
	                  this.inputLength + this.offset;
	          },
	          enumerable: true,
	          configurable: true
	      });
	      _ParseAST.prototype.span = function (start) { return new ParseSpan(start, this.inputIndex); };
	      _ParseAST.prototype.advance = function () { this.index++; };
	      _ParseAST.prototype.optionalCharacter = function (code) {
	          if (this.next.isCharacter(code)) {
	              this.advance();
	              return true;
	          }
	          else {
	              return false;
	          }
	      };
	      _ParseAST.prototype.peekKeywordLet = function () { return this.next.isKeywordLet(); };
	      _ParseAST.prototype.expectCharacter = function (code) {
	          if (this.optionalCharacter(code))
	              return;
	          this.error("Missing expected " + String.fromCharCode(code));
	      };
	      _ParseAST.prototype.optionalOperator = function (op) {
	          if (this.next.isOperator(op)) {
	              this.advance();
	              return true;
	          }
	          else {
	              return false;
	          }
	      };
	      _ParseAST.prototype.expectOperator = function (operator) {
	          if (this.optionalOperator(operator))
	              return;
	          this.error("Missing expected operator " + operator);
	      };
	      _ParseAST.prototype.expectIdentifierOrKeyword = function () {
	          var n = this.next;
	          if (!n.isIdentifier() && !n.isKeyword()) {
	              this.error("Unexpected token " + n + ", expected identifier or keyword");
	              return '';
	          }
	          this.advance();
	          return n.toString();
	      };
	      _ParseAST.prototype.expectIdentifierOrKeywordOrString = function () {
	          var n = this.next;
	          if (!n.isIdentifier() && !n.isKeyword() && !n.isString()) {
	              this.error("Unexpected token " + n + ", expected identifier, keyword, or string");
	              return '';
	          }
	          this.advance();
	          return n.toString();
	      };
	      _ParseAST.prototype.parseChain = function () {
	          var exprs = [];
	          var start = this.inputIndex;
	          while (this.index < this.tokens.length) {
	              var expr = this.parsePipe();
	              exprs.push(expr);
	              if (this.optionalCharacter($SEMICOLON)) {
	                  if (!this.parseAction) {
	                      this.error('Binding expression cannot contain chained expression');
	                  }
	                  while (this.optionalCharacter($SEMICOLON)) {
	                  } // read all semicolons
	              }
	              else if (this.index < this.tokens.length) {
	                  this.error("Unexpected token '" + this.next + "'");
	              }
	          }
	          if (exprs.length == 0)
	              return new EmptyExpr(this.span(start));
	          if (exprs.length == 1)
	              return exprs[0];
	          return new Chain(this.span(start), exprs);
	      };
	      _ParseAST.prototype.parsePipe = function () {
	          var result = this.parseExpression();
	          if (this.optionalOperator('|')) {
	              if (this.parseAction) {
	                  this.error('Cannot have a pipe in an action expression');
	              }
	              do {
	                  var name = this.expectIdentifierOrKeyword();
	                  var args = [];
	                  while (this.optionalCharacter($COLON)) {
	                      args.push(this.parseExpression());
	                  }
	                  result = new BindingPipe(this.span(result.span.start - this.offset), result, name, args);
	              } while (this.optionalOperator('|'));
	          }
	          return result;
	      };
	      _ParseAST.prototype.parseExpression = function () { return this.parseConditional(); };
	      _ParseAST.prototype.parseConditional = function () {
	          var start = this.inputIndex;
	          var result = this.parseLogicalOr();
	          if (this.optionalOperator('?')) {
	              var yes = this.parsePipe();
	              var no = void 0;
	              if (!this.optionalCharacter($COLON)) {
	                  var end = this.inputIndex;
	                  var expression = this.input.substring(start, end);
	                  this.error("Conditional expression " + expression + " requires all 3 expressions");
	                  no = new EmptyExpr(this.span(start));
	              }
	              else {
	                  no = this.parsePipe();
	              }
	              return new Conditional(this.span(start), result, yes, no);
	          }
	          else {
	              return result;
	          }
	      };
	      _ParseAST.prototype.parseLogicalOr = function () {
	          // '||'
	          var result = this.parseLogicalAnd();
	          while (this.optionalOperator('||')) {
	              var right = this.parseLogicalAnd();
	              result = new Binary(this.span(result.span.start), '||', result, right);
	          }
	          return result;
	      };
	      _ParseAST.prototype.parseLogicalAnd = function () {
	          // '&&'
	          var result = this.parseEquality();
	          while (this.optionalOperator('&&')) {
	              var right = this.parseEquality();
	              result = new Binary(this.span(result.span.start), '&&', result, right);
	          }
	          return result;
	      };
	      _ParseAST.prototype.parseEquality = function () {
	          // '==','!=','===','!=='
	          var result = this.parseRelational();
	          while (this.next.type == exports.TokenType.Operator) {
	              var operator = this.next.strValue;
	              switch (operator) {
	                  case '==':
	                  case '===':
	                  case '!=':
	                  case '!==':
	                      this.advance();
	                      var right = this.parseRelational();
	                      result = new Binary(this.span(result.span.start), operator, result, right);
	                      continue;
	              }
	              break;
	          }
	          return result;
	      };
	      _ParseAST.prototype.parseRelational = function () {
	          // '<', '>', '<=', '>='
	          var result = this.parseAdditive();
	          while (this.next.type == exports.TokenType.Operator) {
	              var operator = this.next.strValue;
	              switch (operator) {
	                  case '<':
	                  case '>':
	                  case '<=':
	                  case '>=':
	                      this.advance();
	                      var right = this.parseAdditive();
	                      result = new Binary(this.span(result.span.start), operator, result, right);
	                      continue;
	              }
	              break;
	          }
	          return result;
	      };
	      _ParseAST.prototype.parseAdditive = function () {
	          // '+', '-'
	          var result = this.parseMultiplicative();
	          while (this.next.type == exports.TokenType.Operator) {
	              var operator = this.next.strValue;
	              switch (operator) {
	                  case '+':
	                  case '-':
	                      this.advance();
	                      var right = this.parseMultiplicative();
	                      result = new Binary(this.span(result.span.start), operator, result, right);
	                      continue;
	              }
	              break;
	          }
	          return result;
	      };
	      _ParseAST.prototype.parseMultiplicative = function () {
	          // '*', '%', '/'
	          var result = this.parsePrefix();
	          while (this.next.type == exports.TokenType.Operator) {
	              var operator = this.next.strValue;
	              switch (operator) {
	                  case '*':
	                  case '%':
	                  case '/':
	                      this.advance();
	                      var right = this.parsePrefix();
	                      result = new Binary(this.span(result.span.start), operator, result, right);
	                      continue;
	              }
	              break;
	          }
	          return result;
	      };
	      _ParseAST.prototype.parsePrefix = function () {
	          if (this.next.type == exports.TokenType.Operator) {
	              var start = this.inputIndex;
	              var operator = this.next.strValue;
	              var result = void 0;
	              switch (operator) {
	                  case '+':
	                      this.advance();
	                      return this.parsePrefix();
	                  case '-':
	                      this.advance();
	                      result = this.parsePrefix();
	                      return new Binary(this.span(start), operator, new LiteralPrimitive(new ParseSpan(start, start), 0), result);
	                  case '!':
	                      this.advance();
	                      result = this.parsePrefix();
	                      return new PrefixNot(this.span(start), result);
	              }
	          }
	          return this.parseCallChain();
	      };
	      _ParseAST.prototype.parseCallChain = function () {
	          var result = this.parsePrimary();
	          while (true) {
	              if (this.optionalCharacter($PERIOD)) {
	                  result = this.parseAccessMemberOrMethodCall(result, false);
	              }
	              else if (this.optionalOperator('?.')) {
	                  result = this.parseAccessMemberOrMethodCall(result, true);
	              }
	              else if (this.optionalCharacter($LBRACKET)) {
	                  this.rbracketsExpected++;
	                  var key = this.parsePipe();
	                  this.rbracketsExpected--;
	                  this.expectCharacter($RBRACKET);
	                  if (this.optionalOperator('=')) {
	                      var value = this.parseConditional();
	                      result = new KeyedWrite(this.span(result.span.start), result, key, value);
	                  }
	                  else {
	                      result = new KeyedRead(this.span(result.span.start), result, key);
	                  }
	              }
	              else if (this.optionalCharacter($LPAREN)) {
	                  this.rparensExpected++;
	                  var args = this.parseCallArguments();
	                  this.rparensExpected--;
	                  this.expectCharacter($RPAREN);
	                  result = new FunctionCall(this.span(result.span.start), result, args);
	              }
	              else {
	                  return result;
	              }
	          }
	      };
	      _ParseAST.prototype.parsePrimary = function () {
	          var start = this.inputIndex;
	          if (this.optionalCharacter($LPAREN)) {
	              this.rparensExpected++;
	              var result = this.parsePipe();
	              this.rparensExpected--;
	              this.expectCharacter($RPAREN);
	              return result;
	          }
	          else if (this.next.isKeywordNull()) {
	              this.advance();
	              return new LiteralPrimitive(this.span(start), null);
	          }
	          else if (this.next.isKeywordUndefined()) {
	              this.advance();
	              return new LiteralPrimitive(this.span(start), void 0);
	          }
	          else if (this.next.isKeywordTrue()) {
	              this.advance();
	              return new LiteralPrimitive(this.span(start), true);
	          }
	          else if (this.next.isKeywordFalse()) {
	              this.advance();
	              return new LiteralPrimitive(this.span(start), false);
	          }
	          else if (this.next.isKeywordThis()) {
	              this.advance();
	              return new ImplicitReceiver(this.span(start));
	          }
	          else if (this.optionalCharacter($LBRACKET)) {
	              this.rbracketsExpected++;
	              var elements = this.parseExpressionList($RBRACKET);
	              this.rbracketsExpected--;
	              this.expectCharacter($RBRACKET);
	              return new LiteralArray(this.span(start), elements);
	          }
	          else if (this.next.isCharacter($LBRACE)) {
	              return this.parseLiteralMap();
	          }
	          else if (this.next.isIdentifier()) {
	              return this.parseAccessMemberOrMethodCall(new ImplicitReceiver(this.span(start)), false);
	          }
	          else if (this.next.isNumber()) {
	              var value = this.next.toNumber();
	              this.advance();
	              return new LiteralPrimitive(this.span(start), value);
	          }
	          else if (this.next.isString()) {
	              var literalValue = this.next.toString();
	              this.advance();
	              return new LiteralPrimitive(this.span(start), literalValue);
	          }
	          else if (this.index >= this.tokens.length) {
	              this.error("Unexpected end of expression: " + this.input);
	              return new EmptyExpr(this.span(start));
	          }
	          else {
	              this.error("Unexpected token " + this.next);
	              return new EmptyExpr(this.span(start));
	          }
	      };
	      _ParseAST.prototype.parseExpressionList = function (terminator) {
	          var result = [];
	          if (!this.next.isCharacter(terminator)) {
	              do {
	                  result.push(this.parsePipe());
	              } while (this.optionalCharacter($COMMA));
	          }
	          return result;
	      };
	      _ParseAST.prototype.parseLiteralMap = function () {
	          var keys = [];
	          var values = [];
	          var start = this.inputIndex;
	          this.expectCharacter($LBRACE);
	          if (!this.optionalCharacter($RBRACE)) {
	              this.rbracesExpected++;
	              do {
	                  var key = this.expectIdentifierOrKeywordOrString();
	                  keys.push(key);
	                  this.expectCharacter($COLON);
	                  values.push(this.parsePipe());
	              } while (this.optionalCharacter($COMMA));
	              this.rbracesExpected--;
	              this.expectCharacter($RBRACE);
	          }
	          return new LiteralMap(this.span(start), keys, values);
	      };
	      _ParseAST.prototype.parseAccessMemberOrMethodCall = function (receiver, isSafe) {
	          if (isSafe === void 0) { isSafe = false; }
	          var start = receiver.span.start;
	          var id = this.expectIdentifierOrKeyword();
	          if (this.optionalCharacter($LPAREN)) {
	              this.rparensExpected++;
	              var args = this.parseCallArguments();
	              this.expectCharacter($RPAREN);
	              this.rparensExpected--;
	              var span = this.span(start);
	              return isSafe ? new SafeMethodCall(span, receiver, id, args) :
	                  new MethodCall(span, receiver, id, args);
	          }
	          else {
	              if (isSafe) {
	                  if (this.optionalOperator('=')) {
	                      this.error('The \'?.\' operator cannot be used in the assignment');
	                      return new EmptyExpr(this.span(start));
	                  }
	                  else {
	                      return new SafePropertyRead(this.span(start), receiver, id);
	                  }
	              }
	              else {
	                  if (this.optionalOperator('=')) {
	                      if (!this.parseAction) {
	                          this.error('Bindings cannot contain assignments');
	                          return new EmptyExpr(this.span(start));
	                      }
	                      var value = this.parseConditional();
	                      return new PropertyWrite(this.span(start), receiver, id, value);
	                  }
	                  else {
	                      return new PropertyRead(this.span(start), receiver, id);
	                  }
	              }
	          }
	      };
	      _ParseAST.prototype.parseCallArguments = function () {
	          if (this.next.isCharacter($RPAREN))
	              return [];
	          var positionals = [];
	          do {
	              positionals.push(this.parsePipe());
	          } while (this.optionalCharacter($COMMA));
	          return positionals;
	      };
	      /**
	       * An identifier, a keyword, a string with an optional `-` inbetween.
	       */
	      _ParseAST.prototype.expectTemplateBindingKey = function () {
	          var result = '';
	          var operatorFound = false;
	          do {
	              result += this.expectIdentifierOrKeywordOrString();
	              operatorFound = this.optionalOperator('-');
	              if (operatorFound) {
	                  result += '-';
	              }
	          } while (operatorFound);
	          return result.toString();
	      };
	      _ParseAST.prototype.parseTemplateBindings = function () {
	          var bindings = [];
	          var prefix = null;
	          var warnings = [];
	          while (this.index < this.tokens.length) {
	              var keyIsVar = this.peekKeywordLet();
	              if (keyIsVar) {
	                  this.advance();
	              }
	              var key = this.expectTemplateBindingKey();
	              if (!keyIsVar) {
	                  if (prefix == null) {
	                      prefix = key;
	                  }
	                  else {
	                      key = prefix + key[0].toUpperCase() + key.substring(1);
	                  }
	              }
	              this.optionalCharacter($COLON);
	              var name = null;
	              var expression = null;
	              if (keyIsVar) {
	                  if (this.optionalOperator('=')) {
	                      name = this.expectTemplateBindingKey();
	                  }
	                  else {
	                      name = '\$implicit';
	                  }
	              }
	              else if (this.next !== EOF && !this.peekKeywordLet()) {
	                  var start = this.inputIndex;
	                  var ast = this.parsePipe();
	                  var source = this.input.substring(start, this.inputIndex);
	                  expression = new ASTWithSource(ast, source, this.location, this.errors);
	              }
	              bindings.push(new TemplateBinding(key, keyIsVar, name, expression));
	              if (!this.optionalCharacter($SEMICOLON)) {
	                  this.optionalCharacter($COMMA);
	              }
	          }
	          return new TemplateBindingParseResult(bindings, warnings, this.errors);
	      };
	      _ParseAST.prototype.error = function (message, index) {
	          if (index === void 0) { index = null; }
	          this.errors.push(new ParserError(message, this.input, this.locationText(index), this.location));
	          this.skip();
	      };
	      _ParseAST.prototype.locationText = function (index) {
	          if (index === void 0) { index = null; }
	          if (isBlank(index))
	              index = this.index;
	          return (index < this.tokens.length) ? "at column " + (this.tokens[index].index + 1) + " in" :
	              "at the end of the expression";
	      };
	      // Error recovery should skip tokens until it encounters a recovery point. skip() treats
	      // the end of input and a ';' as unconditionally a recovery point. It also treats ')',
	      // '}' and ']' as conditional recovery points if one of calling productions is expecting
	      // one of these symbols. This allows skip() to recover from errors such as '(a.) + 1' allowing
	      // more of the AST to be retained (it doesn't skip any tokens as the ')' is retained because
	      // of the '(' begins an '(' <expr> ')' production). The recovery points of grouping symbols
	      // must be conditional as they must be skipped if none of the calling productions are not
	      // expecting the closing token else we will never make progress in the case of an
	      // extraneous group closing symbol (such as a stray ')'). This is not the case for ';' because
	      // parseChain() is always the root production and it expects a ';'.
	      // If a production expects one of these token it increments the corresponding nesting count,
	      // and then decrements it just prior to checking if the token is in the input.
	      _ParseAST.prototype.skip = function () {
	          var n = this.next;
	          while (this.index < this.tokens.length && !n.isCharacter($SEMICOLON) &&
	              (this.rparensExpected <= 0 || !n.isCharacter($RPAREN)) &&
	              (this.rbracesExpected <= 0 || !n.isCharacter($RBRACE)) &&
	              (this.rbracketsExpected <= 0 || !n.isCharacter($RBRACKET))) {
	              if (this.next.isError()) {
	                  this.errors.push(new ParserError(this.next.toString(), this.input, this.locationText(), this.location));
	              }
	              this.advance();
	              n = this.next;
	          }
	      };
	      return _ParseAST;
	  }());
	  var SimpleExpressionChecker = (function () {
	      function SimpleExpressionChecker() {
	          this.errors = [];
	      }
	      SimpleExpressionChecker.check = function (ast) {
	          var s = new SimpleExpressionChecker();
	          ast.visit(s);
	          return s.errors;
	      };
	      SimpleExpressionChecker.prototype.visitImplicitReceiver = function (ast, context) { };
	      SimpleExpressionChecker.prototype.visitInterpolation = function (ast, context) { };
	      SimpleExpressionChecker.prototype.visitLiteralPrimitive = function (ast, context) { };
	      SimpleExpressionChecker.prototype.visitPropertyRead = function (ast, context) { };
	      SimpleExpressionChecker.prototype.visitPropertyWrite = function (ast, context) { };
	      SimpleExpressionChecker.prototype.visitSafePropertyRead = function (ast, context) { };
	      SimpleExpressionChecker.prototype.visitMethodCall = function (ast, context) { };
	      SimpleExpressionChecker.prototype.visitSafeMethodCall = function (ast, context) { };
	      SimpleExpressionChecker.prototype.visitFunctionCall = function (ast, context) { };
	      SimpleExpressionChecker.prototype.visitLiteralArray = function (ast, context) { this.visitAll(ast.expressions); };
	      SimpleExpressionChecker.prototype.visitLiteralMap = function (ast, context) { this.visitAll(ast.values); };
	      SimpleExpressionChecker.prototype.visitBinary = function (ast, context) { };
	      SimpleExpressionChecker.prototype.visitPrefixNot = function (ast, context) { };
	      SimpleExpressionChecker.prototype.visitConditional = function (ast, context) { };
	      SimpleExpressionChecker.prototype.visitPipe = function (ast, context) { this.errors.push('pipes'); };
	      SimpleExpressionChecker.prototype.visitKeyedRead = function (ast, context) { };
	      SimpleExpressionChecker.prototype.visitKeyedWrite = function (ast, context) { };
	      SimpleExpressionChecker.prototype.visitAll = function (asts) {
	          var _this = this;
	          return asts.map(function (node) { return node.visit(_this); });
	      };
	      SimpleExpressionChecker.prototype.visitChain = function (ast, context) { };
	      SimpleExpressionChecker.prototype.visitQuote = function (ast, context) { };
	      return SimpleExpressionChecker;
	  }());

	  var ParseLocation = (function () {
	      function ParseLocation(file, offset, line, col) {
	          this.file = file;
	          this.offset = offset;
	          this.line = line;
	          this.col = col;
	      }
	      ParseLocation.prototype.toString = function () {
	          return isPresent(this.offset) ? this.file.url + "@" + this.line + ":" + this.col : this.file.url;
	      };
	      return ParseLocation;
	  }());
	  var ParseSourceFile = (function () {
	      function ParseSourceFile(content, url) {
	          this.content = content;
	          this.url = url;
	      }
	      return ParseSourceFile;
	  }());
	  var ParseSourceSpan = (function () {
	      function ParseSourceSpan(start, end, details) {
	          if (details === void 0) { details = null; }
	          this.start = start;
	          this.end = end;
	          this.details = details;
	      }
	      ParseSourceSpan.prototype.toString = function () {
	          return this.start.file.content.substring(this.start.offset, this.end.offset);
	      };
	      return ParseSourceSpan;
	  }());
	  exports.ParseErrorLevel;
	  (function (ParseErrorLevel) {
	      ParseErrorLevel[ParseErrorLevel["WARNING"] = 0] = "WARNING";
	      ParseErrorLevel[ParseErrorLevel["FATAL"] = 1] = "FATAL";
	  })(exports.ParseErrorLevel || (exports.ParseErrorLevel = {}));
	  var ParseError = (function () {
	      function ParseError(span, msg, level) {
	          if (level === void 0) { level = exports.ParseErrorLevel.FATAL; }
	          this.span = span;
	          this.msg = msg;
	          this.level = level;
	      }
	      ParseError.prototype.toString = function () {
	          var source = this.span.start.file.content;
	          var ctxStart = this.span.start.offset;
	          var contextStr = '';
	          var details = '';
	          if (isPresent(ctxStart)) {
	              if (ctxStart > source.length - 1) {
	                  ctxStart = source.length - 1;
	              }
	              var ctxEnd = ctxStart;
	              var ctxLen = 0;
	              var ctxLines = 0;
	              while (ctxLen < 100 && ctxStart > 0) {
	                  ctxStart--;
	                  ctxLen++;
	                  if (source[ctxStart] == '\n') {
	                      if (++ctxLines == 3) {
	                          break;
	                      }
	                  }
	              }
	              ctxLen = 0;
	              ctxLines = 0;
	              while (ctxLen < 100 && ctxEnd < source.length - 1) {
	                  ctxEnd++;
	                  ctxLen++;
	                  if (source[ctxEnd] == '\n') {
	                      if (++ctxLines == 3) {
	                          break;
	                      }
	                  }
	              }
	              var context = source.substring(ctxStart, this.span.start.offset) + '[ERROR ->]' +
	                  source.substring(this.span.start.offset, ctxEnd + 1);
	              contextStr = " (\"" + context + "\")";
	          }
	          if (this.span.details) {
	              details = ", " + this.span.details;
	          }
	          return "" + this.msg + contextStr + ": " + this.span.start + details;
	      };
	      return ParseError;
	  }());

	  /**
	   * @license
	   * Copyright Google Inc. All Rights Reserved.
	   *
	   * Use of this source code is governed by an MIT-style license that can be
	   * found in the LICENSE file at https://angular.io/license
	   */
	  var Text = (function () {
	      function Text(value, sourceSpan) {
	          this.value = value;
	          this.sourceSpan = sourceSpan;
	      }
	      Text.prototype.visit = function (visitor, context) { return visitor.visitText(this, context); };
	      return Text;
	  }());
	  var Expansion = (function () {
	      function Expansion(switchValue, type, cases, sourceSpan, switchValueSourceSpan) {
	          this.switchValue = switchValue;
	          this.type = type;
	          this.cases = cases;
	          this.sourceSpan = sourceSpan;
	          this.switchValueSourceSpan = switchValueSourceSpan;
	      }
	      Expansion.prototype.visit = function (visitor, context) { return visitor.visitExpansion(this, context); };
	      return Expansion;
	  }());
	  var ExpansionCase = (function () {
	      function ExpansionCase(value, expression, sourceSpan, valueSourceSpan, expSourceSpan) {
	          this.value = value;
	          this.expression = expression;
	          this.sourceSpan = sourceSpan;
	          this.valueSourceSpan = valueSourceSpan;
	          this.expSourceSpan = expSourceSpan;
	      }
	      ExpansionCase.prototype.visit = function (visitor, context) { return visitor.visitExpansionCase(this, context); };
	      return ExpansionCase;
	  }());
	  var Attribute$1 = (function () {
	      function Attribute(name, value, sourceSpan, valueSpan) {
	          this.name = name;
	          this.value = value;
	          this.sourceSpan = sourceSpan;
	          this.valueSpan = valueSpan;
	      }
	      Attribute.prototype.visit = function (visitor, context) { return visitor.visitAttribute(this, context); };
	      return Attribute;
	  }());
	  var Element = (function () {
	      function Element(name, attrs, children, sourceSpan, startSourceSpan, endSourceSpan) {
	          this.name = name;
	          this.attrs = attrs;
	          this.children = children;
	          this.sourceSpan = sourceSpan;
	          this.startSourceSpan = startSourceSpan;
	          this.endSourceSpan = endSourceSpan;
	      }
	      Element.prototype.visit = function (visitor, context) { return visitor.visitElement(this, context); };
	      return Element;
	  }());
	  var Comment = (function () {
	      function Comment(value, sourceSpan) {
	          this.value = value;
	          this.sourceSpan = sourceSpan;
	      }
	      Comment.prototype.visit = function (visitor, context) { return visitor.visitComment(this, context); };
	      return Comment;
	  }());
	  function visitAll(visitor, nodes, context) {
	      if (context === void 0) { context = null; }
	      var result = [];
	      var visit = visitor.visit ?
	          function (ast) { return visitor.visit(ast, context) || ast.visit(visitor, context); } :
	          function (ast) { return ast.visit(visitor, context); };
	      nodes.forEach(function (ast) {
	          var astResult = visit(ast);
	          if (astResult) {
	              result.push(astResult);
	          }
	      });
	      return result;
	  }

	  /**
	   * @license
	   * Copyright Google Inc. All Rights Reserved.
	   *
	   * Use of this source code is governed by an MIT-style license that can be
	   * found in the LICENSE file at https://angular.io/license
	   */
	  var __extends$4 = (this && this.__extends) || function (d, b) {
	      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	      function __() { this.constructor = d; }
	      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	  };
	  var TokenType$1;
	  (function (TokenType) {
	      TokenType[TokenType["TAG_OPEN_START"] = 0] = "TAG_OPEN_START";
	      TokenType[TokenType["TAG_OPEN_END"] = 1] = "TAG_OPEN_END";
	      TokenType[TokenType["TAG_OPEN_END_VOID"] = 2] = "TAG_OPEN_END_VOID";
	      TokenType[TokenType["TAG_CLOSE"] = 3] = "TAG_CLOSE";
	      TokenType[TokenType["TEXT"] = 4] = "TEXT";
	      TokenType[TokenType["ESCAPABLE_RAW_TEXT"] = 5] = "ESCAPABLE_RAW_TEXT";
	      TokenType[TokenType["RAW_TEXT"] = 6] = "RAW_TEXT";
	      TokenType[TokenType["COMMENT_START"] = 7] = "COMMENT_START";
	      TokenType[TokenType["COMMENT_END"] = 8] = "COMMENT_END";
	      TokenType[TokenType["CDATA_START"] = 9] = "CDATA_START";
	      TokenType[TokenType["CDATA_END"] = 10] = "CDATA_END";
	      TokenType[TokenType["ATTR_NAME"] = 11] = "ATTR_NAME";
	      TokenType[TokenType["ATTR_VALUE"] = 12] = "ATTR_VALUE";
	      TokenType[TokenType["DOC_TYPE"] = 13] = "DOC_TYPE";
	      TokenType[TokenType["EXPANSION_FORM_START"] = 14] = "EXPANSION_FORM_START";
	      TokenType[TokenType["EXPANSION_CASE_VALUE"] = 15] = "EXPANSION_CASE_VALUE";
	      TokenType[TokenType["EXPANSION_CASE_EXP_START"] = 16] = "EXPANSION_CASE_EXP_START";
	      TokenType[TokenType["EXPANSION_CASE_EXP_END"] = 17] = "EXPANSION_CASE_EXP_END";
	      TokenType[TokenType["EXPANSION_FORM_END"] = 18] = "EXPANSION_FORM_END";
	      TokenType[TokenType["EOF"] = 19] = "EOF";
	  })(TokenType$1 || (TokenType$1 = {}));
	  var Token$1 = (function () {
	      function Token(type, parts, sourceSpan) {
	          this.type = type;
	          this.parts = parts;
	          this.sourceSpan = sourceSpan;
	      }
	      return Token;
	  }());
	  var TokenError = (function (_super) {
	      __extends$4(TokenError, _super);
	      function TokenError(errorMsg, tokenType, span) {
	          _super.call(this, span, errorMsg);
	          this.tokenType = tokenType;
	      }
	      return TokenError;
	  }(ParseError));
	  var TokenizeResult = (function () {
	      function TokenizeResult(tokens, errors) {
	          this.tokens = tokens;
	          this.errors = errors;
	      }
	      return TokenizeResult;
	  }());
	  function tokenize(source, url, getTagDefinition, tokenizeExpansionForms, interpolationConfig) {
	      if (tokenizeExpansionForms === void 0) { tokenizeExpansionForms = false; }
	      if (interpolationConfig === void 0) { interpolationConfig = DEFAULT_INTERPOLATION_CONFIG; }
	      return new _Tokenizer(new ParseSourceFile(source, url), getTagDefinition, tokenizeExpansionForms, interpolationConfig)
	          .tokenize();
	  }
	  var _CR_OR_CRLF_REGEXP = /\r\n?/g;
	  function _unexpectedCharacterErrorMsg(charCode) {
	      var char = charCode === $EOF ? 'EOF' : String.fromCharCode(charCode);
	      return "Unexpected character \"" + char + "\"";
	  }
	  function _unknownEntityErrorMsg(entitySrc) {
	      return "Unknown entity \"" + entitySrc + "\" - use the \"&#<decimal>;\" or  \"&#x<hex>;\" syntax";
	  }
	  var _ControlFlowError = (function () {
	      function _ControlFlowError(error) {
	          this.error = error;
	      }
	      return _ControlFlowError;
	  }());
	  // See http://www.w3.org/TR/html51/syntax.html#writing
	  var _Tokenizer = (function () {
	      /**
	       * @param _file The html source
	       * @param _getTagDefinition
	       * @param _tokenizeIcu Whether to tokenize ICU messages (considered as text nodes when false)
	       * @param _interpolationConfig
	       */
	      function _Tokenizer(_file, _getTagDefinition, _tokenizeIcu, _interpolationConfig) {
	          if (_interpolationConfig === void 0) { _interpolationConfig = DEFAULT_INTERPOLATION_CONFIG; }
	          this._file = _file;
	          this._getTagDefinition = _getTagDefinition;
	          this._tokenizeIcu = _tokenizeIcu;
	          this._interpolationConfig = _interpolationConfig;
	          // Note: this is always lowercase!
	          this._peek = -1;
	          this._nextPeek = -1;
	          this._index = -1;
	          this._line = 0;
	          this._column = -1;
	          this._expansionCaseStack = [];
	          this._inInterpolation = false;
	          this.tokens = [];
	          this.errors = [];
	          this._input = _file.content;
	          this._length = _file.content.length;
	          this._advance();
	      }
	      _Tokenizer.prototype._processCarriageReturns = function (content) {
	          // http://www.w3.org/TR/html5/syntax.html#preprocessing-the-input-stream
	          // In order to keep the original position in the source, we can not
	          // pre-process it.
	          // Instead CRs are processed right before instantiating the tokens.
	          return content.replace(_CR_OR_CRLF_REGEXP, '\n');
	      };
	      _Tokenizer.prototype.tokenize = function () {
	          while (this._peek !== $EOF) {
	              var start = this._getLocation();
	              try {
	                  if (this._attemptCharCode($LT)) {
	                      if (this._attemptCharCode($BANG)) {
	                          if (this._attemptCharCode($LBRACKET)) {
	                              this._consumeCdata(start);
	                          }
	                          else if (this._attemptCharCode($MINUS)) {
	                              this._consumeComment(start);
	                          }
	                          else {
	                              this._consumeDocType(start);
	                          }
	                      }
	                      else if (this._attemptCharCode($SLASH)) {
	                          this._consumeTagClose(start);
	                      }
	                      else {
	                          this._consumeTagOpen(start);
	                      }
	                  }
	                  else if (!this._tokenizeIcu || !this._tokenizeExpansionForm()) {
	                      this._consumeText();
	                  }
	              }
	              catch (e) {
	                  if (e instanceof _ControlFlowError) {
	                      this.errors.push(e.error);
	                  }
	                  else {
	                      throw e;
	                  }
	              }
	          }
	          this._beginToken(TokenType$1.EOF);
	          this._endToken([]);
	          return new TokenizeResult(mergeTextTokens(this.tokens), this.errors);
	      };
	      /**
	       * @returns {boolean} whether an ICU token has been created
	       * @internal
	       */
	      _Tokenizer.prototype._tokenizeExpansionForm = function () {
	          if (isExpansionFormStart(this._input, this._index, this._interpolationConfig)) {
	              this._consumeExpansionFormStart();
	              return true;
	          }
	          if (isExpansionCaseStart(this._peek) && this._isInExpansionForm()) {
	              this._consumeExpansionCaseStart();
	              return true;
	          }
	          if (this._peek === $RBRACE) {
	              if (this._isInExpansionCase()) {
	                  this._consumeExpansionCaseEnd();
	                  return true;
	              }
	              if (this._isInExpansionForm()) {
	                  this._consumeExpansionFormEnd();
	                  return true;
	              }
	          }
	          return false;
	      };
	      _Tokenizer.prototype._getLocation = function () {
	          return new ParseLocation(this._file, this._index, this._line, this._column);
	      };
	      _Tokenizer.prototype._getSpan = function (start, end) {
	          if (start === void 0) { start = this._getLocation(); }
	          if (end === void 0) { end = this._getLocation(); }
	          return new ParseSourceSpan(start, end);
	      };
	      _Tokenizer.prototype._beginToken = function (type, start) {
	          if (start === void 0) { start = this._getLocation(); }
	          this._currentTokenStart = start;
	          this._currentTokenType = type;
	      };
	      _Tokenizer.prototype._endToken = function (parts, end) {
	          if (end === void 0) { end = this._getLocation(); }
	          var token = new Token$1(this._currentTokenType, parts, new ParseSourceSpan(this._currentTokenStart, end));
	          this.tokens.push(token);
	          this._currentTokenStart = null;
	          this._currentTokenType = null;
	          return token;
	      };
	      _Tokenizer.prototype._createError = function (msg, span) {
	          if (this._isInExpansionForm()) {
	              msg += " (Do you have an unescaped \"{\" in your template? Use \"{{ '{' }}\") to escape it.)";
	          }
	          var error = new TokenError(msg, this._currentTokenType, span);
	          this._currentTokenStart = null;
	          this._currentTokenType = null;
	          return new _ControlFlowError(error);
	      };
	      _Tokenizer.prototype._advance = function () {
	          if (this._index >= this._length) {
	              throw this._createError(_unexpectedCharacterErrorMsg($EOF), this._getSpan());
	          }
	          if (this._peek === $LF) {
	              this._line++;
	              this._column = 0;
	          }
	          else if (this._peek !== $LF && this._peek !== $CR) {
	              this._column++;
	          }
	          this._index++;
	          this._peek = this._index >= this._length ? $EOF : this._input.charCodeAt(this._index);
	          this._nextPeek =
	              this._index + 1 >= this._length ? $EOF : this._input.charCodeAt(this._index + 1);
	      };
	      _Tokenizer.prototype._attemptCharCode = function (charCode) {
	          if (this._peek === charCode) {
	              this._advance();
	              return true;
	          }
	          return false;
	      };
	      _Tokenizer.prototype._attemptCharCodeCaseInsensitive = function (charCode) {
	          if (compareCharCodeCaseInsensitive(this._peek, charCode)) {
	              this._advance();
	              return true;
	          }
	          return false;
	      };
	      _Tokenizer.prototype._requireCharCode = function (charCode) {
	          var location = this._getLocation();
	          if (!this._attemptCharCode(charCode)) {
	              throw this._createError(_unexpectedCharacterErrorMsg(this._peek), this._getSpan(location, location));
	          }
	      };
	      _Tokenizer.prototype._attemptStr = function (chars) {
	          var len = chars.length;
	          if (this._index + len > this._length) {
	              return false;
	          }
	          var initialPosition = this._savePosition();
	          for (var i = 0; i < len; i++) {
	              if (!this._attemptCharCode(chars.charCodeAt(i))) {
	                  // If attempting to parse the string fails, we want to reset the parser
	                  // to where it was before the attempt
	                  this._restorePosition(initialPosition);
	                  return false;
	              }
	          }
	          return true;
	      };
	      _Tokenizer.prototype._attemptStrCaseInsensitive = function (chars) {
	          for (var i = 0; i < chars.length; i++) {
	              if (!this._attemptCharCodeCaseInsensitive(chars.charCodeAt(i))) {
	                  return false;
	              }
	          }
	          return true;
	      };
	      _Tokenizer.prototype._requireStr = function (chars) {
	          var location = this._getLocation();
	          if (!this._attemptStr(chars)) {
	              throw this._createError(_unexpectedCharacterErrorMsg(this._peek), this._getSpan(location));
	          }
	      };
	      _Tokenizer.prototype._attemptCharCodeUntilFn = function (predicate) {
	          while (!predicate(this._peek)) {
	              this._advance();
	          }
	      };
	      _Tokenizer.prototype._requireCharCodeUntilFn = function (predicate, len) {
	          var start = this._getLocation();
	          this._attemptCharCodeUntilFn(predicate);
	          if (this._index - start.offset < len) {
	              throw this._createError(_unexpectedCharacterErrorMsg(this._peek), this._getSpan(start, start));
	          }
	      };
	      _Tokenizer.prototype._attemptUntilChar = function (char) {
	          while (this._peek !== char) {
	              this._advance();
	          }
	      };
	      _Tokenizer.prototype._readChar = function (decodeEntities) {
	          if (decodeEntities && this._peek === $AMPERSAND) {
	              return this._decodeEntity();
	          }
	          else {
	              var index = this._index;
	              this._advance();
	              return this._input[index];
	          }
	      };
	      _Tokenizer.prototype._decodeEntity = function () {
	          var start = this._getLocation();
	          this._advance();
	          if (this._attemptCharCode($HASH)) {
	              var isHex = this._attemptCharCode($x) || this._attemptCharCode($X);
	              var numberStart = this._getLocation().offset;
	              this._attemptCharCodeUntilFn(isDigitEntityEnd);
	              if (this._peek != $SEMICOLON) {
	                  throw this._createError(_unexpectedCharacterErrorMsg(this._peek), this._getSpan());
	              }
	              this._advance();
	              var strNum = this._input.substring(numberStart, this._index - 1);
	              try {
	                  var charCode = parseInt(strNum, isHex ? 16 : 10);
	                  return String.fromCharCode(charCode);
	              }
	              catch (e) {
	                  var entity = this._input.substring(start.offset + 1, this._index - 1);
	                  throw this._createError(_unknownEntityErrorMsg(entity), this._getSpan(start));
	              }
	          }
	          else {
	              var startPosition = this._savePosition();
	              this._attemptCharCodeUntilFn(isNamedEntityEnd);
	              if (this._peek != $SEMICOLON) {
	                  this._restorePosition(startPosition);
	                  return '&';
	              }
	              this._advance();
	              var name_1 = this._input.substring(start.offset + 1, this._index - 1);
	              var char = NAMED_ENTITIES[name_1];
	              if (!char) {
	                  throw this._createError(_unknownEntityErrorMsg(name_1), this._getSpan(start));
	              }
	              return char;
	          }
	      };
	      _Tokenizer.prototype._consumeRawText = function (decodeEntities, firstCharOfEnd, attemptEndRest) {
	          var tagCloseStart;
	          var textStart = this._getLocation();
	          this._beginToken(decodeEntities ? TokenType$1.ESCAPABLE_RAW_TEXT : TokenType$1.RAW_TEXT, textStart);
	          var parts = [];
	          while (true) {
	              tagCloseStart = this._getLocation();
	              if (this._attemptCharCode(firstCharOfEnd) && attemptEndRest()) {
	                  break;
	              }
	              if (this._index > tagCloseStart.offset) {
	                  // add the characters consumed by the previous if statement to the output
	                  parts.push(this._input.substring(tagCloseStart.offset, this._index));
	              }
	              while (this._peek !== firstCharOfEnd) {
	                  parts.push(this._readChar(decodeEntities));
	              }
	          }
	          return this._endToken([this._processCarriageReturns(parts.join(''))], tagCloseStart);
	      };
	      _Tokenizer.prototype._consumeComment = function (start) {
	          var _this = this;
	          this._beginToken(TokenType$1.COMMENT_START, start);
	          this._requireCharCode($MINUS);
	          this._endToken([]);
	          var textToken = this._consumeRawText(false, $MINUS, function () { return _this._attemptStr('->'); });
	          this._beginToken(TokenType$1.COMMENT_END, textToken.sourceSpan.end);
	          this._endToken([]);
	      };
	      _Tokenizer.prototype._consumeCdata = function (start) {
	          var _this = this;
	          this._beginToken(TokenType$1.CDATA_START, start);
	          this._requireStr('CDATA[');
	          this._endToken([]);
	          var textToken = this._consumeRawText(false, $RBRACKET, function () { return _this._attemptStr(']>'); });
	          this._beginToken(TokenType$1.CDATA_END, textToken.sourceSpan.end);
	          this._endToken([]);
	      };
	      _Tokenizer.prototype._consumeDocType = function (start) {
	          this._beginToken(TokenType$1.DOC_TYPE, start);
	          this._attemptUntilChar($GT);
	          this._advance();
	          this._endToken([this._input.substring(start.offset + 2, this._index - 1)]);
	      };
	      _Tokenizer.prototype._consumePrefixAndName = function () {
	          var nameOrPrefixStart = this._index;
	          var prefix = null;
	          while (this._peek !== $COLON && !isPrefixEnd(this._peek)) {
	              this._advance();
	          }
	          var nameStart;
	          if (this._peek === $COLON) {
	              this._advance();
	              prefix = this._input.substring(nameOrPrefixStart, this._index - 1);
	              nameStart = this._index;
	          }
	          else {
	              nameStart = nameOrPrefixStart;
	          }
	          this._requireCharCodeUntilFn(isNameEnd, this._index === nameStart ? 1 : 0);
	          var name = this._input.substring(nameStart, this._index);
	          return [prefix, name];
	      };
	      _Tokenizer.prototype._consumeTagOpen = function (start) {
	          var savedPos = this._savePosition();
	          var tagName;
	          var lowercaseTagName;
	          try {
	              if (!isAsciiLetter(this._peek)) {
	                  throw this._createError(_unexpectedCharacterErrorMsg(this._peek), this._getSpan());
	              }
	              var nameStart = this._index;
	              this._consumeTagOpenStart(start);
	              tagName = this._input.substring(nameStart, this._index);
	              lowercaseTagName = tagName.toLowerCase();
	              this._attemptCharCodeUntilFn(isNotWhitespace);
	              while (this._peek !== $SLASH && this._peek !== $GT) {
	                  this._consumeAttributeName();
	                  this._attemptCharCodeUntilFn(isNotWhitespace);
	                  if (this._attemptCharCode($EQ)) {
	                      this._attemptCharCodeUntilFn(isNotWhitespace);
	                      this._consumeAttributeValue();
	                  }
	                  this._attemptCharCodeUntilFn(isNotWhitespace);
	              }
	              this._consumeTagOpenEnd();
	          }
	          catch (e) {
	              if (e instanceof _ControlFlowError) {
	                  // When the start tag is invalid, assume we want a "<"
	                  this._restorePosition(savedPos);
	                  // Back to back text tokens are merged at the end
	                  this._beginToken(TokenType$1.TEXT, start);
	                  this._endToken(['<']);
	                  return;
	              }
	              throw e;
	          }
	          var contentTokenType = this._getTagDefinition(tagName).contentType;
	          if (contentTokenType === TagContentType.RAW_TEXT) {
	              this._consumeRawTextWithTagClose(lowercaseTagName, false);
	          }
	          else if (contentTokenType === TagContentType.ESCAPABLE_RAW_TEXT) {
	              this._consumeRawTextWithTagClose(lowercaseTagName, true);
	          }
	      };
	      _Tokenizer.prototype._consumeRawTextWithTagClose = function (lowercaseTagName, decodeEntities) {
	          var _this = this;
	          var textToken = this._consumeRawText(decodeEntities, $LT, function () {
	              if (!_this._attemptCharCode($SLASH))
	                  return false;
	              _this._attemptCharCodeUntilFn(isNotWhitespace);
	              if (!_this._attemptStrCaseInsensitive(lowercaseTagName))
	                  return false;
	              _this._attemptCharCodeUntilFn(isNotWhitespace);
	              return _this._attemptCharCode($GT);
	          });
	          this._beginToken(TokenType$1.TAG_CLOSE, textToken.sourceSpan.end);
	          this._endToken([null, lowercaseTagName]);
	      };
	      _Tokenizer.prototype._consumeTagOpenStart = function (start) {
	          this._beginToken(TokenType$1.TAG_OPEN_START, start);
	          var parts = this._consumePrefixAndName();
	          this._endToken(parts);
	      };
	      _Tokenizer.prototype._consumeAttributeName = function () {
	          this._beginToken(TokenType$1.ATTR_NAME);
	          var prefixAndName = this._consumePrefixAndName();
	          this._endToken(prefixAndName);
	      };
	      _Tokenizer.prototype._consumeAttributeValue = function () {
	          this._beginToken(TokenType$1.ATTR_VALUE);
	          var value;
	          if (this._peek === $SQ || this._peek === $DQ) {
	              var quoteChar = this._peek;
	              this._advance();
	              var parts = [];
	              while (this._peek !== quoteChar) {
	                  parts.push(this._readChar(true));
	              }
	              value = parts.join('');
	              this._advance();
	          }
	          else {
	              var valueStart = this._index;
	              this._requireCharCodeUntilFn(isNameEnd, 1);
	              value = this._input.substring(valueStart, this._index);
	          }
	          this._endToken([this._processCarriageReturns(value)]);
	      };
	      _Tokenizer.prototype._consumeTagOpenEnd = function () {
	          var tokenType = this._attemptCharCode($SLASH) ? TokenType$1.TAG_OPEN_END_VOID : TokenType$1.TAG_OPEN_END;
	          this._beginToken(tokenType);
	          this._requireCharCode($GT);
	          this._endToken([]);
	      };
	      _Tokenizer.prototype._consumeTagClose = function (start) {
	          this._beginToken(TokenType$1.TAG_CLOSE, start);
	          this._attemptCharCodeUntilFn(isNotWhitespace);
	          var prefixAndName = this._consumePrefixAndName();
	          this._attemptCharCodeUntilFn(isNotWhitespace);
	          this._requireCharCode($GT);
	          this._endToken(prefixAndName);
	      };
	      _Tokenizer.prototype._consumeExpansionFormStart = function () {
	          this._beginToken(TokenType$1.EXPANSION_FORM_START, this._getLocation());
	          this._requireCharCode($LBRACE);
	          this._endToken([]);
	          this._expansionCaseStack.push(TokenType$1.EXPANSION_FORM_START);
	          this._beginToken(TokenType$1.RAW_TEXT, this._getLocation());
	          var condition = this._readUntil($COMMA);
	          this._endToken([condition], this._getLocation());
	          this._requireCharCode($COMMA);
	          this._attemptCharCodeUntilFn(isNotWhitespace);
	          this._beginToken(TokenType$1.RAW_TEXT, this._getLocation());
	          var type = this._readUntil($COMMA);
	          this._endToken([type], this._getLocation());
	          this._requireCharCode($COMMA);
	          this._attemptCharCodeUntilFn(isNotWhitespace);
	      };
	      _Tokenizer.prototype._consumeExpansionCaseStart = function () {
	          this._beginToken(TokenType$1.EXPANSION_CASE_VALUE, this._getLocation());
	          var value = this._readUntil($LBRACE).trim();
	          this._endToken([value], this._getLocation());
	          this._attemptCharCodeUntilFn(isNotWhitespace);
	          this._beginToken(TokenType$1.EXPANSION_CASE_EXP_START, this._getLocation());
	          this._requireCharCode($LBRACE);
	          this._endToken([], this._getLocation());
	          this._attemptCharCodeUntilFn(isNotWhitespace);
	          this._expansionCaseStack.push(TokenType$1.EXPANSION_CASE_EXP_START);
	      };
	      _Tokenizer.prototype._consumeExpansionCaseEnd = function () {
	          this._beginToken(TokenType$1.EXPANSION_CASE_EXP_END, this._getLocation());
	          this._requireCharCode($RBRACE);
	          this._endToken([], this._getLocation());
	          this._attemptCharCodeUntilFn(isNotWhitespace);
	          this._expansionCaseStack.pop();
	      };
	      _Tokenizer.prototype._consumeExpansionFormEnd = function () {
	          this._beginToken(TokenType$1.EXPANSION_FORM_END, this._getLocation());
	          this._requireCharCode($RBRACE);
	          this._endToken([]);
	          this._expansionCaseStack.pop();
	      };
	      _Tokenizer.prototype._consumeText = function () {
	          var start = this._getLocation();
	          this._beginToken(TokenType$1.TEXT, start);
	          var parts = [];
	          do {
	              if (this._interpolationConfig && this._attemptStr(this._interpolationConfig.start)) {
	                  parts.push(this._interpolationConfig.start);
	                  this._inInterpolation = true;
	              }
	              else if (this._interpolationConfig && this._attemptStr(this._interpolationConfig.end) &&
	                  this._inInterpolation) {
	                  parts.push(this._interpolationConfig.end);
	                  this._inInterpolation = false;
	              }
	              else {
	                  parts.push(this._readChar(true));
	              }
	          } while (!this._isTextEnd());
	          this._endToken([this._processCarriageReturns(parts.join(''))]);
	      };
	      _Tokenizer.prototype._isTextEnd = function () {
	          if (this._peek === $LT || this._peek === $EOF) {
	              return true;
	          }
	          if (this._tokenizeIcu && !this._inInterpolation) {
	              if (isExpansionFormStart(this._input, this._index, this._interpolationConfig)) {
	                  // start of an expansion form
	                  return true;
	              }
	              if (this._peek === $RBRACE && this._isInExpansionCase()) {
	                  // end of and expansion case
	                  return true;
	              }
	          }
	          return false;
	      };
	      _Tokenizer.prototype._savePosition = function () {
	          return [this._peek, this._index, this._column, this._line, this.tokens.length];
	      };
	      _Tokenizer.prototype._readUntil = function (char) {
	          var start = this._index;
	          this._attemptUntilChar(char);
	          return this._input.substring(start, this._index);
	      };
	      _Tokenizer.prototype._restorePosition = function (position) {
	          this._peek = position[0];
	          this._index = position[1];
	          this._column = position[2];
	          this._line = position[3];
	          var nbTokens = position[4];
	          if (nbTokens < this.tokens.length) {
	              // remove any extra tokens
	              this.tokens = this.tokens.slice(0, nbTokens);
	          }
	      };
	      _Tokenizer.prototype._isInExpansionCase = function () {
	          return this._expansionCaseStack.length > 0 &&
	              this._expansionCaseStack[this._expansionCaseStack.length - 1] ===
	                  TokenType$1.EXPANSION_CASE_EXP_START;
	      };
	      _Tokenizer.prototype._isInExpansionForm = function () {
	          return this._expansionCaseStack.length > 0 &&
	              this._expansionCaseStack[this._expansionCaseStack.length - 1] ===
	                  TokenType$1.EXPANSION_FORM_START;
	      };
	      return _Tokenizer;
	  }());
	  function isNotWhitespace(code) {
	      return !isWhitespace(code) || code === $EOF;
	  }
	  function isNameEnd(code) {
	      return isWhitespace(code) || code === $GT || code === $SLASH ||
	          code === $SQ || code === $DQ || code === $EQ;
	  }
	  function isPrefixEnd(code) {
	      return (code < $a || $z < code) && (code < $A || $Z < code) &&
	          (code < $0 || code > $9);
	  }
	  function isDigitEntityEnd(code) {
	      return code == $SEMICOLON || code == $EOF || !isAsciiHexDigit(code);
	  }
	  function isNamedEntityEnd(code) {
	      return code == $SEMICOLON || code == $EOF || !isAsciiLetter(code);
	  }
	  function isExpansionFormStart(input, offset, interpolationConfig) {
	      var isInterpolationStart = interpolationConfig ? input.indexOf(interpolationConfig.start, offset) == offset : false;
	      return input.charCodeAt(offset) == $LBRACE && !isInterpolationStart;
	  }
	  function isExpansionCaseStart(peek) {
	      return peek === $EQ || isAsciiLetter(peek);
	  }
	  function compareCharCodeCaseInsensitive(code1, code2) {
	      return toUpperCaseCharCode(code1) == toUpperCaseCharCode(code2);
	  }
	  function toUpperCaseCharCode(code) {
	      return code >= $a && code <= $z ? code - $a + $A : code;
	  }
	  function mergeTextTokens(srcTokens) {
	      var dstTokens = [];
	      var lastDstToken;
	      for (var i = 0; i < srcTokens.length; i++) {
	          var token = srcTokens[i];
	          if (lastDstToken && lastDstToken.type == TokenType$1.TEXT && token.type == TokenType$1.TEXT) {
	              lastDstToken.parts[0] += token.parts[0];
	              lastDstToken.sourceSpan.end = token.sourceSpan.end;
	          }
	          else {
	              lastDstToken = token;
	              dstTokens.push(lastDstToken);
	          }
	      }
	      return dstTokens;
	  }

	  /**
	   * @license
	   * Copyright Google Inc. All Rights Reserved.
	   *
	   * Use of this source code is governed by an MIT-style license that can be
	   * found in the LICENSE file at https://angular.io/license
	   */
	  var __extends$3 = (this && this.__extends) || function (d, b) {
	      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	      function __() { this.constructor = d; }
	      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	  };
	  var TreeError = (function (_super) {
	      __extends$3(TreeError, _super);
	      function TreeError(elementName, span, msg) {
	          _super.call(this, span, msg);
	          this.elementName = elementName;
	      }
	      TreeError.create = function (elementName, span, msg) {
	          return new TreeError(elementName, span, msg);
	      };
	      return TreeError;
	  }(ParseError));
	  var ParseTreeResult = (function () {
	      function ParseTreeResult(rootNodes, errors) {
	          this.rootNodes = rootNodes;
	          this.errors = errors;
	      }
	      return ParseTreeResult;
	  }());
	  var Parser$1 = (function () {
	      function Parser(getTagDefinition) {
	          this.getTagDefinition = getTagDefinition;
	      }
	      Parser.prototype.parse = function (source, url, parseExpansionForms, interpolationConfig) {
	          if (parseExpansionForms === void 0) { parseExpansionForms = false; }
	          if (interpolationConfig === void 0) { interpolationConfig = DEFAULT_INTERPOLATION_CONFIG; }
	          var tokensAndErrors = tokenize(source, url, this.getTagDefinition, parseExpansionForms, interpolationConfig);
	          var treeAndErrors = new _TreeBuilder(tokensAndErrors.tokens, this.getTagDefinition).build();
	          return new ParseTreeResult(treeAndErrors.rootNodes, tokensAndErrors.errors.concat(treeAndErrors.errors));
	      };
	      return Parser;
	  }());
	  var _TreeBuilder = (function () {
	      function _TreeBuilder(tokens, getTagDefinition) {
	          this.tokens = tokens;
	          this.getTagDefinition = getTagDefinition;
	          this._index = -1;
	          this._rootNodes = [];
	          this._errors = [];
	          this._elementStack = [];
	          this._advance();
	      }
	      _TreeBuilder.prototype.build = function () {
	          while (this._peek.type !== TokenType$1.EOF) {
	              if (this._peek.type === TokenType$1.TAG_OPEN_START) {
	                  this._consumeStartTag(this._advance());
	              }
	              else if (this._peek.type === TokenType$1.TAG_CLOSE) {
	                  this._consumeEndTag(this._advance());
	              }
	              else if (this._peek.type === TokenType$1.CDATA_START) {
	                  this._closeVoidElement();
	                  this._consumeCdata(this._advance());
	              }
	              else if (this._peek.type === TokenType$1.COMMENT_START) {
	                  this._closeVoidElement();
	                  this._consumeComment(this._advance());
	              }
	              else if (this._peek.type === TokenType$1.TEXT || this._peek.type === TokenType$1.RAW_TEXT ||
	                  this._peek.type === TokenType$1.ESCAPABLE_RAW_TEXT) {
	                  this._closeVoidElement();
	                  this._consumeText(this._advance());
	              }
	              else if (this._peek.type === TokenType$1.EXPANSION_FORM_START) {
	                  this._consumeExpansion(this._advance());
	              }
	              else {
	                  // Skip all other tokens...
	                  this._advance();
	              }
	          }
	          return new ParseTreeResult(this._rootNodes, this._errors);
	      };
	      _TreeBuilder.prototype._advance = function () {
	          var prev = this._peek;
	          if (this._index < this.tokens.length - 1) {
	              // Note: there is always an EOF token at the end
	              this._index++;
	          }
	          this._peek = this.tokens[this._index];
	          return prev;
	      };
	      _TreeBuilder.prototype._advanceIf = function (type) {
	          if (this._peek.type === type) {
	              return this._advance();
	          }
	          return null;
	      };
	      _TreeBuilder.prototype._consumeCdata = function (startToken) {
	          this._consumeText(this._advance());
	          this._advanceIf(TokenType$1.CDATA_END);
	      };
	      _TreeBuilder.prototype._consumeComment = function (token) {
	          var text = this._advanceIf(TokenType$1.RAW_TEXT);
	          this._advanceIf(TokenType$1.COMMENT_END);
	          var value = isPresent(text) ? text.parts[0].trim() : null;
	          this._addToParent(new Comment(value, token.sourceSpan));
	      };
	      _TreeBuilder.prototype._consumeExpansion = function (token) {
	          var switchValue = this._advance();
	          var type = this._advance();
	          var cases = [];
	          // read =
	          while (this._peek.type === TokenType$1.EXPANSION_CASE_VALUE) {
	              var expCase = this._parseExpansionCase();
	              if (!expCase)
	                  return; // error
	              cases.push(expCase);
	          }
	          // read the final }
	          if (this._peek.type !== TokenType$1.EXPANSION_FORM_END) {
	              this._errors.push(TreeError.create(null, this._peek.sourceSpan, "Invalid ICU message. Missing '}'."));
	              return;
	          }
	          var sourceSpan = new ParseSourceSpan(token.sourceSpan.start, this._peek.sourceSpan.end);
	          this._addToParent(new Expansion(switchValue.parts[0], type.parts[0], cases, sourceSpan, switchValue.sourceSpan));
	          this._advance();
	      };
	      _TreeBuilder.prototype._parseExpansionCase = function () {
	          var value = this._advance();
	          // read {
	          if (this._peek.type !== TokenType$1.EXPANSION_CASE_EXP_START) {
	              this._errors.push(TreeError.create(null, this._peek.sourceSpan, "Invalid ICU message. Missing '{'."));
	              return null;
	          }
	          // read until }
	          var start = this._advance();
	          var exp = this._collectExpansionExpTokens(start);
	          if (!exp)
	              return null;
	          var end = this._advance();
	          exp.push(new Token$1(TokenType$1.EOF, [], end.sourceSpan));
	          // parse everything in between { and }
	          var parsedExp = new _TreeBuilder(exp, this.getTagDefinition).build();
	          if (parsedExp.errors.length > 0) {
	              this._errors = this._errors.concat(parsedExp.errors);
	              return null;
	          }
	          var sourceSpan = new ParseSourceSpan(value.sourceSpan.start, end.sourceSpan.end);
	          var expSourceSpan = new ParseSourceSpan(start.sourceSpan.start, end.sourceSpan.end);
	          return new ExpansionCase(value.parts[0], parsedExp.rootNodes, sourceSpan, value.sourceSpan, expSourceSpan);
	      };
	      _TreeBuilder.prototype._collectExpansionExpTokens = function (start) {
	          var exp = [];
	          var expansionFormStack = [TokenType$1.EXPANSION_CASE_EXP_START];
	          while (true) {
	              if (this._peek.type === TokenType$1.EXPANSION_FORM_START ||
	                  this._peek.type === TokenType$1.EXPANSION_CASE_EXP_START) {
	                  expansionFormStack.push(this._peek.type);
	              }
	              if (this._peek.type === TokenType$1.EXPANSION_CASE_EXP_END) {
	                  if (lastOnStack(expansionFormStack, TokenType$1.EXPANSION_CASE_EXP_START)) {
	                      expansionFormStack.pop();
	                      if (expansionFormStack.length == 0)
	                          return exp;
	                  }
	                  else {
	                      this._errors.push(TreeError.create(null, start.sourceSpan, "Invalid ICU message. Missing '}'."));
	                      return null;
	                  }
	              }
	              if (this._peek.type === TokenType$1.EXPANSION_FORM_END) {
	                  if (lastOnStack(expansionFormStack, TokenType$1.EXPANSION_FORM_START)) {
	                      expansionFormStack.pop();
	                  }
	                  else {
	                      this._errors.push(TreeError.create(null, start.sourceSpan, "Invalid ICU message. Missing '}'."));
	                      return null;
	                  }
	              }
	              if (this._peek.type === TokenType$1.EOF) {
	                  this._errors.push(TreeError.create(null, start.sourceSpan, "Invalid ICU message. Missing '}'."));
	                  return null;
	              }
	              exp.push(this._advance());
	          }
	      };
	      _TreeBuilder.prototype._consumeText = function (token) {
	          var text = token.parts[0];
	          if (text.length > 0 && text[0] == '\n') {
	              var parent_1 = this._getParentElement();
	              if (isPresent(parent_1) && parent_1.children.length == 0 &&
	                  this.getTagDefinition(parent_1.name).ignoreFirstLf) {
	                  text = text.substring(1);
	              }
	          }
	          if (text.length > 0) {
	              this._addToParent(new Text(text, token.sourceSpan));
	          }
	      };
	      _TreeBuilder.prototype._closeVoidElement = function () {
	          if (this._elementStack.length > 0) {
	              var el = this._elementStack[this._elementStack.length - 1];
	              if (this.getTagDefinition(el.name).isVoid) {
	                  this._elementStack.pop();
	              }
	          }
	      };
	      _TreeBuilder.prototype._consumeStartTag = function (startTagToken) {
	          var prefix = startTagToken.parts[0];
	          var name = startTagToken.parts[1];
	          var attrs = [];
	          while (this._peek.type === TokenType$1.ATTR_NAME) {
	              attrs.push(this._consumeAttr(this._advance()));
	          }
	          var fullName = this._getElementFullName(prefix, name, this._getParentElement());
	          var selfClosing = false;
	          // Note: There could have been a tokenizer error
	          // so that we don't get a token for the end tag...
	          if (this._peek.type === TokenType$1.TAG_OPEN_END_VOID) {
	              this._advance();
	              selfClosing = true;
	              var tagDef = this.getTagDefinition(fullName);
	              if (!(tagDef.canSelfClose || getNsPrefix(fullName) !== null || tagDef.isVoid)) {
	                  this._errors.push(TreeError.create(fullName, startTagToken.sourceSpan, "Only void and foreign elements can be self closed \"" + startTagToken.parts[1] + "\""));
	              }
	          }
	          else if (this._peek.type === TokenType$1.TAG_OPEN_END) {
	              this._advance();
	              selfClosing = false;
	          }
	          var end = this._peek.sourceSpan.start;
	          var span = new ParseSourceSpan(startTagToken.sourceSpan.start, end);
	          var el = new Element(fullName, attrs, [], span, span, null);
	          this._pushElement(el);
	          if (selfClosing) {
	              this._popElement(fullName);
	              el.endSourceSpan = span;
	          }
	      };
	      _TreeBuilder.prototype._pushElement = function (el) {
	          if (this._elementStack.length > 0) {
	              var parentEl = this._elementStack[this._elementStack.length - 1];
	              if (this.getTagDefinition(parentEl.name).isClosedByChild(el.name)) {
	                  this._elementStack.pop();
	              }
	          }
	          var tagDef = this.getTagDefinition(el.name);
	          var _a = this._getParentElementSkippingContainers(), parent = _a.parent, container = _a.container;
	          if (isPresent(parent) && tagDef.requireExtraParent(parent.name)) {
	              var newParent = new Element(tagDef.parentToAdd, [], [], el.sourceSpan, el.startSourceSpan, el.endSourceSpan);
	              this._insertBeforeContainer(parent, container, newParent);
	          }
	          this._addToParent(el);
	          this._elementStack.push(el);
	      };
	      _TreeBuilder.prototype._consumeEndTag = function (endTagToken) {
	          var fullName = this._getElementFullName(endTagToken.parts[0], endTagToken.parts[1], this._getParentElement());
	          if (this._getParentElement()) {
	              this._getParentElement().endSourceSpan = endTagToken.sourceSpan;
	          }
	          if (this.getTagDefinition(fullName).isVoid) {
	              this._errors.push(TreeError.create(fullName, endTagToken.sourceSpan, "Void elements do not have end tags \"" + endTagToken.parts[1] + "\""));
	          }
	          else if (!this._popElement(fullName)) {
	              this._errors.push(TreeError.create(fullName, endTagToken.sourceSpan, "Unexpected closing tag \"" + endTagToken.parts[1] + "\""));
	          }
	      };
	      _TreeBuilder.prototype._popElement = function (fullName) {
	          for (var stackIndex = this._elementStack.length - 1; stackIndex >= 0; stackIndex--) {
	              var el = this._elementStack[stackIndex];
	              if (el.name == fullName) {
	                  this._elementStack.splice(stackIndex, this._elementStack.length - stackIndex);
	                  return true;
	              }
	              if (!this.getTagDefinition(el.name).closedByParent) {
	                  return false;
	              }
	          }
	          return false;
	      };
	      _TreeBuilder.prototype._consumeAttr = function (attrName) {
	          var fullName = mergeNsAndName(attrName.parts[0], attrName.parts[1]);
	          var end = attrName.sourceSpan.end;
	          var value = '';
	          var valueSpan;
	          if (this._peek.type === TokenType$1.ATTR_VALUE) {
	              var valueToken = this._advance();
	              value = valueToken.parts[0];
	              end = valueToken.sourceSpan.end;
	              valueSpan = valueToken.sourceSpan;
	          }
	          return new Attribute$1(fullName, value, new ParseSourceSpan(attrName.sourceSpan.start, end), valueSpan);
	      };
	      _TreeBuilder.prototype._getParentElement = function () {
	          return this._elementStack.length > 0 ? this._elementStack[this._elementStack.length - 1] : null;
	      };
	      /**
	       * Returns the parent in the DOM and the container.
	       *
	       * `<ng-container>` elements are skipped as they are not rendered as DOM element.
	       */
	      _TreeBuilder.prototype._getParentElementSkippingContainers = function () {
	          var container = null;
	          for (var i = this._elementStack.length - 1; i >= 0; i--) {
	              if (this._elementStack[i].name !== 'ng-container') {
	                  return { parent: this._elementStack[i], container: container };
	              }
	              container = this._elementStack[i];
	          }
	          return { parent: this._elementStack[this._elementStack.length - 1], container: container };
	      };
	      _TreeBuilder.prototype._addToParent = function (node) {
	          var parent = this._getParentElement();
	          if (isPresent(parent)) {
	              parent.children.push(node);
	          }
	          else {
	              this._rootNodes.push(node);
	          }
	      };
	      /**
	       * Insert a node between the parent and the container.
	       * When no container is given, the node is appended as a child of the parent.
	       * Also updates the element stack accordingly.
	       *
	       * @internal
	       */
	      _TreeBuilder.prototype._insertBeforeContainer = function (parent, container, node) {
	          if (!container) {
	              this._addToParent(node);
	              this._elementStack.push(node);
	          }
	          else {
	              if (parent) {
	                  // replace the container with the new node in the children
	                  var index = parent.children.indexOf(container);
	                  parent.children[index] = node;
	              }
	              else {
	                  this._rootNodes.push(node);
	              }
	              node.children.push(container);
	              this._elementStack.splice(this._elementStack.indexOf(container), 0, node);
	          }
	      };
	      _TreeBuilder.prototype._getElementFullName = function (prefix, localName, parentElement) {
	          if (isBlank(prefix)) {
	              prefix = this.getTagDefinition(localName).implicitNamespacePrefix;
	              if (isBlank(prefix) && isPresent(parentElement)) {
	                  prefix = getNsPrefix(parentElement.name);
	              }
	          }
	          return mergeNsAndName(prefix, localName);
	      };
	      return _TreeBuilder;
	  }());
	  function lastOnStack(stack, element) {
	      return stack.length > 0 && stack[stack.length - 1] === element;
	  }

	  /**
	   * @license
	   * Copyright Google Inc. All Rights Reserved.
	   *
	   * Use of this source code is governed by an MIT-style license that can be
	   * found in the LICENSE file at https://angular.io/license
	   */
	  function digestMessage(message) {
	      return sha1(serializeNodes(message.nodes).join('') + ("[" + message.meaning + "]"));
	  }
	  /**
	   * Serialize the i18n ast to something xml-like in order to generate an UID.
	   *
	   * The visitor is also used in the i18n parser tests
	   *
	   * @internal
	   */
	  var _SerializerVisitor = (function () {
	      function _SerializerVisitor() {
	      }
	      _SerializerVisitor.prototype.visitText = function (text, context) { return text.value; };
	      _SerializerVisitor.prototype.visitContainer = function (container, context) {
	          var _this = this;
	          return "[" + container.children.map(function (child) { return child.visit(_this); }).join(', ') + "]";
	      };
	      _SerializerVisitor.prototype.visitIcu = function (icu, context) {
	          var _this = this;
	          var strCases = Object.keys(icu.cases).map(function (k) { return (k + " {" + icu.cases[k].visit(_this) + "}"); });
	          return "{" + icu.expression + ", " + icu.type + ", " + strCases.join(', ') + "}";
	      };
	      _SerializerVisitor.prototype.visitTagPlaceholder = function (ph, context) {
	          var _this = this;
	          return ph.isVoid ?
	              "<ph tag name=\"" + ph.startName + "\"/>" :
	              "<ph tag name=\"" + ph.startName + "\">" + ph.children.map(function (child) { return child.visit(_this); }).join(', ') + "</ph name=\"" + ph.closeName + "\">";
	      };
	      _SerializerVisitor.prototype.visitPlaceholder = function (ph, context) {
	          return "<ph name=\"" + ph.name + "\">" + ph.value + "</ph>";
	      };
	      _SerializerVisitor.prototype.visitIcuPlaceholder = function (ph, context) {
	          return "<ph icu name=\"" + ph.name + "\">" + ph.value.visit(this) + "</ph>";
	      };
	      return _SerializerVisitor;
	  }());
	  var serializerVisitor = new _SerializerVisitor();
	  function serializeNodes(nodes) {
	      return nodes.map(function (a) { return a.visit(serializerVisitor, null); });
	  }
	  /**
	   * Compute the SHA1 of the given string
	   *
	   * see http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf
	   *
	   * WARNING: this function has not been designed not tested with security in mind.
	   *          DO NOT USE IT IN A SECURITY SENSITIVE CONTEXT.
	   */
	  function sha1(str) {
	      var utf8 = utf8Encode(str);
	      var words32 = stringToWords32(utf8);
	      var len = utf8.length * 8;
	      var w = new Array(80);
	      var _a = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0], a = _a[0], b = _a[1], c = _a[2], d = _a[3], e = _a[4];
	      words32[len >> 5] |= 0x80 << (24 - len % 32);
	      words32[((len + 64 >> 9) << 4) + 15] = len;
	      for (var i = 0; i < words32.length; i += 16) {
	          var _b = [a, b, c, d, e], h0 = _b[0], h1 = _b[1], h2 = _b[2], h3 = _b[3], h4 = _b[4];
	          for (var j = 0; j < 80; j++) {
	              if (j < 16) {
	                  w[j] = words32[i + j];
	              }
	              else {
	                  w[j] = rol32(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1);
	              }
	              var _c = fk(j, b, c, d), f = _c[0], k = _c[1];
	              var temp = [rol32(a, 5), f, e, k, w[j]].reduce(add32);
	              _d = [d, c, rol32(b, 30), a, temp], e = _d[0], d = _d[1], c = _d[2], b = _d[3], a = _d[4];
	          }
	          _e = [add32(a, h0), add32(b, h1), add32(c, h2), add32(d, h3), add32(e, h4)], a = _e[0], b = _e[1], c = _e[2], d = _e[3], e = _e[4];
	      }
	      var sha1 = words32ToString([a, b, c, d, e]);
	      var hex = '';
	      for (var i = 0; i < sha1.length; i++) {
	          var b_1 = sha1.charCodeAt(i);
	          hex += (b_1 >>> 4 & 0x0f).toString(16) + (b_1 & 0x0f).toString(16);
	      }
	      return hex.toLowerCase();
	      var _d, _e;
	  }
	  function utf8Encode(str) {
	      var encoded = '';
	      for (var index = 0; index < str.length; index++) {
	          var codePoint = decodeSurrogatePairs(str, index);
	          if (codePoint <= 0x7f) {
	              encoded += String.fromCharCode(codePoint);
	          }
	          else if (codePoint <= 0x7ff) {
	              encoded += String.fromCharCode(0xc0 | codePoint >>> 6, 0x80 | codePoint & 0x3f);
	          }
	          else if (codePoint <= 0xffff) {
	              encoded += String.fromCharCode(0xe0 | codePoint >>> 12, 0x80 | codePoint >>> 6 & 0x3f, 0x80 | codePoint & 0x3f);
	          }
	          else if (codePoint <= 0x1fffff) {
	              encoded += String.fromCharCode(0xf0 | codePoint >>> 18, 0x80 | codePoint >>> 12 & 0x3f, 0x80 | codePoint >>> 6 & 0x3f, 0x80 | codePoint & 0x3f);
	          }
	      }
	      return encoded;
	  }
	  // see https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
	  function decodeSurrogatePairs(str, index) {
	      if (index < 0 || index >= str.length) {
	          throw new Error("index=" + index + " is out of range in \"" + str + "\"");
	      }
	      var high = str.charCodeAt(index);
	      var low;
	      if (high >= 0xd800 && high <= 0xdfff && str.length > index + 1) {
	          low = str.charCodeAt(index + 1);
	          if (low >= 0xdc00 && low <= 0xdfff) {
	              return (high - 0xd800) * 0x400 + low - 0xdc00 + 0x10000;
	          }
	      }
	      return high;
	  }
	  function stringToWords32(str) {
	      var words32 = Array(str.length >>> 2);
	      for (var i = 0; i < words32.length; i++) {
	          words32[i] = 0;
	      }
	      for (var i = 0; i < str.length; i++) {
	          words32[i >>> 2] |= (str.charCodeAt(i) & 0xff) << 8 * (3 - i & 0x3);
	      }
	      return words32;
	  }
	  function words32ToString(words32) {
	      var str = '';
	      for (var i = 0; i < words32.length * 4; i++) {
	          str += String.fromCharCode((words32[i >>> 2] >>> 8 * (3 - i & 0x3)) & 0xff);
	      }
	      return str;
	  }
	  function fk(index, b, c, d) {
	      if (index < 20) {
	          return [(b & c) | (~b & d), 0x5a827999];
	      }
	      if (index < 40) {
	          return [b ^ c ^ d, 0x6ed9eba1];
	      }
	      if (index < 60) {
	          return [(b & c) | (b & d) | (c & d), 0x8f1bbcdc];
	      }
	      return [b ^ c ^ d, 0xca62c1d6];
	  }
	  function add32(a, b) {
	      var low = (a & 0xffff) + (b & 0xffff);
	      var high = (a >> 16) + (b >> 16) + (low >> 16);
	      return (high << 16) | (low & 0xffff);
	  }
	  function rol32(a, count) {
	      return (a << count) | (a >>> (32 - count));
	  }

	  /**
	   * @license
	   * Copyright Google Inc. All Rights Reserved.
	   *
	   * Use of this source code is governed by an MIT-style license that can be
	   * found in the LICENSE file at https://angular.io/license
	   */
	  var Message = (function () {
	      /**
	       * @param nodes message AST
	       * @param placeholders maps placeholder names to static content
	       * @param placeholderToMsgIds maps placeholder names to translatable message IDs (used for ICU
	       *                            messages)
	       * @param meaning
	       * @param description
	       */
	      function Message(nodes, placeholders, placeholderToMsgIds, meaning, description) {
	          this.nodes = nodes;
	          this.placeholders = placeholders;
	          this.placeholderToMsgIds = placeholderToMsgIds;
	          this.meaning = meaning;
	          this.description = description;
	      }
	      return Message;
	  }());
	  var Text$1 = (function () {
	      function Text(value, sourceSpan) {
	          this.value = value;
	          this.sourceSpan = sourceSpan;
	      }
	      Text.prototype.visit = function (visitor, context) { return visitor.visitText(this, context); };
	      return Text;
	  }());
	  var Container = (function () {
	      function Container(children, sourceSpan) {
	          this.children = children;
	          this.sourceSpan = sourceSpan;
	      }
	      Container.prototype.visit = function (visitor, context) { return visitor.visitContainer(this, context); };
	      return Container;
	  }());
	  var Icu = (function () {
	      function Icu(expression, type, cases, sourceSpan) {
	          this.expression = expression;
	          this.type = type;
	          this.cases = cases;
	          this.sourceSpan = sourceSpan;
	      }
	      Icu.prototype.visit = function (visitor, context) { return visitor.visitIcu(this, context); };
	      return Icu;
	  }());
	  var TagPlaceholder = (function () {
	      function TagPlaceholder(tag, attrs, startName, closeName, children, isVoid, sourceSpan) {
	          this.tag = tag;
	          this.attrs = attrs;
	          this.startName = startName;
	          this.closeName = closeName;
	          this.children = children;
	          this.isVoid = isVoid;
	          this.sourceSpan = sourceSpan;
	      }
	      TagPlaceholder.prototype.visit = function (visitor, context) { return visitor.visitTagPlaceholder(this, context); };
	      return TagPlaceholder;
	  }());
	  var Placeholder = (function () {
	      function Placeholder(value, name, sourceSpan) {
	          if (name === void 0) { name = ''; }
	          this.value = value;
	          this.name = name;
	          this.sourceSpan = sourceSpan;
	      }
	      Placeholder.prototype.visit = function (visitor, context) { return visitor.visitPlaceholder(this, context); };
	      return Placeholder;
	  }());
	  var IcuPlaceholder = (function () {
	      function IcuPlaceholder(value, name, sourceSpan) {
	          if (name === void 0) { name = ''; }
	          this.value = value;
	          this.name = name;
	          this.sourceSpan = sourceSpan;
	      }
	      IcuPlaceholder.prototype.visit = function (visitor, context) { return visitor.visitIcuPlaceholder(this, context); };
	      return IcuPlaceholder;
	  }());

	  /**
	   * @license
	   * Copyright Google Inc. All Rights Reserved.
	   *
	   * Use of this source code is governed by an MIT-style license that can be
	   * found in the LICENSE file at https://angular.io/license
	   */
	  var TAG_TO_PLACEHOLDER_NAMES = {
	      'A': 'LINK',
	      'B': 'BOLD_TEXT',
	      'BR': 'LINE_BREAK',
	      'EM': 'EMPHASISED_TEXT',
	      'H1': 'HEADING_LEVEL1',
	      'H2': 'HEADING_LEVEL2',
	      'H3': 'HEADING_LEVEL3',
	      'H4': 'HEADING_LEVEL4',
	      'H5': 'HEADING_LEVEL5',
	      'H6': 'HEADING_LEVEL6',
	      'HR': 'HORIZONTAL_RULE',
	      'I': 'ITALIC_TEXT',
	      'LI': 'LIST_ITEM',
	      'LINK': 'MEDIA_LINK',
	      'OL': 'ORDERED_LIST',
	      'P': 'PARAGRAPH',
	      'Q': 'QUOTATION',
	      'S': 'STRIKETHROUGH_TEXT',
	      'SMALL': 'SMALL_TEXT',
	      'SUB': 'SUBSTRIPT',
	      'SUP': 'SUPERSCRIPT',
	      'TBODY': 'TABLE_BODY',
	      'TD': 'TABLE_CELL',
	      'TFOOT': 'TABLE_FOOTER',
	      'TH': 'TABLE_HEADER_CELL',
	      'THEAD': 'TABLE_HEADER',
	      'TR': 'TABLE_ROW',
	      'TT': 'MONOSPACED_TEXT',
	      'U': 'UNDERLINED_TEXT',
	      'UL': 'UNORDERED_LIST',
	  };
	  /**
	   * Creates unique names for placeholder with different content
	   *
	   * @internal
	   */
	  var PlaceholderRegistry = (function () {
	      function PlaceholderRegistry() {
	          // Count the occurrence of the base name top generate a unique name
	          this._placeHolderNameCounts = {};
	          // Maps signature to placeholder names
	          this._signatureToName = {};
	      }
	      PlaceholderRegistry.prototype.getStartTagPlaceholderName = function (tag, attrs, isVoid) {
	          var signature = this._hashTag(tag, attrs, isVoid);
	          if (this._signatureToName[signature]) {
	              return this._signatureToName[signature];
	          }
	          var upperTag = tag.toUpperCase();
	          var baseName = TAG_TO_PLACEHOLDER_NAMES[upperTag] || "TAG_" + upperTag;
	          var name = this._generateUniqueName(isVoid ? baseName : "START_" + baseName);
	          this._signatureToName[signature] = name;
	          return name;
	      };
	      PlaceholderRegistry.prototype.getCloseTagPlaceholderName = function (tag) {
	          var signature = this._hashClosingTag(tag);
	          if (this._signatureToName[signature]) {
	              return this._signatureToName[signature];
	          }
	          var upperTag = tag.toUpperCase();
	          var baseName = TAG_TO_PLACEHOLDER_NAMES[upperTag] || "TAG_" + upperTag;
	          var name = this._generateUniqueName("CLOSE_" + baseName);
	          this._signatureToName[signature] = name;
	          return name;
	      };
	      PlaceholderRegistry.prototype.getPlaceholderName = function (name, content) {
	          var upperName = name.toUpperCase();
	          var signature = "PH: " + upperName + "=" + content;
	          if (this._signatureToName[signature]) {
	              return this._signatureToName[signature];
	          }
	          var uniqueName = this._generateUniqueName(upperName);
	          this._signatureToName[signature] = uniqueName;
	          return uniqueName;
	      };
	      // Generate a hash for a tag - does not take attribute order into account
	      PlaceholderRegistry.prototype._hashTag = function (tag, attrs, isVoid) {
	          var start = "<" + tag;
	          var strAttrs = Object.keys(attrs).sort().map(function (name) { return (" " + name + "=" + attrs[name]); }).join('');
	          var end = isVoid ? '/>' : "></" + tag + ">";
	          return start + strAttrs + end;
	      };
	      PlaceholderRegistry.prototype._hashClosingTag = function (tag) { return this._hashTag("/" + tag, {}, false); };
	      PlaceholderRegistry.prototype._generateUniqueName = function (base) {
	          var name = base;
	          var next = this._placeHolderNameCounts[name];
	          if (!next) {
	              next = 1;
	          }
	          else {
	              name += "_" + next;
	              next++;
	          }
	          this._placeHolderNameCounts[base] = next;
	          return name;
	      };
	      return PlaceholderRegistry;
	  }());

	  var _expParser = new Parser(new Lexer());
	  /**
	   * Returns a function converting html nodes to an i18n Message given an interpolationConfig
	   */
	  function createI18nMessageFactory(interpolationConfig) {
	      var visitor = new _I18nVisitor(_expParser, interpolationConfig);
	      return function (nodes, meaning, description) {
	          return visitor.toI18nMessage(nodes, meaning, description);
	      };
	  }
	  var _I18nVisitor = (function () {
	      function _I18nVisitor(_expressionParser, _interpolationConfig) {
	          this._expressionParser = _expressionParser;
	          this._interpolationConfig = _interpolationConfig;
	      }
	      _I18nVisitor.prototype.toI18nMessage = function (nodes, meaning, description) {
	          this._isIcu = nodes.length == 1 && nodes[0] instanceof Expansion;
	          this._icuDepth = 0;
	          this._placeholderRegistry = new PlaceholderRegistry();
	          this._placeholderToContent = {};
	          this._placeholderToIds = {};
	          var i18nodes = visitAll(this, nodes, {});
	          return new Message(i18nodes, this._placeholderToContent, this._placeholderToIds, meaning, description);
	      };
	      _I18nVisitor.prototype.visitElement = function (el, context) {
	          var children = visitAll(this, el.children);
	          var attrs = {};
	          el.attrs.forEach(function (attr) {
	              // Do not visit the attributes, translatable ones are top-level ASTs
	              attrs[attr.name] = attr.value;
	          });
	          var isVoid = getHtmlTagDefinition(el.name).isVoid;
	          var startPhName = this._placeholderRegistry.getStartTagPlaceholderName(el.name, attrs, isVoid);
	          this._placeholderToContent[startPhName] = el.sourceSpan.toString();
	          var closePhName = '';
	          if (!isVoid) {
	              closePhName = this._placeholderRegistry.getCloseTagPlaceholderName(el.name);
	              this._placeholderToContent[closePhName] = "</" + el.name + ">";
	          }
	          return new TagPlaceholder(el.name, attrs, startPhName, closePhName, children, isVoid, el.sourceSpan);
	      };
	      _I18nVisitor.prototype.visitAttribute = function (attribute, context) {
	          return this._visitTextWithInterpolation(attribute.value, attribute.sourceSpan);
	      };
	      _I18nVisitor.prototype.visitText = function (text, context) {
	          return this._visitTextWithInterpolation(text.value, text.sourceSpan);
	      };
	      _I18nVisitor.prototype.visitComment = function (comment, context) { return null; };
	      _I18nVisitor.prototype.visitExpansion = function (icu, context) {
	          var _this = this;
	          this._icuDepth++;
	          var i18nIcuCases = {};
	          var i18nIcu = new Icu(icu.switchValue, icu.type, i18nIcuCases, icu.sourceSpan);
	          icu.cases.forEach(function (caze) {
	              i18nIcuCases[caze.value] = new Container(caze.expression.map(function (node) { return node.visit(_this, {}); }), caze.expSourceSpan);
	          });
	          this._icuDepth--;
	          if (this._isIcu || this._icuDepth > 0) {
	              // If the message (vs a part of the message) is an ICU message returns it
	              return i18nIcu;
	          }
	          // Else returns a placeholder
	          // ICU placeholders should not be replaced with their original content but with the their
	          // translations. We need to create a new visitor (they are not re-entrant) to compute the
	          // message id.
	          // TODO(vicb): add a html.Node -> i18n.Message cache to avoid having to re-create the msg
	          var phName = this._placeholderRegistry.getPlaceholderName('ICU', icu.sourceSpan.toString());
	          var visitor = new _I18nVisitor(this._expressionParser, this._interpolationConfig);
	          this._placeholderToIds[phName] = digestMessage(visitor.toI18nMessage([icu], '', ''));
	          return new IcuPlaceholder(i18nIcu, phName, icu.sourceSpan);
	      };
	      _I18nVisitor.prototype.visitExpansionCase = function (icuCase, context) {
	          throw new Error('Unreachable code');
	      };
	      _I18nVisitor.prototype._visitTextWithInterpolation = function (text, sourceSpan) {
	          var splitInterpolation = this._expressionParser.splitInterpolation(text, sourceSpan.start.toString(), this._interpolationConfig);
	          if (!splitInterpolation) {
	              // No expression, return a single text
	              return new Text$1(text, sourceSpan);
	          }
	          // Return a group of text + expressions
	          var nodes = [];
	          var container = new Container(nodes, sourceSpan);
	          var _a = this._interpolationConfig, sDelimiter = _a.start, eDelimiter = _a.end;
	          for (var i = 0; i < splitInterpolation.strings.length - 1; i++) {
	              var expression = splitInterpolation.expressions[i];
	              var baseName = _extractPlaceholderName(expression) || 'INTERPOLATION';
	              var phName = this._placeholderRegistry.getPlaceholderName(baseName, expression);
	              if (splitInterpolation.strings[i].length) {
	                  // No need to add empty strings
	                  nodes.push(new Text$1(splitInterpolation.strings[i], sourceSpan));
	              }
	              nodes.push(new Placeholder(expression, phName, sourceSpan));
	              this._placeholderToContent[phName] = sDelimiter + expression + eDelimiter;
	          }
	          // The last index contains no expression
	          var lastStringIdx = splitInterpolation.strings.length - 1;
	          if (splitInterpolation.strings[lastStringIdx].length) {
	              nodes.push(new Text$1(splitInterpolation.strings[lastStringIdx], sourceSpan));
	          }
	          return container;
	      };
	      return _I18nVisitor;
	  }());
	  var _CUSTOM_PH_EXP = /\/\/[\s\S]*i18n[\s\S]*\([\s\S]*ph[\s\S]*=[\s\S]*"([\s\S]*?)"[\s\S]*\)/g;
	  function _extractPlaceholderName(input) {
	      return input.split(_CUSTOM_PH_EXP)[1];
	  }

	  /**
	   * @license
	   * Copyright Google Inc. All Rights Reserved.
	   *
	   * Use of this source code is governed by an MIT-style license that can be
	   * found in the LICENSE file at https://angular.io/license
	   */
	  var __extends$5 = (this && this.__extends) || function (d, b) {
	      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	      function __() { this.constructor = d; }
	      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	  };
	  /**
	   * An i18n error.
	   */
	  var I18nError = (function (_super) {
	      __extends$5(I18nError, _super);
	      function I18nError(span, msg) {
	          _super.call(this, span, msg);
	      }
	      return I18nError;
	  }(ParseError));

	  var _I18N_ATTR = 'i18n';
	  var _I18N_ATTR_PREFIX = 'i18n-';
	  var _I18N_COMMENT_PREFIX_REGEXP = /^i18n:?/;
	  /**
	   * Extract translatable messages from an html AST
	   */
	  function extractMessages(nodes, interpolationConfig, implicitTags, implicitAttrs) {
	      var visitor = new _Visitor(implicitTags, implicitAttrs);
	      return visitor.extract(nodes, interpolationConfig);
	  }
	  function mergeTranslations(nodes, translations, interpolationConfig, implicitTags, implicitAttrs) {
	      var visitor = new _Visitor(implicitTags, implicitAttrs);
	      return visitor.merge(nodes, translations, interpolationConfig);
	  }
	  var ExtractionResult = (function () {
	      function ExtractionResult(messages, errors) {
	          this.messages = messages;
	          this.errors = errors;
	      }
	      return ExtractionResult;
	  }());
	  var _VisitorMode;
	  (function (_VisitorMode) {
	      _VisitorMode[_VisitorMode["Extract"] = 0] = "Extract";
	      _VisitorMode[_VisitorMode["Merge"] = 1] = "Merge";
	  })(_VisitorMode || (_VisitorMode = {}));
	  /**
	   * This Visitor is used:
	   * 1. to extract all the translatable strings from an html AST (see `extract()`),
	   * 2. to replace the translatable strings with the actual translations (see `merge()`)
	   *
	   * @internal
	   */
	  var _Visitor = (function () {
	      function _Visitor(_implicitTags, _implicitAttrs) {
	          this._implicitTags = _implicitTags;
	          this._implicitAttrs = _implicitAttrs;
	      }
	      /**
	       * Extracts the messages from the tree
	       */
	      _Visitor.prototype.extract = function (nodes, interpolationConfig) {
	          var _this = this;
	          this._init(_VisitorMode.Extract, interpolationConfig);
	          nodes.forEach(function (node) { return node.visit(_this, null); });
	          if (this._inI18nBlock) {
	              this._reportError(nodes[nodes.length - 1], 'Unclosed block');
	          }
	          return new ExtractionResult(this._messages, this._errors);
	      };
	      /**
	       * Returns a tree where all translatable nodes are translated
	       */
	      _Visitor.prototype.merge = function (nodes, translations, interpolationConfig) {
	          this._init(_VisitorMode.Merge, interpolationConfig);
	          this._translations = translations;
	          // Construct a single fake root element
	          var wrapper = new Element('wrapper', [], nodes, null, null, null);
	          var translatedNode = wrapper.visit(this, null);
	          if (this._inI18nBlock) {
	              this._reportError(nodes[nodes.length - 1], 'Unclosed block');
	          }
	          return new ParseTreeResult(translatedNode.children, this._errors);
	      };
	      _Visitor.prototype.visitExpansionCase = function (icuCase, context) {
	          // Parse cases for translatable html attributes
	          var expression = visitAll(this, icuCase.expression, context);
	          if (this._mode === _VisitorMode.Merge) {
	              return new ExpansionCase(icuCase.value, expression, icuCase.sourceSpan, icuCase.valueSourceSpan, icuCase.expSourceSpan);
	          }
	      };
	      _Visitor.prototype.visitExpansion = function (icu, context) {
	          this._mayBeAddBlockChildren(icu);
	          var wasInIcu = this._inIcu;
	          if (!this._inIcu) {
	              // nested ICU messages should not be extracted but top-level translated as a whole
	              if (this._isInTranslatableSection) {
	                  this._addMessage([icu]);
	              }
	              this._inIcu = true;
	          }
	          var cases = visitAll(this, icu.cases, context);
	          if (this._mode === _VisitorMode.Merge) {
	              icu = new Expansion(icu.switchValue, icu.type, cases, icu.sourceSpan, icu.switchValueSourceSpan);
	          }
	          this._inIcu = wasInIcu;
	          return icu;
	      };
	      _Visitor.prototype.visitComment = function (comment, context) {
	          var isOpening = _isOpeningComment(comment);
	          if (isOpening && this._isInTranslatableSection) {
	              this._reportError(comment, 'Could not start a block inside a translatable section');
	              return;
	          }
	          var isClosing = _isClosingComment(comment);
	          if (isClosing && !this._inI18nBlock) {
	              this._reportError(comment, 'Trying to close an unopened block');
	              return;
	          }
	          if (!this._inI18nNode && !this._inIcu) {
	              if (!this._inI18nBlock) {
	                  if (isOpening) {
	                      this._inI18nBlock = true;
	                      this._blockStartDepth = this._depth;
	                      this._blockChildren = [];
	                      this._blockMeaningAndDesc = comment.value.replace(_I18N_COMMENT_PREFIX_REGEXP, '').trim();
	                      this._openTranslatableSection(comment);
	                  }
	              }
	              else {
	                  if (isClosing) {
	                      if (this._depth == this._blockStartDepth) {
	                          this._closeTranslatableSection(comment, this._blockChildren);
	                          this._inI18nBlock = false;
	                          var message = this._addMessage(this._blockChildren, this._blockMeaningAndDesc);
	                          // merge attributes in sections
	                          var nodes = this._translateMessage(comment, message);
	                          return visitAll(this, nodes);
	                      }
	                      else {
	                          this._reportError(comment, 'I18N blocks should not cross element boundaries');
	                          return;
	                      }
	                  }
	              }
	          }
	      };
	      _Visitor.prototype.visitText = function (text, context) {
	          if (this._isInTranslatableSection) {
	              this._mayBeAddBlockChildren(text);
	          }
	          return text;
	      };
	      _Visitor.prototype.visitElement = function (el, context) {
	          var _this = this;
	          this._mayBeAddBlockChildren(el);
	          this._depth++;
	          var wasInI18nNode = this._inI18nNode;
	          var wasInImplicitNode = this._inImplicitNode;
	          var childNodes;
	          // Extract only top level nodes with the (implicit) "i18n" attribute if not in a block or an ICU
	          // message
	          var i18nAttr = _getI18nAttr(el);
	          var isImplicit = this._implicitTags.some(function (tag) { return el.name === tag; }) &&
	              !this._inIcu && !this._isInTranslatableSection;
	          var isTopLevelImplicit = !wasInImplicitNode && isImplicit;
	          this._inImplicitNode = this._inImplicitNode || isImplicit;
	          if (!this._isInTranslatableSection && !this._inIcu) {
	              if (i18nAttr) {
	                  // explicit translation
	                  this._inI18nNode = true;
	                  var message = this._addMessage(el.children, i18nAttr.value);
	                  childNodes = this._translateMessage(el, message);
	              }
	              else if (isTopLevelImplicit) {
	                  // implicit translation
	                  this._inI18nNode = true;
	                  var message = this._addMessage(el.children);
	                  childNodes = this._translateMessage(el, message);
	              }
	              if (this._mode == _VisitorMode.Extract) {
	                  var isTranslatable = i18nAttr || isTopLevelImplicit;
	                  if (isTranslatable) {
	                      this._openTranslatableSection(el);
	                  }
	                  visitAll(this, el.children);
	                  if (isTranslatable) {
	                      this._closeTranslatableSection(el, el.children);
	                  }
	              }
	              if (this._mode === _VisitorMode.Merge && !i18nAttr && !isTopLevelImplicit) {
	                  childNodes = [];
	                  el.children.forEach(function (child) {
	                      var visited = child.visit(_this, context);
	                      if (visited && !_this._isInTranslatableSection) {
	                          // Do not add the children from translatable sections (= i18n blocks here)
	                          // They will be added when the section is close (i.e. on `<!-- /i18n -->`)
	                          childNodes = childNodes.concat(visited);
	                      }
	                  });
	              }
	          }
	          else {
	              if (i18nAttr || isTopLevelImplicit) {
	                  this._reportError(el, 'Could not mark an element as translatable inside a translatable section');
	              }
	              if (this._mode == _VisitorMode.Extract) {
	                  // Descend into child nodes for extraction
	                  visitAll(this, el.children);
	              }
	              if (this._mode == _VisitorMode.Merge) {
	                  // Translate attributes in ICU messages
	                  childNodes = [];
	                  el.children.forEach(function (child) {
	                      var visited = child.visit(_this, context);
	                      if (visited && !_this._isInTranslatableSection) {
	                          // Do not add the children from translatable sections (= i18n blocks here)
	                          // They will be added when the section is close (i.e. on `<!-- /i18n -->`)
	                          childNodes = childNodes.concat(visited);
	                      }
	                  });
	              }
	          }
	          this._visitAttributesOf(el);
	          this._depth--;
	          this._inI18nNode = wasInI18nNode;
	          this._inImplicitNode = wasInImplicitNode;
	          if (this._mode === _VisitorMode.Merge) {
	              // There are no childNodes in translatable sections - those nodes will be replace anyway
	              var translatedAttrs = this._translateAttributes(el);
	              return new Element(el.name, translatedAttrs, childNodes, el.sourceSpan, el.startSourceSpan, el.endSourceSpan);
	          }
	      };
	      _Visitor.prototype.visitAttribute = function (attribute, context) {
	          throw new Error('unreachable code');
	      };
	      _Visitor.prototype._init = function (mode, interpolationConfig) {
	          this._mode = mode;
	          this._inI18nBlock = false;
	          this._inI18nNode = false;
	          this._depth = 0;
	          this._inIcu = false;
	          this._msgCountAtSectionStart = void 0;
	          this._errors = [];
	          this._messages = [];
	          this._inImplicitNode = false;
	          this._createI18nMessage = createI18nMessageFactory(interpolationConfig);
	      };
	      // looks for translatable attributes
	      _Visitor.prototype._visitAttributesOf = function (el) {
	          var _this = this;
	          var explicitAttrNameToValue = {};
	          var implicitAttrNames = this._implicitAttrs[el.name] || [];
	          el.attrs.filter(function (attr) { return attr.name.startsWith(_I18N_ATTR_PREFIX); })
	              .forEach(function (attr) { return explicitAttrNameToValue[attr.name.slice(_I18N_ATTR_PREFIX.length)] =
	              attr.value; });
	          el.attrs.forEach(function (attr) {
	              if (attr.name in explicitAttrNameToValue) {
	                  _this._addMessage([attr], explicitAttrNameToValue[attr.name]);
	              }
	              else if (implicitAttrNames.some(function (name) { return attr.name === name; })) {
	                  _this._addMessage([attr]);
	              }
	          });
	      };
	      // add a translatable message
	      _Visitor.prototype._addMessage = function (ast, meaningAndDesc) {
	          if (ast.length == 0 ||
	              ast.length == 1 && ast[0] instanceof Attribute$1 && !ast[0].value) {
	              // Do not create empty messages
	              return;
	          }
	          var _a = _splitMeaningAndDesc(meaningAndDesc), meaning = _a[0], description = _a[1];
	          var message = this._createI18nMessage(ast, meaning, description);
	          this._messages.push(message);
	          return message;
	      };
	      // Translates the given message given the `TranslationBundle`
	      // no-op when called in extraction mode (returns [])
	      _Visitor.prototype._translateMessage = function (el, message) {
	          if (message && this._mode === _VisitorMode.Merge) {
	              var id = digestMessage(message);
	              var nodes = this._translations.get(id);
	              if (nodes) {
	                  return nodes;
	              }
	              this._reportError(el, "Translation unavailable for message id=\"" + id + "\"");
	          }
	          return [];
	      };
	      // translate the attributes of an element and remove i18n specific attributes
	      _Visitor.prototype._translateAttributes = function (el) {
	          var _this = this;
	          var attributes = el.attrs;
	          var i18nAttributeMeanings = {};
	          attributes.forEach(function (attr) {
	              if (attr.name.startsWith(_I18N_ATTR_PREFIX)) {
	                  i18nAttributeMeanings[attr.name.slice(_I18N_ATTR_PREFIX.length)] =
	                      _splitMeaningAndDesc(attr.value)[0];
	              }
	          });
	          var translatedAttributes = [];
	          attributes.forEach(function (attr) {
	              if (attr.name === _I18N_ATTR || attr.name.startsWith(_I18N_ATTR_PREFIX)) {
	                  // strip i18n specific attributes
	                  return;
	              }
	              if (attr.value && attr.value != '' && i18nAttributeMeanings.hasOwnProperty(attr.name)) {
	                  var meaning = i18nAttributeMeanings[attr.name];
	                  var message = _this._createI18nMessage([attr], meaning, '');
	                  var id = digestMessage(message);
	                  var nodes = _this._translations.get(id);
	                  if (nodes) {
	                      if (nodes[0] instanceof Text) {
	                          var value = nodes[0].value;
	                          translatedAttributes.push(new Attribute$1(attr.name, value, attr.sourceSpan));
	                      }
	                      else {
	                          _this._reportError(el, "Unexpected translation for attribute \"" + attr.name + "\" (id=\"" + id + "\")");
	                      }
	                  }
	                  else {
	                      _this._reportError(el, "Translation unavailable for attribute \"" + attr.name + "\" (id=\"" + id + "\")");
	                  }
	              }
	              else {
	                  translatedAttributes.push(attr);
	              }
	          });
	          return translatedAttributes;
	      };
	      /**
	       * Add the node as a child of the block when:
	       * - we are in a block,
	       * - we are not inside a ICU message (those are handled separately),
	       * - the node is a "direct child" of the block
	       */
	      _Visitor.prototype._mayBeAddBlockChildren = function (node) {
	          if (this._inI18nBlock && !this._inIcu && this._depth == this._blockStartDepth) {
	              this._blockChildren.push(node);
	          }
	      };
	      /**
	       * Marks the start of a section, see `_endSection`
	       */
	      _Visitor.prototype._openTranslatableSection = function (node) {
	          if (this._isInTranslatableSection) {
	              this._reportError(node, 'Unexpected section start');
	          }
	          else {
	              this._msgCountAtSectionStart = this._messages.length;
	          }
	      };
	      Object.defineProperty(_Visitor.prototype, "_isInTranslatableSection", {
	          /**
	           * A translatable section could be:
	           * - a translatable element,
	           * - nodes between `<!-- i18n -->` and `<!-- /i18n -->` comments
	           */
	          get: function () {
	              return this._msgCountAtSectionStart !== void 0;
	          },
	          enumerable: true,
	          configurable: true
	      });
	      /**
	       * Terminates a section.
	       *
	       * If a section has only one significant children (comments not significant) then we should not
	       * keep the message from this children:
	       *
	       * `<p i18n="meaning|description">{ICU message}</p>` would produce two messages:
	       * - one for the <p> content with meaning and description,
	       * - another one for the ICU message.
	       *
	       * In this case the last message is discarded as it contains less information (the AST is
	       * otherwise identical).
	       *
	       * Note that we should still keep messages extracted from attributes inside the section (ie in the
	       * ICU message here)
	       */
	      _Visitor.prototype._closeTranslatableSection = function (node, directChildren) {
	          if (!this._isInTranslatableSection) {
	              this._reportError(node, 'Unexpected section end');
	              return;
	          }
	          var startIndex = this._msgCountAtSectionStart;
	          var significantChildren = directChildren.reduce(function (count, node) { return count + (node instanceof Comment ? 0 : 1); }, 0);
	          if (significantChildren == 1) {
	              for (var i = this._messages.length - 1; i >= startIndex; i--) {
	                  var ast = this._messages[i].nodes;
	                  if (!(ast.length == 1 && ast[0] instanceof Text$1)) {
	                      this._messages.splice(i, 1);
	                      break;
	                  }
	              }
	          }
	          this._msgCountAtSectionStart = void 0;
	      };
	      _Visitor.prototype._reportError = function (node, msg) {
	          this._errors.push(new I18nError(node.sourceSpan, msg));
	      };
	      return _Visitor;
	  }());
	  function _isOpeningComment(n) {
	      return n instanceof Comment && n.value && n.value.startsWith('i18n');
	  }
	  function _isClosingComment(n) {
	      return n instanceof Comment && n.value && n.value === '/i18n';
	  }
	  function _getI18nAttr(p) {
	      return p.attrs.find(function (attr) { return attr.name === _I18N_ATTR; }) || null;
	  }
	  function _splitMeaningAndDesc(i18n) {
	      if (!i18n)
	          return ['', ''];
	      var pipeIndex = i18n.indexOf('|');
	      return pipeIndex == -1 ? ['', i18n] : [i18n.slice(0, pipeIndex), i18n.slice(pipeIndex + 1)];
	  }

	  /**
	   * A container for message extracted from the templates.
	   */
	  var MessageBundle = (function () {
	      function MessageBundle(_htmlParser, _implicitTags, _implicitAttrs) {
	          this._htmlParser = _htmlParser;
	          this._implicitTags = _implicitTags;
	          this._implicitAttrs = _implicitAttrs;
	          this._messageMap = {};
	      }
	      MessageBundle.prototype.updateFromTemplate = function (html, url, interpolationConfig) {
	          var _this = this;
	          var htmlParserResult = this._htmlParser.parse(html, url, true, interpolationConfig);
	          if (htmlParserResult.errors.length) {
	              return htmlParserResult.errors;
	          }
	          var i18nParserResult = extractMessages(htmlParserResult.rootNodes, interpolationConfig, this._implicitTags, this._implicitAttrs);
	          if (i18nParserResult.errors.length) {
	              return i18nParserResult.errors;
	          }
	          i18nParserResult.messages.forEach(function (message) { _this._messageMap[digestMessage(message)] = message; });
	      };
	      MessageBundle.prototype.getMessageMap = function () { return this._messageMap; };
	      MessageBundle.prototype.write = function (serializer) { return serializer.write(this._messageMap); };
	      return MessageBundle;
	  }());

	  var XmlTagDefinition = (function () {
	      function XmlTagDefinition() {
	          this.closedByParent = false;
	          this.contentType = TagContentType.PARSABLE_DATA;
	          this.isVoid = false;
	          this.ignoreFirstLf = false;
	          this.canSelfClose = true;
	      }
	      XmlTagDefinition.prototype.requireExtraParent = function (currentParent) { return false; };
	      XmlTagDefinition.prototype.isClosedByChild = function (name) { return false; };
	      return XmlTagDefinition;
	  }());
	  var _TAG_DEFINITION = new XmlTagDefinition();
	  function getXmlTagDefinition(tagName) {
	      return _TAG_DEFINITION;
	  }

	  /**
	   * @license
	   * Copyright Google Inc. All Rights Reserved.
	   *
	   * Use of this source code is governed by an MIT-style license that can be
	   * found in the LICENSE file at https://angular.io/license
	   */
	  var __extends$6 = (this && this.__extends) || function (d, b) {
	      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	      function __() { this.constructor = d; }
	      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	  };
	  var XmlParser = (function (_super) {
	      __extends$6(XmlParser, _super);
	      function XmlParser() {
	          _super.call(this, getXmlTagDefinition);
	      }
	      XmlParser.prototype.parse = function (source, url, parseExpansionForms) {
	          if (parseExpansionForms === void 0) { parseExpansionForms = false; }
	          return _super.prototype.parse.call(this, source, url, parseExpansionForms, null);
	      };
	      return XmlParser;
	  }(Parser$1));

	  /**
	   * @license
	   * Copyright Google Inc. All Rights Reserved.
	   *
	   * Use of this source code is governed by an MIT-style license that can be
	   * found in the LICENSE file at https://angular.io/license
	   */
	  // Generate a map of placeholder to content indexed by message ids
	  function extractPlaceholders(messageBundle) {
	      var messageMap = messageBundle.getMessageMap();
	      var placeholders = {};
	      Object.keys(messageMap).forEach(function (msgId) {
	          placeholders[msgId] = messageMap[msgId].placeholders;
	      });
	      return placeholders;
	  }
	  // Generate a map of placeholder to message ids indexed by message ids
	  function extractPlaceholderToIds(messageBundle) {
	      var messageMap = messageBundle.getMessageMap();
	      var placeholderToIds = {};
	      Object.keys(messageMap).forEach(function (msgId) {
	          placeholderToIds[msgId] = messageMap[msgId].placeholderToMsgIds;
	      });
	      return placeholderToIds;
	  }

	  /**
	   * @license
	   * Copyright Google Inc. All Rights Reserved.
	   *
	   * Use of this source code is governed by an MIT-style license that can be
	   * found in the LICENSE file at https://angular.io/license
	   */
	  var __extends$7 = (this && this.__extends) || function (d, b) {
	      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	      function __() { this.constructor = d; }
	      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	  };
	  var _Visitor$1 = (function () {
	      function _Visitor() {
	      }
	      _Visitor.prototype.visitTag = function (tag) {
	          var _this = this;
	          var strAttrs = this._serializeAttributes(tag.attrs);
	          if (tag.children.length == 0) {
	              return "<" + tag.name + strAttrs + "/>";
	          }
	          var strChildren = tag.children.map(function (node) { return node.visit(_this); });
	          return "<" + tag.name + strAttrs + ">" + strChildren.join('') + "</" + tag.name + ">";
	      };
	      _Visitor.prototype.visitText = function (text) { return text.value; };
	      _Visitor.prototype.visitDeclaration = function (decl) {
	          return "<?xml" + this._serializeAttributes(decl.attrs) + " ?>";
	      };
	      _Visitor.prototype._serializeAttributes = function (attrs) {
	          var strAttrs = Object.keys(attrs).map(function (name) { return (name + "=\"" + attrs[name] + "\""); }).join(' ');
	          return strAttrs.length > 0 ? ' ' + strAttrs : '';
	      };
	      _Visitor.prototype.visitDoctype = function (doctype) {
	          return "<!DOCTYPE " + doctype.rootTag + " [\n" + doctype.dtd + "\n]>";
	      };
	      return _Visitor;
	  }());
	  var _visitor = new _Visitor$1();
	  function serialize(nodes) {
	      return nodes.map(function (node) { return node.visit(_visitor); }).join('');
	  }
	  var Declaration = (function () {
	      function Declaration(unescapedAttrs) {
	          var _this = this;
	          this.attrs = {};
	          Object.keys(unescapedAttrs).forEach(function (k) {
	              _this.attrs[k] = _escapeXml(unescapedAttrs[k]);
	          });
	      }
	      Declaration.prototype.visit = function (visitor) { return visitor.visitDeclaration(this); };
	      return Declaration;
	  }());
	  var Doctype = (function () {
	      function Doctype(rootTag, dtd) {
	          this.rootTag = rootTag;
	          this.dtd = dtd;
	      }
	      ;
	      Doctype.prototype.visit = function (visitor) { return visitor.visitDoctype(this); };
	      return Doctype;
	  }());
	  var Tag = (function () {
	      function Tag(name, unescapedAttrs, children) {
	          var _this = this;
	          if (unescapedAttrs === void 0) { unescapedAttrs = {}; }
	          if (children === void 0) { children = []; }
	          this.name = name;
	          this.children = children;
	          this.attrs = {};
	          Object.keys(unescapedAttrs).forEach(function (k) {
	              _this.attrs[k] = _escapeXml(unescapedAttrs[k]);
	          });
	      }
	      Tag.prototype.visit = function (visitor) { return visitor.visitTag(this); };
	      return Tag;
	  }());
	  var Text$2 = (function () {
	      function Text(unescapedValue) {
	          this.value = _escapeXml(unescapedValue);
	      }
	      ;
	      Text.prototype.visit = function (visitor) { return visitor.visitText(this); };
	      return Text;
	  }());
	  var CR = (function (_super) {
	      __extends$7(CR, _super);
	      function CR(ws) {
	          if (ws === void 0) { ws = 0; }
	          _super.call(this, "\n" + new Array(ws + 1).join(' '));
	      }
	      return CR;
	  }(Text$2));
	  var _ESCAPED_CHARS = [
	      [/&/g, '&amp;'],
	      [/"/g, '&quot;'],
	      [/'/g, '&apos;'],
	      [/</g, '&lt;'],
	      [/>/g, '&gt;'],
	  ];
	  function _escapeXml(text) {
	      return _ESCAPED_CHARS.reduce(function (text, entry) { return text.replace(entry[0], entry[1]); }, text);
	  }

	  var _VERSION = '1.2';
	  var _XMLNS = 'urn:oasis:names:tc:xliff:document:1.2';
	  // TODO(vicb): make this a param (s/_/-/)
	  var _SOURCE_LANG = 'en';
	  var _PLACEHOLDER_TAG = 'x';
	  var _SOURCE_TAG = 'source';
	  var _TARGET_TAG = 'target';
	  var _UNIT_TAG = 'trans-unit';
	  // http://docs.oasis-open.org/xliff/v1.2/os/xliff-core.html
	  // http://docs.oasis-open.org/xliff/v1.2/xliff-profile-html/xliff-profile-html-1.2.html
	  var Xliff = (function () {
	      function Xliff(_htmlParser, _interpolationConfig) {
	          this._htmlParser = _htmlParser;
	          this._interpolationConfig = _interpolationConfig;
	      }
	      Xliff.prototype.write = function (messageMap) {
	          var visitor = new _WriteVisitor();
	          var transUnits = [];
	          Object.keys(messageMap).forEach(function (id) {
	              var message = messageMap[id];
	              var transUnit = new Tag(_UNIT_TAG, { id: id, datatype: 'html' });
	              transUnit.children.push(new CR(8), new Tag(_SOURCE_TAG, {}, visitor.serialize(message.nodes)), new CR(8), new Tag(_TARGET_TAG));
	              if (message.description) {
	                  transUnit.children.push(new CR(8), new Tag('note', { priority: '1', from: 'description' }, [new Text$2(message.description)]));
	              }
	              if (message.meaning) {
	                  transUnit.children.push(new CR(8), new Tag('note', { priority: '1', from: 'meaning' }, [new Text$2(message.meaning)]));
	              }
	              transUnit.children.push(new CR(6));
	              transUnits.push(new CR(6), transUnit);
	          });
	          var body = new Tag('body', {}, transUnits.concat([new CR(4)]));
	          var file = new Tag('file', { 'source-language': _SOURCE_LANG, datatype: 'plaintext', original: 'ng2.template' }, [new CR(4), body, new CR(2)]);
	          var xliff = new Tag('xliff', { version: _VERSION, xmlns: _XMLNS }, [new CR(2), file, new CR()]);
	          return serialize([
	              new Declaration({ version: '1.0', encoding: 'UTF-8' }), new CR(), xliff, new CR()
	          ]);
	      };
	      Xliff.prototype.load = function (content, url, messageBundle) {
	          var _this = this;
	          // Parse the xtb file into xml nodes
	          var result = new XmlParser().parse(content, url);
	          if (result.errors.length) {
	              throw new Error("xtb parse errors:\n" + result.errors.join('\n'));
	          }
	          // Replace the placeholders, messages are now string
	          var _a = new _LoadVisitor().parse(result.rootNodes, messageBundle), messages = _a.messages, errors = _a.errors;
	          if (errors.length) {
	              throw new Error("xtb parse errors:\n" + errors.join('\n'));
	          }
	          // Convert the string messages to html ast
	          // TODO(vicb): map error message back to the original message in xtb
	          var messageMap = {};
	          var parseErrors = [];
	          Object.keys(messages).forEach(function (id) {
	              var res = _this._htmlParser.parse(messages[id], url, true, _this._interpolationConfig);
	              parseErrors.push.apply(parseErrors, res.errors);
	              messageMap[id] = res.rootNodes;
	          });
	          if (parseErrors.length) {
	              throw new Error("xtb parse errors:\n" + parseErrors.join('\n'));
	          }
	          return messageMap;
	      };
	      return Xliff;
	  }());
	  var _WriteVisitor = (function () {
	      function _WriteVisitor() {
	      }
	      _WriteVisitor.prototype.visitText = function (text, context) { return [new Text$2(text.value)]; };
	      _WriteVisitor.prototype.visitContainer = function (container, context) {
	          var _this = this;
	          var nodes = [];
	          container.children.forEach(function (node) { return nodes.push.apply(nodes, node.visit(_this)); });
	          return nodes;
	      };
	      _WriteVisitor.prototype.visitIcu = function (icu, context) {
	          if (this._isInIcu) {
	              // nested ICU is not supported
	              throw new Error('xliff does not support nested ICU messages');
	          }
	          this._isInIcu = true;
	          // TODO(vicb): support ICU messages
	          // https://lists.oasis-open.org/archives/xliff/201201/msg00028.html
	          // http://docs.oasis-open.org/xliff/v1.2/xliff-profile-po/xliff-profile-po-1.2-cd02.html
	          var nodes = [];
	          this._isInIcu = false;
	          return nodes;
	      };
	      _WriteVisitor.prototype.visitTagPlaceholder = function (ph, context) {
	          var ctype = getCtypeForTag(ph.tag);
	          var startTagPh = new Tag(_PLACEHOLDER_TAG, { id: ph.startName, ctype: ctype });
	          if (ph.isVoid) {
	              // void tags have no children nor closing tags
	              return [startTagPh];
	          }
	          var closeTagPh = new Tag(_PLACEHOLDER_TAG, { id: ph.closeName, ctype: ctype });
	          return [startTagPh].concat(this.serialize(ph.children), [closeTagPh]);
	      };
	      _WriteVisitor.prototype.visitPlaceholder = function (ph, context) {
	          return [new Tag(_PLACEHOLDER_TAG, { id: ph.name })];
	      };
	      _WriteVisitor.prototype.visitIcuPlaceholder = function (ph, context) {
	          return [new Tag(_PLACEHOLDER_TAG, { id: ph.name })];
	      };
	      _WriteVisitor.prototype.serialize = function (nodes) {
	          var _this = this;
	          this._isInIcu = false;
	          return ListWrapper.flatten(nodes.map(function (node) { return node.visit(_this); }));
	      };
	      return _WriteVisitor;
	  }());
	  // TODO(vicb): add error management (structure)
	  // TODO(vicb): factorize (xtb) ?
	  var _LoadVisitor = (function () {
	      function _LoadVisitor() {
	      }
	      _LoadVisitor.prototype.parse = function (nodes, messageBundle) {
	          var _this = this;
	          this._messageNodes = [];
	          this._translatedMessages = {};
	          this._msgId = '';
	          this._target = [];
	          this._errors = [];
	          // Find all messages
	          visitAll(this, nodes, null);
	          var messageMap = messageBundle.getMessageMap();
	          var placeholders = extractPlaceholders(messageBundle);
	          var placeholderToIds = extractPlaceholderToIds(messageBundle);
	          this._messageNodes
	              .filter(function (message) {
	              // Remove any messages that is not present in the source message bundle.
	              return messageMap.hasOwnProperty(message[0]);
	          })
	              .sort(function (a, b) {
	              // Because there could be no ICU placeholders inside an ICU message,
	              // we do not need to take into account the `placeholderToMsgIds` of the referenced
	              // messages, those would always be empty
	              // TODO(vicb): overkill - create 2 buckets and [...woDeps, ...wDeps].process()
	              if (Object.keys(messageMap[a[0]].placeholderToMsgIds).length == 0) {
	                  return -1;
	              }
	              if (Object.keys(messageMap[b[0]].placeholderToMsgIds).length == 0) {
	                  return 1;
	              }
	              return 0;
	          })
	              .forEach(function (message) {
	              var id = message[0];
	              _this._placeholders = placeholders[id] || {};
	              _this._placeholderToIds = placeholderToIds[id] || {};
	              // TODO(vicb): make sure there is no `_TRANSLATIONS_TAG` nor `_TRANSLATION_TAG`
	              _this._translatedMessages[id] = visitAll(_this, message[1]).join('');
	          });
	          return { messages: this._translatedMessages, errors: this._errors };
	      };
	      _LoadVisitor.prototype.visitElement = function (element, context) {
	          switch (element.name) {
	              case _UNIT_TAG:
	                  this._target = null;
	                  var msgId = element.attrs.find(function (attr) { return attr.name === 'id'; });
	                  if (!msgId) {
	                      this._addError(element, "<" + _UNIT_TAG + "> misses the \"id\" attribute");
	                  }
	                  else {
	                      this._msgId = msgId.value;
	                  }
	                  visitAll(this, element.children, null);
	                  if (this._msgId !== null) {
	                      this._messageNodes.push([this._msgId, this._target]);
	                  }
	                  break;
	              case _SOURCE_TAG:
	                  // ignore source message
	                  break;
	              case _TARGET_TAG:
	                  this._target = element.children;
	                  break;
	              case _PLACEHOLDER_TAG:
	                  var idAttr = element.attrs.find(function (attr) { return attr.name === 'id'; });
	                  if (!idAttr) {
	                      this._addError(element, "<" + _PLACEHOLDER_TAG + "> misses the \"id\" attribute");
	                  }
	                  else {
	                      var id = idAttr.value;
	                      if (this._placeholders.hasOwnProperty(id)) {
	                          return this._placeholders[id];
	                      }
	                      if (this._placeholderToIds.hasOwnProperty(id) &&
	                          this._translatedMessages.hasOwnProperty(this._placeholderToIds[id])) {
	                          return this._translatedMessages[this._placeholderToIds[id]];
	                      }
	                      // TODO(vicb): better error message for when
	                      // !this._translatedMessages.hasOwnProperty(this._placeholderToIds[id])
	                      this._addError(element, "The placeholder \"" + id + "\" does not exists in the source message");
	                  }
	                  break;
	              default:
	                  visitAll(this, element.children, null);
	          }
	      };
	      _LoadVisitor.prototype.visitAttribute = function (attribute, context) {
	          throw new Error('unreachable code');
	      };
	      _LoadVisitor.prototype.visitText = function (text, context) { return text.value; };
	      _LoadVisitor.prototype.visitComment = function (comment, context) { return ''; };
	      _LoadVisitor.prototype.visitExpansion = function (expansion, context) {
	          throw new Error('unreachable code');
	      };
	      _LoadVisitor.prototype.visitExpansionCase = function (expansionCase, context) {
	          throw new Error('unreachable code');
	      };
	      _LoadVisitor.prototype._addError = function (node, message) {
	          this._errors.push(new I18nError(node.sourceSpan, message));
	      };
	      return _LoadVisitor;
	  }());
	  function getCtypeForTag(tag) {
	      switch (tag.toLowerCase()) {
	          case 'br':
	              return 'lb';
	          case 'img':
	              return 'image';
	          default:
	              return "x-" + tag;
	      }
	  }

	  var _MESSAGES_TAG = 'messagebundle';
	  var _MESSAGE_TAG = 'msg';
	  var _PLACEHOLDER_TAG$1 = 'ph';
	  var _EXEMPLE_TAG = 'ex';
	  var _DOCTYPE = "<!ELEMENT messagebundle (msg)*>\n<!ATTLIST messagebundle class CDATA #IMPLIED>\n\n<!ELEMENT msg (#PCDATA|ph|source)*>\n<!ATTLIST msg id CDATA #IMPLIED>\n<!ATTLIST msg seq CDATA #IMPLIED>\n<!ATTLIST msg name CDATA #IMPLIED>\n<!ATTLIST msg desc CDATA #IMPLIED>\n<!ATTLIST msg meaning CDATA #IMPLIED>\n<!ATTLIST msg obsolete (obsolete) #IMPLIED>\n<!ATTLIST msg xml:space (default|preserve) \"default\">\n<!ATTLIST msg is_hidden CDATA #IMPLIED>\n\n<!ELEMENT source (#PCDATA)>\n\n<!ELEMENT ph (#PCDATA|ex)*>\n<!ATTLIST ph name CDATA #REQUIRED>\n\n<!ELEMENT ex (#PCDATA)>";
	  var Xmb = (function () {
	      function Xmb() {
	      }
	      Xmb.prototype.write = function (messageMap) {
	          var visitor = new _Visitor$2();
	          var rootNode = new Tag(_MESSAGES_TAG);
	          Object.keys(messageMap).forEach(function (id) {
	              var message = messageMap[id];
	              var attrs = { id: id };
	              if (message.description) {
	                  attrs['desc'] = message.description;
	              }
	              if (message.meaning) {
	                  attrs['meaning'] = message.meaning;
	              }
	              rootNode.children.push(new CR(2), new Tag(_MESSAGE_TAG, attrs, visitor.serialize(message.nodes)));
	          });
	          rootNode.children.push(new CR());
	          return serialize([
	              new Declaration({ version: '1.0', encoding: 'UTF-8' }),
	              new CR(),
	              new Doctype(_MESSAGES_TAG, _DOCTYPE),
	              new CR(),
	              rootNode,
	              new CR(),
	          ]);
	      };
	      Xmb.prototype.load = function (content, url, messageBundle) {
	          throw new Error('Unsupported');
	      };
	      return Xmb;
	  }());
	  var _Visitor$2 = (function () {
	      function _Visitor() {
	      }
	      _Visitor.prototype.visitText = function (text, context) { return [new Text$2(text.value)]; };
	      _Visitor.prototype.visitContainer = function (container, context) {
	          var _this = this;
	          var nodes = [];
	          container.children.forEach(function (node) { return nodes.push.apply(nodes, node.visit(_this)); });
	          return nodes;
	      };
	      _Visitor.prototype.visitIcu = function (icu, context) {
	          var _this = this;
	          var nodes = [new Text$2("{" + icu.expression + ", " + icu.type + ", ")];
	          Object.keys(icu.cases).forEach(function (c) {
	              nodes.push.apply(nodes, [new Text$2(c + " {")].concat(icu.cases[c].visit(_this), [new Text$2("} ")]));
	          });
	          nodes.push(new Text$2("}"));
	          return nodes;
	      };
	      _Visitor.prototype.visitTagPlaceholder = function (ph, context) {
	          var startEx = new Tag(_EXEMPLE_TAG, {}, [new Text$2("<" + ph.tag + ">")]);
	          var startTagPh = new Tag(_PLACEHOLDER_TAG$1, { name: ph.startName }, [startEx]);
	          if (ph.isVoid) {
	              // void tags have no children nor closing tags
	              return [startTagPh];
	          }
	          var closeEx = new Tag(_EXEMPLE_TAG, {}, [new Text$2("</" + ph.tag + ">")]);
	          var closeTagPh = new Tag(_PLACEHOLDER_TAG$1, { name: ph.closeName }, [closeEx]);
	          return [startTagPh].concat(this.serialize(ph.children), [closeTagPh]);
	      };
	      _Visitor.prototype.visitPlaceholder = function (ph, context) {
	          return [new Tag(_PLACEHOLDER_TAG$1, { name: ph.name })];
	      };
	      _Visitor.prototype.visitIcuPlaceholder = function (ph, context) {
	          return [new Tag(_PLACEHOLDER_TAG$1, { name: ph.name })];
	      };
	      _Visitor.prototype.serialize = function (nodes) {
	          var _this = this;
	          return ListWrapper.flatten(nodes.map(function (node) { return node.visit(_this); }));
	      };
	      return _Visitor;
	  }());

	  var _TRANSLATIONS_TAG = 'translationbundle';
	  var _TRANSLATION_TAG = 'translation';
	  var _PLACEHOLDER_TAG$2 = 'ph';
	  var Xtb = (function () {
	      function Xtb(_htmlParser, _interpolationConfig) {
	          this._htmlParser = _htmlParser;
	          this._interpolationConfig = _interpolationConfig;
	      }
	      Xtb.prototype.write = function (messageMap) { throw new Error('Unsupported'); };
	      Xtb.prototype.load = function (content, url, messageBundle) {
	          var _this = this;
	          // Parse the xtb file into xml nodes
	          var result = new XmlParser().parse(content, url);
	          if (result.errors.length) {
	              throw new Error("xtb parse errors:\n" + result.errors.join('\n'));
	          }
	          // Replace the placeholders, messages are now string
	          var _a = new _Visitor$3().parse(result.rootNodes, messageBundle), messages = _a.messages, errors = _a.errors;
	          if (errors.length) {
	              throw new Error("xtb parse errors:\n" + errors.join('\n'));
	          }
	          // Convert the string messages to html ast
	          // TODO(vicb): map error message back to the original message in xtb
	          var messageMap = {};
	          var parseErrors = [];
	          Object.keys(messages).forEach(function (id) {
	              var res = _this._htmlParser.parse(messages[id], url, true, _this._interpolationConfig);
	              parseErrors.push.apply(parseErrors, res.errors);
	              messageMap[id] = res.rootNodes;
	          });
	          if (parseErrors.length) {
	              throw new Error("xtb parse errors:\n" + parseErrors.join('\n'));
	          }
	          return messageMap;
	      };
	      return Xtb;
	  }());
	  var _Visitor$3 = (function () {
	      function _Visitor() {
	      }
	      _Visitor.prototype.parse = function (nodes, messageBundle) {
	          var _this = this;
	          this._messageNodes = [];
	          this._translatedMessages = {};
	          this._bundleDepth = 0;
	          this._translationDepth = 0;
	          this._errors = [];
	          // Find all messages
	          visitAll(this, nodes, null);
	          var messageMap = messageBundle.getMessageMap();
	          var placeholders = extractPlaceholders(messageBundle);
	          var placeholderToIds = extractPlaceholderToIds(messageBundle);
	          this._messageNodes
	              .filter(function (message) {
	              // Remove any messages that is not present in the source message bundle.
	              return messageMap.hasOwnProperty(message[0]);
	          })
	              .sort(function (a, b) {
	              // Because there could be no ICU placeholders inside an ICU message,
	              // we do not need to take into account the `placeholderToMsgIds` of the referenced
	              // messages, those would always be empty
	              // TODO(vicb): overkill - create 2 buckets and [...woDeps, ...wDeps].process()
	              if (Object.keys(messageMap[a[0]].placeholderToMsgIds).length == 0) {
	                  return -1;
	              }
	              if (Object.keys(messageMap[b[0]].placeholderToMsgIds).length == 0) {
	                  return 1;
	              }
	              return 0;
	          })
	              .forEach(function (message) {
	              var id = message[0];
	              _this._placeholders = placeholders[id] || {};
	              _this._placeholderToIds = placeholderToIds[id] || {};
	              // TODO(vicb): make sure there is no `_TRANSLATIONS_TAG` nor `_TRANSLATION_TAG`
	              _this._translatedMessages[id] = visitAll(_this, message[1]).join('');
	          });
	          return { messages: this._translatedMessages, errors: this._errors };
	      };
	      _Visitor.prototype.visitElement = function (element, context) {
	          switch (element.name) {
	              case _TRANSLATIONS_TAG:
	                  this._bundleDepth++;
	                  if (this._bundleDepth > 1) {
	                      this._addError(element, "<" + _TRANSLATIONS_TAG + "> elements can not be nested");
	                  }
	                  visitAll(this, element.children, null);
	                  this._bundleDepth--;
	                  break;
	              case _TRANSLATION_TAG:
	                  this._translationDepth++;
	                  if (this._translationDepth > 1) {
	                      this._addError(element, "<" + _TRANSLATION_TAG + "> elements can not be nested");
	                  }
	                  var idAttr = element.attrs.find(function (attr) { return attr.name === 'id'; });
	                  if (!idAttr) {
	                      this._addError(element, "<" + _TRANSLATION_TAG + "> misses the \"id\" attribute");
	                  }
	                  else {
	                      // ICU placeholders are reference to other messages.
	                      // The referenced message might not have been decoded yet.
	                      // We need to have all messages available to make sure deps are decoded first.
	                      // TODO(vicb): report an error on duplicate id
	                      this._messageNodes.push([idAttr.value, element.children]);
	                  }
	                  this._translationDepth--;
	                  break;
	              case _PLACEHOLDER_TAG$2:
	                  var nameAttr = element.attrs.find(function (attr) { return attr.name === 'name'; });
	                  if (!nameAttr) {
	                      this._addError(element, "<" + _PLACEHOLDER_TAG$2 + "> misses the \"name\" attribute");
	                  }
	                  else {
	                      var name_1 = nameAttr.value;
	                      if (this._placeholders.hasOwnProperty(name_1)) {
	                          return this._placeholders[name_1];
	                      }
	                      if (this._placeholderToIds.hasOwnProperty(name_1) &&
	                          this._translatedMessages.hasOwnProperty(this._placeholderToIds[name_1])) {
	                          return this._translatedMessages[this._placeholderToIds[name_1]];
	                      }
	                      // TODO(vicb): better error message for when
	                      // !this._translatedMessages.hasOwnProperty(this._placeholderToIds[name])
	                      this._addError(element, "The placeholder \"" + name_1 + "\" does not exists in the source message");
	                  }
	                  break;
	              default:
	                  this._addError(element, 'Unexpected tag');
	          }
	      };
	      _Visitor.prototype.visitAttribute = function (attribute, context) {
	          throw new Error('unreachable code');
	      };
	      _Visitor.prototype.visitText = function (text, context) { return text.value; };
	      _Visitor.prototype.visitComment = function (comment, context) { return ''; };
	      _Visitor.prototype.visitExpansion = function (expansion, context) {
	          var _this = this;
	          var strCases = expansion.cases.map(function (c) { return c.visit(_this, null); });
	          return "{" + expansion.switchValue + ", " + expansion.type + ", strCases.join(' ')}";
	      };
	      _Visitor.prototype.visitExpansionCase = function (expansionCase, context) {
	          return expansionCase.value + " {" + visitAll(this, expansionCase.expression, null) + "}";
	      };
	      _Visitor.prototype._addError = function (node, message) {
	          this._errors.push(new I18nError(node.sourceSpan, message));
	      };
	      return _Visitor;
	  }());

	  /**
	   * @license
	   * Copyright Google Inc. All Rights Reserved.
	   *
	   * Use of this source code is governed by an MIT-style license that can be
	   * found in the LICENSE file at https://angular.io/license
	   */
	  /**
	   * A container for translated messages
	   */
	  var TranslationBundle = (function () {
	      function TranslationBundle(_messageMap) {
	          if (_messageMap === void 0) { _messageMap = {}; }
	          this._messageMap = _messageMap;
	      }
	      TranslationBundle.load = function (content, url, messageBundle, serializer) {
	          return new TranslationBundle(serializer.load(content, url, messageBundle));
	      };
	      TranslationBundle.prototype.get = function (id) { return this._messageMap[id]; };
	      TranslationBundle.prototype.has = function (id) { return id in this._messageMap; };
	      return TranslationBundle;
	  }());

	  var I18NHtmlParser = (function () {
	      // TODO(vicb): transB.load() should not need a msgB & add transB.resolve(msgB,
	      // interpolationConfig)
	      // TODO(vicb): remove the interpolationConfig from the Xtb serializer
	      function I18NHtmlParser(_htmlParser, _translations, _translationsFormat) {
	          this._htmlParser = _htmlParser;
	          this._translations = _translations;
	          this._translationsFormat = _translationsFormat;
	      }
	      I18NHtmlParser.prototype.parse = function (source, url, parseExpansionForms, interpolationConfig) {
	          if (parseExpansionForms === void 0) { parseExpansionForms = false; }
	          if (interpolationConfig === void 0) { interpolationConfig = DEFAULT_INTERPOLATION_CONFIG; }
	          var parseResult = this._htmlParser.parse(source, url, parseExpansionForms, interpolationConfig);
	          if (!this._translations || this._translations === '') {
	              // Do not enable i18n when no translation bundle is provided
	              return parseResult;
	          }
	          // TODO(vicb): add support for implicit tags / attributes
	          var messageBundle = new MessageBundle(this._htmlParser, [], {});
	          var errors = messageBundle.updateFromTemplate(source, url, interpolationConfig);
	          if (errors && errors.length) {
	              return new ParseTreeResult(parseResult.rootNodes, parseResult.errors.concat(errors));
	          }
	          var serializer = this._createSerializer(interpolationConfig);
	          var translationBundle = TranslationBundle.load(this._translations, url, messageBundle, serializer);
	          return mergeTranslations(parseResult.rootNodes, translationBundle, interpolationConfig, [], {});
	      };
	      I18NHtmlParser.prototype._createSerializer = function (interpolationConfig) {
	          var format = (this._translationsFormat || 'xlf').toLowerCase();
	          switch (format) {
	              case 'xmb':
	                  return new Xmb();
	              case 'xtb':
	                  return new Xtb(this._htmlParser, interpolationConfig);
	              case 'xliff':
	              case 'xlf':
	              default:
	                  return new Xliff(this._htmlParser, interpolationConfig);
	          }
	      };
	      return I18NHtmlParser;
	  }());

	  var isDefaultChangeDetectionStrategy = _angular_core.__core_private__.isDefaultChangeDetectionStrategy;
	  var ChangeDetectorStatus = _angular_core.__core_private__.ChangeDetectorStatus;
	  var LifecycleHooks = _angular_core.__core_private__.LifecycleHooks;
	  var LIFECYCLE_HOOKS_VALUES = _angular_core.__core_private__.LIFECYCLE_HOOKS_VALUES;
	  var ReflectorReader = _angular_core.__core_private__.ReflectorReader;
	  var AppElement = _angular_core.__core_private__.AppElement;
	  var CodegenComponentFactoryResolver = _angular_core.__core_private__.CodegenComponentFactoryResolver;
	  var AppView = _angular_core.__core_private__.AppView;
	  var DebugAppView = _angular_core.__core_private__.DebugAppView;
	  var NgModuleInjector = _angular_core.__core_private__.NgModuleInjector;
	  var registerModuleFactory = _angular_core.__core_private__.registerModuleFactory;
	  var ViewType = _angular_core.__core_private__.ViewType;
	  var view_utils = _angular_core.__core_private__.view_utils;
	  var DebugContext = _angular_core.__core_private__.DebugContext;
	  var StaticNodeDebugInfo = _angular_core.__core_private__.StaticNodeDebugInfo;
	  var devModeEqual = _angular_core.__core_private__.devModeEqual;
	  var UNINITIALIZED = _angular_core.__core_private__.UNINITIALIZED;
	  var ValueUnwrapper = _angular_core.__core_private__.ValueUnwrapper;
	  var TemplateRef_ = _angular_core.__core_private__.TemplateRef_;
	  var Console = _angular_core.__core_private__.Console;
	  var reflector = _angular_core.__core_private__.reflector;
	  var Reflector = _angular_core.__core_private__.Reflector;
	  var ReflectionCapabilities = _angular_core.__core_private__.ReflectionCapabilities;
	  var NoOpAnimationPlayer = _angular_core.__core_private__.NoOpAnimationPlayer;
	  var AnimationSequencePlayer = _angular_core.__core_private__.AnimationSequencePlayer;
	  var AnimationGroupPlayer = _angular_core.__core_private__.AnimationGroupPlayer;
	  var AnimationKeyframe = _angular_core.__core_private__.AnimationKeyframe;
	  var AnimationStyles = _angular_core.__core_private__.AnimationStyles;
	  var ANY_STATE = _angular_core.__core_private__.ANY_STATE;
	  var DEFAULT_STATE = _angular_core.__core_private__.DEFAULT_STATE;
	  var EMPTY_ANIMATION_STATE = _angular_core.__core_private__.EMPTY_STATE;
	  var FILL_STYLE_FLAG = _angular_core.__core_private__.FILL_STYLE_FLAG;
	  var prepareFinalAnimationStyles = _angular_core.__core_private__.prepareFinalAnimationStyles;
	  var balanceAnimationKeyframes = _angular_core.__core_private__.balanceAnimationKeyframes;
	  var clearStyles = _angular_core.__core_private__.clearStyles;
	  var collectAndResolveStyles = _angular_core.__core_private__.collectAndResolveStyles;
	  var renderStyles = _angular_core.__core_private__.renderStyles;
	  var ComponentStillLoadingError = _angular_core.__core_private__.ComponentStillLoadingError;
	  var AnimationTransition = _angular_core.__core_private__.AnimationTransition;

	  var APP_VIEW_MODULE_URL = assetUrl('core', 'linker/view');
	  var VIEW_UTILS_MODULE_URL = assetUrl('core', 'linker/view_utils');
	  var CD_MODULE_URL = assetUrl('core', 'change_detection/change_detection');
	  var ANIMATION_STYLE_UTIL_ASSET_URL = assetUrl('core', 'animation/animation_style_util');
	  var Identifiers = (function () {
	      function Identifiers() {
	      }
	      Identifiers.ANALYZE_FOR_ENTRY_COMPONENTS = {
	          name: 'ANALYZE_FOR_ENTRY_COMPONENTS',
	          moduleUrl: assetUrl('core', 'metadata/di'),
	          runtime: _angular_core.ANALYZE_FOR_ENTRY_COMPONENTS
	      };
	      Identifiers.ViewUtils = {
	          name: 'ViewUtils',
	          moduleUrl: assetUrl('core', 'linker/view_utils'),
	          runtime: view_utils.ViewUtils
	      };
	      Identifiers.AppView = { name: 'AppView', moduleUrl: APP_VIEW_MODULE_URL, runtime: AppView };
	      Identifiers.DebugAppView = {
	          name: 'DebugAppView',
	          moduleUrl: APP_VIEW_MODULE_URL,
	          runtime: DebugAppView
	      };
	      Identifiers.AppElement = {
	          name: 'AppElement',
	          moduleUrl: assetUrl('core', 'linker/element'),
	          runtime: AppElement
	      };
	      Identifiers.ElementRef = {
	          name: 'ElementRef',
	          moduleUrl: assetUrl('core', 'linker/element_ref'),
	          runtime: _angular_core.ElementRef
	      };
	      Identifiers.ViewContainerRef = {
	          name: 'ViewContainerRef',
	          moduleUrl: assetUrl('core', 'linker/view_container_ref'),
	          runtime: _angular_core.ViewContainerRef
	      };
	      Identifiers.ChangeDetectorRef = {
	          name: 'ChangeDetectorRef',
	          moduleUrl: assetUrl('core', 'change_detection/change_detector_ref'),
	          runtime: _angular_core.ChangeDetectorRef
	      };
	      Identifiers.RenderComponentType = {
	          name: 'RenderComponentType',
	          moduleUrl: assetUrl('core', 'render/api'),
	          runtime: _angular_core.RenderComponentType
	      };
	      Identifiers.QueryList = {
	          name: 'QueryList',
	          moduleUrl: assetUrl('core', 'linker/query_list'),
	          runtime: _angular_core.QueryList
	      };
	      Identifiers.TemplateRef = {
	          name: 'TemplateRef',
	          moduleUrl: assetUrl('core', 'linker/template_ref'),
	          runtime: _angular_core.TemplateRef
	      };
	      Identifiers.TemplateRef_ = {
	          name: 'TemplateRef_',
	          moduleUrl: assetUrl('core', 'linker/template_ref'),
	          runtime: TemplateRef_
	      };
	      Identifiers.CodegenComponentFactoryResolver = {
	          name: 'CodegenComponentFactoryResolver',
	          moduleUrl: assetUrl('core', 'linker/component_factory_resolver'),
	          runtime: CodegenComponentFactoryResolver
	      };
	      Identifiers.ComponentFactoryResolver = {
	          name: 'ComponentFactoryResolver',
	          moduleUrl: assetUrl('core', 'linker/component_factory_resolver'),
	          runtime: _angular_core.ComponentFactoryResolver
	      };
	      Identifiers.ComponentFactory = {
	          name: 'ComponentFactory',
	          runtime: _angular_core.ComponentFactory,
	          moduleUrl: assetUrl('core', 'linker/component_factory')
	      };
	      Identifiers.NgModuleFactory = {
	          name: 'NgModuleFactory',
	          runtime: _angular_core.NgModuleFactory,
	          moduleUrl: assetUrl('core', 'linker/ng_module_factory')
	      };
	      Identifiers.NgModuleInjector = {
	          name: 'NgModuleInjector',
	          runtime: NgModuleInjector,
	          moduleUrl: assetUrl('core', 'linker/ng_module_factory')
	      };
	      Identifiers.RegisterModuleFactoryFn = {
	          name: 'registerModuleFactory',
	          runtime: registerModuleFactory,
	          moduleUrl: assetUrl('core', 'linker/ng_module_factory_loader')
	      };
	      Identifiers.ValueUnwrapper = { name: 'ValueUnwrapper', moduleUrl: CD_MODULE_URL, runtime: ValueUnwrapper };
	      Identifiers.Injector = {
	          name: 'Injector',
	          moduleUrl: assetUrl('core', 'di/injector'),
	          runtime: _angular_core.Injector
	      };
	      Identifiers.ViewEncapsulation = {
	          name: 'ViewEncapsulation',
	          moduleUrl: assetUrl('core', 'metadata/view'),
	          runtime: _angular_core.ViewEncapsulation
	      };
	      Identifiers.ViewType = {
	          name: 'ViewType',
	          moduleUrl: assetUrl('core', 'linker/view_type'),
	          runtime: ViewType
	      };
	      Identifiers.ChangeDetectionStrategy = {
	          name: 'ChangeDetectionStrategy',
	          moduleUrl: CD_MODULE_URL,
	          runtime: _angular_core.ChangeDetectionStrategy
	      };
	      Identifiers.StaticNodeDebugInfo = {
	          name: 'StaticNodeDebugInfo',
	          moduleUrl: assetUrl('core', 'linker/debug_context'),
	          runtime: StaticNodeDebugInfo
	      };
	      Identifiers.DebugContext = {
	          name: 'DebugContext',
	          moduleUrl: assetUrl('core', 'linker/debug_context'),
	          runtime: DebugContext
	      };
	      Identifiers.Renderer = {
	          name: 'Renderer',
	          moduleUrl: assetUrl('core', 'render/api'),
	          runtime: _angular_core.Renderer
	      };
	      Identifiers.SimpleChange = { name: 'SimpleChange', moduleUrl: CD_MODULE_URL, runtime: _angular_core.SimpleChange };
	      Identifiers.UNINITIALIZED = { name: 'UNINITIALIZED', moduleUrl: CD_MODULE_URL, runtime: UNINITIALIZED };
	      Identifiers.ChangeDetectorStatus = {
	          name: 'ChangeDetectorStatus',
	          moduleUrl: CD_MODULE_URL,
	          runtime: ChangeDetectorStatus
	      };
	      Identifiers.checkBinding = {
	          name: 'checkBinding',
	          moduleUrl: VIEW_UTILS_MODULE_URL,
	          runtime: view_utils.checkBinding
	      };
	      Identifiers.flattenNestedViewRenderNodes = {
	          name: 'flattenNestedViewRenderNodes',
	          moduleUrl: VIEW_UTILS_MODULE_URL,
	          runtime: view_utils.flattenNestedViewRenderNodes
	      };
	      Identifiers.devModeEqual = { name: 'devModeEqual', moduleUrl: CD_MODULE_URL, runtime: devModeEqual };
	      Identifiers.interpolate = {
	          name: 'interpolate',
	          moduleUrl: VIEW_UTILS_MODULE_URL,
	          runtime: view_utils.interpolate
	      };
	      Identifiers.castByValue = {
	          name: 'castByValue',
	          moduleUrl: VIEW_UTILS_MODULE_URL,
	          runtime: view_utils.castByValue
	      };
	      Identifiers.EMPTY_ARRAY = {
	          name: 'EMPTY_ARRAY',
	          moduleUrl: VIEW_UTILS_MODULE_URL,
	          runtime: view_utils.EMPTY_ARRAY
	      };
	      Identifiers.EMPTY_MAP = {
	          name: 'EMPTY_MAP',
	          moduleUrl: VIEW_UTILS_MODULE_URL,
	          runtime: view_utils.EMPTY_MAP
	      };
	      Identifiers.createRenderElement = {
	          name: 'createRenderElement',
	          moduleUrl: VIEW_UTILS_MODULE_URL,
	          runtime: view_utils.createRenderElement
	      };
	      Identifiers.selectOrCreateRenderHostElement = {
	          name: 'selectOrCreateRenderHostElement',
	          moduleUrl: VIEW_UTILS_MODULE_URL,
	          runtime: view_utils.selectOrCreateRenderHostElement
	      };
	      Identifiers.pureProxies = [
	          null,
	          { name: 'pureProxy1', moduleUrl: VIEW_UTILS_MODULE_URL, runtime: view_utils.pureProxy1 },
	          { name: 'pureProxy2', moduleUrl: VIEW_UTILS_MODULE_URL, runtime: view_utils.pureProxy2 },
	          { name: 'pureProxy3', moduleUrl: VIEW_UTILS_MODULE_URL, runtime: view_utils.pureProxy3 },
	          { name: 'pureProxy4', moduleUrl: VIEW_UTILS_MODULE_URL, runtime: view_utils.pureProxy4 },
	          { name: 'pureProxy5', moduleUrl: VIEW_UTILS_MODULE_URL, runtime: view_utils.pureProxy5 },
	          { name: 'pureProxy6', moduleUrl: VIEW_UTILS_MODULE_URL, runtime: view_utils.pureProxy6 },
	          { name: 'pureProxy7', moduleUrl: VIEW_UTILS_MODULE_URL, runtime: view_utils.pureProxy7 },
	          { name: 'pureProxy8', moduleUrl: VIEW_UTILS_MODULE_URL, runtime: view_utils.pureProxy8 },
	          { name: 'pureProxy9', moduleUrl: VIEW_UTILS_MODULE_URL, runtime: view_utils.pureProxy9 },
	          { name: 'pureProxy10', moduleUrl: VIEW_UTILS_MODULE_URL, runtime: view_utils.pureProxy10 },
	      ];
	      Identifiers.SecurityContext = {
	          name: 'SecurityContext',
	          moduleUrl: assetUrl('core', 'security'),
	          runtime: _angular_core.SecurityContext,
	      };
	      Identifiers.AnimationKeyframe = {
	          name: 'AnimationKeyframe',
	          moduleUrl: assetUrl('core', 'animation/animation_keyframe'),
	          runtime: AnimationKeyframe
	      };
	      Identifiers.AnimationStyles = {
	          name: 'AnimationStyles',
	          moduleUrl: assetUrl('core', 'animation/animation_styles'),
	          runtime: AnimationStyles
	      };
	      Identifiers.NoOpAnimationPlayer = {
	          name: 'NoOpAnimationPlayer',
	          moduleUrl: assetUrl('core', 'animation/animation_player'),
	          runtime: NoOpAnimationPlayer
	      };
	      Identifiers.AnimationGroupPlayer = {
	          name: 'AnimationGroupPlayer',
	          moduleUrl: assetUrl('core', 'animation/animation_group_player'),
	          runtime: AnimationGroupPlayer
	      };
	      Identifiers.AnimationSequencePlayer = {
	          name: 'AnimationSequencePlayer',
	          moduleUrl: assetUrl('core', 'animation/animation_sequence_player'),
	          runtime: AnimationSequencePlayer
	      };
	      Identifiers.prepareFinalAnimationStyles = {
	          name: 'prepareFinalAnimationStyles',
	          moduleUrl: ANIMATION_STYLE_UTIL_ASSET_URL,
	          runtime: prepareFinalAnimationStyles
	      };
	      Identifiers.balanceAnimationKeyframes = {
	          name: 'balanceAnimationKeyframes',
	          moduleUrl: ANIMATION_STYLE_UTIL_ASSET_URL,
	          runtime: balanceAnimationKeyframes
	      };
	      Identifiers.clearStyles = {
	          name: 'clearStyles',
	          moduleUrl: ANIMATION_STYLE_UTIL_ASSET_URL,
	          runtime: clearStyles
	      };
	      Identifiers.renderStyles = {
	          name: 'renderStyles',
	          moduleUrl: ANIMATION_STYLE_UTIL_ASSET_URL,
	          runtime: renderStyles
	      };
	      Identifiers.collectAndResolveStyles = {
	          name: 'collectAndResolveStyles',
	          moduleUrl: ANIMATION_STYLE_UTIL_ASSET_URL,
	          runtime: collectAndResolveStyles
	      };
	      Identifiers.LOCALE_ID = {
	          name: 'LOCALE_ID',
	          moduleUrl: assetUrl('core', 'i18n/tokens'),
	          runtime: _angular_core.LOCALE_ID
	      };
	      Identifiers.TRANSLATIONS_FORMAT = {
	          name: 'TRANSLATIONS_FORMAT',
	          moduleUrl: assetUrl('core', 'i18n/tokens'),
	          runtime: _angular_core.TRANSLATIONS_FORMAT
	      };
	      Identifiers.setBindingDebugInfo = {
	          name: 'setBindingDebugInfo',
	          moduleUrl: VIEW_UTILS_MODULE_URL,
	          runtime: view_utils.setBindingDebugInfo
	      };
	      Identifiers.setBindingDebugInfoForChanges = {
	          name: 'setBindingDebugInfoForChanges',
	          moduleUrl: VIEW_UTILS_MODULE_URL,
	          runtime: view_utils.setBindingDebugInfoForChanges
	      };
	      Identifiers.AnimationTransition = {
	          name: 'AnimationTransition',
	          moduleUrl: assetUrl('core', 'animation/animation_transition'),
	          runtime: AnimationTransition
	      };
	      // This is just the interface!
	      Identifiers.InlineArray = { name: 'InlineArray', moduleUrl: VIEW_UTILS_MODULE_URL, runtime: null };
	      Identifiers.inlineArrays = [
	          { name: 'InlineArray2', moduleUrl: VIEW_UTILS_MODULE_URL, runtime: view_utils.InlineArray2 },
	          { name: 'InlineArray2', moduleUrl: VIEW_UTILS_MODULE_URL, runtime: view_utils.InlineArray2 },
	          { name: 'InlineArray4', moduleUrl: VIEW_UTILS_MODULE_URL, runtime: view_utils.InlineArray4 },
	          { name: 'InlineArray8', moduleUrl: VIEW_UTILS_MODULE_URL, runtime: view_utils.InlineArray8 },
	          { name: 'InlineArray16', moduleUrl: VIEW_UTILS_MODULE_URL, runtime: view_utils.InlineArray16 },
	      ];
	      Identifiers.EMPTY_INLINE_ARRAY = {
	          name: 'EMPTY_INLINE_ARRAY',
	          moduleUrl: VIEW_UTILS_MODULE_URL,
	          runtime: view_utils.EMPTY_INLINE_ARRAY
	      };
	      Identifiers.InlineArrayDynamic = {
	          name: 'InlineArrayDynamic',
	          moduleUrl: VIEW_UTILS_MODULE_URL,
	          runtime: view_utils.InlineArrayDynamic
	      };
	      return Identifiers;
	  }());
	  function assetUrl(pkg, path, type) {
	      if (path === void 0) { path = null; }
	      if (type === void 0) { type = 'src'; }
	      if (path == null) {
	          return "asset:@angular/lib/" + pkg + "/index";
	      }
	      else {
	          return "asset:@angular/lib/" + pkg + "/src/" + path;
	      }
	  }
	  function resolveIdentifier(identifier) {
	      return new CompileIdentifierMetadata({
	          name: identifier.name,
	          moduleUrl: identifier.moduleUrl,
	          reference: reflector.resolveIdentifier(identifier.name, identifier.moduleUrl, identifier.runtime)
	      });
	  }
	  function identifierToken(identifier) {
	      return new CompileTokenMetadata({ identifier: identifier });
	  }
	  function resolveIdentifierToken(identifier) {
	      return identifierToken(resolveIdentifier(identifier));
	  }
	  function resolveEnumIdentifier(enumType, name) {
	      var resolvedEnum = reflector.resolveEnum(enumType.reference, name);
	      return new CompileIdentifierMetadata({ name: enumType.name + "." + name, moduleUrl: enumType.moduleUrl, reference: resolvedEnum });
	  }

	  /**
	   * @license
	   * Copyright Google Inc. All Rights Reserved.
	   *
	   * Use of this source code is governed by an MIT-style license that can be
	   * found in the LICENSE file at https://angular.io/license
	   */
	  var __extends$8 = (this && this.__extends) || function (d, b) {
	      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	      function __() { this.constructor = d; }
	      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	  };
	  var HtmlParser = (function (_super) {
	      __extends$8(HtmlParser, _super);
	      function HtmlParser() {
	          _super.call(this, getHtmlTagDefinition);
	      }
	      HtmlParser.prototype.parse = function (source, url, parseExpansionForms, interpolationConfig) {
	          if (parseExpansionForms === void 0) { parseExpansionForms = false; }
	          if (interpolationConfig === void 0) { interpolationConfig = DEFAULT_INTERPOLATION_CONFIG; }
	          return _super.prototype.parse.call(this, source, url, parseExpansionForms, interpolationConfig);
	      };
	      HtmlParser.decorators = [
	          { type: _angular_core.Injectable },
	      ];
	      /** @nocollapse */
	      HtmlParser.ctorParameters = [];
	      return HtmlParser;
	  }(Parser$1));

	  /**
	   * @license
	   * Copyright Google Inc. All Rights Reserved.
	   *
	   * Use of this source code is governed by an MIT-style license that can be
	   * found in the LICENSE file at https://angular.io/license
	   */
	  var __extends$9 = (this && this.__extends) || function (d, b) {
	      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	      function __() { this.constructor = d; }
	      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	  };
	  // http://cldr.unicode.org/index/cldr-spec/plural-rules
	  var PLURAL_CASES = ['zero', 'one', 'two', 'few', 'many', 'other'];
	  /**
	   * Expands special forms into elements.
	   *
	   * For example,
	   *
	   * ```
	   * { messages.length, plural,
	   *   =0 {zero}
	   *   =1 {one}
	   *   other {more than one}
	   * }
	   * ```
	   *
	   * will be expanded into
	   *
	   * ```
	   * <ng-container [ngPlural]="messages.length">
	   *   <template ngPluralCase="=0">zero</ng-container>
	   *   <template ngPluralCase="=1">one</ng-container>
	   *   <template ngPluralCase="other">more than one</ng-container>
	   * </ng-container>
	   * ```
	   */
	  function expandNodes(nodes) {
	      var expander = new _Expander();
	      return new ExpansionResult(visitAll(expander, nodes), expander.isExpanded, expander.errors);
	  }
	  var ExpansionResult = (function () {
	      function ExpansionResult(nodes, expanded, errors) {
	          this.nodes = nodes;
	          this.expanded = expanded;
	          this.errors = errors;
	      }
	      return ExpansionResult;
	  }());
	  var ExpansionError = (function (_super) {
	      __extends$9(ExpansionError, _super);
	      function ExpansionError(span, errorMsg) {
	          _super.call(this, span, errorMsg);
	      }
	      return ExpansionError;
	  }(ParseError));
	  /**
	   * Expand expansion forms (plural, select) to directives
	   *
	   * @internal
	   */
	  var _Expander = (function () {
	      function _Expander() {
	          this.isExpanded = false;
	          this.errors = [];
	      }
	      _Expander.prototype.visitElement = function (element, context) {
	          return new Element(element.name, element.attrs, visitAll(this, element.children), element.sourceSpan, element.startSourceSpan, element.endSourceSpan);
	      };
	      _Expander.prototype.visitAttribute = function (attribute, context) { return attribute; };
	      _Expander.prototype.visitText = function (text, context) { return text; };
	      _Expander.prototype.visitComment = function (comment, context) { return comment; };
	      _Expander.prototype.visitExpansion = function (icu, context) {
	          this.isExpanded = true;
	          return icu.type == 'plural' ? _expandPluralForm(icu, this.errors) :
	              _expandDefaultForm(icu, this.errors);
	      };
	      _Expander.prototype.visitExpansionCase = function (icuCase, context) {
	          throw new Error('Should not be reached');
	      };
	      return _Expander;
	  }());
	  function _expandPluralForm(ast, errors) {
	      var children = ast.cases.map(function (c) {
	          if (PLURAL_CASES.indexOf(c.value) == -1 && !c.value.match(/^=\d+$/)) {
	              errors.push(new ExpansionError(c.valueSourceSpan, "Plural cases should be \"=<number>\" or one of " + PLURAL_CASES.join(", ")));
	          }
	          var expansionResult = expandNodes(c.expression);
	          errors.push.apply(errors, expansionResult.errors);
	          return new Element("template", [new Attribute$1('ngPluralCase', "" + c.value, c.valueSourceSpan)], expansionResult.nodes, c.sourceSpan, c.sourceSpan, c.sourceSpan);
	      });
	      var switchAttr = new Attribute$1('[ngPlural]', ast.switchValue, ast.switchValueSourceSpan);
	      return new Element('ng-container', [switchAttr], children, ast.sourceSpan, ast.sourceSpan, ast.sourceSpan);
	  }
	  function _expandDefaultForm(ast, errors) {
	      var children = ast.cases.map(function (c) {
	          var expansionResult = expandNodes(c.expression);
	          errors.push.apply(errors, expansionResult.errors);
	          return new Element("template", [new Attribute$1('ngSwitchCase', "" + c.value, c.valueSourceSpan)], expansionResult.nodes, c.sourceSpan, c.sourceSpan, c.sourceSpan);
	      });
	      var switchAttr = new Attribute$1('[ngSwitch]', ast.switchValue, ast.switchValueSourceSpan);
	      return new Element('ng-container', [switchAttr], children, ast.sourceSpan, ast.sourceSpan, ast.sourceSpan);
	  }

	  /**
	   * @license
	   * Copyright Google Inc. All Rights Reserved.
	   *
	   * Use of this source code is governed by an MIT-style license that can be
	   * found in the LICENSE file at https://angular.io/license
	   */
	  var __extends$10 = (this && this.__extends) || function (d, b) {
	      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	      function __() { this.constructor = d; }
	      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	  };
	  var ProviderError = (function (_super) {
	      __extends$10(ProviderError, _super);
	      function ProviderError(message, span) {
	          _super.call(this, span, message);
	      }
	      return ProviderError;
	  }(ParseError));
	  var ProviderViewContext = (function () {
	      function ProviderViewContext(component, sourceSpan) {
	          var _this = this;
	          this.component = component;
	          this.sourceSpan = sourceSpan;
	          this.errors = [];
	          this.viewQueries = _getViewQueries(component);
	          this.viewProviders = new Map();
	          _normalizeProviders(component.viewProviders, sourceSpan, this.errors).forEach(function (provider) {
	              if (isBlank(_this.viewProviders.get(provider.token.reference))) {
	                  _this.viewProviders.set(provider.token.reference, true);
	              }
	          });
	      }
	      return ProviderViewContext;
	  }());
	  var ProviderElementContext = (function () {
	      function ProviderElementContext(viewContext, _parent, _isViewRoot, _directiveAsts, attrs, refs, _sourceSpan) {
	          var _this = this;
	          this.viewContext = viewContext;
	          this._parent = _parent;
	          this._isViewRoot = _isViewRoot;
	          this._directiveAsts = _directiveAsts;
	          this._sourceSpan = _sourceSpan;
	          this._transformedProviders = new Map();
	          this._seenProviders = new Map();
	          this._hasViewContainer = false;
	          this._attrs = {};
	          attrs.forEach(function (attrAst) { return _this._attrs[attrAst.name] = attrAst.value; });
	          var directivesMeta = _directiveAsts.map(function (directiveAst) { return directiveAst.directive; });
	          this._allProviders =
	              _resolveProvidersFromDirectives(directivesMeta, _sourceSpan, viewContext.errors);
	          this._contentQueries = _getContentQueries(directivesMeta);
	          var queriedTokens = new Map();
	          MapWrapper.values(this._allProviders).forEach(function (provider) {
	              _this._addQueryReadsTo(provider.token, queriedTokens);
	          });
	          refs.forEach(function (refAst) {
	              _this._addQueryReadsTo(new CompileTokenMetadata({ value: refAst.name }), queriedTokens);
	          });
	          if (isPresent(queriedTokens.get(resolveIdentifierToken(Identifiers.ViewContainerRef).reference))) {
	              this._hasViewContainer = true;
	          }
	          // create the providers that we know are eager first
	          MapWrapper.values(this._allProviders).forEach(function (provider) {
	              var eager = provider.eager || isPresent(queriedTokens.get(provider.token.reference));
	              if (eager) {
	                  _this._getOrCreateLocalProvider(provider.providerType, provider.token, true);
	              }
	          });
	      }
	      ProviderElementContext.prototype.afterElement = function () {
	          var _this = this;
	          // collect lazy providers
	          MapWrapper.values(this._allProviders).forEach(function (provider) {
	              _this._getOrCreateLocalProvider(provider.providerType, provider.token, false);
	          });
	      };
	      Object.defineProperty(ProviderElementContext.prototype, "transformProviders", {
	          get: function () { return MapWrapper.values(this._transformedProviders); },
	          enumerable: true,
	          configurable: true
	      });
	      Object.defineProperty(ProviderElementContext.prototype, "transformedDirectiveAsts", {
	          get: function () {
	              var sortedProviderTypes = this.transformProviders.map(function (provider) { return provider.token.identifier; });
	              var sortedDirectives = this._directiveAsts.slice();
	              sortedDirectives.sort(function (dir1, dir2) { return sortedProviderTypes.indexOf(dir1.directive.type) -
	                  sortedProviderTypes.indexOf(dir2.directive.type); });
	              return sortedDirectives;
	          },
	          enumerable: true,
	          configurable: true
	      });
	      Object.defineProperty(ProviderElementContext.prototype, "transformedHasViewContainer", {
	          get: function () { return this._hasViewContainer; },
	          enumerable: true,
	          configurable: true
	      });
	      ProviderElementContext.prototype._addQueryReadsTo = function (token, queryReadTokens) {
	          this._getQueriesFor(token).forEach(function (query) {
	              var queryReadToken = query.read || token;
	              if (isBlank(queryReadTokens.get(queryReadToken.reference))) {
	                  queryReadTokens.set(queryReadToken.reference, true);
	              }
	          });
	      };
	      ProviderElementContext.prototype._getQueriesFor = function (token) {
	          var result = [];
	          var currentEl = this;
	          var distance = 0;
	          var queries;
	          while (currentEl !== null) {
	              queries = currentEl._contentQueries.get(token.reference);
	              if (isPresent(queries)) {
	                  result.push.apply(result, queries.filter(function (query) { return query.descendants || distance <= 1; }));
	              }
	              if (currentEl._directiveAsts.length > 0) {
	                  distance++;
	              }
	              currentEl = currentEl._parent;
	          }
	          queries = this.viewContext.viewQueries.get(token.reference);
	          if (isPresent(queries)) {
	              result.push.apply(result, queries);
	          }
	          return result;
	      };
	      ProviderElementContext.prototype._getOrCreateLocalProvider = function (requestingProviderType, token, eager) {
	          var _this = this;
	          var resolvedProvider = this._allProviders.get(token.reference);
	          if (!resolvedProvider || ((requestingProviderType === exports.ProviderAstType.Directive ||
	              requestingProviderType === exports.ProviderAstType.PublicService) &&
	              resolvedProvider.providerType === exports.ProviderAstType.PrivateService) ||
	              ((requestingProviderType === exports.ProviderAstType.PrivateService ||
	                  requestingProviderType === exports.ProviderAstType.PublicService) &&
	                  resolvedProvider.providerType === exports.ProviderAstType.Builtin)) {
	              return null;
	          }
	          var transformedProviderAst = this._transformedProviders.get(token.reference);
	          if (isPresent(transformedProviderAst)) {
	              return transformedProviderAst;
	          }
	          if (isPresent(this._seenProviders.get(token.reference))) {
	              this.viewContext.errors.push(new ProviderError("Cannot instantiate cyclic dependency! " + token.name, this._sourceSpan));
	              return null;
	          }
	          this._seenProviders.set(token.reference, true);
	          var transformedProviders = resolvedProvider.providers.map(function (provider) {
	              var transformedUseValue = provider.useValue;
	              var transformedUseExisting = provider.useExisting;
	              var transformedDeps;
	              if (isPresent(provider.useExisting)) {
	                  var existingDiDep = _this._getDependency(resolvedProvider.providerType, new CompileDiDependencyMetadata({ token: provider.useExisting }), eager);
	                  if (isPresent(existingDiDep.token)) {
	                      transformedUseExisting = existingDiDep.token;
	                  }
	                  else {
	                      transformedUseExisting = null;
	                      transformedUseValue = existingDiDep.value;
	                  }
	              }
	              else if (isPresent(provider.useFactory)) {
	                  var deps = provider.deps || provider.useFactory.diDeps;
	                  transformedDeps =
	                      deps.map(function (dep) { return _this._getDependency(resolvedProvider.providerType, dep, eager); });
	              }
	              else if (isPresent(provider.useClass)) {
	                  var deps = provider.deps || provider.useClass.diDeps;
	                  transformedDeps =
	                      deps.map(function (dep) { return _this._getDependency(resolvedProvider.providerType, dep, eager); });
	              }
	              return _transformProvider(provider, {
	                  useExisting: transformedUseExisting,
	                  useValue: transformedUseValue,
	                  deps: transformedDeps
	              });
	          });
	          transformedProviderAst =
	              _transformProviderAst(resolvedProvider, { eager: eager, providers: transformedProviders });
	          this._transformedProviders.set(token.reference, transformedProviderAst);
	          return transformedProviderAst;
	      };
	      ProviderElementContext.prototype._getLocalDependency = function (requestingProviderType, dep, eager) {
	          if (eager === void 0) { eager = null; }
	          if (dep.isAttribute) {
	              var attrValue = this._attrs[dep.token.value];
	              return new CompileDiDependencyMetadata({ isValue: true, value: attrValue == null ? null : attrValue });
	          }
	          if (isPresent(dep.query) || isPresent(dep.viewQuery)) {
	              return dep;
	          }
	          if (isPresent(dep.token)) {
	              // access builtints
	              if ((requestingProviderType === exports.ProviderAstType.Directive ||
	                  requestingProviderType === exports.ProviderAstType.Component)) {
	                  if (dep.token.reference === resolveIdentifierToken(Identifiers.Renderer).reference ||
	                      dep.token.reference === resolveIdentifierToken(Identifiers.ElementRef).reference ||
	                      dep.token.reference ===
	                          resolveIdentifierToken(Identifiers.ChangeDetectorRef).reference ||
	                      dep.token.reference === resolveIdentifierToken(Identifiers.TemplateRef).reference) {
	                      return dep;
	                  }
	                  if (dep.token.reference ===
	                      resolveIdentifierToken(Identifiers.ViewContainerRef).reference) {
	                      this._hasViewContainer = true;
	                  }
	              }
	              // access the injector
	              if (dep.token.reference === resolveIdentifierToken(Identifiers.Injector).reference) {
	                  return dep;
	              }
	              // access providers
	              if (isPresent(this._getOrCreateLocalProvider(requestingProviderType, dep.token, eager))) {
	                  return dep;
	              }
	          }
	          return null;
	      };
	      ProviderElementContext.prototype._getDependency = function (requestingProviderType, dep, eager) {
	          if (eager === void 0) { eager = null; }
	          var currElement = this;
	          var currEager = eager;
	          var result = null;
	          if (!dep.isSkipSelf) {
	              result = this._getLocalDependency(requestingProviderType, dep, eager);
	          }
	          if (dep.isSelf) {
	              if (!result && dep.isOptional) {
	                  result = new CompileDiDependencyMetadata({ isValue: true, value: null });
	              }
	          }
	          else {
	              // check parent elements
	              while (!result && isPresent(currElement._parent)) {
	                  var prevElement = currElement;
	                  currElement = currElement._parent;
	                  if (prevElement._isViewRoot) {
	                      currEager = false;
	                  }
	                  result = currElement._getLocalDependency(exports.ProviderAstType.PublicService, dep, currEager);
	              }
	              // check @Host restriction
	              if (!result) {
	                  if (!dep.isHost || this.viewContext.component.type.isHost ||
	                      this.viewContext.component.type.reference === dep.token.reference ||
	                      isPresent(this.viewContext.viewProviders.get(dep.token.reference))) {
	                      result = dep;
	                  }
	                  else {
	                      result = dep.isOptional ?
	                          result = new CompileDiDependencyMetadata({ isValue: true, value: null }) :
	                          null;
	                  }
	              }
	          }
	          if (!result) {
	              this.viewContext.errors.push(new ProviderError("No provider for " + dep.token.name, this._sourceSpan));
	          }
	          return result;
	      };
	      return ProviderElementContext;
	  }());
	  var NgModuleProviderAnalyzer = (function () {
	      function NgModuleProviderAnalyzer(ngModule, extraProviders, sourceSpan) {
	          var _this = this;
	          this._transformedProviders = new Map();
	          this._seenProviders = new Map();
	          this._errors = [];
	          this._allProviders = new Map();
	          var ngModuleTypes = ngModule.transitiveModule.modules.map(function (moduleMeta) { return moduleMeta.type; });
	          ngModuleTypes.forEach(function (ngModuleType) {
	              var ngModuleProvider = new CompileProviderMetadata({ token: new CompileTokenMetadata({ identifier: ngModuleType }), useClass: ngModuleType });
	              _resolveProviders([ngModuleProvider], exports.ProviderAstType.PublicService, true, sourceSpan, _this._errors, _this._allProviders);
	          });
	          _resolveProviders(_normalizeProviders(ngModule.transitiveModule.providers.concat(extraProviders), sourceSpan, this._errors), exports.ProviderAstType.PublicService, false, sourceSpan, this._errors, this._allProviders);
	      }
	      NgModuleProviderAnalyzer.prototype.parse = function () {
	          var _this = this;
	          MapWrapper.values(this._allProviders).forEach(function (provider) {
	              _this._getOrCreateLocalProvider(provider.token, provider.eager);
	          });
	          if (this._errors.length > 0) {
	              var errorString = this._errors.join('\n');
	              throw new Error("Provider parse errors:\n" + errorString);
	          }
	          return MapWrapper.values(this._transformedProviders);
	      };
	      NgModuleProviderAnalyzer.prototype._getOrCreateLocalProvider = function (token, eager) {
	          var _this = this;
	          var resolvedProvider = this._allProviders.get(token.reference);
	          if (!resolvedProvider) {
	              return null;
	          }
	          var transformedProviderAst = this._transformedProviders.get(token.reference);
	          if (isPresent(transformedProviderAst)) {
	              return transformedProviderAst;
	          }
	          if (isPresent(this._seenProviders.get(token.reference))) {
	              this._errors.push(new ProviderError("Cannot instantiate cyclic dependency! " + token.name, resolvedProvider.sourceSpan));
	              return null;
	          }
	          this._seenProviders.set(token.reference, true);
	          var transformedProviders = resolvedProvider.providers.map(function (provider) {
	              var transformedUseValue = provider.useValue;
	              var transformedUseExisting = provider.useExisting;
	              var transformedDeps;
	              if (isPresent(provider.useExisting)) {
	                  var existingDiDep = _this._getDependency(new CompileDiDependencyMetadata({ token: provider.useExisting }), eager, resolvedProvider.sourceSpan);
	                  if (isPresent(existingDiDep.token)) {
	                      transformedUseExisting = existingDiDep.token;
	                  }
	                  else {
	                      transformedUseExisting = null;
	                      transformedUseValue = existingDiDep.value;
	                  }
	              }
	              else if (isPresent(provider.useFactory)) {
	                  var deps = provider.deps || provider.useFactory.diDeps;
	                  transformedDeps =
	                      deps.map(function (dep) { return _this._getDependency(dep, eager, resolvedProvider.sourceSpan); });
	              }
	              else if (isPresent(provider.useClass)) {
	                  var deps = provider.deps || provider.useClass.diDeps;
	                  transformedDeps =
	                      deps.map(function (dep) { return _this._getDependency(dep, eager, resolvedProvider.sourceSpan); });
	              }
	              return _transformProvider(provider, {
	                  useExisting: transformedUseExisting,
	                  useValue: transformedUseValue,
	                  deps: transformedDeps
	              });
	          });
	          transformedProviderAst =
	              _transformProviderAst(resolvedProvider, { eager: eager, providers: transformedProviders });
	          this._transformedProviders.set(token.reference, transformedProviderAst);
	          return transformedProviderAst;
	      };
	      NgModuleProviderAnalyzer.prototype._getDependency = function (dep, eager, requestorSourceSpan) {
	          if (eager === void 0) { eager = null; }
	          var foundLocal = false;
	          if (!dep.isSkipSelf && isPresent(dep.token)) {
	              // access the injector
	              if (dep.token.reference === resolveIdentifierToken(Identifiers.Injector).reference ||
	                  dep.token.reference ===
	                      resolveIdentifierToken(Identifiers.ComponentFactoryResolver).reference) {
	                  foundLocal = true;
	              }
	              else if (isPresent(this._getOrCreateLocalProvider(dep.token, eager))) {
	                  foundLocal = true;
	              }
	          }
	          var result = dep;
	          if (dep.isSelf && !foundLocal) {
	              if (dep.isOptional) {
	                  result = new CompileDiDependencyMetadata({ isValue: true, value: null });
	              }
	              else {
	                  this._errors.push(new ProviderError("No provider for " + dep.token.name, requestorSourceSpan));
	              }
	          }
	          return result;
	      };
	      return NgModuleProviderAnalyzer;
	  }());
	  function _transformProvider(provider, _a) {
	      var useExisting = _a.useExisting, useValue = _a.useValue, deps = _a.deps;
	      return new CompileProviderMetadata({
	          token: provider.token,
	          useClass: provider.useClass,
	          useExisting: useExisting,
	          useFactory: provider.useFactory,
	          useValue: useValue,
	          deps: deps,
	          multi: provider.multi
	      });
	  }
	  function _transformProviderAst(provider, _a) {
	      var eager = _a.eager, providers = _a.providers;
	      return new ProviderAst(provider.token, provider.multiProvider, provider.eager || eager, providers, provider.providerType, provider.lifecycleHooks, provider.sourceSpan);
	  }
	  function _normalizeProviders(providers, sourceSpan, targetErrors, targetProviders) {
	      if (targetProviders === void 0) { targetProviders = null; }
	      if (!targetProviders) {
	          targetProviders = [];
	      }
	      if (isPresent(providers)) {
	          providers.forEach(function (provider) {
	              if (Array.isArray(provider)) {
	                  _normalizeProviders(provider, sourceSpan, targetErrors, targetProviders);
	              }
	              else {
	                  var normalizeProvider = void 0;
	                  if (provider instanceof CompileProviderMetadata) {
	                      normalizeProvider = provider;
	                  }
	                  else if (provider instanceof CompileTypeMetadata) {
	                      normalizeProvider = new CompileProviderMetadata({ token: new CompileTokenMetadata({ identifier: provider }), useClass: provider });
	                  }
	                  else {
	                      targetErrors.push(new ProviderError("Unknown provider type " + provider, sourceSpan));
	                  }
	                  if (isPresent(normalizeProvider)) {
	                      targetProviders.push(normalizeProvider);
	                  }
	              }
	          });
	      }
	      return targetProviders;
	  }
	  function _resolveProvidersFromDirectives(directives, sourceSpan, targetErrors) {
	      var providersByToken = new Map();
	      directives.forEach(function (directive) {
	          var dirProvider = new CompileProviderMetadata({ token: new CompileTokenMetadata({ identifier: directive.type }), useClass: directive.type });
	          _resolveProviders([dirProvider], directive.isComponent ? exports.ProviderAstType.Component : exports.ProviderAstType.Directive, true, sourceSpan, targetErrors, providersByToken);
	      });
	      // Note: directives need to be able to overwrite providers of a component!
	      var directivesWithComponentFirst = directives.filter(function (dir) { return dir.isComponent; }).concat(directives.filter(function (dir) { return !dir.isComponent; }));
	      directivesWithComponentFirst.forEach(function (directive) {
	          _resolveProviders(_normalizeProviders(directive.providers, sourceSpan, targetErrors), exports.ProviderAstType.PublicService, false, sourceSpan, targetErrors, providersByToken);
	          _resolveProviders(_normalizeProviders(directive.viewProviders, sourceSpan, targetErrors), exports.ProviderAstType.PrivateService, false, sourceSpan, targetErrors, providersByToken);
	      });
	      return providersByToken;
	  }
	  function _resolveProviders(providers, providerType, eager, sourceSpan, targetErrors, targetProvidersByToken) {
	      providers.forEach(function (provider) {
	          var resolvedProvider = targetProvidersByToken.get(provider.token.reference);
	          if (isPresent(resolvedProvider) && resolvedProvider.multiProvider !== provider.multi) {
	              targetErrors.push(new ProviderError("Mixing multi and non multi provider is not possible for token " + resolvedProvider.token.name, sourceSpan));
	          }
	          if (!resolvedProvider) {
	              var lifecycleHooks = provider.token.identifier && provider.token.identifier instanceof CompileTypeMetadata ?
	                  provider.token.identifier.lifecycleHooks :
	                  [];
	              resolvedProvider = new ProviderAst(provider.token, provider.multi, eager || lifecycleHooks.length > 0, [provider], providerType, lifecycleHooks, sourceSpan);
	              targetProvidersByToken.set(provider.token.reference, resolvedProvider);
	          }
	          else {
	              if (!provider.multi) {
	                  resolvedProvider.providers.length = 0;
	              }
	              resolvedProvider.providers.push(provider);
	          }
	      });
	  }
	  function _getViewQueries(component) {
	      var viewQueries = new Map();
	      if (isPresent(component.viewQueries)) {
	          component.viewQueries.forEach(function (query) { return _addQueryToTokenMap(viewQueries, query); });
	      }
	      component.type.diDeps.forEach(function (dep) {
	          if (isPresent(dep.viewQuery)) {
	              _addQueryToTokenMap(viewQueries, dep.viewQuery);
	          }
	      });
	      return viewQueries;
	  }
	  function _getContentQueries(directives) {
	      var contentQueries = new Map();
	      directives.forEach(function (directive) {
	          if (isPresent(directive.queries)) {
	              directive.queries.forEach(function (query) { return _addQueryToTokenMap(contentQueries, query); });
	          }
	          directive.type.diDeps.forEach(function (dep) {
	              if (isPresent(dep.query)) {
	                  _addQueryToTokenMap(contentQueries, dep.query);
	              }
	          });
	      });
	      return contentQueries;
	  }
	  function _addQueryToTokenMap(map, query) {
	      query.selectors.forEach(function (token) {
	          var entry = map.get(token.reference);
	          if (!entry) {
	              entry = [];
	              map.set(token.reference, entry);
	          }
	          entry.push(query);
	      });
	  }

	  /**
	   * @license
	   * Copyright Google Inc. All Rights Reserved.
	   *
	   * Use of this source code is governed by an MIT-style license that can be
	   * found in the LICENSE file at https://angular.io/license
	   */
	  var ElementSchemaRegistry = (function () {
	      function ElementSchemaRegistry() {
	      }
	      return ElementSchemaRegistry;
	  }());

	  var StyleWithImports = (function () {
	      function StyleWithImports(style, styleUrls) {
	          this.style = style;
	          this.styleUrls = styleUrls;
	      }
	      return StyleWithImports;
	  }());
	  function isStyleUrlResolvable(url) {
	      if (isBlank(url) || url.length === 0 || url[0] == '/')
	          return false;
	      var schemeMatch = url.match(_urlWithSchemaRe);
	      return schemeMatch === null || schemeMatch[1] == 'package' || schemeMatch[1] == 'asset';
	  }
	  /**
	   * Rewrites stylesheets by resolving and removing the @import urls that
	   * are either relative or don't have a `package:` scheme
	   */
	  function extractStyleUrls(resolver, baseUrl, cssText) {
	      var foundUrls = [];
	      var modifiedCssText = cssText.replace(_cssImportRe, function () {
	          var m = [];
	          for (var _i = 0; _i < arguments.length; _i++) {
	              m[_i - 0] = arguments[_i];
	          }
	          var url = m[1] || m[2];
	          if (!isStyleUrlResolvable(url)) {
	              // Do not attempt to resolve non-package absolute URLs with URI scheme
	              return m[0];
	          }
	          foundUrls.push(resolver.resolve(baseUrl, url));
	          return '';
	      });
	      return new StyleWithImports(modifiedCssText, foundUrls);
	  }
	  var _cssImportRe = /@import\s+(?:url\()?\s*(?:(?:['"]([^'"]*))|([^;\)\s]*))[^;]*;?/g;
	  var _urlWithSchemaRe = /^([^:/?#]+):/;

	  /**
	   * @license
	   * Copyright Google Inc. All Rights Reserved.
	   *
	   * Use of this source code is governed by an MIT-style license that can be
	   * found in the LICENSE file at https://angular.io/license
	   */
	  var __extends$11 = (this && this.__extends) || function (d, b) {
	      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	      function __() { this.constructor = d; }
	      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	  };
	  var PROPERTY_PARTS_SEPARATOR = '.';
	  var ATTRIBUTE_PREFIX = 'attr';
	  var CLASS_PREFIX = 'class';
	  var STYLE_PREFIX = 'style';
	  var ANIMATE_PROP_PREFIX = 'animate-';
	  var BoundPropertyType;
	  (function (BoundPropertyType) {
	      BoundPropertyType[BoundPropertyType["DEFAULT"] = 0] = "DEFAULT";
	      BoundPropertyType[BoundPropertyType["LITERAL_ATTR"] = 1] = "LITERAL_ATTR";
	      BoundPropertyType[BoundPropertyType["ANIMATION"] = 2] = "ANIMATION";
	  })(BoundPropertyType || (BoundPropertyType = {}));
	  /**
	   * Represents a parsed property.
	   */
	  var BoundProperty = (function () {
	      function BoundProperty(name, expression, type, sourceSpan) {
	          this.name = name;
	          this.expression = expression;
	          this.type = type;
	          this.sourceSpan = sourceSpan;
	      }
	      Object.defineProperty(BoundProperty.prototype, "isLiteral", {
	          get: function () { return this.type === BoundPropertyType.LITERAL_ATTR; },
	          enumerable: true,
	          configurable: true
	      });
	      Object.defineProperty(BoundProperty.prototype, "isAnimation", {
	          get: function () { return this.type === BoundPropertyType.ANIMATION; },
	          enumerable: true,
	          configurable: true
	      });
	      return BoundProperty;
	  }());
	  /**
	   * Parses bindings in templates and in the directive host area.
	   */
	  var BindingParser = (function () {
	      function BindingParser(_exprParser, _interpolationConfig, _schemaRegistry, pipes, _targetErrors) {
	          var _this = this;
	          this._exprParser = _exprParser;
	          this._interpolationConfig = _interpolationConfig;
	          this._schemaRegistry = _schemaRegistry;
	          this._targetErrors = _targetErrors;
	          this.pipesByName = new Map();
	          pipes.forEach(function (pipe) { return _this.pipesByName.set(pipe.name, pipe); });
	      }
	      BindingParser.prototype.createDirectiveHostPropertyAsts = function (dirMeta, sourceSpan) {
	          var _this = this;
	          if (dirMeta.hostProperties) {
	              var boundProps_1 = [];
	              Object.keys(dirMeta.hostProperties).forEach(function (propName) {
	                  var expression = dirMeta.hostProperties[propName];
	                  if (typeof expression === 'string') {
	                      _this.parsePropertyBinding(propName, expression, true, sourceSpan, [], boundProps_1);
	                  }
	                  else {
	                      _this._reportError("Value of the host property binding \"" + propName + "\" needs to be a string representing an expression but got \"" + expression + "\" (" + typeof expression + ")", sourceSpan);
	                  }
	              });
	              return boundProps_1.map(function (prop) { return _this.createElementPropertyAst(dirMeta.selector, prop); });
	          }
	      };
	      BindingParser.prototype.createDirectiveHostEventAsts = function (dirMeta, sourceSpan) {
	          var _this = this;
	          if (dirMeta.hostListeners) {
	              var targetEventAsts_1 = [];
	              Object.keys(dirMeta.hostListeners).forEach(function (propName) {
	                  var expression = dirMeta.hostListeners[propName];
	                  if (typeof expression === 'string') {
	                      _this.parseEvent(propName, expression, sourceSpan, [], targetEventAsts_1);
	                  }
	                  else {
	                      _this._reportError("Value of the host listener \"" + propName + "\" needs to be a string representing an expression but got \"" + expression + "\" (" + typeof expression + ")", sourceSpan);
	                  }
	              });
	              return targetEventAsts_1;
	          }
	      };
	      BindingParser.prototype.parseInterpolation = function (value, sourceSpan) {
	          var sourceInfo = sourceSpan.start.toString();
	          try {
	              var ast = this._exprParser.parseInterpolation(value, sourceInfo, this._interpolationConfig);
	              if (ast)
	                  this._reportExpressionParserErrors(ast.errors, sourceSpan);
	              this._checkPipes(ast, sourceSpan);
	              if (ast &&
	                  ast.ast.expressions.length > view_utils.MAX_INTERPOLATION_VALUES) {
	                  throw new Error("Only support at most " + view_utils.MAX_INTERPOLATION_VALUES + " interpolation values!");
	              }
	              return ast;
	          }
	          catch (e) {
	              this._reportError("" + e, sourceSpan);
	              return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo);
	          }
	      };
	      BindingParser.prototype.parseInlineTemplateBinding = function (name, value, sourceSpan, targetMatchableAttrs, targetProps, targetVars) {
	          var bindings = this._parseTemplateBindings(value, sourceSpan);
	          for (var i = 0; i < bindings.length; i++) {
	              var binding = bindings[i];
	              if (binding.keyIsVar) {
	                  targetVars.push(new VariableAst(binding.key, binding.name, sourceSpan));
	              }
	              else if (isPresent(binding.expression)) {
	                  this._parsePropertyAst(binding.key, binding.expression, sourceSpan, targetMatchableAttrs, targetProps);
	              }
	              else {
	                  targetMatchableAttrs.push([binding.key, '']);
	                  this.parseLiteralAttr(binding.key, null, sourceSpan, targetMatchableAttrs, targetProps);
	              }
	          }
	      };
	      BindingParser.prototype._parseTemplateBindings = function (value, sourceSpan) {
	          var _this = this;
	          var sourceInfo = sourceSpan.start.toString();
	          try {
	              var bindingsResult = this._exprParser.parseTemplateBindings(value, sourceInfo);
	              this._reportExpressionParserErrors(bindingsResult.errors, sourceSpan);
	              bindingsResult.templateBindings.forEach(function (binding) {
	                  if (isPresent(binding.expression)) {
	                      _this._checkPipes(binding.expression, sourceSpan);
	                  }
	              });
	              bindingsResult.warnings.forEach(function (warning) { _this._reportError(warning, sourceSpan, exports.ParseErrorLevel.WARNING); });
	              return bindingsResult.templateBindings;
	          }
	          catch (e) {
	              this._reportError("" + e, sourceSpan);
	              return [];
	          }
	      };
	      BindingParser.prototype.parseLiteralAttr = function (name, value, sourceSpan, targetMatchableAttrs, targetProps) {
	          if (_isAnimationLabel(name)) {
	              name = name.substring(1);
	              if (value) {
	                  this._reportError("Assigning animation triggers via @prop=\"exp\" attributes with an expression is invalid." +
	                      " Use property bindings (e.g. [@prop]=\"exp\") or use an attribute without a value (e.g. @prop) instead.", sourceSpan, exports.ParseErrorLevel.FATAL);
	              }
	              this._parseAnimation(name, value, sourceSpan, targetMatchableAttrs, targetProps);
	          }
	          else {
	              targetProps.push(new BoundProperty(name, this._exprParser.wrapLiteralPrimitive(value, ''), BoundPropertyType.LITERAL_ATTR, sourceSpan));
	          }
	      };
	      BindingParser.prototype.parsePropertyBinding = function (name, expression, isHost, sourceSpan, targetMatchableAttrs, targetProps) {
	          var isAnimationProp = false;
	          if (name.startsWith(ANIMATE_PROP_PREFIX)) {
	              isAnimationProp = true;
	              name = name.substring(ANIMATE_PROP_PREFIX.length);
	          }
	          else if (_isAnimationLabel(name)) {
	              isAnimationProp = true;
	              name = name.substring(1);
	          }
	          if (isAnimationProp) {
	              this._parseAnimation(name, expression, sourceSpan, targetMatchableAttrs, targetProps);
	          }
	          else {
	              this._parsePropertyAst(name, this._parseBinding(expression, isHost, sourceSpan), sourceSpan, targetMatchableAttrs, targetProps);
	          }
	      };
	      BindingParser.prototype.parsePropertyInterpolation = function (name, value, sourceSpan, targetMatchableAttrs, targetProps) {
	          var expr = this.parseInterpolation(value, sourceSpan);
	          if (isPresent(expr)) {
	              this._parsePropertyAst(name, expr, sourceSpan, targetMatchableAttrs, targetProps);
	              return true;
	          }
	          return false;
	      };
	      BindingParser.prototype._parsePropertyAst = function (name, ast, sourceSpan, targetMatchableAttrs, targetProps) {
	          targetMatchableAttrs.push([name, ast.source]);
	          targetProps.push(new BoundProperty(name, ast, BoundPropertyType.DEFAULT, sourceSpan));
	      };
	      BindingParser.prototype._parseAnimation = function (name, expression, sourceSpan, targetMatchableAttrs, targetProps) {
	          // This will occur when a @trigger is not paired with an expression.
	          // For animations it is valid to not have an expression since */void
	          // states will be applied by angular when the element is attached/detached
	          var ast = this._parseBinding(expression || 'null', false, sourceSpan);
	          targetMatchableAttrs.push([name, ast.source]);
	          targetProps.push(new BoundProperty(name, ast, BoundPropertyType.ANIMATION, sourceSpan));
	      };
	      BindingParser.prototype._parseBinding = function (value, isHostBinding, sourceSpan) {
	          var sourceInfo = sourceSpan.start.toString();
	          try {
	              var ast = isHostBinding ?
	                  this._exprParser.parseSimpleBinding(value, sourceInfo, this._interpolationConfig) :
	                  this._exprParser.parseBinding(value, sourceInfo, this._interpolationConfig);
	              if (ast)
	                  this._reportExpressionParserErrors(ast.errors, sourceSpan);
	              this._checkPipes(ast, sourceSpan);
	              return ast;
	          }
	          catch (e) {
	              this._reportError("" + e, sourceSpan);
	              return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo);
	          }
	      };
	      BindingParser.prototype.createElementPropertyAst = function (elementSelector, boundProp) {
	          if (boundProp.isAnimation) {
	              return new BoundElementPropertyAst(boundProp.name, exports.PropertyBindingType.Animation, _angular_core.SecurityContext.NONE, false, boundProp.expression, null, boundProp.sourceSpan);
	          }
	          var unit = null;
	          var bindingType;
	          var boundPropertyName;
	          var parts = boundProp.name.split(PROPERTY_PARTS_SEPARATOR);
	          var securityContexts;
	          if (parts.length === 1) {
	              var partValue = parts[0];
	              boundPropertyName = this._schemaRegistry.getMappedPropName(partValue);
	              securityContexts = calcPossibleSecurityContexts(this._schemaRegistry, elementSelector, boundPropertyName, false);
	              bindingType = exports.PropertyBindingType.Property;
	              this._validatePropertyOrAttributeName(boundPropertyName, boundProp.sourceSpan, false);
	          }
	          else {
	              if (parts[0] == ATTRIBUTE_PREFIX) {
	                  boundPropertyName = parts[1];
	                  this._validatePropertyOrAttributeName(boundPropertyName, boundProp.sourceSpan, true);
	                  securityContexts = calcPossibleSecurityContexts(this._schemaRegistry, elementSelector, boundPropertyName, true);
	                  var nsSeparatorIdx = boundPropertyName.indexOf(':');
	                  if (nsSeparatorIdx > -1) {
	                      var ns = boundPropertyName.substring(0, nsSeparatorIdx);
	                      var name_1 = boundPropertyName.substring(nsSeparatorIdx + 1);
	                      boundPropertyName = mergeNsAndName(ns, name_1);
	                  }
	                  bindingType = exports.PropertyBindingType.Attribute;
	              }
	              else if (parts[0] == CLASS_PREFIX) {
	                  boundPropertyName = parts[1];
	                  bindingType = exports.PropertyBindingType.Class;
	                  securityContexts = [_angular_core.SecurityContext.NONE];
	              }
	              else if (parts[0] == STYLE_PREFIX) {
	                  unit = parts.length > 2 ? parts[2] : null;
	                  boundPropertyName = parts[1];
	                  bindingType = exports.PropertyBindingType.Style;
	                  securityContexts = [_angular_core.SecurityContext.STYLE];
	              }
	              else {
	                  this._reportError("Invalid property name '" + boundProp.name + "'", boundProp.sourceSpan);
	                  bindingType = null;
	                  securityContexts = [];
	              }
	          }
	          return new BoundElementPropertyAst(boundPropertyName, bindingType, securityContexts.length === 1 ? securityContexts[0] : null, securityContexts.length > 1, boundProp.expression, unit, boundProp.sourceSpan);
	      };
	      BindingParser.prototype.parseEvent = function (name, expression, sourceSpan, targetMatchableAttrs, targetEvents) {
	          if (_isAnimationLabel(name)) {
	              name = name.substr(1);
	              this._parseAnimationEvent(name, expression, sourceSpan, targetEvents);
	          }
	          else {
	              this._parseEvent(name, expression, sourceSpan, targetMatchableAttrs, targetEvents);
	          }
	      };
	      BindingParser.prototype._parseAnimationEvent = function (name, expression, sourceSpan, targetEvents) {
	          var matches = splitAtPeriod(name, [name, '']);
	          var eventName = matches[0];
	          var phase = matches[1].toLowerCase();
	          if (phase) {
	              switch (phase) {
	                  case 'start':
	                  case 'done':
	                      var ast = this._parseAction(expression, sourceSpan);
	                      targetEvents.push(new BoundEventAst(eventName, null, phase, ast, sourceSpan));
	                      break;
	                  default:
	                      this._reportError("The provided animation output phase value \"" + phase + "\" for \"@" + eventName + "\" is not supported (use start or done)", sourceSpan);
	                      break;
	              }
	          }
	          else {
	              this._reportError("The animation trigger output event (@" + eventName + ") is missing its phase value name (start or done are currently supported)", sourceSpan);
	          }
	      };
	      BindingParser.prototype._parseEvent = function (name, expression, sourceSpan, targetMatchableAttrs, targetEvents) {
	          // long format: 'target: eventName'
	          var _a = splitAtColon(name, [null, name]), target = _a[0], eventName = _a[1];
	          var ast = this._parseAction(expression, sourceSpan);
	          targetMatchableAttrs.push([name, ast.source]);
	          targetEvents.push(new BoundEventAst(eventName, target, null, ast, sourceSpan));
	          // Don't detect directives for event names for now,
	          // so don't add the event name to the matchableAttrs
	      };
	      BindingParser.prototype._parseAction = function (value, sourceSpan) {
	          var sourceInfo = sourceSpan.start.toString();
	          try {
	              var ast = this._exprParser.parseAction(value, sourceInfo, this._interpolationConfig);
	              if (ast) {
	                  this._reportExpressionParserErrors(ast.errors, sourceSpan);
	              }
	              if (!ast || ast.ast instanceof EmptyExpr) {
	                  this._reportError("Empty expressions are not allowed", sourceSpan);
	                  return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo);
	              }
	              this._checkPipes(ast, sourceSpan);
	              return ast;
	          }
	          catch (e) {
	              this._reportError("" + e, sourceSpan);
	              return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo);
	          }
	      };
	      BindingParser.prototype._reportError = function (message, sourceSpan, level) {
	          if (level === void 0) { level = exports.ParseErrorLevel.FATAL; }
	          this._targetErrors.push(new ParseError(sourceSpan, message, level));
	      };
	      BindingParser.prototype._reportExpressionParserErrors = function (errors, sourceSpan) {
	          for (var _i = 0, errors_1 = errors; _i < errors_1.length; _i++) {
	              var error = errors_1[_i];
	              this._reportError(error.message, sourceSpan);
	          }
	      };
	      BindingParser.prototype._checkPipes = function (ast, sourceSpan) {
	          var _this = this;
	          if (isPresent(ast)) {
	              var collector = new PipeCollector();
	              ast.visit(collector);
	              collector.pipes.forEach(function (pipeName) {
	                  if (!_this.pipesByName.has(pipeName)) {
	                      _this._reportError("The pipe '" + pipeName + "' could not be found", sourceSpan);
	                  }
	              });
	          }
	      };
	      /**
	       * @param propName the name of the property / attribute
	       * @param sourceSpan
	       * @param isAttr true when binding to an attribute
	       * @private
	       */
	      BindingParser.prototype._validatePropertyOrAttributeName = function (propName, sourceSpan, isAttr) {
	          var report = isAttr ? this._schemaRegistry.validateAttribute(propName) :
	              this._schemaRegistry.validateProperty(propName);
	          if (report.error) {
	              this._reportError(report.msg, sourceSpan, exports.ParseErrorLevel.FATAL);
	          }
	      };
	      return BindingParser;
	  }());
	  var PipeCollector = (function (_super) {
	      __extends$11(PipeCollector, _super);
	      function PipeCollector() {
	          _super.apply(this, arguments);
	          this.pipes = new Set();
	      }
	      PipeCollector.prototype.visitPipe = function (ast, context) {
	          this.pipes.add(ast.name);
	          ast.exp.visit(this);
	          this.visitAll(ast.args, context);
	          return null;
	      };
	      return PipeCollector;
	  }(RecursiveAstVisitor));
	  function _isAnimationLabel(name) {
	      return name[0] == '@';
	  }
	  function calcPossibleSecurityContexts(registry, selector, propName, isAttribute) {
	      var ctxs = [];
	      CssSelector.parse(selector).forEach(function (selector) {
	          var elementNames = selector.element ? [selector.element] : registry.allKnownElementNames();
	          var notElementNames = new Set(selector.notSelectors.filter(function (selector) { return selector.isElementSelector(); })
	              .map(function (selector) { return selector.element; }));
	          var possibleElementNames = elementNames.filter(function (elementName) { return !notElementNames.has(elementName); });
	          ctxs.push.apply(ctxs, possibleElementNames.map(function (elementName) { return registry.securityContext(elementName, propName, isAttribute); }));
	      });
	      return ctxs.length === 0 ? [_angular_core.SecurityContext.NONE] : Array.from(new Set(ctxs)).sort();
	  }

	  var NG_CONTENT_SELECT_ATTR = 'select';
	  var NG_CONTENT_ELEMENT = 'ng-content';
	  var LINK_ELEMENT = 'link';
	  var LINK_STYLE_REL_ATTR = 'rel';
	  var LINK_STYLE_HREF_ATTR = 'href';
	  var LINK_STYLE_REL_VALUE = 'stylesheet';
	  var STYLE_ELEMENT = 'style';
	  var SCRIPT_ELEMENT = 'script';
	  var NG_NON_BINDABLE_ATTR = 'ngNonBindable';
	  var NG_PROJECT_AS = 'ngProjectAs';
	  function preparseElement(ast) {
	      var selectAttr = null;
	      var hrefAttr = null;
	      var relAttr = null;
	      var nonBindable = false;
	      var projectAs = null;
	      ast.attrs.forEach(function (attr) {
	          var lcAttrName = attr.name.toLowerCase();
	          if (lcAttrName == NG_CONTENT_SELECT_ATTR) {
	              selectAttr = attr.value;
	          }
	          else if (lcAttrName == LINK_STYLE_HREF_ATTR) {
	              hrefAttr = attr.value;
	          }
	          else if (lcAttrName == LINK_STYLE_REL_ATTR) {
	              relAttr = attr.value;
	          }
	          else if (attr.name == NG_NON_BINDABLE_ATTR) {
	              nonBindable = true;
	          }
	          else if (attr.name == NG_PROJECT_AS) {
	              if (attr.value.length > 0) {
	                  projectAs = attr.value;
	              }
	          }
	      });
	      selectAttr = normalizeNgContentSelect(selectAttr);
	      var nodeName = ast.name.toLowerCase();
	      var type = PreparsedElementType.OTHER;
	      if (splitNsName(nodeName)[1] == NG_CONTENT_ELEMENT) {
	          type = PreparsedElementType.NG_CONTENT;
	      }
	      else if (nodeName == STYLE_ELEMENT) {
	          type = PreparsedElementType.STYLE;
	      }
	      else if (nodeName == SCRIPT_ELEMENT) {
	          type = PreparsedElementType.SCRIPT;
	      }
	      else if (nodeName == LINK_ELEMENT && relAttr == LINK_STYLE_REL_VALUE) {
	          type = PreparsedElementType.STYLESHEET;
	      }
	      return new PreparsedElement(type, selectAttr, hrefAttr, nonBindable, projectAs);
	  }
	  var PreparsedElementType;
	  (function (PreparsedElementType) {
	      PreparsedElementType[PreparsedElementType["NG_CONTENT"] = 0] = "NG_CONTENT";
	      PreparsedElementType[PreparsedElementType["STYLE"] = 1] = "STYLE";
	      PreparsedElementType[PreparsedElementType["STYLESHEET"] = 2] = "STYLESHEET";
	      PreparsedElementType[PreparsedElementType["SCRIPT"] = 3] = "SCRIPT";
	      PreparsedElementType[PreparsedElementType["OTHER"] = 4] = "OTHER";
	  })(PreparsedElementType || (PreparsedElementType = {}));
	  var PreparsedElement = (function () {
	      function PreparsedElement(type, selectAttr, hrefAttr, nonBindable, projectAs) {
	          this.type = type;
	          this.selectAttr = selectAttr;
	          this.hrefAttr = hrefAttr;
	          this.nonBindable = nonBindable;
	          this.projectAs = projectAs;
	      }
	      return PreparsedElement;
	  }());
	  function normalizeNgContentSelect(selectAttr) {
	      if (selectAttr === null || selectAttr.length === 0) {
	          return '*';
	      }
	      return selectAttr;
	  }

	  /**
	   * @license
	   * Copyright Google Inc. All Rights Reserved.
	   *
	   * Use of this source code is governed by an MIT-style license that can be
	   * found in the LICENSE file at https://angular.io/license
	   */
	  var __extends = (this && this.__extends) || function (d, b) {
	      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	      function __() { this.constructor = d; }
	      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	  };
	  // Group 1 = "bind-"
	  // Group 2 = "let-"
	  // Group 3 = "ref-/#"
	  // Group 4 = "on-"
	  // Group 5 = "bindon-"
	  // Group 6 = "@"
	  // Group 7 = the identifier after "bind-", "let-", "ref-/#", "on-", "bindon-" or "@"
	  // Group 8 = identifier inside [()]
	  // Group 9 = identifier inside []
	  // Group 10 = identifier inside ()
	  var BIND_NAME_REGEXP = /^(?:(?:(?:(bind-)|(let-)|(ref-|#)|(on-)|(bindon-)|(@))(.+))|\[\(([^\)]+)\)\]|\[([^\]]+)\]|\(([^\)]+)\))$/;
	  var KW_BIND_IDX = 1;
	  var KW_LET_IDX = 2;
	  var KW_REF_IDX = 3;
	  var KW_ON_IDX = 4;
	  var KW_BINDON_IDX = 5;
	  var KW_AT_IDX = 6;
	  var IDENT_KW_IDX = 7;
	  var IDENT_BANANA_BOX_IDX = 8;
	  var IDENT_PROPERTY_IDX = 9;
	  var IDENT_EVENT_IDX = 10;
	  var TEMPLATE_ELEMENT = 'template';
	  var TEMPLATE_ATTR = 'template';
	  var TEMPLATE_ATTR_PREFIX = '*';
	  var CLASS_ATTR = 'class';
	  var TEXT_CSS_SELECTOR = CssSelector.parse('*')[0];
	  /**
	   * Provides an array of {@link TemplateAstVisitor}s which will be used to transform
	   * parsed templates before compilation is invoked, allowing custom expression syntax
	   * and other advanced transformations.
	   *
	   * This is currently an internal-only feature and not meant for general use.
	   */
	  var TEMPLATE_TRANSFORMS = new _angular_core.OpaqueToken('TemplateTransforms');
	  var TemplateParseError = (function (_super) {
	      __extends(TemplateParseError, _super);
	      function TemplateParseError(message, span, level) {
	          _super.call(this, span, message, level);
	      }
	      return TemplateParseError;
	  }(ParseError));
	  var TemplateParseResult = (function () {
	      function TemplateParseResult(templateAst, errors) {
	          this.templateAst = templateAst;
	          this.errors = errors;
	      }
	      return TemplateParseResult;
	  }());
	  var TemplateParser = (function () {
	      function TemplateParser(_exprParser, _schemaRegistry, _htmlParser, _console, transforms) {
	          this._exprParser = _exprParser;
	          this._schemaRegistry = _schemaRegistry;
	          this._htmlParser = _htmlParser;
	          this._console = _console;
	          this.transforms = transforms;
	      }
	      TemplateParser.prototype.parse = function (component, template, directives, pipes, schemas, templateUrl) {
	          var result = this.tryParse(component, template, directives, pipes, schemas, templateUrl);
	          var warnings = result.errors.filter(function (error) { return error.level === exports.ParseErrorLevel.WARNING; });
	          var errors = result.errors.filter(function (error) { return error.level === exports.ParseErrorLevel.FATAL; });
	          if (warnings.length > 0) {
	              this._console.warn("Template parse warnings:\n" + warnings.join('\n'));
	          }
	          if (errors.length > 0) {
	              var errorString = errors.join('\n');
	              throw new Error("Template parse errors:\n" + errorString);
	          }
	          return result.templateAst;
	      };
	      TemplateParser.prototype.tryParse = function (component, template, directives, pipes, schemas, templateUrl) {
	          return this.tryParseHtml(this.expandHtml(this._htmlParser.parse(template, templateUrl, true, this.getInterpolationConfig(component))), component, template, directives, pipes, schemas, templateUrl);
	      };
	      TemplateParser.prototype.tryParseHtml = function (htmlAstWithErrors, component, template, directives, pipes, schemas, templateUrl) {
	          var result;
	          var errors = htmlAstWithErrors.errors;
	          if (htmlAstWithErrors.rootNodes.length > 0) {
	              var uniqDirectives = removeIdentifierDuplicates(directives);
	              var uniqPipes = removeIdentifierDuplicates(pipes);
	              var providerViewContext = new ProviderViewContext(component, htmlAstWithErrors.rootNodes[0].sourceSpan);
	              var interpolationConfig = void 0;
	              if (component.template && component.template.interpolation) {
	                  interpolationConfig = {
	                      start: component.template.interpolation[0],
	                      end: component.template.interpolation[1]
	                  };
	              }
	              var bindingParser = new BindingParser(this._exprParser, interpolationConfig, this._schemaRegistry, uniqPipes, errors);
	              var parseVisitor = new TemplateParseVisitor(providerViewContext, uniqDirectives, bindingParser, this._schemaRegistry, schemas, errors);
	              result = visitAll(parseVisitor, htmlAstWithErrors.rootNodes, EMPTY_ELEMENT_CONTEXT);
	              errors.push.apply(errors, providerViewContext.errors);
	          }
	          else {
	              result = [];
	          }
	          this._assertNoReferenceDuplicationOnTemplate(result, errors);
	          if (errors.length > 0) {
	              return new TemplateParseResult(result, errors);
	          }
	          if (isPresent(this.transforms)) {
	              this.transforms.forEach(function (transform) { result = templateVisitAll(transform, result); });
	          }
	          return new TemplateParseResult(result, errors);
	      };
	      TemplateParser.prototype.expandHtml = function (htmlAstWithErrors, forced) {
	          if (forced === void 0) { forced = false; }
	          var errors = htmlAstWithErrors.errors;
	          if (errors.length == 0 || forced) {
	              // Transform ICU messages to angular directives
	              var expandedHtmlAst = expandNodes(htmlAstWithErrors.rootNodes);
	              errors.push.apply(errors, expandedHtmlAst.errors);
	              htmlAstWithErrors = new ParseTreeResult(expandedHtmlAst.nodes, errors);
	          }
	          return htmlAstWithErrors;
	      };
	      TemplateParser.prototype.getInterpolationConfig = function (component) {
	          if (component.template) {
	              return InterpolationConfig.fromArray(component.template.interpolation);
	          }
	      };
	      /** @internal */
	      TemplateParser.prototype._assertNoReferenceDuplicationOnTemplate = function (result, errors) {
	          var existingReferences = [];
	          result.filter(function (element) { return !!element.references; })
	              .forEach(function (element) { return element.references.forEach(function (reference) {
	              var name = reference.name;
	              if (existingReferences.indexOf(name) < 0) {
	                  existingReferences.push(name);
	              }
	              else {
	                  var error = new TemplateParseError("Reference \"#" + name + "\" is defined several times", reference.sourceSpan, exports.ParseErrorLevel.FATAL);
	                  errors.push(error);
	              }
	          }); });
	      };
	      TemplateParser.decorators = [
	          { type: _angular_core.Injectable },
	      ];
	      /** @nocollapse */
	      TemplateParser.ctorParameters = [
	          { type: Parser, },
	          { type: ElementSchemaRegistry, },
	          { type: I18NHtmlParser, },
	          { type: Console, },
	          { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Inject, args: [TEMPLATE_TRANSFORMS,] },] },
	      ];
	      return TemplateParser;
	  }());
	  var TemplateParseVisitor = (function () {
	      function TemplateParseVisitor(providerViewContext, directives, _bindingParser, _schemaRegistry, _schemas, _targetErrors) {
	          var _this = this;
	          this.providerViewContext = providerViewContext;
	          this._bindingParser = _bindingParser;
	          this._schemaRegistry = _schemaRegistry;
	          this._schemas = _schemas;
	          this._targetErrors = _targetErrors;
	          this.selectorMatcher = new SelectorMatcher();
	          this.directivesIndex = new Map();
	          this.ngContentCount = 0;
	          directives.forEach(function (directive, index) {
	              var selector = CssSelector.parse(directive.selector);
	              _this.selectorMatcher.addSelectables(selector, directive);
	              _this.directivesIndex.set(directive, index);
	          });
	      }
	      TemplateParseVisitor.prototype.visitExpansion = function (expansion, context) { return null; };
	      TemplateParseVisitor.prototype.visitExpansionCase = function (expansionCase, context) { return null; };
	      TemplateParseVisitor.prototype.visitText = function (text, parent) {
	          var ngContentIndex = parent.findNgContentIndex(TEXT_CSS_SELECTOR);
	          var expr = this._bindingParser.parseInterpolation(text.value, text.sourceSpan);
	          if (isPresent(expr)) {
	              return new BoundTextAst(expr, ngContentIndex, text.sourceSpan);
	          }
	          else {
	              return new TextAst(text.value, ngContentIndex, text.sourceSpan);
	          }
	      };
	      TemplateParseVisitor.prototype.visitAttribute = function (attribute, context) {
	          return new AttrAst(attribute.name, attribute.value, attribute.sourceSpan);
	      };
	      TemplateParseVisitor.prototype.visitComment = function (comment, context) { return null; };
	      TemplateParseVisitor.prototype.visitElement = function (element, parent) {
	          var _this = this;
	          var nodeName = element.name;
	          var preparsedElement = preparseElement(element);
	          if (preparsedElement.type === PreparsedElementType.SCRIPT ||
	              preparsedElement.type === PreparsedElementType.STYLE) {
	              // Skipping <script> for security reasons
	              // Skipping <style> as we already processed them
	              // in the StyleCompiler
	              return null;
	          }
	          if (preparsedElement.type === PreparsedElementType.STYLESHEET &&
	              isStyleUrlResolvable(preparsedElement.hrefAttr)) {
	              // Skipping stylesheets with either relative urls or package scheme as we already processed
	              // them in the StyleCompiler
	              return null;
	          }
	          var matchableAttrs = [];
	          var elementOrDirectiveProps = [];
	          var elementOrDirectiveRefs = [];
	          var elementVars = [];
	          var events = [];
	          var templateElementOrDirectiveProps = [];
	          var templateMatchableAttrs = [];
	          var templateElementVars = [];
	          var hasInlineTemplates = false;
	          var attrs = [];
	          var lcElName = splitNsName(nodeName.toLowerCase())[1];
	          var isTemplateElement = lcElName == TEMPLATE_ELEMENT;
	          element.attrs.forEach(function (attr) {
	              var hasBinding = _this._parseAttr(isTemplateElement, attr, matchableAttrs, elementOrDirectiveProps, events, elementOrDirectiveRefs, elementVars);
	              var templateBindingsSource;
	              if (_this._normalizeAttributeName(attr.name) == TEMPLATE_ATTR) {
	                  templateBindingsSource = attr.value;
	              }
	              else if (attr.name.startsWith(TEMPLATE_ATTR_PREFIX)) {
	                  var key = attr.name.substring(TEMPLATE_ATTR_PREFIX.length); // remove the star
	                  templateBindingsSource = (attr.value.length == 0) ? key : key + ' ' + attr.value;
	              }
	              var hasTemplateBinding = isPresent(templateBindingsSource);
	              if (hasTemplateBinding) {
	                  if (hasInlineTemplates) {
	                      _this._reportError("Can't have multiple template bindings on one element. Use only one attribute named 'template' or prefixed with *", attr.sourceSpan);
	                  }
	                  hasInlineTemplates = true;
	                  _this._bindingParser.parseInlineTemplateBinding(attr.name, templateBindingsSource, attr.sourceSpan, templateMatchableAttrs, templateElementOrDirectiveProps, templateElementVars);
	              }
	              if (!hasBinding && !hasTemplateBinding) {
	                  // don't include the bindings as attributes as well in the AST
	                  attrs.push(_this.visitAttribute(attr, null));
	                  matchableAttrs.push([attr.name, attr.value]);
	              }
	          });
	          var elementCssSelector = createElementCssSelector(nodeName, matchableAttrs);
	          var _a = this._parseDirectives(this.selectorMatcher, elementCssSelector), directiveMetas = _a.directives, matchElement = _a.matchElement;
	          var references = [];
	          var directiveAsts = this._createDirectiveAsts(isTemplateElement, element.name, directiveMetas, elementOrDirectiveProps, elementOrDirectiveRefs, element.sourceSpan, references);
	          var elementProps = this._createElementPropertyAsts(element.name, elementOrDirectiveProps, directiveAsts);
	          var isViewRoot = parent.isTemplateElement || hasInlineTemplates;
	          var providerContext = new ProviderElementContext(this.providerViewContext, parent.providerContext, isViewRoot, directiveAsts, attrs, references, element.sourceSpan);
	          var children = visitAll(preparsedElement.nonBindable ? NON_BINDABLE_VISITOR : this, element.children, ElementContext.create(isTemplateElement, directiveAsts, isTemplateElement ? parent.providerContext : providerContext));
	          providerContext.afterElement();
	          // Override the actual selector when the `ngProjectAs` attribute is provided
	          var projectionSelector = isPresent(preparsedElement.projectAs) ?
	              CssSelector.parse(preparsedElement.projectAs)[0] :
	              elementCssSelector;
	          var ngContentIndex = parent.findNgContentIndex(projectionSelector);
	          var parsedElement;
	          if (preparsedElement.type === PreparsedElementType.NG_CONTENT) {
	              if (element.children && !element.children.every(_isEmptyTextNode)) {
	                  this._reportError("<ng-content> element cannot have content.", element.sourceSpan);
	              }
	              parsedElement = new NgContentAst(this.ngContentCount++, hasInlineTemplates ? null : ngContentIndex, element.sourceSpan);
	          }
	          else if (isTemplateElement) {
	              this._assertAllEventsPublishedByDirectives(directiveAsts, events);
	              this._assertNoComponentsNorElementBindingsOnTemplate(directiveAsts, elementProps, element.sourceSpan);
	              parsedElement = new EmbeddedTemplateAst(attrs, events, references, elementVars, providerContext.transformedDirectiveAsts, providerContext.transformProviders, providerContext.transformedHasViewContainer, children, hasInlineTemplates ? null : ngContentIndex, element.sourceSpan);
	          }
	          else {
	              this._assertElementExists(matchElement, element);
	              this._assertOnlyOneComponent(directiveAsts, element.sourceSpan);
	              var ngContentIndex_1 = hasInlineTemplates ? null : parent.findNgContentIndex(projectionSelector);
	              parsedElement = new ElementAst(nodeName, attrs, elementProps, events, references, providerContext.transformedDirectiveAsts, providerContext.transformProviders, providerContext.transformedHasViewContainer, children, hasInlineTemplates ? null : ngContentIndex_1, element.sourceSpan, element.endSourceSpan);
	              this._findComponentDirectives(directiveAsts)
	                  .forEach(function (componentDirectiveAst) { return _this._validateElementAnimationInputOutputs(componentDirectiveAst.hostProperties, componentDirectiveAst.hostEvents, componentDirectiveAst.directive.template); });
	              var componentTemplate = providerContext.viewContext.component.template;
	              this._validateElementAnimationInputOutputs(elementProps, events, componentTemplate);
	          }
	          if (hasInlineTemplates) {
	              var templateCssSelector = createElementCssSelector(TEMPLATE_ELEMENT, templateMatchableAttrs);
	              var templateDirectiveMetas = this._parseDirectives(this.selectorMatcher, templateCssSelector).directives;
	              var templateDirectiveAsts = this._createDirectiveAsts(true, element.name, templateDirectiveMetas, templateElementOrDirectiveProps, [], element.sourceSpan, []);
	              var templateElementProps = this._createElementPropertyAsts(element.name, templateElementOrDirectiveProps, templateDirectiveAsts);
	              this._assertNoComponentsNorElementBindingsOnTemplate(templateDirectiveAsts, templateElementProps, element.sourceSpan);
	              var templateProviderContext = new ProviderElementContext(this.providerViewContext, parent.providerContext, parent.isTemplateElement, templateDirectiveAsts, [], [], element.sourceSpan);
	              templateProviderContext.afterElement();
	              parsedElement = new EmbeddedTemplateAst([], [], [], templateElementVars, templateProviderContext.transformedDirectiveAsts, templateProviderContext.transformProviders, templateProviderContext.transformedHasViewContainer, [parsedElement], ngContentIndex, element.sourceSpan);
	          }
	          return parsedElement;
	      };
	      TemplateParseVisitor.prototype._validateElementAnimationInputOutputs = function (inputs, outputs, template) {
	          var _this = this;
	          var triggerLookup = new Set();
	          template.animations.forEach(function (entry) { triggerLookup.add(entry.name); });
	          var animationInputs = inputs.filter(function (input) { return input.isAnimation; });
	          animationInputs.forEach(function (input) {
	              var name = input.name;
	              if (!triggerLookup.has(name)) {
	                  _this._reportError("Couldn't find an animation entry for \"" + name + "\"", input.sourceSpan);
	              }
	          });
	          outputs.forEach(function (output) {
	              if (output.isAnimation) {
	                  var found = animationInputs.find(function (input) { return input.name == output.name; });
	                  if (!found) {
	                      _this._reportError("Unable to listen on (@" + output.name + "." + output.phase + ") because the animation trigger [@" + output.name + "] isn't being used on the same element", output.sourceSpan);
	                  }
	              }
	          });
	      };
	      TemplateParseVisitor.prototype._parseAttr = function (isTemplateElement, attr, targetMatchableAttrs, targetProps, targetEvents, targetRefs, targetVars) {
	          var name = this._normalizeAttributeName(attr.name);
	          var value = attr.value;
	          var srcSpan = attr.sourceSpan;
	          var bindParts = name.match(BIND_NAME_REGEXP);
	          var hasBinding = false;
	          if (bindParts !== null) {
	              hasBinding = true;
	              if (isPresent(bindParts[KW_BIND_IDX])) {
	                  this._bindingParser.parsePropertyBinding(bindParts[IDENT_KW_IDX], value, false, srcSpan, targetMatchableAttrs, targetProps);
	              }
	              else if (bindParts[KW_LET_IDX]) {
	                  if (isTemplateElement) {
	                      var identifier = bindParts[IDENT_KW_IDX];
	                      this._parseVariable(identifier, value, srcSpan, targetVars);
	                  }
	                  else {
	                      this._reportError("\"let-\" is only supported on template elements.", srcSpan);
	                  }
	              }
	              else if (bindParts[KW_REF_IDX]) {
	                  var identifier = bindParts[IDENT_KW_IDX];
	                  this._parseReference(identifier, value, srcSpan, targetRefs);
	              }
	              else if (bindParts[KW_ON_IDX]) {
	                  this._bindingParser.parseEvent(bindParts[IDENT_KW_IDX], value, srcSpan, targetMatchableAttrs, targetEvents);
	              }
	              else if (bindParts[KW_BINDON_IDX]) {
	                  this._bindingParser.parsePropertyBinding(bindParts[IDENT_KW_IDX], value, false, srcSpan, targetMatchableAttrs, targetProps);
	                  this._parseAssignmentEvent(bindParts[IDENT_KW_IDX], value, srcSpan, targetMatchableAttrs, targetEvents);
	              }
	              else if (bindParts[KW_AT_IDX]) {
	                  this._bindingParser.parseLiteralAttr(name, value, srcSpan, targetMatchableAttrs, targetProps);
	              }
	              else if (bindParts[IDENT_BANANA_BOX_IDX]) {
	                  this._bindingParser.parsePropertyBinding(bindParts[IDENT_BANANA_BOX_IDX], value, false, srcSpan, targetMatchableAttrs, targetProps);
	                  this._parseAssignmentEvent(bindParts[IDENT_BANANA_BOX_IDX], value, srcSpan, targetMatchableAttrs, targetEvents);
	              }
	              else if (bindParts[IDENT_PROPERTY_IDX]) {
	                  this._bindingParser.parsePropertyBinding(bindParts[IDENT_PROPERTY_IDX], value, false, srcSpan, targetMatchableAttrs, targetProps);
	              }
	              else if (bindParts[IDENT_EVENT_IDX]) {
	                  this._bindingParser.parseEvent(bindParts[IDENT_EVENT_IDX], value, srcSpan, targetMatchableAttrs, targetEvents);
	              }
	          }
	          else {
	              hasBinding = this._bindingParser.parsePropertyInterpolation(name, value, srcSpan, targetMatchableAttrs, targetProps);
	          }
	          if (!hasBinding) {
	              this._bindingParser.parseLiteralAttr(name, value, srcSpan, targetMatchableAttrs, targetProps);
	          }
	          return hasBinding;
	      };
	      TemplateParseVisitor.prototype._normalizeAttributeName = function (attrName) {
	          return /^data-/i.test(attrName) ? attrName.substring(5) : attrName;
	      };
	      TemplateParseVisitor.prototype._parseVariable = function (identifier, value, sourceSpan, targetVars) {
	          if (identifier.indexOf('-') > -1) {
	              this._reportError("\"-\" is not allowed in variable names", sourceSpan);
	          }
	          targetVars.push(new VariableAst(identifier, value, sourceSpan));
	      };
	      TemplateParseVisitor.prototype._parseReference = function (identifier, value, sourceSpan, targetRefs) {
	          if (identifier.indexOf('-') > -1) {
	              this._reportError("\"-\" is not allowed in reference names", sourceSpan);
	          }
	          targetRefs.push(new ElementOrDirectiveRef(identifier, value, sourceSpan));
	      };
	      TemplateParseVisitor.prototype._parseAssignmentEvent = function (name, expression, sourceSpan, targetMatchableAttrs, targetEvents) {
	          this._bindingParser.parseEvent(name + "Change", expression + "=$event", sourceSpan, targetMatchableAttrs, targetEvents);
	      };
	      TemplateParseVisitor.prototype._parseDirectives = function (selectorMatcher, elementCssSelector) {
	          var _this = this;
	          // Need to sort the directives so that we get consistent results throughout,
	          // as selectorMatcher uses Maps inside.
	          // Also deduplicate directives as they might match more than one time!
	          var directives = new Array(this.directivesIndex.size);
	          // Whether any directive selector matches on the element name
	          var matchElement = false;
	          selectorMatcher.match(elementCssSelector, function (selector, directive) {
	              directives[_this.directivesIndex.get(directive)] = directive;
	              matchElement = matchElement || selector.hasElementSelector();
	          });
	          return {
	              directives: directives.filter(function (dir) { return !!dir; }),
	              matchElement: matchElement,
	          };
	      };
	      TemplateParseVisitor.prototype._createDirectiveAsts = function (isTemplateElement, elementName, directives, props, elementOrDirectiveRefs, elementSourceSpan, targetReferences) {
	          var _this = this;
	          var matchedReferences = new Set();
	          var component = null;
	          var directiveAsts = directives.map(function (directive) {
	              var sourceSpan = new ParseSourceSpan(elementSourceSpan.start, elementSourceSpan.end, "Directive " + directive.type.name);
	              if (directive.isComponent) {
	                  component = directive;
	              }
	              var directiveProperties = [];
	              var hostProperties = _this._bindingParser.createDirectiveHostPropertyAsts(directive, sourceSpan);
	              // Note: We need to check the host properties here as well,
	              // as we don't know the element name in the DirectiveWrapperCompiler yet.
	              _this._checkPropertiesInSchema(elementName, hostProperties);
	              var hostEvents = _this._bindingParser.createDirectiveHostEventAsts(directive, sourceSpan);
	              _this._createDirectivePropertyAsts(directive.inputs, props, directiveProperties);
	              elementOrDirectiveRefs.forEach(function (elOrDirRef) {
	                  if ((elOrDirRef.value.length === 0 && directive.isComponent) ||
	                      (directive.exportAs == elOrDirRef.value)) {
	                      targetReferences.push(new ReferenceAst(elOrDirRef.name, identifierToken(directive.type), elOrDirRef.sourceSpan));
	                      matchedReferences.add(elOrDirRef.name);
	                  }
	              });
	              return new DirectiveAst(directive, directiveProperties, hostProperties, hostEvents, sourceSpan);
	          });
	          elementOrDirectiveRefs.forEach(function (elOrDirRef) {
	              if (elOrDirRef.value.length > 0) {
	                  if (!matchedReferences.has(elOrDirRef.name)) {
	                      _this._reportError("There is no directive with \"exportAs\" set to \"" + elOrDirRef.value + "\"", elOrDirRef.sourceSpan);
	                  }
	              }
	              else if (!component) {
	                  var refToken = null;
	                  if (isTemplateElement) {
	                      refToken = resolveIdentifierToken(Identifiers.TemplateRef);
	                  }
	                  targetReferences.push(new ReferenceAst(elOrDirRef.name, refToken, elOrDirRef.sourceSpan));
	              }
	          }); // fix syntax highlighting issue: `
	          return directiveAsts;
	      };
	      TemplateParseVisitor.prototype._createDirectivePropertyAsts = function (directiveProperties, boundProps, targetBoundDirectiveProps) {
	          if (directiveProperties) {
	              var boundPropsByName_1 = new Map();
	              boundProps.forEach(function (boundProp) {
	                  var prevValue = boundPropsByName_1.get(boundProp.name);
	                  if (!prevValue || prevValue.isLiteral) {
	                      // give [a]="b" a higher precedence than a="b" on the same element
	                      boundPropsByName_1.set(boundProp.name, boundProp);
	                  }
	              });
	              Object.keys(directiveProperties).forEach(function (dirProp) {
	                  var elProp = directiveProperties[dirProp];
	                  var boundProp = boundPropsByName_1.get(elProp);
	                  // Bindings are optional, so this binding only needs to be set up if an expression is given.
	                  if (boundProp) {
	                      targetBoundDirectiveProps.push(new BoundDirectivePropertyAst(dirProp, boundProp.name, boundProp.expression, boundProp.sourceSpan));
	                  }
	              });
	          }
	      };
	      TemplateParseVisitor.prototype._createElementPropertyAsts = function (elementName, props, directives) {
	          var _this = this;
	          var boundElementProps = [];
	          var boundDirectivePropsIndex = new Map();
	          directives.forEach(function (directive) {
	              directive.inputs.forEach(function (prop) {
	                  boundDirectivePropsIndex.set(prop.templateName, prop);
	              });
	          });
	          props.forEach(function (prop) {
	              if (!prop.isLiteral && !boundDirectivePropsIndex.get(prop.name)) {
	                  boundElementProps.push(_this._bindingParser.createElementPropertyAst(elementName, prop));
	              }
	          });
	          this._checkPropertiesInSchema(elementName, boundElementProps);
	          return boundElementProps;
	      };
	      TemplateParseVisitor.prototype._findComponentDirectives = function (directives) {
	          return directives.filter(function (directive) { return directive.directive.isComponent; });
	      };
	      TemplateParseVisitor.prototype._findComponentDirectiveNames = function (directives) {
	          return this._findComponentDirectives(directives)
	              .map(function (directive) { return directive.directive.type.name; });
	      };
	      TemplateParseVisitor.prototype._assertOnlyOneComponent = function (directives, sourceSpan) {
	          var componentTypeNames = this._findComponentDirectiveNames(directives);
	          if (componentTypeNames.length > 1) {
	              this._reportError("More than one component: " + componentTypeNames.join(','), sourceSpan);
	          }
	      };
	      /**
	       * Make sure that non-angular tags conform to the schemas.
	       *
	       * Note: An element is considered an angular tag when at least one directive selector matches the
	       * tag name.
	       *
	       * @param matchElement Whether any directive has matched on the tag name
	       * @param element the html element
	       */
	      TemplateParseVisitor.prototype._assertElementExists = function (matchElement, element) {
	          var elName = element.name.replace(/^:xhtml:/, '');
	          if (!matchElement && !this._schemaRegistry.hasElement(elName, this._schemas)) {
	              var errorMsg = ("'" + elName + "' is not a known element:\n") +
	                  ("1. If '" + elName + "' is an Angular component, then verify that it is part of this module.\n") +
	                  ("2. If '" + elName + "' is a Web Component then add \"CUSTOM_ELEMENTS_SCHEMA\" to the '@NgModule.schemas' of this component to suppress this message.");
	              this._reportError(errorMsg, element.sourceSpan);
	          }
	      };
	      TemplateParseVisitor.prototype._assertNoComponentsNorElementBindingsOnTemplate = function (directives, elementProps, sourceSpan) {
	          var _this = this;
	          var componentTypeNames = this._findComponentDirectiveNames(directives);
	          if (componentTypeNames.length > 0) {
	              this._reportError("Components on an embedded template: " + componentTypeNames.join(','), sourceSpan);
	          }
	          elementProps.forEach(function (prop) {
	              _this._reportError("Property binding " + prop.name + " not used by any directive on an embedded template. Make sure that the property name is spelled correctly and all directives are listed in the \"directives\" section.", sourceSpan);
	          });
	      };
	      TemplateParseVisitor.prototype._assertAllEventsPublishedByDirectives = function (directives, events) {
	          var _this = this;
	          var allDirectiveEvents = new Set();
	          directives.forEach(function (directive) {
	              Object.keys(directive.directive.outputs).forEach(function (k) {
	                  var eventName = directive.directive.outputs[k];
	                  allDirectiveEvents.add(eventName);
	              });
	          });
	          events.forEach(function (event) {
	              if (isPresent(event.target) || !allDirectiveEvents.has(event.name)) {
	                  _this._reportError("Event binding " + event.fullName + " not emitted by any directive on an embedded template. Make sure that the event name is spelled correctly and all directives are listed in the \"directives\" section.", event.sourceSpan);
	              }
	          });
	      };
	      TemplateParseVisitor.prototype._checkPropertiesInSchema = function (elementName, boundProps) {
	          var _this = this;
	          boundProps.forEach(function (boundProp) {
	              if (boundProp.type === exports.PropertyBindingType.Property &&
	                  !_this._schemaRegistry.hasProperty(elementName, boundProp.name, _this._schemas)) {
	                  var errorMsg = "Can't bind to '" + boundProp.name + "' since it isn't a known property of '" + elementName + "'.";
	                  if (elementName.indexOf('-') > -1) {
	                      errorMsg +=
	                          ("\n1. If '" + elementName + "' is an Angular component and it has '" + boundProp.name + "' input, then verify that it is part of this module.") +
	                              ("\n2. If '" + elementName + "' is a Web Component then add \"CUSTOM_ELEMENTS_SCHEMA\" to the '@NgModule.schemas' of this component to suppress this message.\n");
	                  }
	                  _this._reportError(errorMsg, boundProp.sourceSpan);
	              }
	          });
	      };
	      TemplateParseVisitor.prototype._reportError = function (message, sourceSpan, level) {
	          if (level === void 0) { level = exports.ParseErrorLevel.FATAL; }
	          this._targetErrors.push(new ParseError(sourceSpan, message, level));
	      };
	      return TemplateParseVisitor;
	  }());
	  var NonBindableVisitor = (function () {
	      function NonBindableVisitor() {
	      }
	      NonBindableVisitor.prototype.visitElement = function (ast, parent) {
	          var preparsedElement = preparseElement(ast);
	          if (preparsedElement.type === PreparsedElementType.SCRIPT ||
	              preparsedElement.type === PreparsedElementType.STYLE ||
	              preparsedElement.type === PreparsedElementType.STYLESHEET) {
	              // Skipping <script> for security reasons
	              // Skipping <style> and stylesheets as we already processed them
	              // in the StyleCompiler
	              return null;
	          }
	          var attrNameAndValues = ast.attrs.map(function (attrAst) { return [attrAst.name, attrAst.value]; });
	          var selector = createElementCssSelector(ast.name, attrNameAndValues);
	          var ngContentIndex = parent.findNgContentIndex(selector);
	          var children = visitAll(this, ast.children, EMPTY_ELEMENT_CONTEXT);
	          return new ElementAst(ast.name, visitAll(this, ast.attrs), [], [], [], [], [], false, children, ngContentIndex, ast.sourceSpan, ast.endSourceSpan);
	      };
	      NonBindableVisitor.prototype.visitComment = function (comment, context) { return null; };
	      NonBindableVisitor.prototype.visitAttribute = function (attribute, context) {
	          return new AttrAst(attribute.name, attribute.value, attribute.sourceSpan);
	      };
	      NonBindableVisitor.prototype.visitText = function (text, parent) {
	          var ngContentIndex = parent.findNgContentIndex(TEXT_CSS_SELECTOR);
	          return new TextAst(text.value, ngContentIndex, text.sourceSpan);
	      };
	      NonBindableVisitor.prototype.visitExpansion = function (expansion, context) { return expansion; };
	      NonBindableVisitor.prototype.visitExpansionCase = function (expansionCase, context) { return expansionCase; };
	      return NonBindableVisitor;
	  }());
	  var ElementOrDirectiveRef = (function () {
	      function ElementOrDirectiveRef(name, value, sourceSpan) {
	          this.name = name;
	          this.value = value;
	          this.sourceSpan = sourceSpan;
	      }
	      return ElementOrDirectiveRef;
	  }());
	  function splitClasses(classAttrValue) {
	      return classAttrValue.trim().split(/\s+/g);
	  }
	  var ElementContext = (function () {
	      function ElementContext(isTemplateElement, _ngContentIndexMatcher, _wildcardNgContentIndex, providerContext) {
	          this.isTemplateElement = isTemplateElement;
	          this._ngContentIndexMatcher = _ngContentIndexMatcher;
	          this._wildcardNgContentIndex = _wildcardNgContentIndex;
	          this.providerContext = providerContext;
	      }
	      ElementContext.create = function (isTemplateElement, directives, providerContext) {
	          var matcher = new SelectorMatcher();
	          var wildcardNgContentIndex = null;
	          var component = directives.find(function (directive) { return directive.directive.isComponent; });
	          if (component) {
	              var ngContentSelectors = component.directive.template.ngContentSelectors;
	              for (var i = 0; i < ngContentSelectors.length; i++) {
	                  var selector = ngContentSelectors[i];
	                  if (selector === '*') {
	                      wildcardNgContentIndex = i;
	                  }
	                  else {
	                      matcher.addSelectables(CssSelector.parse(ngContentSelectors[i]), i);
	                  }
	              }
	          }
	          return new ElementContext(isTemplateElement, matcher, wildcardNgContentIndex, providerContext);
	      };
	      ElementContext.prototype.findNgContentIndex = function (selector) {
	          var ngContentIndices = [];
	          this._ngContentIndexMatcher.match(selector, function (selector, ngContentIndex) { ngContentIndices.push(ngContentIndex); });
	          ngContentIndices.sort();
	          if (isPresent(this._wildcardNgContentIndex)) {
	              ngContentIndices.push(this._wildcardNgContentIndex);
	          }
	          return ngContentIndices.length > 0 ? ngContentIndices[0] : null;
	      };
	      return ElementContext;
	  }());
	  function createElementCssSelector(elementName, matchableAttrs) {
	      var cssSelector = new CssSelector();
	      var elNameNoNs = splitNsName(elementName)[1];
	      cssSelector.setElement(elNameNoNs);
	      for (var i = 0; i < matchableAttrs.length; i++) {
	          var attrName = matchableAttrs[i][0];
	          var attrNameNoNs = splitNsName(attrName)[1];
	          var attrValue = matchableAttrs[i][1];
	          cssSelector.addAttribute(attrNameNoNs, attrValue);
	          if (attrName.toLowerCase() == CLASS_ATTR) {
	              var classes = splitClasses(attrValue);
	              classes.forEach(function (className) { return cssSelector.addClassName(className); });
	          }
	      }
	      return cssSelector;
	  }
	  var EMPTY_ELEMENT_CONTEXT = new ElementContext(true, new SelectorMatcher(), null, null);
	  var NON_BINDABLE_VISITOR = new NonBindableVisitor();
	  function _isEmptyTextNode(node) {
	      return node instanceof Text && node.value.trim().length == 0;
	  }

	  function unimplemented$1() {
	      throw new Error('unimplemented');
	  }
	  var CompilerConfig = (function () {
	      function CompilerConfig(_a) {
	          var _b = _a === void 0 ? {} : _a, _c = _b.renderTypes, renderTypes = _c === void 0 ? new DefaultRenderTypes() : _c, _d = _b.defaultEncapsulation, defaultEncapsulation = _d === void 0 ? _angular_core.ViewEncapsulation.Emulated : _d, genDebugInfo = _b.genDebugInfo, logBindingUpdate = _b.logBindingUpdate, _e = _b.useJit, useJit = _e === void 0 ? true : _e;
	          this.renderTypes = renderTypes;
	          this.defaultEncapsulation = defaultEncapsulation;
	          this._genDebugInfo = genDebugInfo;
	          this._logBindingUpdate = logBindingUpdate;
	          this.useJit = useJit;
	      }
	      Object.defineProperty(CompilerConfig.prototype, "genDebugInfo", {
	          get: function () {
	              return this._genDebugInfo === void 0 ? _angular_core.isDevMode() : this._genDebugInfo;
	          },
	          enumerable: true,
	          configurable: true
	      });
	      Object.defineProperty(CompilerConfig.prototype, "logBindingUpdate", {
	          get: function () {
	              return this._logBindingUpdate === void 0 ? _angular_core.isDevMode() : this._logBindingUpdate;
	          },
	          enumerable: true,
	          configurable: true
	      });
	      return CompilerConfig;
	  }());
	  /**
	   * Types used for the renderer.
	   * Can be replaced to specialize the generated output to a specific renderer
	   * to help tree shaking.
	   */
	  var RenderTypes = (function () {
	      function RenderTypes() {
	      }
	      Object.defineProperty(RenderTypes.prototype, "renderer", {
	          get: function () { return unimplemented$1(); },
	          enumerable: true,
	          configurable: true
	      });
	      Object.defineProperty(RenderTypes.prototype, "renderText", {
	          get: function () { return unimplemented$1(); },
	          enumerable: true,
	          configurable: true
	      });
	      Object.defineProperty(RenderTypes.prototype, "renderElement", {
	          get: function () { return unimplemented$1(); },
	          enumerable: true,
	          configurable: true
	      });
	      Object.defineProperty(RenderTypes.prototype, "renderComment", {
	          get: function () { return unimplemented$1(); },
	          enumerable: true,
	          configurable: true
	      });
	      Object.defineProperty(RenderTypes.prototype, "renderNode", {
	          get: function () { return unimplemented$1(); },
	          enumerable: true,
	          configurable: true
	      });
	      Object.defineProperty(RenderTypes.prototype, "renderEvent", {
	          get: function () { return unimplemented$1(); },
	          enumerable: true,
	          configurable: true
	      });
	      return RenderTypes;
	  }());
	  var DefaultRenderTypes = (function () {
	      function DefaultRenderTypes() {
	          this.renderText = null;
	          this.renderElement = null;
	          this.renderComment = null;
	          this.renderNode = null;
	          this.renderEvent = null;
	      }
	      Object.defineProperty(DefaultRenderTypes.prototype, "renderer", {
	          get: function () { return resolveIdentifier(Identifiers.Renderer); },
	          enumerable: true,
	          configurable: true
	      });
	      ;
	      return DefaultRenderTypes;
	  }());

	  /**
	   * @license
	   * Copyright Google Inc. All Rights Reserved.
	   *
	   * Use of this source code is governed by an MIT-style license that can be
	   * found in the LICENSE file at https://angular.io/license
	   */
	  var __extends$12 = (this && this.__extends) || function (d, b) {
	      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	      function __() { this.constructor = d; }
	      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	  };
	  //// Types
	  var TypeModifier;
	  (function (TypeModifier) {
	      TypeModifier[TypeModifier["Const"] = 0] = "Const";
	  })(TypeModifier || (TypeModifier = {}));
	  var Type$1 = (function () {
	      function Type(modifiers) {
	          if (modifiers === void 0) { modifiers = null; }
	          this.modifiers = modifiers;
	          if (!modifiers) {
	              this.modifiers = [];
	          }
	      }
	      Type.prototype.hasModifier = function (modifier) { return this.modifiers.indexOf(modifier) !== -1; };
	      return Type;
	  }());
	  var BuiltinTypeName;
	  (function (BuiltinTypeName) {
	      BuiltinTypeName[BuiltinTypeName["Dynamic"] = 0] = "Dynamic";
	      BuiltinTypeName[BuiltinTypeName["Bool"] = 1] = "Bool";
	      BuiltinTypeName[BuiltinTypeName["String"] = 2] = "String";
	      BuiltinTypeName[BuiltinTypeName["Int"] = 3] = "Int";
	      BuiltinTypeName[BuiltinTypeName["Number"] = 4] = "Number";
	      BuiltinTypeName[BuiltinTypeName["Function"] = 5] = "Function";
	  })(BuiltinTypeName || (BuiltinTypeName = {}));
	  var BuiltinType = (function (_super) {
	      __extends$12(BuiltinType, _super);
	      function BuiltinType(name, modifiers) {
	          if (modifiers === void 0) { modifiers = null; }
	          _super.call(this, modifiers);
	          this.name = name;
	      }
	      BuiltinType.prototype.visitType = function (visitor, context) {
	          return visitor.visitBuiltintType(this, context);
	      };
	      return BuiltinType;
	  }(Type$1));
	  var ExternalType = (function (_super) {
	      __extends$12(ExternalType, _super);
	      function ExternalType(value, typeParams, modifiers) {
	          if (typeParams === void 0) { typeParams = null; }
	          if (modifiers === void 0) { modifiers = null; }
	          _super.call(this, modifiers);
	          this.value = value;
	          this.typeParams = typeParams;
	      }
	      ExternalType.prototype.visitType = function (visitor, context) {
	          return visitor.visitExternalType(this, context);
	      };
	      return ExternalType;
	  }(Type$1));
	  var ArrayType = (function (_super) {
	      __extends$12(ArrayType, _super);
	      function ArrayType(of, modifiers) {
	          if (modifiers === void 0) { modifiers = null; }
	          _super.call(this, modifiers);
	          this.of = of;
	      }
	      ArrayType.prototype.visitType = function (visitor, context) {
	          return visitor.visitArrayType(this, context);
	      };
	      return ArrayType;
	  }(Type$1));
	  var MapType = (function (_super) {
	      __extends$12(MapType, _super);
	      function MapType(valueType, modifiers) {
	          if (modifiers === void 0) { modifiers = null; }
	          _super.call(this, modifiers);
	          this.valueType = valueType;
	      }
	      MapType.prototype.visitType = function (visitor, context) { return visitor.visitMapType(this, context); };
	      return MapType;
	  }(Type$1));
	  var DYNAMIC_TYPE = new BuiltinType(BuiltinTypeName.Dynamic);
	  var BOOL_TYPE = new BuiltinType(BuiltinTypeName.Bool);
	  var INT_TYPE = new BuiltinType(BuiltinTypeName.Int);
	  var NUMBER_TYPE = new BuiltinType(BuiltinTypeName.Number);
	  var STRING_TYPE = new BuiltinType(BuiltinTypeName.String);
	  var FUNCTION_TYPE = new BuiltinType(BuiltinTypeName.Function);
	  ///// Expressions
	  var BinaryOperator;
	  (function (BinaryOperator) {
	      BinaryOperator[BinaryOperator["Equals"] = 0] = "Equals";
	      BinaryOperator[BinaryOperator["NotEquals"] = 1] = "NotEquals";
	      BinaryOperator[BinaryOperator["Identical"] = 2] = "Identical";
	      BinaryOperator[BinaryOperator["NotIdentical"] = 3] = "NotIdentical";
	      BinaryOperator[BinaryOperator["Minus"] = 4] = "Minus";
	      BinaryOperator[BinaryOperator["Plus"] = 5] = "Plus";
	      BinaryOperator[BinaryOperator["Divide"] = 6] = "Divide";
	      BinaryOperator[BinaryOperator["Multiply"] = 7] = "Multiply";
	      BinaryOperator[BinaryOperator["Modulo"] = 8] = "Modulo";
	      BinaryOperator[BinaryOperator["And"] = 9] = "And";
	      BinaryOperator[BinaryOperator["Or"] = 10] = "Or";
	      BinaryOperator[BinaryOperator["Lower"] = 11] = "Lower";
	      BinaryOperator[BinaryOperator["LowerEquals"] = 12] = "LowerEquals";
	      BinaryOperator[BinaryOperator["Bigger"] = 13] = "Bigger";
	      BinaryOperator[BinaryOperator["BiggerEquals"] = 14] = "BiggerEquals";
	  })(BinaryOperator || (BinaryOperator = {}));
	  var Expression = (function () {
	      function Expression(type) {
	          this.type = type;
	      }
	      Expression.prototype.prop = function (name) { return new ReadPropExpr(this, name); };
	      Expression.prototype.key = function (index, type) {
	          if (type === void 0) { type = null; }
	          return new ReadKeyExpr(this, index, type);
	      };
	      Expression.prototype.callMethod = function (name, params) {
	          return new InvokeMethodExpr(this, name, params);
	      };
	      Expression.prototype.callFn = function (params) { return new InvokeFunctionExpr(this, params); };
	      Expression.prototype.instantiate = function (params, type) {
	          if (type === void 0) { type = null; }
	          return new InstantiateExpr(this, params, type);
	      };
	      Expression.prototype.conditional = function (trueCase, falseCase) {
	          if (falseCase === void 0) { falseCase = null; }
	          return new ConditionalExpr(this, trueCase, falseCase);
	      };
	      Expression.prototype.equals = function (rhs) {
	          return new BinaryOperatorExpr(BinaryOperator.Equals, this, rhs);
	      };
	      Expression.prototype.notEquals = function (rhs) {
	          return new BinaryOperatorExpr(BinaryOperator.NotEquals, this, rhs);
	      };
	      Expression.prototype.identical = function (rhs) {
	          return new BinaryOperatorExpr(BinaryOperator.Identical, this, rhs);
	      };
	      Expression.prototype.notIdentical = function (rhs) {
	          return new BinaryOperatorExpr(BinaryOperator.NotIdentical, this, rhs);
	      };
	      Expression.prototype.minus = function (rhs) {
	          return new BinaryOperatorExpr(BinaryOperator.Minus, this, rhs);
	      };
	      Expression.prototype.plus = function (rhs) {
	          return new BinaryOperatorExpr(BinaryOperator.Plus, this, rhs);
	      };
	      Expression.prototype.divide = function (rhs) {
	          return new BinaryOperatorExpr(BinaryOperator.Divide, this, rhs);
	      };
	      Expression.prototype.multiply = function (rhs) {
	          return new BinaryOperatorExpr(BinaryOperator.Multiply, this, rhs);
	      };
	      Expression.prototype.modulo = function (rhs) {
	          return new BinaryOperatorExpr(BinaryOperator.Modulo, this, rhs);
	      };
	      Expression.prototype.and = function (rhs) {
	          return new BinaryOperatorExpr(BinaryOperator.And, this, rhs);
	      };
	      Expression.prototype.or = function (rhs) {
	          return new BinaryOperatorExpr(BinaryOperator.Or, this, rhs);
	      };
	      Expression.prototype.lower = function (rhs) {
	          return new BinaryOperatorExpr(BinaryOperator.Lower, this, rhs);
	      };
	      Expression.prototype.lowerEquals = function (rhs) {
	          return new BinaryOperatorExpr(BinaryOperator.LowerEquals, this, rhs);
	      };
	      Expression.prototype.bigger = function (rhs) {
	          return new BinaryOperatorExpr(BinaryOperator.Bigger, this, rhs);
	      };
	      Expression.prototype.biggerEquals = function (rhs) {
	          return new BinaryOperatorExpr(BinaryOperator.BiggerEquals, this, rhs);
	      };
	      Expression.prototype.isBlank = function () {
	          // Note: We use equals by purpose here to compare to null and undefined in JS.
	          return this.equals(NULL_EXPR);
	      };
	      Expression.prototype.cast = function (type) { return new CastExpr(this, type); };
	      Expression.prototype.toStmt = function () { return new ExpressionStatement(this); };
	      return Expression;
	  }());
	  var BuiltinVar;
	  (function (BuiltinVar) {
	      BuiltinVar[BuiltinVar["This"] = 0] = "This";
	      BuiltinVar[BuiltinVar["Super"] = 1] = "Super";
	      BuiltinVar[BuiltinVar["CatchError"] = 2] = "CatchError";
	      BuiltinVar[BuiltinVar["CatchStack"] = 3] = "CatchStack";
	  })(BuiltinVar || (BuiltinVar = {}));
	  var ReadVarExpr = (function (_super) {
	      __extends$12(ReadVarExpr, _super);
	      function ReadVarExpr(name, type) {
	          if (type === void 0) { type = null; }
	          _super.call(this, type);
	          if (typeof name === 'string') {
	              this.name = name;
	              this.builtin = null;
	          }
	          else {
	              this.name = null;
	              this.builtin = name;
	          }
	      }
	      ReadVarExpr.prototype.visitExpression = function (visitor, context) {
	          return visitor.visitReadVarExpr(this, context);
	      };
	      ReadVarExpr.prototype.set = function (value) { return new WriteVarExpr(this.name, value); };
	      return ReadVarExpr;
	  }(Expression));
	  var WriteVarExpr = (function (_super) {
	      __extends$12(WriteVarExpr, _super);
	      function WriteVarExpr(name, value, type) {
	          if (type === void 0) { type = null; }
	          _super.call(this, type || value.type);
	          this.name = name;
	          this.value = value;
	      }
	      WriteVarExpr.prototype.visitExpression = function (visitor, context) {
	          return visitor.visitWriteVarExpr(this, context);
	      };
	      WriteVarExpr.prototype.toDeclStmt = function (type, modifiers) {
	          if (type === void 0) { type = null; }
	          if (modifiers === void 0) { modifiers = null; }
	          return new DeclareVarStmt(this.name, this.value, type, modifiers);
	      };
	      return WriteVarExpr;
	  }(Expression));
	  var WriteKeyExpr = (function (_super) {
	      __extends$12(WriteKeyExpr, _super);
	      function WriteKeyExpr(receiver, index, value, type) {
	          if (type === void 0) { type = null; }
	          _super.call(this, type || value.type);
	          this.receiver = receiver;
	          this.index = index;
	          this.value = value;
	      }
	      WriteKeyExpr.prototype.visitExpression = function (visitor, context) {
	          return visitor.visitWriteKeyExpr(this, context);
	      };
	      return WriteKeyExpr;
	  }(Expression));
	  var WritePropExpr = (function (_super) {
	      __extends$12(WritePropExpr, _super);
	      function WritePropExpr(receiver, name, value, type) {
	          if (type === void 0) { type = null; }
	          _super.call(this, type || value.type);
	          this.receiver = receiver;
	          this.name = name;
	          this.value = value;
	      }
	      WritePropExpr.prototype.visitExpression = function (visitor, context) {
	          return visitor.visitWritePropExpr(this, context);
	      };
	      return WritePropExpr;
	  }(Expression));
	  var BuiltinMethod;
	  (function (BuiltinMethod) {
	      BuiltinMethod[BuiltinMethod["ConcatArray"] = 0] = "ConcatArray";
	      BuiltinMethod[BuiltinMethod["SubscribeObservable"] = 1] = "SubscribeObservable";
	      BuiltinMethod[BuiltinMethod["Bind"] = 2] = "Bind";
	  })(BuiltinMethod || (BuiltinMethod = {}));
	  var InvokeMethodExpr = (function (_super) {
	      __extends$12(InvokeMethodExpr, _super);
	      function InvokeMethodExpr(receiver, method, args, type) {
	          if (type === void 0) { type = null; }
	          _super.call(this, type);
	          this.receiver = receiver;
	          this.args = args;
	          if (typeof method === 'string') {
	              this.name = method;
	              this.builtin = null;
	          }
	          else {
	              this.name = null;
	              this.builtin = method;
	          }
	      }
	      InvokeMethodExpr.prototype.visitExpression = function (visitor, context) {
	          return visitor.visitInvokeMethodExpr(this, context);
	      };
	      return InvokeMethodExpr;
	  }(Expression));
	  var InvokeFunctionExpr = (function (_super) {
	      __extends$12(InvokeFunctionExpr, _super);
	      function InvokeFunctionExpr(fn, args, type) {
	          if (type === void 0) { type = null; }
	          _super.call(this, type);
	          this.fn = fn;
	          this.args = args;
	      }
	      InvokeFunctionExpr.prototype.visitExpression = function (visitor, context) {
	          return visitor.visitInvokeFunctionExpr(this, context);
	      };
	      return InvokeFunctionExpr;
	  }(Expression));
	  var InstantiateExpr = (function (_super) {
	      __extends$12(InstantiateExpr, _super);
	      function InstantiateExpr(classExpr, args, type) {
	          _super.call(this, type);
	          this.classExpr = classExpr;
	          this.args = args;
	      }
	      InstantiateExpr.prototype.visitExpression = function (visitor, context) {
	          return visitor.visitInstantiateExpr(this, context);
	      };
	      return InstantiateExpr;
	  }(Expression));
	  var LiteralExpr = (function (_super) {
	      __extends$12(LiteralExpr, _super);
	      function LiteralExpr(value, type) {
	          if (type === void 0) { type = null; }
	          _super.call(this, type);
	          this.value = value;
	      }
	      LiteralExpr.prototype.visitExpression = function (visitor, context) {
	          return visitor.visitLiteralExpr(this, context);
	      };
	      return LiteralExpr;
	  }(Expression));
	  var ExternalExpr = (function (_super) {
	      __extends$12(ExternalExpr, _super);
	      function ExternalExpr(value, type, typeParams) {
	          if (type === void 0) { type = null; }
	          if (typeParams === void 0) { typeParams = null; }
	          _super.call(this, type);
	          this.value = value;
	          this.typeParams = typeParams;
	      }
	      ExternalExpr.prototype.visitExpression = function (visitor, context) {
	          return visitor.visitExternalExpr(this, context);
	      };
	      return ExternalExpr;
	  }(Expression));
	  var ConditionalExpr = (function (_super) {
	      __extends$12(ConditionalExpr, _super);
	      function ConditionalExpr(condition, trueCase, falseCase, type) {
	          if (falseCase === void 0) { falseCase = null; }
	          if (type === void 0) { type = null; }
	          _super.call(this, type || trueCase.type);
	          this.condition = condition;
	          this.falseCase = falseCase;
	          this.trueCase = trueCase;
	      }
	      ConditionalExpr.prototype.visitExpression = function (visitor, context) {
	          return visitor.visitConditionalExpr(this, context);
	      };
	      return ConditionalExpr;
	  }(Expression));
	  var NotExpr = (function (_super) {
	      __extends$12(NotExpr, _super);
	      function NotExpr(condition) {
	          _super.call(this, BOOL_TYPE);
	          this.condition = condition;
	      }
	      NotExpr.prototype.visitExpression = function (visitor, context) {
	          return visitor.visitNotExpr(this, context);
	      };
	      return NotExpr;
	  }(Expression));
	  var CastExpr = (function (_super) {
	      __extends$12(CastExpr, _super);
	      function CastExpr(value, type) {
	          _super.call(this, type);
	          this.value = value;
	      }
	      CastExpr.prototype.visitExpression = function (visitor, context) {
	          return visitor.visitCastExpr(this, context);
	      };
	      return CastExpr;
	  }(Expression));
	  var FnParam = (function () {
	      function FnParam(name, type) {
	          if (type === void 0) { type = null; }
	          this.name = name;
	          this.type = type;
	      }
	      return FnParam;
	  }());
	  var FunctionExpr = (function (_super) {
	      __extends$12(FunctionExpr, _super);
	      function FunctionExpr(params, statements, type) {
	          if (type === void 0) { type = null; }
	          _super.call(this, type);
	          this.params = params;
	          this.statements = statements;
	      }
	      FunctionExpr.prototype.visitExpression = function (visitor, context) {
	          return visitor.visitFunctionExpr(this, context);
	      };
	      FunctionExpr.prototype.toDeclStmt = function (name, modifiers) {
	          if (modifiers === void 0) { modifiers = null; }
	          return new DeclareFunctionStmt(name, this.params, this.statements, this.type, modifiers);
	      };
	      return FunctionExpr;
	  }(Expression));
	  var BinaryOperatorExpr = (function (_super) {
	      __extends$12(BinaryOperatorExpr, _super);
	      function BinaryOperatorExpr(operator, lhs, rhs, type) {
	          if (type === void 0) { type = null; }
	          _super.call(this, type || lhs.type);
	          this.operator = operator;
	          this.rhs = rhs;
	          this.lhs = lhs;
	      }
	      BinaryOperatorExpr.prototype.visitExpression = function (visitor, context) {
	          return visitor.visitBinaryOperatorExpr(this, context);
	      };
	      return BinaryOperatorExpr;
	  }(Expression));
	  var ReadPropExpr = (function (_super) {
	      __extends$12(ReadPropExpr, _super);
	      function ReadPropExpr(receiver, name, type) {
	          if (type === void 0) { type = null; }
	          _super.call(this, type);
	          this.receiver = receiver;
	          this.name = name;
	      }
	      ReadPropExpr.prototype.visitExpression = function (visitor, context) {
	          return visitor.visitReadPropExpr(this, context);
	      };
	      ReadPropExpr.prototype.set = function (value) {
	          return new WritePropExpr(this.receiver, this.name, value);
	      };
	      return ReadPropExpr;
	  }(Expression));
	  var ReadKeyExpr = (function (_super) {
	      __extends$12(ReadKeyExpr, _super);
	      function ReadKeyExpr(receiver, index, type) {
	          if (type === void 0) { type = null; }
	          _super.call(this, type);
	          this.receiver = receiver;
	          this.index = index;
	      }
	      ReadKeyExpr.prototype.visitExpression = function (visitor, context) {
	          return visitor.visitReadKeyExpr(this, context);
	      };
	      ReadKeyExpr.prototype.set = function (value) {
	          return new WriteKeyExpr(this.receiver, this.index, value);
	      };
	      return ReadKeyExpr;
	  }(Expression));
	  var LiteralArrayExpr = (function (_super) {
	      __extends$12(LiteralArrayExpr, _super);
	      function LiteralArrayExpr(entries, type) {
	          if (type === void 0) { type = null; }
	          _super.call(this, type);
	          this.entries = entries;
	      }
	      LiteralArrayExpr.prototype.visitExpression = function (visitor, context) {
	          return visitor.visitLiteralArrayExpr(this, context);
	      };
	      return LiteralArrayExpr;
	  }(Expression));
	  var LiteralMapExpr = (function (_super) {
	      __extends$12(LiteralMapExpr, _super);
	      function LiteralMapExpr(entries, type) {
	          if (type === void 0) { type = null; }
	          _super.call(this, type);
	          this.entries = entries;
	          this.valueType = null;
	          if (isPresent(type)) {
	              this.valueType = type.valueType;
	          }
	      }
	      LiteralMapExpr.prototype.visitExpression = function (visitor, context) {
	          return visitor.visitLiteralMapExpr(this, context);
	      };
	      return LiteralMapExpr;
	  }(Expression));
	  var THIS_EXPR = new ReadVarExpr(BuiltinVar.This);
	  var SUPER_EXPR = new ReadVarExpr(BuiltinVar.Super);
	  var CATCH_ERROR_VAR = new ReadVarExpr(BuiltinVar.CatchError);
	  var CATCH_STACK_VAR = new ReadVarExpr(BuiltinVar.CatchStack);
	  var NULL_EXPR = new LiteralExpr(null, null);
	  //// Statements
	  var StmtModifier;
	  (function (StmtModifier) {
	      StmtModifier[StmtModifier["Final"] = 0] = "Final";
	      StmtModifier[StmtModifier["Private"] = 1] = "Private";
	  })(StmtModifier || (StmtModifier = {}));
	  var Statement = (function () {
	      function Statement(modifiers) {
	          if (modifiers === void 0) { modifiers = null; }
	          this.modifiers = modifiers;
	          if (!modifiers) {
	              this.modifiers = [];
	          }
	      }
	      Statement.prototype.hasModifier = function (modifier) { return this.modifiers.indexOf(modifier) !== -1; };
	      return Statement;
	  }());
	  var DeclareVarStmt = (function (_super) {
	      __extends$12(DeclareVarStmt, _super);
	      function DeclareVarStmt(name, value, type, modifiers) {
	          if (type === void 0) { type = null; }
	          if (modifiers === void 0) { modifiers = null; }
	          _super.call(this, modifiers);
	          this.name = name;
	          this.value = value;
	          this.type = type || value.type;
	      }
	      DeclareVarStmt.prototype.visitStatement = function (visitor, context) {
	          return visitor.visitDeclareVarStmt(this, context);
	      };
	      return DeclareVarStmt;
	  }(Statement));
	  var DeclareFunctionStmt = (function (_super) {
	      __extends$12(DeclareFunctionStmt, _super);
	      function DeclareFunctionStmt(name, params, statements, type, modifiers) {
	          if (type === void 0) { type = null; }
	          if (modifiers === void 0) { modifiers = null; }
	          _super.call(this, modifiers);
	          this.name = name;
	          this.params = params;
	          this.statements = statements;
	          this.type = type;
	      }
	      DeclareFunctionStmt.prototype.visitStatement = function (visitor, context) {
	          return visitor.visitDeclareFunctionStmt(this, context);
	      };
	      return DeclareFunctionStmt;
	  }(Statement));
	  var ExpressionStatement = (function (_super) {
	      __extends$12(ExpressionStatement, _super);
	      function ExpressionStatement(expr) {
	          _super.call(this);
	          this.expr = expr;
	      }
	      ExpressionStatement.prototype.visitStatement = function (visitor, context) {
	          return visitor.visitExpressionStmt(this, context);
	      };
	      return ExpressionStatement;
	  }(Statement));
	  var ReturnStatement = (function (_super) {
	      __extends$12(ReturnStatement, _super);
	      function ReturnStatement(value) {
	          _super.call(this);
	          this.value = value;
	      }
	      ReturnStatement.prototype.visitStatement = function (visitor, context) {
	          return visitor.visitReturnStmt(this, context);
	      };
	      return ReturnStatement;
	  }(Statement));
	  var AbstractClassPart = (function () {
	      function AbstractClassPart(type, modifiers) {
	          if (type === void 0) { type = null; }
	          this.type = type;
	          this.modifiers = modifiers;
	          if (!modifiers) {
	              this.modifiers = [];
	          }
	      }
	      AbstractClassPart.prototype.hasModifier = function (modifier) { return this.modifiers.indexOf(modifier) !== -1; };
	      return AbstractClassPart;
	  }());
	  var ClassField = (function (_super) {
	      __extends$12(ClassField, _super);
	      function ClassField(name, type, modifiers) {
	          if (type === void 0) { type = null; }
	          if (modifiers === void 0) { modifiers = null; }
	          _super.call(this, type, modifiers);
	          this.name = name;
	      }
	      return ClassField;
	  }(AbstractClassPart));
	  var ClassMethod = (function (_super) {
	      __extends$12(ClassMethod, _super);
	      function ClassMethod(name, params, body, type, modifiers) {
	          if (type === void 0) { type = null; }
	          if (modifiers === void 0) { modifiers = null; }
	          _super.call(this, type, modifiers);
	          this.name = name;
	          this.params = params;
	          this.body = body;
	      }
	      return ClassMethod;
	  }(AbstractClassPart));
	  var ClassGetter = (function (_super) {
	      __extends$12(ClassGetter, _super);
	      function ClassGetter(name, body, type, modifiers) {
	          if (type === void 0) { type = null; }
	          if (modifiers === void 0) { modifiers = null; }
	          _super.call(this, type, modifiers);
	          this.name = name;
	          this.body = body;
	      }
	      return ClassGetter;
	  }(AbstractClassPart));
	  var ClassStmt = (function (_super) {
	      __extends$12(ClassStmt, _super);
	      function ClassStmt(name, parent, fields, getters, constructorMethod, methods, modifiers) {
	          if (modifiers === void 0) { modifiers = null; }
	          _super.call(this, modifiers);
	          this.name = name;
	          this.parent = parent;
	          this.fields = fields;
	          this.getters = getters;
	          this.constructorMethod = constructorMethod;
	          this.methods = methods;
	      }
	      ClassStmt.prototype.visitStatement = function (visitor, context) {
	          return visitor.visitDeclareClassStmt(this, context);
	      };
	      return ClassStmt;
	  }(Statement));
	  var IfStmt = (function (_super) {
	      __extends$12(IfStmt, _super);
	      function IfStmt(condition, trueCase, falseCase) {
	          if (falseCase === void 0) { falseCase = []; }
	          _super.call(this);
	          this.condition = condition;
	          this.trueCase = trueCase;
	          this.falseCase = falseCase;
	      }
	      IfStmt.prototype.visitStatement = function (visitor, context) {
	          return visitor.visitIfStmt(this, context);
	      };
	      return IfStmt;
	  }(Statement));
	  var CommentStmt = (function (_super) {
	      __extends$12(CommentStmt, _super);
	      function CommentStmt(comment) {
	          _super.call(this);
	          this.comment = comment;
	      }
	      CommentStmt.prototype.visitStatement = function (visitor, context) {
	          return visitor.visitCommentStmt(this, context);
	      };
	      return CommentStmt;
	  }(Statement));
	  var TryCatchStmt = (function (_super) {
	      __extends$12(TryCatchStmt, _super);
	      function TryCatchStmt(bodyStmts, catchStmts) {
	          _super.call(this);
	          this.bodyStmts = bodyStmts;
	          this.catchStmts = catchStmts;
	      }
	      TryCatchStmt.prototype.visitStatement = function (visitor, context) {
	          return visitor.visitTryCatchStmt(this, context);
	      };
	      return TryCatchStmt;
	  }(Statement));
	  var ThrowStmt = (function (_super) {
	      __extends$12(ThrowStmt, _super);
	      function ThrowStmt(error) {
	          _super.call(this);
	          this.error = error;
	      }
	      ThrowStmt.prototype.visitStatement = function (visitor, context) {
	          return visitor.visitThrowStmt(this, context);
	      };
	      return ThrowStmt;
	  }(Statement));
	  var ExpressionTransformer = (function () {
	      function ExpressionTransformer() {
	      }
	      ExpressionTransformer.prototype.visitReadVarExpr = function (ast, context) { return ast; };
	      ExpressionTransformer.prototype.visitWriteVarExpr = function (expr, context) {
	          return new WriteVarExpr(expr.name, expr.value.visitExpression(this, context));
	      };
	      ExpressionTransformer.prototype.visitWriteKeyExpr = function (expr, context) {
	          return new WriteKeyExpr(expr.receiver.visitExpression(this, context), expr.index.visitExpression(this, context), expr.value.visitExpression(this, context));
	      };
	      ExpressionTransformer.prototype.visitWritePropExpr = function (expr, context) {
	          return new WritePropExpr(expr.receiver.visitExpression(this, context), expr.name, expr.value.visitExpression(this, context));
	      };
	      ExpressionTransformer.prototype.visitInvokeMethodExpr = function (ast, context) {
	          var method = ast.builtin || ast.name;
	          return new InvokeMethodExpr(ast.receiver.visitExpression(this, context), method, this.visitAllExpressions(ast.args, context), ast.type);
	      };
	      ExpressionTransformer.prototype.visitInvokeFunctionExpr = function (ast, context) {
	          return new InvokeFunctionExpr(ast.fn.visitExpression(this, context), this.visitAllExpressions(ast.args, context), ast.type);
	      };
	      ExpressionTransformer.prototype.visitInstantiateExpr = function (ast, context) {
	          return new InstantiateExpr(ast.classExpr.visitExpression(this, context), this.visitAllExpressions(ast.args, context), ast.type);
	      };
	      ExpressionTransformer.prototype.visitLiteralExpr = function (ast, context) { return ast; };
	      ExpressionTransformer.prototype.visitExternalExpr = function (ast, context) { return ast; };
	      ExpressionTransformer.prototype.visitConditionalExpr = function (ast, context) {
	          return new ConditionalExpr(ast.condition.visitExpression(this, context), ast.trueCase.visitExpression(this, context), ast.falseCase.visitExpression(this, context));
	      };
	      ExpressionTransformer.prototype.visitNotExpr = function (ast, context) {
	          return new NotExpr(ast.condition.visitExpression(this, context));
	      };
	      ExpressionTransformer.prototype.visitCastExpr = function (ast, context) {
	          return new CastExpr(ast.value.visitExpression(this, context), context);
	      };
	      ExpressionTransformer.prototype.visitFunctionExpr = function (ast, context) {
	          // Don't descend into nested functions
	          return ast;
	      };
	      ExpressionTransformer.prototype.visitBinaryOperatorExpr = function (ast, context) {
	          return new BinaryOperatorExpr(ast.operator, ast.lhs.visitExpression(this, context), ast.rhs.visitExpression(this, context), ast.type);
	      };
	      ExpressionTransformer.prototype.visitReadPropExpr = function (ast, context) {
	          return new ReadPropExpr(ast.receiver.visitExpression(this, context), ast.name, ast.type);
	      };
	      ExpressionTransformer.prototype.visitReadKeyExpr = function (ast, context) {
	          return new ReadKeyExpr(ast.receiver.visitExpression(this, context), ast.index.visitExpression(this, context), ast.type);
	      };
	      ExpressionTransformer.prototype.visitLiteralArrayExpr = function (ast, context) {
	          return new LiteralArrayExpr(this.visitAllExpressions(ast.entries, context));
	      };
	      ExpressionTransformer.prototype.visitLiteralMapExpr = function (ast, context) {
	          var _this = this;
	          var entries = ast.entries.map(function (entry) { return [entry[0], entry[1].visitExpression(_this, context),]; });
	          return new LiteralMapExpr(entries);
	      };
	      ExpressionTransformer.prototype.visitAllExpressions = function (exprs, context) {
	          var _this = this;
	          return exprs.map(function (expr) { return expr.visitExpression(_this, context); });
	      };
	      ExpressionTransformer.prototype.visitDeclareVarStmt = function (stmt, context) {
	          return new DeclareVarStmt(stmt.name, stmt.value.visitExpression(this, context), stmt.type, stmt.modifiers);
	      };
	      ExpressionTransformer.prototype.visitDeclareFunctionStmt = function (stmt, context) {
	          // Don't descend into nested functions
	          return stmt;
	      };
	      ExpressionTransformer.prototype.visitExpressionStmt = function (stmt, context) {
	          return new ExpressionStatement(stmt.expr.visitExpression(this, context));
	      };
	      ExpressionTransformer.prototype.visitReturnStmt = function (stmt, context) {
	          return new ReturnStatement(stmt.value.visitExpression(this, context));
	      };
	      ExpressionTransformer.prototype.visitDeclareClassStmt = function (stmt, context) {
	          // Don't descend into nested functions
	          return stmt;
	      };
	      ExpressionTransformer.prototype.visitIfStmt = function (stmt, context) {
	          return new IfStmt(stmt.condition.visitExpression(this, context), this.visitAllStatements(stmt.trueCase, context), this.visitAllStatements(stmt.falseCase, context));
	      };
	      ExpressionTransformer.prototype.visitTryCatchStmt = function (stmt, context) {
	          return new TryCatchStmt(this.visitAllStatements(stmt.bodyStmts, context), this.visitAllStatements(stmt.catchStmts, context));
	      };
	      ExpressionTransformer.prototype.visitThrowStmt = function (stmt, context) {
	          return new ThrowStmt(stmt.error.visitExpression(this, context));
	      };
	      ExpressionTransformer.prototype.visitCommentStmt = function (stmt, context) { return stmt; };
	      ExpressionTransformer.prototype.visitAllStatements = function (stmts, context) {
	          var _this = this;
	          return stmts.map(function (stmt) { return stmt.visitStatement(_this, context); });
	      };
	      return ExpressionTransformer;
	  }());
	  var RecursiveExpressionVisitor = (function () {
	      function RecursiveExpressionVisitor() {
	      }
	      RecursiveExpressionVisitor.prototype.visitReadVarExpr = function (ast, context) { return ast; };
	      RecursiveExpressionVisitor.prototype.visitWriteVarExpr = function (expr, context) {
	          expr.value.visitExpression(this, context);
	          return expr;
	      };
	      RecursiveExpressionVisitor.prototype.visitWriteKeyExpr = function (expr, context) {
	          expr.receiver.visitExpression(this, context);
	          expr.index.visitExpression(this, context);
	          expr.value.visitExpression(this, context);
	          return expr;
	      };
	      RecursiveExpressionVisitor.prototype.visitWritePropExpr = function (expr, context) {
	          expr.receiver.visitExpression(this, context);
	          expr.value.visitExpression(this, context);
	          return expr;
	      };
	      RecursiveExpressionVisitor.prototype.visitInvokeMethodExpr = function (ast, context) {
	          ast.receiver.visitExpression(this, context);
	          this.visitAllExpressions(ast.args, context);
	          return ast;
	      };
	      RecursiveExpressionVisitor.prototype.visitInvokeFunctionExpr = function (ast, context) {
	          ast.fn.visitExpression(this, context);
	          this.visitAllExpressions(ast.args, context);
	          return ast;
	      };
	      RecursiveExpressionVisitor.prototype.visitInstantiateExpr = function (ast, context) {
	          ast.classExpr.visitExpression(this, context);
	          this.visitAllExpressions(ast.args, context);
	          return ast;
	      };
	      RecursiveExpressionVisitor.prototype.visitLiteralExpr = function (ast, context) { return ast; };
	      RecursiveExpressionVisitor.prototype.visitExternalExpr = function (ast, context) { return ast; };
	      RecursiveExpressionVisitor.prototype.visitConditionalExpr = function (ast, context) {
	          ast.condition.visitExpression(this, context);
	          ast.trueCase.visitExpression(this, context);
	          ast.falseCase.visitExpression(this, context);
	          return ast;
	      };
	      RecursiveExpressionVisitor.prototype.visitNotExpr = function (ast, context) {
	          ast.condition.visitExpression(this, context);
	          return ast;
	      };
	      RecursiveExpressionVisitor.prototype.visitCastExpr = function (ast, context) {
	          ast.value.visitExpression(this, context);
	          return ast;
	      };
	      RecursiveExpressionVisitor.prototype.visitFunctionExpr = function (ast, context) { return ast; };
	      RecursiveExpressionVisitor.prototype.visitBinaryOperatorExpr = function (ast, context) {
	          ast.lhs.visitExpression(this, context);
	          ast.rhs.visitExpression(this, context);
	          return ast;
	      };
	      RecursiveExpressionVisitor.prototype.visitReadPropExpr = function (ast, context) {
	          ast.receiver.visitExpression(this, context);
	          return ast;
	      };
	      RecursiveExpressionVisitor.prototype.visitReadKeyExpr = function (ast, context) {
	          ast.receiver.visitExpression(this, context);
	          ast.index.visitExpression(this, context);
	          return ast;
	      };
	      RecursiveExpressionVisitor.prototype.visitLiteralArrayExpr = function (ast, context) {
	          this.visitAllExpressions(ast.entries, context);
	          return ast;
	      };
	      RecursiveExpressionVisitor.prototype.visitLiteralMapExpr = function (ast, context) {
	          var _this = this;
	          ast.entries.forEach(function (entry) { return entry[1].visitExpression(_this, context); });
	          return ast;
	      };
	      RecursiveExpressionVisitor.prototype.visitAllExpressions = function (exprs, context) {
	          var _this = this;
	          exprs.forEach(function (expr) { return expr.visitExpression(_this, context); });
	      };
	      RecursiveExpressionVisitor.prototype.visitDeclareVarStmt = function (stmt, context) {
	          stmt.value.visitExpression(this, context);
	          return stmt;
	      };
	      RecursiveExpressionVisitor.prototype.visitDeclareFunctionStmt = function (stmt, context) {
	          // Don't descend into nested functions
	          return stmt;
	      };
	      RecursiveExpressionVisitor.prototype.visitExpressionStmt = function (stmt, context) {
	          stmt.expr.visitExpression(this, context);
	          return stmt;
	      };
	      RecursiveExpressionVisitor.prototype.visitReturnStmt = function (stmt, context) {
	          stmt.value.visitExpression(this, context);
	          return stmt;
	      };
	      RecursiveExpressionVisitor.prototype.visitDeclareClassStmt = function (stmt, context) {
	          // Don't descend into nested functions
	          return stmt;
	      };
	      RecursiveExpressionVisitor.prototype.visitIfStmt = function (stmt, context) {
	          stmt.condition.visitExpression(this, context);
	          this.visitAllStatements(stmt.trueCase, context);
	          this.visitAllStatements(stmt.falseCase, context);
	          return stmt;
	      };
	      RecursiveExpressionVisitor.prototype.visitTryCatchStmt = function (stmt, context) {
	          this.visitAllStatements(stmt.bodyStmts, context);
	          this.visitAllStatements(stmt.catchStmts, context);
	          return stmt;
	      };
	      RecursiveExpressionVisitor.prototype.visitThrowStmt = function (stmt, context) {
	          stmt.error.visitExpression(this, context);
	          return stmt;
	      };
	      RecursiveExpressionVisitor.prototype.visitCommentStmt = function (stmt, context) { return stmt; };
	      RecursiveExpressionVisitor.prototype.visitAllStatements = function (stmts, context) {
	          var _this = this;
	          stmts.forEach(function (stmt) { return stmt.visitStatement(_this, context); });
	      };
	      return RecursiveExpressionVisitor;
	  }());
	  function replaceVarInExpression(varName, newValue, expression) {
	      var transformer = new _ReplaceVariableTransformer(varName, newValue);
	      return expression.visitExpression(transformer, null);
	  }
	  var _ReplaceVariableTransformer = (function (_super) {
	      __extends$12(_ReplaceVariableTransformer, _super);
	      function _ReplaceVariableTransformer(_varName, _newValue) {
	          _super.call(this);
	          this._varName = _varName;
	          this._newValue = _newValue;
	      }
	      _ReplaceVariableTransformer.prototype.visitReadVarExpr = function (ast, context) {
	          return ast.name == this._varName ? this._newValue : ast;
	      };
	      return _ReplaceVariableTransformer;
	  }(ExpressionTransformer));
	  function findReadVarNames(stmts) {
	      var finder = new _VariableFinder();
	      finder.visitAllStatements(stmts, null);
	      return finder.varNames;
	  }
	  var _VariableFinder = (function (_super) {
	      __extends$12(_VariableFinder, _super);
	      function _VariableFinder() {
	          _super.apply(this, arguments);
	          this.varNames = new Set();
	      }
	      _VariableFinder.prototype.visitReadVarExpr = function (ast, context) {
	          this.varNames.add(ast.name);
	          return null;
	      };
	      return _VariableFinder;
	  }(RecursiveExpressionVisitor));
	  function variable(name, type) {
	      if (type === void 0) { type = null; }
	      return new ReadVarExpr(name, type);
	  }
	  function importExpr(id, typeParams) {
	      if (typeParams === void 0) { typeParams = null; }
	      return new ExternalExpr(id, null, typeParams);
	  }
	  function importType(id, typeParams, typeModifiers) {
	      if (typeParams === void 0) { typeParams = null; }
	      if (typeModifiers === void 0) { typeModifiers = null; }
	      return isPresent(id) ? new ExternalType(id, typeParams, typeModifiers) : null;
	  }
	  function literalArr(values, type) {
	      if (type === void 0) { type = null; }
	      return new LiteralArrayExpr(values, type);
	  }
	  function literalMap(values, type) {
	      if (type === void 0) { type = null; }
	      return new LiteralMapExpr(values, type);
	  }
	  function not(expr) {
	      return new NotExpr(expr);
	  }
	  function fn(params, body, type) {
	      if (type === void 0) { type = null; }
	      return new FunctionExpr(params, body, type);
	  }
	  function literal(value, type) {
	      if (type === void 0) { type = null; }
	      return new LiteralExpr(value, type);
	  }

	  /**
	   * @license
	   * Copyright Google Inc. All Rights Reserved.
	   *
	   * Use of this source code is governed by an MIT-style license that can be
	   * found in the LICENSE file at https://angular.io/license
	   */
	  var __extends$13 = (this && this.__extends) || function (d, b) {
	      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	      function __() { this.constructor = d; }
	      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	  };
	  var AnimationAst = (function () {
	      function AnimationAst() {
	          this.startTime = 0;
	          this.playTime = 0;
	      }
	      return AnimationAst;
	  }());
	  var AnimationStateAst = (function (_super) {
	      __extends$13(AnimationStateAst, _super);
	      function AnimationStateAst() {
	          _super.apply(this, arguments);
	      }
	      return AnimationStateAst;
	  }(AnimationAst));
	  var AnimationEntryAst = (function (_super) {
	      __extends$13(AnimationEntryAst, _super);
	      function AnimationEntryAst(name, stateDeclarations, stateTransitions) {
	          _super.call(this);
	          this.name = name;
	          this.stateDeclarations = stateDeclarations;
	          this.stateTransitions = stateTransitions;
	      }
	      AnimationEntryAst.prototype.visit = function (visitor, context) {
	          return visitor.visitAnimationEntry(this, context);
	      };
	      return AnimationEntryAst;
	  }(AnimationAst));
	  var AnimationStateDeclarationAst = (function (_super) {
	      __extends$13(AnimationStateDeclarationAst, _super);
	      function AnimationStateDeclarationAst(stateName, styles) {
	          _super.call(this);
	          this.stateName = stateName;
	          this.styles = styles;
	      }
	      AnimationStateDeclarationAst.prototype.visit = function (visitor, context) {
	          return visitor.visitAnimationStateDeclaration(this, context);
	      };
	      return AnimationStateDeclarationAst;
	  }(AnimationStateAst));
	  var AnimationStateTransitionExpression = (function () {
	      function AnimationStateTransitionExpression(fromState, toState) {
	          this.fromState = fromState;
	          this.toState = toState;
	      }
	      return AnimationStateTransitionExpression;
	  }());
	  var AnimationStateTransitionAst = (function (_super) {
	      __extends$13(AnimationStateTransitionAst, _super);
	      function AnimationStateTransitionAst(stateChanges, animation) {
	          _super.call(this);
	          this.stateChanges = stateChanges;
	          this.animation = animation;
	      }
	      AnimationStateTransitionAst.prototype.visit = function (visitor, context) {
	          return visitor.visitAnimationStateTransition(this, context);
	      };
	      return AnimationStateTransitionAst;
	  }(AnimationStateAst));
	  var AnimationStepAst = (function (_super) {
	      __extends$13(AnimationStepAst, _super);
	      function AnimationStepAst(startingStyles, keyframes, duration, delay, easing) {
	          _super.call(this);
	          this.startingStyles = startingStyles;
	          this.keyframes = keyframes;
	          this.duration = duration;
	          this.delay = delay;
	          this.easing = easing;
	      }
	      AnimationStepAst.prototype.visit = function (visitor, context) {
	          return visitor.visitAnimationStep(this, context);
	      };
	      return AnimationStepAst;
	  }(AnimationAst));
	  var AnimationStylesAst = (function (_super) {
	      __extends$13(AnimationStylesAst, _super);
	      function AnimationStylesAst(styles) {
	          _super.call(this);
	          this.styles = styles;
	      }
	      AnimationStylesAst.prototype.visit = function (visitor, context) {
	          return visitor.visitAnimationStyles(this, context);
	      };
	      return AnimationStylesAst;
	  }(AnimationAst));
	  var AnimationKeyframeAst = (function (_super) {
	      __extends$13(AnimationKeyframeAst, _super);
	      function AnimationKeyframeAst(offset, styles) {
	          _super.call(this);
	          this.offset = offset;
	          this.styles = styles;
	      }
	      AnimationKeyframeAst.prototype.visit = function (visitor, context) {
	          return visitor.visitAnimationKeyframe(this, context);
	      };
	      return AnimationKeyframeAst;
	  }(AnimationAst));
	  var AnimationWithStepsAst = (function (_super) {
	      __extends$13(AnimationWithStepsAst, _super);
	      function AnimationWithStepsAst(steps) {
	          _super.call(this);
	          this.steps = steps;
	      }
	      return AnimationWithStepsAst;
	  }(AnimationAst));
	  var AnimationGroupAst = (function (_super) {
	      __extends$13(AnimationGroupAst, _super);
	      function AnimationGroupAst(steps) {
	          _super.call(this, steps);
	      }
	      AnimationGroupAst.prototype.visit = function (visitor, context) {
	          return visitor.visitAnimationGroup(this, context);
	      };
	      return AnimationGroupAst;
	  }(AnimationWithStepsAst));
	  var AnimationSequenceAst = (function (_super) {
	      __extends$13(AnimationSequenceAst, _super);
	      function AnimationSequenceAst(steps) {
	          _super.call(this, steps);
	      }
	      AnimationSequenceAst.prototype.visit = function (visitor, context) {
	          return visitor.visitAnimationSequence(this, context);
	      };
	      return AnimationSequenceAst;
	  }(AnimationWithStepsAst));

	  var AnimationEntryCompileResult = (function () {
	      function AnimationEntryCompileResult(name, statements, fnExp) {
	          this.name = name;
	          this.statements = statements;
	          this.fnExp = fnExp;
	      }
	      return AnimationEntryCompileResult;
	  }());
	  var AnimationCompiler = (function () {
	      function AnimationCompiler() {
	      }
	      AnimationCompiler.prototype.compile = function (factoryNamePrefix, parsedAnimations) {
	          return parsedAnimations.map(function (entry) {
	              var factoryName = factoryNamePrefix + "_" + entry.name;
	              var visitor = new _AnimationBuilder(entry.name, factoryName);
	              return visitor.build(entry);
	          });
	      };
	      return AnimationCompiler;
	  }());
	  var _ANIMATION_FACTORY_ELEMENT_VAR = variable('element');
	  var _ANIMATION_DEFAULT_STATE_VAR = variable('defaultStateStyles');
	  var _ANIMATION_FACTORY_VIEW_VAR = variable('view');
	  var _ANIMATION_FACTORY_VIEW_CONTEXT = _ANIMATION_FACTORY_VIEW_VAR.prop('animationContext');
	  var _ANIMATION_FACTORY_RENDERER_VAR = _ANIMATION_FACTORY_VIEW_VAR.prop('renderer');
	  var _ANIMATION_CURRENT_STATE_VAR = variable('currentState');
	  var _ANIMATION_NEXT_STATE_VAR = variable('nextState');
	  var _ANIMATION_PLAYER_VAR = variable('player');
	  var _ANIMATION_TIME_VAR = variable('totalTime');
	  var _ANIMATION_START_STATE_STYLES_VAR = variable('startStateStyles');
	  var _ANIMATION_END_STATE_STYLES_VAR = variable('endStateStyles');
	  var _ANIMATION_COLLECTED_STYLES = variable('collectedStyles');
	  var EMPTY_MAP = literalMap([]);
	  var _AnimationBuilder = (function () {
	      function _AnimationBuilder(animationName, factoryName) {
	          this.animationName = animationName;
	          this._fnVarName = factoryName + '_factory';
	          this._statesMapVarName = factoryName + '_states';
	          this._statesMapVar = variable(this._statesMapVarName);
	      }
	      _AnimationBuilder.prototype.visitAnimationStyles = function (ast, context) {
	          var stylesArr = [];
	          if (context.isExpectingFirstStyleStep) {
	              stylesArr.push(_ANIMATION_START_STATE_STYLES_VAR);
	              context.isExpectingFirstStyleStep = false;
	          }
	          ast.styles.forEach(function (entry) {
	              var entries = Object.keys(entry).map(function (key) { return [key, literal(entry[key])]; });
	              stylesArr.push(literalMap(entries));
	          });
	          return importExpr(resolveIdentifier(Identifiers.AnimationStyles)).instantiate([
	              importExpr(resolveIdentifier(Identifiers.collectAndResolveStyles)).callFn([
	                  _ANIMATION_COLLECTED_STYLES, literalArr(stylesArr)
	              ])
	          ]);
	      };
	      _AnimationBuilder.prototype.visitAnimationKeyframe = function (ast, context) {
	          return importExpr(resolveIdentifier(Identifiers.AnimationKeyframe)).instantiate([
	              literal(ast.offset), ast.styles.visit(this, context)
	          ]);
	      };
	      _AnimationBuilder.prototype.visitAnimationStep = function (ast, context) {
	          var _this = this;
	          if (context.endStateAnimateStep === ast) {
	              return this._visitEndStateAnimation(ast, context);
	          }
	          var startingStylesExpr = ast.startingStyles.visit(this, context);
	          var keyframeExpressions = ast.keyframes.map(function (keyframeEntry) { return keyframeEntry.visit(_this, context); });
	          return this._callAnimateMethod(ast, startingStylesExpr, literalArr(keyframeExpressions), context);
	      };
	      /** @internal */
	      _AnimationBuilder.prototype._visitEndStateAnimation = function (ast, context) {
	          var _this = this;
	          var startingStylesExpr = ast.startingStyles.visit(this, context);
	          var keyframeExpressions = ast.keyframes.map(function (keyframe) { return keyframe.visit(_this, context); });
	          var keyframesExpr = importExpr(resolveIdentifier(Identifiers.balanceAnimationKeyframes)).callFn([
	              _ANIMATION_COLLECTED_STYLES, _ANIMATION_END_STATE_STYLES_VAR,
	              literalArr(keyframeExpressions)
	          ]);
	          return this._callAnimateMethod(ast, startingStylesExpr, keyframesExpr, context);
	      };
	      /** @internal */
	      _AnimationBuilder.prototype._callAnimateMethod = function (ast, startingStylesExpr, keyframesExpr, context) {
	          context.totalTransitionTime += ast.duration + ast.delay;
	          return _ANIMATION_FACTORY_RENDERER_VAR.callMethod('animate', [
	              _ANIMATION_FACTORY_ELEMENT_VAR, startingStylesExpr, keyframesExpr, literal(ast.duration),
	              literal(ast.delay), literal(ast.easing)
	          ]);
	      };
	      _AnimationBuilder.prototype.visitAnimationSequence = function (ast, context) {
	          var _this = this;
	          var playerExprs = ast.steps.map(function (step) { return step.visit(_this, context); });
	          return importExpr(resolveIdentifier(Identifiers.AnimationSequencePlayer)).instantiate([
	              literalArr(playerExprs)
	          ]);
	      };
	      _AnimationBuilder.prototype.visitAnimationGroup = function (ast, context) {
	          var _this = this;
	          var playerExprs = ast.steps.map(function (step) { return step.visit(_this, context); });
	          return importExpr(resolveIdentifier(Identifiers.AnimationGroupPlayer)).instantiate([
	              literalArr(playerExprs)
	          ]);
	      };
	      _AnimationBuilder.prototype.visitAnimationStateDeclaration = function (ast, context) {
	          var flatStyles = {};
	          _getStylesArray(ast).forEach(function (entry) { Object.keys(entry).forEach(function (key) { flatStyles[key] = entry[key]; }); });
	          context.stateMap.registerState(ast.stateName, flatStyles);
	      };
	      _AnimationBuilder.prototype.visitAnimationStateTransition = function (ast, context) {
	          var steps = ast.animation.steps;
	          var lastStep = steps[steps.length - 1];
	          if (_isEndStateAnimateStep(lastStep)) {
	              context.endStateAnimateStep = lastStep;
	          }
	          context.totalTransitionTime = 0;
	          context.isExpectingFirstStyleStep = true;
	          var stateChangePreconditions = [];
	          ast.stateChanges.forEach(function (stateChange) {
	              stateChangePreconditions.push(_compareToAnimationStateExpr(_ANIMATION_CURRENT_STATE_VAR, stateChange.fromState)
	                  .and(_compareToAnimationStateExpr(_ANIMATION_NEXT_STATE_VAR, stateChange.toState)));
	              if (stateChange.fromState != ANY_STATE) {
	                  context.stateMap.registerState(stateChange.fromState);
	              }
	              if (stateChange.toState != ANY_STATE) {
	                  context.stateMap.registerState(stateChange.toState);
	              }
	          });
	          var animationPlayerExpr = ast.animation.visit(this, context);
	          var reducedStateChangesPrecondition = stateChangePreconditions.reduce(function (a, b) { return a.or(b); });
	          var precondition = _ANIMATION_PLAYER_VAR.equals(NULL_EXPR).and(reducedStateChangesPrecondition);
	          var animationStmt = _ANIMATION_PLAYER_VAR.set(animationPlayerExpr).toStmt();
	          var totalTimeStmt = _ANIMATION_TIME_VAR.set(literal(context.totalTransitionTime)).toStmt();
	          return new IfStmt(precondition, [animationStmt, totalTimeStmt]);
	      };
	      _AnimationBuilder.prototype.visitAnimationEntry = function (ast, context) {
	          var _this = this;
	          // visit each of the declarations first to build the context state map
	          ast.stateDeclarations.forEach(function (def) { return def.visit(_this, context); });
	          // this should always be defined even if the user overrides it
	          context.stateMap.registerState(DEFAULT_STATE, {});
	          var statements = [];
	          statements.push(_ANIMATION_FACTORY_VIEW_CONTEXT
	              .callMethod('cancelActiveAnimation', [
	              _ANIMATION_FACTORY_ELEMENT_VAR, literal(this.animationName),
	              _ANIMATION_NEXT_STATE_VAR.equals(literal(EMPTY_ANIMATION_STATE))
	          ])
	              .toStmt());
	          statements.push(_ANIMATION_COLLECTED_STYLES.set(EMPTY_MAP).toDeclStmt());
	          statements.push(_ANIMATION_PLAYER_VAR.set(NULL_EXPR).toDeclStmt());
	          statements.push(_ANIMATION_TIME_VAR.set(literal(0)).toDeclStmt());
	          statements.push(_ANIMATION_DEFAULT_STATE_VAR.set(this._statesMapVar.key(literal(DEFAULT_STATE)))
	              .toDeclStmt());
	          statements.push(_ANIMATION_START_STATE_STYLES_VAR.set(this._statesMapVar.key(_ANIMATION_CURRENT_STATE_VAR))
	              .toDeclStmt());
	          statements.push(new IfStmt(_ANIMATION_START_STATE_STYLES_VAR.equals(NULL_EXPR), [_ANIMATION_START_STATE_STYLES_VAR.set(_ANIMATION_DEFAULT_STATE_VAR).toStmt()]));
	          statements.push(_ANIMATION_END_STATE_STYLES_VAR.set(this._statesMapVar.key(_ANIMATION_NEXT_STATE_VAR))
	              .toDeclStmt());
	          statements.push(new IfStmt(_ANIMATION_END_STATE_STYLES_VAR.equals(NULL_EXPR), [_ANIMATION_END_STATE_STYLES_VAR.set(_ANIMATION_DEFAULT_STATE_VAR).toStmt()]));
	          var RENDER_STYLES_FN = importExpr(resolveIdentifier(Identifiers.renderStyles));
	          // before we start any animation we want to clear out the starting
	          // styles from the element's style property (since they were placed
	          // there at the end of the last animation
	          statements.push(RENDER_STYLES_FN
	              .callFn([
	              _ANIMATION_FACTORY_ELEMENT_VAR, _ANIMATION_FACTORY_RENDERER_VAR,
	              importExpr(resolveIdentifier(Identifiers.clearStyles))
	                  .callFn([_ANIMATION_START_STATE_STYLES_VAR])
	          ])
	              .toStmt());
	          ast.stateTransitions.forEach(function (transAst) { return statements.push(transAst.visit(_this, context)); });
	          // this check ensures that the animation factory always returns a player
	          // so that the onDone callback can be used for tracking
	          statements.push(new IfStmt(_ANIMATION_PLAYER_VAR.equals(NULL_EXPR), [_ANIMATION_PLAYER_VAR
	                  .set(importExpr(resolveIdentifier(Identifiers.NoOpAnimationPlayer)).instantiate([]))
	                  .toStmt()]));
	          // once complete we want to apply the styles on the element
	          // since the destination state's values should persist once
	          // the animation sequence has completed.
	          statements.push(_ANIMATION_PLAYER_VAR
	              .callMethod('onDone', [fn([], [RENDER_STYLES_FN
	                      .callFn([
	                      _ANIMATION_FACTORY_ELEMENT_VAR, _ANIMATION_FACTORY_RENDERER_VAR,
	                      importExpr(resolveIdentifier(Identifiers.prepareFinalAnimationStyles))
	                          .callFn([
	                          _ANIMATION_START_STATE_STYLES_VAR, _ANIMATION_END_STATE_STYLES_VAR
	                      ])
	                  ])
	                      .toStmt()])])
	              .toStmt());
	          statements.push(_ANIMATION_FACTORY_VIEW_CONTEXT
	              .callMethod('queueAnimation', [
	              _ANIMATION_FACTORY_ELEMENT_VAR, literal(this.animationName),
	              _ANIMATION_PLAYER_VAR
	          ])
	              .toStmt());
	          statements.push(new ReturnStatement(importExpr(resolveIdentifier(Identifiers.AnimationTransition)).instantiate([
	              _ANIMATION_PLAYER_VAR, _ANIMATION_CURRENT_STATE_VAR, _ANIMATION_NEXT_STATE_VAR,
	              _ANIMATION_TIME_VAR
	          ])));
	          return fn([
	              new FnParam(_ANIMATION_FACTORY_VIEW_VAR.name, importType(resolveIdentifier(Identifiers.AppView), [DYNAMIC_TYPE])),
	              new FnParam(_ANIMATION_FACTORY_ELEMENT_VAR.name, DYNAMIC_TYPE),
	              new FnParam(_ANIMATION_CURRENT_STATE_VAR.name, DYNAMIC_TYPE),
	              new FnParam(_ANIMATION_NEXT_STATE_VAR.name, DYNAMIC_TYPE)
	          ], statements, importType(resolveIdentifier(Identifiers.AnimationTransition)));
	      };
	      _AnimationBuilder.prototype.build = function (ast) {
	          var context = new _AnimationBuilderContext();
	          var fnStatement = ast.visit(this, context).toDeclStmt(this._fnVarName);
	          var fnVariable = variable(this._fnVarName);
	          var lookupMap = [];
	          Object.keys(context.stateMap.states).forEach(function (stateName) {
	              var value = context.stateMap.states[stateName];
	              var variableValue = EMPTY_MAP;
	              if (isPresent(value)) {
	                  var styleMap_1 = [];
	                  Object.keys(value).forEach(function (key) { styleMap_1.push([key, literal(value[key])]); });
	                  variableValue = literalMap(styleMap_1);
	              }
	              lookupMap.push([stateName, variableValue]);
	          });
	          var compiledStatesMapStmt = this._statesMapVar.set(literalMap(lookupMap)).toDeclStmt();
	          var statements = [compiledStatesMapStmt, fnStatement];
	          return new AnimationEntryCompileResult(this.animationName, statements, fnVariable);
	      };
	      return _AnimationBuilder;
	  }());
	  var _AnimationBuilderContext = (function () {
	      function _AnimationBuilderContext() {
	          this.stateMap = new _AnimationBuilderStateMap();
	          this.endStateAnimateStep = null;
	          this.isExpectingFirstStyleStep = false;
	          this.totalTransitionTime = 0;
	      }
	      return _AnimationBuilderContext;
	  }());
	  var _AnimationBuilderStateMap = (function () {
	      function _AnimationBuilderStateMap() {
	          this._states = {};
	      }
	      Object.defineProperty(_AnimationBuilderStateMap.prototype, "states", {
	          get: function () { return this._states; },
	          enumerable: true,
	          configurable: true
	      });
	      _AnimationBuilderStateMap.prototype.registerState = function (name, value) {
	          if (value === void 0) { value = null; }
	          var existingEntry = this._states[name];
	          if (!existingEntry) {
	              this._states[name] = value;
	          }
	      };
	      return _AnimationBuilderStateMap;
	  }());
	  function _compareToAnimationStateExpr(value, animationState) {
	      var emptyStateLiteral = literal(EMPTY_ANIMATION_STATE);
	      switch (animationState) {
	          case EMPTY_ANIMATION_STATE:
	              return value.equals(emptyStateLiteral);
	          case ANY_STATE:
	              return literal(true);
	          default:
	              return value.equals(literal(animationState));
	      }
	  }
	  function _isEndStateAnimateStep(step) {
	      // the final animation step is characterized by having only TWO
	      // keyframe values and it must have zero styles for both keyframes
	      if (step instanceof AnimationStepAst && step.duration > 0 && step.keyframes.length == 2) {
	          var styles1 = _getStylesArray(step.keyframes[0])[0];
	          var styles2 = _getStylesArray(step.keyframes[1])[0];
	          return Object.keys(styles1).length === 0 && Object.keys(styles2).length === 0;
	      }
	      return false;
	  }
	  function _getStylesArray(obj) {
	      return obj.styles.styles;
	  }

	  var StylesCollectionEntry = (function () {
	      function StylesCollectionEntry(time, value) {
	          this.time = time;
	          this.value = value;
	      }
	      StylesCollectionEntry.prototype.matches = function (time, value) {
	          return time == this.time && value == this.value;
	      };
	      return StylesCollectionEntry;
	  }());
	  var StylesCollection = (function () {
	      function StylesCollection() {
	          this.styles = {};
	      }
	      StylesCollection.prototype.insertAtTime = function (property, time, value) {
	          var tuple = new StylesCollectionEntry(time, value);
	          var entries = this.styles[property];
	          if (!isPresent(entries)) {
	              entries = this.styles[property] = [];
	          }
	          // insert this at the right stop in the array
	          // this way we can keep it sorted
	          var insertionIndex = 0;
	          for (var i = entries.length - 1; i >= 0; i--) {
	              if (entries[i].time <= time) {
	                  insertionIndex = i + 1;
	                  break;
	              }
	          }
	          entries.splice(insertionIndex, 0, tuple);
	      };
	      StylesCollection.prototype.getByIndex = function (property, index) {
	          var items = this.styles[property];
	          if (isPresent(items)) {
	              return index >= items.length ? null : items[index];
	          }
	          return null;
	      };
	      StylesCollection.prototype.indexOfAtOrBeforeTime = function (property, time) {
	          var entries = this.styles[property];
	          if (isPresent(entries)) {
	              for (var i = entries.length - 1; i >= 0; i--) {
	                  if (entries[i].time <= time)
	                      return i;
	              }
	          }
	          return null;
	      };
	      return StylesCollection;
	  }());

	  /**
	   * @license
	   * Copyright Google Inc. All Rights Reserved.
	   *
	   * Use of this source code is governed by an MIT-style license that can be
	   * found in the LICENSE file at https://angular.io/license
	   */
	  var __extends$14 = (this && this.__extends) || function (d, b) {
	      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	      function __() { this.constructor = d; }
	      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	  };
	  var _INITIAL_KEYFRAME = 0;
	  var _TERMINAL_KEYFRAME = 1;
	  var _ONE_SECOND = 1000;
	  var AnimationParseError = (function (_super) {
	      __extends$14(AnimationParseError, _super);
	      function AnimationParseError(message) {
	          _super.call(this, null, message);
	      }
	      AnimationParseError.prototype.toString = function () { return "" + this.msg; };
	      return AnimationParseError;
	  }(ParseError));
	  var AnimationEntryParseResult = (function () {
	      function AnimationEntryParseResult(ast, errors) {
	          this.ast = ast;
	          this.errors = errors;
	      }
	      return AnimationEntryParseResult;
	  }());
	  var AnimationParser = (function () {
	      function AnimationParser() {
	      }
	      AnimationParser.prototype.parseComponent = function (component) {
	          var _this = this;
	          var errors = [];
	          var componentName = component.type.name;
	          var animationTriggerNames = new Set();
	          var asts = component.template.animations.map(function (entry) {
	              var result = _this.parseEntry(entry);
	              var ast = result.ast;
	              var triggerName = ast.name;
	              if (animationTriggerNames.has(triggerName)) {
	                  result.errors.push(new AnimationParseError("The animation trigger \"" + triggerName + "\" has already been registered for the " + componentName + " component"));
	              }
	              else {
	                  animationTriggerNames.add(triggerName);
	              }
	              if (result.errors.length > 0) {
	                  var errorMessage_1 = "- Unable to parse the animation sequence for \"" + triggerName + "\" on the " + componentName + " component due to the following errors:";
	                  result.errors.forEach(function (error) { errorMessage_1 += '\n-- ' + error.msg; });
	                  errors.push(errorMessage_1);
	              }
	              return ast;
	          });
	          if (errors.length > 0) {
	              var errorString = errors.join('\n');
	              throw new Error("Animation parse errors:\n" + errorString);
	          }
	          return asts;
	      };
	      AnimationParser.prototype.parseEntry = function (entry) {
	          var errors = [];
	          var stateStyles = {};
	          var transitions = [];
	          var stateDeclarationAsts = [];
	          entry.definitions.forEach(function (def) {
	              if (def instanceof CompileAnimationStateDeclarationMetadata) {
	                  _parseAnimationDeclarationStates(def, errors).forEach(function (ast) {
	                      stateDeclarationAsts.push(ast);
	                      stateStyles[ast.stateName] = ast.styles;
	                  });
	              }
	              else {
	                  transitions.push(def);
	              }
	          });
	          var stateTransitionAsts = transitions.map(function (transDef) { return _parseAnimationStateTransition(transDef, stateStyles, errors); });
	          var ast = new AnimationEntryAst(entry.name, stateDeclarationAsts, stateTransitionAsts);
	          return new AnimationEntryParseResult(ast, errors);
	      };
	      return AnimationParser;
	  }());
	  function _parseAnimationDeclarationStates(stateMetadata, errors) {
	      var styleValues = [];
	      stateMetadata.styles.styles.forEach(function (stylesEntry) {
	          // TODO (matsko): change this when we get CSS class integration support
	          if (typeof stylesEntry === 'object' && stylesEntry !== null) {
	              styleValues.push(stylesEntry);
	          }
	          else {
	              errors.push(new AnimationParseError("State based animations cannot contain references to other states"));
	          }
	      });
	      var defStyles = new AnimationStylesAst(styleValues);
	      var states = stateMetadata.stateNameExpr.split(/\s*,\s*/);
	      return states.map(function (state) { return new AnimationStateDeclarationAst(state, defStyles); });
	  }
	  function _parseAnimationStateTransition(transitionStateMetadata, stateStyles, errors) {
	      var styles = new StylesCollection();
	      var transitionExprs = [];
	      var transitionStates = transitionStateMetadata.stateChangeExpr.split(/\s*,\s*/);
	      transitionStates.forEach(function (expr) { transitionExprs.push.apply(transitionExprs, _parseAnimationTransitionExpr(expr, errors)); });
	      var entry = _normalizeAnimationEntry(transitionStateMetadata.steps);
	      var animation = _normalizeStyleSteps(entry, stateStyles, errors);
	      var animationAst = _parseTransitionAnimation(animation, 0, styles, stateStyles, errors);
	      if (errors.length == 0) {
	          _fillAnimationAstStartingKeyframes(animationAst, styles, errors);
	      }
	      var stepsAst = (animationAst instanceof AnimationWithStepsAst) ?
	          animationAst :
	          new AnimationSequenceAst([animationAst]);
	      return new AnimationStateTransitionAst(transitionExprs, stepsAst);
	  }
	  function _parseAnimationAlias(alias, errors) {
	      switch (alias) {
	          case ':enter':
	              return 'void => *';
	          case ':leave':
	              return '* => void';
	          default:
	              errors.push(new AnimationParseError("the transition alias value \"" + alias + "\" is not supported"));
	              return '* => *';
	      }
	  }
	  function _parseAnimationTransitionExpr(eventStr, errors) {
	      var expressions = [];
	      if (eventStr[0] == ':') {
	          eventStr = _parseAnimationAlias(eventStr, errors);
	      }
	      var match = eventStr.match(/^(\*|[-\w]+)\s*(<?[=-]>)\s*(\*|[-\w]+)$/);
	      if (!isPresent(match) || match.length < 4) {
	          errors.push(new AnimationParseError("the provided " + eventStr + " is not of a supported format"));
	          return expressions;
	      }
	      var fromState = match[1];
	      var separator = match[2];
	      var toState = match[3];
	      expressions.push(new AnimationStateTransitionExpression(fromState, toState));
	      var isFullAnyStateExpr = fromState == ANY_STATE && toState == ANY_STATE;
	      if (separator[0] == '<' && !isFullAnyStateExpr) {
	          expressions.push(new AnimationStateTransitionExpression(toState, fromState));
	      }
	      return expressions;
	  }
	  function _normalizeAnimationEntry(entry) {
	      return Array.isArray(entry) ? new CompileAnimationSequenceMetadata(entry) : entry;
	  }
	  function _normalizeStyleMetadata(entry, stateStyles, errors) {
	      var normalizedStyles = [];
	      entry.styles.forEach(function (styleEntry) {
	          if (typeof styleEntry === 'string') {
	              normalizedStyles.push.apply(normalizedStyles, _resolveStylesFromState(styleEntry, stateStyles, errors));
	          }
	          else {
	              normalizedStyles.push(styleEntry);
	          }
	      });
	      return normalizedStyles;
	  }
	  function _normalizeStyleSteps(entry, stateStyles, errors) {
	      var steps = _normalizeStyleStepEntry(entry, stateStyles, errors);
	      return (entry instanceof CompileAnimationGroupMetadata) ?
	          new CompileAnimationGroupMetadata(steps) :
	          new CompileAnimationSequenceMetadata(steps);
	  }
	  function _mergeAnimationStyles(stylesList, newItem) {
	      if (typeof newItem === 'object' && newItem !== null && stylesList.length > 0) {
	          var lastIndex = stylesList.length - 1;
	          var lastItem = stylesList[lastIndex];
	          if (typeof lastItem === 'object' && lastItem !== null) {
	              stylesList[lastIndex] = StringMapWrapper.merge(lastItem, newItem);
	              return;
	          }
	      }
	      stylesList.push(newItem);
	  }
	  function _normalizeStyleStepEntry(entry, stateStyles, errors) {
	      var steps;
	      if (entry instanceof CompileAnimationWithStepsMetadata) {
	          steps = entry.steps;
	      }
	      else {
	          return [entry];
	      }
	      var newSteps = [];
	      var combinedStyles;
	      steps.forEach(function (step) {
	          if (step instanceof CompileAnimationStyleMetadata) {
	              // this occurs when a style step is followed by a previous style step
	              // or when the first style step is run. We want to concatenate all subsequent
	              // style steps together into a single style step such that we have the correct
	              // starting keyframe data to pass into the animation player.
	              if (!isPresent(combinedStyles)) {
	                  combinedStyles = [];
	              }
	              _normalizeStyleMetadata(step, stateStyles, errors)
	                  .forEach(function (entry) { _mergeAnimationStyles(combinedStyles, entry); });
	          }
	          else {
	              // it is important that we create a metadata entry of the combined styles
	              // before we go on an process the animate, sequence or group metadata steps.
	              // This will ensure that the AST will have the previous styles painted on
	              // screen before any further animations that use the styles take place.
	              if (isPresent(combinedStyles)) {
	                  newSteps.push(new CompileAnimationStyleMetadata(0, combinedStyles));
	                  combinedStyles = null;
	              }
	              if (step instanceof CompileAnimationAnimateMetadata) {
	                  // we do not recurse into CompileAnimationAnimateMetadata since
	                  // those style steps are not going to be squashed
	                  var animateStyleValue = step.styles;
	                  if (animateStyleValue instanceof CompileAnimationStyleMetadata) {
	                      animateStyleValue.styles =
	                          _normalizeStyleMetadata(animateStyleValue, stateStyles, errors);
	                  }
	                  else if (animateStyleValue instanceof CompileAnimationKeyframesSequenceMetadata) {
	                      animateStyleValue.steps.forEach(function (step) { step.styles = _normalizeStyleMetadata(step, stateStyles, errors); });
	                  }
	              }
	              else if (step instanceof CompileAnimationWithStepsMetadata) {
	                  var innerSteps = _normalizeStyleStepEntry(step, stateStyles, errors);
	                  step = step instanceof CompileAnimationGroupMetadata ?
	                      new CompileAnimationGroupMetadata(innerSteps) :
	                      new CompileAnimationSequenceMetadata(innerSteps);
	              }
	              newSteps.push(step);
	          }
	      });
	      // this happens when only styles were animated within the sequence
	      if (isPresent(combinedStyles)) {
	          newSteps.push(new CompileAnimationStyleMetadata(0, combinedStyles));
	      }
	      return newSteps;
	  }
	  function _resolveStylesFromState(stateName, stateStyles, errors) {
	      var styles = [];
	      if (stateName[0] != ':') {
	          errors.push(new AnimationParseError("Animation states via styles must be prefixed with a \":\""));
	      }
	      else {
	          var normalizedStateName = stateName.substring(1);
	          var value = stateStyles[normalizedStateName];
	          if (!isPresent(value)) {
	              errors.push(new AnimationParseError("Unable to apply styles due to missing a state: \"" + normalizedStateName + "\""));
	          }
	          else {
	              value.styles.forEach(function (stylesEntry) {
	                  if (typeof stylesEntry === 'object' && stylesEntry !== null) {
	                      styles.push(stylesEntry);
	                  }
	              });
	          }
	      }
	      return styles;
	  }
	  var _AnimationTimings = (function () {
	      function _AnimationTimings(duration, delay, easing) {
	          this.duration = duration;
	          this.delay = delay;
	          this.easing = easing;
	      }
	      return _AnimationTimings;
	  }());
	  function _parseAnimationKeyframes(keyframeSequence, currentTime, collectedStyles, stateStyles, errors) {
	      var totalEntries = keyframeSequence.steps.length;
	      var totalOffsets = 0;
	      keyframeSequence.steps.forEach(function (step) { return totalOffsets += (isPresent(step.offset) ? 1 : 0); });
	      if (totalOffsets > 0 && totalOffsets < totalEntries) {
	          errors.push(new AnimationParseError("Not all style() entries contain an offset for the provided keyframe()"));
	          totalOffsets = totalEntries;
	      }
	      var limit = totalEntries - 1;
	      var margin = totalOffsets == 0 ? (1 / limit) : 0;
	      var rawKeyframes = [];
	      var index = 0;
	      var doSortKeyframes = false;
	      var lastOffset = 0;
	      keyframeSequence.steps.forEach(function (styleMetadata) {
	          var offset = styleMetadata.offset;
	          var keyframeStyles = {};
	          styleMetadata.styles.forEach(function (entry) {
	              Object.keys(entry).forEach(function (prop) {
	                  if (prop != 'offset') {
	                      keyframeStyles[prop] = entry[prop];
	                  }
	              });
	          });
	          if (isPresent(offset)) {
	              doSortKeyframes = doSortKeyframes || (offset < lastOffset);
	          }
	          else {
	              offset = index == limit ? _TERMINAL_KEYFRAME : (margin * index);
	          }
	          rawKeyframes.push([offset, keyframeStyles]);
	          lastOffset = offset;
	          index++;
	      });
	      if (doSortKeyframes) {
	          rawKeyframes.sort(function (a, b) { return a[0] <= b[0] ? -1 : 1; });
	      }
	      var firstKeyframe = rawKeyframes[0];
	      if (firstKeyframe[0] != _INITIAL_KEYFRAME) {
	          rawKeyframes.splice(0, 0, firstKeyframe = [_INITIAL_KEYFRAME, {}]);
	      }
	      var firstKeyframeStyles = firstKeyframe[1];
	      limit = rawKeyframes.length - 1;
	      var lastKeyframe = rawKeyframes[limit];
	      if (lastKeyframe[0] != _TERMINAL_KEYFRAME) {
	          rawKeyframes.push(lastKeyframe = [_TERMINAL_KEYFRAME, {}]);
	          limit++;
	      }
	      var lastKeyframeStyles = lastKeyframe[1];
	      for (var i = 1; i <= limit; i++) {
	          var entry = rawKeyframes[i];
	          var styles = entry[1];
	          Object.keys(styles).forEach(function (prop) {
	              if (!isPresent(firstKeyframeStyles[prop])) {
	                  firstKeyframeStyles[prop] = FILL_STYLE_FLAG;
	              }
	          });
	      }
	      var _loop_1 = function(i) {
	          var entry = rawKeyframes[i];
	          var styles = entry[1];
	          Object.keys(styles).forEach(function (prop) {
	              if (!isPresent(lastKeyframeStyles[prop])) {
	                  lastKeyframeStyles[prop] = styles[prop];
	              }
	          });
	      };
	      for (var i = limit - 1; i >= 0; i--) {
	          _loop_1(i);
	      }
	      return rawKeyframes.map(function (entry) { return new AnimationKeyframeAst(entry[0], new AnimationStylesAst([entry[1]])); });
	  }
	  function _parseTransitionAnimation(entry, currentTime, collectedStyles, stateStyles, errors) {
	      var ast;
	      var playTime = 0;
	      var startingTime = currentTime;
	      if (entry instanceof CompileAnimationWithStepsMetadata) {
	          var maxDuration = 0;
	          var steps = [];
	          var isGroup = entry instanceof CompileAnimationGroupMetadata;
	          var previousStyles;
	          entry.steps.forEach(function (entry) {
	              // these will get picked up by the next step...
	              var time = isGroup ? startingTime : currentTime;
	              if (entry instanceof CompileAnimationStyleMetadata) {
	                  entry.styles.forEach(function (stylesEntry) {
	                      // by this point we know that we only have stringmap values
	                      var map = stylesEntry;
	                      Object.keys(map).forEach(function (prop) { collectedStyles.insertAtTime(prop, time, map[prop]); });
	                  });
	                  previousStyles = entry.styles;
	                  return;
	              }
	              var innerAst = _parseTransitionAnimation(entry, time, collectedStyles, stateStyles, errors);
	              if (isPresent(previousStyles)) {
	                  if (entry instanceof CompileAnimationWithStepsMetadata) {
	                      var startingStyles = new AnimationStylesAst(previousStyles);
	                      steps.push(new AnimationStepAst(startingStyles, [], 0, 0, ''));
	                  }
	                  else {
	                      var innerStep = innerAst;
	                      (_a = innerStep.startingStyles.styles).push.apply(_a, previousStyles);
	                  }
	                  previousStyles = null;
	              }
	              var astDuration = innerAst.playTime;
	              currentTime += astDuration;
	              playTime += astDuration;
	              maxDuration = Math.max(astDuration, maxDuration);
	              steps.push(innerAst);
	              var _a;
	          });
	          if (isPresent(previousStyles)) {
	              var startingStyles = new AnimationStylesAst(previousStyles);
	              steps.push(new AnimationStepAst(startingStyles, [], 0, 0, ''));
	          }
	          if (isGroup) {
	              ast = new AnimationGroupAst(steps);
	              playTime = maxDuration;
	              currentTime = startingTime + playTime;
	          }
	          else {
	              ast = new AnimationSequenceAst(steps);
	          }
	      }
	      else if (entry instanceof CompileAnimationAnimateMetadata) {
	          var timings = _parseTimeExpression(entry.timings, errors);
	          var styles = entry.styles;
	          var keyframes;
	          if (styles instanceof CompileAnimationKeyframesSequenceMetadata) {
	              keyframes =
	                  _parseAnimationKeyframes(styles, currentTime, collectedStyles, stateStyles, errors);
	          }
	          else {
	              var styleData = styles;
	              var offset = _TERMINAL_KEYFRAME;
	              var styleAst = new AnimationStylesAst(styleData.styles);
	              var keyframe = new AnimationKeyframeAst(offset, styleAst);
	              keyframes = [keyframe];
	          }
	          ast = new AnimationStepAst(new AnimationStylesAst([]), keyframes, timings.duration, timings.delay, timings.easing);
	          playTime = timings.duration + timings.delay;
	          currentTime += playTime;
	          keyframes.forEach(function (keyframe /** TODO #9100 */) { return keyframe.styles.styles.forEach(function (entry /** TODO #9100 */) { return Object.keys(entry).forEach(function (prop) { collectedStyles.insertAtTime(prop, currentTime, entry[prop]); }); }); });
	      }
	      else {
	          // if the code reaches this stage then an error
	          // has already been populated within the _normalizeStyleSteps()
	          // operation...
	          ast = new AnimationStepAst(null, [], 0, 0, '');
	      }
	      ast.playTime = playTime;
	      ast.startTime = startingTime;
	      return ast;
	  }
	  function _fillAnimationAstStartingKeyframes(ast, collectedStyles, errors) {
	      // steps that only contain style will not be filled
	      if ((ast instanceof AnimationStepAst) && ast.keyframes.length > 0) {
	          var keyframes = ast.keyframes;
	          if (keyframes.length == 1) {
	              var endKeyframe = keyframes[0];
	              var startKeyframe = _createStartKeyframeFromEndKeyframe(endKeyframe, ast.startTime, ast.playTime, collectedStyles, errors);
	              ast.keyframes = [startKeyframe, endKeyframe];
	          }
	      }
	      else if (ast instanceof AnimationWithStepsAst) {
	          ast.steps.forEach(function (entry) { return _fillAnimationAstStartingKeyframes(entry, collectedStyles, errors); });
	      }
	  }
	  function _parseTimeExpression(exp, errors) {
	      var regex = /^([\.\d]+)(m?s)(?:\s+([\.\d]+)(m?s))?(?:\s+([-a-z]+(?:\(.+?\))?))?/i;
	      var duration;
	      var delay = 0;
	      var easing = null;
	      if (typeof exp === 'string') {
	          var matches = exp.match(regex);
	          if (matches === null) {
	              errors.push(new AnimationParseError("The provided timing value \"" + exp + "\" is invalid."));
	              return new _AnimationTimings(0, 0, null);
	          }
	          var durationMatch = parseFloat(matches[1]);
	          var durationUnit = matches[2];
	          if (durationUnit == 's') {
	              durationMatch *= _ONE_SECOND;
	          }
	          duration = Math.floor(durationMatch);
	          var delayMatch = matches[3];
	          var delayUnit = matches[4];
	          if (isPresent(delayMatch)) {
	              var delayVal = parseFloat(delayMatch);
	              if (isPresent(delayUnit) && delayUnit == 's') {
	                  delayVal *= _ONE_SECOND;
	              }
	              delay = Math.floor(delayVal);
	          }
	          var easingVal = matches[5];
	          if (!isBlank(easingVal)) {
	              easing = easingVal;
	          }
	      }
	      else {
	          duration = exp;
	      }
	      return new _AnimationTimings(duration, delay, easing);
	  }
	  function _createStartKeyframeFromEndKeyframe(endKeyframe, startTime, duration, collectedStyles, errors) {
	      var values = {};
	      var endTime = startTime + duration;
	      endKeyframe.styles.styles.forEach(function (styleData) {
	          Object.keys(styleData).forEach(function (prop) {
	              var val = styleData[prop];
	              if (prop == 'offset')
	                  return;
	              var resultIndex = collectedStyles.indexOfAtOrBeforeTime(prop, startTime);
	              var resultEntry /** TODO #9100 */, nextEntry /** TODO #9100 */, value;
	              if (isPresent(resultIndex)) {
	                  resultEntry = collectedStyles.getByIndex(prop, resultIndex);
	                  value = resultEntry.value;
	                  nextEntry = collectedStyles.getByIndex(prop, resultIndex + 1);
	              }
	              else {
	                  // this is a flag that the runtime code uses to pass
	                  // in a value either from the state declaration styles
	                  // or using the AUTO_STYLE value (e.g. getComputedStyle)
	                  value = FILL_STYLE_FLAG;
	              }
	              if (isPresent(nextEntry) && !nextEntry.matches(endTime, val)) {
	                  errors.push(new AnimationParseError("The animated CSS property \"" + prop + "\" unexpectedly changes between steps \"" + resultEntry.time + "ms\" and \"" + endTime + "ms\" at \"" + nextEntry.time + "ms\""));
	              }
	              values[prop] = value;
	          });
	      });
	      return new AnimationKeyframeAst(_INITIAL_KEYFRAME, new AnimationStylesAst([values]));
	  }

	  function createDiTokenExpression(token) {
	      if (isPresent(token.value)) {
	          return literal(token.value);
	      }
	      else if (token.identifierIsInstance) {
	          return importExpr(token.identifier)
	              .instantiate([], importType(token.identifier, [], [TypeModifier.Const]));
	      }
	      else {
	          return importExpr(token.identifier);
	      }
	  }
	  function createInlineArray(values) {
	      if (values.length === 0) {
	          return importExpr(resolveIdentifier(Identifiers.EMPTY_INLINE_ARRAY));
	      }
	      var log2 = Math.log(values.length) / Math.log(2);
	      var index = Math.ceil(log2);
	      var identifierSpec = index < Identifiers.inlineArrays.length ? Identifiers.inlineArrays[index] :
	          Identifiers.InlineArrayDynamic;
	      var identifier = resolveIdentifier(identifierSpec);
	      return importExpr(identifier).instantiate([
	          literal(values.length)
	      ].concat(values));
	  }
	  function createPureProxy(fn, argCount, pureProxyProp, builder) {
	      builder.fields.push(new ClassField(pureProxyProp.name, null));
	      var pureProxyId = argCount < Identifiers.pureProxies.length ? Identifiers.pureProxies[argCount] : null;
	      if (!pureProxyId) {
	          throw new Error("Unsupported number of argument for pure functions: " + argCount);
	      }
	      builder.ctorStmts.push(THIS_EXPR.prop(pureProxyProp.name)
	          .set(importExpr(resolveIdentifier(pureProxyId)).callFn([fn]))
	          .toStmt());
	  }
	  function createEnumExpression(enumType, enumValue) {
	      var enumName = Object.keys(enumType.runtime).find(function (propName) { return enumType.runtime[propName] === enumValue; });
	      if (!enumName) {
	          throw new Error("Unknown enum value " + enumValue + " in " + enumType.name);
	      }
	      return importExpr(resolveEnumIdentifier(resolveIdentifier(enumType), enumName));
	  }

	  var CheckBindingField = (function () {
	      function CheckBindingField(expression, bindingId) {
	          this.expression = expression;
	          this.bindingId = bindingId;
	      }
	      return CheckBindingField;
	  }());
	  function createCheckBindingField(builder) {
	      var bindingId = "" + builder.fields.length;
	      var fieldExpr = createBindFieldExpr(bindingId);
	      // private is fine here as no child view will reference the cached value...
	      builder.fields.push(new ClassField(fieldExpr.name, null, [StmtModifier.Private]));
	      builder.ctorStmts.push(THIS_EXPR.prop(fieldExpr.name)
	          .set(importExpr(resolveIdentifier(Identifiers.UNINITIALIZED)))
	          .toStmt());
	      return new CheckBindingField(fieldExpr, bindingId);
	  }
	  function createCheckBindingStmt(evalResult, fieldExpr, throwOnChangeVar, actions) {
	      var condition = importExpr(resolveIdentifier(Identifiers.checkBinding)).callFn([
	          throwOnChangeVar, fieldExpr, evalResult.currValExpr
	      ]);
	      if (evalResult.forceUpdate) {
	          condition = evalResult.forceUpdate.or(condition);
	      }
	      return evalResult.stmts.concat([
	          new IfStmt(condition, actions.concat([
	              THIS_EXPR.prop(fieldExpr.name).set(evalResult.currValExpr).toStmt()
	          ]))
	      ]);
	  }
	  function createBindFieldExpr(bindingId) {
	      return THIS_EXPR.prop("_expr_" + bindingId);
	  }

	  var VAL_UNWRAPPER_VAR = variable("valUnwrapper");
	  var EventHandlerVars = (function () {
	      function EventHandlerVars() {
	      }
	      EventHandlerVars.event = variable('$event');
	      return EventHandlerVars;
	  }());
	  var ConvertPropertyBindingResult = (function () {
	      function ConvertPropertyBindingResult(stmts, currValExpr, forceUpdate) {
	          this.stmts = stmts;
	          this.currValExpr = currValExpr;
	          this.forceUpdate = forceUpdate;
	      }
	      return ConvertPropertyBindingResult;
	  }());
	  /**
	   * Converts the given expression AST into an executable output AST, assuming the expression is
	   * used in a property binding.
	   */
	  function convertPropertyBinding(builder, nameResolver, implicitReceiver, expression, bindingId) {
	      var currValExpr = createCurrValueExpr(bindingId);
	      var stmts = [];
	      if (!nameResolver) {
	          nameResolver = new DefaultNameResolver();
	      }
	      var visitor = new _AstToIrVisitor(builder, nameResolver, implicitReceiver, VAL_UNWRAPPER_VAR, bindingId, false);
	      var outputExpr = expression.visit(visitor, _Mode.Expression);
	      if (!outputExpr) {
	          // e.g. an empty expression was given
	          return null;
	      }
	      if (visitor.temporaryCount) {
	          for (var i = 0; i < visitor.temporaryCount; i++) {
	              stmts.push(temporaryDeclaration(bindingId, i));
	          }
	      }
	      if (visitor.needsValueUnwrapper) {
	          var initValueUnwrapperStmt = VAL_UNWRAPPER_VAR.callMethod('reset', []).toStmt();
	          stmts.push(initValueUnwrapperStmt);
	      }
	      stmts.push(currValExpr.set(outputExpr).toDeclStmt(null, [StmtModifier.Final]));
	      if (visitor.needsValueUnwrapper) {
	          return new ConvertPropertyBindingResult(stmts, currValExpr, VAL_UNWRAPPER_VAR.prop('hasWrappedValue'));
	      }
	      else {
	          return new ConvertPropertyBindingResult(stmts, currValExpr, null);
	      }
	  }
	  var ConvertActionBindingResult = (function () {
	      function ConvertActionBindingResult(stmts, preventDefault) {
	          this.stmts = stmts;
	          this.preventDefault = preventDefault;
	      }
	      return ConvertActionBindingResult;
	  }());
	  /**
	   * Converts the given expression AST into an executable output AST, assuming the expression is
	   * used in an action binding (e.g. an event handler).
	   */
	  function convertActionBinding(builder, nameResolver, implicitReceiver, action, bindingId) {
	      if (!nameResolver) {
	          nameResolver = new DefaultNameResolver();
	      }
	      var visitor = new _AstToIrVisitor(builder, nameResolver, implicitReceiver, null, bindingId, true);
	      var actionStmts = [];
	      flattenStatements(action.visit(visitor, _Mode.Statement), actionStmts);
	      prependTemporaryDecls(visitor.temporaryCount, bindingId, actionStmts);
	      var lastIndex = actionStmts.length - 1;
	      var preventDefaultVar = null;
	      if (lastIndex >= 0) {
	          var lastStatement = actionStmts[lastIndex];
	          var returnExpr = convertStmtIntoExpression(lastStatement);
	          if (returnExpr) {
	              // Note: We need to cast the result of the method call to dynamic,
	              // as it might be a void method!
	              preventDefaultVar = createPreventDefaultVar(bindingId);
	              actionStmts[lastIndex] =
	                  preventDefaultVar.set(returnExpr.cast(DYNAMIC_TYPE).notIdentical(literal(false)))
	                      .toDeclStmt(null, [StmtModifier.Final]);
	          }
	      }
	      return new ConvertActionBindingResult(actionStmts, preventDefaultVar);
	  }
	  /**
	   * Creates variables that are shared by multiple calls to `convertActionBinding` /
	   * `convertPropertyBinding`
	   */
	  function createSharedBindingVariablesIfNeeded(stmts) {
	      var unwrapperStmts = [];
	      var readVars = findReadVarNames(stmts);
	      if (readVars.has(VAL_UNWRAPPER_VAR.name)) {
	          unwrapperStmts.push(VAL_UNWRAPPER_VAR
	              .set(importExpr(resolveIdentifier(Identifiers.ValueUnwrapper)).instantiate([]))
	              .toDeclStmt(null, [StmtModifier.Final]));
	      }
	      return unwrapperStmts;
	  }
	  function temporaryName(bindingId, temporaryNumber) {
	      return "tmp_" + bindingId + "_" + temporaryNumber;
	  }
	  function temporaryDeclaration(bindingId, temporaryNumber) {
	      return new DeclareVarStmt(temporaryName(bindingId, temporaryNumber), NULL_EXPR);
	  }
	  function prependTemporaryDecls(temporaryCount, bindingId, statements) {
	      for (var i = temporaryCount - 1; i >= 0; i--) {
	          statements.unshift(temporaryDeclaration(bindingId, i));
	      }
	  }
	  var _Mode;
	  (function (_Mode) {
	      _Mode[_Mode["Statement"] = 0] = "Statement";
	      _Mode[_Mode["Expression"] = 1] = "Expression";
	  })(_Mode || (_Mode = {}));
	  function ensureStatementMode(mode, ast) {
	      if (mode !== _Mode.Statement) {
	          throw new Error("Expected a statement, but saw " + ast);
	      }
	  }
	  function ensureExpressionMode(mode, ast) {
	      if (mode !== _Mode.Expression) {
	          throw new Error("Expected an expression, but saw " + ast);
	      }
	  }
	  function convertToStatementIfNeeded(mode, expr) {
	      if (mode === _Mode.Statement) {
	          return expr.toStmt();
	      }
	      else {
	          return expr;
	      }
	  }
	  var _AstToIrVisitor = (function () {
	      function _AstToIrVisitor(_builder, _nameResolver, _implicitReceiver, _valueUnwrapper, bindingId, isAction) {
	          this._builder = _builder;
	          this._nameResolver = _nameResolver;
	          this._implicitReceiver = _implicitReceiver;
	          this._valueUnwrapper = _valueUnwrapper;
	          this.bindingId = bindingId;
	          this.isAction = isAction;
	          this._nodeMap = new Map();
	          this._resultMap = new Map();
	          this._currentTemporary = 0;
	          this.needsValueUnwrapper = false;
	          this.temporaryCount = 0;
	      }
	      _AstToIrVisitor.prototype.visitBinary = function (ast, mode) {
	          var op;
	          switch (ast.operation) {
	              case '+':
	                  op = BinaryOperator.Plus;
	                  break;
	              case '-':
	                  op = BinaryOperator.Minus;
	                  break;
	              case '*':
	                  op = BinaryOperator.Multiply;
	                  break;
	              case '/':
	                  op = BinaryOperator.Divide;
	                  break;
	              case '%':
	                  op = BinaryOperator.Modulo;
	                  break;
	              case '&&':
	                  op = BinaryOperator.And;
	                  break;
	              case '||':
	                  op = BinaryOperator.Or;
	                  break;
	              case '==':
	                  op = BinaryOperator.Equals;
	                  break;
	              case '!=':
	                  op = BinaryOperator.NotEquals;
	                  break;
	              case '===':
	                  op = BinaryOperator.Identical;
	                  break;
	              case '!==':
	                  op = BinaryOperator.NotIdentical;
	                  break;
	              case '<':
	                  op = BinaryOperator.Lower;
	                  break;
	              case '>':
	                  op = BinaryOperator.Bigger;
	                  break;
	              case '<=':
	                  op = BinaryOperator.LowerEquals;
	                  break;
	              case '>=':
	                  op = BinaryOperator.BiggerEquals;
	                  break;
	              default:
	                  throw new Error("Unsupported operation " + ast.operation);
	          }
	          return convertToStatementIfNeeded(mode, new BinaryOperatorExpr(op, this.visit(ast.left, _Mode.Expression), this.visit(ast.right, _Mode.Expression)));
	      };
	      _AstToIrVisitor.prototype.visitChain = function (ast, mode) {
	          ensureStatementMode(mode, ast);
	          return this.visitAll(ast.expressions, mode);
	      };
	      _AstToIrVisitor.prototype.visitConditional = function (ast, mode) {
	          var value = this.visit(ast.condition, _Mode.Expression);
	          return convertToStatementIfNeeded(mode, value.conditional(this.visit(ast.trueExp, _Mode.Expression), this.visit(ast.falseExp, _Mode.Expression)));
	      };
	      _AstToIrVisitor.prototype.visitPipe = function (ast, mode) {
	          var input = this.visit(ast.exp, _Mode.Expression);
	          var args = this.visitAll(ast.args, _Mode.Expression);
	          var value = this._nameResolver.callPipe(ast.name, input, args);
	          if (!value) {
	              throw new Error("Illegal state: Pipe " + ast.name + " is not allowed here!");
	          }
	          this.needsValueUnwrapper = true;
	          return convertToStatementIfNeeded(mode, this._valueUnwrapper.callMethod('unwrap', [value]));
	      };
	      _AstToIrVisitor.prototype.visitFunctionCall = function (ast, mode) {
	          return convertToStatementIfNeeded(mode, this.visit(ast.target, _Mode.Expression).callFn(this.visitAll(ast.args, _Mode.Expression)));
	      };
	      _AstToIrVisitor.prototype.visitImplicitReceiver = function (ast, mode) {
	          ensureExpressionMode(mode, ast);
	          return this._implicitReceiver;
	      };
	      _AstToIrVisitor.prototype.visitInterpolation = function (ast, mode) {
	          ensureExpressionMode(mode, ast);
	          var args = [literal(ast.expressions.length)];
	          for (var i = 0; i < ast.strings.length - 1; i++) {
	              args.push(literal(ast.strings[i]));
	              args.push(this.visit(ast.expressions[i], _Mode.Expression));
	          }
	          args.push(literal(ast.strings[ast.strings.length - 1]));
	          return importExpr(resolveIdentifier(Identifiers.interpolate)).callFn(args);
	      };
	      _AstToIrVisitor.prototype.visitKeyedRead = function (ast, mode) {
	          return convertToStatementIfNeeded(mode, this.visit(ast.obj, _Mode.Expression).key(this.visit(ast.key, _Mode.Expression)));
	      };
	      _AstToIrVisitor.prototype.visitKeyedWrite = function (ast, mode) {
	          var obj = this.visit(ast.obj, _Mode.Expression);
	          var key = this.visit(ast.key, _Mode.Expression);
	          var value = this.visit(ast.value, _Mode.Expression);
	          return convertToStatementIfNeeded(mode, obj.key(key).set(value));
	      };
	      _AstToIrVisitor.prototype.visitLiteralArray = function (ast, mode) {
	          var parts = this.visitAll(ast.expressions, mode);
	          var literalArr$$ = this.isAction ? literalArr(parts) : createCachedLiteralArray(this._builder, parts);
	          return convertToStatementIfNeeded(mode, literalArr$$);
	      };
	      _AstToIrVisitor.prototype.visitLiteralMap = function (ast, mode) {
	          var parts = [];
	          for (var i = 0; i < ast.keys.length; i++) {
	              parts.push([ast.keys[i], this.visit(ast.values[i], _Mode.Expression)]);
	          }
	          var literalMap$$ = this.isAction ? literalMap(parts) : createCachedLiteralMap(this._builder, parts);
	          return convertToStatementIfNeeded(mode, literalMap$$);
	      };
	      _AstToIrVisitor.prototype.visitLiteralPrimitive = function (ast, mode) {
	          return convertToStatementIfNeeded(mode, literal(ast.value));
	      };
	      _AstToIrVisitor.prototype._getLocal = function (name) {
	          if (this.isAction && name == EventHandlerVars.event.name) {
	              return EventHandlerVars.event;
	          }
	          return this._nameResolver.getLocal(name);
	      };
	      _AstToIrVisitor.prototype.visitMethodCall = function (ast, mode) {
	          var leftMostSafe = this.leftMostSafeNode(ast);
	          if (leftMostSafe) {
	              return this.convertSafeAccess(ast, leftMostSafe, mode);
	          }
	          else {
	              var args = this.visitAll(ast.args, _Mode.Expression);
	              var result = null;
	              var receiver = this.visit(ast.receiver, _Mode.Expression);
	              if (receiver === this._implicitReceiver) {
	                  var varExpr = this._getLocal(ast.name);
	                  if (isPresent(varExpr)) {
	                      result = varExpr.callFn(args);
	                  }
	              }
	              if (isBlank(result)) {
	                  result = receiver.callMethod(ast.name, args);
	              }
	              return convertToStatementIfNeeded(mode, result);
	          }
	      };
	      _AstToIrVisitor.prototype.visitPrefixNot = function (ast, mode) {
	          return convertToStatementIfNeeded(mode, not(this.visit(ast.expression, _Mode.Expression)));
	      };
	      _AstToIrVisitor.prototype.visitPropertyRead = function (ast, mode) {
	          var leftMostSafe = this.leftMostSafeNode(ast);
	          if (leftMostSafe) {
	              return this.convertSafeAccess(ast, leftMostSafe, mode);
	          }
	          else {
	              var result = null;
	              var receiver = this.visit(ast.receiver, _Mode.Expression);
	              if (receiver === this._implicitReceiver) {
	                  result = this._getLocal(ast.name);
	              }
	              if (isBlank(result)) {
	                  result = receiver.prop(ast.name);
	              }
	              return convertToStatementIfNeeded(mode, result);
	          }
	      };
	      _AstToIrVisitor.prototype.visitPropertyWrite = function (ast, mode) {
	          var receiver = this.visit(ast.receiver, _Mode.Expression);
	          if (receiver === this._implicitReceiver) {
	              var varExpr = this._getLocal(ast.name);
	              if (isPresent(varExpr)) {
	                  throw new Error('Cannot assign to a reference or variable!');
	              }
	          }
	          return convertToStatementIfNeeded(mode, receiver.prop(ast.name).set(this.visit(ast.value, _Mode.Expression)));
	      };
	      _AstToIrVisitor.prototype.visitSafePropertyRead = function (ast, mode) {
	          return this.convertSafeAccess(ast, this.leftMostSafeNode(ast), mode);
	      };
	      _AstToIrVisitor.prototype.visitSafeMethodCall = function (ast, mode) {
	          return this.convertSafeAccess(ast, this.leftMostSafeNode(ast), mode);
	      };
	      _AstToIrVisitor.prototype.visitAll = function (asts, mode) {
	          var _this = this;
	          return asts.map(function (ast) { return _this.visit(ast, mode); });
	      };
	      _AstToIrVisitor.prototype.visitQuote = function (ast, mode) {
	          throw new Error('Quotes are not supported for evaluation!');
	      };
	      _AstToIrVisitor.prototype.visit = function (ast, mode) {
	          var result = this._resultMap.get(ast);
	          if (result)
	              return result;
	          return (this._nodeMap.get(ast) || ast).visit(this, mode);
	      };
	      _AstToIrVisitor.prototype.convertSafeAccess = function (ast, leftMostSafe, mode) {
	          // If the expression contains a safe access node on the left it needs to be converted to
	          // an expression that guards the access to the member by checking the receiver for blank. As
	          // execution proceeds from left to right, the left most part of the expression must be guarded
	          // first but, because member access is left associative, the right side of the expression is at
	          // the top of the AST. The desired result requires lifting a copy of the the left part of the
	          // expression up to test it for blank before generating the unguarded version.
	          // Consider, for example the following expression: a?.b.c?.d.e
	          // This results in the ast:
	          //         .
	          //        / \
	          //       ?.   e
	          //      /  \
	          //     .    d
	          //    / \
	          //   ?.  c
	          //  /  \
	          // a    b
	          // The following tree should be generated:
	          //
	          //        /---- ? ----\
	          //       /      |      \
	          //     a   /--- ? ---\  null
	          //        /     |     \
	          //       .      .     null
	          //      / \    / \
	          //     .  c   .   e
	          //    / \    / \
	          //   a   b  ,   d
	          //         / \
	          //        .   c
	          //       / \
	          //      a   b
	          //
	          // Notice that the first guard condition is the left hand of the left most safe access node
	          // which comes in as leftMostSafe to this routine.
	          var guardedExpression = this.visit(leftMostSafe.receiver, _Mode.Expression);
	          var temporary;
	          if (this.needsTemporary(leftMostSafe.receiver)) {
	              // If the expression has method calls or pipes then we need to save the result into a
	              // temporary variable to avoid calling stateful or impure code more than once.
	              temporary = this.allocateTemporary();
	              // Preserve the result in the temporary variable
	              guardedExpression = temporary.set(guardedExpression);
	              // Ensure all further references to the guarded expression refer to the temporary instead.
	              this._resultMap.set(leftMostSafe.receiver, temporary);
	          }
	          var condition = guardedExpression.isBlank();
	          // Convert the ast to an unguarded access to the receiver's member. The map will substitute
	          // leftMostNode with its unguarded version in the call to `this.visit()`.
	          if (leftMostSafe instanceof SafeMethodCall) {
	              this._nodeMap.set(leftMostSafe, new MethodCall(leftMostSafe.span, leftMostSafe.receiver, leftMostSafe.name, leftMostSafe.args));
	          }
	          else {
	              this._nodeMap.set(leftMostSafe, new PropertyRead(leftMostSafe.span, leftMostSafe.receiver, leftMostSafe.name));
	          }
	          // Recursively convert the node now without the guarded member access.
	          var access = this.visit(ast, _Mode.Expression);
	          // Remove the mapping. This is not strictly required as the converter only traverses each node
	          // once but is safer if the conversion is changed to traverse the nodes more than once.
	          this._nodeMap.delete(leftMostSafe);
	          // If we allcoated a temporary, release it.
	          if (temporary) {
	              this.releaseTemporary(temporary);
	          }
	          // Produce the conditional
	          return convertToStatementIfNeeded(mode, condition.conditional(literal(null), access));
	      };
	      // Given a expression of the form a?.b.c?.d.e the the left most safe node is
	      // the (a?.b). The . and ?. are left associative thus can be rewritten as:
	      // ((((a?.c).b).c)?.d).e. This returns the most deeply nested safe read or
	      // safe method call as this needs be transform initially to:
	      //   a == null ? null : a.c.b.c?.d.e
	      // then to:
	      //   a == null ? null : a.b.c == null ? null : a.b.c.d.e
	      _AstToIrVisitor.prototype.leftMostSafeNode = function (ast) {
	          var _this = this;
	          var visit = function (visitor, ast) {
	              return (_this._nodeMap.get(ast) || ast).visit(visitor);
	          };
	          return ast.visit({
	              visitBinary: function (ast) { return null; },
	              visitChain: function (ast) { return null; },
	              visitConditional: function (ast) { return null; },
	              visitFunctionCall: function (ast) { return null; },
	              visitImplicitReceiver: function (ast) { return null; },
	              visitInterpolation: function (ast) { return null; },
	              visitKeyedRead: function (ast) { return visit(this, ast.obj); },
	              visitKeyedWrite: function (ast) { return null; },
	              visitLiteralArray: function (ast) { return null; },
	              visitLiteralMap: function (ast) { return null; },
	              visitLiteralPrimitive: function (ast) { return null; },
	              visitMethodCall: function (ast) { return visit(this, ast.receiver); },
	              visitPipe: function (ast) { return null; },
	              visitPrefixNot: function (ast) { return null; },
	              visitPropertyRead: function (ast) { return visit(this, ast.receiver); },
	              visitPropertyWrite: function (ast) { return null; },
	              visitQuote: function (ast) { return null; },
	              visitSafeMethodCall: function (ast) { return visit(this, ast.receiver) || ast; },
	              visitSafePropertyRead: function (ast) {
	                  return visit(this, ast.receiver) || ast;
	              }
	          });
	      };
	      // Returns true of the AST includes a method or a pipe indicating that, if the
	      // expression is used as the target of a safe property or method access then
	      // the expression should be stored into a temporary variable.
	      _AstToIrVisitor.prototype.needsTemporary = function (ast) {
	          var _this = this;
	          var visit = function (visitor, ast) {
	              return ast && (_this._nodeMap.get(ast) || ast).visit(visitor);
	          };
	          var visitSome = function (visitor, ast) {
	              return ast.some(function (ast) { return visit(visitor, ast); });
	          };
	          return ast.visit({
	              visitBinary: function (ast) { return visit(this, ast.left) || visit(this, ast.right); },
	              visitChain: function (ast) { return false; },
	              visitConditional: function (ast) {
	                  return visit(this, ast.condition) || visit(this, ast.trueExp) ||
	                      visit(this, ast.falseExp);
	              },
	              visitFunctionCall: function (ast) { return true; },
	              visitImplicitReceiver: function (ast) { return false; },
	              visitInterpolation: function (ast) { return visitSome(this, ast.expressions); },
	              visitKeyedRead: function (ast) { return false; },
	              visitKeyedWrite: function (ast) { return false; },
	              visitLiteralArray: function (ast) { return true; },
	              visitLiteralMap: function (ast) { return true; },
	              visitLiteralPrimitive: function (ast) { return false; },
	              visitMethodCall: function (ast) { return true; },
	              visitPipe: function (ast) { return true; },
	              visitPrefixNot: function (ast) { return visit(this, ast.expression); },
	              visitPropertyRead: function (ast) { return false; },
	              visitPropertyWrite: function (ast) { return false; },
	              visitQuote: function (ast) { return false; },
	              visitSafeMethodCall: function (ast) { return true; },
	              visitSafePropertyRead: function (ast) { return false; }
	          });
	      };
	      _AstToIrVisitor.prototype.allocateTemporary = function () {
	          var tempNumber = this._currentTemporary++;
	          this.temporaryCount = Math.max(this._currentTemporary, this.temporaryCount);
	          return new ReadVarExpr(temporaryName(this.bindingId, tempNumber));
	      };
	      _AstToIrVisitor.prototype.releaseTemporary = function (temporary) {
	          this._currentTemporary--;
	          if (temporary.name != temporaryName(this.bindingId, this._currentTemporary)) {
	              throw new Error("Temporary " + temporary.name + " released out of order");
	          }
	      };
	      return _AstToIrVisitor;
	  }());
	  function flattenStatements(arg, output) {
	      if (Array.isArray(arg)) {
	          arg.forEach(function (entry) { return flattenStatements(entry, output); });
	      }
	      else {
	          output.push(arg);
	      }
	  }
	  function createCachedLiteralArray(builder, values) {
	      if (values.length === 0) {
	          return importExpr(resolveIdentifier(Identifiers.EMPTY_ARRAY));
	      }
	      var proxyExpr = THIS_EXPR.prop("_arr_" + builder.fields.length);
	      var proxyParams = [];
	      var proxyReturnEntries = [];
	      for (var i = 0; i < values.length; i++) {
	          var paramName = "p" + i;
	          proxyParams.push(new FnParam(paramName));
	          proxyReturnEntries.push(variable(paramName));
	      }
	      createPureProxy(fn(proxyParams, [new ReturnStatement(literalArr(proxyReturnEntries))], new ArrayType(DYNAMIC_TYPE)), values.length, proxyExpr, builder);
	      return proxyExpr.callFn(values);
	  }
	  function createCachedLiteralMap(builder, entries) {
	      if (entries.length === 0) {
	          return importExpr(resolveIdentifier(Identifiers.EMPTY_MAP));
	      }
	      var proxyExpr = THIS_EXPR.prop("_map_" + builder.fields.length);
	      var proxyParams = [];
	      var proxyReturnEntries = [];
	      var values = [];
	      for (var i = 0; i < entries.length; i++) {
	          var paramName = "p" + i;
	          proxyParams.push(new FnParam(paramName));
	          proxyReturnEntries.push([entries[i][0], variable(paramName)]);
	          values.push(entries[i][1]);
	      }
	      createPureProxy(fn(proxyParams, [new ReturnStatement(literalMap(proxyReturnEntries))], new MapType(DYNAMIC_TYPE)), entries.length, proxyExpr, builder);
	      return proxyExpr.callFn(values);
	  }
	  var DefaultNameResolver = (function () {
	      function DefaultNameResolver() {
	      }
	      DefaultNameResolver.prototype.callPipe = function (name, input, args) { return null; };
	      DefaultNameResolver.prototype.getLocal = function (name) { return null; };
	      return DefaultNameResolver;
	  }());
	  function createCurrValueExpr(bindingId) {
	      return variable("currVal_" + bindingId); // fix syntax highlighting: `
	  }
	  function createPreventDefaultVar(bindingId) {
	      return variable("pd_" + bindingId);
	  }
	  function convertStmtIntoExpression(stmt) {
	      if (stmt instanceof ExpressionStatement) {
	          return stmt.expr;
	      }
	      else if (stmt instanceof ReturnStatement) {
	          return stmt.value;
	      }
	      return null;
	  }

	  function writeToRenderer(view, boundProp, renderElement, renderValue, logBindingUpdate, securityContextExpression) {
	      var updateStmts = [];
	      var renderer = view.prop('renderer');
	      renderValue = sanitizedValue(view, boundProp, renderValue, securityContextExpression);
	      switch (boundProp.type) {
	          case exports.PropertyBindingType.Property:
	              if (logBindingUpdate) {
	                  updateStmts.push(importExpr(resolveIdentifier(Identifiers.setBindingDebugInfo))
	                      .callFn([renderer, renderElement, literal(boundProp.name), renderValue])
	                      .toStmt());
	              }
	              updateStmts.push(renderer
	                  .callMethod('setElementProperty', [renderElement, literal(boundProp.name), renderValue])
	                  .toStmt());
	              break;
	          case exports.PropertyBindingType.Attribute:
	              renderValue =
	                  renderValue.isBlank().conditional(NULL_EXPR, renderValue.callMethod('toString', []));
	              updateStmts.push(renderer
	                  .callMethod('setElementAttribute', [renderElement, literal(boundProp.name), renderValue])
	                  .toStmt());
	              break;
	          case exports.PropertyBindingType.Class:
	              updateStmts.push(renderer
	                  .callMethod('setElementClass', [renderElement, literal(boundProp.name), renderValue])
	                  .toStmt());
	              break;
	          case exports.PropertyBindingType.Style:
	              var strValue = renderValue.callMethod('toString', []);
	              if (isPresent(boundProp.unit)) {
	                  strValue = strValue.plus(literal(boundProp.unit));
	              }
	              renderValue = renderValue.isBlank().conditional(NULL_EXPR, strValue);
	              updateStmts.push(renderer
	                  .callMethod('setElementStyle', [renderElement, literal(boundProp.name), renderValue])
	                  .toStmt());
	              break;
	          case exports.PropertyBindingType.Animation:
	              throw new Error('Illegal state: Should not come here!');
	      }
	      return updateStmts;
	  }
	  function sanitizedValue(view, boundProp, renderValue, securityContextExpression) {
	      if (boundProp.securityContext === _angular_core.SecurityContext.NONE) {
	          return renderValue; // No sanitization needed.
	      }
	      if (!boundProp.needsRuntimeSecurityContext) {
	          securityContextExpression =
	              createEnumExpression(Identifiers.SecurityContext, boundProp.securityContext);
	      }
	      if (!securityContextExpression) {
	          throw new Error("internal error, no SecurityContext given " + boundProp.name);
	      }
	      var ctx = view.prop('viewUtils').prop('sanitizer');
	      var args = [securityContextExpression, renderValue];
	      return ctx.callMethod('sanitize', args);
	  }

	  /**
	   * Create a new class stmts based on the given data.
	   */
	  function createClassStmt(config) {
	      var parentArgs = config.parentArgs || [];
	      var superCtorStmts = config.parent ? [SUPER_EXPR.callFn(parentArgs).toStmt()] : [];
	      var builder = concatClassBuilderParts(Array.isArray(config.builders) ? config.builders : [config.builders]);
	      var ctor = new ClassMethod(null, config.ctorParams || [], superCtorStmts.concat(builder.ctorStmts));
	      return new ClassStmt(config.name, config.parent, builder.fields, builder.getters, ctor, builder.methods, config.modifiers || []);
	  }
	  function concatClassBuilderParts(builders) {
	      return {
	          fields: (_a = []).concat.apply(_a, builders.map(function (builder) { return builder.fields || []; })),
	          methods: (_b = []).concat.apply(_b, builders.map(function (builder) { return builder.methods || []; })),
	          getters: (_c = []).concat.apply(_c, builders.map(function (builder) { return builder.getters || []; })),
	          ctorStmts: (_d = []).concat.apply(_d, builders.map(function (builder) { return builder.ctorStmts || []; })),
	      };
	      var _a, _b, _c, _d;
	  }

	  var DirectiveWrapperCompileResult = (function () {
	      function DirectiveWrapperCompileResult(statements, dirWrapperClassVar) {
	          this.statements = statements;
	          this.dirWrapperClassVar = dirWrapperClassVar;
	      }
	      return DirectiveWrapperCompileResult;
	  }());
	  var CONTEXT_FIELD_NAME = 'context';
	  var CHANGES_FIELD_NAME = 'changes';
	  var CHANGED_FIELD_NAME = 'changed';
	  var CURR_VALUE_VAR = variable('currValue');
	  var THROW_ON_CHANGE_VAR = variable('throwOnChange');
	  var FORCE_UPDATE_VAR = variable('forceUpdate');
	  var VIEW_VAR = variable('view');
	  var RENDER_EL_VAR = variable('el');
	  var RESET_CHANGES_STMT = THIS_EXPR.prop(CHANGES_FIELD_NAME).set(literalMap([])).toStmt();
	  /**
	   * We generate directive wrappers to prevent code bloat when a directive is used.
	   * A directive wrapper encapsulates
	   * the dirty checking for `@Input`, the handling of `@HostListener` / `@HostBinding`
	   * and calling the lifecyclehooks `ngOnInit`, `ngOnChanges`, `ngDoCheck`.
	   *
	   * So far, only `@Input` and the lifecycle hooks have been implemented.
	   */
	  var DirectiveWrapperCompiler = (function () {
	      function DirectiveWrapperCompiler(compilerConfig, _exprParser, _schemaRegistry, _console) {
	          this.compilerConfig = compilerConfig;
	          this._exprParser = _exprParser;
	          this._schemaRegistry = _schemaRegistry;
	          this._console = _console;
	      }
	      DirectiveWrapperCompiler.dirWrapperClassName = function (id) { return "Wrapper_" + id.name; };
	      DirectiveWrapperCompiler.prototype.compile = function (dirMeta) {
	          var builder = new DirectiveWrapperBuilder(this.compilerConfig, dirMeta);
	          Object.keys(dirMeta.inputs).forEach(function (inputFieldName) {
	              addCheckInputMethod(inputFieldName, builder);
	          });
	          addDetectChangesInInputPropsMethod(builder);
	          var hostParseResult = parseHostBindings(dirMeta, this._exprParser, this._schemaRegistry);
	          reportParseErrors(hostParseResult.errors, this._console);
	          // host properties are change detected by the DirectiveWrappers,
	          // except for the animation properties as they need close integration with animation events
	          // and DirectiveWrappers don't support
	          // event listeners right now.
	          addDetectChangesInHostPropsMethod(hostParseResult.hostProps.filter(function (hostProp) { return !hostProp.isAnimation; }), builder);
	          // TODO(tbosch): implement hostListeners via DirectiveWrapper as well!
	          var classStmt = builder.build();
	          return new DirectiveWrapperCompileResult([classStmt], classStmt.name);
	      };
	      DirectiveWrapperCompiler.decorators = [
	          { type: _angular_core.Injectable },
	      ];
	      /** @nocollapse */
	      DirectiveWrapperCompiler.ctorParameters = [
	          { type: CompilerConfig, },
	          { type: Parser, },
	          { type: ElementSchemaRegistry, },
	          { type: Console, },
	      ];
	      return DirectiveWrapperCompiler;
	  }());
	  var DirectiveWrapperBuilder = (function () {
	      function DirectiveWrapperBuilder(compilerConfig, dirMeta) {
	          this.compilerConfig = compilerConfig;
	          this.dirMeta = dirMeta;
	          this.fields = [];
	          this.getters = [];
	          this.methods = [];
	          this.ctorStmts = [];
	          var dirLifecycleHooks = dirMeta.type.lifecycleHooks;
	          this.genChanges = dirLifecycleHooks.indexOf(LifecycleHooks.OnChanges) !== -1 ||
	              this.compilerConfig.logBindingUpdate;
	          this.ngOnChanges = dirLifecycleHooks.indexOf(LifecycleHooks.OnChanges) !== -1;
	          this.ngOnInit = dirLifecycleHooks.indexOf(LifecycleHooks.OnInit) !== -1;
	          this.ngDoCheck = dirLifecycleHooks.indexOf(LifecycleHooks.DoCheck) !== -1;
	      }
	      DirectiveWrapperBuilder.prototype.build = function () {
	          var dirDepParamNames = [];
	          for (var i = 0; i < this.dirMeta.type.diDeps.length; i++) {
	              dirDepParamNames.push("p" + i);
	          }
	          var fields = [
	              new ClassField(CONTEXT_FIELD_NAME, importType(this.dirMeta.type)),
	              new ClassField(CHANGED_FIELD_NAME, BOOL_TYPE),
	          ];
	          var ctorStmts = [THIS_EXPR.prop(CHANGED_FIELD_NAME).set(literal(false)).toStmt()];
	          if (this.genChanges) {
	              fields.push(new ClassField(CHANGES_FIELD_NAME, new MapType(DYNAMIC_TYPE)));
	              ctorStmts.push(RESET_CHANGES_STMT);
	          }
	          ctorStmts.push(THIS_EXPR.prop(CONTEXT_FIELD_NAME)
	              .set(importExpr(this.dirMeta.type)
	              .instantiate(dirDepParamNames.map(function (paramName) { return variable(paramName); })))
	              .toStmt());
	          return createClassStmt({
	              name: DirectiveWrapperCompiler.dirWrapperClassName(this.dirMeta.type),
	              ctorParams: dirDepParamNames.map(function (paramName) { return new FnParam(paramName, DYNAMIC_TYPE); }),
	              builders: [{ fields: fields, ctorStmts: ctorStmts }, this]
	          });
	      };
	      return DirectiveWrapperBuilder;
	  }());
	  function addDetectChangesInInputPropsMethod(builder) {
	      var changedVar = variable('changed');
	      var stmts = [
	          changedVar.set(THIS_EXPR.prop(CHANGED_FIELD_NAME)).toDeclStmt(),
	          THIS_EXPR.prop(CHANGED_FIELD_NAME).set(literal(false)).toStmt(),
	      ];
	      var lifecycleStmts = [];
	      if (builder.genChanges) {
	          var onChangesStmts = [];
	          if (builder.ngOnChanges) {
	              onChangesStmts.push(THIS_EXPR.prop(CONTEXT_FIELD_NAME)
	                  .callMethod('ngOnChanges', [THIS_EXPR.prop(CHANGES_FIELD_NAME)])
	                  .toStmt());
	          }
	          if (builder.compilerConfig.logBindingUpdate) {
	              onChangesStmts.push(importExpr(resolveIdentifier(Identifiers.setBindingDebugInfoForChanges))
	                  .callFn([VIEW_VAR.prop('renderer'), RENDER_EL_VAR, THIS_EXPR.prop(CHANGES_FIELD_NAME)])
	                  .toStmt());
	          }
	          onChangesStmts.push(RESET_CHANGES_STMT);
	          lifecycleStmts.push(new IfStmt(changedVar, onChangesStmts));
	      }
	      if (builder.ngOnInit) {
	          lifecycleStmts.push(new IfStmt(VIEW_VAR.prop('numberOfChecks').identical(new LiteralExpr(0)), [THIS_EXPR.prop(CONTEXT_FIELD_NAME).callMethod('ngOnInit', []).toStmt()]));
	      }
	      if (builder.ngDoCheck) {
	          lifecycleStmts.push(THIS_EXPR.prop(CONTEXT_FIELD_NAME).callMethod('ngDoCheck', []).toStmt());
	      }
	      if (lifecycleStmts.length > 0) {
	          stmts.push(new IfStmt(not(THROW_ON_CHANGE_VAR), lifecycleStmts));
	      }
	      stmts.push(new ReturnStatement(changedVar));
	      builder.methods.push(new ClassMethod('detectChangesInInputProps', [
	          new FnParam(VIEW_VAR.name, importType(resolveIdentifier(Identifiers.AppView), [DYNAMIC_TYPE])),
	          new FnParam(RENDER_EL_VAR.name, DYNAMIC_TYPE),
	          new FnParam(THROW_ON_CHANGE_VAR.name, BOOL_TYPE),
	      ], stmts, BOOL_TYPE));
	  }
	  function addCheckInputMethod(input, builder) {
	      var field = createCheckBindingField(builder);
	      var onChangeStatements = [
	          THIS_EXPR.prop(CHANGED_FIELD_NAME).set(literal(true)).toStmt(),
	          THIS_EXPR.prop(CONTEXT_FIELD_NAME).prop(input).set(CURR_VALUE_VAR).toStmt(),
	      ];
	      if (builder.genChanges) {
	          onChangeStatements.push(THIS_EXPR.prop(CHANGES_FIELD_NAME)
	              .key(literal(input))
	              .set(importExpr(resolveIdentifier(Identifiers.SimpleChange))
	              .instantiate([field.expression, CURR_VALUE_VAR]))
	              .toStmt());
	      }
	      var methodBody = createCheckBindingStmt({ currValExpr: CURR_VALUE_VAR, forceUpdate: FORCE_UPDATE_VAR, stmts: [] }, field.expression, THROW_ON_CHANGE_VAR, onChangeStatements);
	      builder.methods.push(new ClassMethod("check_" + input, [
	          new FnParam(CURR_VALUE_VAR.name, DYNAMIC_TYPE),
	          new FnParam(THROW_ON_CHANGE_VAR.name, BOOL_TYPE),
	          new FnParam(FORCE_UPDATE_VAR.name, BOOL_TYPE),
	      ], methodBody));
	  }
	  function addDetectChangesInHostPropsMethod(hostProps, builder) {
	      var stmts = [];
	      var methodParams = [
	          new FnParam(VIEW_VAR.name, importType(resolveIdentifier(Identifiers.AppView), [DYNAMIC_TYPE])),
	          new FnParam(RENDER_EL_VAR.name, DYNAMIC_TYPE),
	          new FnParam(THROW_ON_CHANGE_VAR.name, BOOL_TYPE),
	      ];
	      hostProps.forEach(function (hostProp) {
	          var field = createCheckBindingField(builder);
	          var evalResult = convertPropertyBinding(builder, null, THIS_EXPR.prop(CONTEXT_FIELD_NAME), hostProp.value, field.bindingId);
	          if (!evalResult) {
	              return;
	          }
	          var securityContextExpr;
	          if (hostProp.needsRuntimeSecurityContext) {
	              securityContextExpr = variable("secCtx_" + methodParams.length);
	              methodParams.push(new FnParam(securityContextExpr.name, importType(resolveIdentifier(Identifiers.SecurityContext))));
	          }
	          stmts.push.apply(stmts, createCheckBindingStmt(evalResult, field.expression, THROW_ON_CHANGE_VAR, writeToRenderer(VIEW_VAR, hostProp, RENDER_EL_VAR, evalResult.currValExpr, builder.compilerConfig.logBindingUpdate, securityContextExpr)));
	      });
	      builder.methods.push(new ClassMethod('detectChangesInHostProps', methodParams, stmts));
	  }
	  var ParseResult = (function () {
	      function ParseResult(hostProps, hostListeners, errors) {
	          this.hostProps = hostProps;
	          this.hostListeners = hostListeners;
	          this.errors = errors;
	      }
	      return ParseResult;
	  }());
	  function parseHostBindings(dirMeta, exprParser, schemaRegistry) {
	      var errors = [];
	      var parser = new BindingParser(exprParser, DEFAULT_INTERPOLATION_CONFIG, schemaRegistry, [], errors);
	      var sourceFileName = dirMeta.type.moduleUrl ?
	          "in Directive " + dirMeta.type.name + " in " + dirMeta.type.moduleUrl :
	          "in Directive " + dirMeta.type.name;
	      var sourceFile = new ParseSourceFile('', sourceFileName);
	      var sourceSpan = new ParseSourceSpan(new ParseLocation(sourceFile, null, null, null), new ParseLocation(sourceFile, null, null, null));
	      var parsedHostProps = parser.createDirectiveHostPropertyAsts(dirMeta, sourceSpan);
	      var parsedHostListeners = parser.createDirectiveHostEventAsts(dirMeta, sourceSpan);
	      return new ParseResult(parsedHostProps, parsedHostListeners, errors);
	  }
	  function reportParseErrors(parseErrors, console) {
	      var warnings = parseErrors.filter(function (error) { return error.level === exports.ParseErrorLevel.WARNING; });
	      var errors = parseErrors.filter(function (error) { return error.level === exports.ParseErrorLevel.FATAL; });
	      if (warnings.length > 0) {
	          this._console.warn("Directive parse warnings:\n" + warnings.join('\n'));
	      }
	      if (errors.length > 0) {
	          throw new Error("Directive parse errors:\n" + errors.join('\n'));
	      }
	  }

	  function convertValueToOutputAst(value, type) {
	      if (type === void 0) { type = null; }
	      return visitValue(value, new _ValueOutputAstTransformer(), type);
	  }
	  var _ValueOutputAstTransformer = (function () {
	      function _ValueOutputAstTransformer() {
	      }
	      _ValueOutputAstTransformer.prototype.visitArray = function (arr, type) {
	          var _this = this;
	          return literalArr(arr.map(function (value) { return visitValue(value, _this, null); }), type);
	      };
	      _ValueOutputAstTransformer.prototype.visitStringMap = function (map, type) {
	          var _this = this;
	          var entries = [];
	          Object.keys(map).forEach(function (key) { entries.push([key, visitValue(map[key], _this, null)]); });
	          return literalMap(entries, type);
	      };
	      _ValueOutputAstTransformer.prototype.visitPrimitive = function (value, type) { return literal(value, type); };
	      _ValueOutputAstTransformer.prototype.visitOther = function (value, type) {
	          if (value instanceof CompileIdentifierMetadata) {
	              return importExpr(value);
	          }
	          else if (value instanceof Expression) {
	              return value;
	          }
	          else {
	              throw new Error("Illegal state: Don't now how to compile value " + value);
	          }
	      };
	      return _ValueOutputAstTransformer;
	  }());

	  var _DebugState = (function () {
	      function _DebugState(nodeIndex, sourceAst) {
	          this.nodeIndex = nodeIndex;
	          this.sourceAst = sourceAst;
	      }
	      return _DebugState;
	  }());
	  var NULL_DEBUG_STATE = new _DebugState(null, null);
	  var CompileMethod = (function () {
	      function CompileMethod(_view) {
	          this._view = _view;
	          this._newState = NULL_DEBUG_STATE;
	          this._currState = NULL_DEBUG_STATE;
	          this._bodyStatements = [];
	          this._debugEnabled = this._view.genConfig.genDebugInfo;
	      }
	      CompileMethod.prototype._updateDebugContextIfNeeded = function () {
	          if (this._newState.nodeIndex !== this._currState.nodeIndex ||
	              this._newState.sourceAst !== this._currState.sourceAst) {
	              var expr = this._updateDebugContext(this._newState);
	              if (isPresent(expr)) {
	                  this._bodyStatements.push(expr.toStmt());
	              }
	          }
	      };
	      CompileMethod.prototype._updateDebugContext = function (newState) {
	          this._currState = this._newState = newState;
	          if (this._debugEnabled) {
	              var sourceLocation = isPresent(newState.sourceAst) ? newState.sourceAst.sourceSpan.start : null;
	              return THIS_EXPR.callMethod('debug', [
	                  literal(newState.nodeIndex),
	                  isPresent(sourceLocation) ? literal(sourceLocation.line) : NULL_EXPR,
	                  isPresent(sourceLocation) ? literal(sourceLocation.col) : NULL_EXPR
	              ]);
	          }
	          else {
	              return null;
	          }
	      };
	      CompileMethod.prototype.resetDebugInfoExpr = function (nodeIndex, templateAst) {
	          var res = this._updateDebugContext(new _DebugState(nodeIndex, templateAst));
	          return res || NULL_EXPR;
	      };
	      CompileMethod.prototype.resetDebugInfo = function (nodeIndex, templateAst) {
	          this._newState = new _DebugState(nodeIndex, templateAst);
	      };
	      CompileMethod.prototype.push = function () {
	          var stmts = [];
	          for (var _i = 0; _i < arguments.length; _i++) {
	              stmts[_i - 0] = arguments[_i];
	          }
	          this.addStmts(stmts);
	      };
	      CompileMethod.prototype.addStmt = function (stmt) {
	          this._updateDebugContextIfNeeded();
	          this._bodyStatements.push(stmt);
	      };
	      CompileMethod.prototype.addStmts = function (stmts) {
	          this._updateDebugContextIfNeeded();
	          (_a = this._bodyStatements).push.apply(_a, stmts);
	          var _a;
	      };
	      CompileMethod.prototype.finish = function () { return this._bodyStatements; };
	      CompileMethod.prototype.isEmpty = function () { return this._bodyStatements.length === 0; };
	      return CompileMethod;
	  }());

	  /**
	   * @license
	   * Copyright Google Inc. All Rights Reserved.
	   *
	   * Use of this source code is governed by an MIT-style license that can be
	   * found in the LICENSE file at https://angular.io/license
	   */
	  var __extends$16 = (this && this.__extends) || function (d, b) {
	      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	      function __() { this.constructor = d; }
	      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	  };
	  function getPropertyInView(property, callingView, definedView) {
	      if (callingView === definedView) {
	          return property;
	      }
	      else {
	          var viewProp = THIS_EXPR;
	          var currView = callingView;
	          while (currView !== definedView && isPresent(currView.declarationElement.view)) {
	              currView = currView.declarationElement.view;
	              viewProp = viewProp.prop('parent');
	          }
	          if (currView !== definedView) {
	              throw new Error("Internal error: Could not calculate a property in a parent view: " + property);
	          }
	          return property.visitExpression(new _ReplaceViewTransformer(viewProp, definedView), null);
	      }
	  }
	  var _ReplaceViewTransformer = (function (_super) {
	      __extends$16(_ReplaceViewTransformer, _super);
	      function _ReplaceViewTransformer(_viewExpr, _view) {
	          _super.call(this);
	          this._viewExpr = _viewExpr;
	          this._view = _view;
	      }
	      _ReplaceViewTransformer.prototype._isThis = function (expr) {
	          return expr instanceof ReadVarExpr && expr.builtin === BuiltinVar.This;
	      };
	      _ReplaceViewTransformer.prototype.visitReadVarExpr = function (ast, context) {
	          return this._isThis(ast) ? this._viewExpr : ast;
	      };
	      _ReplaceViewTransformer.prototype.visitReadPropExpr = function (ast, context) {
	          if (this._isThis(ast.receiver)) {
	              // Note: Don't cast for members of the AppView base class...
	              if (this._view.fields.some(function (field) { return field.name == ast.name; }) ||
	                  this._view.getters.some(function (field) { return field.name == ast.name; })) {
	                  return this._viewExpr.cast(this._view.classType).prop(ast.name);
	              }
	          }
	          return _super.prototype.visitReadPropExpr.call(this, ast, context);
	      };
	      return _ReplaceViewTransformer;
	  }(ExpressionTransformer));
	  function injectFromViewParentInjector(token, optional) {
	      var args = [createDiTokenExpression(token)];
	      if (optional) {
	          args.push(NULL_EXPR);
	      }
	      return THIS_EXPR.prop('parentInjector').callMethod('get', args);
	  }
	  function getViewFactoryName(component, embeddedTemplateIndex) {
	      return "viewFactory_" + component.type.name + embeddedTemplateIndex;
	  }
	  function createFlatArray(expressions) {
	      var lastNonArrayExpressions = [];
	      var result = literalArr([]);
	      for (var i = 0; i < expressions.length; i++) {
	          var expr = expressions[i];
	          if (expr.type instanceof ArrayType) {
	              if (lastNonArrayExpressions.length > 0) {
	                  result =
	                      result.callMethod(BuiltinMethod.ConcatArray, [literalArr(lastNonArrayExpressions)]);
	                  lastNonArrayExpressions = [];
	              }
	              result = result.callMethod(BuiltinMethod.ConcatArray, [expr]);
	          }
	          else {
	              lastNonArrayExpressions.push(expr);
	          }
	      }
	      if (lastNonArrayExpressions.length > 0) {
	          result =
	              result.callMethod(BuiltinMethod.ConcatArray, [literalArr(lastNonArrayExpressions)]);
	      }
	      return result;
	  }

	  var ViewQueryValues = (function () {
	      function ViewQueryValues(view, values) {
	          this.view = view;
	          this.values = values;
	      }
	      return ViewQueryValues;
	  }());
	  var CompileQuery = (function () {
	      function CompileQuery(meta, queryList, ownerDirectiveExpression, view) {
	          this.meta = meta;
	          this.queryList = queryList;
	          this.ownerDirectiveExpression = ownerDirectiveExpression;
	          this.view = view;
	          this._values = new ViewQueryValues(view, []);
	      }
	      CompileQuery.prototype.addValue = function (value, view) {
	          var currentView = view;
	          var elPath = [];
	          while (isPresent(currentView) && currentView !== this.view) {
	              var parentEl = currentView.declarationElement;
	              elPath.unshift(parentEl);
	              currentView = parentEl.view;
	          }
	          var queryListForDirtyExpr = getPropertyInView(this.queryList, view, this.view);
	          var viewValues = this._values;
	          elPath.forEach(function (el) {
	              var last = viewValues.values.length > 0 ? viewValues.values[viewValues.values.length - 1] : null;
	              if (last instanceof ViewQueryValues && last.view === el.embeddedView) {
	                  viewValues = last;
	              }
	              else {
	                  var newViewValues = new ViewQueryValues(el.embeddedView, []);
	                  viewValues.values.push(newViewValues);
	                  viewValues = newViewValues;
	              }
	          });
	          viewValues.values.push(value);
	          if (elPath.length > 0) {
	              view.dirtyParentQueriesMethod.addStmt(queryListForDirtyExpr.callMethod('setDirty', []).toStmt());
	          }
	      };
	      CompileQuery.prototype._isStatic = function () {
	          return !this._values.values.some(function (value) { return value instanceof ViewQueryValues; });
	      };
	      CompileQuery.prototype.afterChildren = function (targetStaticMethod, targetDynamicMethod) {
	          var values = createQueryValues(this._values);
	          var updateStmts = [this.queryList.callMethod('reset', [literalArr(values)]).toStmt()];
	          if (isPresent(this.ownerDirectiveExpression)) {
	              var valueExpr = this.meta.first ? this.queryList.prop('first') : this.queryList;
	              updateStmts.push(this.ownerDirectiveExpression.prop(this.meta.propertyName).set(valueExpr).toStmt());
	          }
	          if (!this.meta.first) {
	              updateStmts.push(this.queryList.callMethod('notifyOnChanges', []).toStmt());
	          }
	          if (this.meta.first && this._isStatic()) {
	              // for queries that don't change and the user asked for a single element,
	              // set it immediately. That is e.g. needed for querying for ViewContainerRefs, ...
	              // we don't do this for QueryLists for now as this would break the timing when
	              // we call QueryList listeners...
	              targetStaticMethod.addStmts(updateStmts);
	          }
	          else {
	              targetDynamicMethod.addStmt(new IfStmt(this.queryList.prop('dirty'), updateStmts));
	          }
	      };
	      return CompileQuery;
	  }());
	  function createQueryValues(viewValues) {
	      return ListWrapper.flatten(viewValues.values.map(function (entry) {
	          if (entry instanceof ViewQueryValues) {
	              return mapNestedViews(entry.view.declarationElement.appElement, entry.view, createQueryValues(entry));
	          }
	          else {
	              return entry;
	          }
	      }));
	  }
	  function mapNestedViews(declarationAppElement, view, expressions) {
	      var adjustedExpressions = expressions.map(function (expr) { return replaceVarInExpression(THIS_EXPR.name, variable('nestedView'), expr); });
	      return declarationAppElement.callMethod('mapNestedViews', [
	          variable(view.className),
	          fn([new FnParam('nestedView', view.classType)], [new ReturnStatement(literalArr(adjustedExpressions))], DYNAMIC_TYPE)
	      ]);
	  }
	  function createQueryList(query, directiveInstance, propertyName, compileView) {
	      compileView.fields.push(new ClassField(propertyName, importType(resolveIdentifier(Identifiers.QueryList), [DYNAMIC_TYPE])));
	      var expr = THIS_EXPR.prop(propertyName);
	      compileView.createMethod.addStmt(THIS_EXPR.prop(propertyName)
	          .set(importExpr(resolveIdentifier(Identifiers.QueryList), [DYNAMIC_TYPE])
	          .instantiate([]))
	          .toStmt());
	      return expr;
	  }
	  function addQueryToTokenMap(map, query) {
	      query.meta.selectors.forEach(function (selector) {
	          var entry = map.get(selector.reference);
	          if (!entry) {
	              entry = [];
	              map.set(selector.reference, entry);
	          }
	          entry.push(query);
	      });
	  }

	  var ViewTypeEnum = (function () {
	      function ViewTypeEnum() {
	      }
	      ViewTypeEnum.fromValue = function (value) {
	          return createEnumExpression(Identifiers.ViewType, value);
	      };
	      return ViewTypeEnum;
	  }());
	  var ViewEncapsulationEnum = (function () {
	      function ViewEncapsulationEnum() {
	      }
	      ViewEncapsulationEnum.fromValue = function (value) {
	          return createEnumExpression(Identifiers.ViewEncapsulation, value);
	      };
	      return ViewEncapsulationEnum;
	  }());
	  var ChangeDetectorStatusEnum = (function () {
	      function ChangeDetectorStatusEnum() {
	      }
	      ChangeDetectorStatusEnum.fromValue = function (value) {
	          return createEnumExpression(Identifiers.ChangeDetectorStatus, value);
	      };
	      return ChangeDetectorStatusEnum;
	  }());
	  var ViewConstructorVars = (function () {
	      function ViewConstructorVars() {
	      }
	      ViewConstructorVars.viewUtils = variable('viewUtils');
	      ViewConstructorVars.parentInjector = variable('parentInjector');
	      ViewConstructorVars.declarationEl = variable('declarationEl');
	      return ViewConstructorVars;
	  }());
	  var ViewProperties = (function () {
	      function ViewProperties() {
	      }
	      ViewProperties.renderer = THIS_EXPR.prop('renderer');
	      ViewProperties.projectableNodes = THIS_EXPR.prop('projectableNodes');
	      ViewProperties.viewUtils = THIS_EXPR.prop('viewUtils');
	      return ViewProperties;
	  }());
	  var InjectMethodVars = (function () {
	      function InjectMethodVars() {
	      }
	      InjectMethodVars.token = variable('token');
	      InjectMethodVars.requestNodeIndex = variable('requestNodeIndex');
	      InjectMethodVars.notFoundResult = variable('notFoundResult');
	      return InjectMethodVars;
	  }());
	  var DetectChangesVars = (function () {
	      function DetectChangesVars() {
	      }
	      DetectChangesVars.throwOnChange = variable("throwOnChange");
	      DetectChangesVars.changes = variable("changes");
	      DetectChangesVars.changed = variable("changed");
	      return DetectChangesVars;
	  }());

	  /**
	   * @license
	   * Copyright Google Inc. All Rights Reserved.
	   *
	   * Use of this source code is governed by an MIT-style license that can be
	   * found in the LICENSE file at https://angular.io/license
	   */
	  var ViewFactoryDependency = (function () {
	      function ViewFactoryDependency(comp, placeholder) {
	          this.comp = comp;
	          this.placeholder = placeholder;
	      }
	      return ViewFactoryDependency;
	  }());
	  var ComponentFactoryDependency = (function () {
	      function ComponentFactoryDependency(comp, placeholder) {
	          this.comp = comp;
	          this.placeholder = placeholder;
	      }
	      return ComponentFactoryDependency;
	  }());
	  var DirectiveWrapperDependency = (function () {
	      function DirectiveWrapperDependency(dir, placeholder) {
	          this.dir = dir;
	          this.placeholder = placeholder;
	      }
	      return DirectiveWrapperDependency;
	  }());

	  /**
	   * @license
	   * Copyright Google Inc. All Rights Reserved.
	   *
	   * Use of this source code is governed by an MIT-style license that can be
	   * found in the LICENSE file at https://angular.io/license
	   */
	  var __extends$15 = (this && this.__extends) || function (d, b) {
	      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	      function __() { this.constructor = d; }
	      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	  };
	  var CompileNode = (function () {
	      function CompileNode(parent, view, nodeIndex, renderNode, sourceAst) {
	          this.parent = parent;
	          this.view = view;
	          this.nodeIndex = nodeIndex;
	          this.renderNode = renderNode;
	          this.sourceAst = sourceAst;
	      }
	      CompileNode.prototype.isNull = function () { return !this.renderNode; };
	      CompileNode.prototype.isRootElement = function () { return this.view != this.parent.view; };
	      return CompileNode;
	  }());
	  var CompileElement = (function (_super) {
	      __extends$15(CompileElement, _super);
	      function CompileElement(parent, view, nodeIndex, renderNode, sourceAst, component, _directives, _resolvedProvidersArray, hasViewContainer, hasEmbeddedView, references, _targetDependencies) {
	          var _this = this;
	          _super.call(this, parent, view, nodeIndex, renderNode, sourceAst);
	          this.component = component;
	          this._directives = _directives;
	          this._resolvedProvidersArray = _resolvedProvidersArray;
	          this.hasViewContainer = hasViewContainer;
	          this.hasEmbeddedView = hasEmbeddedView;
	          this._targetDependencies = _targetDependencies;
	          this._compViewExpr = null;
	          this.instances = new Map();
	          this.directiveWrapperInstance = new Map();
	          this._queryCount = 0;
	          this._queries = new Map();
	          this._componentConstructorViewQueryLists = [];
	          this.contentNodesByNgContentIndex = null;
	          this.referenceTokens = {};
	          references.forEach(function (ref) { return _this.referenceTokens[ref.name] = ref.value; });
	          this.elementRef =
	              importExpr(resolveIdentifier(Identifiers.ElementRef)).instantiate([this.renderNode]);
	          this.instances.set(resolveIdentifierToken(Identifiers.ElementRef).reference, this.elementRef);
	          this.injector = THIS_EXPR.callMethod('injector', [literal(this.nodeIndex)]);
	          this.instances.set(resolveIdentifierToken(Identifiers.Injector).reference, this.injector);
	          this.instances.set(resolveIdentifierToken(Identifiers.Renderer).reference, THIS_EXPR.prop('renderer'));
	          if (this.hasViewContainer || this.hasEmbeddedView || isPresent(this.component)) {
	              this._createAppElement();
	          }
	          if (this.component) {
	              this._createComponentFactoryResolver();
	          }
	      }
	      CompileElement.createNull = function () {
	          return new CompileElement(null, null, null, null, null, null, [], [], false, false, [], []);
	      };
	      CompileElement.prototype._createAppElement = function () {
	          var fieldName = "_appEl_" + this.nodeIndex;
	          var parentNodeIndex = this.isRootElement() ? null : this.parent.nodeIndex;
	          // private is fine here as no child view will reference an AppElement
	          this.view.fields.push(new ClassField(fieldName, importType(resolveIdentifier(Identifiers.AppElement)), [StmtModifier.Private]));
	          var statement = THIS_EXPR.prop(fieldName)
	              .set(importExpr(resolveIdentifier(Identifiers.AppElement)).instantiate([
	              literal(this.nodeIndex), literal(parentNodeIndex), THIS_EXPR, this.renderNode
	          ]))
	              .toStmt();
	          this.view.createMethod.addStmt(statement);
	          this.appElement = THIS_EXPR.prop(fieldName);
	          this.instances.set(resolveIdentifierToken(Identifiers.AppElement).reference, this.appElement);
	      };
	      CompileElement.prototype._createComponentFactoryResolver = function () {
	          var _this = this;
	          var entryComponents = this.component.entryComponents.map(function (entryComponent) {
	              var id = new CompileIdentifierMetadata({ name: entryComponent.name });
	              _this._targetDependencies.push(new ComponentFactoryDependency(entryComponent, id));
	              return id;
	          });
	          if (!entryComponents || entryComponents.length === 0) {
	              return;
	          }
	          var createComponentFactoryResolverExpr = importExpr(resolveIdentifier(Identifiers.CodegenComponentFactoryResolver)).instantiate([
	              literalArr(entryComponents.map(function (entryComponent) { return importExpr(entryComponent); })),
	              injectFromViewParentInjector(resolveIdentifierToken(Identifiers.ComponentFactoryResolver), false)
	          ]);
	          var provider = new CompileProviderMetadata({
	              token: resolveIdentifierToken(Identifiers.ComponentFactoryResolver),
	              useValue: createComponentFactoryResolverExpr
	          });
	          // Add ComponentFactoryResolver as first provider as it does not have deps on other providers
	          // ProviderAstType.PrivateService as only the component and its view can see it,
	          // but nobody else
	          this._resolvedProvidersArray.unshift(new ProviderAst(provider.token, false, true, [provider], exports.ProviderAstType.PrivateService, [], this.sourceAst.sourceSpan));
	      };
	      CompileElement.prototype.setComponentView = function (compViewExpr) {
	          this._compViewExpr = compViewExpr;
	          this.contentNodesByNgContentIndex =
	              new Array(this.component.template.ngContentSelectors.length);
	          for (var i = 0; i < this.contentNodesByNgContentIndex.length; i++) {
	              this.contentNodesByNgContentIndex[i] = [];
	          }
	      };
	      CompileElement.prototype.setEmbeddedView = function (embeddedView) {
	          this.embeddedView = embeddedView;
	          if (isPresent(embeddedView)) {
	              var createTemplateRefExpr = importExpr(resolveIdentifier(Identifiers.TemplateRef_)).instantiate([
	                  this.appElement, this.embeddedView.viewFactory
	              ]);
	              var provider = new CompileProviderMetadata({
	                  token: resolveIdentifierToken(Identifiers.TemplateRef),
	                  useValue: createTemplateRefExpr
	              });
	              // Add TemplateRef as first provider as it does not have deps on other providers
	              this._resolvedProvidersArray.unshift(new ProviderAst(provider.token, false, true, [provider], exports.ProviderAstType.Builtin, [], this.sourceAst.sourceSpan));
	          }
	      };
	      CompileElement.prototype.beforeChildren = function () {
	          var _this = this;
	          if (this.hasViewContainer) {
	              this.instances.set(resolveIdentifierToken(Identifiers.ViewContainerRef).reference, this.appElement.prop('vcRef'));
	          }
	          this._resolvedProviders = new Map();
	          this._resolvedProvidersArray.forEach(function (provider) { return _this._resolvedProviders.set(provider.token.reference, provider); });
	          // create all the provider instances, some in the view constructor,
	          // some as getters. We rely on the fact that they are already sorted topologically.
	          MapWrapper.values(this._resolvedProviders).forEach(function (resolvedProvider) {
	              var isDirectiveWrapper = resolvedProvider.providerType === exports.ProviderAstType.Component ||
	                  resolvedProvider.providerType === exports.ProviderAstType.Directive;
	              var providerValueExpressions = resolvedProvider.providers.map(function (provider) {
	                  if (isPresent(provider.useExisting)) {
	                      return _this._getDependency(resolvedProvider.providerType, new CompileDiDependencyMetadata({ token: provider.useExisting }));
	                  }
	                  else if (isPresent(provider.useFactory)) {
	                      var deps = provider.deps || provider.useFactory.diDeps;
	                      var depsExpr = deps.map(function (dep) { return _this._getDependency(resolvedProvider.providerType, dep); });
	                      return importExpr(provider.useFactory).callFn(depsExpr);
	                  }
	                  else if (isPresent(provider.useClass)) {
	                      var deps = provider.deps || provider.useClass.diDeps;
	                      var depsExpr = deps.map(function (dep) { return _this._getDependency(resolvedProvider.providerType, dep); });
	                      if (isDirectiveWrapper) {
	                          var directiveWrapperIdentifier = new CompileIdentifierMetadata({ name: DirectiveWrapperCompiler.dirWrapperClassName(provider.useClass) });
	                          _this._targetDependencies.push(new DirectiveWrapperDependency(provider.useClass, directiveWrapperIdentifier));
	                          return importExpr(directiveWrapperIdentifier)
	                              .instantiate(depsExpr, importType(directiveWrapperIdentifier));
	                      }
	                      else {
	                          return importExpr(provider.useClass)
	                              .instantiate(depsExpr, importType(provider.useClass));
	                      }
	                  }
	                  else {
	                      return convertValueToOutputAst(provider.useValue);
	                  }
	              });
	              var propName = "_" + resolvedProvider.token.name + "_" + _this.nodeIndex + "_" + _this.instances.size;
	              var instance = createProviderProperty(propName, resolvedProvider, providerValueExpressions, resolvedProvider.multiProvider, resolvedProvider.eager, _this);
	              if (isDirectiveWrapper) {
	                  _this.directiveWrapperInstance.set(resolvedProvider.token.reference, instance);
	                  _this.instances.set(resolvedProvider.token.reference, instance.prop('context'));
	              }
	              else {
	                  _this.instances.set(resolvedProvider.token.reference, instance);
	              }
	          });
	          for (var i = 0; i < this._directives.length; i++) {
	              var directive = this._directives[i];
	              var directiveInstance = this.instances.get(identifierToken(directive.type).reference);
	              directive.queries.forEach(function (queryMeta) { _this._addQuery(queryMeta, directiveInstance); });
	          }
	          var queriesWithReads = [];
	          MapWrapper.values(this._resolvedProviders).forEach(function (resolvedProvider) {
	              var queriesForProvider = _this._getQueriesFor(resolvedProvider.token);
	              queriesWithReads.push.apply(queriesWithReads, queriesForProvider.map(function (query) { return new _QueryWithRead(query, resolvedProvider.token); }));
	          });
	          Object.keys(this.referenceTokens).forEach(function (varName) {
	              var token = _this.referenceTokens[varName];
	              var varValue;
	              if (isPresent(token)) {
	                  varValue = _this.instances.get(token.reference);
	              }
	              else {
	                  varValue = _this.renderNode;
	              }
	              _this.view.locals.set(varName, varValue);
	              var varToken = new CompileTokenMetadata({ value: varName });
	              queriesWithReads.push.apply(queriesWithReads, _this._getQueriesFor(varToken).map(function (query) { return new _QueryWithRead(query, varToken); }));
	          });
	          queriesWithReads.forEach(function (queryWithRead) {
	              var value;
	              if (isPresent(queryWithRead.read.identifier)) {
	                  // query for an identifier
	                  value = _this.instances.get(queryWithRead.read.reference);
	              }
	              else {
	                  // query for a reference
	                  var token = _this.referenceTokens[queryWithRead.read.value];
	                  if (isPresent(token)) {
	                      value = _this.instances.get(token.reference);
	                  }
	                  else {
	                      value = _this.elementRef;
	                  }
	              }
	              if (isPresent(value)) {
	                  queryWithRead.query.addValue(value, _this.view);
	              }
	          });
	          if (isPresent(this.component)) {
	              var componentConstructorViewQueryList = isPresent(this.component) ?
	                  literalArr(this._componentConstructorViewQueryLists) :
	                  NULL_EXPR;
	              var compExpr = isPresent(this.getComponent()) ? this.getComponent() : NULL_EXPR;
	              this.view.createMethod.addStmt(this.appElement
	                  .callMethod('initComponent', [compExpr, componentConstructorViewQueryList, this._compViewExpr])
	                  .toStmt());
	          }
	      };
	      CompileElement.prototype.afterChildren = function (childNodeCount) {
	          var _this = this;
	          MapWrapper.values(this._resolvedProviders).forEach(function (resolvedProvider) {
	              // Note: afterChildren is called after recursing into children.
	              // This is good so that an injector match in an element that is closer to a requesting element
	              // matches first.
	              var providerExpr = _this.instances.get(resolvedProvider.token.reference);
	              // Note: view providers are only visible on the injector of that element.
	              // This is not fully correct as the rules during codegen don't allow a directive
	              // to get hold of a view provdier on the same element. We still do this semantic
	              // as it simplifies our model to having only one runtime injector per element.
	              var providerChildNodeCount = resolvedProvider.providerType === exports.ProviderAstType.PrivateService ? 0 : childNodeCount;
	              _this.view.injectorGetMethod.addStmt(createInjectInternalCondition(_this.nodeIndex, providerChildNodeCount, resolvedProvider, providerExpr));
	          });
	          MapWrapper.values(this._queries)
	              .forEach(function (queries) { return queries.forEach(function (query) { return query.afterChildren(_this.view.createMethod, _this.view.updateContentQueriesMethod); }); });
	      };
	      CompileElement.prototype.addContentNode = function (ngContentIndex, nodeExpr) {
	          this.contentNodesByNgContentIndex[ngContentIndex].push(nodeExpr);
	      };
	      CompileElement.prototype.getComponent = function () {
	          return isPresent(this.component) ?
	              this.instances.get(identifierToken(this.component.type).reference) :
	              null;
	      };
	      CompileElement.prototype.getProviderTokens = function () {
	          return MapWrapper.values(this._resolvedProviders)
	              .map(function (resolvedProvider) { return createDiTokenExpression(resolvedProvider.token); });
	      };
	      CompileElement.prototype._getQueriesFor = function (token) {
	          var result = [];
	          var currentEl = this;
	          var distance = 0;
	          var queries;
	          while (!currentEl.isNull()) {
	              queries = currentEl._queries.get(token.reference);
	              if (isPresent(queries)) {
	                  result.push.apply(result, queries.filter(function (query) { return query.meta.descendants || distance <= 1; }));
	              }
	              if (currentEl._directives.length > 0) {
	                  distance++;
	              }
	              currentEl = currentEl.parent;
	          }
	          queries = this.view.componentView.viewQueries.get(token.reference);
	          if (isPresent(queries)) {
	              result.push.apply(result, queries);
	          }
	          return result;
	      };
	      CompileElement.prototype._addQuery = function (queryMeta, directiveInstance) {
	          var propName = "_query_" + queryMeta.selectors[0].name + "_" + this.nodeIndex + "_" + this._queryCount++;
	          var queryList = createQueryList(queryMeta, directiveInstance, propName, this.view);
	          var query = new CompileQuery(queryMeta, queryList, directiveInstance, this.view);
	          addQueryToTokenMap(this._queries, query);
	          return query;
	      };
	      CompileElement.prototype._getLocalDependency = function (requestingProviderType, dep) {
	          var result = null;
	          // constructor content query
	          if (!result && isPresent(dep.query)) {
	              result = this._addQuery(dep.query, null).queryList;
	          }
	          // constructor view query
	          if (!result && isPresent(dep.viewQuery)) {
	              result = createQueryList(dep.viewQuery, null, "_viewQuery_" + dep.viewQuery.selectors[0].name + "_" + this.nodeIndex + "_" + this._componentConstructorViewQueryLists.length, this.view);
	              this._componentConstructorViewQueryLists.push(result);
	          }
	          if (isPresent(dep.token)) {
	              // access builtins with special visibility
	              if (!result) {
	                  if (dep.token.reference ===
	                      resolveIdentifierToken(Identifiers.ChangeDetectorRef).reference) {
	                      if (requestingProviderType === exports.ProviderAstType.Component) {
	                          return this._compViewExpr.prop('ref');
	                      }
	                      else {
	                          return getPropertyInView(THIS_EXPR.prop('ref'), this.view, this.view.componentView);
	                      }
	                  }
	              }
	              // access regular providers on the element
	              if (!result) {
	                  var resolvedProvider = this._resolvedProviders.get(dep.token.reference);
	                  // don't allow directives / public services to access private services.
	                  // only components and private services can access private services.
	                  if (resolvedProvider && (requestingProviderType === exports.ProviderAstType.Directive ||
	                      requestingProviderType === exports.ProviderAstType.PublicService) &&
	                      resolvedProvider.providerType === exports.ProviderAstType.PrivateService) {
	                      return null;
	                  }
	                  result = this.instances.get(dep.token.reference);
	              }
	          }
	          return result;
	      };
	      CompileElement.prototype._getDependency = function (requestingProviderType, dep) {
	          var currElement = this;
	          var result = null;
	          if (dep.isValue) {
	              result = literal(dep.value);
	          }
	          if (!result && !dep.isSkipSelf) {
	              result = this._getLocalDependency(requestingProviderType, dep);
	          }
	          // check parent elements
	          while (!result && !currElement.parent.isNull()) {
	              currElement = currElement.parent;
	              result = currElement._getLocalDependency(exports.ProviderAstType.PublicService, new CompileDiDependencyMetadata({ token: dep.token }));
	          }
	          if (!result) {
	              result = injectFromViewParentInjector(dep.token, dep.isOptional);
	          }
	          if (!result) {
	              result = NULL_EXPR;
	          }
	          return getPropertyInView(result, this.view, currElement.view);
	      };
	      return CompileElement;
	  }(CompileNode));
	  function createInjectInternalCondition(nodeIndex, childNodeCount, provider, providerExpr) {
	      var indexCondition;
	      if (childNodeCount > 0) {
	          indexCondition = literal(nodeIndex)
	              .lowerEquals(InjectMethodVars.requestNodeIndex)
	              .and(InjectMethodVars.requestNodeIndex.lowerEquals(literal(nodeIndex + childNodeCount)));
	      }
	      else {
	          indexCondition = literal(nodeIndex).identical(InjectMethodVars.requestNodeIndex);
	      }
	      return new IfStmt(InjectMethodVars.token.identical(createDiTokenExpression(provider.token)).and(indexCondition), [new ReturnStatement(providerExpr)]);
	  }
	  function createProviderProperty(propName, provider, providerValueExpressions, isMulti, isEager, compileElement) {
	      var view = compileElement.view;
	      var resolvedProviderValueExpr;
	      var type;
	      if (isMulti) {
	          resolvedProviderValueExpr = literalArr(providerValueExpressions);
	          type = new ArrayType(DYNAMIC_TYPE);
	      }
	      else {
	          resolvedProviderValueExpr = providerValueExpressions[0];
	          type = providerValueExpressions[0].type;
	      }
	      if (!type) {
	          type = DYNAMIC_TYPE;
	      }
	      if (isEager) {
	          view.fields.push(new ClassField(propName, type));
	          view.createMethod.addStmt(THIS_EXPR.prop(propName).set(resolvedProviderValueExpr).toStmt());
	      }
	      else {
	          var internalField = "_" + propName;
	          view.fields.push(new ClassField(internalField, type));
	          var getter = new CompileMethod(view);
	          getter.resetDebugInfo(compileElement.nodeIndex, compileElement.sourceAst);
	          // Note: Equals is important for JS so that it also checks the undefined case!
	          getter.addStmt(new IfStmt(THIS_EXPR.prop(internalField).isBlank(), [THIS_EXPR.prop(internalField).set(resolvedProviderValueExpr).toStmt()]));
	          getter.addStmt(new ReturnStatement(THIS_EXPR.prop(internalField)));
	          view.getters.push(new ClassGetter(propName, getter.finish(), type));
	      }
	      return THIS_EXPR.prop(propName);
	  }
	  var _QueryWithRead = (function () {
	      function _QueryWithRead(query, match) {
	          this.query = query;
	          this.read = query.meta.read || match;
	      }
	      return _QueryWithRead;
	  }());

	  var CompilePipe = (function () {
	      function CompilePipe(view, meta) {
	          var _this = this;
	          this.view = view;
	          this.meta = meta;
	          this._purePipeProxyCount = 0;
	          this.instance = THIS_EXPR.prop("_pipe_" + meta.name + "_" + view.pipeCount++);
	          var deps = this.meta.type.diDeps.map(function (diDep) {
	              if (diDep.token.reference ===
	                  resolveIdentifierToken(Identifiers.ChangeDetectorRef).reference) {
	                  return getPropertyInView(THIS_EXPR.prop('ref'), _this.view, _this.view.componentView);
	              }
	              return injectFromViewParentInjector(diDep.token, false);
	          });
	          this.view.fields.push(new ClassField(this.instance.name, importType(this.meta.type)));
	          this.view.createMethod.resetDebugInfo(null, null);
	          this.view.createMethod.addStmt(THIS_EXPR.prop(this.instance.name)
	              .set(importExpr(this.meta.type).instantiate(deps))
	              .toStmt());
	      }
	      CompilePipe.call = function (view, name, args) {
	          var compView = view.componentView;
	          var meta = _findPipeMeta(compView, name);
	          var pipe;
	          if (meta.pure) {
	              // pure pipes live on the component view
	              pipe = compView.purePipes.get(name);
	              if (!pipe) {
	                  pipe = new CompilePipe(compView, meta);
	                  compView.purePipes.set(name, pipe);
	                  compView.pipes.push(pipe);
	              }
	          }
	          else {
	              // Non pure pipes live on the view that called it
	              pipe = new CompilePipe(view, meta);
	              view.pipes.push(pipe);
	          }
	          return pipe._call(view, args);
	      };
	      Object.defineProperty(CompilePipe.prototype, "pure", {
	          get: function () { return this.meta.pure; },
	          enumerable: true,
	          configurable: true
	      });
	      CompilePipe.prototype._call = function (callingView, args) {
	          if (this.meta.pure) {
	              // PurePipeProxies live on the view that called them.
	              var purePipeProxyInstance = THIS_EXPR.prop(this.instance.name + "_" + this._purePipeProxyCount++);
	              var pipeInstanceSeenFromPureProxy = getPropertyInView(this.instance, callingView, this.view);
	              createPureProxy(pipeInstanceSeenFromPureProxy.prop('transform')
	                  .callMethod(BuiltinMethod.Bind, [pipeInstanceSeenFromPureProxy]), args.length, purePipeProxyInstance, { fields: callingView.fields, ctorStmts: callingView.createMethod });
	              return importExpr(resolveIdentifier(Identifiers.castByValue))
	                  .callFn([purePipeProxyInstance, pipeInstanceSeenFromPureProxy.prop('transform')])
	                  .callFn(args);
	          }
	          else {
	              return getPropertyInView(this.instance, callingView, this.view).callMethod('transform', args);
	          }
	      };
	      return CompilePipe;
	  }());
	  function _findPipeMeta(view, name) {
	      var pipeMeta = null;
	      for (var i = view.pipeMetas.length - 1; i >= 0; i--) {
	          var localPipeMeta = view.pipeMetas[i];
	          if (localPipeMeta.name == name) {
	              pipeMeta = localPipeMeta;
	              break;
	          }
	      }
	      if (!pipeMeta) {
	          throw new Error("Illegal state: Could not find pipe " + name + " although the parser should have detected this error!");
	      }
	      return pipeMeta;
	  }

	  var CompileView = (function () {
	      function CompileView(component, genConfig, pipeMetas, styles, animations, viewIndex, declarationElement, templateVariableBindings) {
	          var _this = this;
	          this.component = component;
	          this.genConfig = genConfig;
	          this.pipeMetas = pipeMetas;
	          this.styles = styles;
	          this.animations = animations;
	          this.viewIndex = viewIndex;
	          this.declarationElement = declarationElement;
	          this.templateVariableBindings = templateVariableBindings;
	          this.nodes = [];
	          // root nodes or AppElements for ViewContainers
	          this.rootNodesOrAppElements = [];
	          this.methods = [];
	          this.ctorStmts = [];
	          this.fields = [];
	          this.getters = [];
	          this.disposables = [];
	          this.subscriptions = [];
	          this.purePipes = new Map();
	          this.pipes = [];
	          this.locals = new Map();
	          this.literalArrayCount = 0;
	          this.literalMapCount = 0;
	          this.pipeCount = 0;
	          this.createMethod = new CompileMethod(this);
	          this.animationBindingsMethod = new CompileMethod(this);
	          this.injectorGetMethod = new CompileMethod(this);
	          this.updateContentQueriesMethod = new CompileMethod(this);
	          this.dirtyParentQueriesMethod = new CompileMethod(this);
	          this.updateViewQueriesMethod = new CompileMethod(this);
	          this.detectChangesInInputsMethod = new CompileMethod(this);
	          this.detectChangesRenderPropertiesMethod = new CompileMethod(this);
	          this.afterContentLifecycleCallbacksMethod = new CompileMethod(this);
	          this.afterViewLifecycleCallbacksMethod = new CompileMethod(this);
	          this.destroyMethod = new CompileMethod(this);
	          this.detachMethod = new CompileMethod(this);
	          this.viewType = getViewType(component, viewIndex);
	          this.className = "_View_" + component.type.name + viewIndex;
	          this.classType = importType(new CompileIdentifierMetadata({ name: this.className }));
	          this.viewFactory = variable(getViewFactoryName(component, viewIndex));
	          if (this.viewType === ViewType.COMPONENT || this.viewType === ViewType.HOST) {
	              this.componentView = this;
	          }
	          else {
	              this.componentView = this.declarationElement.view.componentView;
	          }
	          this.componentContext =
	              getPropertyInView(THIS_EXPR.prop('context'), this, this.componentView);
	          var viewQueries = new Map();
	          if (this.viewType === ViewType.COMPONENT) {
	              var directiveInstance = THIS_EXPR.prop('context');
	              this.component.viewQueries.forEach(function (queryMeta, queryIndex) {
	                  var propName = "_viewQuery_" + queryMeta.selectors[0].name + "_" + queryIndex;
	                  var queryList = createQueryList(queryMeta, directiveInstance, propName, _this);
	                  var query = new CompileQuery(queryMeta, queryList, directiveInstance, _this);
	                  addQueryToTokenMap(viewQueries, query);
	              });
	              var constructorViewQueryCount = 0;
	              this.component.type.diDeps.forEach(function (dep) {
	                  if (isPresent(dep.viewQuery)) {
	                      var queryList = THIS_EXPR.prop('declarationAppElement')
	                          .prop('componentConstructorViewQueries')
	                          .key(literal(constructorViewQueryCount++));
	                      var query = new CompileQuery(dep.viewQuery, queryList, null, _this);
	                      addQueryToTokenMap(viewQueries, query);
	                  }
	              });
	          }
	          this.viewQueries = viewQueries;
	          templateVariableBindings.forEach(function (entry) { _this.locals.set(entry[1], THIS_EXPR.prop('context').prop(entry[0])); });
	          if (!this.declarationElement.isNull()) {
	              this.declarationElement.setEmbeddedView(this);
	          }
	      }
	      CompileView.prototype.callPipe = function (name, input, args) {
	          return CompilePipe.call(this, name, [input].concat(args));
	      };
	      CompileView.prototype.getLocal = function (name) {
	          if (name == EventHandlerVars.event.name) {
	              return EventHandlerVars.event;
	          }
	          var currView = this;
	          var result = currView.locals.get(name);
	          while (!result && isPresent(currView.declarationElement.view)) {
	              currView = currView.declarationElement.view;
	              result = currView.locals.get(name);
	          }
	          if (isPresent(result)) {
	              return getPropertyInView(result, this, currView);
	          }
	          else {
	              return null;
	          }
	      };
	      CompileView.prototype.afterNodes = function () {
	          var _this = this;
	          MapWrapper.values(this.viewQueries)
	              .forEach(function (queries) { return queries.forEach(function (query) { return query.afterChildren(_this.createMethod, _this.updateViewQueriesMethod); }); });
	      };
	      return CompileView;
	  }());
	  function getViewType(component, embeddedTemplateIndex) {
	      if (embeddedTemplateIndex > 0) {
	          return ViewType.EMBEDDED;
	      }
	      else if (component.type.isHost) {
	          return ViewType.HOST;
	      }
	      else {
	          return ViewType.COMPONENT;
	      }
	  }

	  var CompileEventListener = (function () {
	      function CompileEventListener(compileElement, eventTarget, eventName, eventPhase, listenerIndex) {
	          this.compileElement = compileElement;
	          this.eventTarget = eventTarget;
	          this.eventName = eventName;
	          this.eventPhase = eventPhase;
	          this._hasComponentHostListener = false;
	          this._actionResultExprs = [];
	          this._method = new CompileMethod(compileElement.view);
	          this._methodName =
	              "_handle_" + sanitizeEventName(eventName) + "_" + compileElement.nodeIndex + "_" + listenerIndex;
	          this._eventParam = new FnParam(EventHandlerVars.event.name, importType(this.compileElement.view.genConfig.renderTypes.renderEvent));
	      }
	      CompileEventListener.getOrCreate = function (compileElement, eventTarget, eventName, eventPhase, targetEventListeners) {
	          var listener = targetEventListeners.find(function (listener) { return listener.eventTarget == eventTarget && listener.eventName == eventName &&
	              listener.eventPhase == eventPhase; });
	          if (!listener) {
	              listener = new CompileEventListener(compileElement, eventTarget, eventName, eventPhase, targetEventListeners.length);
	              targetEventListeners.push(listener);
	          }
	          return listener;
	      };
	      Object.defineProperty(CompileEventListener.prototype, "methodName", {
	          get: function () { return this._methodName; },
	          enumerable: true,
	          configurable: true
	      });
	      Object.defineProperty(CompileEventListener.prototype, "isAnimation", {
	          get: function () { return !!this.eventPhase; },
	          enumerable: true,
	          configurable: true
	      });
	      CompileEventListener.prototype.addAction = function (hostEvent, directive, directiveInstance) {
	          if (isPresent(directive) && directive.isComponent) {
	              this._hasComponentHostListener = true;
	          }
	          this._method.resetDebugInfo(this.compileElement.nodeIndex, hostEvent);
	          var context = directiveInstance || this.compileElement.view.componentContext;
	          var view = this.compileElement.view;
	          var evalResult = convertActionBinding(view, directive ? null : view, context, hostEvent.handler, this.compileElement.nodeIndex + "_" + this._actionResultExprs.length);
	          if (evalResult.preventDefault) {
	              this._actionResultExprs.push(evalResult.preventDefault);
	          }
	          this._method.addStmts(evalResult.stmts);
	      };
	      CompileEventListener.prototype.finishMethod = function () {
	          var markPathToRootStart = this._hasComponentHostListener ?
	              this.compileElement.appElement.prop('componentView') :
	              THIS_EXPR;
	          var resultExpr = literal(true);
	          this._actionResultExprs.forEach(function (expr) { resultExpr = resultExpr.and(expr); });
	          var stmts = [markPathToRootStart.callMethod('markPathToRootAsCheckOnce', []).toStmt()]
	              .concat(this._method.finish())
	              .concat([new ReturnStatement(resultExpr)]);
	          // private is fine here as no child view will reference the event handler...
	          this.compileElement.view.methods.push(new ClassMethod(this._methodName, [this._eventParam], stmts, BOOL_TYPE, [StmtModifier.Private]));
	      };
	      CompileEventListener.prototype.listenToRenderer = function () {
	          var listenExpr;
	          var eventListener = THIS_EXPR.callMethod('eventHandler', [THIS_EXPR.prop(this._methodName).callMethod(BuiltinMethod.Bind, [THIS_EXPR])]);
	          if (isPresent(this.eventTarget)) {
	              listenExpr = ViewProperties.renderer.callMethod('listenGlobal', [literal(this.eventTarget), literal(this.eventName), eventListener]);
	          }
	          else {
	              listenExpr = ViewProperties.renderer.callMethod('listen', [this.compileElement.renderNode, literal(this.eventName), eventListener]);
	          }
	          var disposable = variable("disposable_" + this.compileElement.view.disposables.length);
	          this.compileElement.view.disposables.push(disposable);
	          // private is fine here as no child view will reference the event handler...
	          this.compileElement.view.createMethod.addStmt(disposable.set(listenExpr).toDeclStmt(FUNCTION_TYPE, [StmtModifier.Private]));
	      };
	      CompileEventListener.prototype.listenToAnimation = function (animationTransitionVar) {
	          var callbackMethod = this.eventPhase == 'start' ? 'onStart' : 'onDone';
	          return animationTransitionVar
	              .callMethod(callbackMethod, [THIS_EXPR.prop(this.methodName).callMethod(BuiltinMethod.Bind, [THIS_EXPR])])
	              .toStmt();
	      };
	      CompileEventListener.prototype.listenToDirective = function (directiveInstance, observablePropName) {
	          var subscription = variable("subscription_" + this.compileElement.view.subscriptions.length);
	          this.compileElement.view.subscriptions.push(subscription);
	          var eventListener = THIS_EXPR.callMethod('eventHandler', [THIS_EXPR.prop(this._methodName).callMethod(BuiltinMethod.Bind, [THIS_EXPR])]);
	          this.compileElement.view.createMethod.addStmt(subscription
	              .set(directiveInstance.prop(observablePropName)
	              .callMethod(BuiltinMethod.SubscribeObservable, [eventListener]))
	              .toDeclStmt(null, [StmtModifier.Final]));
	      };
	      return CompileEventListener;
	  }());
	  function collectEventListeners(hostEvents, dirs, compileElement) {
	      var eventListeners = [];
	      hostEvents.forEach(function (hostEvent) {
	          var listener = CompileEventListener.getOrCreate(compileElement, hostEvent.target, hostEvent.name, hostEvent.phase, eventListeners);
	          listener.addAction(hostEvent, null, null);
	      });
	      dirs.forEach(function (directiveAst) {
	          var directiveInstance = compileElement.instances.get(identifierToken(directiveAst.directive.type).reference);
	          directiveAst.hostEvents.forEach(function (hostEvent) {
	              var listener = CompileEventListener.getOrCreate(compileElement, hostEvent.target, hostEvent.name, hostEvent.phase, eventListeners);
	              listener.addAction(hostEvent, directiveAst.directive, directiveInstance);
	          });
	      });
	      eventListeners.forEach(function (listener) { return listener.finishMethod(); });
	      return eventListeners;
	  }
	  function bindDirectiveOutputs(directiveAst, directiveInstance, eventListeners) {
	      Object.keys(directiveAst.directive.outputs).forEach(function (observablePropName) {
	          var eventName = directiveAst.directive.outputs[observablePropName];
	          eventListeners.filter(function (listener) { return listener.eventName == eventName; }).forEach(function (listener) {
	              listener.listenToDirective(directiveInstance, observablePropName);
	          });
	      });
	  }
	  function bindRenderOutputs(eventListeners) {
	      eventListeners.forEach(function (listener) {
	          // the animation listeners are handled within property_binder.ts to
	          // allow them to be placed next to the animation factory statements
	          if (!listener.isAnimation) {
	              listener.listenToRenderer();
	          }
	      });
	  }
	  function sanitizeEventName(name) {
	      return name.replace(/[^a-zA-Z_]/g, '_');
	  }

	  var STATE_IS_NEVER_CHECKED = THIS_EXPR.prop('numberOfChecks').identical(new LiteralExpr(0));
	  var NOT_THROW_ON_CHANGES = not(DetectChangesVars.throwOnChange);
	  function bindDirectiveAfterContentLifecycleCallbacks(directiveMeta, directiveInstance, compileElement) {
	      var view = compileElement.view;
	      var lifecycleHooks = directiveMeta.type.lifecycleHooks;
	      var afterContentLifecycleCallbacksMethod = view.afterContentLifecycleCallbacksMethod;
	      afterContentLifecycleCallbacksMethod.resetDebugInfo(compileElement.nodeIndex, compileElement.sourceAst);
	      if (lifecycleHooks.indexOf(LifecycleHooks.AfterContentInit) !== -1) {
	          afterContentLifecycleCallbacksMethod.addStmt(new IfStmt(STATE_IS_NEVER_CHECKED, [directiveInstance.callMethod('ngAfterContentInit', []).toStmt()]));
	      }
	      if (lifecycleHooks.indexOf(LifecycleHooks.AfterContentChecked) !== -1) {
	          afterContentLifecycleCallbacksMethod.addStmt(directiveInstance.callMethod('ngAfterContentChecked', []).toStmt());
	      }
	  }
	  function bindDirectiveAfterViewLifecycleCallbacks(directiveMeta, directiveInstance, compileElement) {
	      var view = compileElement.view;
	      var lifecycleHooks = directiveMeta.type.lifecycleHooks;
	      var afterViewLifecycleCallbacksMethod = view.afterViewLifecycleCallbacksMethod;
	      afterViewLifecycleCallbacksMethod.resetDebugInfo(compileElement.nodeIndex, compileElement.sourceAst);
	      if (lifecycleHooks.indexOf(LifecycleHooks.AfterViewInit) !== -1) {
	          afterViewLifecycleCallbacksMethod.addStmt(new IfStmt(STATE_IS_NEVER_CHECKED, [directiveInstance.callMethod('ngAfterViewInit', []).toStmt()]));
	      }
	      if (lifecycleHooks.indexOf(LifecycleHooks.AfterViewChecked) !== -1) {
	          afterViewLifecycleCallbacksMethod.addStmt(directiveInstance.callMethod('ngAfterViewChecked', []).toStmt());
	      }
	  }
	  function bindInjectableDestroyLifecycleCallbacks(provider, providerInstance, compileElement) {
	      var onDestroyMethod = compileElement.view.destroyMethod;
	      onDestroyMethod.resetDebugInfo(compileElement.nodeIndex, compileElement.sourceAst);
	      if (provider.lifecycleHooks.indexOf(LifecycleHooks.OnDestroy) !== -1) {
	          onDestroyMethod.addStmt(providerInstance.callMethod('ngOnDestroy', []).toStmt());
	      }
	  }
	  function bindPipeDestroyLifecycleCallbacks(pipeMeta, pipeInstance, view) {
	      var onDestroyMethod = view.destroyMethod;
	      if (pipeMeta.type.lifecycleHooks.indexOf(LifecycleHooks.OnDestroy) !== -1) {
	          onDestroyMethod.addStmt(pipeInstance.callMethod('ngOnDestroy', []).toStmt());
	      }
	  }

	  function bindRenderText(boundText, compileNode, view) {
	      var valueField = createCheckBindingField(view);
	      var evalResult = convertPropertyBinding(view, view, view.componentContext, boundText.value, valueField.bindingId);
	      if (!evalResult) {
	          return null;
	      }
	      view.detectChangesRenderPropertiesMethod.resetDebugInfo(compileNode.nodeIndex, boundText);
	      view.detectChangesRenderPropertiesMethod.addStmts(createCheckBindingStmt(evalResult, valueField.expression, DetectChangesVars.throwOnChange, [THIS_EXPR.prop('renderer')
	              .callMethod('setText', [compileNode.renderNode, evalResult.currValExpr])
	              .toStmt()]));
	  }
	  function bindAndWriteToRenderer(boundProps, context, compileElement, isHostProp, eventListeners) {
	      var view = compileElement.view;
	      var renderNode = compileElement.renderNode;
	      boundProps.forEach(function (boundProp) {
	          var bindingField = createCheckBindingField(view);
	          view.detectChangesRenderPropertiesMethod.resetDebugInfo(compileElement.nodeIndex, boundProp);
	          var evalResult = convertPropertyBinding(view, isHostProp ? null : view, context, boundProp.value, bindingField.bindingId);
	          var updateStmts = [];
	          var compileMethod = view.detectChangesRenderPropertiesMethod;
	          switch (boundProp.type) {
	              case exports.PropertyBindingType.Property:
	              case exports.PropertyBindingType.Attribute:
	              case exports.PropertyBindingType.Class:
	              case exports.PropertyBindingType.Style:
	                  updateStmts.push.apply(updateStmts, writeToRenderer(THIS_EXPR, boundProp, renderNode, evalResult.currValExpr, view.genConfig.logBindingUpdate));
	                  break;
	              case exports.PropertyBindingType.Animation:
	                  compileMethod = view.animationBindingsMethod;
	                  var detachStmts_1 = [];
	                  var animationName_1 = boundProp.name;
	                  var targetViewExpr = isHostProp ? compileElement.appElement.prop('componentView') : THIS_EXPR;
	                  var animationFnExpr = targetViewExpr.prop('componentType').prop('animations').key(literal(animationName_1));
	                  // it's important to normalize the void value as `void` explicitly
	                  // so that the styles data can be obtained from the stringmap
	                  var emptyStateValue = literal(EMPTY_ANIMATION_STATE);
	                  var unitializedValue = importExpr(resolveIdentifier(Identifiers.UNINITIALIZED));
	                  var animationTransitionVar_1 = variable('animationTransition_' + animationName_1);
	                  updateStmts.push(animationTransitionVar_1
	                      .set(animationFnExpr.callFn([
	                      THIS_EXPR, renderNode,
	                      bindingField.expression.equals(unitializedValue)
	                          .conditional(emptyStateValue, bindingField.expression),
	                      evalResult.currValExpr.equals(unitializedValue)
	                          .conditional(emptyStateValue, evalResult.currValExpr)
	                  ]))
	                      .toDeclStmt());
	                  detachStmts_1.push(animationTransitionVar_1
	                      .set(animationFnExpr.callFn([THIS_EXPR, renderNode, bindingField.expression, emptyStateValue]))
	                      .toDeclStmt());
	                  eventListeners.forEach(function (listener) {
	                      if (listener.isAnimation && listener.eventName === animationName_1) {
	                          var animationStmt = listener.listenToAnimation(animationTransitionVar_1);
	                          updateStmts.push(animationStmt);
	                          detachStmts_1.push(animationStmt);
	                      }
	                  });
	                  view.detachMethod.addStmts(detachStmts_1);
	                  break;
	          }
	          compileMethod.addStmts(createCheckBindingStmt(evalResult, bindingField.expression, DetectChangesVars.throwOnChange, updateStmts));
	      });
	  }
	  function bindRenderInputs(boundProps, compileElement, eventListeners) {
	      bindAndWriteToRenderer(boundProps, compileElement.view.componentContext, compileElement, false, eventListeners);
	  }
	  function bindDirectiveHostProps(directiveAst, directiveWrapperInstance, compileElement, eventListeners, elementName, schemaRegistry) {
	      // host properties are change detected by the DirectiveWrappers,
	      // except for the animation properties as they need close integration with animation events
	      // and DirectiveWrappers don't support
	      // event listeners right now.
	      bindAndWriteToRenderer(directiveAst.hostProperties.filter(function (boundProp) { return boundProp.isAnimation; }), directiveWrapperInstance.prop('context'), compileElement, true, eventListeners);
	      var methodArgs = [THIS_EXPR, compileElement.renderNode, DetectChangesVars.throwOnChange];
	      // We need to provide the SecurityContext for properties that could need sanitization.
	      directiveAst.hostProperties.filter(function (boundProp) { return boundProp.needsRuntimeSecurityContext; })
	          .forEach(function (boundProp) {
	          var ctx;
	          switch (boundProp.type) {
	              case exports.PropertyBindingType.Property:
	                  ctx = schemaRegistry.securityContext(elementName, boundProp.name, false);
	                  break;
	              case exports.PropertyBindingType.Attribute:
	                  ctx = schemaRegistry.securityContext(elementName, boundProp.name, true);
	                  break;
	              default:
	                  throw new Error("Illegal state: Only property / attribute bindings can have an unknown security context! Binding " + boundProp.name);
	          }
	          methodArgs.push(createEnumExpression(Identifiers.SecurityContext, ctx));
	      });
	      compileElement.view.detectChangesRenderPropertiesMethod.addStmt(directiveWrapperInstance.callMethod('detectChangesInHostProps', methodArgs).toStmt());
	  }
	  function bindDirectiveInputs(directiveAst, directiveWrapperInstance, dirIndex, compileElement) {
	      var view = compileElement.view;
	      var detectChangesInInputsMethod = view.detectChangesInInputsMethod;
	      detectChangesInInputsMethod.resetDebugInfo(compileElement.nodeIndex, compileElement.sourceAst);
	      directiveAst.inputs.forEach(function (input, inputIdx) {
	          // Note: We can't use `fields.length` here, as we are not adding a field!
	          var bindingId = compileElement.nodeIndex + "_" + dirIndex + "_" + inputIdx;
	          detectChangesInInputsMethod.resetDebugInfo(compileElement.nodeIndex, input);
	          var evalResult = convertPropertyBinding(view, view, view.componentContext, input.value, bindingId);
	          if (!evalResult) {
	              return;
	          }
	          detectChangesInInputsMethod.addStmts(evalResult.stmts);
	          detectChangesInInputsMethod.addStmt(directiveWrapperInstance
	              .callMethod("check_" + input.directiveName, [
	              evalResult.currValExpr, DetectChangesVars.throwOnChange,
	              evalResult.forceUpdate || literal(false)
	          ])
	              .toStmt());
	      });
	      var isOnPushComp = directiveAst.directive.isComponent &&
	          !isDefaultChangeDetectionStrategy(directiveAst.directive.changeDetection);
	      var directiveDetectChangesExpr = directiveWrapperInstance.callMethod('detectChangesInInputProps', [THIS_EXPR, compileElement.renderNode, DetectChangesVars.throwOnChange]);
	      var directiveDetectChangesStmt = isOnPushComp ?
	          new IfStmt(directiveDetectChangesExpr, [compileElement.appElement.prop('componentView')
	                  .callMethod('markAsCheckOnce', [])
	                  .toStmt()]) :
	          directiveDetectChangesExpr.toStmt();
	      detectChangesInInputsMethod.addStmt(directiveDetectChangesStmt);
	  }

	  function bindView(view, parsedTemplate, schemaRegistry) {
	      var visitor = new ViewBinderVisitor(view, schemaRegistry);
	      templateVisitAll(visitor, parsedTemplate);
	      view.pipes.forEach(function (pipe) { bindPipeDestroyLifecycleCallbacks(pipe.meta, pipe.instance, pipe.view); });
	  }
	  var ViewBinderVisitor = (function () {
	      function ViewBinderVisitor(view, _schemaRegistry) {
	          this.view = view;
	          this._schemaRegistry = _schemaRegistry;
	          this._nodeIndex = 0;
	      }
	      ViewBinderVisitor.prototype.visitBoundText = function (ast, parent) {
	          var node = this.view.nodes[this._nodeIndex++];
	          bindRenderText(ast, node, this.view);
	          return null;
	      };
	      ViewBinderVisitor.prototype.visitText = function (ast, parent) {
	          this._nodeIndex++;
	          return null;
	      };
	      ViewBinderVisitor.prototype.visitNgContent = function (ast, parent) { return null; };
	      ViewBinderVisitor.prototype.visitElement = function (ast, parent) {
	          var _this = this;
	          var compileElement = this.view.nodes[this._nodeIndex++];
	          var eventListeners = [];
	          collectEventListeners(ast.outputs, ast.directives, compileElement).forEach(function (entry) {
	              eventListeners.push(entry);
	          });
	          bindRenderInputs(ast.inputs, compileElement, eventListeners);
	          bindRenderOutputs(eventListeners);
	          ast.directives.forEach(function (directiveAst, dirIndex) {
	              var directiveInstance = compileElement.instances.get(directiveAst.directive.type.reference);
	              var directiveWrapperInstance = compileElement.directiveWrapperInstance.get(directiveAst.directive.type.reference);
	              bindDirectiveInputs(directiveAst, directiveWrapperInstance, dirIndex, compileElement);
	              bindDirectiveHostProps(directiveAst, directiveWrapperInstance, compileElement, eventListeners, ast.name, _this._schemaRegistry);
	              bindDirectiveOutputs(directiveAst, directiveInstance, eventListeners);
	          });
	          templateVisitAll(this, ast.children, compileElement);
	          // afterContent and afterView lifecycles need to be called bottom up
	          // so that children are notified before parents
	          ast.directives.forEach(function (directiveAst) {
	              var directiveInstance = compileElement.instances.get(directiveAst.directive.type.reference);
	              bindDirectiveAfterContentLifecycleCallbacks(directiveAst.directive, directiveInstance, compileElement);
	              bindDirectiveAfterViewLifecycleCallbacks(directiveAst.directive, directiveInstance, compileElement);
	          });
	          ast.providers.forEach(function (providerAst) {
	              var providerInstance = compileElement.instances.get(providerAst.token.reference);
	              bindInjectableDestroyLifecycleCallbacks(providerAst, providerInstance, compileElement);
	          });
	          return null;
	      };
	      ViewBinderVisitor.prototype.visitEmbeddedTemplate = function (ast, parent) {
	          var compileElement = this.view.nodes[this._nodeIndex++];
	          var eventListeners = collectEventListeners(ast.outputs, ast.directives, compileElement);
	          ast.directives.forEach(function (directiveAst, dirIndex) {
	              var directiveInstance = compileElement.instances.get(directiveAst.directive.type.reference);
	              var directiveWrapperInstance = compileElement.directiveWrapperInstance.get(directiveAst.directive.type.reference);
	              bindDirectiveInputs(directiveAst, directiveWrapperInstance, dirIndex, compileElement);
	              bindDirectiveOutputs(directiveAst, directiveInstance, eventListeners);
	              bindDirectiveAfterContentLifecycleCallbacks(directiveAst.directive, directiveInstance, compileElement);
	              bindDirectiveAfterViewLifecycleCallbacks(directiveAst.directive, directiveInstance, compileElement);
	          });
	          ast.providers.forEach(function (providerAst) {
	              var providerInstance = compileElement.instances.get(providerAst.token.reference);
	              bindInjectableDestroyLifecycleCallbacks(providerAst, providerInstance, compileElement);
	          });
	          bindView(compileElement.embeddedView, ast.children, this._schemaRegistry);
	          return null;
	      };
	      ViewBinderVisitor.prototype.visitAttr = function (ast, ctx) { return null; };
	      ViewBinderVisitor.prototype.visitDirective = function (ast, ctx) { return null; };
	      ViewBinderVisitor.prototype.visitEvent = function (ast, eventTargetAndNames) {
	          return null;
	      };
	      ViewBinderVisitor.prototype.visitReference = function (ast, ctx) { return null; };
	      ViewBinderVisitor.prototype.visitVariable = function (ast, ctx) { return null; };
	      ViewBinderVisitor.prototype.visitDirectiveProperty = function (ast, context) { return null; };
	      ViewBinderVisitor.prototype.visitElementProperty = function (ast, context) { return null; };
	      return ViewBinderVisitor;
	  }());

	  var IMPLICIT_TEMPLATE_VAR = '\$implicit';
	  var CLASS_ATTR$1 = 'class';
	  var STYLE_ATTR = 'style';
	  var NG_CONTAINER_TAG = 'ng-container';
	  var parentRenderNodeVar = variable('parentRenderNode');
	  var rootSelectorVar = variable('rootSelector');
	  function buildView(view, template, targetDependencies) {
	      var builderVisitor = new ViewBuilderVisitor(view, targetDependencies);
	      templateVisitAll(builderVisitor, template, view.declarationElement.isNull() ? view.declarationElement : view.declarationElement.parent);
	      return builderVisitor.nestedViewCount;
	  }
	  function finishView(view, targetStatements) {
	      view.afterNodes();
	      createViewTopLevelStmts(view, targetStatements);
	      view.nodes.forEach(function (node) {
	          if (node instanceof CompileElement && node.hasEmbeddedView) {
	              finishView(node.embeddedView, targetStatements);
	          }
	      });
	  }
	  var ViewBuilderVisitor = (function () {
	      function ViewBuilderVisitor(view, targetDependencies) {
	          this.view = view;
	          this.targetDependencies = targetDependencies;
	          this.nestedViewCount = 0;
	      }
	      ViewBuilderVisitor.prototype._isRootNode = function (parent) { return parent.view !== this.view; };
	      ViewBuilderVisitor.prototype._addRootNodeAndProject = function (node) {
	          var projectedNode = _getOuterContainerOrSelf(node);
	          var parent = projectedNode.parent;
	          var ngContentIndex = projectedNode.sourceAst.ngContentIndex;
	          var vcAppEl = (node instanceof CompileElement && node.hasViewContainer) ? node.appElement : null;
	          if (this._isRootNode(parent)) {
	              // store appElement as root node only for ViewContainers
	              if (this.view.viewType !== ViewType.COMPONENT) {
	                  this.view.rootNodesOrAppElements.push(vcAppEl || node.renderNode);
	              }
	          }
	          else if (isPresent(parent.component) && isPresent(ngContentIndex)) {
	              parent.addContentNode(ngContentIndex, vcAppEl || node.renderNode);
	          }
	      };
	      ViewBuilderVisitor.prototype._getParentRenderNode = function (parent) {
	          parent = _getOuterContainerParentOrSelf(parent);
	          if (this._isRootNode(parent)) {
	              if (this.view.viewType === ViewType.COMPONENT) {
	                  return parentRenderNodeVar;
	              }
	              else {
	                  // root node of an embedded/host view
	                  return NULL_EXPR;
	              }
	          }
	          else {
	              return isPresent(parent.component) &&
	                  parent.component.template.encapsulation !== _angular_core.ViewEncapsulation.Native ?
	                  NULL_EXPR :
	                  parent.renderNode;
	          }
	      };
	      ViewBuilderVisitor.prototype.visitBoundText = function (ast, parent) {
	          return this._visitText(ast, '', parent);
	      };
	      ViewBuilderVisitor.prototype.visitText = function (ast, parent) {
	          return this._visitText(ast, ast.value, parent);
	      };
	      ViewBuilderVisitor.prototype._visitText = function (ast, value, parent) {
	          var fieldName = "_text_" + this.view.nodes.length;
	          this.view.fields.push(new ClassField(fieldName, importType(this.view.genConfig.renderTypes.renderText)));
	          var renderNode = THIS_EXPR.prop(fieldName);
	          var compileNode = new CompileNode(parent, this.view, this.view.nodes.length, renderNode, ast);
	          var createRenderNode = THIS_EXPR.prop(fieldName)
	              .set(ViewProperties.renderer.callMethod('createText', [
	              this._getParentRenderNode(parent), literal(value),
	              this.view.createMethod.resetDebugInfoExpr(this.view.nodes.length, ast)
	          ]))
	              .toStmt();
	          this.view.nodes.push(compileNode);
	          this.view.createMethod.addStmt(createRenderNode);
	          this._addRootNodeAndProject(compileNode);
	          return renderNode;
	      };
	      ViewBuilderVisitor.prototype.visitNgContent = function (ast, parent) {
	          // the projected nodes originate from a different view, so we don't
	          // have debug information for them...
	          this.view.createMethod.resetDebugInfo(null, ast);
	          var parentRenderNode = this._getParentRenderNode(parent);
	          var nodesExpression = ViewProperties.projectableNodes.key(literal(ast.index), new ArrayType(importType(this.view.genConfig.renderTypes.renderNode)));
	          if (parentRenderNode !== NULL_EXPR) {
	              this.view.createMethod.addStmt(ViewProperties.renderer
	                  .callMethod('projectNodes', [
	                  parentRenderNode,
	                  importExpr(resolveIdentifier(Identifiers.flattenNestedViewRenderNodes))
	                      .callFn([nodesExpression])
	              ])
	                  .toStmt());
	          }
	          else if (this._isRootNode(parent)) {
	              if (this.view.viewType !== ViewType.COMPONENT) {
	                  // store root nodes only for embedded/host views
	                  this.view.rootNodesOrAppElements.push(nodesExpression);
	              }
	          }
	          else {
	              if (isPresent(parent.component) && isPresent(ast.ngContentIndex)) {
	                  parent.addContentNode(ast.ngContentIndex, nodesExpression);
	              }
	          }
	          return null;
	      };
	      ViewBuilderVisitor.prototype.visitElement = function (ast, parent) {
	          var nodeIndex = this.view.nodes.length;
	          var createRenderNodeExpr;
	          var debugContextExpr = this.view.createMethod.resetDebugInfoExpr(nodeIndex, ast);
	          var directives = ast.directives.map(function (directiveAst) { return directiveAst.directive; });
	          var component = directives.find(function (directive) { return directive.isComponent; });
	          if (ast.name === NG_CONTAINER_TAG) {
	              createRenderNodeExpr = ViewProperties.renderer.callMethod('createTemplateAnchor', [this._getParentRenderNode(parent), debugContextExpr]);
	          }
	          else {
	              var htmlAttrs = _readHtmlAttrs(ast.attrs);
	              var attrNameAndValues = createInlineArray(_mergeHtmlAndDirectiveAttrs(htmlAttrs, directives).map(function (v) { return literal(v); }));
	              if (nodeIndex === 0 && this.view.viewType === ViewType.HOST) {
	                  createRenderNodeExpr =
	                      importExpr(resolveIdentifier(Identifiers.selectOrCreateRenderHostElement)).callFn([
	                          ViewProperties.renderer, literal(ast.name), attrNameAndValues, rootSelectorVar,
	                          debugContextExpr
	                      ]);
	              }
	              else {
	                  createRenderNodeExpr =
	                      importExpr(resolveIdentifier(Identifiers.createRenderElement)).callFn([
	                          ViewProperties.renderer, this._getParentRenderNode(parent), literal(ast.name),
	                          attrNameAndValues, debugContextExpr
	                      ]);
	              }
	          }
	          var fieldName = "_el_" + nodeIndex;
	          this.view.fields.push(new ClassField(fieldName, importType(this.view.genConfig.renderTypes.renderElement)));
	          this.view.createMethod.addStmt(THIS_EXPR.prop(fieldName).set(createRenderNodeExpr).toStmt());
	          var renderNode = THIS_EXPR.prop(fieldName);
	          var compileElement = new CompileElement(parent, this.view, nodeIndex, renderNode, ast, component, directives, ast.providers, ast.hasViewContainer, false, ast.references, this.targetDependencies);
	          this.view.nodes.push(compileElement);
	          var compViewExpr = null;
	          if (isPresent(component)) {
	              var nestedComponentIdentifier = new CompileIdentifierMetadata({ name: getViewFactoryName(component, 0) });
	              this.targetDependencies.push(new ViewFactoryDependency(component.type, nestedComponentIdentifier));
	              compViewExpr = variable("compView_" + nodeIndex); // fix highlighting: `
	              compileElement.setComponentView(compViewExpr);
	              this.view.createMethod.addStmt(compViewExpr
	                  .set(importExpr(nestedComponentIdentifier).callFn([
	                  ViewProperties.viewUtils, compileElement.injector, compileElement.appElement
	              ]))
	                  .toDeclStmt());
	          }
	          compileElement.beforeChildren();
	          this._addRootNodeAndProject(compileElement);
	          templateVisitAll(this, ast.children, compileElement);
	          compileElement.afterChildren(this.view.nodes.length - nodeIndex - 1);
	          if (isPresent(compViewExpr)) {
	              var codeGenContentNodes;
	              if (this.view.component.type.isHost) {
	                  codeGenContentNodes = ViewProperties.projectableNodes;
	              }
	              else {
	                  codeGenContentNodes = literalArr(compileElement.contentNodesByNgContentIndex.map(function (nodes) { return createFlatArray(nodes); }));
	              }
	              this.view.createMethod.addStmt(compViewExpr
	                  .callMethod('create', [compileElement.getComponent(), codeGenContentNodes, NULL_EXPR])
	                  .toStmt());
	          }
	          return null;
	      };
	      ViewBuilderVisitor.prototype.visitEmbeddedTemplate = function (ast, parent) {
	          var nodeIndex = this.view.nodes.length;
	          var fieldName = "_anchor_" + nodeIndex;
	          this.view.fields.push(new ClassField(fieldName, importType(this.view.genConfig.renderTypes.renderComment)));
	          this.view.createMethod.addStmt(THIS_EXPR.prop(fieldName)
	              .set(ViewProperties.renderer.callMethod('createTemplateAnchor', [
	              this._getParentRenderNode(parent),
	              this.view.createMethod.resetDebugInfoExpr(nodeIndex, ast)
	          ]))
	              .toStmt());
	          var renderNode = THIS_EXPR.prop(fieldName);
	          var templateVariableBindings = ast.variables.map(function (varAst) { return [varAst.value.length > 0 ? varAst.value : IMPLICIT_TEMPLATE_VAR, varAst.name]; });
	          var directives = ast.directives.map(function (directiveAst) { return directiveAst.directive; });
	          var compileElement = new CompileElement(parent, this.view, nodeIndex, renderNode, ast, null, directives, ast.providers, ast.hasViewContainer, true, ast.references, this.targetDependencies);
	          this.view.nodes.push(compileElement);
	          this.nestedViewCount++;
	          var embeddedView = new CompileView(this.view.component, this.view.genConfig, this.view.pipeMetas, NULL_EXPR, this.view.animations, this.view.viewIndex + this.nestedViewCount, compileElement, templateVariableBindings);
	          this.nestedViewCount += buildView(embeddedView, ast.children, this.targetDependencies);
	          compileElement.beforeChildren();
	          this._addRootNodeAndProject(compileElement);
	          compileElement.afterChildren(0);
	          return null;
	      };
	      ViewBuilderVisitor.prototype.visitAttr = function (ast, ctx) { return null; };
	      ViewBuilderVisitor.prototype.visitDirective = function (ast, ctx) { return null; };
	      ViewBuilderVisitor.prototype.visitEvent = function (ast, eventTargetAndNames) {
	          return null;
	      };
	      ViewBuilderVisitor.prototype.visitReference = function (ast, ctx) { return null; };
	      ViewBuilderVisitor.prototype.visitVariable = function (ast, ctx) { return null; };
	      ViewBuilderVisitor.prototype.visitDirectiveProperty = function (ast, context) { return null; };
	      ViewBuilderVisitor.prototype.visitElementProperty = function (ast, context) { return null; };
	      return ViewBuilderVisitor;
	  }());
	  /**
	   * Walks up the nodes while the direct parent is a container.
	   *
	   * Returns the outer container or the node itself when it is not a direct child of a container.
	   *
	   * @internal
	   */
	  function _getOuterContainerOrSelf(node) {
	      var view = node.view;
	      while (_isNgContainer(node.parent, view)) {
	          node = node.parent;
	      }
	      return node;
	  }
	  /**
	   * Walks up the nodes while they are container and returns the first parent which is not.
	   *
	   * Returns the parent of the outer container or the node itself when it is not a container.
	   *
	   * @internal
	   */
	  function _getOuterContainerParentOrSelf(el) {
	      var view = el.view;
	      while (_isNgContainer(el, view)) {
	          el = el.parent;
	      }
	      return el;
	  }
	  function _isNgContainer(node, view) {
	      return !node.isNull() && node.sourceAst.name === NG_CONTAINER_TAG &&
	          node.view === view;
	  }
	  function _mergeHtmlAndDirectiveAttrs(declaredHtmlAttrs, directives) {
	      var mapResult = {};
	      Object.keys(declaredHtmlAttrs).forEach(function (key) { mapResult[key] = declaredHtmlAttrs[key]; });
	      directives.forEach(function (directiveMeta) {
	          Object.keys(directiveMeta.hostAttributes).forEach(function (name) {
	              var value = directiveMeta.hostAttributes[name];
	              var prevValue = mapResult[name];
	              mapResult[name] = isPresent(prevValue) ? mergeAttributeValue(name, prevValue, value) : value;
	          });
	      });
	      var arrResult = [];
	      // Note: We need to sort to get a defined output order
	      // for tests and for caching generated artifacts...
	      Object.keys(mapResult).sort().forEach(function (attrName) { arrResult.push(attrName, mapResult[attrName]); });
	      return arrResult;
	  }
	  function _readHtmlAttrs(attrs) {
	      var htmlAttrs = {};
	      attrs.forEach(function (ast) { htmlAttrs[ast.name] = ast.value; });
	      return htmlAttrs;
	  }
	  function mergeAttributeValue(attrName, attrValue1, attrValue2) {
	      if (attrName == CLASS_ATTR$1 || attrName == STYLE_ATTR) {
	          return attrValue1 + " " + attrValue2;
	      }
	      else {
	          return attrValue2;
	      }
	  }
	  function createViewTopLevelStmts(view, targetStatements) {
	      var nodeDebugInfosVar = NULL_EXPR;
	      if (view.genConfig.genDebugInfo) {
	          nodeDebugInfosVar = variable("nodeDebugInfos_" + view.component.type.name + view.viewIndex); // fix highlighting: `
	          targetStatements.push(nodeDebugInfosVar
	              .set(literalArr(view.nodes.map(createStaticNodeDebugInfo), new ArrayType(new ExternalType(resolveIdentifier(Identifiers.StaticNodeDebugInfo)), [TypeModifier.Const])))
	              .toDeclStmt(null, [StmtModifier.Final]));
	      }
	      var renderCompTypeVar = variable("renderType_" + view.component.type.name); // fix highlighting: `
	      if (view.viewIndex === 0) {
	          targetStatements.push(renderCompTypeVar.set(NULL_EXPR)
	              .toDeclStmt(importType(resolveIdentifier(Identifiers.RenderComponentType))));
	      }
	      var viewClass = createViewClass(view, renderCompTypeVar, nodeDebugInfosVar);
	      targetStatements.push(viewClass);
	      targetStatements.push(createViewFactory(view, viewClass, renderCompTypeVar));
	  }
	  function createStaticNodeDebugInfo(node) {
	      var compileElement = node instanceof CompileElement ? node : null;
	      var providerTokens = [];
	      var componentToken = NULL_EXPR;
	      var varTokenEntries = [];
	      if (isPresent(compileElement)) {
	          providerTokens = compileElement.getProviderTokens();
	          if (isPresent(compileElement.component)) {
	              componentToken = createDiTokenExpression(identifierToken(compileElement.component.type));
	          }
	          Object.keys(compileElement.referenceTokens).forEach(function (varName) {
	              var token = compileElement.referenceTokens[varName];
	              varTokenEntries.push([varName, isPresent(token) ? createDiTokenExpression(token) : NULL_EXPR]);
	          });
	      }
	      return importExpr(resolveIdentifier(Identifiers.StaticNodeDebugInfo))
	          .instantiate([
	          literalArr(providerTokens, new ArrayType(DYNAMIC_TYPE, [TypeModifier.Const])),
	          componentToken,
	          literalMap(varTokenEntries, new MapType(DYNAMIC_TYPE, [TypeModifier.Const]))
	      ], importType(resolveIdentifier(Identifiers.StaticNodeDebugInfo), null, [TypeModifier.Const]));
	  }
	  function createViewClass(view, renderCompTypeVar, nodeDebugInfosVar) {
	      var viewConstructorArgs = [
	          new FnParam(ViewConstructorVars.viewUtils.name, importType(resolveIdentifier(Identifiers.ViewUtils))),
	          new FnParam(ViewConstructorVars.parentInjector.name, importType(resolveIdentifier(Identifiers.Injector))),
	          new FnParam(ViewConstructorVars.declarationEl.name, importType(resolveIdentifier(Identifiers.AppElement)))
	      ];
	      var superConstructorArgs = [
	          variable(view.className), renderCompTypeVar, ViewTypeEnum.fromValue(view.viewType),
	          ViewConstructorVars.viewUtils, ViewConstructorVars.parentInjector,
	          ViewConstructorVars.declarationEl,
	          ChangeDetectorStatusEnum.fromValue(getChangeDetectionMode(view))
	      ];
	      if (view.genConfig.genDebugInfo) {
	          superConstructorArgs.push(nodeDebugInfosVar);
	      }
	      var viewMethods = [
	          new ClassMethod('createInternal', [new FnParam(rootSelectorVar.name, STRING_TYPE)], generateCreateMethod(view), importType(resolveIdentifier(Identifiers.AppElement))),
	          new ClassMethod('injectorGetInternal', [
	              new FnParam(InjectMethodVars.token.name, DYNAMIC_TYPE),
	              // Note: Can't use o.INT_TYPE here as the method in AppView uses number
	              new FnParam(InjectMethodVars.requestNodeIndex.name, NUMBER_TYPE),
	              new FnParam(InjectMethodVars.notFoundResult.name, DYNAMIC_TYPE)
	          ], addReturnValuefNotEmpty(view.injectorGetMethod.finish(), InjectMethodVars.notFoundResult), DYNAMIC_TYPE),
	          new ClassMethod('detectChangesInternal', [new FnParam(DetectChangesVars.throwOnChange.name, BOOL_TYPE)], generateDetectChangesMethod(view)),
	          new ClassMethod('dirtyParentQueriesInternal', [], view.dirtyParentQueriesMethod.finish()),
	          new ClassMethod('destroyInternal', [], view.destroyMethod.finish()),
	          new ClassMethod('detachInternal', [], view.detachMethod.finish())
	      ].filter(function (method) { return method.body.length > 0; });
	      var superClass = view.genConfig.genDebugInfo ? Identifiers.DebugAppView : Identifiers.AppView;
	      var viewClass = createClassStmt({
	          name: view.className,
	          parent: importExpr(resolveIdentifier(superClass), [getContextType(view)]),
	          parentArgs: superConstructorArgs,
	          ctorParams: viewConstructorArgs,
	          builders: [{ methods: viewMethods }, view]
	      });
	      return viewClass;
	  }
	  function createViewFactory(view, viewClass, renderCompTypeVar) {
	      var viewFactoryArgs = [
	          new FnParam(ViewConstructorVars.viewUtils.name, importType(resolveIdentifier(Identifiers.ViewUtils))),
	          new FnParam(ViewConstructorVars.parentInjector.name, importType(resolveIdentifier(Identifiers.Injector))),
	          new FnParam(ViewConstructorVars.declarationEl.name, importType(resolveIdentifier(Identifiers.AppElement)))
	      ];
	      var initRenderCompTypeStmts = [];
	      var templateUrlInfo;
	      if (view.component.template.templateUrl == view.component.type.moduleUrl) {
	          templateUrlInfo =
	              view.component.type.moduleUrl + " class " + view.component.type.name + " - inline template";
	      }
	      else {
	          templateUrlInfo = view.component.template.templateUrl;
	      }
	      if (view.viewIndex === 0) {
	          var animationsExpr = literalMap(view.animations.map(function (entry) { return [entry.name, entry.fnExp]; }));
	          initRenderCompTypeStmts = [
	              new IfStmt(renderCompTypeVar.identical(NULL_EXPR), [
	                  renderCompTypeVar
	                      .set(ViewConstructorVars.viewUtils.callMethod('createRenderComponentType', [
	                      view.genConfig.genDebugInfo ? literal(templateUrlInfo) : literal(''),
	                      literal(view.component.template.ngContentSelectors.length),
	                      ViewEncapsulationEnum.fromValue(view.component.template.encapsulation),
	                      view.styles,
	                      animationsExpr,
	                  ]))
	                      .toStmt(),
	              ]),
	          ];
	      }
	      return fn(viewFactoryArgs, initRenderCompTypeStmts.concat([
	          new ReturnStatement(variable(viewClass.name)
	              .instantiate(viewClass.constructorMethod.params.map(function (param) { return variable(param.name); }))),
	      ]), importType(resolveIdentifier(Identifiers.AppView), [getContextType(view)]))
	          .toDeclStmt(view.viewFactory.name, [StmtModifier.Final]);
	  }
	  function generateCreateMethod(view) {
	      var parentRenderNodeExpr = NULL_EXPR;
	      var parentRenderNodeStmts = [];
	      if (view.viewType === ViewType.COMPONENT) {
	          parentRenderNodeExpr = ViewProperties.renderer.callMethod('createViewRoot', [THIS_EXPR.prop('declarationAppElement').prop('nativeElement')]);
	          parentRenderNodeStmts =
	              [parentRenderNodeVar.set(parentRenderNodeExpr)
	                      .toDeclStmt(importType(view.genConfig.renderTypes.renderNode), [StmtModifier.Final])];
	      }
	      var resultExpr;
	      if (view.viewType === ViewType.HOST) {
	          resultExpr = view.nodes[0].appElement;
	      }
	      else {
	          resultExpr = NULL_EXPR;
	      }
	      return parentRenderNodeStmts.concat(view.createMethod.finish(), [
	          THIS_EXPR
	              .callMethod('init', [
	              createFlatArray(view.rootNodesOrAppElements),
	              literalArr(view.nodes.map(function (node) { return node.renderNode; })), literalArr(view.disposables),
	              literalArr(view.subscriptions)
	          ])
	              .toStmt(),
	          new ReturnStatement(resultExpr)
	      ]);
	  }
	  function generateDetectChangesMethod(view) {
	      var stmts = [];
	      if (view.animationBindingsMethod.isEmpty() && view.detectChangesInInputsMethod.isEmpty() &&
	          view.updateContentQueriesMethod.isEmpty() &&
	          view.afterContentLifecycleCallbacksMethod.isEmpty() &&
	          view.detectChangesRenderPropertiesMethod.isEmpty() &&
	          view.updateViewQueriesMethod.isEmpty() && view.afterViewLifecycleCallbacksMethod.isEmpty()) {
	          return stmts;
	      }
	      stmts.push.apply(stmts, view.animationBindingsMethod.finish());
	      stmts.push.apply(stmts, view.detectChangesInInputsMethod.finish());
	      stmts.push(THIS_EXPR.callMethod('detectContentChildrenChanges', [DetectChangesVars.throwOnChange])
	          .toStmt());
	      var afterContentStmts = view.updateContentQueriesMethod.finish().concat(view.afterContentLifecycleCallbacksMethod.finish());
	      if (afterContentStmts.length > 0) {
	          stmts.push(new IfStmt(not(DetectChangesVars.throwOnChange), afterContentStmts));
	      }
	      stmts.push.apply(stmts, view.detectChangesRenderPropertiesMethod.finish());
	      stmts.push(THIS_EXPR.callMethod('detectViewChildrenChanges', [DetectChangesVars.throwOnChange])
	          .toStmt());
	      var afterViewStmts = view.updateViewQueriesMethod.finish().concat(view.afterViewLifecycleCallbacksMethod.finish());
	      if (afterViewStmts.length > 0) {
	          stmts.push(new IfStmt(not(DetectChangesVars.throwOnChange), afterViewStmts));
	      }
	      var varStmts = [];
	      var readVars = findReadVarNames(stmts);
	      if (readVars.has(DetectChangesVars.changed.name)) {
	          varStmts.push(DetectChangesVars.changed.set(literal(true)).toDeclStmt(BOOL_TYPE));
	      }
	      if (readVars.has(DetectChangesVars.changes.name)) {
	          varStmts.push(DetectChangesVars.changes.set(NULL_EXPR)
	              .toDeclStmt(new MapType(importType(resolveIdentifier(Identifiers.SimpleChange)))));
	      }
	      varStmts.push.apply(varStmts, createSharedBindingVariablesIfNeeded(stmts));
	      return varStmts.concat(stmts);
	  }
	  function addReturnValuefNotEmpty(statements, value) {
	      if (statements.length > 0) {
	          return statements.concat([new ReturnStatement(value)]);
	      }
	      else {
	          return statements;
	      }
	  }
	  function getContextType(view) {
	      if (view.viewType === ViewType.COMPONENT) {
	          return importType(view.component.type);
	      }
	      return DYNAMIC_TYPE;
	  }
	  function getChangeDetectionMode(view) {
	      var mode;
	      if (view.viewType === ViewType.COMPONENT) {
	          mode = isDefaultChangeDetectionStrategy(view.component.changeDetection) ?
	              ChangeDetectorStatus.CheckAlways :
	              ChangeDetectorStatus.CheckOnce;
	      }
	      else {
	          mode = ChangeDetectorStatus.CheckAlways;
	      }
	      return mode;
	  }

	  var ViewCompileResult = (function () {
	      function ViewCompileResult(statements, viewFactoryVar, dependencies) {
	          this.statements = statements;
	          this.viewFactoryVar = viewFactoryVar;
	          this.dependencies = dependencies;
	      }
	      return ViewCompileResult;
	  }());
	  var ViewCompiler = (function () {
	      function ViewCompiler(_genConfig, _schemaRegistry) {
	          this._genConfig = _genConfig;
	          this._schemaRegistry = _schemaRegistry;
	      }
	      ViewCompiler.prototype.compileComponent = function (component, template, styles, pipes, compiledAnimations) {
	          var dependencies = [];
	          var view = new CompileView(component, this._genConfig, pipes, styles, compiledAnimations, 0, CompileElement.createNull(), []);
	          var statements = [];
	          buildView(view, template, dependencies);
	          // Need to separate binding from creation to be able to refer to
	          // variables that have been declared after usage.
	          bindView(view, template, this._schemaRegistry);
	          finishView(view, statements);
	          return new ViewCompileResult(statements, view.viewFactory.name, dependencies);
	      };
	      ViewCompiler.decorators = [
	          { type: _angular_core.Injectable },
	      ];
	      /** @nocollapse */
	      ViewCompiler.ctorParameters = [
	          { type: CompilerConfig, },
	          { type: ElementSchemaRegistry, },
	      ];
	      return ViewCompiler;
	  }());

	  var SourceModule = (function () {
	      function SourceModule(fileUrl, moduleUrl, source) {
	          this.fileUrl = fileUrl;
	          this.moduleUrl = moduleUrl;
	          this.source = source;
	      }
	      return SourceModule;
	  }());
	  // Returns all the source files and a mapping from modules to directives
	  function analyzeNgModules(programStaticSymbols, options, metadataResolver) {
	      var _a = _extractModulesAndPipesOrDirectives(programStaticSymbols, metadataResolver), programNgModules = _a.ngModules, programPipesOrDirectives = _a.pipesAndDirectives;
	      var moduleMetasByRef = new Map();
	      programNgModules.forEach(function (modMeta) {
	          if (options.transitiveModules) {
	              // For every input modules add the list of transitively included modules
	              modMeta.transitiveModule.modules.forEach(function (modMeta) { moduleMetasByRef.set(modMeta.type.reference, modMeta); });
	          }
	          else {
	              moduleMetasByRef.set(modMeta.type.reference, modMeta);
	          }
	      });
	      var ngModuleMetas = MapWrapper.values(moduleMetasByRef);
	      var ngModuleByPipeOrDirective = new Map();
	      var ngModulesByFile = new Map();
	      var ngDirectivesByFile = new Map();
	      var filePaths = new Set();
	      // Looping over all modules to construct:
	      // - a map from file to modules `ngModulesByFile`,
	      // - a map from file to directives `ngDirectivesByFile`,
	      // - a map from directive/pipe to module `ngModuleByPipeOrDirective`.
	      ngModuleMetas.forEach(function (ngModuleMeta) {
	          var srcFileUrl = ngModuleMeta.type.reference.filePath;
	          filePaths.add(srcFileUrl);
	          ngModulesByFile.set(srcFileUrl, (ngModulesByFile.get(srcFileUrl) || []).concat(ngModuleMeta.type.reference));
	          ngModuleMeta.declaredDirectives.forEach(function (dirMeta) {
	              var fileUrl = dirMeta.type.reference.filePath;
	              filePaths.add(fileUrl);
	              ngDirectivesByFile.set(fileUrl, (ngDirectivesByFile.get(fileUrl) || []).concat(dirMeta.type.reference));
	              ngModuleByPipeOrDirective.set(dirMeta.type.reference, ngModuleMeta);
	          });
	          ngModuleMeta.declaredPipes.forEach(function (pipeMeta) {
	              var fileUrl = pipeMeta.type.reference.filePath;
	              filePaths.add(fileUrl);
	              ngModuleByPipeOrDirective.set(pipeMeta.type.reference, ngModuleMeta);
	          });
	      });
	      // Throw an error if any of the program pipe or directives is not declared by a module
	      var symbolsMissingModule = programPipesOrDirectives.filter(function (s) { return !ngModuleByPipeOrDirective.has(s); });
	      if (symbolsMissingModule.length) {
	          var messages = symbolsMissingModule.map(function (s) { return ("Cannot determine the module for class " + s.name + " in " + s.filePath + "!"); });
	          throw new Error(messages.join('\n'));
	      }
	      var files = [];
	      filePaths.forEach(function (srcUrl) {
	          var directives = ngDirectivesByFile.get(srcUrl) || [];
	          var ngModules = ngModulesByFile.get(srcUrl) || [];
	          files.push({ srcUrl: srcUrl, directives: directives, ngModules: ngModules });
	      });
	      return {
	          // map directive/pipe to module
	          ngModuleByPipeOrDirective: ngModuleByPipeOrDirective,
	          // list modules and directives for every source file
	          files: files,
	      };
	  }
	  var OfflineCompiler = (function () {
	      function OfflineCompiler(_metadataResolver, _directiveNormalizer, _templateParser, _styleCompiler, _viewCompiler, _dirWrapperCompiler, _ngModuleCompiler, _outputEmitter, _localeId, _translationFormat) {
	          this._metadataResolver = _metadataResolver;
	          this._directiveNormalizer = _directiveNormalizer;
	          this._templateParser = _templateParser;
	          this._styleCompiler = _styleCompiler;
	          this._viewCompiler = _viewCompiler;
	          this._dirWrapperCompiler = _dirWrapperCompiler;
	          this._ngModuleCompiler = _ngModuleCompiler;
	          this._outputEmitter = _outputEmitter;
	          this._localeId = _localeId;
	          this._translationFormat = _translationFormat;
	          this._animationParser = new AnimationParser();
	          this._animationCompiler = new AnimationCompiler();
	      }
	      OfflineCompiler.prototype.clearCache = function () {
	          this._directiveNormalizer.clearCache();
	          this._metadataResolver.clearCache();
	      };
	      OfflineCompiler.prototype.compileModules = function (staticSymbols, options) {
	          var _this = this;
	          var _a = analyzeNgModules(staticSymbols, options, this._metadataResolver), ngModuleByPipeOrDirective = _a.ngModuleByPipeOrDirective, files = _a.files;
	          var sourceModules = files.map(function (file) { return _this._compileSrcFile(file.srcUrl, ngModuleByPipeOrDirective, file.directives, file.ngModules); });
	          return Promise.all(sourceModules)
	              .then(function (modules) { return ListWrapper.flatten(modules); });
	      };
	      OfflineCompiler.prototype._compileSrcFile = function (srcFileUrl, ngModuleByPipeOrDirective, directives, ngModules) {
	          var _this = this;
	          var fileSuffix = _splitTypescriptSuffix(srcFileUrl)[1];
	          var statements = [];
	          var exportedVars = [];
	          var outputSourceModules = [];
	          // compile all ng modules
	          exportedVars.push.apply(exportedVars, ngModules.map(function (ngModuleType) { return _this._compileModule(ngModuleType, statements); }));
	          // compile directive wrappers
	          exportedVars.push.apply(exportedVars, directives.map(function (directiveType) { return _this._compileDirectiveWrapper(directiveType, statements); }));
	          // compile components
	          return Promise
	              .all(directives.map(function (dirType) {
	              var compMeta = _this._metadataResolver.getDirectiveMetadata(dirType);
	              if (!compMeta.isComponent) {
	                  return Promise.resolve(null);
	              }
	              var ngModule = ngModuleByPipeOrDirective.get(dirType);
	              if (!ngModule) {
	                  throw new Error("Internal Error: cannot determine the module for component " + compMeta.type.name + "!");
	              }
	              return Promise
	                  .all([compMeta].concat(ngModule.transitiveModule.directives).map(function (dirMeta) { return _this._directiveNormalizer.normalizeDirective(dirMeta).asyncResult; }))
	                  .then(function (normalizedCompWithDirectives) {
	                  var compMeta = normalizedCompWithDirectives[0], dirMetas = normalizedCompWithDirectives.slice(1);
	                  _assertComponent(compMeta);
	                  // compile styles
	                  var stylesCompileResults = _this._styleCompiler.compileComponent(compMeta);
	                  stylesCompileResults.externalStylesheets.forEach(function (compiledStyleSheet) {
	                      outputSourceModules.push(_this._codgenStyles(srcFileUrl, compiledStyleSheet, fileSuffix));
	                  });
	                  // compile components
	                  exportedVars.push(_this._compileComponentFactory(compMeta, fileSuffix, statements), _this._compileComponent(compMeta, dirMetas, ngModule.transitiveModule.pipes, ngModule.schemas, stylesCompileResults.componentStylesheet, fileSuffix, statements));
	              });
	          }))
	              .then(function () {
	              if (statements.length > 0) {
	                  var srcModule = _this._codegenSourceModule(srcFileUrl, _ngfactoryModuleUrl(srcFileUrl), statements, exportedVars);
	                  outputSourceModules.unshift(srcModule);
	              }
	              return outputSourceModules;
	          });
	      };
	      OfflineCompiler.prototype._compileModule = function (ngModuleType, targetStatements) {
	          var ngModule = this._metadataResolver.getNgModuleMetadata(ngModuleType);
	          var providers = [];
	          if (this._localeId) {
	              providers.push(new CompileProviderMetadata({
	                  token: resolveIdentifierToken(Identifiers.LOCALE_ID),
	                  useValue: this._localeId,
	              }));
	          }
	          if (this._translationFormat) {
	              providers.push(new CompileProviderMetadata({
	                  token: resolveIdentifierToken(Identifiers.TRANSLATIONS_FORMAT),
	                  useValue: this._translationFormat
	              }));
	          }
	          var appCompileResult = this._ngModuleCompiler.compile(ngModule, providers);
	          appCompileResult.dependencies.forEach(function (dep) {
	              dep.placeholder.name = _componentFactoryName(dep.comp);
	              dep.placeholder.moduleUrl = _ngfactoryModuleUrl(dep.comp.moduleUrl);
	          });
	          targetStatements.push.apply(targetStatements, appCompileResult.statements);
	          return appCompileResult.ngModuleFactoryVar;
	      };
	      OfflineCompiler.prototype._compileDirectiveWrapper = function (directiveType, targetStatements) {
	          var dirMeta = this._metadataResolver.getDirectiveMetadata(directiveType);
	          var dirCompileResult = this._dirWrapperCompiler.compile(dirMeta);
	          targetStatements.push.apply(targetStatements, dirCompileResult.statements);
	          return dirCompileResult.dirWrapperClassVar;
	      };
	      OfflineCompiler.prototype._compileComponentFactory = function (compMeta, fileSuffix, targetStatements) {
	          var hostMeta = createHostComponentMeta(compMeta);
	          var hostViewFactoryVar = this._compileComponent(hostMeta, [compMeta], [], [], null, fileSuffix, targetStatements);
	          var compFactoryVar = _componentFactoryName(compMeta.type);
	          targetStatements.push(variable(compFactoryVar)
	              .set(importExpr(resolveIdentifier(Identifiers.ComponentFactory), [importType(compMeta.type)])
	              .instantiate([
	              literal(compMeta.selector),
	              variable(hostViewFactoryVar),
	              importExpr(compMeta.type),
	          ], importType(resolveIdentifier(Identifiers.ComponentFactory), [importType(compMeta.type)], [TypeModifier.Const])))
	              .toDeclStmt(null, [StmtModifier.Final]));
	          return compFactoryVar;
	      };
	      OfflineCompiler.prototype._compileComponent = function (compMeta, directives, pipes, schemas, componentStyles, fileSuffix, targetStatements) {
	          var parsedAnimations = this._animationParser.parseComponent(compMeta);
	          var parsedTemplate = this._templateParser.parse(compMeta, compMeta.template.template, directives, pipes, schemas, compMeta.type.name);
	          var stylesExpr = componentStyles ? variable(componentStyles.stylesVar) : literalArr([]);
	          var compiledAnimations = this._animationCompiler.compile(compMeta.type.name, parsedAnimations);
	          var viewResult = this._viewCompiler.compileComponent(compMeta, parsedTemplate, stylesExpr, pipes, compiledAnimations);
	          if (componentStyles) {
	              targetStatements.push.apply(targetStatements, _resolveStyleStatements(componentStyles, fileSuffix));
	          }
	          compiledAnimations.forEach(function (entry) { entry.statements.forEach(function (statement) { targetStatements.push(statement); }); });
	          targetStatements.push.apply(targetStatements, _resolveViewStatements(viewResult));
	          return viewResult.viewFactoryVar;
	      };
	      OfflineCompiler.prototype._codgenStyles = function (fileUrl, stylesCompileResult, fileSuffix) {
	          _resolveStyleStatements(stylesCompileResult, fileSuffix);
	          return this._codegenSourceModule(fileUrl, _stylesModuleUrl(stylesCompileResult.meta.moduleUrl, stylesCompileResult.isShimmed, fileSuffix), stylesCompileResult.statements, [stylesCompileResult.stylesVar]);
	      };
	      OfflineCompiler.prototype._codegenSourceModule = function (fileUrl, moduleUrl, statements, exportedVars) {
	          return new SourceModule(fileUrl, moduleUrl, this._outputEmitter.emitStatements(moduleUrl, statements, exportedVars));
	      };
	      return OfflineCompiler;
	  }());
	  function _resolveViewStatements(compileResult) {
	      compileResult.dependencies.forEach(function (dep) {
	          if (dep instanceof ViewFactoryDependency) {
	              var vfd = dep;
	              vfd.placeholder.moduleUrl = _ngfactoryModuleUrl(vfd.comp.moduleUrl);
	          }
	          else if (dep instanceof ComponentFactoryDependency) {
	              var cfd = dep;
	              cfd.placeholder.name = _componentFactoryName(cfd.comp);
	              cfd.placeholder.moduleUrl = _ngfactoryModuleUrl(cfd.comp.moduleUrl);
	          }
	          else if (dep instanceof DirectiveWrapperDependency) {
	              var dwd = dep;
	              dwd.placeholder.moduleUrl = _ngfactoryModuleUrl(dwd.dir.moduleUrl);
	          }
	      });
	      return compileResult.statements;
	  }
	  function _resolveStyleStatements(compileResult, fileSuffix) {
	      compileResult.dependencies.forEach(function (dep) {
	          dep.valuePlaceholder.moduleUrl = _stylesModuleUrl(dep.moduleUrl, dep.isShimmed, fileSuffix);
	      });
	      return compileResult.statements;
	  }
	  function _ngfactoryModuleUrl(dirUrl) {
	      var urlWithSuffix = _splitTypescriptSuffix(dirUrl);
	      return urlWithSuffix[0] + ".ngfactory" + urlWithSuffix[1];
	  }
	  function _componentFactoryName(comp) {
	      return comp.name + "NgFactory";
	  }
	  function _stylesModuleUrl(stylesheetUrl, shim, suffix) {
	      return shim ? stylesheetUrl + ".shim" + suffix : "" + stylesheetUrl + suffix;
	  }
	  function _assertComponent(meta) {
	      if (!meta.isComponent) {
	          throw new Error("Could not compile '" + meta.type.name + "' because it is not a component.");
	      }
	  }
	  function _splitTypescriptSuffix(path) {
	      if (path.endsWith('.d.ts')) {
	          return [path.slice(0, -5), '.ts'];
	      }
	      var lastDot = path.lastIndexOf('.');
	      if (lastDot !== -1) {
	          return [path.substring(0, lastDot), path.substring(lastDot)];
	      }
	      return [path, ''];
	  }
	  // Group the symbols by types:
	  // - NgModules,
	  // - Pipes and Directives.
	  function _extractModulesAndPipesOrDirectives(programStaticSymbols, metadataResolver) {
	      var ngModules = [];
	      var pipesAndDirectives = [];
	      programStaticSymbols.forEach(function (staticSymbol) {
	          var ngModule = metadataResolver.getNgModuleMetadata(staticSymbol, false);
	          var directive = metadataResolver.getDirectiveMetadata(staticSymbol, false);
	          var pipe = metadataResolver.getPipeMetadata(staticSymbol, false);
	          if (ngModule) {
	              ngModules.push(ngModule);
	          }
	          else if (directive) {
	              pipesAndDirectives.push(staticSymbol);
	          }
	          else if (pipe) {
	              pipesAndDirectives.push(staticSymbol);
	          }
	      });
	      return { ngModules: ngModules, pipesAndDirectives: pipesAndDirectives };
	  }

	  /**
	   * @license
	   * Copyright Google Inc. All Rights Reserved.
	   *
	   * Use of this source code is governed by an MIT-style license that can be
	   * found in the LICENSE file at https://angular.io/license
	   */
	  /**
	   * An interface for retrieving documents by URL that the compiler uses
	   * to load templates.
	   */
	  var ResourceLoader = (function () {
	      function ResourceLoader() {
	      }
	      ResourceLoader.prototype.get = function (url) { return null; };
	      return ResourceLoader;
	  }());

	  var _ASSET_SCHEME = 'asset:';
	  /**
	   * Create a {@link UrlResolver} with no package prefix.
	   */
	  function createUrlResolverWithoutPackagePrefix() {
	      return new UrlResolver();
	  }
	  function createOfflineCompileUrlResolver() {
	      return new UrlResolver(_ASSET_SCHEME);
	  }
	  /**
	   * A default provider for {@link PACKAGE_ROOT_URL} that maps to '/'.
	   */
	  var DEFAULT_PACKAGE_URL_PROVIDER = {
	      provide: _angular_core.PACKAGE_ROOT_URL,
	      useValue: '/'
	  };
	  /**
	   * Used by the {@link Compiler} when resolving HTML and CSS template URLs.
	   *
	   * This class can be overridden by the application developer to create custom behavior.
	   *
	   * See {@link Compiler}
	   *
	   * ## Example
	   *
	   * {@example compiler/ts/url_resolver/url_resolver.ts region='url_resolver'}
	   *
	   * @security  When compiling templates at runtime, you must
	   * ensure that the entire template comes from a trusted source.
	   * Attacker-controlled data introduced by a template could expose your
	   * application to XSS risks. For more detail, see the [Security Guide](http://g.co/ng/security).
	   */
	  var UrlResolver = (function () {
	      function UrlResolver(_packagePrefix) {
	          if (_packagePrefix === void 0) { _packagePrefix = null; }
	          this._packagePrefix = _packagePrefix;
	      }
	      /**
	       * Resolves the `url` given the `baseUrl`:
	       * - when the `url` is null, the `baseUrl` is returned,
	       * - if `url` is relative ('path/to/here', './path/to/here'), the resolved url is a combination of
	       * `baseUrl` and `url`,
	       * - if `url` is absolute (it has a scheme: 'http://', 'https://' or start with '/'), the `url` is
	       * returned as is (ignoring the `baseUrl`)
	       */
	      UrlResolver.prototype.resolve = function (baseUrl, url) {
	          var resolvedUrl = url;
	          if (isPresent(baseUrl) && baseUrl.length > 0) {
	              resolvedUrl = _resolveUrl(baseUrl, resolvedUrl);
	          }
	          var resolvedParts = _split(resolvedUrl);
	          var prefix = this._packagePrefix;
	          if (isPresent(prefix) && isPresent(resolvedParts) &&
	              resolvedParts[_ComponentIndex.Scheme] == 'package') {
	              var path = resolvedParts[_ComponentIndex.Path];
	              if (this._packagePrefix === _ASSET_SCHEME) {
	                  var pathSegements = path.split(/\//);
	                  resolvedUrl = "asset:" + pathSegements[0] + "/lib/" + pathSegements.slice(1).join('/');
	              }
	              else {
	                  prefix = prefix.replace(/\/+$/, '');
	                  path = path.replace(/^\/+/, '');
	                  return prefix + "/" + path;
	              }
	          }
	          return resolvedUrl;
	      };
	      UrlResolver.decorators = [
	          { type: _angular_core.Injectable },
	      ];
	      /** @nocollapse */
	      UrlResolver.ctorParameters = [
	          { type: undefined, decorators: [{ type: _angular_core.Inject, args: [_angular_core.PACKAGE_ROOT_URL,] },] },
	      ];
	      return UrlResolver;
	  }());
	  /**
	   * Extract the scheme of a URL.
	   */
	  function getUrlScheme(url) {
	      var match = _split(url);
	      return (match && match[_ComponentIndex.Scheme]) || '';
	  }
	  // The code below is adapted from Traceur:
	  // https://github.com/google/traceur-compiler/blob/9511c1dafa972bf0de1202a8a863bad02f0f95a8/src/runtime/url.js
	  /**
	   * Builds a URI string from already-encoded parts.
	   *
	   * No encoding is performed.  Any component may be omitted as either null or
	   * undefined.
	   *
	   * @param opt_scheme The scheme such as 'http'.
	   * @param opt_userInfo The user name before the '@'.
	   * @param opt_domain The domain such as 'www.google.com', already
	   *     URI-encoded.
	   * @param opt_port The port number.
	   * @param opt_path The path, already URI-encoded.  If it is not
	   *     empty, it must begin with a slash.
	   * @param opt_queryData The URI-encoded query data.
	   * @param opt_fragment The URI-encoded fragment identifier.
	   * @return The fully combined URI.
	   */
	  function _buildFromEncodedParts(opt_scheme, opt_userInfo, opt_domain, opt_port, opt_path, opt_queryData, opt_fragment) {
	      var out = [];
	      if (isPresent(opt_scheme)) {
	          out.push(opt_scheme + ':');
	      }
	      if (isPresent(opt_domain)) {
	          out.push('//');
	          if (isPresent(opt_userInfo)) {
	              out.push(opt_userInfo + '@');
	          }
	          out.push(opt_domain);
	          if (isPresent(opt_port)) {
	              out.push(':' + opt_port);
	          }
	      }
	      if (isPresent(opt_path)) {
	          out.push(opt_path);
	      }
	      if (isPresent(opt_queryData)) {
	          out.push('?' + opt_queryData);
	      }
	      if (isPresent(opt_fragment)) {
	          out.push('#' + opt_fragment);
	      }
	      return out.join('');
	  }
	  /**
	   * A regular expression for breaking a URI into its component parts.
	   *
	   * {@link http://www.gbiv.com/protocols/uri/rfc/rfc3986.html#RFC2234} says
	   * As the "first-match-wins" algorithm is identical to the "greedy"
	   * disambiguation method used by POSIX regular expressions, it is natural and
	   * commonplace to use a regular expression for parsing the potential five
	   * components of a URI reference.
	   *
	   * The following line is the regular expression for breaking-down a
	   * well-formed URI reference into its components.
	   *
	   * <pre>
	   * ^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?
	   *  12            3  4          5       6  7        8 9
	   * </pre>
	   *
	   * The numbers in the second line above are only to assist readability; they
	   * indicate the reference points for each subexpression (i.e., each paired
	   * parenthesis). We refer to the value matched for subexpression <n> as $<n>.
	   * For example, matching the above expression to
	   * <pre>
	   *     http://www.ics.uci.edu/pub/ietf/uri/#Related
	   * </pre>
	   * results in the following subexpression matches:
	   * <pre>
	   *    $1 = http:
	   *    $2 = http
	   *    $3 = //www.ics.uci.edu
	   *    $4 = www.ics.uci.edu
	   *    $5 = /pub/ietf/uri/
	   *    $6 = <undefined>
	   *    $7 = <undefined>
	   *    $8 = #Related
	   *    $9 = Related
	   * </pre>
	   * where <undefined> indicates that the component is not present, as is the
	   * case for the query component in the above example. Therefore, we can
	   * determine the value of the five components as
	   * <pre>
	   *    scheme    = $2
	   *    authority = $4
	   *    path      = $5
	   *    query     = $7
	   *    fragment  = $9
	   * </pre>
	   *
	   * The regular expression has been modified slightly to expose the
	   * userInfo, domain, and port separately from the authority.
	   * The modified version yields
	   * <pre>
	   *    $1 = http              scheme
	   *    $2 = <undefined>       userInfo -\
	   *    $3 = www.ics.uci.edu   domain     | authority
	   *    $4 = <undefined>       port     -/
	   *    $5 = /pub/ietf/uri/    path
	   *    $6 = <undefined>       query without ?
	   *    $7 = Related           fragment without #
	   * </pre>
	   * @type {!RegExp}
	   * @internal
	   */
	  var _splitRe = new RegExp('^' +
	      '(?:' +
	      '([^:/?#.]+)' +
	      // used by other URL parts such as :,
	      // ?, /, #, and .
	      ':)?' +
	      '(?://' +
	      '(?:([^/?#]*)@)?' +
	      '([\\w\\d\\-\\u0100-\\uffff.%]*)' +
	      // digits, dashes, dots, percent
	      // escapes, and unicode characters.
	      '(?::([0-9]+))?' +
	      ')?' +
	      '([^?#]+)?' +
	      '(?:\\?([^#]*))?' +
	      '(?:#(.*))?' +
	      '$');
	  /**
	   * The index of each URI component in the return value of goog.uri.utils.split.
	   * @enum {number}
	   */
	  var _ComponentIndex;
	  (function (_ComponentIndex) {
	      _ComponentIndex[_ComponentIndex["Scheme"] = 1] = "Scheme";
	      _ComponentIndex[_ComponentIndex["UserInfo"] = 2] = "UserInfo";
	      _ComponentIndex[_ComponentIndex["Domain"] = 3] = "Domain";
	      _ComponentIndex[_ComponentIndex["Port"] = 4] = "Port";
	      _ComponentIndex[_ComponentIndex["Path"] = 5] = "Path";
	      _ComponentIndex[_ComponentIndex["QueryData"] = 6] = "QueryData";
	      _ComponentIndex[_ComponentIndex["Fragment"] = 7] = "Fragment";
	  })(_ComponentIndex || (_ComponentIndex = {}));
	  /**
	   * Splits a URI into its component parts.
	   *
	   * Each component can be accessed via the component indices; for example:
	   * <pre>
	   * goog.uri.utils.split(someStr)[goog.uri.utils.CompontentIndex.QUERY_DATA];
	   * </pre>
	   *
	   * @param uri The URI string to examine.
	   * @return Each component still URI-encoded.
	   *     Each component that is present will contain the encoded value, whereas
	   *     components that are not present will be undefined or empty, depending
	   *     on the browser's regular expression implementation.  Never null, since
	   *     arbitrary strings may still look like path names.
	   */
	  function _split(uri) {
	      return uri.match(_splitRe);
	  }
	  /**
	    * Removes dot segments in given path component, as described in
	    * RFC 3986, section 5.2.4.
	    *
	    * @param path A non-empty path component.
	    * @return Path component with removed dot segments.
	    */
	  function _removeDotSegments(path) {
	      if (path == '/')
	          return '/';
	      var leadingSlash = path[0] == '/' ? '/' : '';
	      var trailingSlash = path[path.length - 1] === '/' ? '/' : '';
	      var segments = path.split('/');
	      var out = [];
	      var up = 0;
	      for (var pos = 0; pos < segments.length; pos++) {
	          var segment = segments[pos];
	          switch (segment) {
	              case '':
	              case '.':
	                  break;
	              case '..':
	                  if (out.length > 0) {
	                      out.pop();
	                  }
	                  else {
	                      up++;
	                  }
	                  break;
	              default:
	                  out.push(segment);
	          }
	      }
	      if (leadingSlash == '') {
	          while (up-- > 0) {
	              out.unshift('..');
	          }
	          if (out.length === 0)
	              out.push('.');
	      }
	      return leadingSlash + out.join('/') + trailingSlash;
	  }
	  /**
	   * Takes an array of the parts from split and canonicalizes the path part
	   * and then joins all the parts.
	   */
	  function _joinAndCanonicalizePath(parts) {
	      var path = parts[_ComponentIndex.Path];
	      path = isBlank(path) ? '' : _removeDotSegments(path);
	      parts[_ComponentIndex.Path] = path;
	      return _buildFromEncodedParts(parts[_ComponentIndex.Scheme], parts[_ComponentIndex.UserInfo], parts[_ComponentIndex.Domain], parts[_ComponentIndex.Port], path, parts[_ComponentIndex.QueryData], parts[_ComponentIndex.Fragment]);
	  }
	  /**
	   * Resolves a URL.
	   * @param base The URL acting as the base URL.
	   * @param to The URL to resolve.
	   */
	  function _resolveUrl(base, url) {
	      var parts = _split(encodeURI(url));
	      var baseParts = _split(base);
	      if (isPresent(parts[_ComponentIndex.Scheme])) {
	          return _joinAndCanonicalizePath(parts);
	      }
	      else {
	          parts[_ComponentIndex.Scheme] = baseParts[_ComponentIndex.Scheme];
	      }
	      for (var i = _ComponentIndex.Scheme; i <= _ComponentIndex.Port; i++) {
	          if (isBlank(parts[i])) {
	              parts[i] = baseParts[i];
	          }
	      }
	      if (parts[_ComponentIndex.Path][0] == '/') {
	          return _joinAndCanonicalizePath(parts);
	      }
	      var path = baseParts[_ComponentIndex.Path];
	      if (isBlank(path))
	          path = '/';
	      var index = path.lastIndexOf('/');
	      path = path.substring(0, index + 1) + parts[_ComponentIndex.Path];
	      parts[_ComponentIndex.Path] = path;
	      return _joinAndCanonicalizePath(parts);
	  }

	  var DirectiveNormalizer = (function () {
	      function DirectiveNormalizer(_resourceLoader, _urlResolver, _htmlParser, _config) {
	          this._resourceLoader = _resourceLoader;
	          this._urlResolver = _urlResolver;
	          this._htmlParser = _htmlParser;
	          this._config = _config;
	          this._resourceLoaderCache = new Map();
	      }
	      DirectiveNormalizer.prototype.clearCache = function () { this._resourceLoaderCache.clear(); };
	      DirectiveNormalizer.prototype.clearCacheFor = function (normalizedDirective) {
	          var _this = this;
	          if (!normalizedDirective.isComponent) {
	              return;
	          }
	          this._resourceLoaderCache.delete(normalizedDirective.template.templateUrl);
	          normalizedDirective.template.externalStylesheets.forEach(function (stylesheet) { _this._resourceLoaderCache.delete(stylesheet.moduleUrl); });
	      };
	      DirectiveNormalizer.prototype._fetch = function (url) {
	          var result = this._resourceLoaderCache.get(url);
	          if (!result) {
	              result = this._resourceLoader.get(url);
	              this._resourceLoaderCache.set(url, result);
	          }
	          return result;
	      };
	      DirectiveNormalizer.prototype.normalizeDirective = function (directive) {
	          var _this = this;
	          if (!directive.isComponent) {
	              // For non components there is nothing to be normalized yet.
	              return new SyncAsyncResult(directive, Promise.resolve(directive));
	          }
	          var normalizedTemplateSync = null;
	          var normalizedTemplateAsync;
	          if (isPresent(directive.template.template)) {
	              normalizedTemplateSync = this.normalizeTemplateSync(directive.type, directive.template);
	              normalizedTemplateAsync = Promise.resolve(normalizedTemplateSync);
	          }
	          else if (directive.template.templateUrl) {
	              normalizedTemplateAsync = this.normalizeTemplateAsync(directive.type, directive.template);
	          }
	          else {
	              throw new Error("No template specified for component " + directive.type.name);
	          }
	          if (normalizedTemplateSync && normalizedTemplateSync.styleUrls.length === 0) {
	              // sync case
	              var normalizedDirective = _cloneDirectiveWithTemplate(directive, normalizedTemplateSync);
	              return new SyncAsyncResult(normalizedDirective, Promise.resolve(normalizedDirective));
	          }
	          else {
	              // async case
	              return new SyncAsyncResult(null, normalizedTemplateAsync
	                  .then(function (normalizedTemplate) { return _this.normalizeExternalStylesheets(normalizedTemplate); })
	                  .then(function (normalizedTemplate) {
	                  return _cloneDirectiveWithTemplate(directive, normalizedTemplate);
	              }));
	          }
	      };
	      DirectiveNormalizer.prototype.normalizeTemplateSync = function (directiveType, template) {
	          return this.normalizeLoadedTemplate(directiveType, template, template.template, directiveType.moduleUrl);
	      };
	      DirectiveNormalizer.prototype.normalizeTemplateAsync = function (directiveType, template) {
	          var _this = this;
	          var templateUrl = this._urlResolver.resolve(directiveType.moduleUrl, template.templateUrl);
	          return this._fetch(templateUrl)
	              .then(function (value) { return _this.normalizeLoadedTemplate(directiveType, template, value, templateUrl); });
	      };
	      DirectiveNormalizer.prototype.normalizeLoadedTemplate = function (directiveType, templateMeta, template, templateAbsUrl) {
	          var interpolationConfig = InterpolationConfig.fromArray(templateMeta.interpolation);
	          var rootNodesAndErrors = this._htmlParser.parse(template, directiveType.name, false, interpolationConfig);
	          if (rootNodesAndErrors.errors.length > 0) {
	              var errorString = rootNodesAndErrors.errors.join('\n');
	              throw new Error("Template parse errors:\n" + errorString);
	          }
	          var templateMetadataStyles = this.normalizeStylesheet(new CompileStylesheetMetadata({
	              styles: templateMeta.styles,
	              styleUrls: templateMeta.styleUrls,
	              moduleUrl: directiveType.moduleUrl
	          }));
	          var visitor = new TemplatePreparseVisitor();
	          visitAll(visitor, rootNodesAndErrors.rootNodes);
	          var templateStyles = this.normalizeStylesheet(new CompileStylesheetMetadata({ styles: visitor.styles, styleUrls: visitor.styleUrls, moduleUrl: templateAbsUrl }));
	          var encapsulation = templateMeta.encapsulation;
	          if (isBlank(encapsulation)) {
	              encapsulation = this._config.defaultEncapsulation;
	          }
	          var styles = templateMetadataStyles.styles.concat(templateStyles.styles);
	          var styleUrls = templateMetadataStyles.styleUrls.concat(templateStyles.styleUrls);
	          if (encapsulation === _angular_core.ViewEncapsulation.Emulated && styles.length === 0 &&
	              styleUrls.length === 0) {
	              encapsulation = _angular_core.ViewEncapsulation.None;
	          }
	          return new CompileTemplateMetadata({
	              encapsulation: encapsulation,
	              template: template,
	              templateUrl: templateAbsUrl, styles: styles, styleUrls: styleUrls,
	              externalStylesheets: templateMeta.externalStylesheets,
	              ngContentSelectors: visitor.ngContentSelectors,
	              animations: templateMeta.animations,
	              interpolation: templateMeta.interpolation,
	          });
	      };
	      DirectiveNormalizer.prototype.normalizeExternalStylesheets = function (templateMeta) {
	          return this._loadMissingExternalStylesheets(templateMeta.styleUrls)
	              .then(function (externalStylesheets) { return new CompileTemplateMetadata({
	              encapsulation: templateMeta.encapsulation,
	              template: templateMeta.template,
	              templateUrl: templateMeta.templateUrl,
	              styles: templateMeta.styles,
	              styleUrls: templateMeta.styleUrls,
	              externalStylesheets: externalStylesheets,
	              ngContentSelectors: templateMeta.ngContentSelectors,
	              animations: templateMeta.animations,
	              interpolation: templateMeta.interpolation
	          }); });
	      };
	      DirectiveNormalizer.prototype._loadMissingExternalStylesheets = function (styleUrls, loadedStylesheets) {
	          var _this = this;
	          if (loadedStylesheets === void 0) { loadedStylesheets = new Map(); }
	          return Promise
	              .all(styleUrls.filter(function (styleUrl) { return !loadedStylesheets.has(styleUrl); })
	              .map(function (styleUrl) { return _this._fetch(styleUrl).then(function (loadedStyle) {
	              var stylesheet = _this.normalizeStylesheet(new CompileStylesheetMetadata({ styles: [loadedStyle], moduleUrl: styleUrl }));
	              loadedStylesheets.set(styleUrl, stylesheet);
	              return _this._loadMissingExternalStylesheets(stylesheet.styleUrls, loadedStylesheets);
	          }); }))
	              .then(function (_) { return MapWrapper.values(loadedStylesheets); });
	      };
	      DirectiveNormalizer.prototype.normalizeStylesheet = function (stylesheet) {
	          var _this = this;
	          var allStyleUrls = stylesheet.styleUrls.filter(isStyleUrlResolvable)
	              .map(function (url) { return _this._urlResolver.resolve(stylesheet.moduleUrl, url); });
	          var allStyles = stylesheet.styles.map(function (style) {
	              var styleWithImports = extractStyleUrls(_this._urlResolver, stylesheet.moduleUrl, style);
	              allStyleUrls.push.apply(allStyleUrls, styleWithImports.styleUrls);
	              return styleWithImports.style;
	          });
	          return new CompileStylesheetMetadata({ styles: allStyles, styleUrls: allStyleUrls, moduleUrl: stylesheet.moduleUrl });
	      };
	      DirectiveNormalizer.decorators = [
	          { type: _angular_core.Injectable },
	      ];
	      /** @nocollapse */
	      DirectiveNormalizer.ctorParameters = [
	          { type: ResourceLoader, },
	          { type: UrlResolver, },
	          { type: HtmlParser, },
	          { type: CompilerConfig, },
	      ];
	      return DirectiveNormalizer;
	  }());
	  var TemplatePreparseVisitor = (function () {
	      function TemplatePreparseVisitor() {
	          this.ngContentSelectors = [];
	          this.styles = [];
	          this.styleUrls = [];
	          this.ngNonBindableStackCount = 0;
	      }
	      TemplatePreparseVisitor.prototype.visitElement = function (ast, context) {
	          var preparsedElement = preparseElement(ast);
	          switch (preparsedElement.type) {
	              case PreparsedElementType.NG_CONTENT:
	                  if (this.ngNonBindableStackCount === 0) {
	                      this.ngContentSelectors.push(preparsedElement.selectAttr);
	                  }
	                  break;
	              case PreparsedElementType.STYLE:
	                  var textContent = '';
	                  ast.children.forEach(function (child) {
	                      if (child instanceof Text) {
	                          textContent += child.value;
	                      }
	                  });
	                  this.styles.push(textContent);
	                  break;
	              case PreparsedElementType.STYLESHEET:
	                  this.styleUrls.push(preparsedElement.hrefAttr);
	                  break;
	              default:
	                  break;
	          }
	          if (preparsedElement.nonBindable) {
	              this.ngNonBindableStackCount++;
	          }
	          visitAll(this, ast.children);
	          if (preparsedElement.nonBindable) {
	              this.ngNonBindableStackCount--;
	          }
	          return null;
	      };
	      TemplatePreparseVisitor.prototype.visitComment = function (ast, context) { return null; };
	      TemplatePreparseVisitor.prototype.visitAttribute = function (ast, context) { return null; };
	      TemplatePreparseVisitor.prototype.visitText = function (ast, context) { return null; };
	      TemplatePreparseVisitor.prototype.visitExpansion = function (ast, context) { return null; };
	      TemplatePreparseVisitor.prototype.visitExpansionCase = function (ast, context) { return null; };
	      return TemplatePreparseVisitor;
	  }());
	  function _cloneDirectiveWithTemplate(directive, template) {
	      return new CompileDirectiveMetadata({
	          type: directive.type,
	          isComponent: directive.isComponent,
	          selector: directive.selector,
	          exportAs: directive.exportAs,
	          changeDetection: directive.changeDetection,
	          inputs: directive.inputs,
	          outputs: directive.outputs,
	          hostListeners: directive.hostListeners,
	          hostProperties: directive.hostProperties,
	          hostAttributes: directive.hostAttributes,
	          providers: directive.providers,
	          viewProviders: directive.viewProviders,
	          queries: directive.queries,
	          viewQueries: directive.viewQueries,
	          entryComponents: directive.entryComponents, template: template,
	      });
	  }

	  /*
	   * Resolve a `Type` for {@link Directive}.
	   *
	   * This interface can be overridden by the application developer to create custom behavior.
	   *
	   * See {@link Compiler}
	   */
	  var DirectiveResolver = (function () {
	      function DirectiveResolver(_reflector) {
	          if (_reflector === void 0) { _reflector = reflector; }
	          this._reflector = _reflector;
	      }
	      /**
	       * Return {@link Directive} for a given `Type`.
	       */
	      DirectiveResolver.prototype.resolve = function (type, throwIfNotFound) {
	          if (throwIfNotFound === void 0) { throwIfNotFound = true; }
	          var typeMetadata = this._reflector.annotations(_angular_core.resolveForwardRef(type));
	          if (typeMetadata) {
	              var metadata = typeMetadata.find(isDirectiveMetadata);
	              if (metadata) {
	                  var propertyMetadata = this._reflector.propMetadata(type);
	                  return this._mergeWithPropertyMetadata(metadata, propertyMetadata, type);
	              }
	          }
	          if (throwIfNotFound) {
	              throw new Error("No Directive annotation found on " + stringify(type));
	          }
	          return null;
	      };
	      DirectiveResolver.prototype._mergeWithPropertyMetadata = function (dm, propertyMetadata, directiveType) {
	          var inputs = [];
	          var outputs = [];
	          var host = {};
	          var queries = {};
	          Object.keys(propertyMetadata).forEach(function (propName) {
	              propertyMetadata[propName].forEach(function (a) {
	                  if (a instanceof _angular_core.Input) {
	                      if (a.bindingPropertyName) {
	                          inputs.push(propName + ": " + a.bindingPropertyName);
	                      }
	                      else {
	                          inputs.push(propName);
	                      }
	                  }
	                  else if (a instanceof _angular_core.Output) {
	                      var output = a;
	                      if (output.bindingPropertyName) {
	                          outputs.push(propName + ": " + output.bindingPropertyName);
	                      }
	                      else {
	                          outputs.push(propName);
	                      }
	                  }
	                  else if (a instanceof _angular_core.HostBinding) {
	                      var hostBinding = a;
	                      if (hostBinding.hostPropertyName) {
	                          var startWith = hostBinding.hostPropertyName[0];
	                          if (startWith === '(') {
	                              throw new Error("@HostBinding can not bind to events. Use @HostListener instead.");
	                          }
	                          else if (startWith === '[') {
	                              throw new Error("@HostBinding parameter should be a property name, 'class.<name>', or 'attr.<name>'.");
	                          }
	                          host[("[" + hostBinding.hostPropertyName + "]")] = propName;
	                      }
	                      else {
	                          host[("[" + propName + "]")] = propName;
	                      }
	                  }
	                  else if (a instanceof _angular_core.HostListener) {
	                      var hostListener = a;
	                      var args = hostListener.args || [];
	                      host[("(" + hostListener.eventName + ")")] = propName + "(" + args.join(',') + ")";
	                  }
	                  else if (a instanceof _angular_core.Query) {
	                      queries[propName] = a;
	                  }
	              });
	          });
	          return this._merge(dm, inputs, outputs, host, queries, directiveType);
	      };
	      DirectiveResolver.prototype._extractPublicName = function (def) { return splitAtColon(def, [null, def])[1].trim(); };
	      DirectiveResolver.prototype._merge = function (directive, inputs, outputs, host, queries, directiveType) {
	          var _this = this;
	          var mergedInputs = inputs;
	          if (directive.inputs) {
	              var inputNames_1 = directive.inputs.map(function (def) { return _this._extractPublicName(def); });
	              inputs.forEach(function (inputDef) {
	                  var publicName = _this._extractPublicName(inputDef);
	                  if (inputNames_1.indexOf(publicName) > -1) {
	                      throw new Error("Input '" + publicName + "' defined multiple times in '" + stringify(directiveType) + "'");
	                  }
	              });
	              mergedInputs.unshift.apply(mergedInputs, directive.inputs);
	          }
	          var mergedOutputs = outputs;
	          if (directive.outputs) {
	              var outputNames_1 = directive.outputs.map(function (def) { return _this._extractPublicName(def); });
	              outputs.forEach(function (outputDef) {
	                  var publicName = _this._extractPublicName(outputDef);
	                  if (outputNames_1.indexOf(publicName) > -1) {
	                      throw new Error("Output event '" + publicName + "' defined multiple times in '" + stringify(directiveType) + "'");
	                  }
	              });
	              mergedOutputs.unshift.apply(mergedOutputs, directive.outputs);
	          }
	          var mergedHost = directive.host ? StringMapWrapper.merge(directive.host, host) : host;
	          var mergedQueries = directive.queries ? StringMapWrapper.merge(directive.queries, queries) : queries;
	          if (directive instanceof _angular_core.Component) {
	              return new _angular_core.Component({
	                  selector: directive.selector,
	                  inputs: mergedInputs,
	                  outputs: mergedOutputs,
	                  host: mergedHost,
	                  exportAs: directive.exportAs,
	                  moduleId: directive.moduleId,
	                  queries: mergedQueries,
	                  changeDetection: directive.changeDetection,
	                  providers: directive.providers,
	                  viewProviders: directive.viewProviders,
	                  entryComponents: directive.entryComponents,
	                  template: directive.template,
	                  templateUrl: directive.templateUrl,
	                  styles: directive.styles,
	                  styleUrls: directive.styleUrls,
	                  encapsulation: directive.encapsulation,
	                  animations: directive.animations,
	                  interpolation: directive.interpolation
	              });
	          }
	          else {
	              return new _angular_core.Directive({
	                  selector: directive.selector,
	                  inputs: mergedInputs,
	                  outputs: mergedOutputs,
	                  host: mergedHost,
	                  exportAs: directive.exportAs,
	                  queries: mergedQueries,
	                  providers: directive.providers
	              });
	          }
	      };
	      DirectiveResolver.decorators = [
	          { type: _angular_core.Injectable },
	      ];
	      /** @nocollapse */
	      DirectiveResolver.ctorParameters = [
	          { type: ReflectorReader, },
	      ];
	      return DirectiveResolver;
	  }());
	  function isDirectiveMetadata(type) {
	      return type instanceof _angular_core.Directive;
	  }

	  function hasLifecycleHook(hook, token) {
	      return reflector.hasLifecycleHook(token, getHookName(hook));
	  }
	  function getHookName(hook) {
	      switch (hook) {
	          case LifecycleHooks.OnInit:
	              return 'ngOnInit';
	          case LifecycleHooks.OnDestroy:
	              return 'ngOnDestroy';
	          case LifecycleHooks.DoCheck:
	              return 'ngDoCheck';
	          case LifecycleHooks.OnChanges:
	              return 'ngOnChanges';
	          case LifecycleHooks.AfterContentInit:
	              return 'ngAfterContentInit';
	          case LifecycleHooks.AfterContentChecked:
	              return 'ngAfterContentChecked';
	          case LifecycleHooks.AfterViewInit:
	              return 'ngAfterViewInit';
	          case LifecycleHooks.AfterViewChecked:
	              return 'ngAfterViewChecked';
	      }
	  }

	  function _isNgModuleMetadata(obj) {
	      return obj instanceof _angular_core.NgModule;
	  }
	  /**
	   * Resolves types to {@link NgModule}.
	   */
	  var NgModuleResolver = (function () {
	      function NgModuleResolver(_reflector) {
	          if (_reflector === void 0) { _reflector = reflector; }
	          this._reflector = _reflector;
	      }
	      NgModuleResolver.prototype.resolve = function (type, throwIfNotFound) {
	          if (throwIfNotFound === void 0) { throwIfNotFound = true; }
	          var ngModuleMeta = this._reflector.annotations(type).find(_isNgModuleMetadata);
	          if (isPresent(ngModuleMeta)) {
	              return ngModuleMeta;
	          }
	          else {
	              if (throwIfNotFound) {
	                  throw new Error("No NgModule metadata found for '" + stringify(type) + "'.");
	              }
	              return null;
	          }
	      };
	      NgModuleResolver.decorators = [
	          { type: _angular_core.Injectable },
	      ];
	      /** @nocollapse */
	      NgModuleResolver.ctorParameters = [
	          { type: ReflectorReader, },
	      ];
	      return NgModuleResolver;
	  }());

	  function _isPipeMetadata(type) {
	      return type instanceof _angular_core.Pipe;
	  }
	  /**
	   * Resolve a `Type` for {@link Pipe}.
	   *
	   * This interface can be overridden by the application developer to create custom behavior.
	   *
	   * See {@link Compiler}
	   */
	  var PipeResolver = (function () {
	      function PipeResolver(_reflector) {
	          if (_reflector === void 0) { _reflector = reflector; }
	          this._reflector = _reflector;
	      }
	      /**
	       * Return {@link Pipe} for a given `Type`.
	       */
	      PipeResolver.prototype.resolve = function (type, throwIfNotFound) {
	          if (throwIfNotFound === void 0) { throwIfNotFound = true; }
	          var metas = this._reflector.annotations(_angular_core.resolveForwardRef(type));
	          if (isPresent(metas)) {
	              var annotation = metas.find(_isPipeMetadata);
	              if (isPresent(annotation)) {
	                  return annotation;
	              }
	          }
	          if (throwIfNotFound) {
	              throw new Error("No Pipe decorator found on " + stringify(type));
	          }
	          return null;
	      };
	      PipeResolver.decorators = [
	          { type: _angular_core.Injectable },
	      ];
	      /** @nocollapse */
	      PipeResolver.ctorParameters = [
	          { type: ReflectorReader, },
	      ];
	      return PipeResolver;
	  }());

	  /**
	   * @license
	   * Copyright Google Inc. All Rights Reserved.
	   *
	   * Use of this source code is governed by an MIT-style license that can be
	   * found in the LICENSE file at https://angular.io/license
	   */
	  var __extends$17 = (this && this.__extends) || function (d, b) {
	      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	      function __() { this.constructor = d; }
	      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	  };
	  var CompileMetadataResolver = (function () {
	      function CompileMetadataResolver(_ngModuleResolver, _directiveResolver, _pipeResolver, _schemaRegistry, _reflector) {
	          if (_reflector === void 0) { _reflector = reflector; }
	          this._ngModuleResolver = _ngModuleResolver;
	          this._directiveResolver = _directiveResolver;
	          this._pipeResolver = _pipeResolver;
	          this._schemaRegistry = _schemaRegistry;
	          this._reflector = _reflector;
	          this._directiveCache = new Map();
	          this._pipeCache = new Map();
	          this._ngModuleCache = new Map();
	          this._ngModuleOfTypes = new Map();
	          this._anonymousTypes = new Map();
	          this._anonymousTypeIndex = 0;
	      }
	      CompileMetadataResolver.prototype.sanitizeTokenName = function (token) {
	          var identifier = stringify(token);
	          if (identifier.indexOf('(') >= 0) {
	              // case: anonymous functions!
	              var found = this._anonymousTypes.get(token);
	              if (!found) {
	                  this._anonymousTypes.set(token, this._anonymousTypeIndex++);
	                  found = this._anonymousTypes.get(token);
	              }
	              identifier = "anonymous_token_" + found + "_";
	          }
	          return sanitizeIdentifier(identifier);
	      };
	      CompileMetadataResolver.prototype.clearCacheFor = function (type) {
	          this._directiveCache.delete(type);
	          this._pipeCache.delete(type);
	          this._ngModuleOfTypes.delete(type);
	          // Clear all of the NgModule as they contain transitive information!
	          this._ngModuleCache.clear();
	      };
	      CompileMetadataResolver.prototype.clearCache = function () {
	          this._directiveCache.clear();
	          this._pipeCache.clear();
	          this._ngModuleCache.clear();
	          this._ngModuleOfTypes.clear();
	      };
	      CompileMetadataResolver.prototype.getAnimationEntryMetadata = function (entry) {
	          var _this = this;
	          var defs = entry.definitions.map(function (def) { return _this.getAnimationStateMetadata(def); });
	          return new CompileAnimationEntryMetadata(entry.name, defs);
	      };
	      CompileMetadataResolver.prototype.getAnimationStateMetadata = function (value) {
	          if (value instanceof _angular_core.AnimationStateDeclarationMetadata) {
	              var styles = this.getAnimationStyleMetadata(value.styles);
	              return new CompileAnimationStateDeclarationMetadata(value.stateNameExpr, styles);
	          }
	          if (value instanceof _angular_core.AnimationStateTransitionMetadata) {
	              return new CompileAnimationStateTransitionMetadata(value.stateChangeExpr, this.getAnimationMetadata(value.steps));
	          }
	          return null;
	      };
	      CompileMetadataResolver.prototype.getAnimationStyleMetadata = function (value) {
	          return new CompileAnimationStyleMetadata(value.offset, value.styles);
	      };
	      CompileMetadataResolver.prototype.getAnimationMetadata = function (value) {
	          var _this = this;
	          if (value instanceof _angular_core.AnimationStyleMetadata) {
	              return this.getAnimationStyleMetadata(value);
	          }
	          if (value instanceof _angular_core.AnimationKeyframesSequenceMetadata) {
	              return new CompileAnimationKeyframesSequenceMetadata(value.steps.map(function (entry) { return _this.getAnimationStyleMetadata(entry); }));
	          }
	          if (value instanceof _angular_core.AnimationAnimateMetadata) {
	              var animateData = this
	                  .getAnimationMetadata(value.styles);
	              return new CompileAnimationAnimateMetadata(value.timings, animateData);
	          }
	          if (value instanceof _angular_core.AnimationWithStepsMetadata) {
	              var steps = value.steps.map(function (step) { return _this.getAnimationMetadata(step); });
	              if (value instanceof _angular_core.AnimationGroupMetadata) {
	                  return new CompileAnimationGroupMetadata(steps);
	              }
	              return new CompileAnimationSequenceMetadata(steps);
	          }
	          return null;
	      };
	      CompileMetadataResolver.prototype.getDirectiveMetadata = function (directiveType, throwIfNotFound) {
	          var _this = this;
	          if (throwIfNotFound === void 0) { throwIfNotFound = true; }
	          directiveType = _angular_core.resolveForwardRef(directiveType);
	          var meta = this._directiveCache.get(directiveType);
	          if (!meta) {
	              var dirMeta = this._directiveResolver.resolve(directiveType, throwIfNotFound);
	              if (!dirMeta) {
	                  return null;
	              }
	              var templateMeta = null;
	              var changeDetectionStrategy = null;
	              var viewProviders = [];
	              var moduleUrl = staticTypeModuleUrl(directiveType);
	              var entryComponentMetadata = [];
	              var selector = dirMeta.selector;
	              if (dirMeta instanceof _angular_core.Component) {
	                  // Component
	                  assertArrayOfStrings('styles', dirMeta.styles);
	                  assertArrayOfStrings('styleUrls', dirMeta.styleUrls);
	                  assertInterpolationSymbols('interpolation', dirMeta.interpolation);
	                  var animations = dirMeta.animations ?
	                      dirMeta.animations.map(function (e) { return _this.getAnimationEntryMetadata(e); }) :
	                      null;
	                  templateMeta = new CompileTemplateMetadata({
	                      encapsulation: dirMeta.encapsulation,
	                      template: dirMeta.template,
	                      templateUrl: dirMeta.templateUrl,
	                      styles: dirMeta.styles,
	                      styleUrls: dirMeta.styleUrls,
	                      animations: animations,
	                      interpolation: dirMeta.interpolation
	                  });
	                  changeDetectionStrategy = dirMeta.changeDetection;
	                  if (dirMeta.viewProviders) {
	                      viewProviders = this.getProvidersMetadata(dirMeta.viewProviders, entryComponentMetadata, "viewProviders for \"" + stringify(directiveType) + "\"");
	                  }
	                  moduleUrl = componentModuleUrl(this._reflector, directiveType, dirMeta);
	                  if (dirMeta.entryComponents) {
	                      entryComponentMetadata =
	                          flattenArray(dirMeta.entryComponents)
	                              .map(function (type) { return _this.getTypeMetadata(type, staticTypeModuleUrl(type)); })
	                              .concat(entryComponentMetadata);
	                  }
	                  if (!selector) {
	                      selector = this._schemaRegistry.getDefaultComponentElementName();
	                  }
	              }
	              else {
	                  // Directive
	                  if (!selector) {
	                      throw new Error("Directive " + stringify(directiveType) + " has no selector, please add it!");
	                  }
	              }
	              var providers = [];
	              if (isPresent(dirMeta.providers)) {
	                  providers = this.getProvidersMetadata(dirMeta.providers, entryComponentMetadata, "providers for \"" + stringify(directiveType) + "\"");
	              }
	              var queries = [];
	              var viewQueries = [];
	              if (isPresent(dirMeta.queries)) {
	                  queries = this.getQueriesMetadata(dirMeta.queries, false, directiveType);
	                  viewQueries = this.getQueriesMetadata(dirMeta.queries, true, directiveType);
	              }
	              meta = CompileDirectiveMetadata.create({
	                  selector: selector,
	                  exportAs: dirMeta.exportAs,
	                  isComponent: !!templateMeta,
	                  type: this.getTypeMetadata(directiveType, moduleUrl),
	                  template: templateMeta,
	                  changeDetection: changeDetectionStrategy,
	                  inputs: dirMeta.inputs,
	                  outputs: dirMeta.outputs,
	                  host: dirMeta.host,
	                  providers: providers,
	                  viewProviders: viewProviders,
	                  queries: queries,
	                  viewQueries: viewQueries,
	                  entryComponents: entryComponentMetadata
	              });
	              this._directiveCache.set(directiveType, meta);
	          }
	          return meta;
	      };
	      CompileMetadataResolver.prototype.getNgModuleMetadata = function (moduleType, throwIfNotFound) {
	          var _this = this;
	          if (throwIfNotFound === void 0) { throwIfNotFound = true; }
	          moduleType = _angular_core.resolveForwardRef(moduleType);
	          var compileMeta = this._ngModuleCache.get(moduleType);
	          if (!compileMeta) {
	              var meta = this._ngModuleResolver.resolve(moduleType, throwIfNotFound);
	              if (!meta) {
	                  return null;
	              }
	              var declaredDirectives_1 = [];
	              var exportedDirectives_1 = [];
	              var declaredPipes_1 = [];
	              var exportedPipes_1 = [];
	              var importedModules_1 = [];
	              var exportedModules_1 = [];
	              var providers_1 = [];
	              var entryComponents_1 = [];
	              var bootstrapComponents = [];
	              var schemas = [];
	              if (meta.imports) {
	                  flattenArray(meta.imports).forEach(function (importedType) {
	                      var importedModuleType;
	                      if (isValidType(importedType)) {
	                          importedModuleType = importedType;
	                      }
	                      else if (importedType && importedType.ngModule) {
	                          var moduleWithProviders = importedType;
	                          importedModuleType = moduleWithProviders.ngModule;
	                          if (moduleWithProviders.providers) {
	                              providers_1.push.apply(providers_1, _this.getProvidersMetadata(moduleWithProviders.providers, entryComponents_1, "provider for the NgModule '" + stringify(importedModuleType) + "'"));
	                          }
	                      }
	                      if (importedModuleType) {
	                          var importedMeta = _this.getNgModuleMetadata(importedModuleType, false);
	                          if (importedMeta === null) {
	                              throw new Error("Unexpected " + _this._getTypeDescriptor(importedType) + " '" + stringify(importedType) + "' imported by the module '" + stringify(moduleType) + "'");
	                          }
	                          importedModules_1.push(importedMeta);
	                      }
	                      else {
	                          throw new Error("Unexpected value '" + stringify(importedType) + "' imported by the module '" + stringify(moduleType) + "'");
	                      }
	                  });
	              }
	              if (meta.exports) {
	                  flattenArray(meta.exports).forEach(function (exportedType) {
	                      if (!isValidType(exportedType)) {
	                          throw new Error("Unexpected value '" + stringify(exportedType) + "' exported by the module '" + stringify(moduleType) + "'");
	                      }
	                      var exportedDirMeta;
	                      var exportedPipeMeta;
	                      var exportedModuleMeta;
	                      if (exportedDirMeta = _this.getDirectiveMetadata(exportedType, false)) {
	                          exportedDirectives_1.push(exportedDirMeta);
	                      }
	                      else if (exportedPipeMeta = _this.getPipeMetadata(exportedType, false)) {
	                          exportedPipes_1.push(exportedPipeMeta);
	                      }
	                      else if (exportedModuleMeta = _this.getNgModuleMetadata(exportedType, false)) {
	                          exportedModules_1.push(exportedModuleMeta);
	                      }
	                      else {
	                          throw new Error("Unexpected " + _this._getTypeDescriptor(exportedType) + " '" + stringify(exportedType) + "' exported by the module '" + stringify(moduleType) + "'");
	                      }
	                  });
	              }
	              // Note: This will be modified later, so we rely on
	              // getting a new instance every time!
	              var transitiveModule_1 = this._getTransitiveNgModuleMetadata(importedModules_1, exportedModules_1);
	              if (meta.declarations) {
	                  flattenArray(meta.declarations).forEach(function (declaredType) {
	                      if (!isValidType(declaredType)) {
	                          throw new Error("Unexpected value '" + stringify(declaredType) + "' declared by the module '" + stringify(moduleType) + "'");
	                      }
	                      var declaredDirMeta;
	                      var declaredPipeMeta;
	                      if (declaredDirMeta = _this.getDirectiveMetadata(declaredType, false)) {
	                          _this._addDirectiveToModule(declaredDirMeta, moduleType, transitiveModule_1, declaredDirectives_1, true);
	                      }
	                      else if (declaredPipeMeta = _this.getPipeMetadata(declaredType, false)) {
	                          _this._addPipeToModule(declaredPipeMeta, moduleType, transitiveModule_1, declaredPipes_1, true);
	                      }
	                      else {
	                          throw new Error("Unexpected " + _this._getTypeDescriptor(declaredType) + " '" + stringify(declaredType) + "' declared by the module '" + stringify(moduleType) + "'");
	                      }
	                  });
	              }
	              // The providers of the module have to go last
	              // so that they overwrite any other provider we already added.
	              if (meta.providers) {
	                  providers_1.push.apply(providers_1, this.getProvidersMetadata(meta.providers, entryComponents_1, "provider for the NgModule '" + stringify(moduleType) + "'"));
	              }
	              if (meta.entryComponents) {
	                  entryComponents_1.push.apply(entryComponents_1, flattenArray(meta.entryComponents)
	                      .map(function (type) { return _this.getTypeMetadata(type, staticTypeModuleUrl(type)); }));
	              }
	              if (meta.bootstrap) {
	                  var typeMetadata = flattenArray(meta.bootstrap).map(function (type) {
	                      if (!isValidType(type)) {
	                          throw new Error("Unexpected value '" + stringify(type) + "' used in the bootstrap property of module '" + stringify(moduleType) + "'");
	                      }
	                      return _this.getTypeMetadata(type, staticTypeModuleUrl(type));
	                  });
	                  bootstrapComponents.push.apply(bootstrapComponents, typeMetadata);
	              }
	              entryComponents_1.push.apply(entryComponents_1, bootstrapComponents);
	              if (meta.schemas) {
	                  schemas.push.apply(schemas, flattenArray(meta.schemas));
	              }
	              (_a = transitiveModule_1.entryComponents).push.apply(_a, entryComponents_1);
	              (_b = transitiveModule_1.providers).push.apply(_b, providers_1);
	              compileMeta = new CompileNgModuleMetadata({
	                  type: this.getTypeMetadata(moduleType, staticTypeModuleUrl(moduleType)),
	                  providers: providers_1,
	                  entryComponents: entryComponents_1,
	                  bootstrapComponents: bootstrapComponents,
	                  schemas: schemas,
	                  declaredDirectives: declaredDirectives_1,
	                  exportedDirectives: exportedDirectives_1,
	                  declaredPipes: declaredPipes_1,
	                  exportedPipes: exportedPipes_1,
	                  importedModules: importedModules_1,
	                  exportedModules: exportedModules_1,
	                  transitiveModule: transitiveModule_1,
	                  id: meta.id,
	              });
	              transitiveModule_1.modules.push(compileMeta);
	              this._verifyModule(compileMeta);
	              this._ngModuleCache.set(moduleType, compileMeta);
	          }
	          return compileMeta;
	          var _a, _b;
	      };
	      CompileMetadataResolver.prototype._verifyModule = function (moduleMeta) {
	          moduleMeta.exportedDirectives.forEach(function (dirMeta) {
	              if (!moduleMeta.transitiveModule.directivesSet.has(dirMeta.type.reference)) {
	                  throw new Error("Can't export directive " + stringify(dirMeta.type.reference) + " from " + stringify(moduleMeta.type.reference) + " as it was neither declared nor imported!");
	              }
	          });
	          moduleMeta.exportedPipes.forEach(function (pipeMeta) {
	              if (!moduleMeta.transitiveModule.pipesSet.has(pipeMeta.type.reference)) {
	                  throw new Error("Can't export pipe " + stringify(pipeMeta.type.reference) + " from " + stringify(moduleMeta.type.reference) + " as it was neither declared nor imported!");
	              }
	          });
	      };
	      CompileMetadataResolver.prototype._getTypeDescriptor = function (type) {
	          if (this._directiveResolver.resolve(type, false)) {
	              return 'directive';
	          }
	          if (this._pipeResolver.resolve(type, false)) {
	              return 'pipe';
	          }
	          if (this._ngModuleResolver.resolve(type, false)) {
	              return 'module';
	          }
	          if (type.provide) {
	              return 'provider';
	          }
	          return 'value';
	      };
	      CompileMetadataResolver.prototype._addTypeToModule = function (type, moduleType) {
	          var oldModule = this._ngModuleOfTypes.get(type);
	          if (oldModule && oldModule !== moduleType) {
	              throw new Error(("Type " + stringify(type) + " is part of the declarations of 2 modules: " + stringify(oldModule) + " and " + stringify(moduleType) + "! ") +
	                  ("Please consider moving " + stringify(type) + " to a higher module that imports " + stringify(oldModule) + " and " + stringify(moduleType) + ". ") +
	                  ("You can also create a new NgModule that exports and includes " + stringify(type) + " then import that NgModule in " + stringify(oldModule) + " and " + stringify(moduleType) + "."));
	          }
	          this._ngModuleOfTypes.set(type, moduleType);
	      };
	      CompileMetadataResolver.prototype._getTransitiveNgModuleMetadata = function (importedModules, exportedModules) {
	          // collect `providers` / `entryComponents` from all imported and all exported modules
	          var transitiveModules = getTransitiveModules(importedModules.concat(exportedModules), true);
	          var providers = flattenArray(transitiveModules.map(function (ngModule) { return ngModule.providers; }));
	          var entryComponents = flattenArray(transitiveModules.map(function (ngModule) { return ngModule.entryComponents; }));
	          var transitiveExportedModules = getTransitiveModules(importedModules, false);
	          var directives = flattenArray(transitiveExportedModules.map(function (ngModule) { return ngModule.exportedDirectives; }));
	          var pipes = flattenArray(transitiveExportedModules.map(function (ngModule) { return ngModule.exportedPipes; }));
	          return new TransitiveCompileNgModuleMetadata(transitiveModules, providers, entryComponents, directives, pipes);
	      };
	      CompileMetadataResolver.prototype._addDirectiveToModule = function (dirMeta, moduleType, transitiveModule, declaredDirectives, force) {
	          if (force === void 0) { force = false; }
	          if (force || !transitiveModule.directivesSet.has(dirMeta.type.reference)) {
	              transitiveModule.directivesSet.add(dirMeta.type.reference);
	              transitiveModule.directives.push(dirMeta);
	              declaredDirectives.push(dirMeta);
	              this._addTypeToModule(dirMeta.type.reference, moduleType);
	              return true;
	          }
	          return false;
	      };
	      CompileMetadataResolver.prototype._addPipeToModule = function (pipeMeta, moduleType, transitiveModule, declaredPipes, force) {
	          if (force === void 0) { force = false; }
	          if (force || !transitiveModule.pipesSet.has(pipeMeta.type.reference)) {
	              transitiveModule.pipesSet.add(pipeMeta.type.reference);
	              transitiveModule.pipes.push(pipeMeta);
	              declaredPipes.push(pipeMeta);
	              this._addTypeToModule(pipeMeta.type.reference, moduleType);
	              return true;
	          }
	          return false;
	      };
	      CompileMetadataResolver.prototype.getTypeMetadata = function (type, moduleUrl, dependencies) {
	          if (dependencies === void 0) { dependencies = null; }
	          type = _angular_core.resolveForwardRef(type);
	          return new CompileTypeMetadata({
	              name: this.sanitizeTokenName(type),
	              moduleUrl: moduleUrl,
	              reference: type,
	              diDeps: this.getDependenciesMetadata(type, dependencies),
	              lifecycleHooks: LIFECYCLE_HOOKS_VALUES.filter(function (hook) { return hasLifecycleHook(hook, type); }),
	          });
	      };
	      CompileMetadataResolver.prototype.getFactoryMetadata = function (factory, moduleUrl, dependencies) {
	          if (dependencies === void 0) { dependencies = null; }
	          factory = _angular_core.resolveForwardRef(factory);
	          return new CompileFactoryMetadata({
	              name: this.sanitizeTokenName(factory),
	              moduleUrl: moduleUrl,
	              reference: factory,
	              diDeps: this.getDependenciesMetadata(factory, dependencies)
	          });
	      };
	      CompileMetadataResolver.prototype.getPipeMetadata = function (pipeType, throwIfNotFound) {
	          if (throwIfNotFound === void 0) { throwIfNotFound = true; }
	          pipeType = _angular_core.resolveForwardRef(pipeType);
	          var meta = this._pipeCache.get(pipeType);
	          if (!meta) {
	              var pipeMeta = this._pipeResolver.resolve(pipeType, throwIfNotFound);
	              if (!pipeMeta) {
	                  return null;
	              }
	              meta = new CompilePipeMetadata({
	                  type: this.getTypeMetadata(pipeType, staticTypeModuleUrl(pipeType)),
	                  name: pipeMeta.name,
	                  pure: pipeMeta.pure
	              });
	              this._pipeCache.set(pipeType, meta);
	          }
	          return meta;
	      };
	      CompileMetadataResolver.prototype.getDependenciesMetadata = function (typeOrFunc, dependencies) {
	          var _this = this;
	          var hasUnknownDeps = false;
	          var params = dependencies || this._reflector.parameters(typeOrFunc) || [];
	          var dependenciesMetadata = params.map(function (param) {
	              var isAttribute = false;
	              var isHost = false;
	              var isSelf = false;
	              var isSkipSelf = false;
	              var isOptional = false;
	              var query = null;
	              var viewQuery = null;
	              var token = null;
	              if (Array.isArray(param)) {
	                  param.forEach(function (paramEntry) {
	                      if (paramEntry instanceof _angular_core.Host) {
	                          isHost = true;
	                      }
	                      else if (paramEntry instanceof _angular_core.Self) {
	                          isSelf = true;
	                      }
	                      else if (paramEntry instanceof _angular_core.SkipSelf) {
	                          isSkipSelf = true;
	                      }
	                      else if (paramEntry instanceof _angular_core.Optional) {
	                          isOptional = true;
	                      }
	                      else if (paramEntry instanceof _angular_core.Attribute) {
	                          isAttribute = true;
	                          token = paramEntry.attributeName;
	                      }
	                      else if (paramEntry instanceof _angular_core.Query) {
	                          if (paramEntry.isViewQuery) {
	                              viewQuery = paramEntry;
	                          }
	                          else {
	                              query = paramEntry;
	                          }
	                      }
	                      else if (paramEntry instanceof _angular_core.Inject) {
	                          token = paramEntry.token;
	                      }
	                      else if (isValidType(paramEntry) && isBlank(token)) {
	                          token = paramEntry;
	                      }
	                  });
	              }
	              else {
	                  token = param;
	              }
	              if (isBlank(token)) {
	                  hasUnknownDeps = true;
	                  return null;
	              }
	              return new CompileDiDependencyMetadata({
	                  isAttribute: isAttribute,
	                  isHost: isHost,
	                  isSelf: isSelf,
	                  isSkipSelf: isSkipSelf,
	                  isOptional: isOptional,
	                  query: query ? _this.getQueryMetadata(query, null, typeOrFunc) : null,
	                  viewQuery: viewQuery ? _this.getQueryMetadata(viewQuery, null, typeOrFunc) : null,
	                  token: _this.getTokenMetadata(token)
	              });
	          });
	          if (hasUnknownDeps) {
	              var depsTokens = dependenciesMetadata.map(function (dep) { return dep ? stringify(dep.token) : '?'; }).join(', ');
	              throw new Error("Can't resolve all parameters for " + stringify(typeOrFunc) + ": (" + depsTokens + ").");
	          }
	          return dependenciesMetadata;
	      };
	      CompileMetadataResolver.prototype.getTokenMetadata = function (token) {
	          token = _angular_core.resolveForwardRef(token);
	          var compileToken;
	          if (typeof token === 'string') {
	              compileToken = new CompileTokenMetadata({ value: token });
	          }
	          else {
	              compileToken = new CompileTokenMetadata({
	                  identifier: new CompileIdentifierMetadata({
	                      reference: token,
	                      name: this.sanitizeTokenName(token),
	                      moduleUrl: staticTypeModuleUrl(token)
	                  })
	              });
	          }
	          return compileToken;
	      };
	      CompileMetadataResolver.prototype.getProvidersMetadata = function (providers, targetEntryComponents, debugInfo) {
	          var _this = this;
	          var compileProviders = [];
	          providers.forEach(function (provider, providerIdx) {
	              provider = _angular_core.resolveForwardRef(provider);
	              if (provider && typeof provider == 'object' && provider.hasOwnProperty('provide')) {
	                  provider = new ProviderMeta(provider.provide, provider);
	              }
	              var compileProvider;
	              if (Array.isArray(provider)) {
	                  compileProvider = _this.getProvidersMetadata(provider, targetEntryComponents, debugInfo);
	              }
	              else if (provider instanceof ProviderMeta) {
	                  var tokenMeta = _this.getTokenMetadata(provider.token);
	                  if (tokenMeta.reference ===
	                      resolveIdentifierToken(Identifiers.ANALYZE_FOR_ENTRY_COMPONENTS).reference) {
	                      targetEntryComponents.push.apply(targetEntryComponents, _this._getEntryComponentsFromProvider(provider));
	                  }
	                  else {
	                      compileProvider = _this.getProviderMetadata(provider);
	                  }
	              }
	              else if (isValidType(provider)) {
	                  compileProvider = _this.getTypeMetadata(provider, staticTypeModuleUrl(provider));
	              }
	              else {
	                  var providersInfo = providers.reduce(function (soFar, seenProvider, seenProviderIdx) {
	                      if (seenProviderIdx < providerIdx) {
	                          soFar.push("" + stringify(seenProvider));
	                      }
	                      else if (seenProviderIdx == providerIdx) {
	                          soFar.push("?" + stringify(seenProvider) + "?");
	                      }
	                      else if (seenProviderIdx == providerIdx + 1) {
	                          soFar.push('...');
	                      }
	                      return soFar;
	                  }, [])
	                      .join(', ');
	                  throw new Error("Invalid " + (debugInfo ? debugInfo : 'provider') + " - only instances of Provider and Type are allowed, got: [" + providersInfo + "]");
	              }
	              if (compileProvider) {
	                  compileProviders.push(compileProvider);
	              }
	          });
	          return compileProviders;
	      };
	      CompileMetadataResolver.prototype._getEntryComponentsFromProvider = function (provider) {
	          var _this = this;
	          var components = [];
	          var collectedIdentifiers = [];
	          if (provider.useFactory || provider.useExisting || provider.useClass) {
	              throw new Error("The ANALYZE_FOR_ENTRY_COMPONENTS token only supports useValue!");
	          }
	          if (!provider.multi) {
	              throw new Error("The ANALYZE_FOR_ENTRY_COMPONENTS token only supports 'multi = true'!");
	          }
	          convertToCompileValue(provider.useValue, collectedIdentifiers);
	          collectedIdentifiers.forEach(function (identifier) {
	              var dirMeta = _this.getDirectiveMetadata(identifier.reference, false);
	              if (dirMeta) {
	                  components.push(dirMeta.type);
	              }
	          });
	          return components;
	      };
	      CompileMetadataResolver.prototype.getProviderMetadata = function (provider) {
	          var compileDeps;
	          var compileTypeMetadata = null;
	          var compileFactoryMetadata = null;
	          if (provider.useClass) {
	              compileTypeMetadata = this.getTypeMetadata(provider.useClass, staticTypeModuleUrl(provider.useClass), provider.dependencies);
	              compileDeps = compileTypeMetadata.diDeps;
	          }
	          else if (provider.useFactory) {
	              compileFactoryMetadata = this.getFactoryMetadata(provider.useFactory, staticTypeModuleUrl(provider.useFactory), provider.dependencies);
	              compileDeps = compileFactoryMetadata.diDeps;
	          }
	          return new CompileProviderMetadata({
	              token: this.getTokenMetadata(provider.token),
	              useClass: compileTypeMetadata,
	              useValue: convertToCompileValue(provider.useValue, []),
	              useFactory: compileFactoryMetadata,
	              useExisting: provider.useExisting ? this.getTokenMetadata(provider.useExisting) : null,
	              deps: compileDeps,
	              multi: provider.multi
	          });
	      };
	      CompileMetadataResolver.prototype.getQueriesMetadata = function (queries, isViewQuery, directiveType) {
	          var _this = this;
	          var res = [];
	          Object.keys(queries).forEach(function (propertyName) {
	              var query = queries[propertyName];
	              if (query.isViewQuery === isViewQuery) {
	                  res.push(_this.getQueryMetadata(query, propertyName, directiveType));
	              }
	          });
	          return res;
	      };
	      CompileMetadataResolver.prototype._queryVarBindings = function (selector) { return selector.split(/\s*,\s*/); };
	      CompileMetadataResolver.prototype.getQueryMetadata = function (q, propertyName, typeOrFunc) {
	          var _this = this;
	          var selectors;
	          if (typeof q.selector === 'string') {
	              selectors = this._queryVarBindings(q.selector).map(function (varName) { return _this.getTokenMetadata(varName); });
	          }
	          else {
	              if (!q.selector) {
	                  throw new Error("Can't construct a query for the property \"" + propertyName + "\" of \"" + stringify(typeOrFunc) + "\" since the query selector wasn't defined.");
	              }
	              selectors = [this.getTokenMetadata(q.selector)];
	          }
	          return new CompileQueryMetadata({
	              selectors: selectors,
	              first: q.first,
	              descendants: q.descendants, propertyName: propertyName,
	              read: q.read ? this.getTokenMetadata(q.read) : null
	          });
	      };
	      CompileMetadataResolver.decorators = [
	          { type: _angular_core.Injectable },
	      ];
	      /** @nocollapse */
	      CompileMetadataResolver.ctorParameters = [
	          { type: NgModuleResolver, },
	          { type: DirectiveResolver, },
	          { type: PipeResolver, },
	          { type: ElementSchemaRegistry, },
	          { type: ReflectorReader, },
	      ];
	      return CompileMetadataResolver;
	  }());
	  function getTransitiveModules(modules, includeImports, targetModules, visitedModules) {
	      if (targetModules === void 0) { targetModules = []; }
	      if (visitedModules === void 0) { visitedModules = new Set(); }
	      modules.forEach(function (ngModule) {
	          if (!visitedModules.has(ngModule.type.reference)) {
	              visitedModules.add(ngModule.type.reference);
	              var nestedModules = includeImports ?
	                  ngModule.importedModules.concat(ngModule.exportedModules) :
	                  ngModule.exportedModules;
	              getTransitiveModules(nestedModules, includeImports, targetModules, visitedModules);
	              // Add after recursing so imported/exported modules are before the module itself.
	              // This is important for overwriting providers of imported modules!
	              targetModules.push(ngModule);
	          }
	      });
	      return targetModules;
	  }
	  function flattenArray(tree, out) {
	      if (out === void 0) { out = []; }
	      if (tree) {
	          for (var i = 0; i < tree.length; i++) {
	              var item = _angular_core.resolveForwardRef(tree[i]);
	              if (Array.isArray(item)) {
	                  flattenArray(item, out);
	              }
	              else {
	                  out.push(item);
	              }
	          }
	      }
	      return out;
	  }
	  function isValidType(value) {
	      return isStaticSymbol(value) || (value instanceof _angular_core.Type);
	  }
	  function staticTypeModuleUrl(value) {
	      return isStaticSymbol(value) ? value.filePath : null;
	  }
	  function componentModuleUrl(reflector, type, cmpMetadata) {
	      if (isStaticSymbol(type)) {
	          return staticTypeModuleUrl(type);
	      }
	      var moduleId = cmpMetadata.moduleId;
	      if (typeof moduleId === 'string') {
	          var scheme = getUrlScheme(moduleId);
	          return scheme ? moduleId : "package:" + moduleId + MODULE_SUFFIX;
	      }
	      else if (moduleId !== null && moduleId !== void 0) {
	          throw new Error(("moduleId should be a string in \"" + stringify(type) + "\". See https://goo.gl/wIDDiL for more information.\n") +
	              "If you're using Webpack you should inline the template and the styles, see https://goo.gl/X2J8zc.");
	      }
	      return reflector.importUri(type);
	  }
	  function convertToCompileValue(value, targetIdentifiers) {
	      return visitValue(value, new _CompileValueConverter(), targetIdentifiers);
	  }
	  var _CompileValueConverter = (function (_super) {
	      __extends$17(_CompileValueConverter, _super);
	      function _CompileValueConverter() {
	          _super.apply(this, arguments);
	      }
	      _CompileValueConverter.prototype.visitOther = function (value, targetIdentifiers) {
	          var identifier;
	          if (isStaticSymbol(value)) {
	              identifier = new CompileIdentifierMetadata({ name: value.name, moduleUrl: value.filePath, reference: value });
	          }
	          else {
	              identifier = new CompileIdentifierMetadata({ reference: value });
	          }
	          targetIdentifiers.push(identifier);
	          return identifier;
	      };
	      return _CompileValueConverter;
	  }(ValueTransformer));

	  var ComponentFactoryDependency$1 = (function () {
	      function ComponentFactoryDependency(comp, placeholder) {
	          this.comp = comp;
	          this.placeholder = placeholder;
	      }
	      return ComponentFactoryDependency;
	  }());
	  var NgModuleCompileResult = (function () {
	      function NgModuleCompileResult(statements, ngModuleFactoryVar, dependencies) {
	          this.statements = statements;
	          this.ngModuleFactoryVar = ngModuleFactoryVar;
	          this.dependencies = dependencies;
	      }
	      return NgModuleCompileResult;
	  }());
	  var NgModuleCompiler = (function () {
	      function NgModuleCompiler() {
	      }
	      NgModuleCompiler.prototype.compile = function (ngModuleMeta, extraProviders) {
	          var sourceFileName = isPresent(ngModuleMeta.type.moduleUrl) ?
	              "in NgModule " + ngModuleMeta.type.name + " in " + ngModuleMeta.type.moduleUrl :
	              "in NgModule " + ngModuleMeta.type.name;
	          var sourceFile = new ParseSourceFile('', sourceFileName);
	          var sourceSpan = new ParseSourceSpan(new ParseLocation(sourceFile, null, null, null), new ParseLocation(sourceFile, null, null, null));
	          var deps = [];
	          var bootstrapComponentFactories = [];
	          var entryComponentFactories = ngModuleMeta.transitiveModule.entryComponents.map(function (entryComponent) {
	              var id = new CompileIdentifierMetadata({ name: entryComponent.name });
	              if (ngModuleMeta.bootstrapComponents.indexOf(entryComponent) > -1) {
	                  bootstrapComponentFactories.push(id);
	              }
	              deps.push(new ComponentFactoryDependency$1(entryComponent, id));
	              return id;
	          });
	          var builder = new _InjectorBuilder(ngModuleMeta, entryComponentFactories, bootstrapComponentFactories, sourceSpan);
	          var providerParser = new NgModuleProviderAnalyzer(ngModuleMeta, extraProviders, sourceSpan);
	          providerParser.parse().forEach(function (provider) { return builder.addProvider(provider); });
	          var injectorClass = builder.build();
	          var ngModuleFactoryVar = ngModuleMeta.type.name + "NgFactory";
	          var ngModuleFactoryStmt = variable(ngModuleFactoryVar)
	              .set(importExpr(resolveIdentifier(Identifiers.NgModuleFactory))
	              .instantiate([variable(injectorClass.name), importExpr(ngModuleMeta.type)], importType(resolveIdentifier(Identifiers.NgModuleFactory), [importType(ngModuleMeta.type)], [TypeModifier.Const])))
	              .toDeclStmt(null, [StmtModifier.Final]);
	          var stmts = [injectorClass, ngModuleFactoryStmt];
	          if (ngModuleMeta.id) {
	              var registerFactoryStmt = importExpr(resolveIdentifier(Identifiers.RegisterModuleFactoryFn))
	                  .callFn([literal(ngModuleMeta.id), variable(ngModuleFactoryVar)])
	                  .toStmt();
	              stmts.push(registerFactoryStmt);
	          }
	          return new NgModuleCompileResult(stmts, ngModuleFactoryVar, deps);
	      };
	      NgModuleCompiler.decorators = [
	          { type: _angular_core.Injectable },
	      ];
	      /** @nocollapse */
	      NgModuleCompiler.ctorParameters = [];
	      return NgModuleCompiler;
	  }());
	  var _InjectorBuilder = (function () {
	      function _InjectorBuilder(_ngModuleMeta, _entryComponentFactories, _bootstrapComponentFactories, _sourceSpan) {
	          this._ngModuleMeta = _ngModuleMeta;
	          this._entryComponentFactories = _entryComponentFactories;
	          this._bootstrapComponentFactories = _bootstrapComponentFactories;
	          this._sourceSpan = _sourceSpan;
	          this.fields = [];
	          this.getters = [];
	          this.methods = [];
	          this.ctorStmts = [];
	          this._tokens = [];
	          this._instances = new Map();
	          this._createStmts = [];
	          this._destroyStmts = [];
	      }
	      _InjectorBuilder.prototype.addProvider = function (resolvedProvider) {
	          var _this = this;
	          var providerValueExpressions = resolvedProvider.providers.map(function (provider) { return _this._getProviderValue(provider); });
	          var propName = "_" + resolvedProvider.token.name + "_" + this._instances.size;
	          var instance = this._createProviderProperty(propName, resolvedProvider, providerValueExpressions, resolvedProvider.multiProvider, resolvedProvider.eager);
	          if (resolvedProvider.lifecycleHooks.indexOf(LifecycleHooks.OnDestroy) !== -1) {
	              this._destroyStmts.push(instance.callMethod('ngOnDestroy', []).toStmt());
	          }
	          this._tokens.push(resolvedProvider.token);
	          this._instances.set(resolvedProvider.token.reference, instance);
	      };
	      _InjectorBuilder.prototype.build = function () {
	          var _this = this;
	          var getMethodStmts = this._tokens.map(function (token) {
	              var providerExpr = _this._instances.get(token.reference);
	              return new IfStmt(InjectMethodVars$1.token.identical(createDiTokenExpression(token)), [new ReturnStatement(providerExpr)]);
	          });
	          var methods = [
	              new ClassMethod('createInternal', [], this._createStmts.concat(new ReturnStatement(this._instances.get(this._ngModuleMeta.type.reference))), importType(this._ngModuleMeta.type)),
	              new ClassMethod('getInternal', [
	                  new FnParam(InjectMethodVars$1.token.name, DYNAMIC_TYPE),
	                  new FnParam(InjectMethodVars$1.notFoundResult.name, DYNAMIC_TYPE)
	              ], getMethodStmts.concat([new ReturnStatement(InjectMethodVars$1.notFoundResult)]), DYNAMIC_TYPE),
	              new ClassMethod('destroyInternal', [], this._destroyStmts),
	          ];
	          var parentArgs = [
	              variable(InjectorProps.parent.name),
	              literalArr(this._entryComponentFactories.map(function (componentFactory) { return importExpr(componentFactory); })),
	              literalArr(this._bootstrapComponentFactories.map(function (componentFactory) { return importExpr(componentFactory); }))
	          ];
	          var injClassName = this._ngModuleMeta.type.name + "Injector";
	          return createClassStmt({
	              name: injClassName,
	              ctorParams: [new FnParam(InjectorProps.parent.name, importType(resolveIdentifier(Identifiers.Injector)))],
	              parent: importExpr(resolveIdentifier(Identifiers.NgModuleInjector), [importType(this._ngModuleMeta.type)]),
	              parentArgs: parentArgs,
	              builders: [{ methods: methods }, this]
	          });
	      };
	      _InjectorBuilder.prototype._getProviderValue = function (provider) {
	          var _this = this;
	          var result;
	          if (isPresent(provider.useExisting)) {
	              result = this._getDependency(new CompileDiDependencyMetadata({ token: provider.useExisting }));
	          }
	          else if (isPresent(provider.useFactory)) {
	              var deps = provider.deps || provider.useFactory.diDeps;
	              var depsExpr = deps.map(function (dep) { return _this._getDependency(dep); });
	              result = importExpr(provider.useFactory).callFn(depsExpr);
	          }
	          else if (isPresent(provider.useClass)) {
	              var deps = provider.deps || provider.useClass.diDeps;
	              var depsExpr = deps.map(function (dep) { return _this._getDependency(dep); });
	              result =
	                  importExpr(provider.useClass).instantiate(depsExpr, importType(provider.useClass));
	          }
	          else {
	              result = convertValueToOutputAst(provider.useValue);
	          }
	          return result;
	      };
	      _InjectorBuilder.prototype._createProviderProperty = function (propName, provider, providerValueExpressions, isMulti, isEager) {
	          var resolvedProviderValueExpr;
	          var type;
	          if (isMulti) {
	              resolvedProviderValueExpr = literalArr(providerValueExpressions);
	              type = new ArrayType(DYNAMIC_TYPE);
	          }
	          else {
	              resolvedProviderValueExpr = providerValueExpressions[0];
	              type = providerValueExpressions[0].type;
	          }
	          if (!type) {
	              type = DYNAMIC_TYPE;
	          }
	          if (isEager) {
	              this.fields.push(new ClassField(propName, type));
	              this._createStmts.push(THIS_EXPR.prop(propName).set(resolvedProviderValueExpr).toStmt());
	          }
	          else {
	              var internalField = "_" + propName;
	              this.fields.push(new ClassField(internalField, type));
	              // Note: Equals is important for JS so that it also checks the undefined case!
	              var getterStmts = [
	                  new IfStmt(THIS_EXPR.prop(internalField).isBlank(), [THIS_EXPR.prop(internalField).set(resolvedProviderValueExpr).toStmt()]),
	                  new ReturnStatement(THIS_EXPR.prop(internalField))
	              ];
	              this.getters.push(new ClassGetter(propName, getterStmts, type));
	          }
	          return THIS_EXPR.prop(propName);
	      };
	      _InjectorBuilder.prototype._getDependency = function (dep) {
	          var result = null;
	          if (dep.isValue) {
	              result = literal(dep.value);
	          }
	          if (!dep.isSkipSelf) {
	              if (dep.token &&
	                  (dep.token.reference === resolveIdentifierToken(Identifiers.Injector).reference ||
	                      dep.token.reference ===
	                          resolveIdentifierToken(Identifiers.ComponentFactoryResolver).reference)) {
	                  result = THIS_EXPR;
	              }
	              if (!result) {
	                  result = this._instances.get(dep.token.reference);
	              }
	          }
	          if (!result) {
	              var args = [createDiTokenExpression(dep.token)];
	              if (dep.isOptional) {
	                  args.push(NULL_EXPR);
	              }
	              result = InjectorProps.parent.callMethod('get', args);
	          }
	          return result;
	      };
	      return _InjectorBuilder;
	  }());
	  var InjectorProps = (function () {
	      function InjectorProps() {
	      }
	      InjectorProps.parent = THIS_EXPR.prop('parent');
	      return InjectorProps;
	  }());
	  var InjectMethodVars$1 = (function () {
	      function InjectMethodVars() {
	      }
	      InjectMethodVars.token = variable('token');
	      InjectMethodVars.notFoundResult = variable('notFoundResult');
	      return InjectMethodVars;
	  }());

	  var _SINGLE_QUOTE_ESCAPE_STRING_RE = /'|\\|\n|\r|\$/g;
	  var _LEGAL_IDENTIFIER_RE = /^[$A-Z_][0-9A-Z_$]*$/i;
	  var CATCH_ERROR_VAR$2 = variable('error');
	  var CATCH_STACK_VAR$2 = variable('stack');
	  var _EmittedLine = (function () {
	      function _EmittedLine(indent) {
	          this.indent = indent;
	          this.parts = [];
	      }
	      return _EmittedLine;
	  }());
	  var EmitterVisitorContext = (function () {
	      function EmitterVisitorContext(_exportedVars, _indent) {
	          this._exportedVars = _exportedVars;
	          this._indent = _indent;
	          this._classes = [];
	          this._lines = [new _EmittedLine(_indent)];
	      }
	      EmitterVisitorContext.createRoot = function (exportedVars) {
	          return new EmitterVisitorContext(exportedVars, 0);
	      };
	      Object.defineProperty(EmitterVisitorContext.prototype, "_currentLine", {
	          get: function () { return this._lines[this._lines.length - 1]; },
	          enumerable: true,
	          configurable: true
	      });
	      EmitterVisitorContext.prototype.isExportedVar = function (varName) { return this._exportedVars.indexOf(varName) !== -1; };
	      EmitterVisitorContext.prototype.println = function (lastPart) {
	          if (lastPart === void 0) { lastPart = ''; }
	          this.print(lastPart, true);
	      };
	      EmitterVisitorContext.prototype.lineIsEmpty = function () { return this._currentLine.parts.length === 0; };
	      EmitterVisitorContext.prototype.print = function (part, newLine) {
	          if (newLine === void 0) { newLine = false; }
	          if (part.length > 0) {
	              this._currentLine.parts.push(part);
	          }
	          if (newLine) {
	              this._lines.push(new _EmittedLine(this._indent));
	          }
	      };
	      EmitterVisitorContext.prototype.removeEmptyLastLine = function () {
	          if (this.lineIsEmpty()) {
	              this._lines.pop();
	          }
	      };
	      EmitterVisitorContext.prototype.incIndent = function () {
	          this._indent++;
	          this._currentLine.indent = this._indent;
	      };
	      EmitterVisitorContext.prototype.decIndent = function () {
	          this._indent--;
	          this._currentLine.indent = this._indent;
	      };
	      EmitterVisitorContext.prototype.pushClass = function (clazz) { this._classes.push(clazz); };
	      EmitterVisitorContext.prototype.popClass = function () { return this._classes.pop(); };
	      Object.defineProperty(EmitterVisitorContext.prototype, "currentClass", {
	          get: function () {
	              return this._classes.length > 0 ? this._classes[this._classes.length - 1] : null;
	          },
	          enumerable: true,
	          configurable: true
	      });
	      EmitterVisitorContext.prototype.toSource = function () {
	          var lines = this._lines;
	          if (lines[lines.length - 1].parts.length === 0) {
	              lines = lines.slice(0, lines.length - 1);
	          }
	          return lines
	              .map(function (line) {
	              if (line.parts.length > 0) {
	                  return _createIndent(line.indent) + line.parts.join('');
	              }
	              else {
	                  return '';
	              }
	          })
	              .join('\n');
	      };
	      return EmitterVisitorContext;
	  }());
	  var AbstractEmitterVisitor = (function () {
	      function AbstractEmitterVisitor(_escapeDollarInStrings) {
	          this._escapeDollarInStrings = _escapeDollarInStrings;
	      }
	      AbstractEmitterVisitor.prototype.visitExpressionStmt = function (stmt, ctx) {
	          stmt.expr.visitExpression(this, ctx);
	          ctx.println(';');
	          return null;
	      };
	      AbstractEmitterVisitor.prototype.visitReturnStmt = function (stmt, ctx) {
	          ctx.print("return ");
	          stmt.value.visitExpression(this, ctx);
	          ctx.println(';');
	          return null;
	      };
	      AbstractEmitterVisitor.prototype.visitIfStmt = function (stmt, ctx) {
	          ctx.print("if (");
	          stmt.condition.visitExpression(this, ctx);
	          ctx.print(") {");
	          var hasElseCase = isPresent(stmt.falseCase) && stmt.falseCase.length > 0;
	          if (stmt.trueCase.length <= 1 && !hasElseCase) {
	              ctx.print(" ");
	              this.visitAllStatements(stmt.trueCase, ctx);
	              ctx.removeEmptyLastLine();
	              ctx.print(" ");
	          }
	          else {
	              ctx.println();
	              ctx.incIndent();
	              this.visitAllStatements(stmt.trueCase, ctx);
	              ctx.decIndent();
	              if (hasElseCase) {
	                  ctx.println("} else {");
	                  ctx.incIndent();
	                  this.visitAllStatements(stmt.falseCase, ctx);
	                  ctx.decIndent();
	              }
	          }
	          ctx.println("}");
	          return null;
	      };
	      AbstractEmitterVisitor.prototype.visitThrowStmt = function (stmt, ctx) {
	          ctx.print("throw ");
	          stmt.error.visitExpression(this, ctx);
	          ctx.println(";");
	          return null;
	      };
	      AbstractEmitterVisitor.prototype.visitCommentStmt = function (stmt, ctx) {
	          var lines = stmt.comment.split('\n');
	          lines.forEach(function (line) { ctx.println("// " + line); });
	          return null;
	      };
	      AbstractEmitterVisitor.prototype.visitWriteVarExpr = function (expr, ctx) {
	          var lineWasEmpty = ctx.lineIsEmpty();
	          if (!lineWasEmpty) {
	              ctx.print('(');
	          }
	          ctx.print(expr.name + " = ");
	          expr.value.visitExpression(this, ctx);
	          if (!lineWasEmpty) {
	              ctx.print(')');
	          }
	          return null;
	      };
	      AbstractEmitterVisitor.prototype.visitWriteKeyExpr = function (expr, ctx) {
	          var lineWasEmpty = ctx.lineIsEmpty();
	          if (!lineWasEmpty) {
	              ctx.print('(');
	          }
	          expr.receiver.visitExpression(this, ctx);
	          ctx.print("[");
	          expr.index.visitExpression(this, ctx);
	          ctx.print("] = ");
	          expr.value.visitExpression(this, ctx);
	          if (!lineWasEmpty) {
	              ctx.print(')');
	          }
	          return null;
	      };
	      AbstractEmitterVisitor.prototype.visitWritePropExpr = function (expr, ctx) {
	          var lineWasEmpty = ctx.lineIsEmpty();
	          if (!lineWasEmpty) {
	              ctx.print('(');
	          }
	          expr.receiver.visitExpression(this, ctx);
	          ctx.print("." + expr.name + " = ");
	          expr.value.visitExpression(this, ctx);
	          if (!lineWasEmpty) {
	              ctx.print(')');
	          }
	          return null;
	      };
	      AbstractEmitterVisitor.prototype.visitInvokeMethodExpr = function (expr, ctx) {
	          expr.receiver.visitExpression(this, ctx);
	          var name = expr.name;
	          if (isPresent(expr.builtin)) {
	              name = this.getBuiltinMethodName(expr.builtin);
	              if (isBlank(name)) {
	                  // some builtins just mean to skip the call.
	                  return null;
	              }
	          }
	          ctx.print("." + name + "(");
	          this.visitAllExpressions(expr.args, ctx, ",");
	          ctx.print(")");
	          return null;
	      };
	      AbstractEmitterVisitor.prototype.visitInvokeFunctionExpr = function (expr, ctx) {
	          expr.fn.visitExpression(this, ctx);
	          ctx.print("(");
	          this.visitAllExpressions(expr.args, ctx, ',');
	          ctx.print(")");
	          return null;
	      };
	      AbstractEmitterVisitor.prototype.visitReadVarExpr = function (ast, ctx) {
	          var varName = ast.name;
	          if (isPresent(ast.builtin)) {
	              switch (ast.builtin) {
	                  case BuiltinVar.Super:
	                      varName = 'super';
	                      break;
	                  case BuiltinVar.This:
	                      varName = 'this';
	                      break;
	                  case BuiltinVar.CatchError:
	                      varName = CATCH_ERROR_VAR$2.name;
	                      break;
	                  case BuiltinVar.CatchStack:
	                      varName = CATCH_STACK_VAR$2.name;
	                      break;
	                  default:
	                      throw new Error("Unknown builtin variable " + ast.builtin);
	              }
	          }
	          ctx.print(varName);
	          return null;
	      };
	      AbstractEmitterVisitor.prototype.visitInstantiateExpr = function (ast, ctx) {
	          ctx.print("new ");
	          ast.classExpr.visitExpression(this, ctx);
	          ctx.print("(");
	          this.visitAllExpressions(ast.args, ctx, ',');
	          ctx.print(")");
	          return null;
	      };
	      AbstractEmitterVisitor.prototype.visitLiteralExpr = function (ast, ctx, absentValue) {
	          if (absentValue === void 0) { absentValue = 'null'; }
	          var value = ast.value;
	          if (typeof value === 'string') {
	              ctx.print(escapeIdentifier(value, this._escapeDollarInStrings));
	          }
	          else if (isBlank(value)) {
	              ctx.print(absentValue);
	          }
	          else {
	              ctx.print("" + value);
	          }
	          return null;
	      };
	      AbstractEmitterVisitor.prototype.visitConditionalExpr = function (ast, ctx) {
	          ctx.print("(");
	          ast.condition.visitExpression(this, ctx);
	          ctx.print('? ');
	          ast.trueCase.visitExpression(this, ctx);
	          ctx.print(': ');
	          ast.falseCase.visitExpression(this, ctx);
	          ctx.print(")");
	          return null;
	      };
	      AbstractEmitterVisitor.prototype.visitNotExpr = function (ast, ctx) {
	          ctx.print('!');
	          ast.condition.visitExpression(this, ctx);
	          return null;
	      };
	      AbstractEmitterVisitor.prototype.visitBinaryOperatorExpr = function (ast, ctx) {
	          var opStr;
	          switch (ast.operator) {
	              case BinaryOperator.Equals:
	                  opStr = '==';
	                  break;
	              case BinaryOperator.Identical:
	                  opStr = '===';
	                  break;
	              case BinaryOperator.NotEquals:
	                  opStr = '!=';
	                  break;
	              case BinaryOperator.NotIdentical:
	                  opStr = '!==';
	                  break;
	              case BinaryOperator.And:
	                  opStr = '&&';
	                  break;
	              case BinaryOperator.Or:
	                  opStr = '||';
	                  break;
	              case BinaryOperator.Plus:
	                  opStr = '+';
	                  break;
	              case BinaryOperator.Minus:
	                  opStr = '-';
	                  break;
	              case BinaryOperator.Divide:
	                  opStr = '/';
	                  break;
	              case BinaryOperator.Multiply:
	                  opStr = '*';
	                  break;
	              case BinaryOperator.Modulo:
	                  opStr = '%';
	                  break;
	              case BinaryOperator.Lower:
	                  opStr = '<';
	                  break;
	              case BinaryOperator.LowerEquals:
	                  opStr = '<=';
	                  break;
	              case BinaryOperator.Bigger:
	                  opStr = '>';
	                  break;
	              case BinaryOperator.BiggerEquals:
	                  opStr = '>=';
	                  break;
	              default:
	                  throw new Error("Unknown operator " + ast.operator);
	          }
	          ctx.print("(");
	          ast.lhs.visitExpression(this, ctx);
	          ctx.print(" " + opStr + " ");
	          ast.rhs.visitExpression(this, ctx);
	          ctx.print(")");
	          return null;
	      };
	      AbstractEmitterVisitor.prototype.visitReadPropExpr = function (ast, ctx) {
	          ast.receiver.visitExpression(this, ctx);
	          ctx.print(".");
	          ctx.print(ast.name);
	          return null;
	      };
	      AbstractEmitterVisitor.prototype.visitReadKeyExpr = function (ast, ctx) {
	          ast.receiver.visitExpression(this, ctx);
	          ctx.print("[");
	          ast.index.visitExpression(this, ctx);
	          ctx.print("]");
	          return null;
	      };
	      AbstractEmitterVisitor.prototype.visitLiteralArrayExpr = function (ast, ctx) {
	          var useNewLine = ast.entries.length > 1;
	          ctx.print("[", useNewLine);
	          ctx.incIndent();
	          this.visitAllExpressions(ast.entries, ctx, ',', useNewLine);
	          ctx.decIndent();
	          ctx.print("]", useNewLine);
	          return null;
	      };
	      AbstractEmitterVisitor.prototype.visitLiteralMapExpr = function (ast, ctx) {
	          var _this = this;
	          var useNewLine = ast.entries.length > 1;
	          ctx.print("{", useNewLine);
	          ctx.incIndent();
	          this.visitAllObjects(function (entry) {
	              ctx.print(escapeIdentifier(entry[0], _this._escapeDollarInStrings, false) + ": ");
	              entry[1].visitExpression(_this, ctx);
	          }, ast.entries, ctx, ',', useNewLine);
	          ctx.decIndent();
	          ctx.print("}", useNewLine);
	          return null;
	      };
	      AbstractEmitterVisitor.prototype.visitAllExpressions = function (expressions, ctx, separator, newLine) {
	          var _this = this;
	          if (newLine === void 0) { newLine = false; }
	          this.visitAllObjects(function (expr) { return expr.visitExpression(_this, ctx); }, expressions, ctx, separator, newLine);
	      };
	      AbstractEmitterVisitor.prototype.visitAllObjects = function (handler, expressions, ctx, separator, newLine) {
	          if (newLine === void 0) { newLine = false; }
	          for (var i = 0; i < expressions.length; i++) {
	              if (i > 0) {
	                  ctx.print(separator, newLine);
	              }
	              handler(expressions[i]);
	          }
	          if (newLine) {
	              ctx.println();
	          }
	      };
	      AbstractEmitterVisitor.prototype.visitAllStatements = function (statements, ctx) {
	          var _this = this;
	          statements.forEach(function (stmt) { return stmt.visitStatement(_this, ctx); });
	      };
	      return AbstractEmitterVisitor;
	  }());
	  function escapeIdentifier(input, escapeDollar, alwaysQuote) {
	      if (alwaysQuote === void 0) { alwaysQuote = true; }
	      if (isBlank(input)) {
	          return null;
	      }
	      var body = input.replace(_SINGLE_QUOTE_ESCAPE_STRING_RE, function () {
	          var match = [];
	          for (var _i = 0; _i < arguments.length; _i++) {
	              match[_i - 0] = arguments[_i];
	          }
	          if (match[0] == '$') {
	              return escapeDollar ? '\\$' : '$';
	          }
	          else if (match[0] == '\n') {
	              return '\\n';
	          }
	          else if (match[0] == '\r') {
	              return '\\r';
	          }
	          else {
	              return "\\" + match[0];
	          }
	      });
	      var requiresQuotes = alwaysQuote || !_LEGAL_IDENTIFIER_RE.test(body);
	      return requiresQuotes ? "'" + body + "'" : body;
	  }
	  function _createIndent(count) {
	      var res = '';
	      for (var i = 0; i < count; i++) {
	          res += '  ';
	      }
	      return res;
	  }

	  /**
	   * @license
	   * Copyright Google Inc. All Rights Reserved.
	   *
	   * Use of this source code is governed by an MIT-style license that can be
	   * found in the LICENSE file at https://angular.io/license
	   */
	  var __extends$18 = (this && this.__extends) || function (d, b) {
	      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	      function __() { this.constructor = d; }
	      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	  };
	  var _debugModuleUrl = 'asset://debug/lib';
	  function debugOutputAstAsTypeScript(ast) {
	      var converter = new _TsEmitterVisitor(_debugModuleUrl);
	      var ctx = EmitterVisitorContext.createRoot([]);
	      var asts = Array.isArray(ast) ? ast : [ast];
	      asts.forEach(function (ast) {
	          if (ast instanceof Statement) {
	              ast.visitStatement(converter, ctx);
	          }
	          else if (ast instanceof Expression) {
	              ast.visitExpression(converter, ctx);
	          }
	          else if (ast instanceof Type$1) {
	              ast.visitType(converter, ctx);
	          }
	          else {
	              throw new Error("Don't know how to print debug info for " + ast);
	          }
	      });
	      return ctx.toSource();
	  }
	  var TypeScriptEmitter = (function () {
	      function TypeScriptEmitter(_importGenerator) {
	          this._importGenerator = _importGenerator;
	      }
	      TypeScriptEmitter.prototype.emitStatements = function (moduleUrl, stmts, exportedVars) {
	          var _this = this;
	          var converter = new _TsEmitterVisitor(moduleUrl);
	          var ctx = EmitterVisitorContext.createRoot(exportedVars);
	          converter.visitAllStatements(stmts, ctx);
	          var srcParts = [];
	          converter.importsWithPrefixes.forEach(function (prefix, importedModuleUrl) {
	              // Note: can't write the real word for import as it screws up system.js auto detection...
	              srcParts.push("imp" +
	                  ("ort * as " + prefix + " from '" + _this._importGenerator.getImportPath(moduleUrl, importedModuleUrl) + "';"));
	          });
	          srcParts.push(ctx.toSource());
	          return srcParts.join('\n');
	      };
	      return TypeScriptEmitter;
	  }());
	  var _TsEmitterVisitor = (function (_super) {
	      __extends$18(_TsEmitterVisitor, _super);
	      function _TsEmitterVisitor(_moduleUrl) {
	          _super.call(this, false);
	          this._moduleUrl = _moduleUrl;
	          this.importsWithPrefixes = new Map();
	      }
	      _TsEmitterVisitor.prototype.visitType = function (t, ctx, defaultType) {
	          if (defaultType === void 0) { defaultType = 'any'; }
	          if (isPresent(t)) {
	              t.visitType(this, ctx);
	          }
	          else {
	              ctx.print(defaultType);
	          }
	      };
	      _TsEmitterVisitor.prototype.visitLiteralExpr = function (ast, ctx) {
	          _super.prototype.visitLiteralExpr.call(this, ast, ctx, '(null as any)');
	      };
	      // Temporary workaround to support strictNullCheck enabled consumers of ngc emit.
	      // In SNC mode, [] have the type never[], so we cast here to any[].
	      // TODO: narrow the cast to a more explicit type, or use a pattern that does not
	      // start with [].concat. see https://github.com/angular/angular/pull/11846
	      _TsEmitterVisitor.prototype.visitLiteralArrayExpr = function (ast, ctx) {
	          if (ast.entries.length === 0) {
	              ctx.print('(');
	          }
	          var result = _super.prototype.visitLiteralArrayExpr.call(this, ast, ctx);
	          if (ast.entries.length === 0) {
	              ctx.print(' as any[])');
	          }
	          return result;
	      };
	      _TsEmitterVisitor.prototype.visitExternalExpr = function (ast, ctx) {
	          this._visitIdentifier(ast.value, ast.typeParams, ctx);
	          return null;
	      };
	      _TsEmitterVisitor.prototype.visitDeclareVarStmt = function (stmt, ctx) {
	          if (ctx.isExportedVar(stmt.name)) {
	              ctx.print("export ");
	          }
	          if (stmt.hasModifier(StmtModifier.Final)) {
	              ctx.print("const");
	          }
	          else {
	              ctx.print("var");
	          }
	          ctx.print(" " + stmt.name + ":");
	          this.visitType(stmt.type, ctx);
	          ctx.print(" = ");
	          stmt.value.visitExpression(this, ctx);
	          ctx.println(";");
	          return null;
	      };
	      _TsEmitterVisitor.prototype.visitCastExpr = function (ast, ctx) {
	          ctx.print("(<");
	          ast.type.visitType(this, ctx);
	          ctx.print(">");
	          ast.value.visitExpression(this, ctx);
	          ctx.print(")");
	          return null;
	      };
	      _TsEmitterVisitor.prototype.visitDeclareClassStmt = function (stmt, ctx) {
	          var _this = this;
	          ctx.pushClass(stmt);
	          if (ctx.isExportedVar(stmt.name)) {
	              ctx.print("export ");
	          }
	          ctx.print("class " + stmt.name);
	          if (isPresent(stmt.parent)) {
	              ctx.print(" extends ");
	              stmt.parent.visitExpression(this, ctx);
	          }
	          ctx.println(" {");
	          ctx.incIndent();
	          stmt.fields.forEach(function (field) { return _this._visitClassField(field, ctx); });
	          if (isPresent(stmt.constructorMethod)) {
	              this._visitClassConstructor(stmt, ctx);
	          }
	          stmt.getters.forEach(function (getter) { return _this._visitClassGetter(getter, ctx); });
	          stmt.methods.forEach(function (method) { return _this._visitClassMethod(method, ctx); });
	          ctx.decIndent();
	          ctx.println("}");
	          ctx.popClass();
	          return null;
	      };
	      _TsEmitterVisitor.prototype._visitClassField = function (field, ctx) {
	          if (field.hasModifier(StmtModifier.Private)) {
	              // comment out as a workaround for #10967
	              ctx.print("/*private*/ ");
	          }
	          ctx.print(field.name);
	          ctx.print(':');
	          this.visitType(field.type, ctx);
	          ctx.println(";");
	      };
	      _TsEmitterVisitor.prototype._visitClassGetter = function (getter, ctx) {
	          if (getter.hasModifier(StmtModifier.Private)) {
	              ctx.print("private ");
	          }
	          ctx.print("get " + getter.name + "()");
	          ctx.print(':');
	          this.visitType(getter.type, ctx);
	          ctx.println(" {");
	          ctx.incIndent();
	          this.visitAllStatements(getter.body, ctx);
	          ctx.decIndent();
	          ctx.println("}");
	      };
	      _TsEmitterVisitor.prototype._visitClassConstructor = function (stmt, ctx) {
	          ctx.print("constructor(");
	          this._visitParams(stmt.constructorMethod.params, ctx);
	          ctx.println(") {");
	          ctx.incIndent();
	          this.visitAllStatements(stmt.constructorMethod.body, ctx);
	          ctx.decIndent();
	          ctx.println("}");
	      };
	      _TsEmitterVisitor.prototype._visitClassMethod = function (method, ctx) {
	          if (method.hasModifier(StmtModifier.Private)) {
	              ctx.print("private ");
	          }
	          ctx.print(method.name + "(");
	          this._visitParams(method.params, ctx);
	          ctx.print("):");
	          this.visitType(method.type, ctx, 'void');
	          ctx.println(" {");
	          ctx.incIndent();
	          this.visitAllStatements(method.body, ctx);
	          ctx.decIndent();
	          ctx.println("}");
	      };
	      _TsEmitterVisitor.prototype.visitFunctionExpr = function (ast, ctx) {
	          ctx.print("(");
	          this._visitParams(ast.params, ctx);
	          ctx.print("):");
	          this.visitType(ast.type, ctx, 'void');
	          ctx.println(" => {");
	          ctx.incIndent();
	          this.visitAllStatements(ast.statements, ctx);
	          ctx.decIndent();
	          ctx.print("}");
	          return null;
	      };
	      _TsEmitterVisitor.prototype.visitDeclareFunctionStmt = function (stmt, ctx) {
	          if (ctx.isExportedVar(stmt.name)) {
	              ctx.print("export ");
	          }
	          ctx.print("function " + stmt.name + "(");
	          this._visitParams(stmt.params, ctx);
	          ctx.print("):");
	          this.visitType(stmt.type, ctx, 'void');
	          ctx.println(" {");
	          ctx.incIndent();
	          this.visitAllStatements(stmt.statements, ctx);
	          ctx.decIndent();
	          ctx.println("}");
	          return null;
	      };
	      _TsEmitterVisitor.prototype.visitTryCatchStmt = function (stmt, ctx) {
	          ctx.println("try {");
	          ctx.incIndent();
	          this.visitAllStatements(stmt.bodyStmts, ctx);
	          ctx.decIndent();
	          ctx.println("} catch (" + CATCH_ERROR_VAR$2.name + ") {");
	          ctx.incIndent();
	          var catchStmts = [CATCH_STACK_VAR$2.set(CATCH_ERROR_VAR$2.prop('stack')).toDeclStmt(null, [
	                  StmtModifier.Final
	              ])].concat(stmt.catchStmts);
	          this.visitAllStatements(catchStmts, ctx);
	          ctx.decIndent();
	          ctx.println("}");
	          return null;
	      };
	      _TsEmitterVisitor.prototype.visitBuiltintType = function (type, ctx) {
	          var typeStr;
	          switch (type.name) {
	              case BuiltinTypeName.Bool:
	                  typeStr = 'boolean';
	                  break;
	              case BuiltinTypeName.Dynamic:
	                  typeStr = 'any';
	                  break;
	              case BuiltinTypeName.Function:
	                  typeStr = 'Function';
	                  break;
	              case BuiltinTypeName.Number:
	                  typeStr = 'number';
	                  break;
	              case BuiltinTypeName.Int:
	                  typeStr = 'number';
	                  break;
	              case BuiltinTypeName.String:
	                  typeStr = 'string';
	                  break;
	              default:
	                  throw new Error("Unsupported builtin type " + type.name);
	          }
	          ctx.print(typeStr);
	          return null;
	      };
	      _TsEmitterVisitor.prototype.visitExternalType = function (ast, ctx) {
	          this._visitIdentifier(ast.value, ast.typeParams, ctx);
	          return null;
	      };
	      _TsEmitterVisitor.prototype.visitArrayType = function (type, ctx) {
	          this.visitType(type.of, ctx);
	          ctx.print("[]");
	          return null;
	      };
	      _TsEmitterVisitor.prototype.visitMapType = function (type, ctx) {
	          ctx.print("{[key: string]:");
	          this.visitType(type.valueType, ctx);
	          ctx.print("}");
	          return null;
	      };
	      _TsEmitterVisitor.prototype.getBuiltinMethodName = function (method) {
	          var name;
	          switch (method) {
	              case BuiltinMethod.ConcatArray:
	                  name = 'concat';
	                  break;
	              case BuiltinMethod.SubscribeObservable:
	                  name = 'subscribe';
	                  break;
	              case BuiltinMethod.Bind:
	                  name = 'bind';
	                  break;
	              default:
	                  throw new Error("Unknown builtin method: " + method);
	          }
	          return name;
	      };
	      _TsEmitterVisitor.prototype._visitParams = function (params, ctx) {
	          var _this = this;
	          this.visitAllObjects(function (param) {
	              ctx.print(param.name);
	              ctx.print(':');
	              _this.visitType(param.type, ctx);
	          }, params, ctx, ',');
	      };
	      _TsEmitterVisitor.prototype._visitIdentifier = function (value, typeParams, ctx) {
	          var _this = this;
	          if (isBlank(value.name)) {
	              throw new Error("Internal error: unknown identifier " + value);
	          }
	          if (isPresent(value.moduleUrl) && value.moduleUrl != this._moduleUrl) {
	              var prefix = this.importsWithPrefixes.get(value.moduleUrl);
	              if (isBlank(prefix)) {
	                  prefix = "import" + this.importsWithPrefixes.size;
	                  this.importsWithPrefixes.set(value.moduleUrl, prefix);
	              }
	              ctx.print(prefix + ".");
	          }
	          if (value.reference && value.reference.members) {
	              ctx.print(value.reference.name);
	              ctx.print('.');
	              ctx.print(value.reference.members.join('.'));
	          }
	          else {
	              ctx.print(value.name);
	          }
	          if (isPresent(typeParams) && typeParams.length > 0) {
	              ctx.print("<");
	              this.visitAllObjects(function (type) { return type.visitType(_this, ctx); }, typeParams, ctx, ',');
	              ctx.print(">");
	          }
	      };
	      return _TsEmitterVisitor;
	  }(AbstractEmitterVisitor));

	  function interpretStatements(statements, resultVar) {
	      var stmtsWithReturn = statements.concat([new ReturnStatement(variable(resultVar))]);
	      var ctx = new _ExecutionContext(null, null, null, new Map());
	      var visitor = new StatementInterpreter();
	      var result = visitor.visitAllStatements(stmtsWithReturn, ctx);
	      return isPresent(result) ? result.value : null;
	  }
	  function _executeFunctionStatements(varNames, varValues, statements, ctx, visitor) {
	      var childCtx = ctx.createChildWihtLocalVars();
	      for (var i = 0; i < varNames.length; i++) {
	          childCtx.vars.set(varNames[i], varValues[i]);
	      }
	      var result = visitor.visitAllStatements(statements, childCtx);
	      return isPresent(result) ? result.value : null;
	  }
	  var _ExecutionContext = (function () {
	      function _ExecutionContext(parent, instance, className, vars) {
	          this.parent = parent;
	          this.instance = instance;
	          this.className = className;
	          this.vars = vars;
	      }
	      _ExecutionContext.prototype.createChildWihtLocalVars = function () {
	          return new _ExecutionContext(this, this.instance, this.className, new Map());
	      };
	      return _ExecutionContext;
	  }());
	  var ReturnValue = (function () {
	      function ReturnValue(value) {
	          this.value = value;
	      }
	      return ReturnValue;
	  }());
	  function createDynamicClass(_classStmt, _ctx, _visitor) {
	      var propertyDescriptors = {};
	      _classStmt.getters.forEach(function (getter) {
	          // Note: use `function` instead of arrow function to capture `this`
	          propertyDescriptors[getter.name] = {
	              configurable: false,
	              get: function () {
	                  var instanceCtx = new _ExecutionContext(_ctx, this, _classStmt.name, _ctx.vars);
	                  return _executeFunctionStatements([], [], getter.body, instanceCtx, _visitor);
	              }
	          };
	      });
	      _classStmt.methods.forEach(function (method) {
	          var paramNames = method.params.map(function (param) { return param.name; });
	          // Note: use `function` instead of arrow function to capture `this`
	          propertyDescriptors[method.name] = {
	              writable: false,
	              configurable: false,
	              value: function () {
	                  var args = [];
	                  for (var _i = 0; _i < arguments.length; _i++) {
	                      args[_i - 0] = arguments[_i];
	                  }
	                  var instanceCtx = new _ExecutionContext(_ctx, this, _classStmt.name, _ctx.vars);
	                  return _executeFunctionStatements(paramNames, args, method.body, instanceCtx, _visitor);
	              }
	          };
	      });
	      var ctorParamNames = _classStmt.constructorMethod.params.map(function (param) { return param.name; });
	      // Note: use `function` instead of arrow function to capture `this`
	      var ctor = function () {
	          var _this = this;
	          var args = [];
	          for (var _i = 0; _i < arguments.length; _i++) {
	              args[_i - 0] = arguments[_i];
	          }
	          var instanceCtx = new _ExecutionContext(_ctx, this, _classStmt.name, _ctx.vars);
	          _classStmt.fields.forEach(function (field) { _this[field.name] = undefined; });
	          _executeFunctionStatements(ctorParamNames, args, _classStmt.constructorMethod.body, instanceCtx, _visitor);
	      };
	      var superClass = _classStmt.parent ? _classStmt.parent.visitExpression(_visitor, _ctx) : Object;
	      ctor.prototype = Object.create(superClass.prototype, propertyDescriptors);
	      return ctor;
	  }
	  var StatementInterpreter = (function () {
	      function StatementInterpreter() {
	      }
	      StatementInterpreter.prototype.debugAst = function (ast) { return debugOutputAstAsTypeScript(ast); };
	      StatementInterpreter.prototype.visitDeclareVarStmt = function (stmt, ctx) {
	          ctx.vars.set(stmt.name, stmt.value.visitExpression(this, ctx));
	          return null;
	      };
	      StatementInterpreter.prototype.visitWriteVarExpr = function (expr, ctx) {
	          var value = expr.value.visitExpression(this, ctx);
	          var currCtx = ctx;
	          while (currCtx != null) {
	              if (currCtx.vars.has(expr.name)) {
	                  currCtx.vars.set(expr.name, value);
	                  return value;
	              }
	              currCtx = currCtx.parent;
	          }
	          throw new Error("Not declared variable " + expr.name);
	      };
	      StatementInterpreter.prototype.visitReadVarExpr = function (ast, ctx) {
	          var varName = ast.name;
	          if (isPresent(ast.builtin)) {
	              switch (ast.builtin) {
	                  case BuiltinVar.Super:
	                      return ctx.instance.__proto__;
	                  case BuiltinVar.This:
	                      return ctx.instance;
	                  case BuiltinVar.CatchError:
	                      varName = CATCH_ERROR_VAR$1;
	                      break;
	                  case BuiltinVar.CatchStack:
	                      varName = CATCH_STACK_VAR$1;
	                      break;
	                  default:
	                      throw new Error("Unknown builtin variable " + ast.builtin);
	              }
	          }
	          var currCtx = ctx;
	          while (currCtx != null) {
	              if (currCtx.vars.has(varName)) {
	                  return currCtx.vars.get(varName);
	              }
	              currCtx = currCtx.parent;
	          }
	          throw new Error("Not declared variable " + varName);
	      };
	      StatementInterpreter.prototype.visitWriteKeyExpr = function (expr, ctx) {
	          var receiver = expr.receiver.visitExpression(this, ctx);
	          var index = expr.index.visitExpression(this, ctx);
	          var value = expr.value.visitExpression(this, ctx);
	          receiver[index] = value;
	          return value;
	      };
	      StatementInterpreter.prototype.visitWritePropExpr = function (expr, ctx) {
	          var receiver = expr.receiver.visitExpression(this, ctx);
	          var value = expr.value.visitExpression(this, ctx);
	          receiver[expr.name] = value;
	          return value;
	      };
	      StatementInterpreter.prototype.visitInvokeMethodExpr = function (expr, ctx) {
	          var receiver = expr.receiver.visitExpression(this, ctx);
	          var args = this.visitAllExpressions(expr.args, ctx);
	          var result;
	          if (isPresent(expr.builtin)) {
	              switch (expr.builtin) {
	                  case BuiltinMethod.ConcatArray:
	                      result = receiver.concat(args[0]);
	                      break;
	                  case BuiltinMethod.SubscribeObservable:
	                      result = receiver.subscribe({ next: args[0] });
	                      break;
	                  case BuiltinMethod.Bind:
	                      result = receiver.bind(args[0]);
	                      break;
	                  default:
	                      throw new Error("Unknown builtin method " + expr.builtin);
	              }
	          }
	          else {
	              result = receiver[expr.name].apply(receiver, args);
	          }
	          return result;
	      };
	      StatementInterpreter.prototype.visitInvokeFunctionExpr = function (stmt, ctx) {
	          var args = this.visitAllExpressions(stmt.args, ctx);
	          var fnExpr = stmt.fn;
	          if (fnExpr instanceof ReadVarExpr && fnExpr.builtin === BuiltinVar.Super) {
	              ctx.instance.constructor.prototype.constructor.apply(ctx.instance, args);
	              return null;
	          }
	          else {
	              var fn = stmt.fn.visitExpression(this, ctx);
	              return fn.apply(null, args);
	          }
	      };
	      StatementInterpreter.prototype.visitReturnStmt = function (stmt, ctx) {
	          return new ReturnValue(stmt.value.visitExpression(this, ctx));
	      };
	      StatementInterpreter.prototype.visitDeclareClassStmt = function (stmt, ctx) {
	          var clazz = createDynamicClass(stmt, ctx, this);
	          ctx.vars.set(stmt.name, clazz);
	          return null;
	      };
	      StatementInterpreter.prototype.visitExpressionStmt = function (stmt, ctx) {
	          return stmt.expr.visitExpression(this, ctx);
	      };
	      StatementInterpreter.prototype.visitIfStmt = function (stmt, ctx) {
	          var condition = stmt.condition.visitExpression(this, ctx);
	          if (condition) {
	              return this.visitAllStatements(stmt.trueCase, ctx);
	          }
	          else if (isPresent(stmt.falseCase)) {
	              return this.visitAllStatements(stmt.falseCase, ctx);
	          }
	          return null;
	      };
	      StatementInterpreter.prototype.visitTryCatchStmt = function (stmt, ctx) {
	          try {
	              return this.visitAllStatements(stmt.bodyStmts, ctx);
	          }
	          catch (e) {
	              var childCtx = ctx.createChildWihtLocalVars();
	              childCtx.vars.set(CATCH_ERROR_VAR$1, e);
	              childCtx.vars.set(CATCH_STACK_VAR$1, e.stack);
	              return this.visitAllStatements(stmt.catchStmts, childCtx);
	          }
	      };
	      StatementInterpreter.prototype.visitThrowStmt = function (stmt, ctx) {
	          throw stmt.error.visitExpression(this, ctx);
	      };
	      StatementInterpreter.prototype.visitCommentStmt = function (stmt, context) { return null; };
	      StatementInterpreter.prototype.visitInstantiateExpr = function (ast, ctx) {
	          var args = this.visitAllExpressions(ast.args, ctx);
	          var clazz = ast.classExpr.visitExpression(this, ctx);
	          return new (clazz.bind.apply(clazz, [void 0].concat(args)))();
	      };
	      StatementInterpreter.prototype.visitLiteralExpr = function (ast, ctx) { return ast.value; };
	      StatementInterpreter.prototype.visitExternalExpr = function (ast, ctx) {
	          return ast.value.reference;
	      };
	      StatementInterpreter.prototype.visitConditionalExpr = function (ast, ctx) {
	          if (ast.condition.visitExpression(this, ctx)) {
	              return ast.trueCase.visitExpression(this, ctx);
	          }
	          else if (isPresent(ast.falseCase)) {
	              return ast.falseCase.visitExpression(this, ctx);
	          }
	          return null;
	      };
	      StatementInterpreter.prototype.visitNotExpr = function (ast, ctx) {
	          return !ast.condition.visitExpression(this, ctx);
	      };
	      StatementInterpreter.prototype.visitCastExpr = function (ast, ctx) {
	          return ast.value.visitExpression(this, ctx);
	      };
	      StatementInterpreter.prototype.visitFunctionExpr = function (ast, ctx) {
	          var paramNames = ast.params.map(function (param) { return param.name; });
	          return _declareFn(paramNames, ast.statements, ctx, this);
	      };
	      StatementInterpreter.prototype.visitDeclareFunctionStmt = function (stmt, ctx) {
	          var paramNames = stmt.params.map(function (param) { return param.name; });
	          ctx.vars.set(stmt.name, _declareFn(paramNames, stmt.statements, ctx, this));
	          return null;
	      };
	      StatementInterpreter.prototype.visitBinaryOperatorExpr = function (ast, ctx) {
	          var _this = this;
	          var lhs = function () { return ast.lhs.visitExpression(_this, ctx); };
	          var rhs = function () { return ast.rhs.visitExpression(_this, ctx); };
	          switch (ast.operator) {
	              case BinaryOperator.Equals:
	                  return lhs() == rhs();
	              case BinaryOperator.Identical:
	                  return lhs() === rhs();
	              case BinaryOperator.NotEquals:
	                  return lhs() != rhs();
	              case BinaryOperator.NotIdentical:
	                  return lhs() !== rhs();
	              case BinaryOperator.And:
	                  return lhs() && rhs();
	              case BinaryOperator.Or:
	                  return lhs() || rhs();
	              case BinaryOperator.Plus:
	                  return lhs() + rhs();
	              case BinaryOperator.Minus:
	                  return lhs() - rhs();
	              case BinaryOperator.Divide:
	                  return lhs() / rhs();
	              case BinaryOperator.Multiply:
	                  return lhs() * rhs();
	              case BinaryOperator.Modulo:
	                  return lhs() % rhs();
	              case BinaryOperator.Lower:
	                  return lhs() < rhs();
	              case BinaryOperator.LowerEquals:
	                  return lhs() <= rhs();
	              case BinaryOperator.Bigger:
	                  return lhs() > rhs();
	              case BinaryOperator.BiggerEquals:
	                  return lhs() >= rhs();
	              default:
	                  throw new Error("Unknown operator " + ast.operator);
	          }
	      };
	      StatementInterpreter.prototype.visitReadPropExpr = function (ast, ctx) {
	          var result;
	          var receiver = ast.receiver.visitExpression(this, ctx);
	          result = receiver[ast.name];
	          return result;
	      };
	      StatementInterpreter.prototype.visitReadKeyExpr = function (ast, ctx) {
	          var receiver = ast.receiver.visitExpression(this, ctx);
	          var prop = ast.index.visitExpression(this, ctx);
	          return receiver[prop];
	      };
	      StatementInterpreter.prototype.visitLiteralArrayExpr = function (ast, ctx) {
	          return this.visitAllExpressions(ast.entries, ctx);
	      };
	      StatementInterpreter.prototype.visitLiteralMapExpr = function (ast, ctx) {
	          var _this = this;
	          var result = {};
	          ast.entries.forEach(function (entry) { return result[entry[0]] =
	              entry[1].visitExpression(_this, ctx); });
	          return result;
	      };
	      StatementInterpreter.prototype.visitAllExpressions = function (expressions, ctx) {
	          var _this = this;
	          return expressions.map(function (expr) { return expr.visitExpression(_this, ctx); });
	      };
	      StatementInterpreter.prototype.visitAllStatements = function (statements, ctx) {
	          for (var i = 0; i < statements.length; i++) {
	              var stmt = statements[i];
	              var val = stmt.visitStatement(this, ctx);
	              if (val instanceof ReturnValue) {
	                  return val;
	              }
	          }
	          return null;
	      };
	      return StatementInterpreter;
	  }());
	  function _declareFn(varNames, statements, ctx, visitor) {
	      return function () {
	          var args = [];
	          for (var _i = 0; _i < arguments.length; _i++) {
	              args[_i - 0] = arguments[_i];
	          }
	          return _executeFunctionStatements(varNames, args, statements, ctx, visitor);
	      };
	  }
	  var CATCH_ERROR_VAR$1 = 'error';
	  var CATCH_STACK_VAR$1 = 'stack';

	  /**
	   * @license
	   * Copyright Google Inc. All Rights Reserved.
	   *
	   * Use of this source code is governed by an MIT-style license that can be
	   * found in the LICENSE file at https://angular.io/license
	   */
	  var __extends$20 = (this && this.__extends) || function (d, b) {
	      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	      function __() { this.constructor = d; }
	      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	  };
	  var AbstractJsEmitterVisitor = (function (_super) {
	      __extends$20(AbstractJsEmitterVisitor, _super);
	      function AbstractJsEmitterVisitor() {
	          _super.call(this, false);
	      }
	      AbstractJsEmitterVisitor.prototype.visitDeclareClassStmt = function (stmt, ctx) {
	          var _this = this;
	          ctx.pushClass(stmt);
	          this._visitClassConstructor(stmt, ctx);
	          if (isPresent(stmt.parent)) {
	              ctx.print(stmt.name + ".prototype = Object.create(");
	              stmt.parent.visitExpression(this, ctx);
	              ctx.println(".prototype);");
	          }
	          stmt.getters.forEach(function (getter) { return _this._visitClassGetter(stmt, getter, ctx); });
	          stmt.methods.forEach(function (method) { return _this._visitClassMethod(stmt, method, ctx); });
	          ctx.popClass();
	          return null;
	      };
	      AbstractJsEmitterVisitor.prototype._visitClassConstructor = function (stmt, ctx) {
	          ctx.print("function " + stmt.name + "(");
	          if (isPresent(stmt.constructorMethod)) {
	              this._visitParams(stmt.constructorMethod.params, ctx);
	          }
	          ctx.println(") {");
	          ctx.incIndent();
	          if (isPresent(stmt.constructorMethod)) {
	              if (stmt.constructorMethod.body.length > 0) {
	                  ctx.println("var self = this;");
	                  this.visitAllStatements(stmt.constructorMethod.body, ctx);
	              }
	          }
	          ctx.decIndent();
	          ctx.println("}");
	      };
	      AbstractJsEmitterVisitor.prototype._visitClassGetter = function (stmt, getter, ctx) {
	          ctx.println("Object.defineProperty(" + stmt.name + ".prototype, '" + getter.name + "', { get: function() {");
	          ctx.incIndent();
	          if (getter.body.length > 0) {
	              ctx.println("var self = this;");
	              this.visitAllStatements(getter.body, ctx);
	          }
	          ctx.decIndent();
	          ctx.println("}});");
	      };
	      AbstractJsEmitterVisitor.prototype._visitClassMethod = function (stmt, method, ctx) {
	          ctx.print(stmt.name + ".prototype." + method.name + " = function(");
	          this._visitParams(method.params, ctx);
	          ctx.println(") {");
	          ctx.incIndent();
	          if (method.body.length > 0) {
	              ctx.println("var self = this;");
	              this.visitAllStatements(method.body, ctx);
	          }
	          ctx.decIndent();
	          ctx.println("};");
	      };
	      AbstractJsEmitterVisitor.prototype.visitReadVarExpr = function (ast, ctx) {
	          if (ast.builtin === BuiltinVar.This) {
	              ctx.print('self');
	          }
	          else if (ast.builtin === BuiltinVar.Super) {
	              throw new Error("'super' needs to be handled at a parent ast node, not at the variable level!");
	          }
	          else {
	              _super.prototype.visitReadVarExpr.call(this, ast, ctx);
	          }
	          return null;
	      };
	      AbstractJsEmitterVisitor.prototype.visitDeclareVarStmt = function (stmt, ctx) {
	          ctx.print("var " + stmt.name + " = ");
	          stmt.value.visitExpression(this, ctx);
	          ctx.println(";");
	          return null;
	      };
	      AbstractJsEmitterVisitor.prototype.visitCastExpr = function (ast, ctx) {
	          ast.value.visitExpression(this, ctx);
	          return null;
	      };
	      AbstractJsEmitterVisitor.prototype.visitInvokeFunctionExpr = function (expr, ctx) {
	          var fnExpr = expr.fn;
	          if (fnExpr instanceof ReadVarExpr && fnExpr.builtin === BuiltinVar.Super) {
	              ctx.currentClass.parent.visitExpression(this, ctx);
	              ctx.print(".call(this");
	              if (expr.args.length > 0) {
	                  ctx.print(", ");
	                  this.visitAllExpressions(expr.args, ctx, ',');
	              }
	              ctx.print(")");
	          }
	          else {
	              _super.prototype.visitInvokeFunctionExpr.call(this, expr, ctx);
	          }
	          return null;
	      };
	      AbstractJsEmitterVisitor.prototype.visitFunctionExpr = function (ast, ctx) {
	          ctx.print("function(");
	          this._visitParams(ast.params, ctx);
	          ctx.println(") {");
	          ctx.incIndent();
	          this.visitAllStatements(ast.statements, ctx);
	          ctx.decIndent();
	          ctx.print("}");
	          return null;
	      };
	      AbstractJsEmitterVisitor.prototype.visitDeclareFunctionStmt = function (stmt, ctx) {
	          ctx.print("function " + stmt.name + "(");
	          this._visitParams(stmt.params, ctx);
	          ctx.println(") {");
	          ctx.incIndent();
	          this.visitAllStatements(stmt.statements, ctx);
	          ctx.decIndent();
	          ctx.println("}");
	          return null;
	      };
	      AbstractJsEmitterVisitor.prototype.visitTryCatchStmt = function (stmt, ctx) {
	          ctx.println("try {");
	          ctx.incIndent();
	          this.visitAllStatements(stmt.bodyStmts, ctx);
	          ctx.decIndent();
	          ctx.println("} catch (" + CATCH_ERROR_VAR$2.name + ") {");
	          ctx.incIndent();
	          var catchStmts = [CATCH_STACK_VAR$2.set(CATCH_ERROR_VAR$2.prop('stack')).toDeclStmt(null, [
	                  StmtModifier.Final
	              ])].concat(stmt.catchStmts);
	          this.visitAllStatements(catchStmts, ctx);
	          ctx.decIndent();
	          ctx.println("}");
	          return null;
	      };
	      AbstractJsEmitterVisitor.prototype._visitParams = function (params, ctx) {
	          this.visitAllObjects(function (param) { return ctx.print(param.name); }, params, ctx, ',');
	      };
	      AbstractJsEmitterVisitor.prototype.getBuiltinMethodName = function (method) {
	          var name;
	          switch (method) {
	              case BuiltinMethod.ConcatArray:
	                  name = 'concat';
	                  break;
	              case BuiltinMethod.SubscribeObservable:
	                  name = 'subscribe';
	                  break;
	              case BuiltinMethod.Bind:
	                  name = 'bind';
	                  break;
	              default:
	                  throw new Error("Unknown builtin method: " + method);
	          }
	          return name;
	      };
	      return AbstractJsEmitterVisitor;
	  }(AbstractEmitterVisitor));

	  /**
	   * @license
	   * Copyright Google Inc. All Rights Reserved.
	   *
	   * Use of this source code is governed by an MIT-style license that can be
	   * found in the LICENSE file at https://angular.io/license
	   */
	  var __extends$19 = (this && this.__extends) || function (d, b) {
	      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	      function __() { this.constructor = d; }
	      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	  };
	  function evalExpression(sourceUrl, expr, declarations, vars) {
	      var fnBody = declarations + "\nreturn " + expr + "\n//# sourceURL=" + sourceUrl;
	      var fnArgNames = [];
	      var fnArgValues = [];
	      for (var argName in vars) {
	          fnArgNames.push(argName);
	          fnArgValues.push(vars[argName]);
	      }
	      return new (Function.bind.apply(Function, [void 0].concat(fnArgNames.concat(fnBody))))().apply(void 0, fnArgValues);
	  }
	  function jitStatements(sourceUrl, statements, resultVar) {
	      var converter = new JitEmitterVisitor();
	      var ctx = EmitterVisitorContext.createRoot([resultVar]);
	      converter.visitAllStatements(statements, ctx);
	      return evalExpression(sourceUrl, resultVar, ctx.toSource(), converter.getArgs());
	  }
	  var JitEmitterVisitor = (function (_super) {
	      __extends$19(JitEmitterVisitor, _super);
	      function JitEmitterVisitor() {
	          _super.apply(this, arguments);
	          this._evalArgNames = [];
	          this._evalArgValues = [];
	      }
	      JitEmitterVisitor.prototype.getArgs = function () {
	          var result = {};
	          for (var i = 0; i < this._evalArgNames.length; i++) {
	              result[this._evalArgNames[i]] = this._evalArgValues[i];
	          }
	          return result;
	      };
	      JitEmitterVisitor.prototype.visitExternalExpr = function (ast, ctx) {
	          var value = ast.value.reference;
	          var id = this._evalArgValues.indexOf(value);
	          if (id === -1) {
	              id = this._evalArgValues.length;
	              this._evalArgValues.push(value);
	              var name = isPresent(ast.value.name) ? sanitizeIdentifier(ast.value.name) : 'val';
	              this._evalArgNames.push(sanitizeIdentifier("jit_" + name + id));
	          }
	          ctx.print(this._evalArgNames[id]);
	          return null;
	      };
	      return JitEmitterVisitor;
	  }(AbstractJsEmitterVisitor));

	  /**
	   * @license
	   * Copyright Google Inc. All Rights Reserved.
	   *
	   * Use of this source code is governed by an MIT-style license that can be
	   * found in the LICENSE file at https://angular.io/license
	   */
	  /**
	   * This file is a port of shadowCSS from webcomponents.js to TypeScript.
	   *
	   * Please make sure to keep to edits in sync with the source file.
	   *
	   * Source:
	   * https://github.com/webcomponents/webcomponentsjs/blob/4efecd7e0e/src/ShadowCSS/ShadowCSS.js
	   *
	   * The original file level comment is reproduced below
	   */
	  /*
	    This is a limited shim for ShadowDOM css styling.
	    https://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/shadow/index.html#styles

	    The intention here is to support only the styling features which can be
	    relatively simply implemented. The goal is to allow users to avoid the
	    most obvious pitfalls and do so without compromising performance significantly.
	    For ShadowDOM styling that's not covered here, a set of best practices
	    can be provided that should allow users to accomplish more complex styling.

	    The following is a list of specific ShadowDOM styling features and a brief
	    discussion of the approach used to shim.

	    Shimmed features:

	    * :host, :host-context: ShadowDOM allows styling of the shadowRoot's host
	    element using the :host rule. To shim this feature, the :host styles are
	    reformatted and prefixed with a given scope name and promoted to a
	    document level stylesheet.
	    For example, given a scope name of .foo, a rule like this:

	      :host {
	          background: red;
	        }
	      }

	    becomes:

	      .foo {
	        background: red;
	      }

	    * encapsulation: Styles defined within ShadowDOM, apply only to
	    dom inside the ShadowDOM. Polymer uses one of two techniques to implement
	    this feature.

	    By default, rules are prefixed with the host element tag name
	    as a descendant selector. This ensures styling does not leak out of the 'top'
	    of the element's ShadowDOM. For example,

	    div {
	        font-weight: bold;
	      }

	    becomes:

	    x-foo div {
	        font-weight: bold;
	      }

	    becomes:


	    Alternatively, if WebComponents.ShadowCSS.strictStyling is set to true then
	    selectors are scoped by adding an attribute selector suffix to each
	    simple selector that contains the host element tag name. Each element
	    in the element's ShadowDOM template is also given the scope attribute.
	    Thus, these rules match only elements that have the scope attribute.
	    For example, given a scope name of x-foo, a rule like this:

	      div {
	        font-weight: bold;
	      }

	    becomes:

	      div[x-foo] {
	        font-weight: bold;
	      }

	    Note that elements that are dynamically added to a scope must have the scope
	    selector added to them manually.

	    * upper/lower bound encapsulation: Styles which are defined outside a
	    shadowRoot should not cross the ShadowDOM boundary and should not apply
	    inside a shadowRoot.

	    This styling behavior is not emulated. Some possible ways to do this that
	    were rejected due to complexity and/or performance concerns include: (1) reset
	    every possible property for every possible selector for a given scope name;
	    (2) re-implement css in javascript.

	    As an alternative, users should make sure to use selectors
	    specific to the scope in which they are working.

	    * ::distributed: This behavior is not emulated. It's often not necessary
	    to style the contents of a specific insertion point and instead, descendants
	    of the host element can be styled selectively. Users can also create an
	    extra node around an insertion point and style that node's contents
	    via descendent selectors. For example, with a shadowRoot like this:

	      <style>
	        ::content(div) {
	          background: red;
	        }
	      </style>
	      <content></content>

	    could become:

	      <style>
	        / *@polyfill .content-container div * /
	        ::content(div) {
	          background: red;
	        }
	      </style>
	      <div class="content-container">
	        <content></content>
	      </div>

	    Note the use of @polyfill in the comment above a ShadowDOM specific style
	    declaration. This is a directive to the styling shim to use the selector
	    in comments in lieu of the next selector when running under polyfill.
	  */
	  var ShadowCss = (function () {
	      function ShadowCss() {
	          this.strictStyling = true;
	      }
	      /*
	      * Shim some cssText with the given selector. Returns cssText that can
	      * be included in the document via WebComponents.ShadowCSS.addCssToDocument(css).
	      *
	      * When strictStyling is true:
	      * - selector is the attribute added to all elements inside the host,
	      * - hostSelector is the attribute added to the host itself.
	      */
	      ShadowCss.prototype.shimCssText = function (cssText, selector, hostSelector) {
	          if (hostSelector === void 0) { hostSelector = ''; }
	          var sourceMappingUrl = extractSourceMappingUrl(cssText);
	          cssText = stripComments(cssText);
	          cssText = this._insertDirectives(cssText);
	          return this._scopeCssText(cssText, selector, hostSelector) + sourceMappingUrl;
	      };
	      ShadowCss.prototype._insertDirectives = function (cssText) {
	          cssText = this._insertPolyfillDirectivesInCssText(cssText);
	          return this._insertPolyfillRulesInCssText(cssText);
	      };
	      /*
	       * Process styles to convert native ShadowDOM rules that will trip
	       * up the css parser; we rely on decorating the stylesheet with inert rules.
	       *
	       * For example, we convert this rule:
	       *
	       * polyfill-next-selector { content: ':host menu-item'; }
	       * ::content menu-item {
	       *
	       * to this:
	       *
	       * scopeName menu-item {
	       *
	      **/
	      ShadowCss.prototype._insertPolyfillDirectivesInCssText = function (cssText) {
	          // Difference with webcomponents.js: does not handle comments
	          return cssText.replace(_cssContentNextSelectorRe, function () {
	              var m = [];
	              for (var _i = 0; _i < arguments.length; _i++) {
	                  m[_i - 0] = arguments[_i];
	              }
	              return m[2] + '{';
	          });
	      };
	      /*
	       * Process styles to add rules which will only apply under the polyfill
	       *
	       * For example, we convert this rule:
	       *
	       * polyfill-rule {
	       *   content: ':host menu-item';
	       * ...
	       * }
	       *
	       * to this:
	       *
	       * scopeName menu-item {...}
	       *
	      **/
	      ShadowCss.prototype._insertPolyfillRulesInCssText = function (cssText) {
	          // Difference with webcomponents.js: does not handle comments
	          return cssText.replace(_cssContentRuleRe, function () {
	              var m = [];
	              for (var _i = 0; _i < arguments.length; _i++) {
	                  m[_i - 0] = arguments[_i];
	              }
	              var rule = m[0].replace(m[1], '').replace(m[2], '');
	              return m[4] + rule;
	          });
	      };
	      /* Ensure styles are scoped. Pseudo-scoping takes a rule like:
	       *
	       *  .foo {... }
	       *
	       *  and converts this to
	       *
	       *  scopeName .foo { ... }
	      */
	      ShadowCss.prototype._scopeCssText = function (cssText, scopeSelector, hostSelector) {
	          var unscopedRules = this._extractUnscopedRulesFromCssText(cssText);
	          // replace :host and :host-context -shadowcsshost and -shadowcsshost respectively
	          cssText = this._insertPolyfillHostInCssText(cssText);
	          cssText = this._convertColonHost(cssText);
	          cssText = this._convertColonHostContext(cssText);
	          cssText = this._convertShadowDOMSelectors(cssText);
	          if (scopeSelector) {
	              cssText = this._scopeSelectors(cssText, scopeSelector, hostSelector);
	          }
	          cssText = cssText + '\n' + unscopedRules;
	          return cssText.trim();
	      };
	      /*
	       * Process styles to add rules which will only apply under the polyfill
	       * and do not process via CSSOM. (CSSOM is destructive to rules on rare
	       * occasions, e.g. -webkit-calc on Safari.)
	       * For example, we convert this rule:
	       *
	       * @polyfill-unscoped-rule {
	       *   content: 'menu-item';
	       * ... }
	       *
	       * to this:
	       *
	       * menu-item {...}
	       *
	      **/
	      ShadowCss.prototype._extractUnscopedRulesFromCssText = function (cssText) {
	          // Difference with webcomponents.js: does not handle comments
	          var r = '';
	          var m;
	          _cssContentUnscopedRuleRe.lastIndex = 0;
	          while ((m = _cssContentUnscopedRuleRe.exec(cssText)) !== null) {
	              var rule = m[0].replace(m[2], '').replace(m[1], m[4]);
	              r += rule + '\n\n';
	          }
	          return r;
	      };
	      /*
	       * convert a rule like :host(.foo) > .bar { }
	       *
	       * to
	       *
	       * .foo<scopeName> > .bar
	      */
	      ShadowCss.prototype._convertColonHost = function (cssText) {
	          return this._convertColonRule(cssText, _cssColonHostRe, this._colonHostPartReplacer);
	      };
	      /*
	       * convert a rule like :host-context(.foo) > .bar { }
	       *
	       * to
	       *
	       * .foo<scopeName> > .bar, .foo scopeName > .bar { }
	       *
	       * and
	       *
	       * :host-context(.foo:host) .bar { ... }
	       *
	       * to
	       *
	       * .foo<scopeName> .bar { ... }
	      */
	      ShadowCss.prototype._convertColonHostContext = function (cssText) {
	          return this._convertColonRule(cssText, _cssColonHostContextRe, this._colonHostContextPartReplacer);
	      };
	      ShadowCss.prototype._convertColonRule = function (cssText, regExp, partReplacer) {
	          // m[1] = :host(-context), m[2] = contents of (), m[3] rest of rule
	          return cssText.replace(regExp, function () {
	              var m = [];
	              for (var _i = 0; _i < arguments.length; _i++) {
	                  m[_i - 0] = arguments[_i];
	              }
	              if (m[2]) {
	                  var parts = m[2].split(',');
	                  var r = [];
	                  for (var i = 0; i < parts.length; i++) {
	                      var p = parts[i].trim();
	                      if (!p)
	                          break;
	                      r.push(partReplacer(_polyfillHostNoCombinator, p, m[3]));
	                  }
	                  return r.join(',');
	              }
	              else {
	                  return _polyfillHostNoCombinator + m[3];
	              }
	          });
	      };
	      ShadowCss.prototype._colonHostContextPartReplacer = function (host, part, suffix) {
	          if (part.indexOf(_polyfillHost) > -1) {
	              return this._colonHostPartReplacer(host, part, suffix);
	          }
	          else {
	              return host + part + suffix + ', ' + part + ' ' + host + suffix;
	          }
	      };
	      ShadowCss.prototype._colonHostPartReplacer = function (host, part, suffix) {
	          return host + part.replace(_polyfillHost, '') + suffix;
	      };
	      /*
	       * Convert combinators like ::shadow and pseudo-elements like ::content
	       * by replacing with space.
	      */
	      ShadowCss.prototype._convertShadowDOMSelectors = function (cssText) {
	          return _shadowDOMSelectorsRe.reduce(function (result, pattern) { return result.replace(pattern, ' '); }, cssText);
	      };
	      // change a selector like 'div' to 'name div'
	      ShadowCss.prototype._scopeSelectors = function (cssText, scopeSelector, hostSelector) {
	          var _this = this;
	          return processRules(cssText, function (rule) {
	              var selector = rule.selector;
	              var content = rule.content;
	              if (rule.selector[0] != '@') {
	                  selector =
	                      _this._scopeSelector(rule.selector, scopeSelector, hostSelector, _this.strictStyling);
	              }
	              else if (rule.selector.startsWith('@media') || rule.selector.startsWith('@supports') ||
	                  rule.selector.startsWith('@page') || rule.selector.startsWith('@document')) {
	                  content = _this._scopeSelectors(rule.content, scopeSelector, hostSelector);
	              }
	              return new CssRule(selector, content);
	          });
	      };
	      ShadowCss.prototype._scopeSelector = function (selector, scopeSelector, hostSelector, strict) {
	          var _this = this;
	          return selector.split(',')
	              .map(function (part) { return part.trim().split(_shadowDeepSelectors); })
	              .map(function (deepParts) {
	              var shallowPart = deepParts[0], otherParts = deepParts.slice(1);
	              var applyScope = function (shallowPart) {
	                  if (_this._selectorNeedsScoping(shallowPart, scopeSelector)) {
	                      return strict ?
	                          _this._applyStrictSelectorScope(shallowPart, scopeSelector, hostSelector) :
	                          _this._applySelectorScope(shallowPart, scopeSelector, hostSelector);
	                  }
	                  else {
	                      return shallowPart;
	                  }
	              };
	              return [applyScope(shallowPart)].concat(otherParts).join(' ');
	          })
	              .join(', ');
	      };
	      ShadowCss.prototype._selectorNeedsScoping = function (selector, scopeSelector) {
	          var re = this._makeScopeMatcher(scopeSelector);
	          return !re.test(selector);
	      };
	      ShadowCss.prototype._makeScopeMatcher = function (scopeSelector) {
	          var lre = /\[/g;
	          var rre = /\]/g;
	          scopeSelector = scopeSelector.replace(lre, '\\[').replace(rre, '\\]');
	          return new RegExp('^(' + scopeSelector + ')' + _selectorReSuffix, 'm');
	      };
	      ShadowCss.prototype._applySelectorScope = function (selector, scopeSelector, hostSelector) {
	          // Difference from webcomponents.js: scopeSelector could not be an array
	          return this._applySimpleSelectorScope(selector, scopeSelector, hostSelector);
	      };
	      // scope via name and [is=name]
	      ShadowCss.prototype._applySimpleSelectorScope = function (selector, scopeSelector, hostSelector) {
	          // In Android browser, the lastIndex is not reset when the regex is used in String.replace()
	          _polyfillHostRe.lastIndex = 0;
	          if (_polyfillHostRe.test(selector)) {
	              var replaceBy_1 = this.strictStyling ? "[" + hostSelector + "]" : scopeSelector;
	              return selector
	                  .replace(_polyfillHostNoCombinatorRe, function (hnc, selector) { return selector[0] === ':' ? replaceBy_1 + selector : selector + replaceBy_1; })
	                  .replace(_polyfillHostRe, replaceBy_1 + ' ');
	          }
	          return scopeSelector + ' ' + selector;
	      };
	      // return a selector with [name] suffix on each simple selector
	      // e.g. .foo.bar > .zot becomes .foo[name].bar[name] > .zot[name]  /** @internal */
	      ShadowCss.prototype._applyStrictSelectorScope = function (selector, scopeSelector, hostSelector) {
	          var _this = this;
	          var isRe = /\[is=([^\]]*)\]/g;
	          scopeSelector = scopeSelector.replace(isRe, function (_) {
	              var parts = [];
	              for (var _i = 1; _i < arguments.length; _i++) {
	                  parts[_i - 1] = arguments[_i];
	              }
	              return parts[0];
	          });
	          var attrName = '[' + scopeSelector + ']';
	          var _scopeSelectorPart = function (p) {
	              var scopedP = p.trim();
	              if (!scopedP) {
	                  return '';
	              }
	              if (p.indexOf(_polyfillHostNoCombinator) > -1) {
	                  scopedP = _this._applySimpleSelectorScope(p, scopeSelector, hostSelector);
	              }
	              else {
	                  // remove :host since it should be unnecessary
	                  var t = p.replace(_polyfillHostRe, '');
	                  if (t.length > 0) {
	                      var matches = t.match(/([^:]*)(:*)(.*)/);
	                      if (matches !== null) {
	                          scopedP = matches[1] + attrName + matches[2] + matches[3];
	                      }
	                  }
	              }
	              return scopedP;
	          };
	          var attrSelectorIndex = 0;
	          var attrSelectors = [];
	          // replace attribute selectors with placeholders to avoid issue with white space being treated
	          // as separator
	          selector = selector.replace(/\[[^\]]*\]/g, function (attrSelector) {
	              var replaceBy = "__attr_sel_" + attrSelectorIndex + "__";
	              attrSelectors.push(attrSelector);
	              attrSelectorIndex++;
	              return replaceBy;
	          });
	          var scopedSelector = '';
	          var startIndex = 0;
	          var res;
	          var sep = /( |>|\+|~(?!=))\s*/g;
	          var scopeAfter = selector.indexOf(_polyfillHostNoCombinator);
	          while ((res = sep.exec(selector)) !== null) {
	              var separator = res[1];
	              var part = selector.slice(startIndex, res.index).trim();
	              // if a selector appears before :host-context it should not be shimmed as it
	              // matches on ancestor elements and not on elements in the host's shadow
	              var scopedPart = startIndex >= scopeAfter ? _scopeSelectorPart(part) : part;
	              scopedSelector += scopedPart + " " + separator + " ";
	              startIndex = sep.lastIndex;
	          }
	          scopedSelector += _scopeSelectorPart(selector.substring(startIndex));
	          // replace the placeholders with their original values
	          return scopedSelector.replace(/__attr_sel_(\d+)__/g, function (ph, index) { return attrSelectors[+index]; });
	      };
	      ShadowCss.prototype._insertPolyfillHostInCssText = function (selector) {
	          return selector.replace(_colonHostContextRe, _polyfillHostContext)
	              .replace(_colonHostRe, _polyfillHost);
	      };
	      return ShadowCss;
	  }());
	  var _cssContentNextSelectorRe = /polyfill-next-selector[^}]*content:[\s]*?(['"])(.*?)\1[;\s]*}([^{]*?){/gim;
	  var _cssContentRuleRe = /(polyfill-rule)[^}]*(content:[\s]*(['"])(.*?)\3)[;\s]*[^}]*}/gim;
	  var _cssContentUnscopedRuleRe = /(polyfill-unscoped-rule)[^}]*(content:[\s]*(['"])(.*?)\3)[;\s]*[^}]*}/gim;
	  var _polyfillHost = '-shadowcsshost';
	  // note: :host-context pre-processed to -shadowcsshostcontext.
	  var _polyfillHostContext = '-shadowcsscontext';
	  var _parenSuffix = ')(?:\\((' +
	      '(?:\\([^)(]*\\)|[^)(]*)+?' +
	      ')\\))?([^,{]*)';
	  var _cssColonHostRe = new RegExp('(' + _polyfillHost + _parenSuffix, 'gim');
	  var _cssColonHostContextRe = new RegExp('(' + _polyfillHostContext + _parenSuffix, 'gim');
	  var _polyfillHostNoCombinator = _polyfillHost + '-no-combinator';
	  var _polyfillHostNoCombinatorRe = /-shadowcsshost-no-combinator([^\s]*)/;
	  var _shadowDOMSelectorsRe = [
	      /::shadow/g,
	      /::content/g,
	      // Deprecated selectors
	      /\/shadow-deep\//g,
	      /\/shadow\//g,
	  ];
	  var _shadowDeepSelectors = /(?:>>>)|(?:\/deep\/)/g;
	  var _selectorReSuffix = '([>\\s~+\[.,{:][\\s\\S]*)?$';
	  var _polyfillHostRe = /-shadowcsshost/gim;
	  var _colonHostRe = /:host/gim;
	  var _colonHostContextRe = /:host-context/gim;
	  var _commentRe = /\/\*\s*[\s\S]*?\*\//g;
	  function stripComments(input) {
	      return input.replace(_commentRe, '');
	  }
	  // all comments except inline source mapping
	  var _sourceMappingUrlRe = /\/\*\s*#\s*sourceMappingURL=[\s\S]+?\*\//;
	  function extractSourceMappingUrl(input) {
	      var matcher = input.match(_sourceMappingUrlRe);
	      return matcher ? matcher[0] : '';
	  }
	  var _ruleRe = /(\s*)([^;\{\}]+?)(\s*)((?:{%BLOCK%}?\s*;?)|(?:\s*;))/g;
	  var _curlyRe = /([{}])/g;
	  var OPEN_CURLY = '{';
	  var CLOSE_CURLY = '}';
	  var BLOCK_PLACEHOLDER = '%BLOCK%';
	  var CssRule = (function () {
	      function CssRule(selector, content) {
	          this.selector = selector;
	          this.content = content;
	      }
	      return CssRule;
	  }());
	  function processRules(input, ruleCallback) {
	      var inputWithEscapedBlocks = escapeBlocks(input);
	      var nextBlockIndex = 0;
	      return inputWithEscapedBlocks.escapedString.replace(_ruleRe, function () {
	          var m = [];
	          for (var _i = 0; _i < arguments.length; _i++) {
	              m[_i - 0] = arguments[_i];
	          }
	          var selector = m[2];
	          var content = '';
	          var suffix = m[4];
	          var contentPrefix = '';
	          if (suffix && suffix.startsWith('{' + BLOCK_PLACEHOLDER)) {
	              content = inputWithEscapedBlocks.blocks[nextBlockIndex++];
	              suffix = suffix.substring(BLOCK_PLACEHOLDER.length + 1);
	              contentPrefix = '{';
	          }
	          var rule = ruleCallback(new CssRule(selector, content));
	          return "" + m[1] + rule.selector + m[3] + contentPrefix + rule.content + suffix;
	      });
	  }
	  var StringWithEscapedBlocks = (function () {
	      function StringWithEscapedBlocks(escapedString, blocks) {
	          this.escapedString = escapedString;
	          this.blocks = blocks;
	      }
	      return StringWithEscapedBlocks;
	  }());
	  function escapeBlocks(input) {
	      var inputParts = input.split(_curlyRe);
	      var resultParts = [];
	      var escapedBlocks = [];
	      var bracketCount = 0;
	      var currentBlockParts = [];
	      for (var partIndex = 0; partIndex < inputParts.length; partIndex++) {
	          var part = inputParts[partIndex];
	          if (part == CLOSE_CURLY) {
	              bracketCount--;
	          }
	          if (bracketCount > 0) {
	              currentBlockParts.push(part);
	          }
	          else {
	              if (currentBlockParts.length > 0) {
	                  escapedBlocks.push(currentBlockParts.join(''));
	                  resultParts.push(BLOCK_PLACEHOLDER);
	                  currentBlockParts = [];
	              }
	              resultParts.push(part);
	          }
	          if (part == OPEN_CURLY) {
	              bracketCount++;
	          }
	      }
	      if (currentBlockParts.length > 0) {
	          escapedBlocks.push(currentBlockParts.join(''));
	          resultParts.push(BLOCK_PLACEHOLDER);
	      }
	      return new StringWithEscapedBlocks(resultParts.join(''), escapedBlocks);
	  }

	  var COMPONENT_VARIABLE = '%COMP%';
	  var HOST_ATTR = "_nghost-" + COMPONENT_VARIABLE;
	  var CONTENT_ATTR = "_ngcontent-" + COMPONENT_VARIABLE;
	  var StylesCompileDependency = (function () {
	      function StylesCompileDependency(moduleUrl, isShimmed, valuePlaceholder) {
	          this.moduleUrl = moduleUrl;
	          this.isShimmed = isShimmed;
	          this.valuePlaceholder = valuePlaceholder;
	      }
	      return StylesCompileDependency;
	  }());
	  var StylesCompileResult = (function () {
	      function StylesCompileResult(componentStylesheet, externalStylesheets) {
	          this.componentStylesheet = componentStylesheet;
	          this.externalStylesheets = externalStylesheets;
	      }
	      return StylesCompileResult;
	  }());
	  var CompiledStylesheet = (function () {
	      function CompiledStylesheet(statements, stylesVar, dependencies, isShimmed, meta) {
	          this.statements = statements;
	          this.stylesVar = stylesVar;
	          this.dependencies = dependencies;
	          this.isShimmed = isShimmed;
	          this.meta = meta;
	      }
	      return CompiledStylesheet;
	  }());
	  var StyleCompiler = (function () {
	      function StyleCompiler(_urlResolver) {
	          this._urlResolver = _urlResolver;
	          this._shadowCss = new ShadowCss();
	      }
	      StyleCompiler.prototype.compileComponent = function (comp) {
	          var _this = this;
	          var externalStylesheets = [];
	          var componentStylesheet = this._compileStyles(comp, new CompileStylesheetMetadata({
	              styles: comp.template.styles,
	              styleUrls: comp.template.styleUrls,
	              moduleUrl: comp.type.moduleUrl
	          }), true);
	          comp.template.externalStylesheets.forEach(function (stylesheetMeta) {
	              var compiledStylesheet = _this._compileStyles(comp, stylesheetMeta, false);
	              externalStylesheets.push(compiledStylesheet);
	          });
	          return new StylesCompileResult(componentStylesheet, externalStylesheets);
	      };
	      StyleCompiler.prototype._compileStyles = function (comp, stylesheet, isComponentStylesheet) {
	          var _this = this;
	          var shim = comp.template.encapsulation === _angular_core.ViewEncapsulation.Emulated;
	          var styleExpressions = stylesheet.styles.map(function (plainStyle) { return literal(_this._shimIfNeeded(plainStyle, shim)); });
	          var dependencies = [];
	          for (var i = 0; i < stylesheet.styleUrls.length; i++) {
	              var identifier = new CompileIdentifierMetadata({ name: getStylesVarName(null) });
	              dependencies.push(new StylesCompileDependency(stylesheet.styleUrls[i], shim, identifier));
	              styleExpressions.push(new ExternalExpr(identifier));
	          }
	          // styles variable contains plain strings and arrays of other styles arrays (recursive),
	          // so we set its type to dynamic.
	          var stylesVar = getStylesVarName(isComponentStylesheet ? comp : null);
	          var stmt = variable(stylesVar)
	              .set(literalArr(styleExpressions, new ArrayType(DYNAMIC_TYPE, [TypeModifier.Const])))
	              .toDeclStmt(null, [StmtModifier.Final]);
	          return new CompiledStylesheet([stmt], stylesVar, dependencies, shim, stylesheet);
	      };
	      StyleCompiler.prototype._shimIfNeeded = function (style, shim) {
	          return shim ? this._shadowCss.shimCssText(style, CONTENT_ATTR, HOST_ATTR) : style;
	      };
	      StyleCompiler.decorators = [
	          { type: _angular_core.Injectable },
	      ];
	      /** @nocollapse */
	      StyleCompiler.ctorParameters = [
	          { type: UrlResolver, },
	      ];
	      return StyleCompiler;
	  }());
	  function getStylesVarName(component) {
	      var result = "styles";
	      if (component) {
	          result += "_" + component.type.name;
	      }
	      return result;
	  }

	  /**
	   * An internal module of the Angular compiler that begins with component types,
	   * extracts templates, and eventually produces a compiled version of the component
	   * ready for linking into an application.
	   *
	   * @security  When compiling templates at runtime, you must ensure that the entire template comes
	   * from a trusted source. Attacker-controlled data introduced by a template could expose your
	   * application to XSS risks.  For more detail, see the [Security Guide](http://g.co/ng/security).
	   */
	  var RuntimeCompiler = (function () {
	      function RuntimeCompiler(_injector, _metadataResolver, _templateNormalizer, _templateParser, _styleCompiler, _viewCompiler, _ngModuleCompiler, _directiveWrapperCompiler, _compilerConfig) {
	          this._injector = _injector;
	          this._metadataResolver = _metadataResolver;
	          this._templateNormalizer = _templateNormalizer;
	          this._templateParser = _templateParser;
	          this._styleCompiler = _styleCompiler;
	          this._viewCompiler = _viewCompiler;
	          this._ngModuleCompiler = _ngModuleCompiler;
	          this._directiveWrapperCompiler = _directiveWrapperCompiler;
	          this._compilerConfig = _compilerConfig;
	          this._compiledTemplateCache = new Map();
	          this._compiledHostTemplateCache = new Map();
	          this._compiledDirectiveWrapperCache = new Map();
	          this._compiledNgModuleCache = new Map();
	          this._animationParser = new AnimationParser();
	          this._animationCompiler = new AnimationCompiler();
	      }
	      Object.defineProperty(RuntimeCompiler.prototype, "injector", {
	          get: function () { return this._injector; },
	          enumerable: true,
	          configurable: true
	      });
	      RuntimeCompiler.prototype.compileModuleSync = function (moduleType) {
	          return this._compileModuleAndComponents(moduleType, true).syncResult;
	      };
	      RuntimeCompiler.prototype.compileModuleAsync = function (moduleType) {
	          return this._compileModuleAndComponents(moduleType, false).asyncResult;
	      };
	      RuntimeCompiler.prototype.compileModuleAndAllComponentsSync = function (moduleType) {
	          return this._compileModuleAndAllComponents(moduleType, true).syncResult;
	      };
	      RuntimeCompiler.prototype.compileModuleAndAllComponentsAsync = function (moduleType) {
	          return this._compileModuleAndAllComponents(moduleType, false).asyncResult;
	      };
	      RuntimeCompiler.prototype._compileModuleAndComponents = function (moduleType, isSync) {
	          var componentPromise = this._compileComponents(moduleType, isSync);
	          var ngModuleFactory = this._compileModule(moduleType);
	          return new SyncAsyncResult(ngModuleFactory, componentPromise.then(function () { return ngModuleFactory; }));
	      };
	      RuntimeCompiler.prototype._compileModuleAndAllComponents = function (moduleType, isSync) {
	          var _this = this;
	          var componentPromise = this._compileComponents(moduleType, isSync);
	          var ngModuleFactory = this._compileModule(moduleType);
	          var moduleMeta = this._metadataResolver.getNgModuleMetadata(moduleType);
	          var componentFactories = [];
	          var templates = new Set();
	          moduleMeta.transitiveModule.modules.forEach(function (localModuleMeta) {
	              localModuleMeta.declaredDirectives.forEach(function (dirMeta) {
	                  if (dirMeta.isComponent) {
	                      var template = _this._createCompiledHostTemplate(dirMeta.type.reference, localModuleMeta);
	                      templates.add(template);
	                      componentFactories.push(template.proxyComponentFactory);
	                  }
	              });
	          });
	          var syncResult = new _angular_core.ModuleWithComponentFactories(ngModuleFactory, componentFactories);
	          // Note: host components themselves can always be compiled synchronously as they have an
	          // inline template. However, we still need to wait for the components that they
	          // reference to be loaded / compiled.
	          var compile = function () {
	              templates.forEach(function (template) { _this._compileTemplate(template); });
	              return syncResult;
	          };
	          var asyncResult = isSync ? Promise.resolve(compile()) : componentPromise.then(compile);
	          return new SyncAsyncResult(syncResult, asyncResult);
	      };
	      RuntimeCompiler.prototype._compileModule = function (moduleType) {
	          var _this = this;
	          var ngModuleFactory = this._compiledNgModuleCache.get(moduleType);
	          if (!ngModuleFactory) {
	              var moduleMeta_1 = this._metadataResolver.getNgModuleMetadata(moduleType);
	              // Always provide a bound Compiler
	              var extraProviders = [this._metadataResolver.getProviderMetadata(new ProviderMeta(_angular_core.Compiler, { useFactory: function () { return new ModuleBoundCompiler(_this, moduleMeta_1.type.reference); } }))];
	              var compileResult = this._ngModuleCompiler.compile(moduleMeta_1, extraProviders);
	              compileResult.dependencies.forEach(function (dep) {
	                  dep.placeholder.reference =
	                      _this._assertComponentKnown(dep.comp.reference, true).proxyComponentFactory;
	                  dep.placeholder.name = "compFactory_" + dep.comp.name;
	              });
	              if (!this._compilerConfig.useJit) {
	                  ngModuleFactory =
	                      interpretStatements(compileResult.statements, compileResult.ngModuleFactoryVar);
	              }
	              else {
	                  ngModuleFactory = jitStatements("/" + moduleMeta_1.type.name + "/module.ngfactory.js", compileResult.statements, compileResult.ngModuleFactoryVar);
	              }
	              this._compiledNgModuleCache.set(moduleMeta_1.type.reference, ngModuleFactory);
	          }
	          return ngModuleFactory;
	      };
	      /**
	       * @internal
	       */
	      RuntimeCompiler.prototype._compileComponents = function (mainModule, isSync) {
	          var _this = this;
	          var templates = new Set();
	          var loadingPromises = [];
	          var ngModule = this._metadataResolver.getNgModuleMetadata(mainModule);
	          var moduleByDirective = new Map();
	          ngModule.transitiveModule.modules.forEach(function (localModuleMeta) {
	              localModuleMeta.declaredDirectives.forEach(function (dirMeta) {
	                  moduleByDirective.set(dirMeta.type.reference, localModuleMeta);
	                  _this._compileDirectiveWrapper(dirMeta, localModuleMeta);
	                  if (dirMeta.isComponent) {
	                      templates.add(_this._createCompiledTemplate(dirMeta, localModuleMeta));
	                  }
	              });
	          });
	          ngModule.transitiveModule.modules.forEach(function (localModuleMeta) {
	              localModuleMeta.declaredDirectives.forEach(function (dirMeta) {
	                  if (dirMeta.isComponent) {
	                      dirMeta.entryComponents.forEach(function (entryComponentType) {
	                          var moduleMeta = moduleByDirective.get(entryComponentType.reference);
	                          templates.add(_this._createCompiledHostTemplate(entryComponentType.reference, moduleMeta));
	                      });
	                  }
	              });
	              localModuleMeta.entryComponents.forEach(function (entryComponentType) {
	                  var moduleMeta = moduleByDirective.get(entryComponentType.reference);
	                  templates.add(_this._createCompiledHostTemplate(entryComponentType.reference, moduleMeta));
	              });
	          });
	          templates.forEach(function (template) {
	              if (template.loading) {
	                  if (isSync) {
	                      throw new ComponentStillLoadingError(template.compType.reference);
	                  }
	                  else {
	                      loadingPromises.push(template.loading);
	                  }
	              }
	          });
	          var compile = function () { templates.forEach(function (template) { _this._compileTemplate(template); }); };
	          if (isSync) {
	              compile();
	              return Promise.resolve(null);
	          }
	          else {
	              return Promise.all(loadingPromises).then(compile);
	          }
	      };
	      RuntimeCompiler.prototype.clearCacheFor = function (type) {
	          this._compiledNgModuleCache.delete(type);
	          this._metadataResolver.clearCacheFor(type);
	          this._compiledHostTemplateCache.delete(type);
	          var compiledTemplate = this._compiledTemplateCache.get(type);
	          if (compiledTemplate) {
	              this._templateNormalizer.clearCacheFor(compiledTemplate.normalizedCompMeta);
	              this._compiledTemplateCache.delete(type);
	          }
	      };
	      RuntimeCompiler.prototype.clearCache = function () {
	          this._metadataResolver.clearCache();
	          this._compiledTemplateCache.clear();
	          this._compiledHostTemplateCache.clear();
	          this._templateNormalizer.clearCache();
	          this._compiledNgModuleCache.clear();
	      };
	      RuntimeCompiler.prototype._createCompiledHostTemplate = function (compType, ngModule) {
	          if (!ngModule) {
	              throw new Error("Component " + stringify(compType) + " is not part of any NgModule or the module has not been imported into your module.");
	          }
	          var compiledTemplate = this._compiledHostTemplateCache.get(compType);
	          if (!compiledTemplate) {
	              var compMeta = this._metadataResolver.getDirectiveMetadata(compType);
	              assertComponent(compMeta);
	              var hostMeta = createHostComponentMeta(compMeta);
	              compiledTemplate = new CompiledTemplate(true, compMeta.selector, compMeta.type, ngModule, [compMeta], this._templateNormalizer.normalizeDirective(hostMeta));
	              this._compiledHostTemplateCache.set(compType, compiledTemplate);
	          }
	          return compiledTemplate;
	      };
	      RuntimeCompiler.prototype._createCompiledTemplate = function (compMeta, ngModule) {
	          var compiledTemplate = this._compiledTemplateCache.get(compMeta.type.reference);
	          if (!compiledTemplate) {
	              assertComponent(compMeta);
	              compiledTemplate = new CompiledTemplate(false, compMeta.selector, compMeta.type, ngModule, ngModule.transitiveModule.directives, this._templateNormalizer.normalizeDirective(compMeta));
	              this._compiledTemplateCache.set(compMeta.type.reference, compiledTemplate);
	          }
	          return compiledTemplate;
	      };
	      RuntimeCompiler.prototype._assertComponentKnown = function (compType, isHost) {
	          var compiledTemplate = isHost ? this._compiledHostTemplateCache.get(compType) :
	              this._compiledTemplateCache.get(compType);
	          if (!compiledTemplate) {
	              throw new Error("Illegal state: Compiled view for component " + stringify(compType) + " does not exist!");
	          }
	          return compiledTemplate;
	      };
	      RuntimeCompiler.prototype._assertComponentLoaded = function (compType, isHost) {
	          var compiledTemplate = this._assertComponentKnown(compType, isHost);
	          if (compiledTemplate.loading) {
	              throw new Error("Illegal state: CompiledTemplate for " + stringify(compType) + " (isHost: " + isHost + ") is still loading!");
	          }
	          return compiledTemplate;
	      };
	      RuntimeCompiler.prototype._assertDirectiveWrapper = function (dirType) {
	          var dirWrapper = this._compiledDirectiveWrapperCache.get(dirType);
	          if (!dirWrapper) {
	              throw new Error("Illegal state: Directive wrapper for " + stringify(dirType) + " has not been compiled!");
	          }
	          return dirWrapper;
	      };
	      RuntimeCompiler.prototype._compileDirectiveWrapper = function (dirMeta, moduleMeta) {
	          var compileResult = this._directiveWrapperCompiler.compile(dirMeta);
	          var statements = compileResult.statements;
	          var directiveWrapperClass;
	          if (!this._compilerConfig.useJit) {
	              directiveWrapperClass = interpretStatements(statements, compileResult.dirWrapperClassVar);
	          }
	          else {
	              directiveWrapperClass = jitStatements("/" + moduleMeta.type.name + "/" + dirMeta.type.name + "/wrapper.ngfactory.js", statements, compileResult.dirWrapperClassVar);
	          }
	          this._compiledDirectiveWrapperCache.set(dirMeta.type.reference, directiveWrapperClass);
	      };
	      RuntimeCompiler.prototype._compileTemplate = function (template) {
	          var _this = this;
	          if (template.isCompiled) {
	              return;
	          }
	          var compMeta = template.normalizedCompMeta;
	          var externalStylesheetsByModuleUrl = new Map();
	          var stylesCompileResult = this._styleCompiler.compileComponent(compMeta);
	          stylesCompileResult.externalStylesheets.forEach(function (r) { externalStylesheetsByModuleUrl.set(r.meta.moduleUrl, r); });
	          this._resolveStylesCompileResult(stylesCompileResult.componentStylesheet, externalStylesheetsByModuleUrl);
	          var viewCompMetas = template.viewComponentTypes.map(function (compType) { return _this._assertComponentLoaded(compType, false).normalizedCompMeta; });
	          var parsedAnimations = this._animationParser.parseComponent(compMeta);
	          var parsedTemplate = this._templateParser.parse(compMeta, compMeta.template.template, template.viewDirectives.concat(viewCompMetas), template.viewPipes, template.schemas, compMeta.type.name);
	          var compiledAnimations = this._animationCompiler.compile(compMeta.type.name, parsedAnimations);
	          var compileResult = this._viewCompiler.compileComponent(compMeta, parsedTemplate, variable(stylesCompileResult.componentStylesheet.stylesVar), template.viewPipes, compiledAnimations);
	          compileResult.dependencies.forEach(function (dep) {
	              var depTemplate;
	              if (dep instanceof ViewFactoryDependency) {
	                  var vfd = dep;
	                  depTemplate = _this._assertComponentLoaded(vfd.comp.reference, false);
	                  vfd.placeholder.reference = depTemplate.proxyViewFactory;
	                  vfd.placeholder.name = "viewFactory_" + vfd.comp.name;
	              }
	              else if (dep instanceof ComponentFactoryDependency) {
	                  var cfd = dep;
	                  depTemplate = _this._assertComponentLoaded(cfd.comp.reference, true);
	                  cfd.placeholder.reference = depTemplate.proxyComponentFactory;
	                  cfd.placeholder.name = "compFactory_" + cfd.comp.name;
	              }
	              else if (dep instanceof DirectiveWrapperDependency) {
	                  var dwd = dep;
	                  dwd.placeholder.reference = _this._assertDirectiveWrapper(dwd.dir.reference);
	              }
	          });
	          var statements = stylesCompileResult.componentStylesheet.statements.concat(compileResult.statements);
	          compiledAnimations.forEach(function (entry) { entry.statements.forEach(function (statement) { statements.push(statement); }); });
	          var factory;
	          if (!this._compilerConfig.useJit) {
	              factory = interpretStatements(statements, compileResult.viewFactoryVar);
	          }
	          else {
	              factory = jitStatements("/" + template.ngModule.type.name + "/" + template.compType.name + "/" + (template.isHost ? 'host' : 'component') + ".ngfactory.js", statements, compileResult.viewFactoryVar);
	          }
	          template.compiled(factory);
	      };
	      RuntimeCompiler.prototype._resolveStylesCompileResult = function (result, externalStylesheetsByModuleUrl) {
	          var _this = this;
	          result.dependencies.forEach(function (dep, i) {
	              var nestedCompileResult = externalStylesheetsByModuleUrl.get(dep.moduleUrl);
	              var nestedStylesArr = _this._resolveAndEvalStylesCompileResult(nestedCompileResult, externalStylesheetsByModuleUrl);
	              dep.valuePlaceholder.reference = nestedStylesArr;
	              dep.valuePlaceholder.name = "importedStyles" + i;
	          });
	      };
	      RuntimeCompiler.prototype._resolveAndEvalStylesCompileResult = function (result, externalStylesheetsByModuleUrl) {
	          this._resolveStylesCompileResult(result, externalStylesheetsByModuleUrl);
	          if (!this._compilerConfig.useJit) {
	              return interpretStatements(result.statements, result.stylesVar);
	          }
	          else {
	              return jitStatements("/" + result.meta.moduleUrl + ".css.js", result.statements, result.stylesVar);
	          }
	      };
	      RuntimeCompiler.decorators = [
	          { type: _angular_core.Injectable },
	      ];
	      /** @nocollapse */
	      RuntimeCompiler.ctorParameters = [
	          { type: _angular_core.Injector, },
	          { type: CompileMetadataResolver, },
	          { type: DirectiveNormalizer, },
	          { type: TemplateParser, },
	          { type: StyleCompiler, },
	          { type: ViewCompiler, },
	          { type: NgModuleCompiler, },
	          { type: DirectiveWrapperCompiler, },
	          { type: CompilerConfig, },
	      ];
	      return RuntimeCompiler;
	  }());
	  var CompiledTemplate = (function () {
	      function CompiledTemplate(isHost, selector, compType, ngModule, viewDirectiveAndComponents, _normalizeResult) {
	          var _this = this;
	          this.isHost = isHost;
	          this.compType = compType;
	          this.ngModule = ngModule;
	          this._viewFactory = null;
	          this.loading = null;
	          this._normalizedCompMeta = null;
	          this.isCompiled = false;
	          this.isCompiledWithDeps = false;
	          this.viewComponentTypes = [];
	          this.viewDirectives = [];
	          this.viewPipes = ngModule.transitiveModule.pipes;
	          this.schemas = ngModule.schemas;
	          viewDirectiveAndComponents.forEach(function (dirMeta) {
	              if (dirMeta.isComponent) {
	                  _this.viewComponentTypes.push(dirMeta.type.reference);
	              }
	              else {
	                  _this.viewDirectives.push(dirMeta);
	              }
	          });
	          this.proxyViewFactory = function () {
	              var args = [];
	              for (var _i = 0; _i < arguments.length; _i++) {
	                  args[_i - 0] = arguments[_i];
	              }
	              if (!_this._viewFactory) {
	                  throw new Error("Illegal state: CompiledTemplate for " + stringify(_this.compType) + " is not compiled yet!");
	              }
	              return _this._viewFactory.apply(null, args);
	          };
	          this.proxyComponentFactory = isHost ?
	              new _angular_core.ComponentFactory(selector, this.proxyViewFactory, compType.reference) :
	              null;
	          if (_normalizeResult.syncResult) {
	              this._normalizedCompMeta = _normalizeResult.syncResult;
	          }
	          else {
	              this.loading = _normalizeResult.asyncResult.then(function (normalizedCompMeta) {
	                  _this._normalizedCompMeta = normalizedCompMeta;
	                  _this.loading = null;
	              });
	          }
	      }
	      Object.defineProperty(CompiledTemplate.prototype, "normalizedCompMeta", {
	          get: function () {
	              if (this.loading) {
	                  throw new Error("Template is still loading for " + this.compType.name + "!");
	              }
	              return this._normalizedCompMeta;
	          },
	          enumerable: true,
	          configurable: true
	      });
	      CompiledTemplate.prototype.compiled = function (viewFactory) {
	          this._viewFactory = viewFactory;
	          this.isCompiled = true;
	      };
	      CompiledTemplate.prototype.depsCompiled = function () { this.isCompiledWithDeps = true; };
	      return CompiledTemplate;
	  }());
	  function assertComponent(meta) {
	      if (!meta.isComponent) {
	          throw new Error("Could not compile '" + meta.type.name + "' because it is not a component.");
	      }
	  }
	  /**
	   * Implements `Compiler` by delegating to the RuntimeCompiler using a known module.
	   */
	  var ModuleBoundCompiler = (function () {
	      function ModuleBoundCompiler(_delegate, _ngModule) {
	          this._delegate = _delegate;
	          this._ngModule = _ngModule;
	      }
	      Object.defineProperty(ModuleBoundCompiler.prototype, "_injector", {
	          get: function () { return this._delegate.injector; },
	          enumerable: true,
	          configurable: true
	      });
	      ModuleBoundCompiler.prototype.compileModuleSync = function (moduleType) {
	          return this._delegate.compileModuleSync(moduleType);
	      };
	      ModuleBoundCompiler.prototype.compileModuleAsync = function (moduleType) {
	          return this._delegate.compileModuleAsync(moduleType);
	      };
	      ModuleBoundCompiler.prototype.compileModuleAndAllComponentsSync = function (moduleType) {
	          return this._delegate.compileModuleAndAllComponentsSync(moduleType);
	      };
	      ModuleBoundCompiler.prototype.compileModuleAndAllComponentsAsync = function (moduleType) {
	          return this._delegate.compileModuleAndAllComponentsAsync(moduleType);
	      };
	      /**
	       * Clears all caches
	       */
	      ModuleBoundCompiler.prototype.clearCache = function () { this._delegate.clearCache(); };
	      /**
	       * Clears the cache for the given component/ngModule.
	       */
	      ModuleBoundCompiler.prototype.clearCacheFor = function (type) { this._delegate.clearCacheFor(type); };
	      return ModuleBoundCompiler;
	  }());

	  // =================================================================================================
	  // =================================================================================================
	  // =========== S T O P   -  S T O P   -  S T O P   -  S T O P   -  S T O P   -  S T O P  ===========
	  // =================================================================================================
	  // =================================================================================================
	  //
	  //        DO NOT EDIT THIS LIST OF SECURITY SENSITIVE PROPERTIES WITHOUT A SECURITY REVIEW!
	  //                               Reach out to mprobst for details.
	  //
	  // =================================================================================================
	  /** Map from tagName|propertyName SecurityContext. Properties applying to all tags use '*'. */
	  var SECURITY_SCHEMA = {};
	  function registerContext(ctx, specs) {
	      for (var _i = 0, specs_1 = specs; _i < specs_1.length; _i++) {
	          var spec = specs_1[_i];
	          SECURITY_SCHEMA[spec.toLowerCase()] = ctx;
	      }
	  }
	  // Case is insignificant below, all element and attribute names are lower-cased for lookup.
	  registerContext(_angular_core.SecurityContext.HTML, [
	      'iframe|srcdoc',
	      '*|innerHTML',
	      '*|outerHTML',
	  ]);
	  registerContext(_angular_core.SecurityContext.STYLE, ['*|style']);
	  // NB: no SCRIPT contexts here, they are never allowed due to the parser stripping them.
	  registerContext(_angular_core.SecurityContext.URL, [
	      '*|formAction', 'area|href', 'area|ping', 'audio|src', 'a|href',
	      'a|ping', 'blockquote|cite', 'body|background', 'del|cite', 'form|action',
	      'img|src', 'img|srcset', 'input|src', 'ins|cite', 'q|cite',
	      'source|src', 'source|srcset', 'track|src', 'video|poster', 'video|src',
	  ]);
	  registerContext(_angular_core.SecurityContext.RESOURCE_URL, [
	      'applet|code',
	      'applet|codebase',
	      'base|href',
	      'embed|src',
	      'frame|src',
	      'head|profile',
	      'html|manifest',
	      'iframe|src',
	      'link|href',
	      'media|src',
	      'object|codebase',
	      'object|data',
	      'script|src',
	  ]);

	  /**
	   * @license
	   * Copyright Google Inc. All Rights Reserved.
	   *
	   * Use of this source code is governed by an MIT-style license that can be
	   * found in the LICENSE file at https://angular.io/license
	   */
	  var __extends$21 = (this && this.__extends) || function (d, b) {
	      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	      function __() { this.constructor = d; }
	      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	  };
	  var BOOLEAN = 'boolean';
	  var NUMBER = 'number';
	  var STRING = 'string';
	  var OBJECT = 'object';
	  /**
	   * This array represents the DOM schema. It encodes inheritance, properties, and events.
	   *
	   * ## Overview
	   *
	   * Each line represents one kind of element. The `element_inheritance` and properties are joined
	   * using `element_inheritance|properties` syntax.
	   *
	   * ## Element Inheritance
	   *
	   * The `element_inheritance` can be further subdivided as `element1,element2,...^parentElement`.
	   * Here the individual elements are separated by `,` (commas). Every element in the list
	   * has identical properties.
	   *
	   * An `element` may inherit additional properties from `parentElement` If no `^parentElement` is
	   * specified then `""` (blank) element is assumed.
	   *
	   * NOTE: The blank element inherits from root `[Element]` element, the super element of all
	   * elements.
	   *
	   * NOTE an element prefix such as `:svg:` has no special meaning to the schema.
	   *
	   * ## Properties
	   *
	   * Each element has a set of properties separated by `,` (commas). Each property can be prefixed
	   * by a special character designating its type:
	   *
	   * - (no prefix): property is a string.
	   * - `*`: property represents an event.
	   * - `!`: property is a boolean.
	   * - `#`: property is a number.
	   * - `%`: property is an object.
	   *
	   * ## Query
	   *
	   * The class creates an internal squas representation which allows to easily answer the query of
	   * if a given property exist on a given element.
	   *
	   * NOTE: We don't yet support querying for types or events.
	   * NOTE: This schema is auto extracted from `schema_extractor.ts` located in the test folder,
	   *       see dom_element_schema_registry_spec.ts
	   */
	  // =================================================================================================
	  // =================================================================================================
	  // =========== S T O P   -  S T O P   -  S T O P   -  S T O P   -  S T O P   -  S T O P  ===========
	  // =================================================================================================
	  // =================================================================================================
	  //
	  //                       DO NOT EDIT THIS DOM SCHEMA WITHOUT A SECURITY REVIEW!
	  //
	  // Newly added properties must be security reviewed and assigned an appropriate SecurityContext in
	  // dom_security_schema.ts. Reach out to mprobst & rjamet for details.
	  //
	  // =================================================================================================
	  var SCHEMA = [
	      '[Element]|textContent,%classList,className,id,innerHTML,*beforecopy,*beforecut,*beforepaste,*copy,*cut,*paste,*search,*selectstart,*webkitfullscreenchange,*webkitfullscreenerror,*wheel,outerHTML,#scrollLeft,#scrollTop',
	      '[HTMLElement]^[Element]|accessKey,contentEditable,dir,!draggable,!hidden,innerText,lang,*abort,*beforecopy,*beforecut,*beforepaste,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*copy,*cuechange,*cut,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*message,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*mozfullscreenchange,*mozfullscreenerror,*mozpointerlockchange,*mozpointerlockerror,*paste,*pause,*play,*playing,*progress,*ratechange,*reset,*resize,*scroll,*search,*seeked,*seeking,*select,*selectstart,*show,*stalled,*submit,*suspend,*timeupdate,*toggle,*volumechange,*waiting,*webglcontextcreationerror,*webglcontextlost,*webglcontextrestored,*webkitfullscreenchange,*webkitfullscreenerror,*wheel,outerText,!spellcheck,%style,#tabIndex,title,!translate',
	      'abbr,address,article,aside,b,bdi,bdo,cite,code,dd,dfn,dt,em,figcaption,figure,footer,header,i,kbd,main,mark,nav,noscript,rb,rp,rt,rtc,ruby,s,samp,section,small,strong,sub,sup,u,var,wbr^[HTMLElement]|accessKey,contentEditable,dir,!draggable,!hidden,innerText,lang,*abort,*beforecopy,*beforecut,*beforepaste,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*copy,*cuechange,*cut,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*message,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*mozfullscreenchange,*mozfullscreenerror,*mozpointerlockchange,*mozpointerlockerror,*paste,*pause,*play,*playing,*progress,*ratechange,*reset,*resize,*scroll,*search,*seeked,*seeking,*select,*selectstart,*show,*stalled,*submit,*suspend,*timeupdate,*toggle,*volumechange,*waiting,*webglcontextcreationerror,*webglcontextlost,*webglcontextrestored,*webkitfullscreenchange,*webkitfullscreenerror,*wheel,outerText,!spellcheck,%style,#tabIndex,title,!translate',
	      'media^[HTMLElement]|!autoplay,!controls,%crossOrigin,#currentTime,!defaultMuted,#defaultPlaybackRate,!disableRemotePlayback,!loop,!muted,*encrypted,#playbackRate,preload,src,%srcObject,#volume',
	      ':svg:^[HTMLElement]|*abort,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*cuechange,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*pause,*play,*playing,*progress,*ratechange,*reset,*resize,*scroll,*seeked,*seeking,*select,*show,*stalled,*submit,*suspend,*timeupdate,*toggle,*volumechange,*waiting,%style,#tabIndex',
	      ':svg:graphics^:svg:|',
	      ':svg:animation^:svg:|*begin,*end,*repeat',
	      ':svg:geometry^:svg:|',
	      ':svg:componentTransferFunction^:svg:|',
	      ':svg:gradient^:svg:|',
	      ':svg:textContent^:svg:graphics|',
	      ':svg:textPositioning^:svg:textContent|',
	      'a^[HTMLElement]|charset,coords,download,hash,host,hostname,href,hreflang,name,password,pathname,ping,port,protocol,referrerPolicy,rel,rev,search,shape,target,text,type,username',
	      'area^[HTMLElement]|alt,coords,hash,host,hostname,href,!noHref,password,pathname,ping,port,protocol,referrerPolicy,search,shape,target,username',
	      'audio^media|',
	      'br^[HTMLElement]|clear',
	      'base^[HTMLElement]|href,target',
	      'body^[HTMLElement]|aLink,background,bgColor,link,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,text,vLink',
	      'button^[HTMLElement]|!autofocus,!disabled,formAction,formEnctype,formMethod,!formNoValidate,formTarget,name,type,value',
	      'canvas^[HTMLElement]|#height,#width',
	      'content^[HTMLElement]|select',
	      'dl^[HTMLElement]|!compact',
	      'datalist^[HTMLElement]|',
	      'details^[HTMLElement]|!open',
	      'dialog^[HTMLElement]|!open,returnValue',
	      'dir^[HTMLElement]|!compact',
	      'div^[HTMLElement]|align',
	      'embed^[HTMLElement]|align,height,name,src,type,width',
	      'fieldset^[HTMLElement]|!disabled,name',
	      'font^[HTMLElement]|color,face,size',
	      'form^[HTMLElement]|acceptCharset,action,autocomplete,encoding,enctype,method,name,!noValidate,target',
	      'frame^[HTMLElement]|frameBorder,longDesc,marginHeight,marginWidth,name,!noResize,scrolling,src',
	      'frameset^[HTMLElement]|cols,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,rows',
	      'hr^[HTMLElement]|align,color,!noShade,size,width',
	      'head^[HTMLElement]|',
	      'h1,h2,h3,h4,h5,h6^[HTMLElement]|align',
	      'html^[HTMLElement]|version',
	      'iframe^[HTMLElement]|align,!allowFullscreen,frameBorder,height,longDesc,marginHeight,marginWidth,name,referrerPolicy,%sandbox,scrolling,src,srcdoc,width',
	      'img^[HTMLElement]|align,alt,border,%crossOrigin,#height,#hspace,!isMap,longDesc,lowsrc,name,referrerPolicy,sizes,src,srcset,useMap,#vspace,#width',
	      'input^[HTMLElement]|accept,align,alt,autocapitalize,autocomplete,!autofocus,!checked,!defaultChecked,defaultValue,dirName,!disabled,%files,formAction,formEnctype,formMethod,!formNoValidate,formTarget,#height,!incremental,!indeterminate,max,#maxLength,min,#minLength,!multiple,name,pattern,placeholder,!readOnly,!required,selectionDirection,#selectionEnd,#selectionStart,#size,src,step,type,useMap,value,%valueAsDate,#valueAsNumber,#width',
	      'keygen^[HTMLElement]|!autofocus,challenge,!disabled,keytype,name',
	      'li^[HTMLElement]|type,#value',
	      'label^[HTMLElement]|htmlFor',
	      'legend^[HTMLElement]|align',
	      'link^[HTMLElement]|as,charset,%crossOrigin,!disabled,href,hreflang,integrity,media,rel,%relList,rev,%sizes,target,type',
	      'map^[HTMLElement]|name',
	      'marquee^[HTMLElement]|behavior,bgColor,direction,height,#hspace,#loop,#scrollAmount,#scrollDelay,!trueSpeed,#vspace,width',
	      'menu^[HTMLElement]|!compact',
	      'meta^[HTMLElement]|content,httpEquiv,name,scheme',
	      'meter^[HTMLElement]|#high,#low,#max,#min,#optimum,#value',
	      'ins,del^[HTMLElement]|cite,dateTime',
	      'ol^[HTMLElement]|!compact,!reversed,#start,type',
	      'object^[HTMLElement]|align,archive,border,code,codeBase,codeType,data,!declare,height,#hspace,name,standby,type,useMap,#vspace,width',
	      'optgroup^[HTMLElement]|!disabled,label',
	      'option^[HTMLElement]|!defaultSelected,!disabled,label,!selected,text,value',
	      'output^[HTMLElement]|defaultValue,%htmlFor,name,value',
	      'p^[HTMLElement]|align',
	      'param^[HTMLElement]|name,type,value,valueType',
	      'picture^[HTMLElement]|',
	      'pre^[HTMLElement]|#width',
	      'progress^[HTMLElement]|#max,#value',
	      'q,blockquote,cite^[HTMLElement]|',
	      'script^[HTMLElement]|!async,charset,%crossOrigin,!defer,event,htmlFor,integrity,src,text,type',
	      'select^[HTMLElement]|!autofocus,!disabled,#length,!multiple,name,!required,#selectedIndex,#size,value',
	      'shadow^[HTMLElement]|',
	      'source^[HTMLElement]|media,sizes,src,srcset,type',
	      'span^[HTMLElement]|',
	      'style^[HTMLElement]|!disabled,media,type',
	      'caption^[HTMLElement]|align',
	      'th,td^[HTMLElement]|abbr,align,axis,bgColor,ch,chOff,#colSpan,headers,height,!noWrap,#rowSpan,scope,vAlign,width',
	      'col,colgroup^[HTMLElement]|align,ch,chOff,#span,vAlign,width',
	      'table^[HTMLElement]|align,bgColor,border,%caption,cellPadding,cellSpacing,frame,rules,summary,%tFoot,%tHead,width',
	      'tr^[HTMLElement]|align,bgColor,ch,chOff,vAlign',
	      'tfoot,thead,tbody^[HTMLElement]|align,ch,chOff,vAlign',
	      'template^[HTMLElement]|',
	      'textarea^[HTMLElement]|autocapitalize,!autofocus,#cols,defaultValue,dirName,!disabled,#maxLength,#minLength,name,placeholder,!readOnly,!required,#rows,selectionDirection,#selectionEnd,#selectionStart,value,wrap',
	      'title^[HTMLElement]|text',
	      'track^[HTMLElement]|!default,kind,label,src,srclang',
	      'ul^[HTMLElement]|!compact,type',
	      'unknown^[HTMLElement]|',
	      'video^media|#height,poster,#width',
	      ':svg:a^:svg:graphics|',
	      ':svg:animate^:svg:animation|',
	      ':svg:animateMotion^:svg:animation|',
	      ':svg:animateTransform^:svg:animation|',
	      ':svg:circle^:svg:geometry|',
	      ':svg:clipPath^:svg:graphics|',
	      ':svg:cursor^:svg:|',
	      ':svg:defs^:svg:graphics|',
	      ':svg:desc^:svg:|',
	      ':svg:discard^:svg:|',
	      ':svg:ellipse^:svg:geometry|',
	      ':svg:feBlend^:svg:|',
	      ':svg:feColorMatrix^:svg:|',
	      ':svg:feComponentTransfer^:svg:|',
	      ':svg:feComposite^:svg:|',
	      ':svg:feConvolveMatrix^:svg:|',
	      ':svg:feDiffuseLighting^:svg:|',
	      ':svg:feDisplacementMap^:svg:|',
	      ':svg:feDistantLight^:svg:|',
	      ':svg:feDropShadow^:svg:|',
	      ':svg:feFlood^:svg:|',
	      ':svg:feFuncA^:svg:componentTransferFunction|',
	      ':svg:feFuncB^:svg:componentTransferFunction|',
	      ':svg:feFuncG^:svg:componentTransferFunction|',
	      ':svg:feFuncR^:svg:componentTransferFunction|',
	      ':svg:feGaussianBlur^:svg:|',
	      ':svg:feImage^:svg:|',
	      ':svg:feMerge^:svg:|',
	      ':svg:feMergeNode^:svg:|',
	      ':svg:feMorphology^:svg:|',
	      ':svg:feOffset^:svg:|',
	      ':svg:fePointLight^:svg:|',
	      ':svg:feSpecularLighting^:svg:|',
	      ':svg:feSpotLight^:svg:|',
	      ':svg:feTile^:svg:|',
	      ':svg:feTurbulence^:svg:|',
	      ':svg:filter^:svg:|',
	      ':svg:foreignObject^:svg:graphics|',
	      ':svg:g^:svg:graphics|',
	      ':svg:image^:svg:graphics|',
	      ':svg:line^:svg:geometry|',
	      ':svg:linearGradient^:svg:gradient|',
	      ':svg:mpath^:svg:|',
	      ':svg:marker^:svg:|',
	      ':svg:mask^:svg:|',
	      ':svg:metadata^:svg:|',
	      ':svg:path^:svg:geometry|',
	      ':svg:pattern^:svg:|',
	      ':svg:polygon^:svg:geometry|',
	      ':svg:polyline^:svg:geometry|',
	      ':svg:radialGradient^:svg:gradient|',
	      ':svg:rect^:svg:geometry|',
	      ':svg:svg^:svg:graphics|#currentScale,#zoomAndPan',
	      ':svg:script^:svg:|type',
	      ':svg:set^:svg:animation|',
	      ':svg:stop^:svg:|',
	      ':svg:style^:svg:|!disabled,media,title,type',
	      ':svg:switch^:svg:graphics|',
	      ':svg:symbol^:svg:|',
	      ':svg:tspan^:svg:textPositioning|',
	      ':svg:text^:svg:textPositioning|',
	      ':svg:textPath^:svg:textContent|',
	      ':svg:title^:svg:|',
	      ':svg:use^:svg:graphics|',
	      ':svg:view^:svg:|#zoomAndPan',
	      'data^[HTMLElement]|value',
	      'menuitem^[HTMLElement]|type,label,icon,!disabled,!checked,radiogroup,!default',
	      'summary^[HTMLElement]|',
	      'time^[HTMLElement]|dateTime',
	  ];
	  var _ATTR_TO_PROP = {
	      'class': 'className',
	      'formaction': 'formAction',
	      'innerHtml': 'innerHTML',
	      'readonly': 'readOnly',
	      'tabindex': 'tabIndex',
	  };
	  var DomElementSchemaRegistry = (function (_super) {
	      __extends$21(DomElementSchemaRegistry, _super);
	      function DomElementSchemaRegistry() {
	          var _this = this;
	          _super.call(this);
	          this._schema = {};
	          SCHEMA.forEach(function (encodedType) {
	              var type = {};
	              var _a = encodedType.split('|'), strType = _a[0], strProperties = _a[1];
	              var properties = strProperties.split(',');
	              var _b = strType.split('^'), typeNames = _b[0], superName = _b[1];
	              typeNames.split(',').forEach(function (tag) { return _this._schema[tag.toLowerCase()] = type; });
	              var superType = superName && _this._schema[superName.toLowerCase()];
	              if (superType) {
	                  Object.keys(superType).forEach(function (prop) { type[prop] = superType[prop]; });
	              }
	              properties.forEach(function (property) {
	                  if (property.length > 0) {
	                      switch (property[0]) {
	                          case '*':
	                              // We don't yet support events.
	                              // If ever allowing to bind to events, GO THROUGH A SECURITY REVIEW, allowing events
	                              // will
	                              // almost certainly introduce bad XSS vulnerabilities.
	                              // type[property.substring(1)] = EVENT;
	                              break;
	                          case '!':
	                              type[property.substring(1)] = BOOLEAN;
	                              break;
	                          case '#':
	                              type[property.substring(1)] = NUMBER;
	                              break;
	                          case '%':
	                              type[property.substring(1)] = OBJECT;
	                              break;
	                          default:
	                              type[property] = STRING;
	                      }
	                  }
	              });
	          });
	      }
	      DomElementSchemaRegistry.prototype.hasProperty = function (tagName, propName, schemaMetas) {
	          if (schemaMetas.some(function (schema) { return schema.name === _angular_core.NO_ERRORS_SCHEMA.name; })) {
	              return true;
	          }
	          if (tagName.indexOf('-') > -1) {
	              if (tagName === 'ng-container' || tagName === 'ng-content') {
	                  return false;
	              }
	              if (schemaMetas.some(function (schema) { return schema.name === _angular_core.CUSTOM_ELEMENTS_SCHEMA.name; })) {
	                  // Can't tell now as we don't know which properties a custom element will get
	                  // once it is instantiated
	                  return true;
	              }
	          }
	          var elementProperties = this._schema[tagName.toLowerCase()] || this._schema['unknown'];
	          return !!elementProperties[propName];
	      };
	      DomElementSchemaRegistry.prototype.hasElement = function (tagName, schemaMetas) {
	          if (schemaMetas.some(function (schema) { return schema.name === _angular_core.NO_ERRORS_SCHEMA.name; })) {
	              return true;
	          }
	          if (tagName.indexOf('-') > -1) {
	              if (tagName === 'ng-container' || tagName === 'ng-content') {
	                  return true;
	              }
	              if (schemaMetas.some(function (schema) { return schema.name === _angular_core.CUSTOM_ELEMENTS_SCHEMA.name; })) {
	                  // Allow any custom elements
	                  return true;
	              }
	          }
	          return !!this._schema[tagName.toLowerCase()];
	      };
	      /**
	       * securityContext returns the security context for the given property on the given DOM tag.
	       *
	       * Tag and property name are statically known and cannot change at runtime, i.e. it is not
	       * possible to bind a value into a changing attribute or tag name.
	       *
	       * The filtering is white list based. All attributes in the schema above are assumed to have the
	       * 'NONE' security context, i.e. that they are safe inert string values. Only specific well known
	       * attack vectors are assigned their appropriate context.
	       */
	      DomElementSchemaRegistry.prototype.securityContext = function (tagName, propName, isAttribute) {
	          if (isAttribute) {
	              // NB: For security purposes, use the mapped property name, not the attribute name.
	              propName = this.getMappedPropName(propName);
	          }
	          // Make sure comparisons are case insensitive, so that case differences between attribute and
	          // property names do not have a security impact.
	          tagName = tagName.toLowerCase();
	          propName = propName.toLowerCase();
	          var ctx = SECURITY_SCHEMA[tagName + '|' + propName];
	          if (ctx) {
	              return ctx;
	          }
	          ctx = SECURITY_SCHEMA['*|' + propName];
	          return ctx ? ctx : _angular_core.SecurityContext.NONE;
	      };
	      DomElementSchemaRegistry.prototype.getMappedPropName = function (propName) { return _ATTR_TO_PROP[propName] || propName; };
	      DomElementSchemaRegistry.prototype.getDefaultComponentElementName = function () { return 'ng-component'; };
	      DomElementSchemaRegistry.prototype.validateProperty = function (name) {
	          if (name.toLowerCase().startsWith('on')) {
	              var msg = ("Binding to event property '" + name + "' is disallowed for security reasons, ") +
	                  ("please use (" + name.slice(2) + ")=...") +
	                  ("\nIf '" + name + "' is a directive input, make sure the directive is imported by the") +
	                  " current module.";
	              return { error: true, msg: msg };
	          }
	          else {
	              return { error: false };
	          }
	      };
	      DomElementSchemaRegistry.prototype.validateAttribute = function (name) {
	          if (name.toLowerCase().startsWith('on')) {
	              var msg = ("Binding to event attribute '" + name + "' is disallowed for security reasons, ") +
	                  ("please use (" + name.slice(2) + ")=...");
	              return { error: true, msg: msg };
	          }
	          else {
	              return { error: false };
	          }
	      };
	      DomElementSchemaRegistry.prototype.allKnownElementNames = function () { return Object.keys(this._schema); };
	      DomElementSchemaRegistry.decorators = [
	          { type: _angular_core.Injectable },
	      ];
	      /** @nocollapse */
	      DomElementSchemaRegistry.ctorParameters = [];
	      return DomElementSchemaRegistry;
	  }(ElementSchemaRegistry));

	  var _NO_RESOURCE_LOADER = {
	      get: function (url) {
	          throw new Error("No ResourceLoader implementation has been provided. Can't read the url \"" + url + "\"");
	      }
	  };
	  /**
	   * A set of providers that provide `RuntimeCompiler` and its dependencies to use for
	   * template compilation.
	   */
	  var COMPILER_PROVIDERS = [
	      { provide: Reflector, useValue: reflector },
	      { provide: ReflectorReader, useExisting: Reflector },
	      { provide: ResourceLoader, useValue: _NO_RESOURCE_LOADER },
	      Console,
	      Lexer,
	      Parser,
	      HtmlParser,
	      {
	          provide: I18NHtmlParser,
	          useFactory: function (parser, translations, format) {
	              return new I18NHtmlParser(parser, translations, format);
	          },
	          deps: [
	              HtmlParser,
	              [new _angular_core.Optional(), new _angular_core.Inject(_angular_core.TRANSLATIONS)],
	              [new _angular_core.Optional(), new _angular_core.Inject(_angular_core.TRANSLATIONS_FORMAT)],
	          ]
	      },
	      TemplateParser,
	      DirectiveNormalizer,
	      CompileMetadataResolver,
	      DEFAULT_PACKAGE_URL_PROVIDER,
	      StyleCompiler,
	      ViewCompiler,
	      NgModuleCompiler,
	      DirectiveWrapperCompiler,
	      { provide: CompilerConfig, useValue: new CompilerConfig() },
	      RuntimeCompiler,
	      { provide: _angular_core.Compiler, useExisting: RuntimeCompiler },
	      DomElementSchemaRegistry,
	      { provide: ElementSchemaRegistry, useExisting: DomElementSchemaRegistry },
	      UrlResolver,
	      DirectiveResolver,
	      PipeResolver,
	      NgModuleResolver
	  ];
	  var RuntimeCompilerFactory = (function () {
	      function RuntimeCompilerFactory(defaultOptions) {
	          this._defaultOptions = [{
	                  useDebug: _angular_core.isDevMode(),
	                  useJit: true,
	                  defaultEncapsulation: _angular_core.ViewEncapsulation.Emulated
	              }].concat(defaultOptions);
	      }
	      RuntimeCompilerFactory.prototype.createCompiler = function (options) {
	          if (options === void 0) { options = []; }
	          var mergedOptions = _mergeOptions(this._defaultOptions.concat(options));
	          var injector = _angular_core.ReflectiveInjector.resolveAndCreate([
	              COMPILER_PROVIDERS, {
	                  provide: CompilerConfig,
	                  useFactory: function () {
	                      return new CompilerConfig({
	                          // let explicit values from the compiler options overwrite options
	                          // from the app providers. E.g. important for the testing platform.
	                          genDebugInfo: mergedOptions.useDebug,
	                          // let explicit values from the compiler options overwrite options
	                          // from the app providers
	                          useJit: mergedOptions.useJit,
	                          // let explicit values from the compiler options overwrite options
	                          // from the app providers
	                          defaultEncapsulation: mergedOptions.defaultEncapsulation,
	                          logBindingUpdate: mergedOptions.useDebug
	                      });
	                  },
	                  deps: []
	              },
	              mergedOptions.providers
	          ]);
	          return injector.get(_angular_core.Compiler);
	      };
	      RuntimeCompilerFactory.decorators = [
	          { type: _angular_core.Injectable },
	      ];
	      /** @nocollapse */
	      RuntimeCompilerFactory.ctorParameters = [
	          { type: Array, decorators: [{ type: _angular_core.Inject, args: [_angular_core.COMPILER_OPTIONS,] },] },
	      ];
	      return RuntimeCompilerFactory;
	  }());
	  function _initReflector() {
	      reflector.reflectionCapabilities = new ReflectionCapabilities();
	  }
	  /**
	   * A platform that included corePlatform and the compiler.
	   *
	   * @experimental
	   */
	  var platformCoreDynamic = _angular_core.createPlatformFactory(_angular_core.platformCore, 'coreDynamic', [
	      { provide: _angular_core.COMPILER_OPTIONS, useValue: {}, multi: true },
	      { provide: _angular_core.CompilerFactory, useClass: RuntimeCompilerFactory },
	      { provide: _angular_core.PLATFORM_INITIALIZER, useValue: _initReflector, multi: true },
	  ]);
	  function _mergeOptions(optionsArr) {
	      return {
	          useDebug: _lastDefined(optionsArr.map(function (options) { return options.useDebug; })),
	          useJit: _lastDefined(optionsArr.map(function (options) { return options.useJit; })),
	          defaultEncapsulation: _lastDefined(optionsArr.map(function (options) { return options.defaultEncapsulation; })),
	          providers: _mergeArrays(optionsArr.map(function (options) { return options.providers; }))
	      };
	  }
	  function _lastDefined(args) {
	      for (var i = args.length - 1; i >= 0; i--) {
	          if (args[i] !== undefined) {
	              return args[i];
	          }
	      }
	      return undefined;
	  }
	  function _mergeArrays(parts) {
	      var result = [];
	      parts.forEach(function (part) { return part && result.push.apply(result, part); });
	      return result;
	  }

	  /**
	   * @license
	   * Copyright Google Inc. All Rights Reserved.
	   *
	   * Use of this source code is governed by an MIT-style license that can be
	   * found in the LICENSE file at https://angular.io/license
	   */
	  // asset:<package-name>/<realm>/<path-to-module>
	  var _ASSET_URL_RE = /asset:([^\/]+)\/([^\/]+)\/(.+)/;
	  /**
	   * Interface that defines how import statements should be generated.
	   */
	  var ImportGenerator = (function () {
	      function ImportGenerator() {
	      }
	      ImportGenerator.parseAssetUrl = function (url) { return AssetUrl.parse(url); };
	      return ImportGenerator;
	  }());
	  var AssetUrl = (function () {
	      function AssetUrl(packageName, firstLevelDir, modulePath) {
	          this.packageName = packageName;
	          this.firstLevelDir = firstLevelDir;
	          this.modulePath = modulePath;
	      }
	      AssetUrl.parse = function (url, allowNonMatching) {
	          if (allowNonMatching === void 0) { allowNonMatching = true; }
	          var match = url.match(_ASSET_URL_RE);
	          if (match !== null) {
	              return new AssetUrl(match[1], match[2], match[3]);
	          }
	          if (allowNonMatching) {
	              return null;
	          }
	          throw new Error("Url " + url + " is not a valid asset: url");
	      };
	      return AssetUrl;
	  }());

	  exports.TEMPLATE_TRANSFORMS = TEMPLATE_TRANSFORMS;
	  exports.CompilerConfig = CompilerConfig;
	  exports.RenderTypes = RenderTypes;
	  exports.RuntimeCompiler = RuntimeCompiler;
	  exports.DirectiveResolver = DirectiveResolver;
	  exports.PipeResolver = PipeResolver;
	  exports.NgModuleResolver = NgModuleResolver;
	  exports.DEFAULT_INTERPOLATION_CONFIG = DEFAULT_INTERPOLATION_CONFIG;
	  exports.InterpolationConfig = InterpolationConfig;
	  exports.NgModuleCompiler = NgModuleCompiler;
	  exports.DirectiveWrapperCompiler = DirectiveWrapperCompiler;
	  exports.ViewCompiler = ViewCompiler;
	  exports.TextAst = TextAst;
	  exports.BoundTextAst = BoundTextAst;
	  exports.AttrAst = AttrAst;
	  exports.BoundElementPropertyAst = BoundElementPropertyAst;
	  exports.BoundEventAst = BoundEventAst;
	  exports.ReferenceAst = ReferenceAst;
	  exports.VariableAst = VariableAst;
	  exports.ElementAst = ElementAst;
	  exports.EmbeddedTemplateAst = EmbeddedTemplateAst;
	  exports.BoundDirectivePropertyAst = BoundDirectivePropertyAst;
	  exports.DirectiveAst = DirectiveAst;
	  exports.ProviderAst = ProviderAst;
	  exports.NgContentAst = NgContentAst;
	  exports.templateVisitAll = templateVisitAll;
	  exports.CompileMetadataWithIdentifier = CompileMetadataWithIdentifier;
	  exports.CompileAnimationEntryMetadata = CompileAnimationEntryMetadata;
	  exports.CompileAnimationStateMetadata = CompileAnimationStateMetadata;
	  exports.CompileAnimationStateDeclarationMetadata = CompileAnimationStateDeclarationMetadata;
	  exports.CompileAnimationStateTransitionMetadata = CompileAnimationStateTransitionMetadata;
	  exports.CompileAnimationMetadata = CompileAnimationMetadata;
	  exports.CompileAnimationKeyframesSequenceMetadata = CompileAnimationKeyframesSequenceMetadata;
	  exports.CompileAnimationStyleMetadata = CompileAnimationStyleMetadata;
	  exports.CompileAnimationAnimateMetadata = CompileAnimationAnimateMetadata;
	  exports.CompileAnimationWithStepsMetadata = CompileAnimationWithStepsMetadata;
	  exports.CompileAnimationSequenceMetadata = CompileAnimationSequenceMetadata;
	  exports.CompileAnimationGroupMetadata = CompileAnimationGroupMetadata;
	  exports.CompileIdentifierMetadata = CompileIdentifierMetadata;
	  exports.CompileDiDependencyMetadata = CompileDiDependencyMetadata;
	  exports.CompileProviderMetadata = CompileProviderMetadata;
	  exports.CompileFactoryMetadata = CompileFactoryMetadata;
	  exports.CompileTokenMetadata = CompileTokenMetadata;
	  exports.CompileTypeMetadata = CompileTypeMetadata;
	  exports.CompileQueryMetadata = CompileQueryMetadata;
	  exports.CompileStylesheetMetadata = CompileStylesheetMetadata;
	  exports.CompileTemplateMetadata = CompileTemplateMetadata;
	  exports.CompileDirectiveMetadata = CompileDirectiveMetadata;
	  exports.createHostComponentMeta = createHostComponentMeta;
	  exports.CompilePipeMetadata = CompilePipeMetadata;
	  exports.CompileNgModuleMetadata = CompileNgModuleMetadata;
	  exports.TransitiveCompileNgModuleMetadata = TransitiveCompileNgModuleMetadata;
	  exports.removeIdentifierDuplicates = removeIdentifierDuplicates;
	  exports.isStaticSymbol = isStaticSymbol;
	  exports.ProviderMeta = ProviderMeta;
	  exports.SourceModule = SourceModule;
	  exports.analyzeNgModules = analyzeNgModules;
	  exports.OfflineCompiler = OfflineCompiler;
	  exports.createUrlResolverWithoutPackagePrefix = createUrlResolverWithoutPackagePrefix;
	  exports.createOfflineCompileUrlResolver = createOfflineCompileUrlResolver;
	  exports.DEFAULT_PACKAGE_URL_PROVIDER = DEFAULT_PACKAGE_URL_PROVIDER;
	  exports.UrlResolver = UrlResolver;
	  exports.getUrlScheme = getUrlScheme;
	  exports.ResourceLoader = ResourceLoader;
	  exports.COMPILER_PROVIDERS = COMPILER_PROVIDERS;
	  exports.RuntimeCompilerFactory = RuntimeCompilerFactory;
	  exports.platformCoreDynamic = platformCoreDynamic;
	  exports.ElementSchemaRegistry = ElementSchemaRegistry;
	  exports.I18NHtmlParser = I18NHtmlParser;
	  exports.MessageBundle = MessageBundle;
	  exports.Xliff = Xliff;
	  exports.Xmb = Xmb;
	  exports.Xtb = Xtb;
	  exports.DirectiveNormalizer = DirectiveNormalizer;
	  exports.Lexer = Lexer;
	  exports.Token = Token;
	  exports.EOF = EOF;
	  exports.isIdentifier = isIdentifier;
	  exports.isQuote = isQuote;
	  exports.SplitInterpolation = SplitInterpolation;
	  exports.TemplateBindingParseResult = TemplateBindingParseResult;
	  exports.Parser = Parser;
	  exports._ParseAST = _ParseAST;
	  exports.CompileMetadataResolver = CompileMetadataResolver;
	  exports.HtmlParser = HtmlParser;
	  exports.ParseTreeResult = ParseTreeResult;
	  exports.TreeError = TreeError;
	  exports.ImportGenerator = ImportGenerator;
	  exports.AssetUrl = AssetUrl;
	  exports.debugOutputAstAsTypeScript = debugOutputAstAsTypeScript;
	  exports.TypeScriptEmitter = TypeScriptEmitter;
	  exports.ParseLocation = ParseLocation;
	  exports.ParseSourceFile = ParseSourceFile;
	  exports.ParseSourceSpan = ParseSourceSpan;
	  exports.ParseError = ParseError;
	  exports.DomElementSchemaRegistry = DomElementSchemaRegistry;
	  exports.CssSelector = CssSelector;
	  exports.SelectorMatcher = SelectorMatcher;
	  exports.SelectorListContext = SelectorListContext;
	  exports.SelectorContext = SelectorContext;
	  exports.StylesCompileDependency = StylesCompileDependency;
	  exports.StylesCompileResult = StylesCompileResult;
	  exports.CompiledStylesheet = CompiledStylesheet;
	  exports.StyleCompiler = StyleCompiler;
	  exports.TemplateParseError = TemplateParseError;
	  exports.TemplateParseResult = TemplateParseResult;
	  exports.TemplateParser = TemplateParser;
	  exports.splitClasses = splitClasses;

	}));


/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/**
	 * @license Angular v2.1.2
	 * (c) 2010-2016 Google, Inc. https://angular.io/
	 * License: MIT
	 */
	(function (global, factory) {
	     true ? factory(exports, __webpack_require__(4), __webpack_require__(5)) :
	    typeof define === 'function' && define.amd ? define(['exports', 'rxjs/Subject', 'rxjs/Observable'], factory) :
	    (factory((global.ng = global.ng || {}, global.ng.core = global.ng.core || {}),global.Rx,global.Rx));
	}(this, function (exports,rxjs_Subject,rxjs_Observable) { 'use strict';

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var globalScope;
	    if (typeof window === 'undefined') {
	        if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) {
	            // TODO: Replace any with WorkerGlobalScope from lib.webworker.d.ts #3492
	            globalScope = self;
	        }
	        else {
	            globalScope = global;
	        }
	    }
	    else {
	        globalScope = window;
	    }
	    function scheduleMicroTask(fn) {
	        Zone.current.scheduleMicroTask('scheduleMicrotask', fn);
	    }
	    // Need to declare a new variable for global here since TypeScript
	    // exports the original value of the symbol.
	    var global$1 = globalScope;
	    function getTypeNameForDebugging(type) {
	        return type['name'] || typeof type;
	    }
	    // TODO: remove calls to assert in production environment
	    // Note: Can't just export this and import in in other files
	    // as `assert` is a reserved keyword in Dart
	    global$1.assert = function assert(condition) {
	        // TODO: to be fixed properly via #2830, noop for now
	    };
	    function isPresent(obj) {
	        return obj != null;
	    }
	    function isBlank(obj) {
	        return obj == null;
	    }
	    function stringify(token) {
	        if (typeof token === 'string') {
	            return token;
	        }
	        if (token === undefined || token === null) {
	            return '' + token;
	        }
	        if (token.overriddenName) {
	            return token.overriddenName;
	        }
	        if (token.name) {
	            return token.name;
	        }
	        var res = token.toString();
	        var newLineIndex = res.indexOf('\n');
	        return newLineIndex === -1 ? res : res.substring(0, newLineIndex);
	    }
	    // JS has NaN !== NaN
	    function looseIdentical(a, b) {
	        return a === b || typeof a === 'number' && typeof b === 'number' && isNaN(a) && isNaN(b);
	    }
	    function isJsObject(o) {
	        return o !== null && (typeof o === 'function' || typeof o === 'object');
	    }
	    function print(obj) {
	        console.log(obj);
	    }
	    function warn(obj) {
	        console.warn(obj);
	    }
	    var _symbolIterator = null;
	    function getSymbolIterator() {
	        if (!_symbolIterator) {
	            if (globalScope.Symbol && Symbol.iterator) {
	                _symbolIterator = Symbol.iterator;
	            }
	            else {
	                // es6-shim specific logic
	                var keys = Object.getOwnPropertyNames(Map.prototype);
	                for (var i = 0; i < keys.length; ++i) {
	                    var key = keys[i];
	                    if (key !== 'entries' && key !== 'size' &&
	                        Map.prototype[key] === Map.prototype['entries']) {
	                        _symbolIterator = key;
	                    }
	                }
	            }
	        }
	        return _symbolIterator;
	    }
	    function isPrimitive(obj) {
	        return !isJsObject(obj);
	    }

	    var _nextClassId = 0;
	    var Reflect = global$1.Reflect;
	    function extractAnnotation(annotation) {
	        if (typeof annotation === 'function' && annotation.hasOwnProperty('annotation')) {
	            // it is a decorator, extract annotation
	            annotation = annotation.annotation;
	        }
	        return annotation;
	    }
	    function applyParams(fnOrArray, key) {
	        if (fnOrArray === Object || fnOrArray === String || fnOrArray === Function ||
	            fnOrArray === Number || fnOrArray === Array) {
	            throw new Error("Can not use native " + stringify(fnOrArray) + " as constructor");
	        }
	        if (typeof fnOrArray === 'function') {
	            return fnOrArray;
	        }
	        if (Array.isArray(fnOrArray)) {
	            var annotations = fnOrArray;
	            var annoLength = annotations.length - 1;
	            var fn = fnOrArray[annoLength];
	            if (typeof fn !== 'function') {
	                throw new Error("Last position of Class method array must be Function in key " + key + " was '" + stringify(fn) + "'");
	            }
	            if (annoLength != fn.length) {
	                throw new Error("Number of annotations (" + annoLength + ") does not match number of arguments (" + fn.length + ") in the function: " + stringify(fn));
	            }
	            var paramsAnnotations = [];
	            for (var i = 0, ii = annotations.length - 1; i < ii; i++) {
	                var paramAnnotations = [];
	                paramsAnnotations.push(paramAnnotations);
	                var annotation = annotations[i];
	                if (Array.isArray(annotation)) {
	                    for (var j = 0; j < annotation.length; j++) {
	                        paramAnnotations.push(extractAnnotation(annotation[j]));
	                    }
	                }
	                else if (typeof annotation === 'function') {
	                    paramAnnotations.push(extractAnnotation(annotation));
	                }
	                else {
	                    paramAnnotations.push(annotation);
	                }
	            }
	            Reflect.defineMetadata('parameters', paramsAnnotations, fn);
	            return fn;
	        }
	        throw new Error("Only Function or Array is supported in Class definition for key '" + key + "' is '" + stringify(fnOrArray) + "'");
	    }
	    /**
	     * Provides a way for expressing ES6 classes with parameter annotations in ES5.
	     *
	     * ## Basic Example
	     *
	     * ```
	     * var Greeter = ng.Class({
	     *   constructor: function(name) {
	     *     this.name = name;
	     *   },
	     *
	     *   greet: function() {
	     *     alert('Hello ' + this.name + '!');
	     *   }
	     * });
	     * ```
	     *
	     * is equivalent to ES6:
	     *
	     * ```
	     * class Greeter {
	     *   constructor(name) {
	     *     this.name = name;
	     *   }
	     *
	     *   greet() {
	     *     alert('Hello ' + this.name + '!');
	     *   }
	     * }
	     * ```
	     *
	     * or equivalent to ES5:
	     *
	     * ```
	     * var Greeter = function (name) {
	     *   this.name = name;
	     * }
	     *
	     * Greeter.prototype.greet = function () {
	     *   alert('Hello ' + this.name + '!');
	     * }
	     * ```
	     *
	     * ### Example with parameter annotations
	     *
	     * ```
	     * var MyService = ng.Class({
	     *   constructor: [String, [new Optional(), Service], function(name, myService) {
	     *     ...
	     *   }]
	     * });
	     * ```
	     *
	     * is equivalent to ES6:
	     *
	     * ```
	     * class MyService {
	     *   constructor(name: string, @Optional() myService: Service) {
	     *     ...
	     *   }
	     * }
	     * ```
	     *
	     * ### Example with inheritance
	     *
	     * ```
	     * var Shape = ng.Class({
	     *   constructor: (color) {
	     *     this.color = color;
	     *   }
	     * });
	     *
	     * var Square = ng.Class({
	     *   extends: Shape,
	     *   constructor: function(color, size) {
	     *     Shape.call(this, color);
	     *     this.size = size;
	     *   }
	     * });
	     * ```
	     * @stable
	     */
	    function Class(clsDef) {
	        var constructor = applyParams(clsDef.hasOwnProperty('constructor') ? clsDef.constructor : undefined, 'constructor');
	        var proto = constructor.prototype;
	        if (clsDef.hasOwnProperty('extends')) {
	            if (typeof clsDef.extends === 'function') {
	                constructor.prototype = proto =
	                    Object.create(clsDef.extends.prototype);
	            }
	            else {
	                throw new Error("Class definition 'extends' property must be a constructor function was: " + stringify(clsDef.extends));
	            }
	        }
	        for (var key in clsDef) {
	            if (key !== 'extends' && key !== 'prototype' && clsDef.hasOwnProperty(key)) {
	                proto[key] = applyParams(clsDef[key], key);
	            }
	        }
	        if (this && this.annotations instanceof Array) {
	            Reflect.defineMetadata('annotations', this.annotations, constructor);
	        }
	        var constructorName = constructor['name'];
	        if (!constructorName || constructorName === 'constructor') {
	            constructor['overriddenName'] = "class" + _nextClassId++;
	        }
	        return constructor;
	    }
	    function makeDecorator(name, props, parentClass, chainFn) {
	        if (chainFn === void 0) { chainFn = null; }
	        var metaCtor = makeMetadataCtor([props]);
	        function DecoratorFactory(objOrType) {
	            if (!(Reflect && Reflect.getMetadata)) {
	                throw 'reflect-metadata shim is required when using class decorators';
	            }
	            if (this instanceof DecoratorFactory) {
	                metaCtor.call(this, objOrType);
	                return this;
	            }
	            var annotationInstance = new DecoratorFactory(objOrType);
	            var chainAnnotation = typeof this === 'function' && Array.isArray(this.annotations) ? this.annotations : [];
	            chainAnnotation.push(annotationInstance);
	            var TypeDecorator = function TypeDecorator(cls) {
	                var annotations = Reflect.getOwnMetadata('annotations', cls) || [];
	                annotations.push(annotationInstance);
	                Reflect.defineMetadata('annotations', annotations, cls);
	                return cls;
	            };
	            TypeDecorator.annotations = chainAnnotation;
	            TypeDecorator.Class = Class;
	            if (chainFn)
	                chainFn(TypeDecorator);
	            return TypeDecorator;
	        }
	        if (parentClass) {
	            DecoratorFactory.prototype = Object.create(parentClass.prototype);
	        }
	        DecoratorFactory.prototype.toString = function () { return ("@" + name); };
	        DecoratorFactory.annotationCls = DecoratorFactory;
	        return DecoratorFactory;
	    }
	    function makeMetadataCtor(props) {
	        return function ctor() {
	            var _this = this;
	            var args = [];
	            for (var _i = 0; _i < arguments.length; _i++) {
	                args[_i - 0] = arguments[_i];
	            }
	            props.forEach(function (prop, i) {
	                var argVal = args[i];
	                if (Array.isArray(prop)) {
	                    // plain parameter
	                    _this[prop[0]] = argVal === undefined ? prop[1] : argVal;
	                }
	                else {
	                    for (var propName in prop) {
	                        _this[propName] =
	                            argVal && argVal.hasOwnProperty(propName) ? argVal[propName] : prop[propName];
	                    }
	                }
	            });
	        };
	    }
	    function makeParamDecorator(name, props, parentClass) {
	        var metaCtor = makeMetadataCtor(props);
	        function ParamDecoratorFactory() {
	            var args = [];
	            for (var _i = 0; _i < arguments.length; _i++) {
	                args[_i - 0] = arguments[_i];
	            }
	            if (this instanceof ParamDecoratorFactory) {
	                metaCtor.apply(this, args);
	                return this;
	            }
	            var annotationInstance = new ((_a = ParamDecoratorFactory).bind.apply(_a, [void 0].concat(args)))();
	            ParamDecorator.annotation = annotationInstance;
	            return ParamDecorator;
	            function ParamDecorator(cls, unusedKey, index) {
	                var parameters = Reflect.getMetadata('parameters', cls) || [];
	                // there might be gaps if some in between parameters do not have annotations.
	                // we pad with nulls.
	                while (parameters.length <= index) {
	                    parameters.push(null);
	                }
	                parameters[index] = parameters[index] || [];
	                parameters[index].push(annotationInstance);
	                Reflect.defineMetadata('parameters', parameters, cls);
	                return cls;
	            }
	            var _a;
	        }
	        if (parentClass) {
	            ParamDecoratorFactory.prototype = Object.create(parentClass.prototype);
	        }
	        ParamDecoratorFactory.prototype.toString = function () { return ("@" + name); };
	        ParamDecoratorFactory.annotationCls = ParamDecoratorFactory;
	        return ParamDecoratorFactory;
	    }
	    function makePropDecorator(name, props, parentClass) {
	        var metaCtor = makeMetadataCtor(props);
	        function PropDecoratorFactory() {
	            var args = [];
	            for (var _i = 0; _i < arguments.length; _i++) {
	                args[_i - 0] = arguments[_i];
	            }
	            if (this instanceof PropDecoratorFactory) {
	                metaCtor.apply(this, args);
	                return this;
	            }
	            var decoratorInstance = new ((_a = PropDecoratorFactory).bind.apply(_a, [void 0].concat(args)))();
	            return function PropDecorator(target, name) {
	                var meta = Reflect.getOwnMetadata('propMetadata', target.constructor) || {};
	                meta[name] = meta.hasOwnProperty(name) && meta[name] || [];
	                meta[name].unshift(decoratorInstance);
	                Reflect.defineMetadata('propMetadata', meta, target.constructor);
	            };
	            var _a;
	        }
	        if (parentClass) {
	            PropDecoratorFactory.prototype = Object.create(parentClass.prototype);
	        }
	        PropDecoratorFactory.prototype.toString = function () { return ("@" + name); };
	        PropDecoratorFactory.annotationCls = PropDecoratorFactory;
	        return PropDecoratorFactory;
	    }

	    /**
	     * Inject decorator and metadata.
	     *
	     * @stable
	     * @Annotation
	     */
	    var Inject = makeParamDecorator('Inject', [['token', undefined]]);
	    /**
	     * Optional decorator and metadata.
	     *
	     * @stable
	     * @Annotation
	     */
	    var Optional = makeParamDecorator('Optional', []);
	    /**
	     * Injectable decorator and metadata.
	     *
	     * @stable
	     * @Annotation
	     */
	    var Injectable = makeParamDecorator('Injectable', []);
	    /**
	     * Self decorator and metadata.
	     *
	     * @stable
	     * @Annotation
	     */
	    var Self = makeParamDecorator('Self', []);
	    /**
	     * SkipSelf decorator and metadata.
	     *
	     * @stable
	     * @Annotation
	     */
	    var SkipSelf = makeParamDecorator('SkipSelf', []);
	    /**
	     * Host decorator and metadata.
	     *
	     * @stable
	     * @Annotation
	     */
	    var Host = makeParamDecorator('Host', []);

	    /**
	     * Creates a token that can be used in a DI Provider.
	     *
	     * ### Example ([live demo](http://plnkr.co/edit/Ys9ezXpj2Mnoy3Uc8KBp?p=preview))
	     *
	     * ```typescript
	     * var t = new OpaqueToken("value");
	     *
	     * var injector = Injector.resolveAndCreate([
	     *   {provide: t, useValue: "bindingValue"}
	     * ]);
	     *
	     * expect(injector.get(t)).toEqual("bindingValue");
	     * ```
	     *
	     * Using an `OpaqueToken` is preferable to using strings as tokens because of possible collisions
	     * caused by multiple providers using the same string as two different tokens.
	     *
	     * Using an `OpaqueToken` is preferable to using an `Object` as tokens because it provides better
	     * error messages.
	     * @stable
	     */
	    // so that metadata is gathered for this class
	    var OpaqueToken = (function () {
	        function OpaqueToken(_desc) {
	            this._desc = _desc;
	        }
	        OpaqueToken.prototype.toString = function () { return "Token " + this._desc; };
	        OpaqueToken.decorators = [
	            { type: Injectable },
	        ];
	        /** @nocollapse */
	        OpaqueToken.ctorParameters = [
	            null,
	        ];
	        return OpaqueToken;
	    }());

	    /**
	     * This token can be used to create a virtual provider that will populate the
	     * `entryComponents` fields of components and ng modules based on its `useValue`.
	     * All components that are referenced in the `useValue` value (either directly
	     * or in a nested array or map) will be added to the `entryComponents` property.
	     *
	     * ### Example
	     * The following example shows how the router can populate the `entryComponents`
	     * field of an NgModule based on the router configuration which refers
	     * to components.
	     *
	     * ```typescript
	     * // helper function inside the router
	     * function provideRoutes(routes) {
	     *   return [
	     *     {provide: ROUTES, useValue: routes},
	     *     {provide: ANALYZE_FOR_ENTRY_COMPONENTS, useValue: routes, multi: true}
	     *   ];
	     * }
	     *
	     * // user code
	     * let routes = [
	     *   {path: '/root', component: RootComp},
	     *   {path: '/teams', component: TeamsComp}
	     * ];
	     *
	     * @NgModule({
	     *   providers: [provideRoutes(routes)]
	     * })
	     * class ModuleWithRoutes {}
	     * ```
	     *
	     * @experimental
	     */
	    var ANALYZE_FOR_ENTRY_COMPONENTS = new OpaqueToken('AnalyzeForEntryComponents');
	    /**
	     * Attribute decorator and metadata.
	     *
	     * @stable
	     * @Annotation
	     */
	    var Attribute = makeParamDecorator('Attribute', [['attributeName', undefined]]);
	    /**
	     * Base class for query metadata.
	     *
	     * See {@link ContentChildren}, {@link ContentChild}, {@link ViewChildren}, {@link ViewChild} for
	     * more information.
	     *
	     * @stable
	     */
	    var Query = (function () {
	        function Query() {
	        }
	        return Query;
	    }());
	    /**
	     * ContentChildren decorator and metadata.
	     *
	     *  @stable
	     *  @Annotation
	     */
	    var ContentChildren = makePropDecorator('ContentChildren', [
	        ['selector', undefined], {
	            first: false,
	            isViewQuery: false,
	            descendants: false,
	            read: undefined,
	        }
	    ], Query);
	    /**
	     * @whatItDoes Configures a content query.
	     *
	     * @howToUse
	     *
	     * {@example core/di/ts/contentChild/content_child_howto.ts region='HowTo'}
	     *
	     * @description
	     *
	     * You can use ContentChild to get the first element or the directive matching the selector from the
	     * content DOM. If the content DOM changes, and a new child matches the selector,
	     * the property will be updated.
	     *
	     * Content queries are set before the `ngAfterContentInit` callback is called.
	     *
	     * **Metadata Properties**:
	     *
	     * * **selector** - the directive type or the name used for querying.
	     * * **read** - read a different token from the queried element.
	     *
	     * Let's look at an example:
	     *
	     * {@example core/di/ts/contentChild/content_child_example.ts region='Component'}
	     *
	     * **npm package**: `@angular/core`
	     *
	     * @stable
	     * @Annotation
	     */
	    var ContentChild = makePropDecorator('ContentChild', [
	        ['selector', undefined], {
	            first: true,
	            isViewQuery: false,
	            descendants: true,
	            read: undefined,
	        }
	    ], Query);
	    /**
	     * @whatItDoes Configures a view query.
	     *
	     * @howToUse
	     *
	     * {@example core/di/ts/viewChildren/view_children_howto.ts region='HowTo'}
	     *
	     * @description
	     *
	     * You can use ViewChildren to get the {@link QueryList} of elements or directives from the
	     * view DOM. Any time a child element is added, removed, or moved, the query list will be updated,
	     * and the changes observable of the query list will emit a new value.
	     *
	     * View queries are set before the `ngAfterViewInit` callback is called.
	     *
	     * **Metadata Properties**:
	     *
	     * * **selector** - the directive type or the name used for querying.
	     * * **read** - read a different token from the queried elements.
	     *
	     * Let's look at an example:
	     *
	     * {@example core/di/ts/viewChildren/view_children_example.ts region='Component'}
	     *
	     * **npm package**: `@angular/core`
	     *
	     * @stable
	     * @Annotation
	     */
	    var ViewChildren = makePropDecorator('ViewChildren', [
	        ['selector', undefined], {
	            first: false,
	            isViewQuery: true,
	            descendants: true,
	            read: undefined,
	        }
	    ], Query);
	    /**
	     * ViewChild decorator and metadata.
	     *
	     * @stable
	     * @Annotation
	     */
	    var ViewChild = makePropDecorator('ViewChild', [
	        ['selector', undefined], {
	            first: true,
	            isViewQuery: true,
	            descendants: true,
	            read: undefined,
	        }
	    ], Query);

	    /**
	     * Describes within the change detector which strategy will be used the next time change
	     * detection is triggered.
	     * @stable
	     */
	    exports.ChangeDetectionStrategy;
	    (function (ChangeDetectionStrategy) {
	        /**
	         * `OnPush` means that the change detector's mode will be set to `CheckOnce` during hydration.
	         */
	        ChangeDetectionStrategy[ChangeDetectionStrategy["OnPush"] = 0] = "OnPush";
	        /**
	         * `Default` means that the change detector's mode will be set to `CheckAlways` during hydration.
	         */
	        ChangeDetectionStrategy[ChangeDetectionStrategy["Default"] = 1] = "Default";
	    })(exports.ChangeDetectionStrategy || (exports.ChangeDetectionStrategy = {}));
	    /**
	     * Describes the status of the detector.
	     */
	    var ChangeDetectorStatus;
	    (function (ChangeDetectorStatus) {
	        /**
	         * `CheckedOnce` means that after calling detectChanges the mode of the change detector
	         * will become `Checked`.
	         */
	        ChangeDetectorStatus[ChangeDetectorStatus["CheckOnce"] = 0] = "CheckOnce";
	        /**
	         * `Checked` means that the change detector should be skipped until its mode changes to
	         * `CheckOnce`.
	         */
	        ChangeDetectorStatus[ChangeDetectorStatus["Checked"] = 1] = "Checked";
	        /**
	         * `CheckAlways` means that after calling detectChanges the mode of the change detector
	         * will remain `CheckAlways`.
	         */
	        ChangeDetectorStatus[ChangeDetectorStatus["CheckAlways"] = 2] = "CheckAlways";
	        /**
	         * `Detached` means that the change detector sub tree is not a part of the main tree and
	         * should be skipped.
	         */
	        ChangeDetectorStatus[ChangeDetectorStatus["Detached"] = 3] = "Detached";
	        /**
	         * `Errored` means that the change detector encountered an error checking a binding
	         * or calling a directive lifecycle method and is now in an inconsistent state. Change
	         * detectors in this state will no longer detect changes.
	         */
	        ChangeDetectorStatus[ChangeDetectorStatus["Errored"] = 4] = "Errored";
	        /**
	         * `Destroyed` means that the change detector is destroyed.
	         */
	        ChangeDetectorStatus[ChangeDetectorStatus["Destroyed"] = 5] = "Destroyed";
	    })(ChangeDetectorStatus || (ChangeDetectorStatus = {}));
	    function isDefaultChangeDetectionStrategy(changeDetectionStrategy) {
	        return isBlank(changeDetectionStrategy) ||
	            changeDetectionStrategy === exports.ChangeDetectionStrategy.Default;
	    }

	    /**
	     * Directive decorator and metadata.
	     *
	     * @stable
	     * @Annotation
	     */
	    var Directive = makeDecorator('Directive', {
	        selector: undefined,
	        inputs: undefined,
	        outputs: undefined,
	        host: undefined,
	        providers: undefined,
	        exportAs: undefined,
	        queries: undefined
	    });
	    /**
	     * Component decorator and metadata.
	     *
	     * @stable
	     * @Annotation
	     */
	    var Component = makeDecorator('Component', {
	        selector: undefined,
	        inputs: undefined,
	        outputs: undefined,
	        host: undefined,
	        exportAs: undefined,
	        moduleId: undefined,
	        providers: undefined,
	        viewProviders: undefined,
	        changeDetection: exports.ChangeDetectionStrategy.Default,
	        queries: undefined,
	        templateUrl: undefined,
	        template: undefined,
	        styleUrls: undefined,
	        styles: undefined,
	        animations: undefined,
	        encapsulation: undefined,
	        interpolation: undefined,
	        entryComponents: undefined
	    }, Directive);
	    /**
	     * Pipe decorator and metadata.
	     *
	     * @stable
	     * @Annotation
	     */
	    var Pipe = makeDecorator('Pipe', {
	        name: undefined,
	        pure: true,
	    });
	    /**
	     * Input decorator and metadata.
	     *
	     * @stable
	     * @Annotation
	     */
	    var Input = makePropDecorator('Input', [['bindingPropertyName', undefined]]);
	    /**
	     * Output decorator and metadata.
	     *
	     * @stable
	     * @Annotation
	     */
	    var Output = makePropDecorator('Output', [['bindingPropertyName', undefined]]);
	    /**
	     * HostBinding decorator and metadata.
	     *
	     * @stable
	     * @Annotation
	     */
	    var HostBinding = makePropDecorator('HostBinding', [['hostPropertyName', undefined]]);
	    /**
	     * HostBinding decorator and metadata.
	     *
	     * @stable
	     * @Annotation
	     */
	    var HostListener = makePropDecorator('HostListener', [['eventName', undefined], ['args', []]]);

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    /**
	     * @stable
	     */
	    var LifecycleHooks;
	    (function (LifecycleHooks) {
	        LifecycleHooks[LifecycleHooks["OnInit"] = 0] = "OnInit";
	        LifecycleHooks[LifecycleHooks["OnDestroy"] = 1] = "OnDestroy";
	        LifecycleHooks[LifecycleHooks["DoCheck"] = 2] = "DoCheck";
	        LifecycleHooks[LifecycleHooks["OnChanges"] = 3] = "OnChanges";
	        LifecycleHooks[LifecycleHooks["AfterContentInit"] = 4] = "AfterContentInit";
	        LifecycleHooks[LifecycleHooks["AfterContentChecked"] = 5] = "AfterContentChecked";
	        LifecycleHooks[LifecycleHooks["AfterViewInit"] = 6] = "AfterViewInit";
	        LifecycleHooks[LifecycleHooks["AfterViewChecked"] = 7] = "AfterViewChecked";
	    })(LifecycleHooks || (LifecycleHooks = {}));
	    var LIFECYCLE_HOOKS_VALUES = [
	        LifecycleHooks.OnInit, LifecycleHooks.OnDestroy, LifecycleHooks.DoCheck, LifecycleHooks.OnChanges,
	        LifecycleHooks.AfterContentInit, LifecycleHooks.AfterContentChecked, LifecycleHooks.AfterViewInit,
	        LifecycleHooks.AfterViewChecked
	    ];
	    /**
	     * @whatItDoes Lifecycle hook that is called when any data-bound property of a directive changes.
	     * @howToUse
	     * {@example core/ts/metadata/lifecycle_hooks_spec.ts region='OnChanges'}
	     *
	     * @description
	     * `ngOnChanges` is called right after the data-bound properties have been checked and before view
	     * and content children are checked if at least one of them has changed.
	     * The `changes` parameter contains the changed properties.
	     *
	     * See {@linkDocs guide/lifecycle-hooks#onchanges "Lifecycle Hooks Guide"}.
	     *
	     * @stable
	     */
	    var OnChanges = (function () {
	        function OnChanges() {
	        }
	        return OnChanges;
	    }());
	    /**
	     * @whatItDoes Lifecycle hook that is called after data-bound properties of a directive are
	     * initialized.
	     * @howToUse
	     * {@example core/ts/metadata/lifecycle_hooks_spec.ts region='OnInit'}
	     *
	     * @description
	     * `ngOnInit` is called right after the directive's data-bound properties have been checked for the
	     * first time, and before any of its children have been checked. It is invoked only once when the
	     * directive is instantiated.
	     *
	     * See {@linkDocs guide/lifecycle-hooks "Lifecycle Hooks Guide"}.
	     *
	     * @stable
	     */
	    var OnInit = (function () {
	        function OnInit() {
	        }
	        return OnInit;
	    }());
	    /**
	     * @whatItDoes Lifecycle hook that is called when Angular dirty checks a directive.
	     * @howToUse
	     * {@example core/ts/metadata/lifecycle_hooks_spec.ts region='DoCheck'}
	     *
	     * @description
	     * `ngDoCheck` gets called to check the changes in the directives in addition to the default
	     * algorithm. The default change detection algorithm looks for differences by comparing
	     * bound-property values by reference across change detection runs.
	     *
	     * Note that a directive typically should not use both `DoCheck` and {@link OnChanges} to respond to
	     * changes on the same input, as `ngOnChanges` will continue to be called when the default change
	     * detector detects changes.
	     *
	     * See {@link KeyValueDiffers} and {@link IterableDiffers} for implementing custom dirty checking
	     * for collections.
	     *
	     * See {@linkDocs guide/lifecycle-hooks#docheck "Lifecycle Hooks Guide"}.
	     *
	     * @stable
	     */
	    var DoCheck = (function () {
	        function DoCheck() {
	        }
	        return DoCheck;
	    }());
	    /**
	     * @whatItDoes Lifecycle hook that is called when a directive or pipe is destroyed.
	     * @howToUse
	     * {@example core/ts/metadata/lifecycle_hooks_spec.ts region='OnDestroy'}
	     *
	     * @description
	     * `ngOnDestroy` callback is typically used for any custom cleanup that needs to occur when the
	     * instance is destroyed.
	     *
	     * See {@linkDocs guide/lifecycle-hooks "Lifecycle Hooks Guide"}.
	     *
	     * @stable
	     */
	    var OnDestroy = (function () {
	        function OnDestroy() {
	        }
	        return OnDestroy;
	    }());
	    /**
	     *
	     * @whatItDoes Lifecycle hook that is called after a directive's content has been fully
	     * initialized.
	     * @howToUse
	     * {@example core/ts/metadata/lifecycle_hooks_spec.ts region='AfterContentInit'}
	     *
	     * @description
	     * See {@linkDocs guide/lifecycle-hooks#aftercontent "Lifecycle Hooks Guide"}.
	     *
	     * @stable
	     */
	    var AfterContentInit = (function () {
	        function AfterContentInit() {
	        }
	        return AfterContentInit;
	    }());
	    /**
	     * @whatItDoes Lifecycle hook that is called after every check of a directive's content.
	     * @howToUse
	     * {@example core/ts/metadata/lifecycle_hooks_spec.ts region='AfterContentChecked'}
	     *
	     * @description
	     * See {@linkDocs guide/lifecycle-hooks#aftercontent "Lifecycle Hooks Guide"}.
	     *
	     * @stable
	     */
	    var AfterContentChecked = (function () {
	        function AfterContentChecked() {
	        }
	        return AfterContentChecked;
	    }());
	    /**
	     * @whatItDoes Lifecycle hook that is called after a component's view has been fully
	     * initialized.
	     * @howToUse
	     * {@example core/ts/metadata/lifecycle_hooks_spec.ts region='AfterViewInit'}
	     *
	     * @description
	     * See {@linkDocs guide/lifecycle-hooks#afterview "Lifecycle Hooks Guide"}.
	     *
	     * @stable
	     */
	    var AfterViewInit = (function () {
	        function AfterViewInit() {
	        }
	        return AfterViewInit;
	    }());
	    /**
	     * @whatItDoes Lifecycle hook that is called after every check of a component's view.
	     * @howToUse
	     * {@example core/ts/metadata/lifecycle_hooks_spec.ts region='AfterViewChecked'}
	     *
	     * @description
	     * See {@linkDocs guide/lifecycle-hooks#afterview "Lifecycle Hooks Guide"}.
	     *
	     * @stable
	     */
	    var AfterViewChecked = (function () {
	        function AfterViewChecked() {
	        }
	        return AfterViewChecked;
	    }());

	    /**
	     * Defines a schema that will allow:
	     * - any non-Angular elements with a `-` in their name,
	     * - any properties on elements with a `-` in their name which is the common rule for custom
	     * elements.
	     *
	     * @stable
	     */
	    var CUSTOM_ELEMENTS_SCHEMA = {
	        name: 'custom-elements'
	    };
	    /**
	     * Defines a schema that will allow any property on any element.
	     *
	     * @experimental
	     */
	    var NO_ERRORS_SCHEMA = {
	        name: 'no-errors-schema'
	    };
	    /**
	     * NgModule decorator and metadata.
	     *
	     * @stable
	     * @Annotation
	     */
	    var NgModule = makeDecorator('NgModule', {
	        providers: undefined,
	        declarations: undefined,
	        imports: undefined,
	        exports: undefined,
	        entryComponents: undefined,
	        bootstrap: undefined,
	        schemas: undefined,
	        id: undefined,
	    });

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    /**
	     * Defines template and style encapsulation options available for Component's {@link Component}.
	     *
	     * See {@link ViewMetadata#encapsulation}.
	     * @stable
	     */
	    exports.ViewEncapsulation;
	    (function (ViewEncapsulation) {
	        /**
	         * Emulate `Native` scoping of styles by adding an attribute containing surrogate id to the Host
	         * Element and pre-processing the style rules provided via
	         * {@link ViewMetadata#styles} or {@link ViewMetadata#stylesUrls}, and adding the new Host Element
	         * attribute to all selectors.
	         *
	         * This is the default option.
	         */
	        ViewEncapsulation[ViewEncapsulation["Emulated"] = 0] = "Emulated";
	        /**
	         * Use the native encapsulation mechanism of the renderer.
	         *
	         * For the DOM this means using [Shadow DOM](https://w3c.github.io/webcomponents/spec/shadow/) and
	         * creating a ShadowRoot for Component's Host Element.
	         */
	        ViewEncapsulation[ViewEncapsulation["Native"] = 1] = "Native";
	        /**
	         * Don't provide any template or style encapsulation.
	         */
	        ViewEncapsulation[ViewEncapsulation["None"] = 2] = "None";
	    })(exports.ViewEncapsulation || (exports.ViewEncapsulation = {}));
	    /**
	     * Metadata properties available for configuring Views.
	     *
	     * For details on the `@Component` annotation, see {@link Component}.
	     *
	     * ### Example
	     *
	     * ```
	     * @Component({
	     *   selector: 'greet',
	     *   template: 'Hello {{name}}!',
	     * })
	     * class Greet {
	     *   name: string;
	     *
	     *   constructor() {
	     *     this.name = 'World';
	     *   }
	     * }
	     * ```
	     *
	     * @deprecated Use Component instead.
	     *
	     * {@link Component}
	     */
	    var ViewMetadata = (function () {
	        function ViewMetadata(_a) {
	            var _b = _a === void 0 ? {} : _a, templateUrl = _b.templateUrl, template = _b.template, encapsulation = _b.encapsulation, styles = _b.styles, styleUrls = _b.styleUrls, animations = _b.animations, interpolation = _b.interpolation;
	            this.templateUrl = templateUrl;
	            this.template = template;
	            this.styleUrls = styleUrls;
	            this.styles = styles;
	            this.encapsulation = encapsulation;
	            this.animations = animations;
	            this.interpolation = interpolation;
	        }
	        return ViewMetadata;
	    }());

	    /**
	     * Allows to refer to references which are not yet defined.
	     *
	     * For instance, `forwardRef` is used when the `token` which we need to refer to for the purposes of
	     * DI is declared,
	     * but not yet defined. It is also used when the `token` which we use when creating a query is not
	     * yet defined.
	     *
	     * ### Example
	     * {@example core/di/ts/forward_ref/forward_ref_spec.ts region='forward_ref'}
	     * @experimental
	     */
	    function forwardRef(forwardRefFn) {
	        forwardRefFn.__forward_ref__ = forwardRef;
	        forwardRefFn.toString = function () { return stringify(this()); };
	        return forwardRefFn;
	    }
	    /**
	     * Lazily retrieves the reference value from a forwardRef.
	     *
	     * Acts as the identity function when given a non-forward-ref value.
	     *
	     * ### Example ([live demo](http://plnkr.co/edit/GU72mJrk1fiodChcmiDR?p=preview))
	     *
	     * {@example core/di/ts/forward_ref/forward_ref_spec.ts region='resolve_forward_ref'}
	     *
	     * See: {@link forwardRef}
	     * @experimental
	     */
	    function resolveForwardRef(type) {
	        if (typeof type === 'function' && type.hasOwnProperty('__forward_ref__') &&
	            type.__forward_ref__ === forwardRef) {
	            return type();
	        }
	        else {
	            return type;
	        }
	    }

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    function unimplemented() {
	        throw new Error('unimplemented');
	    }
	    /**
	     * @stable
	     */
	    var BaseError = (function (_super) {
	        __extends(BaseError, _super);
	        function BaseError(message) {
	            // Errors don't use current this, instead they create a new instance.
	            // We have to do forward all of our api to the nativeInstance.
	            var nativeError = _super.call(this, message);
	            this._nativeError = nativeError;
	        }
	        Object.defineProperty(BaseError.prototype, "message", {
	            get: function () { return this._nativeError.message; },
	            set: function (message) { this._nativeError.message = message; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(BaseError.prototype, "name", {
	            get: function () { return this._nativeError.name; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(BaseError.prototype, "stack", {
	            get: function () { return this._nativeError.stack; },
	            set: function (value) { this._nativeError.stack = value; },
	            enumerable: true,
	            configurable: true
	        });
	        BaseError.prototype.toString = function () { return this._nativeError.toString(); };
	        return BaseError;
	    }(Error));
	    /**
	     * @stable
	     */
	    var WrappedError = (function (_super) {
	        __extends(WrappedError, _super);
	        function WrappedError(message, error) {
	            _super.call(this, message + " caused by: " + (error instanceof Error ? error.message : error));
	            this.originalError = error;
	        }
	        Object.defineProperty(WrappedError.prototype, "stack", {
	            get: function () {
	                return (this.originalError instanceof Error ? this.originalError : this._nativeError)
	                    .stack;
	            },
	            enumerable: true,
	            configurable: true
	        });
	        return WrappedError;
	    }(BaseError));

	    var _THROW_IF_NOT_FOUND = new Object();
	    var THROW_IF_NOT_FOUND = _THROW_IF_NOT_FOUND;
	    var _NullInjector = (function () {
	        function _NullInjector() {
	        }
	        _NullInjector.prototype.get = function (token, notFoundValue) {
	            if (notFoundValue === void 0) { notFoundValue = _THROW_IF_NOT_FOUND; }
	            if (notFoundValue === _THROW_IF_NOT_FOUND) {
	                throw new Error("No provider for " + stringify(token) + "!");
	            }
	            return notFoundValue;
	        };
	        return _NullInjector;
	    }());
	    /**
	     * @whatItDoes Injector interface
	     * @howToUse
	     * ```
	     * const injector: Injector = ...;
	     * injector.get(...);
	     * ```
	     *
	     * @description
	     * For more details, see the {@linkDocs guide/dependency-injection "Dependency Injection Guide"}.
	     *
	     * ### Example
	     *
	     * {@example core/di/ts/injector_spec.ts region='Injector'}
	     *
	     * `Injector` returns itself when given `Injector` as a token:
	     * {@example core/di/ts/injector_spec.ts region='injectInjector'}
	     *
	     * @stable
	     */
	    var Injector = (function () {
	        function Injector() {
	        }
	        /**
	         * Retrieves an instance from the injector based on the provided token.
	         * If not found:
	         * - Throws {@link NoProviderError} if no `notFoundValue` that is not equal to
	         * Injector.THROW_IF_NOT_FOUND is given
	         * - Returns the `notFoundValue` otherwise
	         */
	        Injector.prototype.get = function (token, notFoundValue) { return unimplemented(); };
	        Injector.THROW_IF_NOT_FOUND = _THROW_IF_NOT_FOUND;
	        Injector.NULL = new _NullInjector();
	        return Injector;
	    }());

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$1 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    function findFirstClosedCycle(keys) {
	        var res = [];
	        for (var i = 0; i < keys.length; ++i) {
	            if (res.indexOf(keys[i]) > -1) {
	                res.push(keys[i]);
	                return res;
	            }
	            res.push(keys[i]);
	        }
	        return res;
	    }
	    function constructResolvingPath(keys) {
	        if (keys.length > 1) {
	            var reversed = findFirstClosedCycle(keys.slice().reverse());
	            var tokenStrs = reversed.map(function (k) { return stringify(k.token); });
	            return ' (' + tokenStrs.join(' -> ') + ')';
	        }
	        return '';
	    }
	    /**
	     * Base class for all errors arising from misconfigured providers.
	     * @stable
	     */
	    var AbstractProviderError = (function (_super) {
	        __extends$1(AbstractProviderError, _super);
	        function AbstractProviderError(injector, key, constructResolvingMessage) {
	            _super.call(this, 'DI Error');
	            this.keys = [key];
	            this.injectors = [injector];
	            this.constructResolvingMessage = constructResolvingMessage;
	            this.message = this.constructResolvingMessage(this.keys);
	        }
	        AbstractProviderError.prototype.addKey = function (injector, key) {
	            this.injectors.push(injector);
	            this.keys.push(key);
	            this.message = this.constructResolvingMessage(this.keys);
	        };
	        return AbstractProviderError;
	    }(BaseError));
	    /**
	     * Thrown when trying to retrieve a dependency by key from {@link Injector}, but the
	     * {@link Injector} does not have a {@link Provider} for the given key.
	     *
	     * ### Example ([live demo](http://plnkr.co/edit/vq8D3FRB9aGbnWJqtEPE?p=preview))
	     *
	     * ```typescript
	     * class A {
	     *   constructor(b:B) {}
	     * }
	     *
	     * expect(() => Injector.resolveAndCreate([A])).toThrowError();
	     * ```
	     * @stable
	     */
	    var NoProviderError = (function (_super) {
	        __extends$1(NoProviderError, _super);
	        function NoProviderError(injector, key) {
	            _super.call(this, injector, key, function (keys) {
	                var first = stringify(keys[0].token);
	                return "No provider for " + first + "!" + constructResolvingPath(keys);
	            });
	        }
	        return NoProviderError;
	    }(AbstractProviderError));
	    /**
	     * Thrown when dependencies form a cycle.
	     *
	     * ### Example ([live demo](http://plnkr.co/edit/wYQdNos0Tzql3ei1EV9j?p=info))
	     *
	     * ```typescript
	     * var injector = Injector.resolveAndCreate([
	     *   {provide: "one", useFactory: (two) => "two", deps: [[new Inject("two")]]},
	     *   {provide: "two", useFactory: (one) => "one", deps: [[new Inject("one")]]}
	     * ]);
	     *
	     * expect(() => injector.get("one")).toThrowError();
	     * ```
	     *
	     * Retrieving `A` or `B` throws a `CyclicDependencyError` as the graph above cannot be constructed.
	     * @stable
	     */
	    var CyclicDependencyError = (function (_super) {
	        __extends$1(CyclicDependencyError, _super);
	        function CyclicDependencyError(injector, key) {
	            _super.call(this, injector, key, function (keys) {
	                return "Cannot instantiate cyclic dependency!" + constructResolvingPath(keys);
	            });
	        }
	        return CyclicDependencyError;
	    }(AbstractProviderError));
	    /**
	     * Thrown when a constructing type returns with an Error.
	     *
	     * The `InstantiationError` class contains the original error plus the dependency graph which caused
	     * this object to be instantiated.
	     *
	     * ### Example ([live demo](http://plnkr.co/edit/7aWYdcqTQsP0eNqEdUAf?p=preview))
	     *
	     * ```typescript
	     * class A {
	     *   constructor() {
	     *     throw new Error('message');
	     *   }
	     * }
	     *
	     * var injector = Injector.resolveAndCreate([A]);

	     * try {
	     *   injector.get(A);
	     * } catch (e) {
	     *   expect(e instanceof InstantiationError).toBe(true);
	     *   expect(e.originalException.message).toEqual("message");
	     *   expect(e.originalStack).toBeDefined();
	     * }
	     * ```
	     * @stable
	     */
	    var InstantiationError = (function (_super) {
	        __extends$1(InstantiationError, _super);
	        function InstantiationError(injector, originalException, originalStack, key) {
	            _super.call(this, 'DI Error', originalException);
	            this.keys = [key];
	            this.injectors = [injector];
	        }
	        InstantiationError.prototype.addKey = function (injector, key) {
	            this.injectors.push(injector);
	            this.keys.push(key);
	        };
	        Object.defineProperty(InstantiationError.prototype, "message", {
	            get: function () {
	                var first = stringify(this.keys[0].token);
	                return this.originalError.message + ": Error during instantiation of " + first + "!" + constructResolvingPath(this.keys) + ".";
	            },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(InstantiationError.prototype, "causeKey", {
	            get: function () { return this.keys[0]; },
	            enumerable: true,
	            configurable: true
	        });
	        return InstantiationError;
	    }(WrappedError));
	    /**
	     * Thrown when an object other then {@link Provider} (or `Type`) is passed to {@link Injector}
	     * creation.
	     *
	     * ### Example ([live demo](http://plnkr.co/edit/YatCFbPAMCL0JSSQ4mvH?p=preview))
	     *
	     * ```typescript
	     * expect(() => Injector.resolveAndCreate(["not a type"])).toThrowError();
	     * ```
	     * @stable
	     */
	    var InvalidProviderError = (function (_super) {
	        __extends$1(InvalidProviderError, _super);
	        function InvalidProviderError(provider) {
	            _super.call(this, "Invalid provider - only instances of Provider and Type are allowed, got: " + provider);
	        }
	        return InvalidProviderError;
	    }(BaseError));
	    /**
	     * Thrown when the class has no annotation information.
	     *
	     * Lack of annotation information prevents the {@link Injector} from determining which dependencies
	     * need to be injected into the constructor.
	     *
	     * ### Example ([live demo](http://plnkr.co/edit/rHnZtlNS7vJOPQ6pcVkm?p=preview))
	     *
	     * ```typescript
	     * class A {
	     *   constructor(b) {}
	     * }
	     *
	     * expect(() => Injector.resolveAndCreate([A])).toThrowError();
	     * ```
	     *
	     * This error is also thrown when the class not marked with {@link Injectable} has parameter types.
	     *
	     * ```typescript
	     * class B {}
	     *
	     * class A {
	     *   constructor(b:B) {} // no information about the parameter types of A is available at runtime.
	     * }
	     *
	     * expect(() => Injector.resolveAndCreate([A,B])).toThrowError();
	     * ```
	     * @stable
	     */
	    var NoAnnotationError = (function (_super) {
	        __extends$1(NoAnnotationError, _super);
	        function NoAnnotationError(typeOrFunc, params) {
	            _super.call(this, NoAnnotationError._genMessage(typeOrFunc, params));
	        }
	        NoAnnotationError._genMessage = function (typeOrFunc, params) {
	            var signature = [];
	            for (var i = 0, ii = params.length; i < ii; i++) {
	                var parameter = params[i];
	                if (!parameter || parameter.length == 0) {
	                    signature.push('?');
	                }
	                else {
	                    signature.push(parameter.map(stringify).join(' '));
	                }
	            }
	            return 'Cannot resolve all parameters for \'' + stringify(typeOrFunc) + '\'(' +
	                signature.join(', ') + '). ' +
	                'Make sure that all the parameters are decorated with Inject or have valid type annotations and that \'' +
	                stringify(typeOrFunc) + '\' is decorated with Injectable.';
	        };
	        return NoAnnotationError;
	    }(BaseError));
	    /**
	     * Thrown when getting an object by index.
	     *
	     * ### Example ([live demo](http://plnkr.co/edit/bRs0SX2OTQiJzqvjgl8P?p=preview))
	     *
	     * ```typescript
	     * class A {}
	     *
	     * var injector = Injector.resolveAndCreate([A]);
	     *
	     * expect(() => injector.getAt(100)).toThrowError();
	     * ```
	     * @stable
	     */
	    var OutOfBoundsError = (function (_super) {
	        __extends$1(OutOfBoundsError, _super);
	        function OutOfBoundsError(index) {
	            _super.call(this, "Index " + index + " is out-of-bounds.");
	        }
	        return OutOfBoundsError;
	    }(BaseError));
	    // TODO: add a working example after alpha38 is released
	    /**
	     * Thrown when a multi provider and a regular provider are bound to the same token.
	     *
	     * ### Example
	     *
	     * ```typescript
	     * expect(() => Injector.resolveAndCreate([
	     *   { provide: "Strings", useValue: "string1", multi: true},
	     *   { provide: "Strings", useValue: "string2", multi: false}
	     * ])).toThrowError();
	     * ```
	     */
	    var MixingMultiProvidersWithRegularProvidersError = (function (_super) {
	        __extends$1(MixingMultiProvidersWithRegularProvidersError, _super);
	        function MixingMultiProvidersWithRegularProvidersError(provider1, provider2) {
	            _super.call(this, 'Cannot mix multi providers and regular providers, got: ' + provider1.toString() + ' ' +
	                provider2.toString());
	        }
	        return MixingMultiProvidersWithRegularProvidersError;
	    }(BaseError));

	    /**
	     * A unique object used for retrieving items from the {@link ReflectiveInjector}.
	     *
	     * Keys have:
	     * - a system-wide unique `id`.
	     * - a `token`.
	     *
	     * `Key` is used internally by {@link ReflectiveInjector} because its system-wide unique `id` allows
	     * the
	     * injector to store created objects in a more efficient way.
	     *
	     * `Key` should not be created directly. {@link ReflectiveInjector} creates keys automatically when
	     * resolving
	     * providers.
	     * @experimental
	     */
	    var ReflectiveKey = (function () {
	        /**
	         * Private
	         */
	        function ReflectiveKey(token, id) {
	            this.token = token;
	            this.id = id;
	            if (!token) {
	                throw new Error('Token must be defined!');
	            }
	        }
	        Object.defineProperty(ReflectiveKey.prototype, "displayName", {
	            /**
	             * Returns a stringified token.
	             */
	            get: function () { return stringify(this.token); },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * Retrieves a `Key` for a token.
	         */
	        ReflectiveKey.get = function (token) {
	            return _globalKeyRegistry.get(resolveForwardRef(token));
	        };
	        Object.defineProperty(ReflectiveKey, "numberOfKeys", {
	            /**
	             * @returns the number of keys registered in the system.
	             */
	            get: function () { return _globalKeyRegistry.numberOfKeys; },
	            enumerable: true,
	            configurable: true
	        });
	        return ReflectiveKey;
	    }());
	    /**
	     * @internal
	     */
	    var KeyRegistry = (function () {
	        function KeyRegistry() {
	            this._allKeys = new Map();
	        }
	        KeyRegistry.prototype.get = function (token) {
	            if (token instanceof ReflectiveKey)
	                return token;
	            if (this._allKeys.has(token)) {
	                return this._allKeys.get(token);
	            }
	            var newKey = new ReflectiveKey(token, ReflectiveKey.numberOfKeys);
	            this._allKeys.set(token, newKey);
	            return newKey;
	        };
	        Object.defineProperty(KeyRegistry.prototype, "numberOfKeys", {
	            get: function () { return this._allKeys.size; },
	            enumerable: true,
	            configurable: true
	        });
	        return KeyRegistry;
	    }());
	    var _globalKeyRegistry = new KeyRegistry();

	    // Safari doesn't implement MapIterator.next(), which is used is Traceur's polyfill of Array.from
	    // TODO(mlaval): remove the work around once we have a working polyfill of Array.from
	    var _arrayFromMap = (function () {
	        try {
	            if ((new Map()).values().next) {
	                return function createArrayFromMap(m, getValues) {
	                    return getValues ? Array.from(m.values()) : Array.from(m.keys());
	                };
	            }
	        }
	        catch (e) {
	        }
	        return function createArrayFromMapWithForeach(m, getValues) {
	            var res = new Array(m.size), i = 0;
	            m.forEach(function (v, k) {
	                res[i] = getValues ? v : k;
	                i++;
	            });
	            return res;
	        };
	    })();
	    var MapWrapper = (function () {
	        function MapWrapper() {
	        }
	        MapWrapper.createFromStringMap = function (stringMap) {
	            var result = new Map();
	            for (var prop in stringMap) {
	                result.set(prop, stringMap[prop]);
	            }
	            return result;
	        };
	        MapWrapper.keys = function (m) { return _arrayFromMap(m, false); };
	        MapWrapper.values = function (m) { return _arrayFromMap(m, true); };
	        return MapWrapper;
	    }());
	    /**
	     * Wraps Javascript Objects
	     */
	    var StringMapWrapper = (function () {
	        function StringMapWrapper() {
	        }
	        StringMapWrapper.merge = function (m1, m2) {
	            var m = {};
	            for (var _i = 0, _a = Object.keys(m1); _i < _a.length; _i++) {
	                var k = _a[_i];
	                m[k] = m1[k];
	            }
	            for (var _b = 0, _c = Object.keys(m2); _b < _c.length; _b++) {
	                var k = _c[_b];
	                m[k] = m2[k];
	            }
	            return m;
	        };
	        StringMapWrapper.equals = function (m1, m2) {
	            var k1 = Object.keys(m1);
	            var k2 = Object.keys(m2);
	            if (k1.length != k2.length) {
	                return false;
	            }
	            for (var i = 0; i < k1.length; i++) {
	                var key = k1[i];
	                if (m1[key] !== m2[key]) {
	                    return false;
	                }
	            }
	            return true;
	        };
	        return StringMapWrapper;
	    }());
	    var ListWrapper = (function () {
	        function ListWrapper() {
	        }
	        ListWrapper.removeAll = function (list, items) {
	            for (var i = 0; i < items.length; ++i) {
	                var index = list.indexOf(items[i]);
	                list.splice(index, 1);
	            }
	        };
	        ListWrapper.remove = function (list, el) {
	            var index = list.indexOf(el);
	            if (index > -1) {
	                list.splice(index, 1);
	                return true;
	            }
	            return false;
	        };
	        ListWrapper.equals = function (a, b) {
	            if (a.length != b.length)
	                return false;
	            for (var i = 0; i < a.length; ++i) {
	                if (a[i] !== b[i])
	                    return false;
	            }
	            return true;
	        };
	        ListWrapper.maximum = function (list, predicate) {
	            if (list.length == 0) {
	                return null;
	            }
	            var solution = null;
	            var maxValue = -Infinity;
	            for (var index = 0; index < list.length; index++) {
	                var candidate = list[index];
	                if (candidate == null) {
	                    continue;
	                }
	                var candidateValue = predicate(candidate);
	                if (candidateValue > maxValue) {
	                    solution = candidate;
	                    maxValue = candidateValue;
	                }
	            }
	            return solution;
	        };
	        ListWrapper.flatten = function (list) {
	            var target = [];
	            _flattenArray(list, target);
	            return target;
	        };
	        return ListWrapper;
	    }());
	    function _flattenArray(source, target) {
	        if (isPresent(source)) {
	            for (var i = 0; i < source.length; i++) {
	                var item = source[i];
	                if (Array.isArray(item)) {
	                    _flattenArray(item, target);
	                }
	                else {
	                    target.push(item);
	                }
	            }
	        }
	        return target;
	    }
	    function isListLikeIterable(obj) {
	        if (!isJsObject(obj))
	            return false;
	        return Array.isArray(obj) ||
	            (!(obj instanceof Map) &&
	                getSymbolIterator() in obj); // JS Iterable have a Symbol.iterator prop
	    }
	    function areIterablesEqual(a, b, comparator) {
	        var iterator1 = a[getSymbolIterator()]();
	        var iterator2 = b[getSymbolIterator()]();
	        while (true) {
	            var item1 = iterator1.next();
	            var item2 = iterator2.next();
	            if (item1.done && item2.done)
	                return true;
	            if (item1.done || item2.done)
	                return false;
	            if (!comparator(item1.value, item2.value))
	                return false;
	        }
	    }
	    function iterateListLike(obj, fn) {
	        if (Array.isArray(obj)) {
	            for (var i = 0; i < obj.length; i++) {
	                fn(obj[i]);
	            }
	        }
	        else {
	            var iterator = obj[getSymbolIterator()]();
	            var item = void 0;
	            while (!((item = iterator.next()).done)) {
	                fn(item.value);
	            }
	        }
	    }

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    /**
	     * @whatItDoes Represents a type that a Component or other object is instances of.
	     *
	     * @description
	     *
	     * An example of a `Type` is `MyCustomComponent` class, which in JavaScript is be represented by
	     * the `MyCustomComponent` constructor function.
	     *
	     * @stable
	     */
	    var Type = Function;

	    var ReflectionCapabilities = (function () {
	        function ReflectionCapabilities(reflect) {
	            this._reflect = reflect || global$1.Reflect;
	        }
	        ReflectionCapabilities.prototype.isReflectionEnabled = function () { return true; };
	        ReflectionCapabilities.prototype.factory = function (t) { return function () {
	            var args = [];
	            for (var _i = 0; _i < arguments.length; _i++) {
	                args[_i - 0] = arguments[_i];
	            }
	            return new (t.bind.apply(t, [void 0].concat(args)))();
	        }; };
	        /** @internal */
	        ReflectionCapabilities.prototype._zipTypesAndAnnotations = function (paramTypes, paramAnnotations) {
	            var result;
	            if (typeof paramTypes === 'undefined') {
	                result = new Array(paramAnnotations.length);
	            }
	            else {
	                result = new Array(paramTypes.length);
	            }
	            for (var i = 0; i < result.length; i++) {
	                // TS outputs Object for parameters without types, while Traceur omits
	                // the annotations. For now we preserve the Traceur behavior to aid
	                // migration, but this can be revisited.
	                if (typeof paramTypes === 'undefined') {
	                    result[i] = [];
	                }
	                else if (paramTypes[i] != Object) {
	                    result[i] = [paramTypes[i]];
	                }
	                else {
	                    result[i] = [];
	                }
	                if (paramAnnotations && isPresent(paramAnnotations[i])) {
	                    result[i] = result[i].concat(paramAnnotations[i]);
	                }
	            }
	            return result;
	        };
	        ReflectionCapabilities.prototype.parameters = function (type) {
	            // Prefer the direct API.
	            if (type.parameters) {
	                return type.parameters;
	            }
	            // API of tsickle for lowering decorators to properties on the class.
	            if (type.ctorParameters) {
	                var ctorParameters = type.ctorParameters;
	                var paramTypes = ctorParameters.map(function (ctorParam) { return ctorParam && ctorParam.type; });
	                var paramAnnotations = ctorParameters.map(function (ctorParam) {
	                    return ctorParam && convertTsickleDecoratorIntoMetadata(ctorParam.decorators);
	                });
	                return this._zipTypesAndAnnotations(paramTypes, paramAnnotations);
	            }
	            // API for metadata created by invoking the decorators.
	            if (isPresent(this._reflect) && isPresent(this._reflect.getMetadata)) {
	                var paramAnnotations = this._reflect.getMetadata('parameters', type);
	                var paramTypes = this._reflect.getMetadata('design:paramtypes', type);
	                if (paramTypes || paramAnnotations) {
	                    return this._zipTypesAndAnnotations(paramTypes, paramAnnotations);
	                }
	            }
	            // The array has to be filled with `undefined` because holes would be skipped by `some`
	            return new Array(type.length).fill(undefined);
	        };
	        ReflectionCapabilities.prototype.annotations = function (typeOrFunc) {
	            // Prefer the direct API.
	            if (typeOrFunc.annotations) {
	                var annotations = typeOrFunc.annotations;
	                if (typeof annotations === 'function' && annotations.annotations) {
	                    annotations = annotations.annotations;
	                }
	                return annotations;
	            }
	            // API of tsickle for lowering decorators to properties on the class.
	            if (typeOrFunc.decorators) {
	                return convertTsickleDecoratorIntoMetadata(typeOrFunc.decorators);
	            }
	            // API for metadata created by invoking the decorators.
	            if (this._reflect && this._reflect.getMetadata) {
	                var annotations = this._reflect.getMetadata('annotations', typeOrFunc);
	                if (annotations)
	                    return annotations;
	            }
	            return [];
	        };
	        ReflectionCapabilities.prototype.propMetadata = function (typeOrFunc) {
	            // Prefer the direct API.
	            if (typeOrFunc.propMetadata) {
	                var propMetadata = typeOrFunc.propMetadata;
	                if (typeof propMetadata === 'function' && propMetadata.propMetadata) {
	                    propMetadata = propMetadata.propMetadata;
	                }
	                return propMetadata;
	            }
	            // API of tsickle for lowering decorators to properties on the class.
	            if (typeOrFunc.propDecorators) {
	                var propDecorators_1 = typeOrFunc.propDecorators;
	                var propMetadata_1 = {};
	                Object.keys(propDecorators_1).forEach(function (prop) {
	                    propMetadata_1[prop] = convertTsickleDecoratorIntoMetadata(propDecorators_1[prop]);
	                });
	                return propMetadata_1;
	            }
	            // API for metadata created by invoking the decorators.
	            if (this._reflect && this._reflect.getMetadata) {
	                var propMetadata = this._reflect.getMetadata('propMetadata', typeOrFunc);
	                if (propMetadata)
	                    return propMetadata;
	            }
	            return {};
	        };
	        ReflectionCapabilities.prototype.hasLifecycleHook = function (type, lcProperty) {
	            return type instanceof Type && lcProperty in type.prototype;
	        };
	        ReflectionCapabilities.prototype.getter = function (name) { return new Function('o', 'return o.' + name + ';'); };
	        ReflectionCapabilities.prototype.setter = function (name) {
	            return new Function('o', 'v', 'return o.' + name + ' = v;');
	        };
	        ReflectionCapabilities.prototype.method = function (name) {
	            var functionBody = "if (!o." + name + ") throw new Error('\"" + name + "\" is undefined');\n        return o." + name + ".apply(o, args);";
	            return new Function('o', 'args', functionBody);
	        };
	        // There is not a concept of import uri in Js, but this is useful in developing Dart applications.
	        ReflectionCapabilities.prototype.importUri = function (type) {
	            // StaticSymbol
	            if (typeof type === 'object' && type['filePath']) {
	                return type['filePath'];
	            }
	            // Runtime type
	            return "./" + stringify(type);
	        };
	        ReflectionCapabilities.prototype.resolveIdentifier = function (name, moduleUrl, runtime) { return runtime; };
	        ReflectionCapabilities.prototype.resolveEnum = function (enumIdentifier, name) { return enumIdentifier[name]; };
	        return ReflectionCapabilities;
	    }());
	    function convertTsickleDecoratorIntoMetadata(decoratorInvocations) {
	        if (!decoratorInvocations) {
	            return [];
	        }
	        return decoratorInvocations.map(function (decoratorInvocation) {
	            var decoratorType = decoratorInvocation.type;
	            var annotationCls = decoratorType.annotationCls;
	            var annotationArgs = decoratorInvocation.args ? decoratorInvocation.args : [];
	            return new (annotationCls.bind.apply(annotationCls, [void 0].concat(annotationArgs)))();
	        });
	    }

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    /**
	     * Provides read-only access to reflection data about symbols. Used internally by Angular
	     * to power dependency injection and compilation.
	     */
	    var ReflectorReader = (function () {
	        function ReflectorReader() {
	        }
	        return ReflectorReader;
	    }());

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$2 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    /**
	     * Provides access to reflection data about symbols. Used internally by Angular
	     * to power dependency injection and compilation.
	     */
	    var Reflector = (function (_super) {
	        __extends$2(Reflector, _super);
	        function Reflector(reflectionCapabilities) {
	            _super.call(this);
	            this.reflectionCapabilities = reflectionCapabilities;
	        }
	        Reflector.prototype.updateCapabilities = function (caps) { this.reflectionCapabilities = caps; };
	        Reflector.prototype.factory = function (type) { return this.reflectionCapabilities.factory(type); };
	        Reflector.prototype.parameters = function (typeOrFunc) {
	            return this.reflectionCapabilities.parameters(typeOrFunc);
	        };
	        Reflector.prototype.annotations = function (typeOrFunc) {
	            return this.reflectionCapabilities.annotations(typeOrFunc);
	        };
	        Reflector.prototype.propMetadata = function (typeOrFunc) {
	            return this.reflectionCapabilities.propMetadata(typeOrFunc);
	        };
	        Reflector.prototype.hasLifecycleHook = function (type, lcProperty) {
	            return this.reflectionCapabilities.hasLifecycleHook(type, lcProperty);
	        };
	        Reflector.prototype.getter = function (name) { return this.reflectionCapabilities.getter(name); };
	        Reflector.prototype.setter = function (name) { return this.reflectionCapabilities.setter(name); };
	        Reflector.prototype.method = function (name) { return this.reflectionCapabilities.method(name); };
	        Reflector.prototype.importUri = function (type) { return this.reflectionCapabilities.importUri(type); };
	        Reflector.prototype.resolveIdentifier = function (name, moduleUrl, runtime) {
	            return this.reflectionCapabilities.resolveIdentifier(name, moduleUrl, runtime);
	        };
	        Reflector.prototype.resolveEnum = function (identifier, name) {
	            return this.reflectionCapabilities.resolveEnum(identifier, name);
	        };
	        return Reflector;
	    }(ReflectorReader));

	    /**
	     * The {@link Reflector} used internally in Angular to access metadata
	     * about symbols.
	     */
	    var reflector = new Reflector(new ReflectionCapabilities());

	    /**
	     * `Dependency` is used by the framework to extend DI.
	     * This is internal to Angular and should not be used directly.
	     */
	    var ReflectiveDependency = (function () {
	        function ReflectiveDependency(key, optional, lowerBoundVisibility, upperBoundVisibility, properties) {
	            this.key = key;
	            this.optional = optional;
	            this.lowerBoundVisibility = lowerBoundVisibility;
	            this.upperBoundVisibility = upperBoundVisibility;
	            this.properties = properties;
	        }
	        ReflectiveDependency.fromKey = function (key) {
	            return new ReflectiveDependency(key, false, null, null, []);
	        };
	        return ReflectiveDependency;
	    }());
	    var _EMPTY_LIST = [];
	    var ResolvedReflectiveProvider_ = (function () {
	        function ResolvedReflectiveProvider_(key, resolvedFactories, multiProvider) {
	            this.key = key;
	            this.resolvedFactories = resolvedFactories;
	            this.multiProvider = multiProvider;
	        }
	        Object.defineProperty(ResolvedReflectiveProvider_.prototype, "resolvedFactory", {
	            get: function () { return this.resolvedFactories[0]; },
	            enumerable: true,
	            configurable: true
	        });
	        return ResolvedReflectiveProvider_;
	    }());
	    /**
	     * An internal resolved representation of a factory function created by resolving {@link
	     * Provider}.
	     * @experimental
	     */
	    var ResolvedReflectiveFactory = (function () {
	        function ResolvedReflectiveFactory(
	            /**
	             * Factory function which can return an instance of an object represented by a key.
	             */
	            factory,
	            /**
	             * Arguments (dependencies) to the `factory` function.
	             */
	            dependencies) {
	            this.factory = factory;
	            this.dependencies = dependencies;
	        }
	        return ResolvedReflectiveFactory;
	    }());
	    /**
	     * Resolve a single provider.
	     */
	    function resolveReflectiveFactory(provider) {
	        var factoryFn;
	        var resolvedDeps;
	        if (isPresent(provider.useClass)) {
	            var useClass = resolveForwardRef(provider.useClass);
	            factoryFn = reflector.factory(useClass);
	            resolvedDeps = _dependenciesFor(useClass);
	        }
	        else if (isPresent(provider.useExisting)) {
	            factoryFn = function (aliasInstance) { return aliasInstance; };
	            resolvedDeps = [ReflectiveDependency.fromKey(ReflectiveKey.get(provider.useExisting))];
	        }
	        else if (isPresent(provider.useFactory)) {
	            factoryFn = provider.useFactory;
	            resolvedDeps = constructDependencies(provider.useFactory, provider.deps);
	        }
	        else {
	            factoryFn = function () { return provider.useValue; };
	            resolvedDeps = _EMPTY_LIST;
	        }
	        return new ResolvedReflectiveFactory(factoryFn, resolvedDeps);
	    }
	    /**
	     * Converts the {@link Provider} into {@link ResolvedProvider}.
	     *
	     * {@link Injector} internally only uses {@link ResolvedProvider}, {@link Provider} contains
	     * convenience provider syntax.
	     */
	    function resolveReflectiveProvider(provider) {
	        return new ResolvedReflectiveProvider_(ReflectiveKey.get(provider.provide), [resolveReflectiveFactory(provider)], provider.multi);
	    }
	    /**
	     * Resolve a list of Providers.
	     */
	    function resolveReflectiveProviders(providers) {
	        var normalized = _normalizeProviders(providers, []);
	        var resolved = normalized.map(resolveReflectiveProvider);
	        return MapWrapper.values(mergeResolvedReflectiveProviders(resolved, new Map()));
	    }
	    /**
	     * Merges a list of ResolvedProviders into a list where
	     * each key is contained exactly once and multi providers
	     * have been merged.
	     */
	    function mergeResolvedReflectiveProviders(providers, normalizedProvidersMap) {
	        for (var i = 0; i < providers.length; i++) {
	            var provider = providers[i];
	            var existing = normalizedProvidersMap.get(provider.key.id);
	            if (isPresent(existing)) {
	                if (provider.multiProvider !== existing.multiProvider) {
	                    throw new MixingMultiProvidersWithRegularProvidersError(existing, provider);
	                }
	                if (provider.multiProvider) {
	                    for (var j = 0; j < provider.resolvedFactories.length; j++) {
	                        existing.resolvedFactories.push(provider.resolvedFactories[j]);
	                    }
	                }
	                else {
	                    normalizedProvidersMap.set(provider.key.id, provider);
	                }
	            }
	            else {
	                var resolvedProvider;
	                if (provider.multiProvider) {
	                    resolvedProvider = new ResolvedReflectiveProvider_(provider.key, provider.resolvedFactories.slice(), provider.multiProvider);
	                }
	                else {
	                    resolvedProvider = provider;
	                }
	                normalizedProvidersMap.set(provider.key.id, resolvedProvider);
	            }
	        }
	        return normalizedProvidersMap;
	    }
	    function _normalizeProviders(providers, res) {
	        providers.forEach(function (b) {
	            if (b instanceof Type) {
	                res.push({ provide: b, useClass: b });
	            }
	            else if (b && typeof b == 'object' && b.provide !== undefined) {
	                res.push(b);
	            }
	            else if (b instanceof Array) {
	                _normalizeProviders(b, res);
	            }
	            else {
	                throw new InvalidProviderError(b);
	            }
	        });
	        return res;
	    }
	    function constructDependencies(typeOrFunc, dependencies) {
	        if (!dependencies) {
	            return _dependenciesFor(typeOrFunc);
	        }
	        else {
	            var params = dependencies.map(function (t) { return [t]; });
	            return dependencies.map(function (t) { return _extractToken(typeOrFunc, t, params); });
	        }
	    }
	    function _dependenciesFor(typeOrFunc) {
	        var params = reflector.parameters(typeOrFunc);
	        if (!params)
	            return [];
	        if (params.some(isBlank)) {
	            throw new NoAnnotationError(typeOrFunc, params);
	        }
	        return params.map(function (p) { return _extractToken(typeOrFunc, p, params); });
	    }
	    function _extractToken(typeOrFunc /** TODO #9100 */, metadata /** TODO #9100 */ /*any[] | any*/, params) {
	        var depProps = [];
	        var token = null;
	        var optional = false;
	        if (!Array.isArray(metadata)) {
	            if (metadata instanceof Inject) {
	                return _createDependency(metadata.token, optional, null, null, depProps);
	            }
	            else {
	                return _createDependency(metadata, optional, null, null, depProps);
	            }
	        }
	        var lowerBoundVisibility = null;
	        var upperBoundVisibility = null;
	        for (var i = 0; i < metadata.length; ++i) {
	            var paramMetadata = metadata[i];
	            if (paramMetadata instanceof Type) {
	                token = paramMetadata;
	            }
	            else if (paramMetadata instanceof Inject) {
	                token = paramMetadata.token;
	            }
	            else if (paramMetadata instanceof Optional) {
	                optional = true;
	            }
	            else if (paramMetadata instanceof Self) {
	                upperBoundVisibility = paramMetadata;
	            }
	            else if (paramMetadata instanceof Host) {
	                upperBoundVisibility = paramMetadata;
	            }
	            else if (paramMetadata instanceof SkipSelf) {
	                lowerBoundVisibility = paramMetadata;
	            }
	        }
	        token = resolveForwardRef(token);
	        if (isPresent(token)) {
	            return _createDependency(token, optional, lowerBoundVisibility, upperBoundVisibility, depProps);
	        }
	        else {
	            throw new NoAnnotationError(typeOrFunc, params);
	        }
	    }
	    function _createDependency(token /** TODO #9100 */, optional /** TODO #9100 */, lowerBoundVisibility /** TODO #9100 */, upperBoundVisibility /** TODO #9100 */, depProps /** TODO #9100 */) {
	        return new ReflectiveDependency(ReflectiveKey.get(token), optional, lowerBoundVisibility, upperBoundVisibility, depProps);
	    }

	    // Threshold for the dynamic version
	    var _MAX_CONSTRUCTION_COUNTER = 10;
	    var UNDEFINED = new Object();
	    var ReflectiveProtoInjectorInlineStrategy = (function () {
	        function ReflectiveProtoInjectorInlineStrategy(protoEI, providers) {
	            this.provider0 = null;
	            this.provider1 = null;
	            this.provider2 = null;
	            this.provider3 = null;
	            this.provider4 = null;
	            this.provider5 = null;
	            this.provider6 = null;
	            this.provider7 = null;
	            this.provider8 = null;
	            this.provider9 = null;
	            this.keyId0 = null;
	            this.keyId1 = null;
	            this.keyId2 = null;
	            this.keyId3 = null;
	            this.keyId4 = null;
	            this.keyId5 = null;
	            this.keyId6 = null;
	            this.keyId7 = null;
	            this.keyId8 = null;
	            this.keyId9 = null;
	            var length = providers.length;
	            if (length > 0) {
	                this.provider0 = providers[0];
	                this.keyId0 = providers[0].key.id;
	            }
	            if (length > 1) {
	                this.provider1 = providers[1];
	                this.keyId1 = providers[1].key.id;
	            }
	            if (length > 2) {
	                this.provider2 = providers[2];
	                this.keyId2 = providers[2].key.id;
	            }
	            if (length > 3) {
	                this.provider3 = providers[3];
	                this.keyId3 = providers[3].key.id;
	            }
	            if (length > 4) {
	                this.provider4 = providers[4];
	                this.keyId4 = providers[4].key.id;
	            }
	            if (length > 5) {
	                this.provider5 = providers[5];
	                this.keyId5 = providers[5].key.id;
	            }
	            if (length > 6) {
	                this.provider6 = providers[6];
	                this.keyId6 = providers[6].key.id;
	            }
	            if (length > 7) {
	                this.provider7 = providers[7];
	                this.keyId7 = providers[7].key.id;
	            }
	            if (length > 8) {
	                this.provider8 = providers[8];
	                this.keyId8 = providers[8].key.id;
	            }
	            if (length > 9) {
	                this.provider9 = providers[9];
	                this.keyId9 = providers[9].key.id;
	            }
	        }
	        ReflectiveProtoInjectorInlineStrategy.prototype.getProviderAtIndex = function (index) {
	            if (index == 0)
	                return this.provider0;
	            if (index == 1)
	                return this.provider1;
	            if (index == 2)
	                return this.provider2;
	            if (index == 3)
	                return this.provider3;
	            if (index == 4)
	                return this.provider4;
	            if (index == 5)
	                return this.provider5;
	            if (index == 6)
	                return this.provider6;
	            if (index == 7)
	                return this.provider7;
	            if (index == 8)
	                return this.provider8;
	            if (index == 9)
	                return this.provider9;
	            throw new OutOfBoundsError(index);
	        };
	        ReflectiveProtoInjectorInlineStrategy.prototype.createInjectorStrategy = function (injector) {
	            return new ReflectiveInjectorInlineStrategy(injector, this);
	        };
	        return ReflectiveProtoInjectorInlineStrategy;
	    }());
	    var ReflectiveProtoInjectorDynamicStrategy = (function () {
	        function ReflectiveProtoInjectorDynamicStrategy(protoInj, providers) {
	            this.providers = providers;
	            var len = providers.length;
	            this.keyIds = new Array(len);
	            for (var i = 0; i < len; i++) {
	                this.keyIds[i] = providers[i].key.id;
	            }
	        }
	        ReflectiveProtoInjectorDynamicStrategy.prototype.getProviderAtIndex = function (index) {
	            if (index < 0 || index >= this.providers.length) {
	                throw new OutOfBoundsError(index);
	            }
	            return this.providers[index];
	        };
	        ReflectiveProtoInjectorDynamicStrategy.prototype.createInjectorStrategy = function (ei) {
	            return new ReflectiveInjectorDynamicStrategy(this, ei);
	        };
	        return ReflectiveProtoInjectorDynamicStrategy;
	    }());
	    var ReflectiveProtoInjector = (function () {
	        function ReflectiveProtoInjector(providers) {
	            this.numberOfProviders = providers.length;
	            this._strategy = providers.length > _MAX_CONSTRUCTION_COUNTER ?
	                new ReflectiveProtoInjectorDynamicStrategy(this, providers) :
	                new ReflectiveProtoInjectorInlineStrategy(this, providers);
	        }
	        ReflectiveProtoInjector.fromResolvedProviders = function (providers) {
	            return new ReflectiveProtoInjector(providers);
	        };
	        ReflectiveProtoInjector.prototype.getProviderAtIndex = function (index) {
	            return this._strategy.getProviderAtIndex(index);
	        };
	        return ReflectiveProtoInjector;
	    }());
	    var ReflectiveInjectorInlineStrategy = (function () {
	        function ReflectiveInjectorInlineStrategy(injector, protoStrategy) {
	            this.injector = injector;
	            this.protoStrategy = protoStrategy;
	            this.obj0 = UNDEFINED;
	            this.obj1 = UNDEFINED;
	            this.obj2 = UNDEFINED;
	            this.obj3 = UNDEFINED;
	            this.obj4 = UNDEFINED;
	            this.obj5 = UNDEFINED;
	            this.obj6 = UNDEFINED;
	            this.obj7 = UNDEFINED;
	            this.obj8 = UNDEFINED;
	            this.obj9 = UNDEFINED;
	        }
	        ReflectiveInjectorInlineStrategy.prototype.resetConstructionCounter = function () { this.injector._constructionCounter = 0; };
	        ReflectiveInjectorInlineStrategy.prototype.instantiateProvider = function (provider) {
	            return this.injector._new(provider);
	        };
	        ReflectiveInjectorInlineStrategy.prototype.getObjByKeyId = function (keyId) {
	            var p = this.protoStrategy;
	            var inj = this.injector;
	            if (p.keyId0 === keyId) {
	                if (this.obj0 === UNDEFINED) {
	                    this.obj0 = inj._new(p.provider0);
	                }
	                return this.obj0;
	            }
	            if (p.keyId1 === keyId) {
	                if (this.obj1 === UNDEFINED) {
	                    this.obj1 = inj._new(p.provider1);
	                }
	                return this.obj1;
	            }
	            if (p.keyId2 === keyId) {
	                if (this.obj2 === UNDEFINED) {
	                    this.obj2 = inj._new(p.provider2);
	                }
	                return this.obj2;
	            }
	            if (p.keyId3 === keyId) {
	                if (this.obj3 === UNDEFINED) {
	                    this.obj3 = inj._new(p.provider3);
	                }
	                return this.obj3;
	            }
	            if (p.keyId4 === keyId) {
	                if (this.obj4 === UNDEFINED) {
	                    this.obj4 = inj._new(p.provider4);
	                }
	                return this.obj4;
	            }
	            if (p.keyId5 === keyId) {
	                if (this.obj5 === UNDEFINED) {
	                    this.obj5 = inj._new(p.provider5);
	                }
	                return this.obj5;
	            }
	            if (p.keyId6 === keyId) {
	                if (this.obj6 === UNDEFINED) {
	                    this.obj6 = inj._new(p.provider6);
	                }
	                return this.obj6;
	            }
	            if (p.keyId7 === keyId) {
	                if (this.obj7 === UNDEFINED) {
	                    this.obj7 = inj._new(p.provider7);
	                }
	                return this.obj7;
	            }
	            if (p.keyId8 === keyId) {
	                if (this.obj8 === UNDEFINED) {
	                    this.obj8 = inj._new(p.provider8);
	                }
	                return this.obj8;
	            }
	            if (p.keyId9 === keyId) {
	                if (this.obj9 === UNDEFINED) {
	                    this.obj9 = inj._new(p.provider9);
	                }
	                return this.obj9;
	            }
	            return UNDEFINED;
	        };
	        ReflectiveInjectorInlineStrategy.prototype.getObjAtIndex = function (index) {
	            if (index == 0)
	                return this.obj0;
	            if (index == 1)
	                return this.obj1;
	            if (index == 2)
	                return this.obj2;
	            if (index == 3)
	                return this.obj3;
	            if (index == 4)
	                return this.obj4;
	            if (index == 5)
	                return this.obj5;
	            if (index == 6)
	                return this.obj6;
	            if (index == 7)
	                return this.obj7;
	            if (index == 8)
	                return this.obj8;
	            if (index == 9)
	                return this.obj9;
	            throw new OutOfBoundsError(index);
	        };
	        ReflectiveInjectorInlineStrategy.prototype.getMaxNumberOfObjects = function () { return _MAX_CONSTRUCTION_COUNTER; };
	        return ReflectiveInjectorInlineStrategy;
	    }());
	    var ReflectiveInjectorDynamicStrategy = (function () {
	        function ReflectiveInjectorDynamicStrategy(protoStrategy, injector) {
	            this.protoStrategy = protoStrategy;
	            this.injector = injector;
	            this.objs = new Array(protoStrategy.providers.length).fill(UNDEFINED);
	        }
	        ReflectiveInjectorDynamicStrategy.prototype.resetConstructionCounter = function () { this.injector._constructionCounter = 0; };
	        ReflectiveInjectorDynamicStrategy.prototype.instantiateProvider = function (provider) {
	            return this.injector._new(provider);
	        };
	        ReflectiveInjectorDynamicStrategy.prototype.getObjByKeyId = function (keyId) {
	            var p = this.protoStrategy;
	            for (var i = 0; i < p.keyIds.length; i++) {
	                if (p.keyIds[i] === keyId) {
	                    if (this.objs[i] === UNDEFINED) {
	                        this.objs[i] = this.injector._new(p.providers[i]);
	                    }
	                    return this.objs[i];
	                }
	            }
	            return UNDEFINED;
	        };
	        ReflectiveInjectorDynamicStrategy.prototype.getObjAtIndex = function (index) {
	            if (index < 0 || index >= this.objs.length) {
	                throw new OutOfBoundsError(index);
	            }
	            return this.objs[index];
	        };
	        ReflectiveInjectorDynamicStrategy.prototype.getMaxNumberOfObjects = function () { return this.objs.length; };
	        return ReflectiveInjectorDynamicStrategy;
	    }());
	    /**
	     * A ReflectiveDependency injection container used for instantiating objects and resolving
	     * dependencies.
	     *
	     * An `Injector` is a replacement for a `new` operator, which can automatically resolve the
	     * constructor dependencies.
	     *
	     * In typical use, application code asks for the dependencies in the constructor and they are
	     * resolved by the `Injector`.
	     *
	     * ### Example ([live demo](http://plnkr.co/edit/jzjec0?p=preview))
	     *
	     * The following example creates an `Injector` configured to create `Engine` and `Car`.
	     *
	     * ```typescript
	     * @Injectable()
	     * class Engine {
	     * }
	     *
	     * @Injectable()
	     * class Car {
	     *   constructor(public engine:Engine) {}
	     * }
	     *
	     * var injector = ReflectiveInjector.resolveAndCreate([Car, Engine]);
	     * var car = injector.get(Car);
	     * expect(car instanceof Car).toBe(true);
	     * expect(car.engine instanceof Engine).toBe(true);
	     * ```
	     *
	     * Notice, we don't use the `new` operator because we explicitly want to have the `Injector`
	     * resolve all of the object's dependencies automatically.
	     *
	     * @stable
	     */
	    var ReflectiveInjector = (function () {
	        function ReflectiveInjector() {
	        }
	        /**
	         * Turns an array of provider definitions into an array of resolved providers.
	         *
	         * A resolution is a process of flattening multiple nested arrays and converting individual
	         * providers into an array of {@link ResolvedReflectiveProvider}s.
	         *
	         * ### Example ([live demo](http://plnkr.co/edit/AiXTHi?p=preview))
	         *
	         * ```typescript
	         * @Injectable()
	         * class Engine {
	         * }
	         *
	         * @Injectable()
	         * class Car {
	         *   constructor(public engine:Engine) {}
	         * }
	         *
	         * var providers = ReflectiveInjector.resolve([Car, [[Engine]]]);
	         *
	         * expect(providers.length).toEqual(2);
	         *
	         * expect(providers[0] instanceof ResolvedReflectiveProvider).toBe(true);
	         * expect(providers[0].key.displayName).toBe("Car");
	         * expect(providers[0].dependencies.length).toEqual(1);
	         * expect(providers[0].factory).toBeDefined();
	         *
	         * expect(providers[1].key.displayName).toBe("Engine");
	         * });
	         * ```
	         *
	         * See {@link ReflectiveInjector#fromResolvedProviders} for more info.
	         */
	        ReflectiveInjector.resolve = function (providers) {
	            return resolveReflectiveProviders(providers);
	        };
	        /**
	         * Resolves an array of providers and creates an injector from those providers.
	         *
	         * The passed-in providers can be an array of `Type`, {@link Provider},
	         * or a recursive array of more providers.
	         *
	         * ### Example ([live demo](http://plnkr.co/edit/ePOccA?p=preview))
	         *
	         * ```typescript
	         * @Injectable()
	         * class Engine {
	         * }
	         *
	         * @Injectable()
	         * class Car {
	         *   constructor(public engine:Engine) {}
	         * }
	         *
	         * var injector = ReflectiveInjector.resolveAndCreate([Car, Engine]);
	         * expect(injector.get(Car) instanceof Car).toBe(true);
	         * ```
	         *
	         * This function is slower than the corresponding `fromResolvedProviders`
	         * because it needs to resolve the passed-in providers first.
	         * See {@link Injector#resolve} and {@link Injector#fromResolvedProviders}.
	         */
	        ReflectiveInjector.resolveAndCreate = function (providers, parent) {
	            if (parent === void 0) { parent = null; }
	            var ResolvedReflectiveProviders = ReflectiveInjector.resolve(providers);
	            return ReflectiveInjector.fromResolvedProviders(ResolvedReflectiveProviders, parent);
	        };
	        /**
	         * Creates an injector from previously resolved providers.
	         *
	         * This API is the recommended way to construct injectors in performance-sensitive parts.
	         *
	         * ### Example ([live demo](http://plnkr.co/edit/KrSMci?p=preview))
	         *
	         * ```typescript
	         * @Injectable()
	         * class Engine {
	         * }
	         *
	         * @Injectable()
	         * class Car {
	         *   constructor(public engine:Engine) {}
	         * }
	         *
	         * var providers = ReflectiveInjector.resolve([Car, Engine]);
	         * var injector = ReflectiveInjector.fromResolvedProviders(providers);
	         * expect(injector.get(Car) instanceof Car).toBe(true);
	         * ```
	         * @experimental
	         */
	        ReflectiveInjector.fromResolvedProviders = function (providers, parent) {
	            if (parent === void 0) { parent = null; }
	            return new ReflectiveInjector_(ReflectiveProtoInjector.fromResolvedProviders(providers), parent);
	        };
	        Object.defineProperty(ReflectiveInjector.prototype, "parent", {
	            /**
	             * Parent of this injector.
	             *
	             * <!-- TODO: Add a link to the section of the user guide talking about hierarchical injection.
	             * -->
	             *
	             * ### Example ([live demo](http://plnkr.co/edit/eosMGo?p=preview))
	             *
	             * ```typescript
	             * var parent = ReflectiveInjector.resolveAndCreate([]);
	             * var child = parent.resolveAndCreateChild([]);
	             * expect(child.parent).toBe(parent);
	             * ```
	             */
	            get: function () { return unimplemented(); },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * Resolves an array of providers and creates a child injector from those providers.
	         *
	         * <!-- TODO: Add a link to the section of the user guide talking about hierarchical injection.
	         * -->
	         *
	         * The passed-in providers can be an array of `Type`, {@link Provider},
	         * or a recursive array of more providers.
	         *
	         * ### Example ([live demo](http://plnkr.co/edit/opB3T4?p=preview))
	         *
	         * ```typescript
	         * class ParentProvider {}
	         * class ChildProvider {}
	         *
	         * var parent = ReflectiveInjector.resolveAndCreate([ParentProvider]);
	         * var child = parent.resolveAndCreateChild([ChildProvider]);
	         *
	         * expect(child.get(ParentProvider) instanceof ParentProvider).toBe(true);
	         * expect(child.get(ChildProvider) instanceof ChildProvider).toBe(true);
	         * expect(child.get(ParentProvider)).toBe(parent.get(ParentProvider));
	         * ```
	         *
	         * This function is slower than the corresponding `createChildFromResolved`
	         * because it needs to resolve the passed-in providers first.
	         * See {@link Injector#resolve} and {@link Injector#createChildFromResolved}.
	         */
	        ReflectiveInjector.prototype.resolveAndCreateChild = function (providers) { return unimplemented(); };
	        /**
	         * Creates a child injector from previously resolved providers.
	         *
	         * <!-- TODO: Add a link to the section of the user guide talking about hierarchical injection.
	         * -->
	         *
	         * This API is the recommended way to construct injectors in performance-sensitive parts.
	         *
	         * ### Example ([live demo](http://plnkr.co/edit/VhyfjN?p=preview))
	         *
	         * ```typescript
	         * class ParentProvider {}
	         * class ChildProvider {}
	         *
	         * var parentProviders = ReflectiveInjector.resolve([ParentProvider]);
	         * var childProviders = ReflectiveInjector.resolve([ChildProvider]);
	         *
	         * var parent = ReflectiveInjector.fromResolvedProviders(parentProviders);
	         * var child = parent.createChildFromResolved(childProviders);
	         *
	         * expect(child.get(ParentProvider) instanceof ParentProvider).toBe(true);
	         * expect(child.get(ChildProvider) instanceof ChildProvider).toBe(true);
	         * expect(child.get(ParentProvider)).toBe(parent.get(ParentProvider));
	         * ```
	         */
	        ReflectiveInjector.prototype.createChildFromResolved = function (providers) {
	            return unimplemented();
	        };
	        /**
	         * Resolves a provider and instantiates an object in the context of the injector.
	         *
	         * The created object does not get cached by the injector.
	         *
	         * ### Example ([live demo](http://plnkr.co/edit/yvVXoB?p=preview))
	         *
	         * ```typescript
	         * @Injectable()
	         * class Engine {
	         * }
	         *
	         * @Injectable()
	         * class Car {
	         *   constructor(public engine:Engine) {}
	         * }
	         *
	         * var injector = ReflectiveInjector.resolveAndCreate([Engine]);
	         *
	         * var car = injector.resolveAndInstantiate(Car);
	         * expect(car.engine).toBe(injector.get(Engine));
	         * expect(car).not.toBe(injector.resolveAndInstantiate(Car));
	         * ```
	         */
	        ReflectiveInjector.prototype.resolveAndInstantiate = function (provider) { return unimplemented(); };
	        /**
	         * Instantiates an object using a resolved provider in the context of the injector.
	         *
	         * The created object does not get cached by the injector.
	         *
	         * ### Example ([live demo](http://plnkr.co/edit/ptCImQ?p=preview))
	         *
	         * ```typescript
	         * @Injectable()
	         * class Engine {
	         * }
	         *
	         * @Injectable()
	         * class Car {
	         *   constructor(public engine:Engine) {}
	         * }
	         *
	         * var injector = ReflectiveInjector.resolveAndCreate([Engine]);
	         * var carProvider = ReflectiveInjector.resolve([Car])[0];
	         * var car = injector.instantiateResolved(carProvider);
	         * expect(car.engine).toBe(injector.get(Engine));
	         * expect(car).not.toBe(injector.instantiateResolved(carProvider));
	         * ```
	         */
	        ReflectiveInjector.prototype.instantiateResolved = function (provider) { return unimplemented(); };
	        return ReflectiveInjector;
	    }());
	    var ReflectiveInjector_ = (function () {
	        /**
	         * Private
	         */
	        function ReflectiveInjector_(_proto /* ProtoInjector */, _parent) {
	            if (_parent === void 0) { _parent = null; }
	            /** @internal */
	            this._constructionCounter = 0;
	            this._proto = _proto;
	            this._parent = _parent;
	            this._strategy = _proto._strategy.createInjectorStrategy(this);
	        }
	        ReflectiveInjector_.prototype.get = function (token, notFoundValue) {
	            if (notFoundValue === void 0) { notFoundValue = THROW_IF_NOT_FOUND; }
	            return this._getByKey(ReflectiveKey.get(token), null, null, notFoundValue);
	        };
	        ReflectiveInjector_.prototype.getAt = function (index) { return this._strategy.getObjAtIndex(index); };
	        Object.defineProperty(ReflectiveInjector_.prototype, "parent", {
	            get: function () { return this._parent; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(ReflectiveInjector_.prototype, "internalStrategy", {
	            /**
	             * @internal
	             * Internal. Do not use.
	             * We return `any` not to export the InjectorStrategy type.
	             */
	            get: function () { return this._strategy; },
	            enumerable: true,
	            configurable: true
	        });
	        ReflectiveInjector_.prototype.resolveAndCreateChild = function (providers) {
	            var ResolvedReflectiveProviders = ReflectiveInjector.resolve(providers);
	            return this.createChildFromResolved(ResolvedReflectiveProviders);
	        };
	        ReflectiveInjector_.prototype.createChildFromResolved = function (providers) {
	            var proto = new ReflectiveProtoInjector(providers);
	            var inj = new ReflectiveInjector_(proto);
	            inj._parent = this;
	            return inj;
	        };
	        ReflectiveInjector_.prototype.resolveAndInstantiate = function (provider) {
	            return this.instantiateResolved(ReflectiveInjector.resolve([provider])[0]);
	        };
	        ReflectiveInjector_.prototype.instantiateResolved = function (provider) {
	            return this._instantiateProvider(provider);
	        };
	        /** @internal */
	        ReflectiveInjector_.prototype._new = function (provider) {
	            if (this._constructionCounter++ > this._strategy.getMaxNumberOfObjects()) {
	                throw new CyclicDependencyError(this, provider.key);
	            }
	            return this._instantiateProvider(provider);
	        };
	        ReflectiveInjector_.prototype._instantiateProvider = function (provider) {
	            if (provider.multiProvider) {
	                var res = new Array(provider.resolvedFactories.length);
	                for (var i = 0; i < provider.resolvedFactories.length; ++i) {
	                    res[i] = this._instantiate(provider, provider.resolvedFactories[i]);
	                }
	                return res;
	            }
	            else {
	                return this._instantiate(provider, provider.resolvedFactories[0]);
	            }
	        };
	        ReflectiveInjector_.prototype._instantiate = function (provider, ResolvedReflectiveFactory) {
	            var factory = ResolvedReflectiveFactory.factory;
	            var deps = ResolvedReflectiveFactory.dependencies;
	            var length = deps.length;
	            var d0;
	            var d1;
	            var d2;
	            var d3;
	            var d4;
	            var d5;
	            var d6;
	            var d7;
	            var d8;
	            var d9;
	            var d10;
	            var d11;
	            var d12;
	            var d13;
	            var d14;
	            var d15;
	            var d16;
	            var d17;
	            var d18;
	            var d19;
	            try {
	                d0 = length > 0 ? this._getByReflectiveDependency(provider, deps[0]) : null;
	                d1 = length > 1 ? this._getByReflectiveDependency(provider, deps[1]) : null;
	                d2 = length > 2 ? this._getByReflectiveDependency(provider, deps[2]) : null;
	                d3 = length > 3 ? this._getByReflectiveDependency(provider, deps[3]) : null;
	                d4 = length > 4 ? this._getByReflectiveDependency(provider, deps[4]) : null;
	                d5 = length > 5 ? this._getByReflectiveDependency(provider, deps[5]) : null;
	                d6 = length > 6 ? this._getByReflectiveDependency(provider, deps[6]) : null;
	                d7 = length > 7 ? this._getByReflectiveDependency(provider, deps[7]) : null;
	                d8 = length > 8 ? this._getByReflectiveDependency(provider, deps[8]) : null;
	                d9 = length > 9 ? this._getByReflectiveDependency(provider, deps[9]) : null;
	                d10 = length > 10 ? this._getByReflectiveDependency(provider, deps[10]) : null;
	                d11 = length > 11 ? this._getByReflectiveDependency(provider, deps[11]) : null;
	                d12 = length > 12 ? this._getByReflectiveDependency(provider, deps[12]) : null;
	                d13 = length > 13 ? this._getByReflectiveDependency(provider, deps[13]) : null;
	                d14 = length > 14 ? this._getByReflectiveDependency(provider, deps[14]) : null;
	                d15 = length > 15 ? this._getByReflectiveDependency(provider, deps[15]) : null;
	                d16 = length > 16 ? this._getByReflectiveDependency(provider, deps[16]) : null;
	                d17 = length > 17 ? this._getByReflectiveDependency(provider, deps[17]) : null;
	                d18 = length > 18 ? this._getByReflectiveDependency(provider, deps[18]) : null;
	                d19 = length > 19 ? this._getByReflectiveDependency(provider, deps[19]) : null;
	            }
	            catch (e) {
	                if (e instanceof AbstractProviderError || e instanceof InstantiationError) {
	                    e.addKey(this, provider.key);
	                }
	                throw e;
	            }
	            var obj;
	            try {
	                switch (length) {
	                    case 0:
	                        obj = factory();
	                        break;
	                    case 1:
	                        obj = factory(d0);
	                        break;
	                    case 2:
	                        obj = factory(d0, d1);
	                        break;
	                    case 3:
	                        obj = factory(d0, d1, d2);
	                        break;
	                    case 4:
	                        obj = factory(d0, d1, d2, d3);
	                        break;
	                    case 5:
	                        obj = factory(d0, d1, d2, d3, d4);
	                        break;
	                    case 6:
	                        obj = factory(d0, d1, d2, d3, d4, d5);
	                        break;
	                    case 7:
	                        obj = factory(d0, d1, d2, d3, d4, d5, d6);
	                        break;
	                    case 8:
	                        obj = factory(d0, d1, d2, d3, d4, d5, d6, d7);
	                        break;
	                    case 9:
	                        obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8);
	                        break;
	                    case 10:
	                        obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9);
	                        break;
	                    case 11:
	                        obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10);
	                        break;
	                    case 12:
	                        obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11);
	                        break;
	                    case 13:
	                        obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12);
	                        break;
	                    case 14:
	                        obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13);
	                        break;
	                    case 15:
	                        obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14);
	                        break;
	                    case 16:
	                        obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15);
	                        break;
	                    case 17:
	                        obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15, d16);
	                        break;
	                    case 18:
	                        obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15, d16, d17);
	                        break;
	                    case 19:
	                        obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15, d16, d17, d18);
	                        break;
	                    case 20:
	                        obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15, d16, d17, d18, d19);
	                        break;
	                    default:
	                        throw new Error("Cannot instantiate '" + provider.key.displayName + "' because it has more than 20 dependencies");
	                }
	            }
	            catch (e) {
	                throw new InstantiationError(this, e, e.stack, provider.key);
	            }
	            return obj;
	        };
	        ReflectiveInjector_.prototype._getByReflectiveDependency = function (provider, dep) {
	            return this._getByKey(dep.key, dep.lowerBoundVisibility, dep.upperBoundVisibility, dep.optional ? null : THROW_IF_NOT_FOUND);
	        };
	        ReflectiveInjector_.prototype._getByKey = function (key, lowerBoundVisibility, upperBoundVisibility, notFoundValue) {
	            if (key === INJECTOR_KEY) {
	                return this;
	            }
	            if (upperBoundVisibility instanceof Self) {
	                return this._getByKeySelf(key, notFoundValue);
	            }
	            else {
	                return this._getByKeyDefault(key, notFoundValue, lowerBoundVisibility);
	            }
	        };
	        /** @internal */
	        ReflectiveInjector_.prototype._throwOrNull = function (key, notFoundValue) {
	            if (notFoundValue !== THROW_IF_NOT_FOUND) {
	                return notFoundValue;
	            }
	            else {
	                throw new NoProviderError(this, key);
	            }
	        };
	        /** @internal */
	        ReflectiveInjector_.prototype._getByKeySelf = function (key, notFoundValue) {
	            var obj = this._strategy.getObjByKeyId(key.id);
	            return (obj !== UNDEFINED) ? obj : this._throwOrNull(key, notFoundValue);
	        };
	        /** @internal */
	        ReflectiveInjector_.prototype._getByKeyDefault = function (key, notFoundValue, lowerBoundVisibility) {
	            var inj;
	            if (lowerBoundVisibility instanceof SkipSelf) {
	                inj = this._parent;
	            }
	            else {
	                inj = this;
	            }
	            while (inj instanceof ReflectiveInjector_) {
	                var inj_ = inj;
	                var obj = inj_._strategy.getObjByKeyId(key.id);
	                if (obj !== UNDEFINED)
	                    return obj;
	                inj = inj_._parent;
	            }
	            if (inj !== null) {
	                return inj.get(key.token, notFoundValue);
	            }
	            else {
	                return this._throwOrNull(key, notFoundValue);
	            }
	        };
	        Object.defineProperty(ReflectiveInjector_.prototype, "displayName", {
	            get: function () {
	                var providers = _mapProviders(this, function (b) { return ' "' + b.key.displayName + '" '; })
	                    .join(', ');
	                return "ReflectiveInjector(providers: [" + providers + "])";
	            },
	            enumerable: true,
	            configurable: true
	        });
	        ReflectiveInjector_.prototype.toString = function () { return this.displayName; };
	        return ReflectiveInjector_;
	    }());
	    var INJECTOR_KEY = ReflectiveKey.get(Injector);
	    function _mapProviders(injector, fn) {
	        var res = new Array(injector._proto.numberOfProviders);
	        for (var i = 0; i < injector._proto.numberOfProviders; ++i) {
	            res[i] = fn(injector._proto.getProviderAtIndex(i));
	        }
	        return res;
	    }

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    /**
	     * @whatItDoes Provides a hook for centralized exception handling.
	     *
	     * @description
	     *
	     * The default implementation of `ErrorHandler` prints error messages to the `console`. To
	     * intercept error handling, write a custom exception handler that replaces this default as
	     * appropriate for your app.
	     *
	     * ### Example
	     *
	     * ```
	     * class MyErrorHandler implements ErrorHandler {
	     *   handleError(error) {
	     *     // do something with the exception
	     *   }
	     * }
	     *
	     * @NgModule({
	     *   providers: [{provide: ErrorHandler, useClass: MyErrorHandler}]
	     * })
	     * class MyModule {}
	     * ```
	     *
	     * @stable
	     */
	    var ErrorHandler = (function () {
	        function ErrorHandler(rethrowError) {
	            if (rethrowError === void 0) { rethrowError = true; }
	            /**
	             * @internal
	             */
	            this._console = console;
	            this.rethrowError = rethrowError;
	        }
	        ErrorHandler.prototype.handleError = function (error) {
	            var originalError = this._findOriginalError(error);
	            var originalStack = this._findOriginalStack(error);
	            var context = this._findContext(error);
	            this._console.error("EXCEPTION: " + this._extractMessage(error));
	            if (originalError) {
	                this._console.error("ORIGINAL EXCEPTION: " + this._extractMessage(originalError));
	            }
	            if (originalStack) {
	                this._console.error('ORIGINAL STACKTRACE:');
	                this._console.error(originalStack);
	            }
	            if (context) {
	                this._console.error('ERROR CONTEXT:');
	                this._console.error(context);
	            }
	            // We rethrow exceptions, so operations like 'bootstrap' will result in an error
	            // when an error happens. If we do not rethrow, bootstrap will always succeed.
	            if (this.rethrowError)
	                throw error;
	        };
	        /** @internal */
	        ErrorHandler.prototype._extractMessage = function (error) {
	            return error instanceof Error ? error.message : error.toString();
	        };
	        /** @internal */
	        ErrorHandler.prototype._findContext = function (error) {
	            if (error) {
	                return error.context ? error.context :
	                    this._findContext(error.originalError);
	            }
	            return null;
	        };
	        /** @internal */
	        ErrorHandler.prototype._findOriginalError = function (error) {
	            var e = error.originalError;
	            while (e && e.originalError) {
	                e = e.originalError;
	            }
	            return e;
	        };
	        /** @internal */
	        ErrorHandler.prototype._findOriginalStack = function (error) {
	            if (!(error instanceof Error))
	                return null;
	            var e = error;
	            var stack = e.stack;
	            while (e instanceof Error && e.originalError) {
	                e = e.originalError;
	                if (e instanceof Error && e.stack) {
	                    stack = e.stack;
	                }
	            }
	            return stack;
	        };
	        return ErrorHandler;
	    }());

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    function isPromise(obj) {
	        // allow any Promise/A+ compliant thenable.
	        // It's up to the caller to ensure that obj.then conforms to the spec
	        return !!obj && typeof obj.then === 'function';
	    }

	    /**
	     * A function that will be executed when an application is initialized.
	     * @experimental
	     */
	    var APP_INITIALIZER = new OpaqueToken('Application Initializer');
	    /**
	     * A class that reflects the state of running {@link APP_INITIALIZER}s.
	     *
	     * @experimental
	     */
	    var ApplicationInitStatus = (function () {
	        function ApplicationInitStatus(appInits) {
	            var _this = this;
	            this._done = false;
	            var asyncInitPromises = [];
	            if (appInits) {
	                for (var i = 0; i < appInits.length; i++) {
	                    var initResult = appInits[i]();
	                    if (isPromise(initResult)) {
	                        asyncInitPromises.push(initResult);
	                    }
	                }
	            }
	            this._donePromise = Promise.all(asyncInitPromises).then(function () { _this._done = true; });
	            if (asyncInitPromises.length === 0) {
	                this._done = true;
	            }
	        }
	        Object.defineProperty(ApplicationInitStatus.prototype, "done", {
	            get: function () { return this._done; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(ApplicationInitStatus.prototype, "donePromise", {
	            get: function () { return this._donePromise; },
	            enumerable: true,
	            configurable: true
	        });
	        ApplicationInitStatus.decorators = [
	            { type: Injectable },
	        ];
	        /** @nocollapse */
	        ApplicationInitStatus.ctorParameters = [
	            { type: Array, decorators: [{ type: Inject, args: [APP_INITIALIZER,] }, { type: Optional },] },
	        ];
	        return ApplicationInitStatus;
	    }());

	    /**
	     * A DI Token representing a unique string id assigned to the application by Angular and used
	     * primarily for prefixing application attributes and CSS styles when
	     * {@link ViewEncapsulation#Emulated} is being used.
	     *
	     * If you need to avoid randomly generated value to be used as an application id, you can provide
	     * a custom value via a DI provider <!-- TODO: provider --> configuring the root {@link Injector}
	     * using this token.
	     * @experimental
	     */
	    var APP_ID = new OpaqueToken('AppId');
	    function _appIdRandomProviderFactory() {
	        return "" + _randomChar() + _randomChar() + _randomChar();
	    }
	    /**
	     * Providers that will generate a random APP_ID_TOKEN.
	     * @experimental
	     */
	    var APP_ID_RANDOM_PROVIDER = {
	        provide: APP_ID,
	        useFactory: _appIdRandomProviderFactory,
	        deps: [],
	    };
	    function _randomChar() {
	        return String.fromCharCode(97 + Math.floor(Math.random() * 25));
	    }
	    /**
	     * A function that will be executed when a platform is initialized.
	     * @experimental
	     */
	    var PLATFORM_INITIALIZER = new OpaqueToken('Platform Initializer');
	    /**
	     * All callbacks provided via this token will be called for every component that is bootstrapped.
	     * Signature of the callback:
	     *
	     * `(componentRef: ComponentRef) => void`.
	     *
	     * @experimental
	     */
	    var APP_BOOTSTRAP_LISTENER = new OpaqueToken('appBootstrapListener');
	    /**
	     * A token which indicates the root directory of the application
	     * @experimental
	     */
	    var PACKAGE_ROOT_URL = new OpaqueToken('Application Packages Root URL');

	    var Console = (function () {
	        function Console() {
	        }
	        Console.prototype.log = function (message) { print(message); };
	        // Note: for reporting errors use `DOM.logError()` as it is platform specific
	        Console.prototype.warn = function (message) { warn(message); };
	        Console.decorators = [
	            { type: Injectable },
	        ];
	        /** @nocollapse */
	        Console.ctorParameters = [];
	        return Console;
	    }());

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$4 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    /**
	     * Indicates that a component is still being loaded in a synchronous compile.
	     *
	     * @stable
	     */
	    var ComponentStillLoadingError = (function (_super) {
	        __extends$4(ComponentStillLoadingError, _super);
	        function ComponentStillLoadingError(compType) {
	            _super.call(this, "Can't compile synchronously as " + stringify(compType) + " is still being loaded!");
	            this.compType = compType;
	        }
	        return ComponentStillLoadingError;
	    }(BaseError));
	    /**
	     * Combination of NgModuleFactory and ComponentFactorys.
	     *
	     * @experimental
	     */
	    var ModuleWithComponentFactories = (function () {
	        function ModuleWithComponentFactories(ngModuleFactory, componentFactories) {
	            this.ngModuleFactory = ngModuleFactory;
	            this.componentFactories = componentFactories;
	        }
	        return ModuleWithComponentFactories;
	    }());
	    function _throwError() {
	        throw new Error("Runtime compiler is not loaded");
	    }
	    /**
	     * Low-level service for running the angular compiler during runtime
	     * to create {@link ComponentFactory}s, which
	     * can later be used to create and render a Component instance.
	     *
	     * Each `@NgModule` provides an own `Compiler` to its injector,
	     * that will use the directives/pipes of the ng module for compilation
	     * of components.
	     * @stable
	     */
	    var Compiler = (function () {
	        function Compiler() {
	        }
	        /**
	         * Compiles the given NgModule and all of its components. All templates of the components listed
	         * in `entryComponents`
	         * have to be inlined. Otherwise throws a {@link ComponentStillLoadingError}.
	         */
	        Compiler.prototype.compileModuleSync = function (moduleType) { throw _throwError(); };
	        /**
	         * Compiles the given NgModule and all of its components
	         */
	        Compiler.prototype.compileModuleAsync = function (moduleType) { throw _throwError(); };
	        /**
	         * Same as {@link compileModuleSync} but also creates ComponentFactories for all components.
	         */
	        Compiler.prototype.compileModuleAndAllComponentsSync = function (moduleType) {
	            throw _throwError();
	        };
	        /**
	         * Same as {@link compileModuleAsync} but also creates ComponentFactories for all components.
	         */
	        Compiler.prototype.compileModuleAndAllComponentsAsync = function (moduleType) {
	            throw _throwError();
	        };
	        /**
	         * Clears all caches.
	         */
	        Compiler.prototype.clearCache = function () { };
	        /**
	         * Clears the cache for the given component/ngModule.
	         */
	        Compiler.prototype.clearCacheFor = function (type) { };
	        return Compiler;
	    }());
	    /**
	     * Token to provide CompilerOptions in the platform injector.
	     *
	     * @experimental
	     */
	    var COMPILER_OPTIONS = new OpaqueToken('compilerOptions');
	    /**
	     * A factory for creating a Compiler
	     *
	     * @experimental
	     */
	    var CompilerFactory = (function () {
	        function CompilerFactory() {
	        }
	        return CompilerFactory;
	    }());

	    var DefaultIterableDifferFactory = (function () {
	        function DefaultIterableDifferFactory() {
	        }
	        DefaultIterableDifferFactory.prototype.supports = function (obj) { return isListLikeIterable(obj); };
	        DefaultIterableDifferFactory.prototype.create = function (cdRef, trackByFn) {
	            return new DefaultIterableDiffer(trackByFn);
	        };
	        return DefaultIterableDifferFactory;
	    }());
	    var trackByIdentity = function (index, item) { return item; };
	    /**
	     * @stable
	     */
	    var DefaultIterableDiffer = (function () {
	        function DefaultIterableDiffer(_trackByFn) {
	            this._trackByFn = _trackByFn;
	            this._length = null;
	            this._collection = null;
	            // Keeps track of the used records at any point in time (during & across `_check()` calls)
	            this._linkedRecords = null;
	            // Keeps track of the removed records at any point in time during `_check()` calls.
	            this._unlinkedRecords = null;
	            this._previousItHead = null;
	            this._itHead = null;
	            this._itTail = null;
	            this._additionsHead = null;
	            this._additionsTail = null;
	            this._movesHead = null;
	            this._movesTail = null;
	            this._removalsHead = null;
	            this._removalsTail = null;
	            // Keeps track of records where custom track by is the same, but item identity has changed
	            this._identityChangesHead = null;
	            this._identityChangesTail = null;
	            this._trackByFn = this._trackByFn || trackByIdentity;
	        }
	        Object.defineProperty(DefaultIterableDiffer.prototype, "collection", {
	            get: function () { return this._collection; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(DefaultIterableDiffer.prototype, "length", {
	            get: function () { return this._length; },
	            enumerable: true,
	            configurable: true
	        });
	        DefaultIterableDiffer.prototype.forEachItem = function (fn) {
	            var record;
	            for (record = this._itHead; record !== null; record = record._next) {
	                fn(record);
	            }
	        };
	        DefaultIterableDiffer.prototype.forEachOperation = function (fn) {
	            var nextIt = this._itHead;
	            var nextRemove = this._removalsHead;
	            var addRemoveOffset = 0;
	            var moveOffsets = null;
	            while (nextIt || nextRemove) {
	                // Figure out which is the next record to process
	                // Order: remove, add, move
	                var record = !nextRemove ||
	                    nextIt &&
	                        nextIt.currentIndex < getPreviousIndex(nextRemove, addRemoveOffset, moveOffsets) ?
	                    nextIt :
	                    nextRemove;
	                var adjPreviousIndex = getPreviousIndex(record, addRemoveOffset, moveOffsets);
	                var currentIndex = record.currentIndex;
	                // consume the item, and adjust the addRemoveOffset and update moveDistance if necessary
	                if (record === nextRemove) {
	                    addRemoveOffset--;
	                    nextRemove = nextRemove._nextRemoved;
	                }
	                else {
	                    nextIt = nextIt._next;
	                    if (record.previousIndex == null) {
	                        addRemoveOffset++;
	                    }
	                    else {
	                        // INVARIANT:  currentIndex < previousIndex
	                        if (!moveOffsets)
	                            moveOffsets = [];
	                        var localMovePreviousIndex = adjPreviousIndex - addRemoveOffset;
	                        var localCurrentIndex = currentIndex - addRemoveOffset;
	                        if (localMovePreviousIndex != localCurrentIndex) {
	                            for (var i = 0; i < localMovePreviousIndex; i++) {
	                                var offset = i < moveOffsets.length ? moveOffsets[i] : (moveOffsets[i] = 0);
	                                var index = offset + i;
	                                if (localCurrentIndex <= index && index < localMovePreviousIndex) {
	                                    moveOffsets[i] = offset + 1;
	                                }
	                            }
	                            var previousIndex = record.previousIndex;
	                            moveOffsets[previousIndex] = localCurrentIndex - localMovePreviousIndex;
	                        }
	                    }
	                }
	                if (adjPreviousIndex !== currentIndex) {
	                    fn(record, adjPreviousIndex, currentIndex);
	                }
	            }
	        };
	        DefaultIterableDiffer.prototype.forEachPreviousItem = function (fn) {
	            var record;
	            for (record = this._previousItHead; record !== null; record = record._nextPrevious) {
	                fn(record);
	            }
	        };
	        DefaultIterableDiffer.prototype.forEachAddedItem = function (fn) {
	            var record;
	            for (record = this._additionsHead; record !== null; record = record._nextAdded) {
	                fn(record);
	            }
	        };
	        DefaultIterableDiffer.prototype.forEachMovedItem = function (fn) {
	            var record;
	            for (record = this._movesHead; record !== null; record = record._nextMoved) {
	                fn(record);
	            }
	        };
	        DefaultIterableDiffer.prototype.forEachRemovedItem = function (fn) {
	            var record;
	            for (record = this._removalsHead; record !== null; record = record._nextRemoved) {
	                fn(record);
	            }
	        };
	        DefaultIterableDiffer.prototype.forEachIdentityChange = function (fn) {
	            var record;
	            for (record = this._identityChangesHead; record !== null; record = record._nextIdentityChange) {
	                fn(record);
	            }
	        };
	        DefaultIterableDiffer.prototype.diff = function (collection) {
	            if (isBlank(collection))
	                collection = [];
	            if (!isListLikeIterable(collection)) {
	                throw new Error("Error trying to diff '" + collection + "'");
	            }
	            if (this.check(collection)) {
	                return this;
	            }
	            else {
	                return null;
	            }
	        };
	        DefaultIterableDiffer.prototype.onDestroy = function () { };
	        // todo(vicb): optim for UnmodifiableListView (frozen arrays)
	        DefaultIterableDiffer.prototype.check = function (collection) {
	            var _this = this;
	            this._reset();
	            var record = this._itHead;
	            var mayBeDirty = false;
	            var index;
	            var item;
	            var itemTrackBy;
	            if (Array.isArray(collection)) {
	                var list = collection;
	                this._length = collection.length;
	                for (var index_1 = 0; index_1 < this._length; index_1++) {
	                    item = list[index_1];
	                    itemTrackBy = this._trackByFn(index_1, item);
	                    if (record === null || !looseIdentical(record.trackById, itemTrackBy)) {
	                        record = this._mismatch(record, item, itemTrackBy, index_1);
	                        mayBeDirty = true;
	                    }
	                    else {
	                        if (mayBeDirty) {
	                            // TODO(misko): can we limit this to duplicates only?
	                            record = this._verifyReinsertion(record, item, itemTrackBy, index_1);
	                        }
	                        if (!looseIdentical(record.item, item))
	                            this._addIdentityChange(record, item);
	                    }
	                    record = record._next;
	                }
	            }
	            else {
	                index = 0;
	                iterateListLike(collection, function (item /** TODO #9100 */) {
	                    itemTrackBy = _this._trackByFn(index, item);
	                    if (record === null || !looseIdentical(record.trackById, itemTrackBy)) {
	                        record = _this._mismatch(record, item, itemTrackBy, index);
	                        mayBeDirty = true;
	                    }
	                    else {
	                        if (mayBeDirty) {
	                            // TODO(misko): can we limit this to duplicates only?
	                            record = _this._verifyReinsertion(record, item, itemTrackBy, index);
	                        }
	                        if (!looseIdentical(record.item, item))
	                            _this._addIdentityChange(record, item);
	                    }
	                    record = record._next;
	                    index++;
	                });
	                this._length = index;
	            }
	            this._truncate(record);
	            this._collection = collection;
	            return this.isDirty;
	        };
	        Object.defineProperty(DefaultIterableDiffer.prototype, "isDirty", {
	            /* CollectionChanges is considered dirty if it has any additions, moves, removals, or identity
	             * changes.
	             */
	            get: function () {
	                return this._additionsHead !== null || this._movesHead !== null ||
	                    this._removalsHead !== null || this._identityChangesHead !== null;
	            },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * Reset the state of the change objects to show no changes. This means set previousKey to
	         * currentKey, and clear all of the queues (additions, moves, removals).
	         * Set the previousIndexes of moved and added items to their currentIndexes
	         * Reset the list of additions, moves and removals
	         *
	         * @internal
	         */
	        DefaultIterableDiffer.prototype._reset = function () {
	            if (this.isDirty) {
	                var record;
	                var nextRecord;
	                for (record = this._previousItHead = this._itHead; record !== null; record = record._next) {
	                    record._nextPrevious = record._next;
	                }
	                for (record = this._additionsHead; record !== null; record = record._nextAdded) {
	                    record.previousIndex = record.currentIndex;
	                }
	                this._additionsHead = this._additionsTail = null;
	                for (record = this._movesHead; record !== null; record = nextRecord) {
	                    record.previousIndex = record.currentIndex;
	                    nextRecord = record._nextMoved;
	                }
	                this._movesHead = this._movesTail = null;
	                this._removalsHead = this._removalsTail = null;
	                this._identityChangesHead = this._identityChangesTail = null;
	            }
	        };
	        /**
	         * This is the core function which handles differences between collections.
	         *
	         * - `record` is the record which we saw at this position last time. If null then it is a new
	         *   item.
	         * - `item` is the current item in the collection
	         * - `index` is the position of the item in the collection
	         *
	         * @internal
	         */
	        DefaultIterableDiffer.prototype._mismatch = function (record, item, itemTrackBy, index) {
	            // The previous record after which we will append the current one.
	            var previousRecord;
	            if (record === null) {
	                previousRecord = this._itTail;
	            }
	            else {
	                previousRecord = record._prev;
	                // Remove the record from the collection since we know it does not match the item.
	                this._remove(record);
	            }
	            // Attempt to see if we have seen the item before.
	            record = this._linkedRecords === null ? null : this._linkedRecords.get(itemTrackBy, index);
	            if (record !== null) {
	                // We have seen this before, we need to move it forward in the collection.
	                // But first we need to check if identity changed, so we can update in view if necessary
	                if (!looseIdentical(record.item, item))
	                    this._addIdentityChange(record, item);
	                this._moveAfter(record, previousRecord, index);
	            }
	            else {
	                // Never seen it, check evicted list.
	                record = this._unlinkedRecords === null ? null : this._unlinkedRecords.get(itemTrackBy);
	                if (record !== null) {
	                    // It is an item which we have evicted earlier: reinsert it back into the list.
	                    // But first we need to check if identity changed, so we can update in view if necessary
	                    if (!looseIdentical(record.item, item))
	                        this._addIdentityChange(record, item);
	                    this._reinsertAfter(record, previousRecord, index);
	                }
	                else {
	                    // It is a new item: add it.
	                    record =
	                        this._addAfter(new CollectionChangeRecord(item, itemTrackBy), previousRecord, index);
	                }
	            }
	            return record;
	        };
	        /**
	         * This check is only needed if an array contains duplicates. (Short circuit of nothing dirty)
	         *
	         * Use case: `[a, a]` => `[b, a, a]`
	         *
	         * If we did not have this check then the insertion of `b` would:
	         *   1) evict first `a`
	         *   2) insert `b` at `0` index.
	         *   3) leave `a` at index `1` as is. <-- this is wrong!
	         *   3) reinsert `a` at index 2. <-- this is wrong!
	         *
	         * The correct behavior is:
	         *   1) evict first `a`
	         *   2) insert `b` at `0` index.
	         *   3) reinsert `a` at index 1.
	         *   3) move `a` at from `1` to `2`.
	         *
	         *
	         * Double check that we have not evicted a duplicate item. We need to check if the item type may
	         * have already been removed:
	         * The insertion of b will evict the first 'a'. If we don't reinsert it now it will be reinserted
	         * at the end. Which will show up as the two 'a's switching position. This is incorrect, since a
	         * better way to think of it is as insert of 'b' rather then switch 'a' with 'b' and then add 'a'
	         * at the end.
	         *
	         * @internal
	         */
	        DefaultIterableDiffer.prototype._verifyReinsertion = function (record, item, itemTrackBy, index) {
	            var reinsertRecord = this._unlinkedRecords === null ? null : this._unlinkedRecords.get(itemTrackBy);
	            if (reinsertRecord !== null) {
	                record = this._reinsertAfter(reinsertRecord, record._prev, index);
	            }
	            else if (record.currentIndex != index) {
	                record.currentIndex = index;
	                this._addToMoves(record, index);
	            }
	            return record;
	        };
	        /**
	         * Get rid of any excess {@link CollectionChangeRecord}s from the previous collection
	         *
	         * - `record` The first excess {@link CollectionChangeRecord}.
	         *
	         * @internal
	         */
	        DefaultIterableDiffer.prototype._truncate = function (record) {
	            // Anything after that needs to be removed;
	            while (record !== null) {
	                var nextRecord = record._next;
	                this._addToRemovals(this._unlink(record));
	                record = nextRecord;
	            }
	            if (this._unlinkedRecords !== null) {
	                this._unlinkedRecords.clear();
	            }
	            if (this._additionsTail !== null) {
	                this._additionsTail._nextAdded = null;
	            }
	            if (this._movesTail !== null) {
	                this._movesTail._nextMoved = null;
	            }
	            if (this._itTail !== null) {
	                this._itTail._next = null;
	            }
	            if (this._removalsTail !== null) {
	                this._removalsTail._nextRemoved = null;
	            }
	            if (this._identityChangesTail !== null) {
	                this._identityChangesTail._nextIdentityChange = null;
	            }
	        };
	        /** @internal */
	        DefaultIterableDiffer.prototype._reinsertAfter = function (record, prevRecord, index) {
	            if (this._unlinkedRecords !== null) {
	                this._unlinkedRecords.remove(record);
	            }
	            var prev = record._prevRemoved;
	            var next = record._nextRemoved;
	            if (prev === null) {
	                this._removalsHead = next;
	            }
	            else {
	                prev._nextRemoved = next;
	            }
	            if (next === null) {
	                this._removalsTail = prev;
	            }
	            else {
	                next._prevRemoved = prev;
	            }
	            this._insertAfter(record, prevRecord, index);
	            this._addToMoves(record, index);
	            return record;
	        };
	        /** @internal */
	        DefaultIterableDiffer.prototype._moveAfter = function (record, prevRecord, index) {
	            this._unlink(record);
	            this._insertAfter(record, prevRecord, index);
	            this._addToMoves(record, index);
	            return record;
	        };
	        /** @internal */
	        DefaultIterableDiffer.prototype._addAfter = function (record, prevRecord, index) {
	            this._insertAfter(record, prevRecord, index);
	            if (this._additionsTail === null) {
	                // todo(vicb)
	                // assert(this._additionsHead === null);
	                this._additionsTail = this._additionsHead = record;
	            }
	            else {
	                // todo(vicb)
	                // assert(_additionsTail._nextAdded === null);
	                // assert(record._nextAdded === null);
	                this._additionsTail = this._additionsTail._nextAdded = record;
	            }
	            return record;
	        };
	        /** @internal */
	        DefaultIterableDiffer.prototype._insertAfter = function (record, prevRecord, index) {
	            // todo(vicb)
	            // assert(record != prevRecord);
	            // assert(record._next === null);
	            // assert(record._prev === null);
	            var next = prevRecord === null ? this._itHead : prevRecord._next;
	            // todo(vicb)
	            // assert(next != record);
	            // assert(prevRecord != record);
	            record._next = next;
	            record._prev = prevRecord;
	            if (next === null) {
	                this._itTail = record;
	            }
	            else {
	                next._prev = record;
	            }
	            if (prevRecord === null) {
	                this._itHead = record;
	            }
	            else {
	                prevRecord._next = record;
	            }
	            if (this._linkedRecords === null) {
	                this._linkedRecords = new _DuplicateMap();
	            }
	            this._linkedRecords.put(record);
	            record.currentIndex = index;
	            return record;
	        };
	        /** @internal */
	        DefaultIterableDiffer.prototype._remove = function (record) {
	            return this._addToRemovals(this._unlink(record));
	        };
	        /** @internal */
	        DefaultIterableDiffer.prototype._unlink = function (record) {
	            if (this._linkedRecords !== null) {
	                this._linkedRecords.remove(record);
	            }
	            var prev = record._prev;
	            var next = record._next;
	            // todo(vicb)
	            // assert((record._prev = null) === null);
	            // assert((record._next = null) === null);
	            if (prev === null) {
	                this._itHead = next;
	            }
	            else {
	                prev._next = next;
	            }
	            if (next === null) {
	                this._itTail = prev;
	            }
	            else {
	                next._prev = prev;
	            }
	            return record;
	        };
	        /** @internal */
	        DefaultIterableDiffer.prototype._addToMoves = function (record, toIndex) {
	            // todo(vicb)
	            // assert(record._nextMoved === null);
	            if (record.previousIndex === toIndex) {
	                return record;
	            }
	            if (this._movesTail === null) {
	                // todo(vicb)
	                // assert(_movesHead === null);
	                this._movesTail = this._movesHead = record;
	            }
	            else {
	                // todo(vicb)
	                // assert(_movesTail._nextMoved === null);
	                this._movesTail = this._movesTail._nextMoved = record;
	            }
	            return record;
	        };
	        /** @internal */
	        DefaultIterableDiffer.prototype._addToRemovals = function (record) {
	            if (this._unlinkedRecords === null) {
	                this._unlinkedRecords = new _DuplicateMap();
	            }
	            this._unlinkedRecords.put(record);
	            record.currentIndex = null;
	            record._nextRemoved = null;
	            if (this._removalsTail === null) {
	                // todo(vicb)
	                // assert(_removalsHead === null);
	                this._removalsTail = this._removalsHead = record;
	                record._prevRemoved = null;
	            }
	            else {
	                // todo(vicb)
	                // assert(_removalsTail._nextRemoved === null);
	                // assert(record._nextRemoved === null);
	                record._prevRemoved = this._removalsTail;
	                this._removalsTail = this._removalsTail._nextRemoved = record;
	            }
	            return record;
	        };
	        /** @internal */
	        DefaultIterableDiffer.prototype._addIdentityChange = function (record, item) {
	            record.item = item;
	            if (this._identityChangesTail === null) {
	                this._identityChangesTail = this._identityChangesHead = record;
	            }
	            else {
	                this._identityChangesTail = this._identityChangesTail._nextIdentityChange = record;
	            }
	            return record;
	        };
	        DefaultIterableDiffer.prototype.toString = function () {
	            var list = [];
	            this.forEachItem(function (record /** TODO #9100 */) { return list.push(record); });
	            var previous = [];
	            this.forEachPreviousItem(function (record /** TODO #9100 */) { return previous.push(record); });
	            var additions = [];
	            this.forEachAddedItem(function (record /** TODO #9100 */) { return additions.push(record); });
	            var moves = [];
	            this.forEachMovedItem(function (record /** TODO #9100 */) { return moves.push(record); });
	            var removals = [];
	            this.forEachRemovedItem(function (record /** TODO #9100 */) { return removals.push(record); });
	            var identityChanges = [];
	            this.forEachIdentityChange(function (record /** TODO #9100 */) { return identityChanges.push(record); });
	            return 'collection: ' + list.join(', ') + '\n' +
	                'previous: ' + previous.join(', ') + '\n' +
	                'additions: ' + additions.join(', ') + '\n' +
	                'moves: ' + moves.join(', ') + '\n' +
	                'removals: ' + removals.join(', ') + '\n' +
	                'identityChanges: ' + identityChanges.join(', ') + '\n';
	        };
	        return DefaultIterableDiffer;
	    }());
	    /**
	     * @stable
	     */
	    var CollectionChangeRecord = (function () {
	        function CollectionChangeRecord(item, trackById) {
	            this.item = item;
	            this.trackById = trackById;
	            this.currentIndex = null;
	            this.previousIndex = null;
	            /** @internal */
	            this._nextPrevious = null;
	            /** @internal */
	            this._prev = null;
	            /** @internal */
	            this._next = null;
	            /** @internal */
	            this._prevDup = null;
	            /** @internal */
	            this._nextDup = null;
	            /** @internal */
	            this._prevRemoved = null;
	            /** @internal */
	            this._nextRemoved = null;
	            /** @internal */
	            this._nextAdded = null;
	            /** @internal */
	            this._nextMoved = null;
	            /** @internal */
	            this._nextIdentityChange = null;
	        }
	        CollectionChangeRecord.prototype.toString = function () {
	            return this.previousIndex === this.currentIndex ? stringify(this.item) :
	                stringify(this.item) + '[' +
	                    stringify(this.previousIndex) + '->' + stringify(this.currentIndex) + ']';
	        };
	        return CollectionChangeRecord;
	    }());
	    // A linked list of CollectionChangeRecords with the same CollectionChangeRecord.item
	    var _DuplicateItemRecordList = (function () {
	        function _DuplicateItemRecordList() {
	            /** @internal */
	            this._head = null;
	            /** @internal */
	            this._tail = null;
	        }
	        /**
	         * Append the record to the list of duplicates.
	         *
	         * Note: by design all records in the list of duplicates hold the same value in record.item.
	         */
	        _DuplicateItemRecordList.prototype.add = function (record) {
	            if (this._head === null) {
	                this._head = this._tail = record;
	                record._nextDup = null;
	                record._prevDup = null;
	            }
	            else {
	                // todo(vicb)
	                // assert(record.item ==  _head.item ||
	                //       record.item is num && record.item.isNaN && _head.item is num && _head.item.isNaN);
	                this._tail._nextDup = record;
	                record._prevDup = this._tail;
	                record._nextDup = null;
	                this._tail = record;
	            }
	        };
	        // Returns a CollectionChangeRecord having CollectionChangeRecord.trackById == trackById and
	        // CollectionChangeRecord.currentIndex >= afterIndex
	        _DuplicateItemRecordList.prototype.get = function (trackById, afterIndex) {
	            var record;
	            for (record = this._head; record !== null; record = record._nextDup) {
	                if ((afterIndex === null || afterIndex < record.currentIndex) &&
	                    looseIdentical(record.trackById, trackById)) {
	                    return record;
	                }
	            }
	            return null;
	        };
	        /**
	         * Remove one {@link CollectionChangeRecord} from the list of duplicates.
	         *
	         * Returns whether the list of duplicates is empty.
	         */
	        _DuplicateItemRecordList.prototype.remove = function (record) {
	            // todo(vicb)
	            // assert(() {
	            //  // verify that the record being removed is in the list.
	            //  for (CollectionChangeRecord cursor = _head; cursor != null; cursor = cursor._nextDup) {
	            //    if (identical(cursor, record)) return true;
	            //  }
	            //  return false;
	            //});
	            var prev = record._prevDup;
	            var next = record._nextDup;
	            if (prev === null) {
	                this._head = next;
	            }
	            else {
	                prev._nextDup = next;
	            }
	            if (next === null) {
	                this._tail = prev;
	            }
	            else {
	                next._prevDup = prev;
	            }
	            return this._head === null;
	        };
	        return _DuplicateItemRecordList;
	    }());
	    var _DuplicateMap = (function () {
	        function _DuplicateMap() {
	            this.map = new Map();
	        }
	        _DuplicateMap.prototype.put = function (record) {
	            var key = record.trackById;
	            var duplicates = this.map.get(key);
	            if (!duplicates) {
	                duplicates = new _DuplicateItemRecordList();
	                this.map.set(key, duplicates);
	            }
	            duplicates.add(record);
	        };
	        /**
	         * Retrieve the `value` using key. Because the CollectionChangeRecord value may be one which we
	         * have already iterated over, we use the afterIndex to pretend it is not there.
	         *
	         * Use case: `[a, b, c, a, a]` if we are at index `3` which is the second `a` then asking if we
	         * have any more `a`s needs to return the last `a` not the first or second.
	         */
	        _DuplicateMap.prototype.get = function (trackById, afterIndex) {
	            if (afterIndex === void 0) { afterIndex = null; }
	            var key = trackById;
	            var recordList = this.map.get(key);
	            return recordList ? recordList.get(trackById, afterIndex) : null;
	        };
	        /**
	         * Removes a {@link CollectionChangeRecord} from the list of duplicates.
	         *
	         * The list of duplicates also is removed from the map if it gets empty.
	         */
	        _DuplicateMap.prototype.remove = function (record) {
	            var key = record.trackById;
	            var recordList = this.map.get(key);
	            // Remove the list of duplicates when it gets empty
	            if (recordList.remove(record)) {
	                this.map.delete(key);
	            }
	            return record;
	        };
	        Object.defineProperty(_DuplicateMap.prototype, "isEmpty", {
	            get: function () { return this.map.size === 0; },
	            enumerable: true,
	            configurable: true
	        });
	        _DuplicateMap.prototype.clear = function () { this.map.clear(); };
	        _DuplicateMap.prototype.toString = function () { return '_DuplicateMap(' + stringify(this.map) + ')'; };
	        return _DuplicateMap;
	    }());
	    function getPreviousIndex(item, addRemoveOffset, moveOffsets) {
	        var previousIndex = item.previousIndex;
	        if (previousIndex === null)
	            return previousIndex;
	        var moveOffset = 0;
	        if (moveOffsets && previousIndex < moveOffsets.length) {
	            moveOffset = moveOffsets[previousIndex];
	        }
	        return previousIndex + addRemoveOffset + moveOffset;
	    }

	    var DefaultKeyValueDifferFactory = (function () {
	        function DefaultKeyValueDifferFactory() {
	        }
	        DefaultKeyValueDifferFactory.prototype.supports = function (obj) { return obj instanceof Map || isJsObject(obj); };
	        DefaultKeyValueDifferFactory.prototype.create = function (cdRef) { return new DefaultKeyValueDiffer(); };
	        return DefaultKeyValueDifferFactory;
	    }());
	    var DefaultKeyValueDiffer = (function () {
	        function DefaultKeyValueDiffer() {
	            this._records = new Map();
	            this._mapHead = null;
	            this._previousMapHead = null;
	            this._changesHead = null;
	            this._changesTail = null;
	            this._additionsHead = null;
	            this._additionsTail = null;
	            this._removalsHead = null;
	            this._removalsTail = null;
	        }
	        Object.defineProperty(DefaultKeyValueDiffer.prototype, "isDirty", {
	            get: function () {
	                return this._additionsHead !== null || this._changesHead !== null ||
	                    this._removalsHead !== null;
	            },
	            enumerable: true,
	            configurable: true
	        });
	        DefaultKeyValueDiffer.prototype.forEachItem = function (fn) {
	            var record;
	            for (record = this._mapHead; record !== null; record = record._next) {
	                fn(record);
	            }
	        };
	        DefaultKeyValueDiffer.prototype.forEachPreviousItem = function (fn) {
	            var record;
	            for (record = this._previousMapHead; record !== null; record = record._nextPrevious) {
	                fn(record);
	            }
	        };
	        DefaultKeyValueDiffer.prototype.forEachChangedItem = function (fn) {
	            var record;
	            for (record = this._changesHead; record !== null; record = record._nextChanged) {
	                fn(record);
	            }
	        };
	        DefaultKeyValueDiffer.prototype.forEachAddedItem = function (fn) {
	            var record;
	            for (record = this._additionsHead; record !== null; record = record._nextAdded) {
	                fn(record);
	            }
	        };
	        DefaultKeyValueDiffer.prototype.forEachRemovedItem = function (fn) {
	            var record;
	            for (record = this._removalsHead; record !== null; record = record._nextRemoved) {
	                fn(record);
	            }
	        };
	        DefaultKeyValueDiffer.prototype.diff = function (map) {
	            if (!map) {
	                map = new Map();
	            }
	            else if (!(map instanceof Map || isJsObject(map))) {
	                throw new Error("Error trying to diff '" + map + "'");
	            }
	            return this.check(map) ? this : null;
	        };
	        DefaultKeyValueDiffer.prototype.onDestroy = function () { };
	        DefaultKeyValueDiffer.prototype.check = function (map) {
	            var _this = this;
	            this._reset();
	            var records = this._records;
	            var oldSeqRecord = this._mapHead;
	            var lastOldSeqRecord = null;
	            var lastNewSeqRecord = null;
	            var seqChanged = false;
	            this._forEach(map, function (value, key) {
	                var newSeqRecord;
	                if (oldSeqRecord && key === oldSeqRecord.key) {
	                    newSeqRecord = oldSeqRecord;
	                    _this._maybeAddToChanges(newSeqRecord, value);
	                }
	                else {
	                    seqChanged = true;
	                    if (oldSeqRecord !== null) {
	                        _this._removeFromSeq(lastOldSeqRecord, oldSeqRecord);
	                        _this._addToRemovals(oldSeqRecord);
	                    }
	                    if (records.has(key)) {
	                        newSeqRecord = records.get(key);
	                        _this._maybeAddToChanges(newSeqRecord, value);
	                    }
	                    else {
	                        newSeqRecord = new KeyValueChangeRecord(key);
	                        records.set(key, newSeqRecord);
	                        newSeqRecord.currentValue = value;
	                        _this._addToAdditions(newSeqRecord);
	                    }
	                }
	                if (seqChanged) {
	                    if (_this._isInRemovals(newSeqRecord)) {
	                        _this._removeFromRemovals(newSeqRecord);
	                    }
	                    if (lastNewSeqRecord == null) {
	                        _this._mapHead = newSeqRecord;
	                    }
	                    else {
	                        lastNewSeqRecord._next = newSeqRecord;
	                    }
	                }
	                lastOldSeqRecord = oldSeqRecord;
	                lastNewSeqRecord = newSeqRecord;
	                oldSeqRecord = oldSeqRecord && oldSeqRecord._next;
	            });
	            this._truncate(lastOldSeqRecord, oldSeqRecord);
	            return this.isDirty;
	        };
	        /** @internal */
	        DefaultKeyValueDiffer.prototype._reset = function () {
	            if (this.isDirty) {
	                var record = void 0;
	                // Record the state of the mapping
	                for (record = this._previousMapHead = this._mapHead; record !== null; record = record._next) {
	                    record._nextPrevious = record._next;
	                }
	                for (record = this._changesHead; record !== null; record = record._nextChanged) {
	                    record.previousValue = record.currentValue;
	                }
	                for (record = this._additionsHead; record != null; record = record._nextAdded) {
	                    record.previousValue = record.currentValue;
	                }
	                this._changesHead = this._changesTail = null;
	                this._additionsHead = this._additionsTail = null;
	                this._removalsHead = this._removalsTail = null;
	            }
	        };
	        /** @internal */
	        DefaultKeyValueDiffer.prototype._truncate = function (lastRecord, record) {
	            while (record !== null) {
	                if (lastRecord === null) {
	                    this._mapHead = null;
	                }
	                else {
	                    lastRecord._next = null;
	                }
	                var nextRecord = record._next;
	                this._addToRemovals(record);
	                lastRecord = record;
	                record = nextRecord;
	            }
	            for (var rec = this._removalsHead; rec !== null; rec = rec._nextRemoved) {
	                rec.previousValue = rec.currentValue;
	                rec.currentValue = null;
	                this._records.delete(rec.key);
	            }
	        };
	        DefaultKeyValueDiffer.prototype._maybeAddToChanges = function (record, newValue) {
	            if (!looseIdentical(newValue, record.currentValue)) {
	                record.previousValue = record.currentValue;
	                record.currentValue = newValue;
	                this._addToChanges(record);
	            }
	        };
	        /** @internal */
	        DefaultKeyValueDiffer.prototype._isInRemovals = function (record) {
	            return record === this._removalsHead || record._nextRemoved !== null ||
	                record._prevRemoved !== null;
	        };
	        /** @internal */
	        DefaultKeyValueDiffer.prototype._addToRemovals = function (record) {
	            if (this._removalsHead === null) {
	                this._removalsHead = this._removalsTail = record;
	            }
	            else {
	                this._removalsTail._nextRemoved = record;
	                record._prevRemoved = this._removalsTail;
	                this._removalsTail = record;
	            }
	        };
	        /** @internal */
	        DefaultKeyValueDiffer.prototype._removeFromSeq = function (prev, record) {
	            var next = record._next;
	            if (prev === null) {
	                this._mapHead = next;
	            }
	            else {
	                prev._next = next;
	            }
	            record._next = null;
	        };
	        /** @internal */
	        DefaultKeyValueDiffer.prototype._removeFromRemovals = function (record) {
	            var prev = record._prevRemoved;
	            var next = record._nextRemoved;
	            if (prev === null) {
	                this._removalsHead = next;
	            }
	            else {
	                prev._nextRemoved = next;
	            }
	            if (next === null) {
	                this._removalsTail = prev;
	            }
	            else {
	                next._prevRemoved = prev;
	            }
	            record._prevRemoved = record._nextRemoved = null;
	        };
	        /** @internal */
	        DefaultKeyValueDiffer.prototype._addToAdditions = function (record) {
	            if (this._additionsHead === null) {
	                this._additionsHead = this._additionsTail = record;
	            }
	            else {
	                this._additionsTail._nextAdded = record;
	                this._additionsTail = record;
	            }
	        };
	        /** @internal */
	        DefaultKeyValueDiffer.prototype._addToChanges = function (record) {
	            if (this._changesHead === null) {
	                this._changesHead = this._changesTail = record;
	            }
	            else {
	                this._changesTail._nextChanged = record;
	                this._changesTail = record;
	            }
	        };
	        DefaultKeyValueDiffer.prototype.toString = function () {
	            var items = [];
	            var previous = [];
	            var changes = [];
	            var additions = [];
	            var removals = [];
	            var record;
	            for (record = this._mapHead; record !== null; record = record._next) {
	                items.push(stringify(record));
	            }
	            for (record = this._previousMapHead; record !== null; record = record._nextPrevious) {
	                previous.push(stringify(record));
	            }
	            for (record = this._changesHead; record !== null; record = record._nextChanged) {
	                changes.push(stringify(record));
	            }
	            for (record = this._additionsHead; record !== null; record = record._nextAdded) {
	                additions.push(stringify(record));
	            }
	            for (record = this._removalsHead; record !== null; record = record._nextRemoved) {
	                removals.push(stringify(record));
	            }
	            return 'map: ' + items.join(', ') + '\n' +
	                'previous: ' + previous.join(', ') + '\n' +
	                'additions: ' + additions.join(', ') + '\n' +
	                'changes: ' + changes.join(', ') + '\n' +
	                'removals: ' + removals.join(', ') + '\n';
	        };
	        /** @internal */
	        DefaultKeyValueDiffer.prototype._forEach = function (obj, fn) {
	            if (obj instanceof Map) {
	                obj.forEach(fn);
	            }
	            else {
	                Object.keys(obj).forEach(function (k) { return fn(obj[k], k); });
	            }
	        };
	        return DefaultKeyValueDiffer;
	    }());
	    /**
	     * @stable
	     */
	    var KeyValueChangeRecord = (function () {
	        function KeyValueChangeRecord(key) {
	            this.key = key;
	            this.previousValue = null;
	            this.currentValue = null;
	            /** @internal */
	            this._nextPrevious = null;
	            /** @internal */
	            this._next = null;
	            /** @internal */
	            this._nextAdded = null;
	            /** @internal */
	            this._nextRemoved = null;
	            /** @internal */
	            this._prevRemoved = null;
	            /** @internal */
	            this._nextChanged = null;
	        }
	        KeyValueChangeRecord.prototype.toString = function () {
	            return looseIdentical(this.previousValue, this.currentValue) ?
	                stringify(this.key) :
	                (stringify(this.key) + '[' + stringify(this.previousValue) + '->' +
	                    stringify(this.currentValue) + ']');
	        };
	        return KeyValueChangeRecord;
	    }());

	    /**
	     * A repository of different iterable diffing strategies used by NgFor, NgClass, and others.
	     * @stable
	     */
	    var IterableDiffers = (function () {
	        function IterableDiffers(factories) {
	            this.factories = factories;
	        }
	        IterableDiffers.create = function (factories, parent) {
	            if (isPresent(parent)) {
	                var copied = parent.factories.slice();
	                factories = factories.concat(copied);
	                return new IterableDiffers(factories);
	            }
	            else {
	                return new IterableDiffers(factories);
	            }
	        };
	        /**
	         * Takes an array of {@link IterableDifferFactory} and returns a provider used to extend the
	         * inherited {@link IterableDiffers} instance with the provided factories and return a new
	         * {@link IterableDiffers} instance.
	         *
	         * The following example shows how to extend an existing list of factories,
	               * which will only be applied to the injector for this component and its children.
	               * This step is all that's required to make a new {@link IterableDiffer} available.
	         *
	         * ### Example
	         *
	         * ```
	         * @Component({
	         *   viewProviders: [
	         *     IterableDiffers.extend([new ImmutableListDiffer()])
	         *   ]
	         * })
	         * ```
	         */
	        IterableDiffers.extend = function (factories) {
	            return {
	                provide: IterableDiffers,
	                useFactory: function (parent) {
	                    if (!parent) {
	                        // Typically would occur when calling IterableDiffers.extend inside of dependencies passed
	                        // to
	                        // bootstrap(), which would override default pipes instead of extending them.
	                        throw new Error('Cannot extend IterableDiffers without a parent injector');
	                    }
	                    return IterableDiffers.create(factories, parent);
	                },
	                // Dependency technically isn't optional, but we can provide a better error message this way.
	                deps: [[IterableDiffers, new SkipSelf(), new Optional()]]
	            };
	        };
	        IterableDiffers.prototype.find = function (iterable) {
	            var factory = this.factories.find(function (f) { return f.supports(iterable); });
	            if (isPresent(factory)) {
	                return factory;
	            }
	            else {
	                throw new Error("Cannot find a differ supporting object '" + iterable + "' of type '" + getTypeNameForDebugging(iterable) + "'");
	            }
	        };
	        return IterableDiffers;
	    }());

	    /**
	     * A repository of different Map diffing strategies used by NgClass, NgStyle, and others.
	     * @stable
	     */
	    var KeyValueDiffers = (function () {
	        function KeyValueDiffers(factories) {
	            this.factories = factories;
	        }
	        KeyValueDiffers.create = function (factories, parent) {
	            if (isPresent(parent)) {
	                var copied = parent.factories.slice();
	                factories = factories.concat(copied);
	                return new KeyValueDiffers(factories);
	            }
	            else {
	                return new KeyValueDiffers(factories);
	            }
	        };
	        /**
	         * Takes an array of {@link KeyValueDifferFactory} and returns a provider used to extend the
	         * inherited {@link KeyValueDiffers} instance with the provided factories and return a new
	         * {@link KeyValueDiffers} instance.
	         *
	         * The following example shows how to extend an existing list of factories,
	               * which will only be applied to the injector for this component and its children.
	               * This step is all that's required to make a new {@link KeyValueDiffer} available.
	         *
	         * ### Example
	         *
	         * ```
	         * @Component({
	         *   viewProviders: [
	         *     KeyValueDiffers.extend([new ImmutableMapDiffer()])
	         *   ]
	         * })
	         * ```
	         */
	        KeyValueDiffers.extend = function (factories) {
	            return {
	                provide: KeyValueDiffers,
	                useFactory: function (parent) {
	                    if (!parent) {
	                        // Typically would occur when calling KeyValueDiffers.extend inside of dependencies passed
	                        // to
	                        // bootstrap(), which would override default pipes instead of extending them.
	                        throw new Error('Cannot extend KeyValueDiffers without a parent injector');
	                    }
	                    return KeyValueDiffers.create(factories, parent);
	                },
	                // Dependency technically isn't optional, but we can provide a better error message this way.
	                deps: [[KeyValueDiffers, new SkipSelf(), new Optional()]]
	            };
	        };
	        KeyValueDiffers.prototype.find = function (kv) {
	            var factory = this.factories.find(function (f) { return f.supports(kv); });
	            if (isPresent(factory)) {
	                return factory;
	            }
	            else {
	                throw new Error("Cannot find a differ supporting object '" + kv + "'");
	            }
	        };
	        return KeyValueDiffers;
	    }());

	    var UNINITIALIZED = {
	        toString: function () { return 'CD_INIT_VALUE'; }
	    };
	    function devModeEqual(a, b) {
	        if (isListLikeIterable(a) && isListLikeIterable(b)) {
	            return areIterablesEqual(a, b, devModeEqual);
	        }
	        else if (!isListLikeIterable(a) && !isPrimitive(a) && !isListLikeIterable(b) && !isPrimitive(b)) {
	            return true;
	        }
	        else {
	            return looseIdentical(a, b);
	        }
	    }
	    /**
	     * Indicates that the result of a {@link Pipe} transformation has changed even though the
	     * reference
	     * has not changed.
	     *
	     * The wrapped value will be unwrapped by change detection, and the unwrapped value will be stored.
	     *
	     * Example:
	     *
	     * ```
	     * if (this._latestValue === this._latestReturnedValue) {
	     *    return this._latestReturnedValue;
	     *  } else {
	     *    this._latestReturnedValue = this._latestValue;
	     *    return WrappedValue.wrap(this._latestValue); // this will force update
	     *  }
	     * ```
	     * @stable
	     */
	    var WrappedValue = (function () {
	        function WrappedValue(wrapped) {
	            this.wrapped = wrapped;
	        }
	        WrappedValue.wrap = function (value) { return new WrappedValue(value); };
	        return WrappedValue;
	    }());
	    /**
	     * Helper class for unwrapping WrappedValue s
	     */
	    var ValueUnwrapper = (function () {
	        function ValueUnwrapper() {
	            this.hasWrappedValue = false;
	        }
	        ValueUnwrapper.prototype.unwrap = function (value) {
	            if (value instanceof WrappedValue) {
	                this.hasWrappedValue = true;
	                return value.wrapped;
	            }
	            return value;
	        };
	        ValueUnwrapper.prototype.reset = function () { this.hasWrappedValue = false; };
	        return ValueUnwrapper;
	    }());
	    /**
	     * Represents a basic change from a previous to a new value.
	     * @stable
	     */
	    var SimpleChange = (function () {
	        function SimpleChange(previousValue, currentValue) {
	            this.previousValue = previousValue;
	            this.currentValue = currentValue;
	        }
	        /**
	         * Check whether the new value is the first value assigned.
	         */
	        SimpleChange.prototype.isFirstChange = function () { return this.previousValue === UNINITIALIZED; };
	        return SimpleChange;
	    }());

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    /**
	     * @stable
	     */
	    var ChangeDetectorRef = (function () {
	        function ChangeDetectorRef() {
	        }
	        return ChangeDetectorRef;
	    }());

	    /**
	     * Structural diffing for `Object`s and `Map`s.
	     */
	    var keyValDiff = [new DefaultKeyValueDifferFactory()];
	    /**
	     * Structural diffing for `Iterable` types such as `Array`s.
	     */
	    var iterableDiff = [new DefaultIterableDifferFactory()];
	    var defaultIterableDiffers = new IterableDiffers(iterableDiff);
	    var defaultKeyValueDiffers = new KeyValueDiffers(keyValDiff);

	    /**
	     * @experimental
	     */
	    // TODO (matsko): add typing for the animation function
	    var RenderComponentType = (function () {
	        function RenderComponentType(id, templateUrl, slotCount, encapsulation, styles, animations) {
	            this.id = id;
	            this.templateUrl = templateUrl;
	            this.slotCount = slotCount;
	            this.encapsulation = encapsulation;
	            this.styles = styles;
	            this.animations = animations;
	        }
	        return RenderComponentType;
	    }());
	    var RenderDebugInfo = (function () {
	        function RenderDebugInfo() {
	        }
	        Object.defineProperty(RenderDebugInfo.prototype, "injector", {
	            get: function () { return unimplemented(); },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(RenderDebugInfo.prototype, "component", {
	            get: function () { return unimplemented(); },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(RenderDebugInfo.prototype, "providerTokens", {
	            get: function () { return unimplemented(); },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(RenderDebugInfo.prototype, "references", {
	            get: function () { return unimplemented(); },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(RenderDebugInfo.prototype, "context", {
	            get: function () { return unimplemented(); },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(RenderDebugInfo.prototype, "source", {
	            get: function () { return unimplemented(); },
	            enumerable: true,
	            configurable: true
	        });
	        return RenderDebugInfo;
	    }());
	    /**
	     * @experimental
	     */
	    var Renderer = (function () {
	        function Renderer() {
	        }
	        return Renderer;
	    }());
	    /**
	     * Injectable service that provides a low-level interface for modifying the UI.
	     *
	     * Use this service to bypass Angular's templating and make custom UI changes that can't be
	     * expressed declaratively. For example if you need to set a property or an attribute whose name is
	     * not statically known, use {@link #setElementProperty} or {@link #setElementAttribute}
	     * respectively.
	     *
	     * If you are implementing a custom renderer, you must implement this interface.
	     *
	     * The default Renderer implementation is `DomRenderer`. Also available is `WebWorkerRenderer`.
	     * @experimental
	     */
	    var RootRenderer = (function () {
	        function RootRenderer() {
	        }
	        return RootRenderer;
	    }());

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    /**
	     * A SecurityContext marks a location that has dangerous security implications, e.g. a DOM property
	     * like `innerHTML` that could cause Cross Site Scripting (XSS) security bugs when improperly
	     * handled.
	     *
	     * See DomSanitizer for more details on security in Angular applications.
	     *
	     * @stable
	     */
	    exports.SecurityContext;
	    (function (SecurityContext) {
	        SecurityContext[SecurityContext["NONE"] = 0] = "NONE";
	        SecurityContext[SecurityContext["HTML"] = 1] = "HTML";
	        SecurityContext[SecurityContext["STYLE"] = 2] = "STYLE";
	        SecurityContext[SecurityContext["SCRIPT"] = 3] = "SCRIPT";
	        SecurityContext[SecurityContext["URL"] = 4] = "URL";
	        SecurityContext[SecurityContext["RESOURCE_URL"] = 5] = "RESOURCE_URL";
	    })(exports.SecurityContext || (exports.SecurityContext = {}));
	    /**
	     * Sanitizer is used by the views to sanitize potentially dangerous values.
	     *
	     * @stable
	     */
	    var Sanitizer = (function () {
	        function Sanitizer() {
	        }
	        return Sanitizer;
	    }());

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    /**
	     * A wrapper around a native element inside of a View.
	     *
	     * An `ElementRef` is backed by a render-specific element. In the browser, this is usually a DOM
	     * element.
	     *
	     * @security Permitting direct access to the DOM can make your application more vulnerable to
	     * XSS attacks. Carefully review any use of `ElementRef` in your code. For more detail, see the
	     * [Security Guide](http://g.co/ng/security).
	     *
	     * @stable
	     */
	    // Note: We don't expose things like `Injector`, `ViewContainer`, ... here,
	    // i.e. users have to ask for what they need. With that, we can build better analysis tools
	    // and could do better codegen in the future.
	    var ElementRef = (function () {
	        function ElementRef(nativeElement) {
	            this.nativeElement = nativeElement;
	        }
	        return ElementRef;
	    }());

	    var trace;
	    var events;
	    function detectWTF() {
	        var wtf = global$1['wtf'];
	        if (wtf) {
	            trace = wtf['trace'];
	            if (trace) {
	                events = trace['events'];
	                return true;
	            }
	        }
	        return false;
	    }
	    function createScope(signature, flags) {
	        if (flags === void 0) { flags = null; }
	        return events.createScope(signature, flags);
	    }
	    function leave(scope, returnValue) {
	        trace.leaveScope(scope, returnValue);
	        return returnValue;
	    }
	    function startTimeRange(rangeType, action) {
	        return trace.beginTimeRange(rangeType, action);
	    }
	    function endTimeRange(range) {
	        trace.endTimeRange(range);
	    }

	    /**
	     * True if WTF is enabled.
	     */
	    var wtfEnabled = detectWTF();
	    function noopScope(arg0, arg1) {
	        return null;
	    }
	    /**
	     * Create trace scope.
	     *
	     * Scopes must be strictly nested and are analogous to stack frames, but
	     * do not have to follow the stack frames. Instead it is recommended that they follow logical
	     * nesting. You may want to use
	     * [Event
	     * Signatures](http://google.github.io/tracing-framework/instrumenting-code.html#custom-events)
	     * as they are defined in WTF.
	     *
	     * Used to mark scope entry. The return value is used to leave the scope.
	     *
	     *     var myScope = wtfCreateScope('MyClass#myMethod(ascii someVal)');
	     *
	     *     someMethod() {
	     *        var s = myScope('Foo'); // 'Foo' gets stored in tracing UI
	     *        // DO SOME WORK HERE
	     *        return wtfLeave(s, 123); // Return value 123
	     *     }
	     *
	     * Note, adding try-finally block around the work to ensure that `wtfLeave` gets called can
	     * negatively impact the performance of your application. For this reason we recommend that
	     * you don't add them to ensure that `wtfLeave` gets called. In production `wtfLeave` is a noop and
	     * so try-finally block has no value. When debugging perf issues, skipping `wtfLeave`, do to
	     * exception, will produce incorrect trace, but presence of exception signifies logic error which
	     * needs to be fixed before the app should be profiled. Add try-finally only when you expect that
	     * an exception is expected during normal execution while profiling.
	     *
	     * @experimental
	     */
	    var wtfCreateScope = wtfEnabled ? createScope : function (signature, flags) { return noopScope; };
	    /**
	     * Used to mark end of Scope.
	     *
	     * - `scope` to end.
	     * - `returnValue` (optional) to be passed to the WTF.
	     *
	     * Returns the `returnValue for easy chaining.
	     * @experimental
	     */
	    var wtfLeave = wtfEnabled ? leave : function (s, r) { return r; };
	    /**
	     * Used to mark Async start. Async are similar to scope but they don't have to be strictly nested.
	     * The return value is used in the call to [endAsync]. Async ranges only work if WTF has been
	     * enabled.
	     *
	     *     someMethod() {
	     *        var s = wtfStartTimeRange('HTTP:GET', 'some.url');
	     *        var future = new Future.delay(5).then((_) {
	     *          wtfEndTimeRange(s);
	     *        });
	     *     }
	     * @experimental
	     */
	    var wtfStartTimeRange = wtfEnabled ? startTimeRange : function (rangeType, action) { return null; };
	    /**
	     * Ends a async time range operation.
	     * [range] is the return value from [wtfStartTimeRange] Async ranges only work if WTF has been
	     * enabled.
	     * @experimental
	     */
	    var wtfEndTimeRange = wtfEnabled ? endTimeRange : function (r) { return null; };

	    /**
	     * Represents a container where one or more Views can be attached.
	     *
	     * The container can contain two kinds of Views. Host Views, created by instantiating a
	     * {@link Component} via {@link #createComponent}, and Embedded Views, created by instantiating an
	     * {@link TemplateRef Embedded Template} via {@link #createEmbeddedView}.
	     *
	     * The location of the View Container within the containing View is specified by the Anchor
	     * `element`. Each View Container can have only one Anchor Element and each Anchor Element can only
	     * have a single View Container.
	     *
	     * Root elements of Views attached to this container become siblings of the Anchor Element in
	     * the Rendered View.
	     *
	     * To access a `ViewContainerRef` of an Element, you can either place a {@link Directive} injected
	     * with `ViewContainerRef` on the Element, or you obtain it via a {@link ViewChild} query.
	     * @stable
	     */
	    var ViewContainerRef = (function () {
	        function ViewContainerRef() {
	        }
	        Object.defineProperty(ViewContainerRef.prototype, "element", {
	            /**
	             * Anchor element that specifies the location of this container in the containing View.
	             * <!-- TODO: rename to anchorElement -->
	             */
	            get: function () { return unimplemented(); },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(ViewContainerRef.prototype, "injector", {
	            get: function () { return unimplemented(); },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(ViewContainerRef.prototype, "parentInjector", {
	            get: function () { return unimplemented(); },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(ViewContainerRef.prototype, "length", {
	            /**
	             * Returns the number of Views currently attached to this container.
	             */
	            get: function () { return unimplemented(); },
	            enumerable: true,
	            configurable: true
	        });
	        ;
	        return ViewContainerRef;
	    }());
	    var ViewContainerRef_ = (function () {
	        function ViewContainerRef_(_element) {
	            this._element = _element;
	            /** @internal */
	            this._createComponentInContainerScope = wtfCreateScope('ViewContainerRef#createComponent()');
	            /** @internal */
	            this._insertScope = wtfCreateScope('ViewContainerRef#insert()');
	            /** @internal */
	            this._removeScope = wtfCreateScope('ViewContainerRef#remove()');
	            /** @internal */
	            this._detachScope = wtfCreateScope('ViewContainerRef#detach()');
	        }
	        ViewContainerRef_.prototype.get = function (index) { return this._element.nestedViews[index].ref; };
	        Object.defineProperty(ViewContainerRef_.prototype, "length", {
	            get: function () {
	                var views = this._element.nestedViews;
	                return isPresent(views) ? views.length : 0;
	            },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(ViewContainerRef_.prototype, "element", {
	            get: function () { return this._element.elementRef; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(ViewContainerRef_.prototype, "injector", {
	            get: function () { return this._element.injector; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(ViewContainerRef_.prototype, "parentInjector", {
	            get: function () { return this._element.parentInjector; },
	            enumerable: true,
	            configurable: true
	        });
	        // TODO(rado): profile and decide whether bounds checks should be added
	        // to the methods below.
	        ViewContainerRef_.prototype.createEmbeddedView = function (templateRef, context, index) {
	            if (context === void 0) { context = null; }
	            if (index === void 0) { index = -1; }
	            var viewRef = templateRef.createEmbeddedView(context);
	            this.insert(viewRef, index);
	            return viewRef;
	        };
	        ViewContainerRef_.prototype.createComponent = function (componentFactory, index, injector, projectableNodes) {
	            if (index === void 0) { index = -1; }
	            if (injector === void 0) { injector = null; }
	            if (projectableNodes === void 0) { projectableNodes = null; }
	            var s = this._createComponentInContainerScope();
	            var contextInjector = injector || this._element.parentInjector;
	            var componentRef = componentFactory.create(contextInjector, projectableNodes);
	            this.insert(componentRef.hostView, index);
	            return wtfLeave(s, componentRef);
	        };
	        // TODO(i): refactor insert+remove into move
	        ViewContainerRef_.prototype.insert = function (viewRef, index) {
	            if (index === void 0) { index = -1; }
	            var s = this._insertScope();
	            if (index == -1)
	                index = this.length;
	            var viewRef_ = viewRef;
	            this._element.attachView(viewRef_.internalView, index);
	            return wtfLeave(s, viewRef_);
	        };
	        ViewContainerRef_.prototype.move = function (viewRef, currentIndex) {
	            var s = this._insertScope();
	            if (currentIndex == -1)
	                return;
	            var viewRef_ = viewRef;
	            this._element.moveView(viewRef_.internalView, currentIndex);
	            return wtfLeave(s, viewRef_);
	        };
	        ViewContainerRef_.prototype.indexOf = function (viewRef) {
	            return this._element.nestedViews.indexOf(viewRef.internalView);
	        };
	        // TODO(i): rename to destroy
	        ViewContainerRef_.prototype.remove = function (index) {
	            if (index === void 0) { index = -1; }
	            var s = this._removeScope();
	            if (index == -1)
	                index = this.length - 1;
	            var view = this._element.detachView(index);
	            view.destroy();
	            // view is intentionally not returned to the client.
	            wtfLeave(s);
	        };
	        // TODO(i): refactor insert+remove into move
	        ViewContainerRef_.prototype.detach = function (index) {
	            if (index === void 0) { index = -1; }
	            var s = this._detachScope();
	            if (index == -1)
	                index = this.length - 1;
	            var view = this._element.detachView(index);
	            return wtfLeave(s, view.ref);
	        };
	        ViewContainerRef_.prototype.clear = function () {
	            for (var i = this.length - 1; i >= 0; i--) {
	                this.remove(i);
	            }
	        };
	        return ViewContainerRef_;
	    }());

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var ViewType;
	    (function (ViewType) {
	        // A view that contains the host element with bound component directive.
	        // Contains a COMPONENT view
	        ViewType[ViewType["HOST"] = 0] = "HOST";
	        // The view of the component
	        // Can contain 0 to n EMBEDDED views
	        ViewType[ViewType["COMPONENT"] = 1] = "COMPONENT";
	        // A view that is embedded into another View via a <template> element
	        // inside of a COMPONENT view
	        ViewType[ViewType["EMBEDDED"] = 2] = "EMBEDDED";
	    })(ViewType || (ViewType = {}));

	    /**
	     * An AppElement is created for elements that have a ViewContainerRef,
	     * a nested component or a <template> element to keep data around
	     * that is needed for later instantiations.
	     */
	    var AppElement = (function () {
	        function AppElement(index, parentIndex, parentView, nativeElement) {
	            this.index = index;
	            this.parentIndex = parentIndex;
	            this.parentView = parentView;
	            this.nativeElement = nativeElement;
	            this.nestedViews = null;
	            this.componentView = null;
	        }
	        Object.defineProperty(AppElement.prototype, "elementRef", {
	            get: function () { return new ElementRef(this.nativeElement); },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AppElement.prototype, "vcRef", {
	            get: function () { return new ViewContainerRef_(this); },
	            enumerable: true,
	            configurable: true
	        });
	        AppElement.prototype.initComponent = function (component, componentConstructorViewQueries, view) {
	            this.component = component;
	            this.componentConstructorViewQueries = componentConstructorViewQueries;
	            this.componentView = view;
	        };
	        Object.defineProperty(AppElement.prototype, "parentInjector", {
	            get: function () { return this.parentView.injector(this.parentIndex); },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AppElement.prototype, "injector", {
	            get: function () { return this.parentView.injector(this.index); },
	            enumerable: true,
	            configurable: true
	        });
	        AppElement.prototype.mapNestedViews = function (nestedViewClass, callback) {
	            var result = [];
	            if (isPresent(this.nestedViews)) {
	                this.nestedViews.forEach(function (nestedView) {
	                    if (nestedView.clazz === nestedViewClass) {
	                        result.push(callback(nestedView));
	                    }
	                });
	            }
	            return result;
	        };
	        AppElement.prototype.moveView = function (view, currentIndex) {
	            var previousIndex = this.nestedViews.indexOf(view);
	            if (view.type === ViewType.COMPONENT) {
	                throw new Error("Component views can't be moved!");
	            }
	            var nestedViews = this.nestedViews;
	            if (nestedViews == null) {
	                nestedViews = [];
	                this.nestedViews = nestedViews;
	            }
	            nestedViews.splice(previousIndex, 1);
	            nestedViews.splice(currentIndex, 0, view);
	            var refRenderNode;
	            if (currentIndex > 0) {
	                var prevView = nestedViews[currentIndex - 1];
	                refRenderNode = prevView.lastRootNode;
	            }
	            else {
	                refRenderNode = this.nativeElement;
	            }
	            if (isPresent(refRenderNode)) {
	                view.renderer.attachViewAfter(refRenderNode, view.flatRootNodes);
	            }
	            view.markContentChildAsMoved(this);
	        };
	        AppElement.prototype.attachView = function (view, viewIndex) {
	            if (view.type === ViewType.COMPONENT) {
	                throw new Error("Component views can't be moved!");
	            }
	            var nestedViews = this.nestedViews;
	            if (nestedViews == null) {
	                nestedViews = [];
	                this.nestedViews = nestedViews;
	            }
	            nestedViews.splice(viewIndex, 0, view);
	            var refRenderNode;
	            if (viewIndex > 0) {
	                var prevView = nestedViews[viewIndex - 1];
	                refRenderNode = prevView.lastRootNode;
	            }
	            else {
	                refRenderNode = this.nativeElement;
	            }
	            if (isPresent(refRenderNode)) {
	                view.renderer.attachViewAfter(refRenderNode, view.flatRootNodes);
	            }
	            view.addToContentChildren(this);
	        };
	        AppElement.prototype.detachView = function (viewIndex) {
	            var view = this.nestedViews.splice(viewIndex, 1)[0];
	            if (view.type === ViewType.COMPONENT) {
	                throw new Error("Component views can't be moved!");
	            }
	            view.detach();
	            view.removeFromContentChildren(this);
	            return view;
	        };
	        return AppElement;
	    }());

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$6 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    /**
	     * An error thrown if application changes model breaking the top-down data flow.
	     *
	     * This exception is only thrown in dev mode.
	     *
	     * <!-- TODO: Add a link once the dev mode option is configurable -->
	     *
	     * ### Example
	     *
	     * ```typescript
	     * @Component({
	     *   selector: 'parent',
	     *   template: '<child [prop]="parentProp"></child>',
	     * })
	     * class Parent {
	     *   parentProp = 'init';
	     * }
	     *
	     * @Directive({selector: 'child', inputs: ['prop']})
	     * class Child {
	     *   constructor(public parent: Parent) {}
	     *
	     *   set prop(v) {
	     *     // this updates the parent property, which is disallowed during change detection
	     *     // this will result in ExpressionChangedAfterItHasBeenCheckedError
	     *     this.parent.parentProp = 'updated';
	     *   }
	     * }
	     * ```
	     * @stable
	     */
	    var ExpressionChangedAfterItHasBeenCheckedError = (function (_super) {
	        __extends$6(ExpressionChangedAfterItHasBeenCheckedError, _super);
	        function ExpressionChangedAfterItHasBeenCheckedError(oldValue, currValue) {
	            var msg = "Expression has changed after it was checked. Previous value: '" + oldValue + "'. Current value: '" + currValue + "'.";
	            if (oldValue === UNINITIALIZED) {
	                msg +=
	                    " It seems like the view has been created after its parent and its children have been dirty checked." +
	                        " Has it been created in a change detection hook ?";
	            }
	            _super.call(this, msg);
	        }
	        return ExpressionChangedAfterItHasBeenCheckedError;
	    }(BaseError));
	    /**
	     * Thrown when an exception was raised during view creation, change detection or destruction.
	     *
	     * This error wraps the original exception to attach additional contextual information that can
	     * be useful for debugging.
	     * @stable
	     */
	    var ViewWrappedError = (function (_super) {
	        __extends$6(ViewWrappedError, _super);
	        function ViewWrappedError(originalError, context) {
	            _super.call(this, "Error in " + context.source, originalError);
	            this.context = context;
	        }
	        return ViewWrappedError;
	    }(WrappedError));
	    /**
	     * Thrown when a destroyed view is used.
	     *
	     * This error indicates a bug in the framework.
	     *
	     * This is an internal Angular error.
	     * @stable
	     */
	    var ViewDestroyedError = (function (_super) {
	        __extends$6(ViewDestroyedError, _super);
	        function ViewDestroyedError(details) {
	            _super.call(this, "Attempt to use a destroyed view: " + details);
	        }
	        return ViewDestroyedError;
	    }(BaseError));

	    var ViewUtils = (function () {
	        function ViewUtils(_renderer, _appId, sanitizer) {
	            this._renderer = _renderer;
	            this._appId = _appId;
	            this._nextCompTypeId = 0;
	            this.sanitizer = sanitizer;
	        }
	        /**
	         * Used by the generated code
	         */
	        // TODO (matsko): add typing for the animation function
	        ViewUtils.prototype.createRenderComponentType = function (templateUrl, slotCount, encapsulation, styles, animations) {
	            return new RenderComponentType(this._appId + "-" + this._nextCompTypeId++, templateUrl, slotCount, encapsulation, styles, animations);
	        };
	        /** @internal */
	        ViewUtils.prototype.renderComponent = function (renderComponentType) {
	            return this._renderer.renderComponent(renderComponentType);
	        };
	        ViewUtils.decorators = [
	            { type: Injectable },
	        ];
	        /** @nocollapse */
	        ViewUtils.ctorParameters = [
	            { type: RootRenderer, },
	            { type: undefined, decorators: [{ type: Inject, args: [APP_ID,] },] },
	            { type: Sanitizer, },
	        ];
	        return ViewUtils;
	    }());
	    function flattenNestedViewRenderNodes(nodes) {
	        return _flattenNestedViewRenderNodes(nodes, []);
	    }
	    function _flattenNestedViewRenderNodes(nodes, renderNodes) {
	        for (var i = 0; i < nodes.length; i++) {
	            var node = nodes[i];
	            if (node instanceof AppElement) {
	                var appEl = node;
	                renderNodes.push(appEl.nativeElement);
	                if (isPresent(appEl.nestedViews)) {
	                    for (var k = 0; k < appEl.nestedViews.length; k++) {
	                        _flattenNestedViewRenderNodes(appEl.nestedViews[k].rootNodesOrAppElements, renderNodes);
	                    }
	                }
	            }
	            else {
	                renderNodes.push(node);
	            }
	        }
	        return renderNodes;
	    }
	    var EMPTY_ARR = [];
	    function ensureSlotCount(projectableNodes, expectedSlotCount) {
	        var res;
	        if (!projectableNodes) {
	            res = EMPTY_ARR;
	        }
	        else if (projectableNodes.length < expectedSlotCount) {
	            var givenSlotCount = projectableNodes.length;
	            res = new Array(expectedSlotCount);
	            for (var i = 0; i < expectedSlotCount; i++) {
	                res[i] = (i < givenSlotCount) ? projectableNodes[i] : EMPTY_ARR;
	            }
	        }
	        else {
	            res = projectableNodes;
	        }
	        return res;
	    }
	    var MAX_INTERPOLATION_VALUES = 9;
	    function interpolate(valueCount, c0, a1, c1, a2, c2, a3, c3, a4, c4, a5, c5, a6, c6, a7, c7, a8, c8, a9, c9) {
	        switch (valueCount) {
	            case 1:
	                return c0 + _toStringWithNull(a1) + c1;
	            case 2:
	                return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2;
	            case 3:
	                return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +
	                    c3;
	            case 4:
	                return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +
	                    c3 + _toStringWithNull(a4) + c4;
	            case 5:
	                return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +
	                    c3 + _toStringWithNull(a4) + c4 + _toStringWithNull(a5) + c5;
	            case 6:
	                return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +
	                    c3 + _toStringWithNull(a4) + c4 + _toStringWithNull(a5) + c5 + _toStringWithNull(a6) + c6;
	            case 7:
	                return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +
	                    c3 + _toStringWithNull(a4) + c4 + _toStringWithNull(a5) + c5 + _toStringWithNull(a6) +
	                    c6 + _toStringWithNull(a7) + c7;
	            case 8:
	                return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +
	                    c3 + _toStringWithNull(a4) + c4 + _toStringWithNull(a5) + c5 + _toStringWithNull(a6) +
	                    c6 + _toStringWithNull(a7) + c7 + _toStringWithNull(a8) + c8;
	            case 9:
	                return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +
	                    c3 + _toStringWithNull(a4) + c4 + _toStringWithNull(a5) + c5 + _toStringWithNull(a6) +
	                    c6 + _toStringWithNull(a7) + c7 + _toStringWithNull(a8) + c8 + _toStringWithNull(a9) + c9;
	            default:
	                throw new Error("Does not support more than 9 expressions");
	        }
	    }
	    function _toStringWithNull(v) {
	        return v != null ? v.toString() : '';
	    }
	    function checkBinding(throwOnChange, oldValue, newValue) {
	        if (throwOnChange) {
	            if (!devModeEqual(oldValue, newValue)) {
	                throw new ExpressionChangedAfterItHasBeenCheckedError(oldValue, newValue);
	            }
	            return false;
	        }
	        else {
	            return !looseIdentical(oldValue, newValue);
	        }
	    }
	    function castByValue(input, value) {
	        return input;
	    }
	    var EMPTY_ARRAY = [];
	    var EMPTY_MAP = {};
	    function pureProxy1(fn) {
	        var result;
	        var v0 = UNINITIALIZED;
	        return function (p0) {
	            if (!looseIdentical(v0, p0)) {
	                v0 = p0;
	                result = fn(p0);
	            }
	            return result;
	        };
	    }
	    function pureProxy2(fn) {
	        var result;
	        var v0 = UNINITIALIZED;
	        var v1 = UNINITIALIZED;
	        return function (p0, p1) {
	            if (!looseIdentical(v0, p0) || !looseIdentical(v1, p1)) {
	                v0 = p0;
	                v1 = p1;
	                result = fn(p0, p1);
	            }
	            return result;
	        };
	    }
	    function pureProxy3(fn) {
	        var result;
	        var v0 = UNINITIALIZED;
	        var v1 = UNINITIALIZED;
	        var v2 = UNINITIALIZED;
	        return function (p0, p1, p2) {
	            if (!looseIdentical(v0, p0) || !looseIdentical(v1, p1) || !looseIdentical(v2, p2)) {
	                v0 = p0;
	                v1 = p1;
	                v2 = p2;
	                result = fn(p0, p1, p2);
	            }
	            return result;
	        };
	    }
	    function pureProxy4(fn) {
	        var result;
	        var v0, v1, v2, v3;
	        v0 = v1 = v2 = v3 = UNINITIALIZED;
	        return function (p0, p1, p2, p3) {
	            if (!looseIdentical(v0, p0) || !looseIdentical(v1, p1) || !looseIdentical(v2, p2) ||
	                !looseIdentical(v3, p3)) {
	                v0 = p0;
	                v1 = p1;
	                v2 = p2;
	                v3 = p3;
	                result = fn(p0, p1, p2, p3);
	            }
	            return result;
	        };
	    }
	    function pureProxy5(fn) {
	        var result;
	        var v0, v1, v2, v3, v4;
	        v0 = v1 = v2 = v3 = v4 = UNINITIALIZED;
	        return function (p0, p1, p2, p3, p4) {
	            if (!looseIdentical(v0, p0) || !looseIdentical(v1, p1) || !looseIdentical(v2, p2) ||
	                !looseIdentical(v3, p3) || !looseIdentical(v4, p4)) {
	                v0 = p0;
	                v1 = p1;
	                v2 = p2;
	                v3 = p3;
	                v4 = p4;
	                result = fn(p0, p1, p2, p3, p4);
	            }
	            return result;
	        };
	    }
	    function pureProxy6(fn) {
	        var result;
	        var v0, v1, v2, v3, v4, v5;
	        v0 = v1 = v2 = v3 = v4 = v5 = UNINITIALIZED;
	        return function (p0, p1, p2, p3, p4, p5) {
	            if (!looseIdentical(v0, p0) || !looseIdentical(v1, p1) || !looseIdentical(v2, p2) ||
	                !looseIdentical(v3, p3) || !looseIdentical(v4, p4) || !looseIdentical(v5, p5)) {
	                v0 = p0;
	                v1 = p1;
	                v2 = p2;
	                v3 = p3;
	                v4 = p4;
	                v5 = p5;
	                result = fn(p0, p1, p2, p3, p4, p5);
	            }
	            return result;
	        };
	    }
	    function pureProxy7(fn) {
	        var result;
	        var v0, v1, v2, v3, v4, v5, v6;
	        v0 = v1 = v2 = v3 = v4 = v5 = v6 = UNINITIALIZED;
	        return function (p0, p1, p2, p3, p4, p5, p6) {
	            if (!looseIdentical(v0, p0) || !looseIdentical(v1, p1) || !looseIdentical(v2, p2) ||
	                !looseIdentical(v3, p3) || !looseIdentical(v4, p4) || !looseIdentical(v5, p5) ||
	                !looseIdentical(v6, p6)) {
	                v0 = p0;
	                v1 = p1;
	                v2 = p2;
	                v3 = p3;
	                v4 = p4;
	                v5 = p5;
	                v6 = p6;
	                result = fn(p0, p1, p2, p3, p4, p5, p6);
	            }
	            return result;
	        };
	    }
	    function pureProxy8(fn) {
	        var result;
	        var v0, v1, v2, v3, v4, v5, v6, v7;
	        v0 = v1 = v2 = v3 = v4 = v5 = v6 = v7 = UNINITIALIZED;
	        return function (p0, p1, p2, p3, p4, p5, p6, p7) {
	            if (!looseIdentical(v0, p0) || !looseIdentical(v1, p1) || !looseIdentical(v2, p2) ||
	                !looseIdentical(v3, p3) || !looseIdentical(v4, p4) || !looseIdentical(v5, p5) ||
	                !looseIdentical(v6, p6) || !looseIdentical(v7, p7)) {
	                v0 = p0;
	                v1 = p1;
	                v2 = p2;
	                v3 = p3;
	                v4 = p4;
	                v5 = p5;
	                v6 = p6;
	                v7 = p7;
	                result = fn(p0, p1, p2, p3, p4, p5, p6, p7);
	            }
	            return result;
	        };
	    }
	    function pureProxy9(fn) {
	        var result;
	        var v0, v1, v2, v3, v4, v5, v6, v7, v8;
	        v0 = v1 = v2 = v3 = v4 = v5 = v6 = v7 = v8 = UNINITIALIZED;
	        return function (p0, p1, p2, p3, p4, p5, p6, p7, p8) {
	            if (!looseIdentical(v0, p0) || !looseIdentical(v1, p1) || !looseIdentical(v2, p2) ||
	                !looseIdentical(v3, p3) || !looseIdentical(v4, p4) || !looseIdentical(v5, p5) ||
	                !looseIdentical(v6, p6) || !looseIdentical(v7, p7) || !looseIdentical(v8, p8)) {
	                v0 = p0;
	                v1 = p1;
	                v2 = p2;
	                v3 = p3;
	                v4 = p4;
	                v5 = p5;
	                v6 = p6;
	                v7 = p7;
	                v8 = p8;
	                result = fn(p0, p1, p2, p3, p4, p5, p6, p7, p8);
	            }
	            return result;
	        };
	    }
	    function pureProxy10(fn) {
	        var result;
	        var v0, v1, v2, v3, v4, v5, v6, v7, v8, v9;
	        v0 = v1 = v2 = v3 = v4 = v5 = v6 = v7 = v8 = v9 = UNINITIALIZED;
	        return function (p0, p1, p2, p3, p4, p5, p6, p7, p8, p9) {
	            if (!looseIdentical(v0, p0) || !looseIdentical(v1, p1) || !looseIdentical(v2, p2) ||
	                !looseIdentical(v3, p3) || !looseIdentical(v4, p4) || !looseIdentical(v5, p5) ||
	                !looseIdentical(v6, p6) || !looseIdentical(v7, p7) || !looseIdentical(v8, p8) ||
	                !looseIdentical(v9, p9)) {
	                v0 = p0;
	                v1 = p1;
	                v2 = p2;
	                v3 = p3;
	                v4 = p4;
	                v5 = p5;
	                v6 = p6;
	                v7 = p7;
	                v8 = p8;
	                v9 = p9;
	                result = fn(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9);
	            }
	            return result;
	        };
	    }
	    function setBindingDebugInfoForChanges(renderer, el, changes) {
	        Object.keys(changes).forEach(function (propName) {
	            setBindingDebugInfo(renderer, el, propName, changes[propName].currentValue);
	        });
	    }
	    function setBindingDebugInfo(renderer, el, propName, value) {
	        try {
	            renderer.setBindingDebugInfo(el, "ng-reflect-" + camelCaseToDashCase(propName), value ? value.toString() : null);
	        }
	        catch (e) {
	            renderer.setBindingDebugInfo(el, "ng-reflect-" + camelCaseToDashCase(propName), '[ERROR] Exception while trying to serialize the value');
	        }
	    }
	    var CAMEL_CASE_REGEXP = /([A-Z])/g;
	    function camelCaseToDashCase(input) {
	        return input.replace(CAMEL_CASE_REGEXP, function () {
	            var m = [];
	            for (var _i = 0; _i < arguments.length; _i++) {
	                m[_i - 0] = arguments[_i];
	            }
	            return '-' + m[1].toLowerCase();
	        });
	    }
	    function createRenderElement(renderer, parentElement, name, attrs, debugInfo) {
	        var el = renderer.createElement(parentElement, name, debugInfo);
	        for (var i = 0; i < attrs.length; i += 2) {
	            renderer.setElementAttribute(el, attrs.get(i), attrs.get(i + 1));
	        }
	        return el;
	    }
	    function selectOrCreateRenderHostElement(renderer, elementName, attrs, rootSelectorOrNode, debugInfo) {
	        var hostElement;
	        if (isPresent(rootSelectorOrNode)) {
	            hostElement = renderer.selectRootElement(rootSelectorOrNode, debugInfo);
	        }
	        else {
	            hostElement = createRenderElement(renderer, null, elementName, attrs, debugInfo);
	        }
	        return hostElement;
	    }
	    var InlineArray0 = (function () {
	        function InlineArray0() {
	            this.length = 0;
	        }
	        InlineArray0.prototype.get = function (index) { return undefined; };
	        return InlineArray0;
	    }());
	    var InlineArray2 = (function () {
	        function InlineArray2(length, _v0, _v1) {
	            this.length = length;
	            this._v0 = _v0;
	            this._v1 = _v1;
	        }
	        InlineArray2.prototype.get = function (index) {
	            switch (index) {
	                case 0:
	                    return this._v0;
	                case 1:
	                    return this._v1;
	                default:
	                    return undefined;
	            }
	        };
	        return InlineArray2;
	    }());
	    var InlineArray4 = (function () {
	        function InlineArray4(length, _v0, _v1, _v2, _v3) {
	            this.length = length;
	            this._v0 = _v0;
	            this._v1 = _v1;
	            this._v2 = _v2;
	            this._v3 = _v3;
	        }
	        InlineArray4.prototype.get = function (index) {
	            switch (index) {
	                case 0:
	                    return this._v0;
	                case 1:
	                    return this._v1;
	                case 2:
	                    return this._v2;
	                case 3:
	                    return this._v3;
	                default:
	                    return undefined;
	            }
	        };
	        return InlineArray4;
	    }());
	    var InlineArray8 = (function () {
	        function InlineArray8(length, _v0, _v1, _v2, _v3, _v4, _v5, _v6, _v7) {
	            this.length = length;
	            this._v0 = _v0;
	            this._v1 = _v1;
	            this._v2 = _v2;
	            this._v3 = _v3;
	            this._v4 = _v4;
	            this._v5 = _v5;
	            this._v6 = _v6;
	            this._v7 = _v7;
	        }
	        InlineArray8.prototype.get = function (index) {
	            switch (index) {
	                case 0:
	                    return this._v0;
	                case 1:
	                    return this._v1;
	                case 2:
	                    return this._v2;
	                case 3:
	                    return this._v3;
	                case 4:
	                    return this._v4;
	                case 5:
	                    return this._v5;
	                case 6:
	                    return this._v6;
	                case 7:
	                    return this._v7;
	                default:
	                    return undefined;
	            }
	        };
	        return InlineArray8;
	    }());
	    var InlineArray16 = (function () {
	        function InlineArray16(length, _v0, _v1, _v2, _v3, _v4, _v5, _v6, _v7, _v8, _v9, _v10, _v11, _v12, _v13, _v14, _v15) {
	            this.length = length;
	            this._v0 = _v0;
	            this._v1 = _v1;
	            this._v2 = _v2;
	            this._v3 = _v3;
	            this._v4 = _v4;
	            this._v5 = _v5;
	            this._v6 = _v6;
	            this._v7 = _v7;
	            this._v8 = _v8;
	            this._v9 = _v9;
	            this._v10 = _v10;
	            this._v11 = _v11;
	            this._v12 = _v12;
	            this._v13 = _v13;
	            this._v14 = _v14;
	            this._v15 = _v15;
	        }
	        InlineArray16.prototype.get = function (index) {
	            switch (index) {
	                case 0:
	                    return this._v0;
	                case 1:
	                    return this._v1;
	                case 2:
	                    return this._v2;
	                case 3:
	                    return this._v3;
	                case 4:
	                    return this._v4;
	                case 5:
	                    return this._v5;
	                case 6:
	                    return this._v6;
	                case 7:
	                    return this._v7;
	                case 8:
	                    return this._v8;
	                case 9:
	                    return this._v9;
	                case 10:
	                    return this._v10;
	                case 11:
	                    return this._v11;
	                case 12:
	                    return this._v12;
	                case 13:
	                    return this._v13;
	                case 14:
	                    return this._v14;
	                case 15:
	                    return this._v15;
	                default:
	                    return undefined;
	            }
	        };
	        return InlineArray16;
	    }());
	    var InlineArrayDynamic = (function () {
	        // Note: We still take the length argument so this class can be created
	        // in the same ways as the other classes!
	        function InlineArrayDynamic(length) {
	            var values = [];
	            for (var _i = 1; _i < arguments.length; _i++) {
	                values[_i - 1] = arguments[_i];
	            }
	            this.length = length;
	            this._values = values;
	        }
	        InlineArrayDynamic.prototype.get = function (index) { return this._values[index]; };
	        return InlineArrayDynamic;
	    }());
	    var EMPTY_INLINE_ARRAY = new InlineArray0();


	    var view_utils = Object.freeze({
	        ViewUtils: ViewUtils,
	        flattenNestedViewRenderNodes: flattenNestedViewRenderNodes,
	        ensureSlotCount: ensureSlotCount,
	        MAX_INTERPOLATION_VALUES: MAX_INTERPOLATION_VALUES,
	        interpolate: interpolate,
	        checkBinding: checkBinding,
	        castByValue: castByValue,
	        EMPTY_ARRAY: EMPTY_ARRAY,
	        EMPTY_MAP: EMPTY_MAP,
	        pureProxy1: pureProxy1,
	        pureProxy2: pureProxy2,
	        pureProxy3: pureProxy3,
	        pureProxy4: pureProxy4,
	        pureProxy5: pureProxy5,
	        pureProxy6: pureProxy6,
	        pureProxy7: pureProxy7,
	        pureProxy8: pureProxy8,
	        pureProxy9: pureProxy9,
	        pureProxy10: pureProxy10,
	        setBindingDebugInfoForChanges: setBindingDebugInfoForChanges,
	        setBindingDebugInfo: setBindingDebugInfo,
	        createRenderElement: createRenderElement,
	        selectOrCreateRenderHostElement: selectOrCreateRenderHostElement,
	        InlineArray2: InlineArray2,
	        InlineArray4: InlineArray4,
	        InlineArray8: InlineArray8,
	        InlineArray16: InlineArray16,
	        InlineArrayDynamic: InlineArrayDynamic,
	        EMPTY_INLINE_ARRAY: EMPTY_INLINE_ARRAY
	    });

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$5 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    /**
	     * Represents an instance of a Component created via a {@link ComponentFactory}.
	     *
	     * `ComponentRef` provides access to the Component Instance as well other objects related to this
	     * Component Instance and allows you to destroy the Component Instance via the {@link #destroy}
	     * method.
	     * @stable
	     */
	    var ComponentRef = (function () {
	        function ComponentRef() {
	        }
	        Object.defineProperty(ComponentRef.prototype, "location", {
	            /**
	             * Location of the Host Element of this Component Instance.
	             */
	            get: function () { return unimplemented(); },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(ComponentRef.prototype, "injector", {
	            /**
	             * The injector on which the component instance exists.
	             */
	            get: function () { return unimplemented(); },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(ComponentRef.prototype, "instance", {
	            /**
	             * The instance of the Component.
	             */
	            get: function () { return unimplemented(); },
	            enumerable: true,
	            configurable: true
	        });
	        ;
	        Object.defineProperty(ComponentRef.prototype, "hostView", {
	            /**
	             * The {@link ViewRef} of the Host View of this Component instance.
	             */
	            get: function () { return unimplemented(); },
	            enumerable: true,
	            configurable: true
	        });
	        ;
	        Object.defineProperty(ComponentRef.prototype, "changeDetectorRef", {
	            /**
	             * The {@link ChangeDetectorRef} of the Component instance.
	             */
	            get: function () { return unimplemented(); },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(ComponentRef.prototype, "componentType", {
	            /**
	             * The component type.
	             */
	            get: function () { return unimplemented(); },
	            enumerable: true,
	            configurable: true
	        });
	        return ComponentRef;
	    }());
	    var ComponentRef_ = (function (_super) {
	        __extends$5(ComponentRef_, _super);
	        function ComponentRef_(_hostElement, _componentType) {
	            _super.call(this);
	            this._hostElement = _hostElement;
	            this._componentType = _componentType;
	        }
	        Object.defineProperty(ComponentRef_.prototype, "location", {
	            get: function () { return this._hostElement.elementRef; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(ComponentRef_.prototype, "injector", {
	            get: function () { return this._hostElement.injector; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(ComponentRef_.prototype, "instance", {
	            get: function () { return this._hostElement.component; },
	            enumerable: true,
	            configurable: true
	        });
	        ;
	        Object.defineProperty(ComponentRef_.prototype, "hostView", {
	            get: function () { return this._hostElement.parentView.ref; },
	            enumerable: true,
	            configurable: true
	        });
	        ;
	        Object.defineProperty(ComponentRef_.prototype, "changeDetectorRef", {
	            get: function () { return this._hostElement.parentView.ref; },
	            enumerable: true,
	            configurable: true
	        });
	        ;
	        Object.defineProperty(ComponentRef_.prototype, "componentType", {
	            get: function () { return this._componentType; },
	            enumerable: true,
	            configurable: true
	        });
	        ComponentRef_.prototype.destroy = function () { this._hostElement.parentView.destroy(); };
	        ComponentRef_.prototype.onDestroy = function (callback) { this.hostView.onDestroy(callback); };
	        return ComponentRef_;
	    }(ComponentRef));
	    /**
	     * @experimental
	     */
	    var EMPTY_CONTEXT = new Object();
	    /**
	     * @stable
	     */
	    var ComponentFactory = (function () {
	        function ComponentFactory(selector, _viewFactory, _componentType) {
	            this.selector = selector;
	            this._viewFactory = _viewFactory;
	            this._componentType = _componentType;
	        }
	        Object.defineProperty(ComponentFactory.prototype, "componentType", {
	            get: function () { return this._componentType; },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * Creates a new component.
	         */
	        ComponentFactory.prototype.create = function (injector, projectableNodes, rootSelectorOrNode) {
	            if (projectableNodes === void 0) { projectableNodes = null; }
	            if (rootSelectorOrNode === void 0) { rootSelectorOrNode = null; }
	            var vu = injector.get(ViewUtils);
	            if (!projectableNodes) {
	                projectableNodes = [];
	            }
	            // Note: Host views don't need a declarationAppElement!
	            var hostView = this._viewFactory(vu, injector, null);
	            var hostElement = hostView.create(EMPTY_CONTEXT, projectableNodes, rootSelectorOrNode);
	            return new ComponentRef_(hostElement, this._componentType);
	        };
	        return ComponentFactory;
	    }());

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$7 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    /**
	     * @stable
	     */
	    var NoComponentFactoryError = (function (_super) {
	        __extends$7(NoComponentFactoryError, _super);
	        function NoComponentFactoryError(component) {
	            _super.call(this, "No component factory found for " + stringify(component));
	            this.component = component;
	        }
	        return NoComponentFactoryError;
	    }(BaseError));
	    var _NullComponentFactoryResolver = (function () {
	        function _NullComponentFactoryResolver() {
	        }
	        _NullComponentFactoryResolver.prototype.resolveComponentFactory = function (component) {
	            throw new NoComponentFactoryError(component);
	        };
	        return _NullComponentFactoryResolver;
	    }());
	    /**
	     * @stable
	     */
	    var ComponentFactoryResolver = (function () {
	        function ComponentFactoryResolver() {
	        }
	        ComponentFactoryResolver.NULL = new _NullComponentFactoryResolver();
	        return ComponentFactoryResolver;
	    }());
	    var CodegenComponentFactoryResolver = (function () {
	        function CodegenComponentFactoryResolver(factories, _parent) {
	            this._parent = _parent;
	            this._factories = new Map();
	            for (var i = 0; i < factories.length; i++) {
	                var factory = factories[i];
	                this._factories.set(factory.componentType, factory);
	            }
	        }
	        CodegenComponentFactoryResolver.prototype.resolveComponentFactory = function (component) {
	            var result = this._factories.get(component);
	            if (!result) {
	                result = this._parent.resolveComponentFactory(component);
	            }
	            return result;
	        };
	        return CodegenComponentFactoryResolver;
	    }());

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$8 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    /**
	     * Use by directives and components to emit custom Events.
	     *
	     * ### Examples
	     *
	     * In the following example, `Zippy` alternatively emits `open` and `close` events when its
	     * title gets clicked:
	     *
	     * ```
	     * @Component({
	     *   selector: 'zippy',
	     *   template: `
	     *   <div class="zippy">
	     *     <div (click)="toggle()">Toggle</div>
	     *     <div [hidden]="!visible">
	     *       <ng-content></ng-content>
	     *     </div>
	     *  </div>`})
	     * export class Zippy {
	     *   visible: boolean = true;
	     *   @Output() open: EventEmitter<any> = new EventEmitter();
	     *   @Output() close: EventEmitter<any> = new EventEmitter();
	     *
	     *   toggle() {
	     *     this.visible = !this.visible;
	     *     if (this.visible) {
	     *       this.open.emit(null);
	     *     } else {
	     *       this.close.emit(null);
	     *     }
	     *   }
	     * }
	     * ```
	     *
	     * The events payload can be accessed by the parameter `$event` on the components output event
	     * handler:
	     *
	     * ```
	     * <zippy (open)="onOpen($event)" (close)="onClose($event)"></zippy>
	     * ```
	     *
	     * Uses Rx.Observable but provides an adapter to make it work as specified here:
	     * https://github.com/jhusain/observable-spec
	     *
	     * Once a reference implementation of the spec is available, switch to it.
	     * @stable
	     */
	    var EventEmitter = (function (_super) {
	        __extends$8(EventEmitter, _super);
	        /**
	         * Creates an instance of [EventEmitter], which depending on [isAsync],
	         * delivers events synchronously or asynchronously.
	         */
	        function EventEmitter(isAsync) {
	            if (isAsync === void 0) { isAsync = false; }
	            _super.call(this);
	            this.__isAsync = isAsync;
	        }
	        EventEmitter.prototype.emit = function (value) { _super.prototype.next.call(this, value); };
	        EventEmitter.prototype.subscribe = function (generatorOrNext, error, complete) {
	            var schedulerFn;
	            var errorFn = function (err) { return null; };
	            var completeFn = function () { return null; };
	            if (generatorOrNext && typeof generatorOrNext === 'object') {
	                schedulerFn = this.__isAsync ? function (value) {
	                    setTimeout(function () { return generatorOrNext.next(value); });
	                } : function (value) { generatorOrNext.next(value); };
	                if (generatorOrNext.error) {
	                    errorFn = this.__isAsync ? function (err) { setTimeout(function () { return generatorOrNext.error(err); }); } :
	                        function (err) { generatorOrNext.error(err); };
	                }
	                if (generatorOrNext.complete) {
	                    completeFn = this.__isAsync ? function () { setTimeout(function () { return generatorOrNext.complete(); }); } :
	                        function () { generatorOrNext.complete(); };
	                }
	            }
	            else {
	                schedulerFn = this.__isAsync ? function (value) { setTimeout(function () { return generatorOrNext(value); }); } :
	                    function (value) { generatorOrNext(value); };
	                if (error) {
	                    errorFn =
	                        this.__isAsync ? function (err) { setTimeout(function () { return error(err); }); } : function (err) { error(err); };
	                }
	                if (complete) {
	                    completeFn =
	                        this.__isAsync ? function () { setTimeout(function () { return complete(); }); } : function () { complete(); };
	                }
	            }
	            return _super.prototype.subscribe.call(this, schedulerFn, errorFn, completeFn);
	        };
	        return EventEmitter;
	    }(rxjs_Subject.Subject));

	    /**
	     * An injectable service for executing work inside or outside of the Angular zone.
	     *
	     * The most common use of this service is to optimize performance when starting a work consisting of
	     * one or more asynchronous tasks that don't require UI updates or error handling to be handled by
	     * Angular. Such tasks can be kicked off via {@link runOutsideAngular} and if needed, these tasks
	     * can reenter the Angular zone via {@link run}.
	     *
	     * <!-- TODO: add/fix links to:
	     *   - docs explaining zones and the use of zones in Angular and change-detection
	     *   - link to runOutsideAngular/run (throughout this file!)
	     *   -->
	     *
	     * ### Example
	     * ```
	     * import {Component, NgZone} from '@angular/core';
	     * import {NgIf} from '@angular/common';
	     *
	     * @Component({
	     *   selector: 'ng-zone-demo'.
	     *   template: `
	     *     <h2>Demo: NgZone</h2>
	     *
	     *     <p>Progress: {{progress}}%</p>
	     *     <p *ngIf="progress >= 100">Done processing {{label}} of Angular zone!</p>
	     *
	     *     <button (click)="processWithinAngularZone()">Process within Angular zone</button>
	     *     <button (click)="processOutsideOfAngularZone()">Process outside of Angular zone</button>
	     *   `,
	     * })
	     * export class NgZoneDemo {
	     *   progress: number = 0;
	     *   label: string;
	     *
	     *   constructor(private _ngZone: NgZone) {}
	     *
	     *   // Loop inside the Angular zone
	     *   // so the UI DOES refresh after each setTimeout cycle
	     *   processWithinAngularZone() {
	     *     this.label = 'inside';
	     *     this.progress = 0;
	     *     this._increaseProgress(() => console.log('Inside Done!'));
	     *   }
	     *
	     *   // Loop outside of the Angular zone
	     *   // so the UI DOES NOT refresh after each setTimeout cycle
	     *   processOutsideOfAngularZone() {
	     *     this.label = 'outside';
	     *     this.progress = 0;
	     *     this._ngZone.runOutsideAngular(() => {
	     *       this._increaseProgress(() => {
	     *       // reenter the Angular zone and display done
	     *       this._ngZone.run(() => {console.log('Outside Done!') });
	     *     }}));
	     *   }
	     *
	     *   _increaseProgress(doneCallback: () => void) {
	     *     this.progress += 1;
	     *     console.log(`Current progress: ${this.progress}%`);
	     *
	     *     if (this.progress < 100) {
	     *       window.setTimeout(() => this._increaseProgress(doneCallback)), 10)
	     *     } else {
	     *       doneCallback();
	     *     }
	     *   }
	     * }
	     * ```
	     * @experimental
	     */
	    var NgZone = (function () {
	        function NgZone(_a) {
	            var _b = _a.enableLongStackTrace, enableLongStackTrace = _b === void 0 ? false : _b;
	            this._hasPendingMicrotasks = false;
	            this._hasPendingMacrotasks = false;
	            this._isStable = true;
	            this._nesting = 0;
	            this._onUnstable = new EventEmitter(false);
	            this._onMicrotaskEmpty = new EventEmitter(false);
	            this._onStable = new EventEmitter(false);
	            this._onErrorEvents = new EventEmitter(false);
	            if (typeof Zone == 'undefined') {
	                throw new Error('Angular requires Zone.js prolyfill.');
	            }
	            Zone.assertZonePatched();
	            this.outer = this.inner = Zone.current;
	            if (Zone['wtfZoneSpec']) {
	                this.inner = this.inner.fork(Zone['wtfZoneSpec']);
	            }
	            if (enableLongStackTrace && Zone['longStackTraceZoneSpec']) {
	                this.inner = this.inner.fork(Zone['longStackTraceZoneSpec']);
	            }
	            this.forkInnerZoneWithAngularBehavior();
	        }
	        NgZone.isInAngularZone = function () { return Zone.current.get('isAngularZone') === true; };
	        NgZone.assertInAngularZone = function () {
	            if (!NgZone.isInAngularZone()) {
	                throw new Error('Expected to be in Angular Zone, but it is not!');
	            }
	        };
	        NgZone.assertNotInAngularZone = function () {
	            if (NgZone.isInAngularZone()) {
	                throw new Error('Expected to not be in Angular Zone, but it is!');
	            }
	        };
	        /**
	         * Executes the `fn` function synchronously within the Angular zone and returns value returned by
	         * the function.
	         *
	         * Running functions via `run` allows you to reenter Angular zone from a task that was executed
	         * outside of the Angular zone (typically started via {@link runOutsideAngular}).
	         *
	         * Any future tasks or microtasks scheduled from within this function will continue executing from
	         * within the Angular zone.
	         *
	         * If a synchronous error happens it will be rethrown and not reported via `onError`.
	         */
	        NgZone.prototype.run = function (fn) { return this.inner.run(fn); };
	        /**
	         * Same as `run`, except that synchronous errors are caught and forwarded via `onError` and not
	         * rethrown.
	         */
	        NgZone.prototype.runGuarded = function (fn) { return this.inner.runGuarded(fn); };
	        /**
	         * Executes the `fn` function synchronously in Angular's parent zone and returns value returned by
	         * the function.
	         *
	         * Running functions via `runOutsideAngular` allows you to escape Angular's zone and do work that
	         * doesn't trigger Angular change-detection or is subject to Angular's error handling.
	         *
	         * Any future tasks or microtasks scheduled from within this function will continue executing from
	         * outside of the Angular zone.
	         *
	         * Use {@link run} to reenter the Angular zone and do work that updates the application model.
	         */
	        NgZone.prototype.runOutsideAngular = function (fn) { return this.outer.run(fn); };
	        Object.defineProperty(NgZone.prototype, "onUnstable", {
	            /**
	             * Notifies when code enters Angular Zone. This gets fired first on VM Turn.
	             */
	            get: function () { return this._onUnstable; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(NgZone.prototype, "onMicrotaskEmpty", {
	            /**
	             * Notifies when there is no more microtasks enqueue in the current VM Turn.
	             * This is a hint for Angular to do change detection, which may enqueue more microtasks.
	             * For this reason this event can fire multiple times per VM Turn.
	             */
	            get: function () { return this._onMicrotaskEmpty; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(NgZone.prototype, "onStable", {
	            /**
	             * Notifies when the last `onMicrotaskEmpty` has run and there are no more microtasks, which
	             * implies we are about to relinquish VM turn.
	             * This event gets called just once.
	             */
	            get: function () { return this._onStable; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(NgZone.prototype, "onError", {
	            /**
	             * Notify that an error has been delivered.
	             */
	            get: function () { return this._onErrorEvents; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(NgZone.prototype, "isStable", {
	            /**
	             * Whether there are no outstanding microtasks or macrotasks.
	             */
	            get: function () { return this._isStable; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(NgZone.prototype, "hasPendingMicrotasks", {
	            get: function () { return this._hasPendingMicrotasks; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(NgZone.prototype, "hasPendingMacrotasks", {
	            get: function () { return this._hasPendingMacrotasks; },
	            enumerable: true,
	            configurable: true
	        });
	        NgZone.prototype.checkStable = function () {
	            var _this = this;
	            if (this._nesting == 0 && !this._hasPendingMicrotasks && !this._isStable) {
	                try {
	                    this._nesting++;
	                    this._onMicrotaskEmpty.emit(null);
	                }
	                finally {
	                    this._nesting--;
	                    if (!this._hasPendingMicrotasks) {
	                        try {
	                            this.runOutsideAngular(function () { return _this._onStable.emit(null); });
	                        }
	                        finally {
	                            this._isStable = true;
	                        }
	                    }
	                }
	            }
	        };
	        NgZone.prototype.forkInnerZoneWithAngularBehavior = function () {
	            var _this = this;
	            this.inner = this.inner.fork({
	                name: 'angular',
	                properties: { 'isAngularZone': true },
	                onInvokeTask: function (delegate, current, target, task, applyThis, applyArgs) {
	                    try {
	                        _this.onEnter();
	                        return delegate.invokeTask(target, task, applyThis, applyArgs);
	                    }
	                    finally {
	                        _this.onLeave();
	                    }
	                },
	                onInvoke: function (delegate, current, target, callback, applyThis, applyArgs, source) {
	                    try {
	                        _this.onEnter();
	                        return delegate.invoke(target, callback, applyThis, applyArgs, source);
	                    }
	                    finally {
	                        _this.onLeave();
	                    }
	                },
	                onHasTask: function (delegate, current, target, hasTaskState) {
	                    delegate.hasTask(target, hasTaskState);
	                    if (current === target) {
	                        // We are only interested in hasTask events which originate from our zone
	                        // (A child hasTask event is not interesting to us)
	                        if (hasTaskState.change == 'microTask') {
	                            _this.setHasMicrotask(hasTaskState.microTask);
	                        }
	                        else if (hasTaskState.change == 'macroTask') {
	                            _this.setHasMacrotask(hasTaskState.macroTask);
	                        }
	                    }
	                },
	                onHandleError: function (delegate, current, target, error) {
	                    delegate.handleError(target, error);
	                    _this.triggerError(error);
	                    return false;
	                }
	            });
	        };
	        NgZone.prototype.onEnter = function () {
	            this._nesting++;
	            if (this._isStable) {
	                this._isStable = false;
	                this._onUnstable.emit(null);
	            }
	        };
	        NgZone.prototype.onLeave = function () {
	            this._nesting--;
	            this.checkStable();
	        };
	        NgZone.prototype.setHasMicrotask = function (hasMicrotasks) {
	            this._hasPendingMicrotasks = hasMicrotasks;
	            this.checkStable();
	        };
	        NgZone.prototype.setHasMacrotask = function (hasMacrotasks) { this._hasPendingMacrotasks = hasMacrotasks; };
	        NgZone.prototype.triggerError = function (error) { this._onErrorEvents.emit(error); };
	        return NgZone;
	    }());

	    /**
	     * The Testability service provides testing hooks that can be accessed from
	     * the browser and by services such as Protractor. Each bootstrapped Angular
	     * application on the page will have an instance of Testability.
	     * @experimental
	     */
	    var Testability = (function () {
	        function Testability(_ngZone) {
	            this._ngZone = _ngZone;
	            /** @internal */
	            this._pendingCount = 0;
	            /** @internal */
	            this._isZoneStable = true;
	            /**
	             * Whether any work was done since the last 'whenStable' callback. This is
	             * useful to detect if this could have potentially destabilized another
	             * component while it is stabilizing.
	             * @internal
	             */
	            this._didWork = false;
	            /** @internal */
	            this._callbacks = [];
	            this._watchAngularEvents();
	        }
	        /** @internal */
	        Testability.prototype._watchAngularEvents = function () {
	            var _this = this;
	            this._ngZone.onUnstable.subscribe({
	                next: function () {
	                    _this._didWork = true;
	                    _this._isZoneStable = false;
	                }
	            });
	            this._ngZone.runOutsideAngular(function () {
	                _this._ngZone.onStable.subscribe({
	                    next: function () {
	                        NgZone.assertNotInAngularZone();
	                        scheduleMicroTask(function () {
	                            _this._isZoneStable = true;
	                            _this._runCallbacksIfReady();
	                        });
	                    }
	                });
	            });
	        };
	        Testability.prototype.increasePendingRequestCount = function () {
	            this._pendingCount += 1;
	            this._didWork = true;
	            return this._pendingCount;
	        };
	        Testability.prototype.decreasePendingRequestCount = function () {
	            this._pendingCount -= 1;
	            if (this._pendingCount < 0) {
	                throw new Error('pending async requests below zero');
	            }
	            this._runCallbacksIfReady();
	            return this._pendingCount;
	        };
	        Testability.prototype.isStable = function () {
	            return this._isZoneStable && this._pendingCount == 0 && !this._ngZone.hasPendingMacrotasks;
	        };
	        /** @internal */
	        Testability.prototype._runCallbacksIfReady = function () {
	            var _this = this;
	            if (this.isStable()) {
	                // Schedules the call backs in a new frame so that it is always async.
	                scheduleMicroTask(function () {
	                    while (_this._callbacks.length !== 0) {
	                        (_this._callbacks.pop())(_this._didWork);
	                    }
	                    _this._didWork = false;
	                });
	            }
	            else {
	                // Not Ready
	                this._didWork = true;
	            }
	        };
	        Testability.prototype.whenStable = function (callback) {
	            this._callbacks.push(callback);
	            this._runCallbacksIfReady();
	        };
	        Testability.prototype.getPendingRequestCount = function () { return this._pendingCount; };
	        /** @deprecated use findProviders */
	        Testability.prototype.findBindings = function (using, provider, exactMatch) {
	            // TODO(juliemr): implement.
	            return [];
	        };
	        Testability.prototype.findProviders = function (using, provider, exactMatch) {
	            // TODO(juliemr): implement.
	            return [];
	        };
	        Testability.decorators = [
	            { type: Injectable },
	        ];
	        /** @nocollapse */
	        Testability.ctorParameters = [
	            { type: NgZone, },
	        ];
	        return Testability;
	    }());
	    /**
	     * A global registry of {@link Testability} instances for specific elements.
	     * @experimental
	     */
	    var TestabilityRegistry = (function () {
	        function TestabilityRegistry() {
	            /** @internal */
	            this._applications = new Map();
	            _testabilityGetter.addToWindow(this);
	        }
	        TestabilityRegistry.prototype.registerApplication = function (token, testability) {
	            this._applications.set(token, testability);
	        };
	        TestabilityRegistry.prototype.getTestability = function (elem) { return this._applications.get(elem); };
	        TestabilityRegistry.prototype.getAllTestabilities = function () { return MapWrapper.values(this._applications); };
	        TestabilityRegistry.prototype.getAllRootElements = function () { return MapWrapper.keys(this._applications); };
	        TestabilityRegistry.prototype.findTestabilityInTree = function (elem, findInAncestors) {
	            if (findInAncestors === void 0) { findInAncestors = true; }
	            return _testabilityGetter.findTestabilityInTree(this, elem, findInAncestors);
	        };
	        TestabilityRegistry.decorators = [
	            { type: Injectable },
	        ];
	        /** @nocollapse */
	        TestabilityRegistry.ctorParameters = [];
	        return TestabilityRegistry;
	    }());
	    var _NoopGetTestability = (function () {
	        function _NoopGetTestability() {
	        }
	        _NoopGetTestability.prototype.addToWindow = function (registry) { };
	        _NoopGetTestability.prototype.findTestabilityInTree = function (registry, elem, findInAncestors) {
	            return null;
	        };
	        return _NoopGetTestability;
	    }());
	    /**
	     * Set the {@link GetTestability} implementation used by the Angular testing framework.
	     * @experimental
	     */
	    function setTestabilityGetter(getter) {
	        _testabilityGetter = getter;
	    }
	    var _testabilityGetter = new _NoopGetTestability();

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$3 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    var _devMode = true;
	    var _runModeLocked = false;
	    var _platform;
	    /**
	     * Disable Angular's development mode, which turns off assertions and other
	     * checks within the framework.
	     *
	     * One important assertion this disables verifies that a change detection pass
	     * does not result in additional changes to any bindings (also known as
	     * unidirectional data flow).
	     *
	     * @stable
	     */
	    function enableProdMode() {
	        if (_runModeLocked) {
	            throw new Error('Cannot enable prod mode after platform setup.');
	        }
	        _devMode = false;
	    }
	    /**
	     * Returns whether Angular is in development mode. After called once,
	     * the value is locked and won't change any more.
	     *
	     * By default, this is true, unless a user calls `enableProdMode` before calling this.
	     *
	     * @experimental APIs related to application bootstrap are currently under review.
	     */
	    function isDevMode() {
	        _runModeLocked = true;
	        return _devMode;
	    }
	    /**
	     * Creates a platform.
	     * Platforms have to be eagerly created via this function.
	     *
	     * @experimental APIs related to application bootstrap are currently under review.
	     */
	    function createPlatform(injector) {
	        if (_platform && !_platform.destroyed) {
	            throw new Error('There can be only one platform. Destroy the previous one to create a new one.');
	        }
	        _platform = injector.get(PlatformRef);
	        var inits = injector.get(PLATFORM_INITIALIZER, null);
	        if (inits)
	            inits.forEach(function (init) { return init(); });
	        return _platform;
	    }
	    /**
	     * Creates a factory for a platform
	     *
	     * @experimental APIs related to application bootstrap are currently under review.
	     */
	    function createPlatformFactory(parentPlaformFactory, name, providers) {
	        if (providers === void 0) { providers = []; }
	        var marker = new OpaqueToken("Platform: " + name);
	        return function (extraProviders) {
	            if (extraProviders === void 0) { extraProviders = []; }
	            if (!getPlatform()) {
	                if (parentPlaformFactory) {
	                    parentPlaformFactory(providers.concat(extraProviders).concat({ provide: marker, useValue: true }));
	                }
	                else {
	                    createPlatform(ReflectiveInjector.resolveAndCreate(providers.concat(extraProviders).concat({ provide: marker, useValue: true })));
	                }
	            }
	            return assertPlatform(marker);
	        };
	    }
	    /**
	     * Checks that there currently is a platform
	     * which contains the given token as a provider.
	     *
	     * @experimental APIs related to application bootstrap are currently under review.
	     */
	    function assertPlatform(requiredToken) {
	        var platform = getPlatform();
	        if (!platform) {
	            throw new Error('No platform exists!');
	        }
	        if (!platform.injector.get(requiredToken, null)) {
	            throw new Error('A platform with a different configuration has been created. Please destroy it first.');
	        }
	        return platform;
	    }
	    /**
	     * Destroy the existing platform.
	     *
	     * @experimental APIs related to application bootstrap are currently under review.
	     */
	    function destroyPlatform() {
	        if (_platform && !_platform.destroyed) {
	            _platform.destroy();
	        }
	    }
	    /**
	     * Returns the current platform.
	     *
	     * @experimental APIs related to application bootstrap are currently under review.
	     */
	    function getPlatform() {
	        return _platform && !_platform.destroyed ? _platform : null;
	    }
	    /**
	     * The Angular platform is the entry point for Angular on a web page. Each page
	     * has exactly one platform, and services (such as reflection) which are common
	     * to every Angular application running on the page are bound in its scope.
	     *
	     * A page's platform is initialized implicitly when {@link bootstrap}() is called, or
	     * explicitly by calling {@link createPlatform}().
	     *
	     * @stable
	     */
	    var PlatformRef = (function () {
	        function PlatformRef() {
	        }
	        /**
	         * Creates an instance of an `@NgModule` for the given platform
	         * for offline compilation.
	         *
	         * ## Simple Example
	         *
	         * ```typescript
	         * my_module.ts:
	         *
	         * @NgModule({
	         *   imports: [BrowserModule]
	         * })
	         * class MyModule {}
	         *
	         * main.ts:
	         * import {MyModuleNgFactory} from './my_module.ngfactory';
	         * import {platformBrowser} from '@angular/platform-browser';
	         *
	         * let moduleRef = platformBrowser().bootstrapModuleFactory(MyModuleNgFactory);
	         * ```
	         *
	         * @experimental APIs related to application bootstrap are currently under review.
	         */
	        PlatformRef.prototype.bootstrapModuleFactory = function (moduleFactory) {
	            throw unimplemented();
	        };
	        /**
	         * Creates an instance of an `@NgModule` for a given platform using the given runtime compiler.
	         *
	         * ## Simple Example
	         *
	         * ```typescript
	         * @NgModule({
	         *   imports: [BrowserModule]
	         * })
	         * class MyModule {}
	         *
	         * let moduleRef = platformBrowser().bootstrapModule(MyModule);
	         * ```
	         * @stable
	         */
	        PlatformRef.prototype.bootstrapModule = function (moduleType, compilerOptions) {
	            if (compilerOptions === void 0) { compilerOptions = []; }
	            throw unimplemented();
	        };
	        Object.defineProperty(PlatformRef.prototype, "injector", {
	            /**
	             * Retrieve the platform {@link Injector}, which is the parent injector for
	             * every Angular application on the page and provides singleton providers.
	             */
	            get: function () { throw unimplemented(); },
	            enumerable: true,
	            configurable: true
	        });
	        ;
	        Object.defineProperty(PlatformRef.prototype, "destroyed", {
	            get: function () { throw unimplemented(); },
	            enumerable: true,
	            configurable: true
	        });
	        return PlatformRef;
	    }());
	    function _callAndReportToErrorHandler(errorHandler, callback) {
	        try {
	            var result = callback();
	            if (isPromise(result)) {
	                return result.catch(function (e) {
	                    errorHandler.handleError(e);
	                    // rethrow as the exception handler might not do it
	                    throw e;
	                });
	            }
	            return result;
	        }
	        catch (e) {
	            errorHandler.handleError(e);
	            // rethrow as the exception handler might not do it
	            throw e;
	        }
	    }
	    var PlatformRef_ = (function (_super) {
	        __extends$3(PlatformRef_, _super);
	        function PlatformRef_(_injector) {
	            _super.call(this);
	            this._injector = _injector;
	            this._modules = [];
	            this._destroyListeners = [];
	            this._destroyed = false;
	        }
	        PlatformRef_.prototype.onDestroy = function (callback) { this._destroyListeners.push(callback); };
	        Object.defineProperty(PlatformRef_.prototype, "injector", {
	            get: function () { return this._injector; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(PlatformRef_.prototype, "destroyed", {
	            get: function () { return this._destroyed; },
	            enumerable: true,
	            configurable: true
	        });
	        PlatformRef_.prototype.destroy = function () {
	            if (this._destroyed) {
	                throw new Error('The platform has already been destroyed!');
	            }
	            this._modules.slice().forEach(function (module) { return module.destroy(); });
	            this._destroyListeners.forEach(function (listener) { return listener(); });
	            this._destroyed = true;
	        };
	        PlatformRef_.prototype.bootstrapModuleFactory = function (moduleFactory) {
	            return this._bootstrapModuleFactoryWithZone(moduleFactory, null);
	        };
	        PlatformRef_.prototype._bootstrapModuleFactoryWithZone = function (moduleFactory, ngZone) {
	            var _this = this;
	            // Note: We need to create the NgZone _before_ we instantiate the module,
	            // as instantiating the module creates some providers eagerly.
	            // So we create a mini parent injector that just contains the new NgZone and
	            // pass that as parent to the NgModuleFactory.
	            if (!ngZone)
	                ngZone = new NgZone({ enableLongStackTrace: isDevMode() });
	            // Attention: Don't use ApplicationRef.run here,
	            // as we want to be sure that all possible constructor calls are inside `ngZone.run`!
	            return ngZone.run(function () {
	                var ngZoneInjector = ReflectiveInjector.resolveAndCreate([{ provide: NgZone, useValue: ngZone }], _this.injector);
	                var moduleRef = moduleFactory.create(ngZoneInjector);
	                var exceptionHandler = moduleRef.injector.get(ErrorHandler, null);
	                if (!exceptionHandler) {
	                    throw new Error('No ErrorHandler. Is platform module (BrowserModule) included?');
	                }
	                moduleRef.onDestroy(function () { return ListWrapper.remove(_this._modules, moduleRef); });
	                ngZone.onError.subscribe({ next: function (error) { exceptionHandler.handleError(error); } });
	                return _callAndReportToErrorHandler(exceptionHandler, function () {
	                    var initStatus = moduleRef.injector.get(ApplicationInitStatus);
	                    return initStatus.donePromise.then(function () {
	                        _this._moduleDoBootstrap(moduleRef);
	                        return moduleRef;
	                    });
	                });
	            });
	        };
	        PlatformRef_.prototype.bootstrapModule = function (moduleType, compilerOptions) {
	            if (compilerOptions === void 0) { compilerOptions = []; }
	            return this._bootstrapModuleWithZone(moduleType, compilerOptions, null);
	        };
	        PlatformRef_.prototype._bootstrapModuleWithZone = function (moduleType, compilerOptions, ngZone, componentFactoryCallback) {
	            var _this = this;
	            if (compilerOptions === void 0) { compilerOptions = []; }
	            var compilerFactory = this.injector.get(CompilerFactory);
	            var compiler = compilerFactory.createCompiler(Array.isArray(compilerOptions) ? compilerOptions : [compilerOptions]);
	            // ugly internal api hack: generate host component factories for all declared components and
	            // pass the factories into the callback - this is used by UpdateAdapter to get hold of all
	            // factories.
	            if (componentFactoryCallback) {
	                return compiler.compileModuleAndAllComponentsAsync(moduleType)
	                    .then(function (_a) {
	                    var ngModuleFactory = _a.ngModuleFactory, componentFactories = _a.componentFactories;
	                    componentFactoryCallback(componentFactories);
	                    return _this._bootstrapModuleFactoryWithZone(ngModuleFactory, ngZone);
	                });
	            }
	            return compiler.compileModuleAsync(moduleType)
	                .then(function (moduleFactory) { return _this._bootstrapModuleFactoryWithZone(moduleFactory, ngZone); });
	        };
	        PlatformRef_.prototype._moduleDoBootstrap = function (moduleRef) {
	            var appRef = moduleRef.injector.get(ApplicationRef);
	            if (moduleRef.bootstrapFactories.length > 0) {
	                moduleRef.bootstrapFactories.forEach(function (compFactory) { return appRef.bootstrap(compFactory); });
	            }
	            else if (moduleRef.instance.ngDoBootstrap) {
	                moduleRef.instance.ngDoBootstrap(appRef);
	            }
	            else {
	                throw new Error(("The module " + stringify(moduleRef.instance.constructor) + " was bootstrapped, but it does not declare \"@NgModule.bootstrap\" components nor a \"ngDoBootstrap\" method. ") +
	                    "Please define one of these.");
	            }
	        };
	        PlatformRef_.decorators = [
	            { type: Injectable },
	        ];
	        /** @nocollapse */
	        PlatformRef_.ctorParameters = [
	            { type: Injector, },
	        ];
	        return PlatformRef_;
	    }(PlatformRef));
	    /**
	     * A reference to an Angular application running on a page.
	     *
	     * For more about Angular applications, see the documentation for {@link bootstrap}.
	     *
	     * @stable
	     */
	    var ApplicationRef = (function () {
	        function ApplicationRef() {
	        }
	        Object.defineProperty(ApplicationRef.prototype, "componentTypes", {
	            /**
	             * Get a list of component types registered to this application.
	             * This list is populated even before the component is created.
	             */
	            get: function () { return unimplemented(); },
	            enumerable: true,
	            configurable: true
	        });
	        ;
	        Object.defineProperty(ApplicationRef.prototype, "components", {
	            /**
	             * Get a list of components registered to this application.
	             */
	            get: function () { return unimplemented(); },
	            enumerable: true,
	            configurable: true
	        });
	        ;
	        return ApplicationRef;
	    }());
	    var ApplicationRef_ = (function (_super) {
	        __extends$3(ApplicationRef_, _super);
	        function ApplicationRef_(_zone, _console, _injector, _exceptionHandler, _componentFactoryResolver, _initStatus, _testabilityRegistry, _testability) {
	            var _this = this;
	            _super.call(this);
	            this._zone = _zone;
	            this._console = _console;
	            this._injector = _injector;
	            this._exceptionHandler = _exceptionHandler;
	            this._componentFactoryResolver = _componentFactoryResolver;
	            this._initStatus = _initStatus;
	            this._testabilityRegistry = _testabilityRegistry;
	            this._testability = _testability;
	            this._bootstrapListeners = [];
	            this._rootComponents = [];
	            this._rootComponentTypes = [];
	            this._changeDetectorRefs = [];
	            this._runningTick = false;
	            this._enforceNoNewChanges = false;
	            this._enforceNoNewChanges = isDevMode();
	            this._zone.onMicrotaskEmpty.subscribe({ next: function () { _this._zone.run(function () { _this.tick(); }); } });
	        }
	        ApplicationRef_.prototype.registerChangeDetector = function (changeDetector) {
	            this._changeDetectorRefs.push(changeDetector);
	        };
	        ApplicationRef_.prototype.unregisterChangeDetector = function (changeDetector) {
	            ListWrapper.remove(this._changeDetectorRefs, changeDetector);
	        };
	        ApplicationRef_.prototype.bootstrap = function (componentOrFactory) {
	            var _this = this;
	            if (!this._initStatus.done) {
	                throw new Error('Cannot bootstrap as there are still asynchronous initializers running. Bootstrap components in the `ngDoBootstrap` method of the root module.');
	            }
	            var componentFactory;
	            if (componentOrFactory instanceof ComponentFactory) {
	                componentFactory = componentOrFactory;
	            }
	            else {
	                componentFactory = this._componentFactoryResolver.resolveComponentFactory(componentOrFactory);
	            }
	            this._rootComponentTypes.push(componentFactory.componentType);
	            var compRef = componentFactory.create(this._injector, [], componentFactory.selector);
	            compRef.onDestroy(function () { _this._unloadComponent(compRef); });
	            var testability = compRef.injector.get(Testability, null);
	            if (testability) {
	                compRef.injector.get(TestabilityRegistry)
	                    .registerApplication(compRef.location.nativeElement, testability);
	            }
	            this._loadComponent(compRef);
	            if (isDevMode()) {
	                this._console.log("Angular 2 is running in the development mode. Call enableProdMode() to enable the production mode.");
	            }
	            return compRef;
	        };
	        /** @internal */
	        ApplicationRef_.prototype._loadComponent = function (componentRef) {
	            this._changeDetectorRefs.push(componentRef.changeDetectorRef);
	            this.tick();
	            this._rootComponents.push(componentRef);
	            // Get the listeners lazily to prevent DI cycles.
	            var listeners = this._injector.get(APP_BOOTSTRAP_LISTENER, [])
	                .concat(this._bootstrapListeners);
	            listeners.forEach(function (listener) { return listener(componentRef); });
	        };
	        /** @internal */
	        ApplicationRef_.prototype._unloadComponent = function (componentRef) {
	            if (this._rootComponents.indexOf(componentRef) == -1) {
	                return;
	            }
	            this.unregisterChangeDetector(componentRef.changeDetectorRef);
	            ListWrapper.remove(this._rootComponents, componentRef);
	        };
	        ApplicationRef_.prototype.tick = function () {
	            if (this._runningTick) {
	                throw new Error('ApplicationRef.tick is called recursively');
	            }
	            var scope = ApplicationRef_._tickScope();
	            try {
	                this._runningTick = true;
	                this._changeDetectorRefs.forEach(function (detector) { return detector.detectChanges(); });
	                if (this._enforceNoNewChanges) {
	                    this._changeDetectorRefs.forEach(function (detector) { return detector.checkNoChanges(); });
	                }
	            }
	            finally {
	                this._runningTick = false;
	                wtfLeave(scope);
	            }
	        };
	        ApplicationRef_.prototype.ngOnDestroy = function () {
	            // TODO(alxhub): Dispose of the NgZone.
	            this._rootComponents.slice().forEach(function (component) { return component.destroy(); });
	        };
	        Object.defineProperty(ApplicationRef_.prototype, "componentTypes", {
	            get: function () { return this._rootComponentTypes; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(ApplicationRef_.prototype, "components", {
	            get: function () { return this._rootComponents; },
	            enumerable: true,
	            configurable: true
	        });
	        /** @internal */
	        ApplicationRef_._tickScope = wtfCreateScope('ApplicationRef#tick()');
	        ApplicationRef_.decorators = [
	            { type: Injectable },
	        ];
	        /** @nocollapse */
	        ApplicationRef_.ctorParameters = [
	            { type: NgZone, },
	            { type: Console, },
	            { type: Injector, },
	            { type: ErrorHandler, },
	            { type: ComponentFactoryResolver, },
	            { type: ApplicationInitStatus, },
	            { type: TestabilityRegistry, decorators: [{ type: Optional },] },
	            { type: Testability, decorators: [{ type: Optional },] },
	        ];
	        return ApplicationRef_;
	    }(ApplicationRef));

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$9 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    /**
	     * Represents an instance of an NgModule created via a {@link NgModuleFactory}.
	     *
	     * `NgModuleRef` provides access to the NgModule Instance as well other objects related to this
	     * NgModule Instance.
	     *
	     * @stable
	     */
	    var NgModuleRef = (function () {
	        function NgModuleRef() {
	        }
	        Object.defineProperty(NgModuleRef.prototype, "injector", {
	            /**
	             * The injector that contains all of the providers of the NgModule.
	             */
	            get: function () { return unimplemented(); },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(NgModuleRef.prototype, "componentFactoryResolver", {
	            /**
	             * The ComponentFactoryResolver to get hold of the ComponentFactories
	             * declared in the `entryComponents` property of the module.
	             */
	            get: function () { return unimplemented(); },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(NgModuleRef.prototype, "instance", {
	            /**
	             * The NgModule instance.
	             */
	            get: function () { return unimplemented(); },
	            enumerable: true,
	            configurable: true
	        });
	        return NgModuleRef;
	    }());
	    /**
	     * @experimental
	     */
	    var NgModuleFactory = (function () {
	        function NgModuleFactory(_injectorClass, _moduleType) {
	            this._injectorClass = _injectorClass;
	            this._moduleType = _moduleType;
	        }
	        Object.defineProperty(NgModuleFactory.prototype, "moduleType", {
	            get: function () { return this._moduleType; },
	            enumerable: true,
	            configurable: true
	        });
	        NgModuleFactory.prototype.create = function (parentInjector) {
	            if (!parentInjector) {
	                parentInjector = Injector.NULL;
	            }
	            var instance = new this._injectorClass(parentInjector);
	            instance.create();
	            return instance;
	        };
	        return NgModuleFactory;
	    }());
	    var _UNDEFINED = new Object();
	    var NgModuleInjector = (function (_super) {
	        __extends$9(NgModuleInjector, _super);
	        function NgModuleInjector(parent, factories, bootstrapFactories) {
	            _super.call(this, factories, parent.get(ComponentFactoryResolver, ComponentFactoryResolver.NULL));
	            this.parent = parent;
	            this.bootstrapFactories = bootstrapFactories;
	            this._destroyListeners = [];
	            this._destroyed = false;
	        }
	        NgModuleInjector.prototype.create = function () { this.instance = this.createInternal(); };
	        NgModuleInjector.prototype.get = function (token, notFoundValue) {
	            if (notFoundValue === void 0) { notFoundValue = THROW_IF_NOT_FOUND; }
	            if (token === Injector || token === ComponentFactoryResolver) {
	                return this;
	            }
	            var result = this.getInternal(token, _UNDEFINED);
	            return result === _UNDEFINED ? this.parent.get(token, notFoundValue) : result;
	        };
	        Object.defineProperty(NgModuleInjector.prototype, "injector", {
	            get: function () { return this; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(NgModuleInjector.prototype, "componentFactoryResolver", {
	            get: function () { return this; },
	            enumerable: true,
	            configurable: true
	        });
	        NgModuleInjector.prototype.destroy = function () {
	            if (this._destroyed) {
	                throw new Error("The ng module " + stringify(this.instance.constructor) + " has already been destroyed.");
	            }
	            this._destroyed = true;
	            this.destroyInternal();
	            this._destroyListeners.forEach(function (listener) { return listener(); });
	        };
	        NgModuleInjector.prototype.onDestroy = function (callback) { this._destroyListeners.push(callback); };
	        return NgModuleInjector;
	    }(CodegenComponentFactoryResolver));

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    /**
	     * Used to load ng module factories.
	     * @stable
	     */
	    var NgModuleFactoryLoader = (function () {
	        function NgModuleFactoryLoader() {
	        }
	        return NgModuleFactoryLoader;
	    }());
	    var moduleFactories = new Map();
	    /**
	     * Registers a loaded module. Should only be called from generated NgModuleFactory code.
	     * @experimental
	     */
	    function registerModuleFactory(id, factory) {
	        var existing = moduleFactories.get(id);
	        if (existing) {
	            throw new Error("Duplicate module registered for " + id + " - " + existing.moduleType.name + " vs " + factory.moduleType.name);
	        }
	        moduleFactories.set(id, factory);
	    }
	    /**
	     * Returns the NgModuleFactory with the given id, if it exists and has been loaded.
	     * Factories for modules that do not specify an `id` cannot be retrieved. Throws if the module
	     * cannot be found.
	     * @experimental
	     */
	    function getModuleFactory(id) {
	        var factory = moduleFactories.get(id);
	        if (!factory)
	            throw new Error("No module with ID " + id + " loaded");
	        return factory;
	    }

	    /**
	     * An unmodifiable list of items that Angular keeps up to date when the state
	     * of the application changes.
	     *
	     * The type of object that {@link Query} and {@link ViewQueryMetadata} provide.
	     *
	     * Implements an iterable interface, therefore it can be used in both ES6
	     * javascript `for (var i of items)` loops as well as in Angular templates with
	     * `*ngFor="let i of myList"`.
	     *
	     * Changes can be observed by subscribing to the changes `Observable`.
	     *
	     * NOTE: In the future this class will implement an `Observable` interface.
	     *
	     * ### Example ([live demo](http://plnkr.co/edit/RX8sJnQYl9FWuSCWme5z?p=preview))
	     * ```typescript
	     * @Component({...})
	     * class Container {
	     *   @ViewChildren(Item) items:QueryList<Item>;
	     * }
	     * ```
	     * @stable
	     */
	    var QueryList = (function () {
	        function QueryList() {
	            this._dirty = true;
	            this._results = [];
	            this._emitter = new EventEmitter();
	        }
	        Object.defineProperty(QueryList.prototype, "changes", {
	            get: function () { return this._emitter; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(QueryList.prototype, "length", {
	            get: function () { return this._results.length; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(QueryList.prototype, "first", {
	            get: function () { return this._results[0]; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(QueryList.prototype, "last", {
	            get: function () { return this._results[this.length - 1]; },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * See
	         * [Array.map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map)
	         */
	        QueryList.prototype.map = function (fn) { return this._results.map(fn); };
	        /**
	         * See
	         * [Array.filter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter)
	         */
	        QueryList.prototype.filter = function (fn) {
	            return this._results.filter(fn);
	        };
	        /**
	         * See
	         * [Array.reduce](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce)
	         */
	        QueryList.prototype.reduce = function (fn, init) {
	            return this._results.reduce(fn, init);
	        };
	        /**
	         * See
	         * [Array.forEach](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach)
	         */
	        QueryList.prototype.forEach = function (fn) { this._results.forEach(fn); };
	        /**
	         * See
	         * [Array.some](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some)
	         */
	        QueryList.prototype.some = function (fn) {
	            return this._results.some(fn);
	        };
	        QueryList.prototype.toArray = function () { return this._results.slice(); };
	        QueryList.prototype[getSymbolIterator()] = function () { return this._results[getSymbolIterator()](); };
	        QueryList.prototype.toString = function () { return this._results.toString(); };
	        QueryList.prototype.reset = function (res) {
	            this._results = ListWrapper.flatten(res);
	            this._dirty = false;
	        };
	        QueryList.prototype.notifyOnChanges = function () { this._emitter.emit(this); };
	        /** internal */
	        QueryList.prototype.setDirty = function () { this._dirty = true; };
	        Object.defineProperty(QueryList.prototype, "dirty", {
	            /** internal */
	            get: function () { return this._dirty; },
	            enumerable: true,
	            configurable: true
	        });
	        return QueryList;
	    }());

	    var _SEPARATOR = '#';
	    var FACTORY_CLASS_SUFFIX = 'NgFactory';
	    /**
	     * Configuration for SystemJsNgModuleLoader.
	     * token.
	     *
	     * @experimental
	     */
	    var SystemJsNgModuleLoaderConfig = (function () {
	        function SystemJsNgModuleLoaderConfig() {
	        }
	        return SystemJsNgModuleLoaderConfig;
	    }());
	    var DEFAULT_CONFIG = {
	        factoryPathPrefix: '',
	        factoryPathSuffix: '.ngfactory',
	    };
	    /**
	     * NgModuleFactoryLoader that uses SystemJS to load NgModuleFactory
	     * @experimental
	     */
	    var SystemJsNgModuleLoader = (function () {
	        function SystemJsNgModuleLoader(_compiler, config) {
	            this._compiler = _compiler;
	            this._config = config || DEFAULT_CONFIG;
	        }
	        SystemJsNgModuleLoader.prototype.load = function (path) {
	            var offlineMode = this._compiler instanceof Compiler;
	            return offlineMode ? this.loadFactory(path) : this.loadAndCompile(path);
	        };
	        SystemJsNgModuleLoader.prototype.loadAndCompile = function (path) {
	            var _this = this;
	            var _a = path.split(_SEPARATOR), module = _a[0], exportName = _a[1];
	            if (exportName === undefined)
	                exportName = 'default';
	            return System.import(module)
	                .then(function (module) { return module[exportName]; })
	                .then(function (type) { return checkNotEmpty(type, module, exportName); })
	                .then(function (type) { return _this._compiler.compileModuleAsync(type); });
	        };
	        SystemJsNgModuleLoader.prototype.loadFactory = function (path) {
	            var _a = path.split(_SEPARATOR), module = _a[0], exportName = _a[1];
	            var factoryClassSuffix = FACTORY_CLASS_SUFFIX;
	            if (exportName === undefined) {
	                exportName = 'default';
	                factoryClassSuffix = '';
	            }
	            return System.import(this._config.factoryPathPrefix + module + this._config.factoryPathSuffix)
	                .then(function (module) { return module[exportName + factoryClassSuffix]; })
	                .then(function (factory) { return checkNotEmpty(factory, module, exportName); });
	        };
	        SystemJsNgModuleLoader.decorators = [
	            { type: Injectable },
	        ];
	        /** @nocollapse */
	        SystemJsNgModuleLoader.ctorParameters = [
	            { type: Compiler, },
	            { type: SystemJsNgModuleLoaderConfig, decorators: [{ type: Optional },] },
	        ];
	        return SystemJsNgModuleLoader;
	    }());
	    function checkNotEmpty(value, modulePath, exportName) {
	        if (!value) {
	            throw new Error("Cannot find '" + exportName + "' in '" + modulePath + "'");
	        }
	        return value;
	    }

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$10 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    /**
	     * Represents an Embedded Template that can be used to instantiate Embedded Views.
	     *
	     * You can access a `TemplateRef`, in two ways. Via a directive placed on a `<template>` element (or
	     * directive prefixed with `*`) and have the `TemplateRef` for this Embedded View injected into the
	     * constructor of the directive using the `TemplateRef` Token. Alternatively you can query for the
	     * `TemplateRef` from a Component or a Directive via {@link Query}.
	     *
	     * To instantiate Embedded Views based on a Template, use
	     * {@link ViewContainerRef#createEmbeddedView}, which will create the View and attach it to the
	     * View Container.
	     * @stable
	     */
	    var TemplateRef = (function () {
	        function TemplateRef() {
	        }
	        Object.defineProperty(TemplateRef.prototype, "elementRef", {
	            /**
	             * The location in the View where the Embedded View logically belongs to.
	             *
	             * The data-binding and injection contexts of Embedded Views created from this `TemplateRef`
	             * inherit from the contexts of this location.
	             *
	             * Typically new Embedded Views are attached to the View Container of this location, but in
	             * advanced use-cases, the View can be attached to a different container while keeping the
	             * data-binding and injection context from the original location.
	             *
	             */
	            // TODO(i): rename to anchor or location
	            get: function () { return null; },
	            enumerable: true,
	            configurable: true
	        });
	        return TemplateRef;
	    }());
	    var TemplateRef_ = (function (_super) {
	        __extends$10(TemplateRef_, _super);
	        function TemplateRef_(_appElement, _viewFactory) {
	            _super.call(this);
	            this._appElement = _appElement;
	            this._viewFactory = _viewFactory;
	        }
	        TemplateRef_.prototype.createEmbeddedView = function (context) {
	            var view = this._viewFactory(this._appElement.parentView.viewUtils, this._appElement.parentInjector, this._appElement);
	            view.create(context || {}, null, null);
	            return view.ref;
	        };
	        Object.defineProperty(TemplateRef_.prototype, "elementRef", {
	            get: function () { return this._appElement.elementRef; },
	            enumerable: true,
	            configurable: true
	        });
	        return TemplateRef_;
	    }(TemplateRef));

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var _queuedAnimations = [];
	    /** @internal */
	    function queueAnimationGlobally(player) {
	        _queuedAnimations.push(player);
	    }
	    /** @internal */
	    function triggerQueuedAnimations() {
	        for (var i = 0; i < _queuedAnimations.length; i++) {
	            var player = _queuedAnimations[i];
	            player.play();
	        }
	        _queuedAnimations = [];
	    }

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$11 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    /**
	     * @stable
	     */
	    var ViewRef = (function () {
	        function ViewRef() {
	        }
	        Object.defineProperty(ViewRef.prototype, "destroyed", {
	            get: function () { return unimplemented(); },
	            enumerable: true,
	            configurable: true
	        });
	        return ViewRef;
	    }());
	    /**
	     * Represents an Angular View.
	     *
	     * <!-- TODO: move the next two paragraphs to the dev guide -->
	     * A View is a fundamental building block of the application UI. It is the smallest grouping of
	     * Elements which are created and destroyed together.
	     *
	     * Properties of elements in a View can change, but the structure (number and order) of elements in
	     * a View cannot. Changing the structure of Elements can only be done by inserting, moving or
	     * removing nested Views via a {@link ViewContainerRef}. Each View can contain many View Containers.
	     * <!-- /TODO -->
	     *
	     * ### Example
	     *
	     * Given this template...
	     *
	     * ```
	     * Count: {{items.length}}
	     * <ul>
	     *   <li *ngFor="let  item of items">{{item}}</li>
	     * </ul>
	     * ```
	     *
	     * We have two {@link TemplateRef}s:
	     *
	     * Outer {@link TemplateRef}:
	     * ```
	     * Count: {{items.length}}
	     * <ul>
	     *   <template ngFor let-item [ngForOf]="items"></template>
	     * </ul>
	     * ```
	     *
	     * Inner {@link TemplateRef}:
	     * ```
	     *   <li>{{item}}</li>
	     * ```
	     *
	     * Notice that the original template is broken down into two separate {@link TemplateRef}s.
	     *
	     * The outer/inner {@link TemplateRef}s are then assembled into views like so:
	     *
	     * ```
	     * <!-- ViewRef: outer-0 -->
	     * Count: 2
	     * <ul>
	     *   <template view-container-ref></template>
	     *   <!-- ViewRef: inner-1 --><li>first</li><!-- /ViewRef: inner-1 -->
	     *   <!-- ViewRef: inner-2 --><li>second</li><!-- /ViewRef: inner-2 -->
	     * </ul>
	     * <!-- /ViewRef: outer-0 -->
	     * ```
	     * @experimental
	     */
	    var EmbeddedViewRef = (function (_super) {
	        __extends$11(EmbeddedViewRef, _super);
	        function EmbeddedViewRef() {
	            _super.apply(this, arguments);
	        }
	        Object.defineProperty(EmbeddedViewRef.prototype, "context", {
	            get: function () { return unimplemented(); },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(EmbeddedViewRef.prototype, "rootNodes", {
	            get: function () { return unimplemented(); },
	            enumerable: true,
	            configurable: true
	        });
	        ;
	        return EmbeddedViewRef;
	    }(ViewRef));
	    var ViewRef_ = (function () {
	        function ViewRef_(_view) {
	            this._view = _view;
	            this._view = _view;
	            this._originalMode = this._view.cdMode;
	        }
	        Object.defineProperty(ViewRef_.prototype, "internalView", {
	            get: function () { return this._view; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(ViewRef_.prototype, "rootNodes", {
	            get: function () { return this._view.flatRootNodes; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(ViewRef_.prototype, "context", {
	            get: function () { return this._view.context; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(ViewRef_.prototype, "destroyed", {
	            get: function () { return this._view.destroyed; },
	            enumerable: true,
	            configurable: true
	        });
	        ViewRef_.prototype.markForCheck = function () { this._view.markPathToRootAsCheckOnce(); };
	        ViewRef_.prototype.detach = function () { this._view.cdMode = ChangeDetectorStatus.Detached; };
	        ViewRef_.prototype.detectChanges = function () {
	            this._view.detectChanges(false);
	            triggerQueuedAnimations();
	        };
	        ViewRef_.prototype.checkNoChanges = function () { this._view.detectChanges(true); };
	        ViewRef_.prototype.reattach = function () {
	            this._view.cdMode = this._originalMode;
	            this.markForCheck();
	        };
	        ViewRef_.prototype.onDestroy = function (callback) { this._view.disposables.push(callback); };
	        ViewRef_.prototype.destroy = function () { this._view.destroy(); };
	        return ViewRef_;
	    }());

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$12 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    var EventListener = (function () {
	        function EventListener(name, callback) {
	            this.name = name;
	            this.callback = callback;
	        }
	        ;
	        return EventListener;
	    }());
	    /**
	     * @experimental All debugging apis are currently experimental.
	     */
	    var DebugNode = (function () {
	        function DebugNode(nativeNode, parent, _debugInfo) {
	            this._debugInfo = _debugInfo;
	            this.nativeNode = nativeNode;
	            if (isPresent(parent) && parent instanceof DebugElement) {
	                parent.addChild(this);
	            }
	            else {
	                this.parent = null;
	            }
	            this.listeners = [];
	        }
	        Object.defineProperty(DebugNode.prototype, "injector", {
	            get: function () { return isPresent(this._debugInfo) ? this._debugInfo.injector : null; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(DebugNode.prototype, "componentInstance", {
	            get: function () {
	                return isPresent(this._debugInfo) ? this._debugInfo.component : null;
	            },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(DebugNode.prototype, "context", {
	            get: function () { return isPresent(this._debugInfo) ? this._debugInfo.context : null; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(DebugNode.prototype, "references", {
	            get: function () {
	                return isPresent(this._debugInfo) ? this._debugInfo.references : null;
	            },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(DebugNode.prototype, "providerTokens", {
	            get: function () {
	                return isPresent(this._debugInfo) ? this._debugInfo.providerTokens : null;
	            },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(DebugNode.prototype, "source", {
	            get: function () { return isPresent(this._debugInfo) ? this._debugInfo.source : null; },
	            enumerable: true,
	            configurable: true
	        });
	        return DebugNode;
	    }());
	    /**
	     * @experimental All debugging apis are currently experimental.
	     */
	    var DebugElement = (function (_super) {
	        __extends$12(DebugElement, _super);
	        function DebugElement(nativeNode, parent, _debugInfo) {
	            _super.call(this, nativeNode, parent, _debugInfo);
	            this.properties = {};
	            this.attributes = {};
	            this.classes = {};
	            this.styles = {};
	            this.childNodes = [];
	            this.nativeElement = nativeNode;
	        }
	        DebugElement.prototype.addChild = function (child) {
	            if (isPresent(child)) {
	                this.childNodes.push(child);
	                child.parent = this;
	            }
	        };
	        DebugElement.prototype.removeChild = function (child) {
	            var childIndex = this.childNodes.indexOf(child);
	            if (childIndex !== -1) {
	                child.parent = null;
	                this.childNodes.splice(childIndex, 1);
	            }
	        };
	        DebugElement.prototype.insertChildrenAfter = function (child, newChildren) {
	            var siblingIndex = this.childNodes.indexOf(child);
	            if (siblingIndex !== -1) {
	                var previousChildren = this.childNodes.slice(0, siblingIndex + 1);
	                var nextChildren = this.childNodes.slice(siblingIndex + 1);
	                this.childNodes = previousChildren.concat(newChildren, nextChildren);
	                for (var i = 0; i < newChildren.length; ++i) {
	                    var newChild = newChildren[i];
	                    if (isPresent(newChild.parent)) {
	                        newChild.parent.removeChild(newChild);
	                    }
	                    newChild.parent = this;
	                }
	            }
	        };
	        DebugElement.prototype.query = function (predicate) {
	            var results = this.queryAll(predicate);
	            return results.length > 0 ? results[0] : null;
	        };
	        DebugElement.prototype.queryAll = function (predicate) {
	            var matches = [];
	            _queryElementChildren(this, predicate, matches);
	            return matches;
	        };
	        DebugElement.prototype.queryAllNodes = function (predicate) {
	            var matches = [];
	            _queryNodeChildren(this, predicate, matches);
	            return matches;
	        };
	        Object.defineProperty(DebugElement.prototype, "children", {
	            get: function () {
	                var children = [];
	                this.childNodes.forEach(function (node) {
	                    if (node instanceof DebugElement) {
	                        children.push(node);
	                    }
	                });
	                return children;
	            },
	            enumerable: true,
	            configurable: true
	        });
	        DebugElement.prototype.triggerEventHandler = function (eventName, eventObj) {
	            this.listeners.forEach(function (listener) {
	                if (listener.name == eventName) {
	                    listener.callback(eventObj);
	                }
	            });
	        };
	        return DebugElement;
	    }(DebugNode));
	    /**
	     * @experimental
	     */
	    function asNativeElements(debugEls) {
	        return debugEls.map(function (el) { return el.nativeElement; });
	    }
	    function _queryElementChildren(element, predicate, matches) {
	        element.childNodes.forEach(function (node) {
	            if (node instanceof DebugElement) {
	                if (predicate(node)) {
	                    matches.push(node);
	                }
	                _queryElementChildren(node, predicate, matches);
	            }
	        });
	    }
	    function _queryNodeChildren(parentNode, predicate, matches) {
	        if (parentNode instanceof DebugElement) {
	            parentNode.childNodes.forEach(function (node) {
	                if (predicate(node)) {
	                    matches.push(node);
	                }
	                if (node instanceof DebugElement) {
	                    _queryNodeChildren(node, predicate, matches);
	                }
	            });
	        }
	    }
	    // Need to keep the nodes in a global Map so that multiple angular apps are supported.
	    var _nativeNodeToDebugNode = new Map();
	    /**
	     * @experimental
	     */
	    function getDebugNode(nativeNode) {
	        return _nativeNodeToDebugNode.get(nativeNode);
	    }
	    function indexDebugNode(node) {
	        _nativeNodeToDebugNode.set(node.nativeNode, node);
	    }
	    function removeDebugNodeFromIndex(node) {
	        _nativeNodeToDebugNode.delete(node.nativeNode);
	    }

	    function _reflector() {
	        return reflector;
	    }
	    var _CORE_PLATFORM_PROVIDERS = [
	        PlatformRef_,
	        { provide: PlatformRef, useExisting: PlatformRef_ },
	        { provide: Reflector, useFactory: _reflector, deps: [] },
	        { provide: ReflectorReader, useExisting: Reflector },
	        TestabilityRegistry,
	        Console,
	    ];
	    /**
	     * This platform has to be included in any other platform
	     *
	     * @experimental
	     */
	    var platformCore = createPlatformFactory(null, 'core', _CORE_PLATFORM_PROVIDERS);

	    /**
	     * @experimental i18n support is experimental.
	     */
	    var LOCALE_ID = new OpaqueToken('LocaleId');
	    /**
	     * @experimental i18n support is experimental.
	     */
	    var TRANSLATIONS = new OpaqueToken('Translations');
	    /**
	     * @experimental i18n support is experimental.
	     */
	    var TRANSLATIONS_FORMAT = new OpaqueToken('TranslationsFormat');

	    function _iterableDiffersFactory() {
	        return defaultIterableDiffers;
	    }
	    function _keyValueDiffersFactory() {
	        return defaultKeyValueDiffers;
	    }
	    /**
	     * This module includes the providers of @angular/core that are needed
	     * to bootstrap components via `ApplicationRef`.
	     *
	     * @experimental
	     */
	    var ApplicationModule = (function () {
	        function ApplicationModule() {
	        }
	        ApplicationModule.decorators = [
	            { type: NgModule, args: [{
	                        providers: [
	                            ApplicationRef_,
	                            { provide: ApplicationRef, useExisting: ApplicationRef_ },
	                            ApplicationInitStatus,
	                            Compiler,
	                            APP_ID_RANDOM_PROVIDER,
	                            ViewUtils,
	                            { provide: IterableDiffers, useFactory: _iterableDiffersFactory },
	                            { provide: KeyValueDiffers, useFactory: _keyValueDiffersFactory },
	                            { provide: LOCALE_ID, useValue: 'en-US' },
	                        ]
	                    },] },
	        ];
	        /** @nocollapse */
	        ApplicationModule.ctorParameters = [];
	        return ApplicationModule;
	    }());

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var FILL_STYLE_FLAG = 'true'; // TODO (matsko): change to boolean
	    var ANY_STATE = '*';
	    var DEFAULT_STATE = '*';
	    var EMPTY_STATE = 'void';

	    var AnimationGroupPlayer = (function () {
	        function AnimationGroupPlayer(_players) {
	            var _this = this;
	            this._players = _players;
	            this._onDoneFns = [];
	            this._onStartFns = [];
	            this._finished = false;
	            this._started = false;
	            this.parentPlayer = null;
	            var count = 0;
	            var total = this._players.length;
	            if (total == 0) {
	                scheduleMicroTask(function () { return _this._onFinish(); });
	            }
	            else {
	                this._players.forEach(function (player) {
	                    player.parentPlayer = _this;
	                    player.onDone(function () {
	                        if (++count >= total) {
	                            _this._onFinish();
	                        }
	                    });
	                });
	            }
	        }
	        AnimationGroupPlayer.prototype._onFinish = function () {
	            if (!this._finished) {
	                this._finished = true;
	                if (!isPresent(this.parentPlayer)) {
	                    this.destroy();
	                }
	                this._onDoneFns.forEach(function (fn) { return fn(); });
	                this._onDoneFns = [];
	            }
	        };
	        AnimationGroupPlayer.prototype.init = function () { this._players.forEach(function (player) { return player.init(); }); };
	        AnimationGroupPlayer.prototype.onStart = function (fn) { this._onStartFns.push(fn); };
	        AnimationGroupPlayer.prototype.onDone = function (fn) { this._onDoneFns.push(fn); };
	        AnimationGroupPlayer.prototype.hasStarted = function () { return this._started; };
	        AnimationGroupPlayer.prototype.play = function () {
	            if (!isPresent(this.parentPlayer)) {
	                this.init();
	            }
	            if (!this.hasStarted()) {
	                this._onStartFns.forEach(function (fn) { return fn(); });
	                this._onStartFns = [];
	                this._started = true;
	            }
	            this._players.forEach(function (player) { return player.play(); });
	        };
	        AnimationGroupPlayer.prototype.pause = function () { this._players.forEach(function (player) { return player.pause(); }); };
	        AnimationGroupPlayer.prototype.restart = function () { this._players.forEach(function (player) { return player.restart(); }); };
	        AnimationGroupPlayer.prototype.finish = function () {
	            this._onFinish();
	            this._players.forEach(function (player) { return player.finish(); });
	        };
	        AnimationGroupPlayer.prototype.destroy = function () {
	            this._onFinish();
	            this._players.forEach(function (player) { return player.destroy(); });
	        };
	        AnimationGroupPlayer.prototype.reset = function () { this._players.forEach(function (player) { return player.reset(); }); };
	        AnimationGroupPlayer.prototype.setPosition = function (p /** TODO #9100 */) {
	            this._players.forEach(function (player) { player.setPosition(p); });
	        };
	        AnimationGroupPlayer.prototype.getPosition = function () {
	            var min = 0;
	            this._players.forEach(function (player) {
	                var p = player.getPosition();
	                min = Math.min(p, min);
	            });
	            return min;
	        };
	        return AnimationGroupPlayer;
	    }());

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var AnimationKeyframe = (function () {
	        function AnimationKeyframe(offset, styles) {
	            this.offset = offset;
	            this.styles = styles;
	        }
	        return AnimationKeyframe;
	    }());

	    /**
	     * @experimental Animation support is experimental.
	     */
	    var AnimationPlayer = (function () {
	        function AnimationPlayer() {
	        }
	        Object.defineProperty(AnimationPlayer.prototype, "parentPlayer", {
	            get: function () { throw new Error('NOT IMPLEMENTED: Base Class'); },
	            set: function (player) { throw new Error('NOT IMPLEMENTED: Base Class'); },
	            enumerable: true,
	            configurable: true
	        });
	        return AnimationPlayer;
	    }());
	    var NoOpAnimationPlayer = (function () {
	        function NoOpAnimationPlayer() {
	            var _this = this;
	            this._onDoneFns = [];
	            this._onStartFns = [];
	            this._started = false;
	            this.parentPlayer = null;
	            scheduleMicroTask(function () { return _this._onFinish(); });
	        }
	        /** @internal */
	        NoOpAnimationPlayer.prototype._onFinish = function () {
	            this._onDoneFns.forEach(function (fn) { return fn(); });
	            this._onDoneFns = [];
	        };
	        NoOpAnimationPlayer.prototype.onStart = function (fn) { this._onStartFns.push(fn); };
	        NoOpAnimationPlayer.prototype.onDone = function (fn) { this._onDoneFns.push(fn); };
	        NoOpAnimationPlayer.prototype.hasStarted = function () { return this._started; };
	        NoOpAnimationPlayer.prototype.init = function () { };
	        NoOpAnimationPlayer.prototype.play = function () {
	            if (!this.hasStarted()) {
	                this._onStartFns.forEach(function (fn) { return fn(); });
	                this._onStartFns = [];
	            }
	            this._started = true;
	        };
	        NoOpAnimationPlayer.prototype.pause = function () { };
	        NoOpAnimationPlayer.prototype.restart = function () { };
	        NoOpAnimationPlayer.prototype.finish = function () { this._onFinish(); };
	        NoOpAnimationPlayer.prototype.destroy = function () { };
	        NoOpAnimationPlayer.prototype.reset = function () { };
	        NoOpAnimationPlayer.prototype.setPosition = function (p /** TODO #9100 */) { };
	        NoOpAnimationPlayer.prototype.getPosition = function () { return 0; };
	        return NoOpAnimationPlayer;
	    }());

	    var AnimationSequencePlayer = (function () {
	        function AnimationSequencePlayer(_players) {
	            var _this = this;
	            this._players = _players;
	            this._currentIndex = 0;
	            this._onDoneFns = [];
	            this._onStartFns = [];
	            this._finished = false;
	            this._started = false;
	            this.parentPlayer = null;
	            this._players.forEach(function (player) { player.parentPlayer = _this; });
	            this._onNext(false);
	        }
	        AnimationSequencePlayer.prototype._onNext = function (start) {
	            var _this = this;
	            if (this._finished)
	                return;
	            if (this._players.length == 0) {
	                this._activePlayer = new NoOpAnimationPlayer();
	                scheduleMicroTask(function () { return _this._onFinish(); });
	            }
	            else if (this._currentIndex >= this._players.length) {
	                this._activePlayer = new NoOpAnimationPlayer();
	                this._onFinish();
	            }
	            else {
	                var player = this._players[this._currentIndex++];
	                player.onDone(function () { return _this._onNext(true); });
	                this._activePlayer = player;
	                if (start) {
	                    player.play();
	                }
	            }
	        };
	        AnimationSequencePlayer.prototype._onFinish = function () {
	            if (!this._finished) {
	                this._finished = true;
	                if (!isPresent(this.parentPlayer)) {
	                    this.destroy();
	                }
	                this._onDoneFns.forEach(function (fn) { return fn(); });
	                this._onDoneFns = [];
	            }
	        };
	        AnimationSequencePlayer.prototype.init = function () { this._players.forEach(function (player) { return player.init(); }); };
	        AnimationSequencePlayer.prototype.onStart = function (fn) { this._onStartFns.push(fn); };
	        AnimationSequencePlayer.prototype.onDone = function (fn) { this._onDoneFns.push(fn); };
	        AnimationSequencePlayer.prototype.hasStarted = function () { return this._started; };
	        AnimationSequencePlayer.prototype.play = function () {
	            if (!isPresent(this.parentPlayer)) {
	                this.init();
	            }
	            if (!this.hasStarted()) {
	                this._onStartFns.forEach(function (fn) { return fn(); });
	                this._onStartFns = [];
	                this._started = true;
	            }
	            this._activePlayer.play();
	        };
	        AnimationSequencePlayer.prototype.pause = function () { this._activePlayer.pause(); };
	        AnimationSequencePlayer.prototype.restart = function () {
	            if (this._players.length > 0) {
	                this.reset();
	                this._players[0].restart();
	            }
	        };
	        AnimationSequencePlayer.prototype.reset = function () { this._players.forEach(function (player) { return player.reset(); }); };
	        AnimationSequencePlayer.prototype.finish = function () {
	            this._onFinish();
	            this._players.forEach(function (player) { return player.finish(); });
	        };
	        AnimationSequencePlayer.prototype.destroy = function () {
	            this._onFinish();
	            this._players.forEach(function (player) { return player.destroy(); });
	        };
	        AnimationSequencePlayer.prototype.setPosition = function (p /** TODO #9100 */) { this._players[0].setPosition(p); };
	        AnimationSequencePlayer.prototype.getPosition = function () { return this._players[0].getPosition(); };
	        return AnimationSequencePlayer;
	    }());

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$13 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    /**
	     * @experimental Animation support is experimental.
	     */
	    var AUTO_STYLE = '*';
	    /**
	     * Metadata representing the entry of animations.
	     * Instances of this class are provided via the animation DSL when the {@link trigger trigger
	     * animation function} is called.
	     *
	     * @experimental Animation support is experimental.
	     */
	    var AnimationEntryMetadata = (function () {
	        function AnimationEntryMetadata(name, definitions) {
	            this.name = name;
	            this.definitions = definitions;
	        }
	        return AnimationEntryMetadata;
	    }());
	    /**
	     * @experimental Animation support is experimental.
	     */
	    var AnimationStateMetadata = (function () {
	        function AnimationStateMetadata() {
	        }
	        return AnimationStateMetadata;
	    }());
	    /**
	     * Metadata representing the entry of animations.
	     * Instances of this class are provided via the animation DSL when the {@link state state animation
	     * function} is called.
	     *
	     * @experimental Animation support is experimental.
	     */
	    var AnimationStateDeclarationMetadata = (function (_super) {
	        __extends$13(AnimationStateDeclarationMetadata, _super);
	        function AnimationStateDeclarationMetadata(stateNameExpr, styles) {
	            _super.call(this);
	            this.stateNameExpr = stateNameExpr;
	            this.styles = styles;
	        }
	        return AnimationStateDeclarationMetadata;
	    }(AnimationStateMetadata));
	    /**
	     * Metadata representing the entry of animations.
	     * Instances of this class are provided via the animation DSL when the
	     * {@link transition transition animation function} is called.
	     *
	     * @experimental Animation support is experimental.
	     */
	    var AnimationStateTransitionMetadata = (function (_super) {
	        __extends$13(AnimationStateTransitionMetadata, _super);
	        function AnimationStateTransitionMetadata(stateChangeExpr, steps) {
	            _super.call(this);
	            this.stateChangeExpr = stateChangeExpr;
	            this.steps = steps;
	        }
	        return AnimationStateTransitionMetadata;
	    }(AnimationStateMetadata));
	    /**
	     * @experimental Animation support is experimental.
	     */
	    var AnimationMetadata = (function () {
	        function AnimationMetadata() {
	        }
	        return AnimationMetadata;
	    }());
	    /**
	     * Metadata representing the entry of animations.
	     * Instances of this class are provided via the animation DSL when the {@link keyframes keyframes
	     * animation function} is called.
	     *
	     * @experimental Animation support is experimental.
	     */
	    var AnimationKeyframesSequenceMetadata = (function (_super) {
	        __extends$13(AnimationKeyframesSequenceMetadata, _super);
	        function AnimationKeyframesSequenceMetadata(steps) {
	            _super.call(this);
	            this.steps = steps;
	        }
	        return AnimationKeyframesSequenceMetadata;
	    }(AnimationMetadata));
	    /**
	     * Metadata representing the entry of animations.
	     * Instances of this class are provided via the animation DSL when the {@link style style animation
	     * function} is called.
	     *
	     * @experimental Animation support is experimental.
	     */
	    var AnimationStyleMetadata = (function (_super) {
	        __extends$13(AnimationStyleMetadata, _super);
	        function AnimationStyleMetadata(styles, offset) {
	            if (offset === void 0) { offset = null; }
	            _super.call(this);
	            this.styles = styles;
	            this.offset = offset;
	        }
	        return AnimationStyleMetadata;
	    }(AnimationMetadata));
	    /**
	     * Metadata representing the entry of animations.
	     * Instances of this class are provided via the animation DSL when the {@link animate animate
	     * animation function} is called.
	     *
	     * @experimental Animation support is experimental.
	     */
	    var AnimationAnimateMetadata = (function (_super) {
	        __extends$13(AnimationAnimateMetadata, _super);
	        function AnimationAnimateMetadata(timings, styles) {
	            _super.call(this);
	            this.timings = timings;
	            this.styles = styles;
	        }
	        return AnimationAnimateMetadata;
	    }(AnimationMetadata));
	    /**
	     * @experimental Animation support is experimental.
	     */
	    var AnimationWithStepsMetadata = (function (_super) {
	        __extends$13(AnimationWithStepsMetadata, _super);
	        function AnimationWithStepsMetadata() {
	            _super.call(this);
	        }
	        Object.defineProperty(AnimationWithStepsMetadata.prototype, "steps", {
	            get: function () { throw new Error('NOT IMPLEMENTED: Base Class'); },
	            enumerable: true,
	            configurable: true
	        });
	        return AnimationWithStepsMetadata;
	    }(AnimationMetadata));
	    /**
	     * Metadata representing the entry of animations.
	     * Instances of this class are provided via the animation DSL when the {@link sequence sequence
	     * animation function} is called.
	     *
	     * @experimental Animation support is experimental.
	     */
	    var AnimationSequenceMetadata = (function (_super) {
	        __extends$13(AnimationSequenceMetadata, _super);
	        function AnimationSequenceMetadata(_steps) {
	            _super.call(this);
	            this._steps = _steps;
	        }
	        Object.defineProperty(AnimationSequenceMetadata.prototype, "steps", {
	            get: function () { return this._steps; },
	            enumerable: true,
	            configurable: true
	        });
	        return AnimationSequenceMetadata;
	    }(AnimationWithStepsMetadata));
	    /**
	     * Metadata representing the entry of animations.
	     * Instances of this class are provided via the animation DSL when the {@link group group animation
	     * function} is called.
	     *
	     * @experimental Animation support is experimental.
	     */
	    var AnimationGroupMetadata = (function (_super) {
	        __extends$13(AnimationGroupMetadata, _super);
	        function AnimationGroupMetadata(_steps) {
	            _super.call(this);
	            this._steps = _steps;
	        }
	        Object.defineProperty(AnimationGroupMetadata.prototype, "steps", {
	            get: function () { return this._steps; },
	            enumerable: true,
	            configurable: true
	        });
	        return AnimationGroupMetadata;
	    }(AnimationWithStepsMetadata));
	    /**
	     * `animate` is an animation-specific function that is designed to be used inside of Angular2's
	     * animation
	     * DSL language. If this information is new, please navigate to the
	     * {@link Component#animations-anchor component animations metadata
	     * page} to gain a better understanding of how animations in Angular2 are used.
	     *
	     * `animate` specifies an animation step that will apply the provided `styles` data for a given
	     * amount of
	     * time based on the provided `timing` expression value. Calls to `animate` are expected to be
	     * used within {@link sequence an animation sequence}, {@link group group}, or {@link transition
	     * transition}.
	     *
	     * ### Usage
	     *
	     * The `animate` function accepts two input parameters: `timing` and `styles`:
	     *
	     * - `timing` is a string based value that can be a combination of a duration with optional
	     * delay and easing values. The format for the expression breaks down to `duration delay easing`
	     * (therefore a value such as `1s 100ms ease-out` will be parse itself into `duration=1000,
	     * delay=100, easing=ease-out`.
	     * If a numeric value is provided then that will be used as the `duration` value in millisecond
	     * form.
	     * - `styles` is the style input data which can either be a call to {@link style style} or {@link
	     * keyframes keyframes}.
	     * If left empty then the styles from the destination state will be collected and used (this is
	     * useful when
	     * describing an animation step that will complete an animation by {@link
	     * transition#the-final-animate-call animating to the final state}).
	     *
	     * ```typescript
	     * // various functions for specifying timing data
	     * animate(500, style(...))
	     * animate("1s", style(...))
	     * animate("100ms 0.5s", style(...))
	     * animate("5s ease", style(...))
	     * animate("5s 10ms cubic-bezier(.17,.67,.88,.1)", style(...))
	     *
	     * // either style() of keyframes() can be used
	     * animate(500, style({ background: "red" }))
	     * animate(500, keyframes([
	     *   style({ background: "blue" })),
	     *   style({ background: "red" }))
	     * ])
	     * ```
	     *
	     * ### Example ([live demo](http://plnkr.co/edit/Kez8XGWBxWue7qP7nNvF?p=preview))
	     *
	     * {@example core/animation/ts/dsl/animation_example.ts region='Component'}
	     *
	     * @experimental Animation support is experimental.
	     */
	    function animate(timing, styles) {
	        if (styles === void 0) { styles = null; }
	        var stylesEntry = styles;
	        if (!isPresent(stylesEntry)) {
	            var EMPTY_STYLE = {};
	            stylesEntry = new AnimationStyleMetadata([EMPTY_STYLE], 1);
	        }
	        return new AnimationAnimateMetadata(timing, stylesEntry);
	    }
	    /**
	     * `group` is an animation-specific function that is designed to be used inside of Angular2's
	     * animation
	     * DSL language. If this information is new, please navigate to the
	     * {@link Component#animations-anchor component animations metadata
	     * page} to gain a better understanding of how animations in Angular2 are used.
	     *
	     * `group` specifies a list of animation steps that are all run in parallel. Grouped animations
	     * are useful when a series of styles must be animated/closed off
	     * at different statrting/ending times.
	     *
	     * The `group` function can either be used within a {@link sequence sequence} or a {@link transition
	     * transition}
	     * and it will only continue to the next instruction once all of the inner animation steps
	     * have completed.
	     *
	     * ### Usage
	     *
	     * The `steps` data that is passed into the `group` animation function can either consist
	     * of {@link style style} or {@link animate animate} function calls. Each call to `style()` or
	     * `animate()`
	     * within a group will be executed instantly (use {@link keyframes keyframes} or a
	     * {@link animate#usage animate() with a delay value} to offset styles to be applied at a later
	     * time).
	     *
	     * ```typescript
	     * group([
	     *   animate("1s", { background: "black" }))
	     *   animate("2s", { color: "white" }))
	     * ])
	     * ```
	     *
	     * ### Example ([live demo](http://plnkr.co/edit/Kez8XGWBxWue7qP7nNvF?p=preview))
	     *
	     * {@example core/animation/ts/dsl/animation_example.ts region='Component'}
	     *
	     * @experimental Animation support is experimental.
	     */
	    function group(steps) {
	        return new AnimationGroupMetadata(steps);
	    }
	    /**
	     * `sequence` is an animation-specific function that is designed to be used inside of Angular2's
	     * animation
	     * DSL language. If this information is new, please navigate to the
	     * {@link Component#animations-anchor component animations metadata
	     * page} to gain a better understanding of how animations in Angular2 are used.
	     *
	     * `sequence` Specifies a list of animation steps that are run one by one. (`sequence` is used
	     * by default when an array is passed as animation data into {@link transition transition}.)
	     *
	     * The `sequence` function can either be used within a {@link group group} or a {@link transition
	     * transition}
	     * and it will only continue to the next instruction once each of the inner animation steps
	     * have completed.
	     *
	     * To perform animation styling in parallel with other animation steps then
	     * have a look at the {@link group group} animation function.
	     *
	     * ### Usage
	     *
	     * The `steps` data that is passed into the `sequence` animation function can either consist
	     * of {@link style style} or {@link animate animate} function calls. A call to `style()` will apply
	     * the
	     * provided styling data immediately while a call to `animate()` will apply its styling
	     * data over a given time depending on its timing data.
	     *
	     * ```typescript
	     * sequence([
	     *   style({ opacity: 0 })),
	     *   animate("1s", { opacity: 1 }))
	     * ])
	     * ```
	     *
	     * ### Example ([live demo](http://plnkr.co/edit/Kez8XGWBxWue7qP7nNvF?p=preview))
	     *
	     * {@example core/animation/ts/dsl/animation_example.ts region='Component'}
	     *
	     * @experimental Animation support is experimental.
	     */
	    function sequence(steps) {
	        return new AnimationSequenceMetadata(steps);
	    }
	    /**
	     * `style` is an animation-specific function that is designed to be used inside of Angular2's
	     * animation
	     * DSL language. If this information is new, please navigate to the
	     * {@link Component#animations-anchor component animations metadata
	     * page} to gain a better understanding of how animations in Angular2 are used.
	     *
	     * `style` declares a key/value object containing CSS properties/styles that can then
	     * be used for {@link state animation states}, within an {@link sequence animation sequence}, or as
	     * styling data for both {@link animate animate} and {@link keyframes keyframes}.
	     *
	     * ### Usage
	     *
	     * `style` takes in a key/value string map as data and expects one or more CSS property/value
	     * pairs to be defined.
	     *
	     * ```typescript
	     * // string values are used for css properties
	     * style({ background: "red", color: "blue" })
	     *
	     * // numerical (pixel) values are also supported
	     * style({ width: 100, height: 0 })
	     * ```
	     *
	     * #### Auto-styles (using `*`)
	     *
	     * When an asterix (`*`) character is used as a value then it will be detected from the element
	     * being animated
	     * and applied as animation data when the animation starts.
	     *
	     * This feature proves useful for a state depending on layout and/or environment factors; in such
	     * cases
	     * the styles are calculated just before the animation starts.
	     *
	     * ```typescript
	     * // the steps below will animate from 0 to the
	     * // actual height of the element
	     * style({ height: 0 }),
	     * animate("1s", style({ height: "*" }))
	     * ```
	     *
	     * ### Example ([live demo](http://plnkr.co/edit/Kez8XGWBxWue7qP7nNvF?p=preview))
	     *
	     * {@example core/animation/ts/dsl/animation_example.ts region='Component'}
	     *
	     * @experimental Animation support is experimental.
	     */
	    function style(tokens) {
	        var input;
	        var offset = null;
	        if (typeof tokens === 'string') {
	            input = [tokens];
	        }
	        else {
	            if (Array.isArray(tokens)) {
	                input = tokens;
	            }
	            else {
	                input = [tokens];
	            }
	            input.forEach(function (entry) {
	                var entryOffset = entry['offset'];
	                if (isPresent(entryOffset)) {
	                    offset = offset == null ? parseFloat(entryOffset) : offset;
	                }
	            });
	        }
	        return new AnimationStyleMetadata(input, offset);
	    }
	    /**
	     * `state` is an animation-specific function that is designed to be used inside of Angular2's
	     * animation
	     * DSL language. If this information is new, please navigate to the
	     * {@link Component#animations-anchor component animations metadata
	     * page} to gain a better understanding of how animations in Angular2 are used.
	     *
	     * `state` declares an animation state within the given trigger. When a state is
	     * active within a component then its associated styles will persist on
	     * the element that the trigger is attached to (even when the animation ends).
	     *
	     * To animate between states, have a look at the animation {@link transition transition}
	     * DSL function. To register states to an animation trigger please have a look
	     * at the {@link trigger trigger} function.
	     *
	     * #### The `void` state
	     *
	     * The `void` state value is a reserved word that angular uses to determine when the element is not
	     * apart
	     * of the application anymore (e.g. when an `ngIf` evaluates to false then the state of the
	     * associated element
	     * is void).
	     *
	     * #### The `*` (default) state
	     *
	     * The `*` state (when styled) is a fallback state that will be used if
	     * the state that is being animated is not declared within the trigger.
	     *
	     * ### Usage
	     *
	     * `state` will declare an animation state with its associated styles
	     * within the given trigger.
	     *
	     * - `stateNameExpr` can be one or more state names separated by commas.
	     * - `styles` refers to the {@link style styling data} that will be persisted on the element once
	     * the state
	     * has been reached.
	     *
	     * ```typescript
	     * // "void" is a reserved name for a state and is used to represent
	     * // the state in which an element is detached from from the application.
	     * state("void", style({ height: 0 }))
	     *
	     * // user-defined states
	     * state("closed", style({ height: 0 }))
	     * state("open, visible", style({ height: "*" }))
	     * ```
	     *
	     * ### Example ([live demo](http://plnkr.co/edit/Kez8XGWBxWue7qP7nNvF?p=preview))
	     *
	     * {@example core/animation/ts/dsl/animation_example.ts region='Component'}
	     *
	     * @experimental Animation support is experimental.
	     */
	    function state(stateNameExpr, styles) {
	        return new AnimationStateDeclarationMetadata(stateNameExpr, styles);
	    }
	    /**
	     * `keyframes` is an animation-specific function that is designed to be used inside of Angular2's
	     * animation
	     * DSL language. If this information is new, please navigate to the
	     * {@link Component#animations-anchor component animations metadata
	     * page} to gain a better understanding of how animations in Angular2 are used.
	     *
	     * `keyframes` specifies a collection of {@link style style} entries each optionally characterized
	     * by an `offset` value.
	     *
	     * ### Usage
	     *
	     * The `keyframes` animation function is designed to be used alongside the {@link animate animate}
	     * animation function. Instead of applying animations from where they are
	     * currently to their destination, keyframes can describe how each style entry is applied
	     * and at what point within the animation arc (much like CSS Keyframe Animations do).
	     *
	     * For each `style()` entry an `offset` value can be set. Doing so allows to specifiy at
	     * what percentage of the animate time the styles will be applied.
	     *
	     * ```typescript
	     * // the provided offset values describe when each backgroundColor value is applied.
	     * animate("5s", keyframes([
	     *   style({ backgroundColor: "red", offset: 0 }),
	     *   style({ backgroundColor: "blue", offset: 0.2 }),
	     *   style({ backgroundColor: "orange", offset: 0.3 }),
	     *   style({ backgroundColor: "black", offset: 1 })
	     * ]))
	     * ```
	     *
	     * Alternatively, if there are no `offset` values used within the style entries then the offsets
	     * will
	     * be calculated automatically.
	     *
	     * ```typescript
	     * animate("5s", keyframes([
	     *   style({ backgroundColor: "red" }) // offset = 0
	     *   style({ backgroundColor: "blue" }) // offset = 0.33
	     *   style({ backgroundColor: "orange" }) // offset = 0.66
	     *   style({ backgroundColor: "black" }) // offset = 1
	     * ]))
	     * ```
	     *
	     * ### Example ([live demo](http://plnkr.co/edit/Kez8XGWBxWue7qP7nNvF?p=preview))
	     *
	     * {@example core/animation/ts/dsl/animation_example.ts region='Component'}
	     *
	     * @experimental Animation support is experimental.
	     */
	    function keyframes(steps) {
	        return new AnimationKeyframesSequenceMetadata(steps);
	    }
	    /**
	     * `transition` is an animation-specific function that is designed to be used inside of Angular2's
	     * animation
	     * DSL language. If this information is new, please navigate to the
	     * {@link Component#animations-anchor component animations metadata
	     * page} to gain a better understanding of how animations in Angular2 are used.
	     *
	     * `transition` declares the {@link sequence sequence of animation steps} that will be run when the
	     * provided
	     * `stateChangeExpr` value is satisfied. The `stateChangeExpr` consists of a `state1 => state2`
	     * which consists
	     * of two known states (use an asterix (`*`) to refer to a dynamic starting and/or ending state).
	     *
	     * Animation transitions are placed within an {@link trigger animation trigger}. For an transition
	     * to animate to
	     * a state value and persist its styles then one or more {@link state animation states} is expected
	     * to be defined.
	     *
	     * ### Usage
	     *
	     * An animation transition is kicked off the `stateChangeExpr` predicate evaluates to true based on
	     * what the
	     * previous state is and what the current state has become. In other words, if a transition is
	     * defined that
	     * matches the old/current state criteria then the associated animation will be triggered.
	     *
	     * ```typescript
	     * // all transition/state changes are defined within an animation trigger
	     * trigger("myAnimationTrigger", [
	     *   // if a state is defined then its styles will be persisted when the
	     *   // animation has fully completed itself
	     *   state("on", style({ background: "green" })),
	     *   state("off", style({ background: "grey" })),
	     *
	     *   // a transition animation that will be kicked off when the state value
	     *   // bound to "myAnimationTrigger" changes from "on" to "off"
	     *   transition("on => off", animate(500)),
	     *
	     *   // it is also possible to do run the same animation for both directions
	     *   transition("on <=> off", animate(500)),
	     *
	     *   // or to define multiple states pairs separated by commas
	     *   transition("on => off, off => void", animate(500)),
	     *
	     *   // this is a catch-all state change for when an element is inserted into
	     *   // the page and the destination state is unknown
	     *   transition("void => *", [
	     *     style({ opacity: 0 }),
	     *     animate(500)
	     *   ]),
	     *
	     *   // this will capture a state change between any states
	     *   transition("* => *", animate("1s 0s")),
	     * ])
	     * ```
	     *
	     * The template associated with this component will make use of the `myAnimationTrigger`
	     * animation trigger by binding to an element within its template code.
	     *
	     * ```html
	     * <!-- somewhere inside of my-component-tpl.html -->
	     * <div [@myAnimationTrigger]="myStatusExp">...</div>
	     * ```
	     *
	     * #### The final `animate` call
	     *
	     * If the final step within the transition steps is a call to `animate()` that **only**
	     * uses a timing value with **no style data** then it will be automatically used as the final
	     * animation
	     * arc for the element to animate itself to the final state. This involves an automatic mix of
	     * adding/removing CSS styles so that the element will be in the exact state it should be for the
	     * applied state to be presented correctly.
	     *
	     * ```
	     * // start off by hiding the element, but make sure that it animates properly to whatever state
	     * // is currently active for "myAnimationTrigger"
	     * transition("void => *", [
	     *   style({ opacity: 0 }),
	     *   animate(500)
	     * ])
	     * ```
	     *
	     * ### Transition Aliases (`:enter` and `:leave`)
	     *
	     * Given that enter (insertion) and leave (removal) animations are so common,
	     * the `transition` function accepts both `:enter` and `:leave` values which
	     * are aliases for the `void => *` and `* => void` state changes.
	     *
	     * ```
	     * transition(":enter", [
	     *   style({ opacity: 0 }),
	     *   animate(500, style({ opacity: 1 }))
	     * ])
	     * transition(":leave", [
	     *   animate(500, style({ opacity: 0 }))
	     * ])
	     * ```
	     *
	     * ### Example ([live demo](http://plnkr.co/edit/Kez8XGWBxWue7qP7nNvF?p=preview))
	     *
	     * {@example core/animation/ts/dsl/animation_example.ts region='Component'}
	     *
	     * @experimental Animation support is experimental.
	     */
	    function transition(stateChangeExpr, steps) {
	        var animationData = Array.isArray(steps) ? new AnimationSequenceMetadata(steps) : steps;
	        return new AnimationStateTransitionMetadata(stateChangeExpr, animationData);
	    }
	    /**
	     * `trigger` is an animation-specific function that is designed to be used inside of Angular2's
	     * animation
	     * DSL language. If this information is new, please navigate to the
	     * {@link Component#animations-anchor component animations metadata
	     * page} to gain a better understanding of how animations in Angular2 are used.
	     *
	     * `trigger` Creates an animation trigger which will a list of {@link state state} and {@link
	     * transition transition}
	     * entries that will be evaluated when the expression bound to the trigger changes.
	     *
	     * Triggers are registered within the component annotation data under the
	     * {@link Component#animations-anchor animations section}. An animation trigger can
	     * be placed on an element within a template by referencing the name of the
	     * trigger followed by the expression value that the trigger is bound to
	     * (in the form of `[@triggerName]="expression"`.
	     *
	     * ### Usage
	     *
	     * `trigger` will create an animation trigger reference based on the provided `name` value.
	     * The provided `animation` value is expected to be an array consisting of {@link state state} and
	     * {@link transition transition}
	     * declarations.
	     *
	     * ```typescript
	     * @Component({
	     *   selector: 'my-component',
	     *   templateUrl: 'my-component-tpl.html',
	     *   animations: [
	     *     trigger("myAnimationTrigger", [
	     *       state(...),
	     *       state(...),
	     *       transition(...),
	     *       transition(...)
	     *     ])
	     *   ]
	     * })
	     * class MyComponent {
	     *   myStatusExp = "something";
	     * }
	     * ```
	     *
	     * The template associated with this component will make use of the `myAnimationTrigger`
	     * animation trigger by binding to an element within its template code.
	     *
	     * ```html
	     * <!-- somewhere inside of my-component-tpl.html -->
	     * <div [@myAnimationTrigger]="myStatusExp">...</div>
	     * ```
	     *
	     * ### Example ([live demo](http://plnkr.co/edit/Kez8XGWBxWue7qP7nNvF?p=preview))
	     *
	     * {@example core/animation/ts/dsl/animation_example.ts region='Component'}
	     *
	     * @experimental Animation support is experimental.
	     */
	    function trigger(name, animation) {
	        return new AnimationEntryMetadata(name, animation);
	    }

	    function prepareFinalAnimationStyles(previousStyles, newStyles, nullValue) {
	        if (nullValue === void 0) { nullValue = null; }
	        var finalStyles = {};
	        Object.keys(newStyles).forEach(function (prop) {
	            var value = newStyles[prop];
	            finalStyles[prop] = value == AUTO_STYLE ? nullValue : value.toString();
	        });
	        Object.keys(previousStyles).forEach(function (prop) {
	            if (!isPresent(finalStyles[prop])) {
	                finalStyles[prop] = nullValue;
	            }
	        });
	        return finalStyles;
	    }
	    function balanceAnimationKeyframes(collectedStyles, finalStateStyles, keyframes) {
	        var limit = keyframes.length - 1;
	        var firstKeyframe = keyframes[0];
	        // phase 1: copy all the styles from the first keyframe into the lookup map
	        var flatenedFirstKeyframeStyles = flattenStyles(firstKeyframe.styles.styles);
	        var extraFirstKeyframeStyles = {};
	        var hasExtraFirstStyles = false;
	        Object.keys(collectedStyles).forEach(function (prop) {
	            var value = collectedStyles[prop];
	            // if the style is already defined in the first keyframe then
	            // we do not replace it.
	            if (!flatenedFirstKeyframeStyles[prop]) {
	                flatenedFirstKeyframeStyles[prop] = value;
	                extraFirstKeyframeStyles[prop] = value;
	                hasExtraFirstStyles = true;
	            }
	        });
	        var keyframeCollectedStyles = StringMapWrapper.merge({}, flatenedFirstKeyframeStyles);
	        // phase 2: normalize the final keyframe
	        var finalKeyframe = keyframes[limit];
	        finalKeyframe.styles.styles.unshift(finalStateStyles);
	        var flatenedFinalKeyframeStyles = flattenStyles(finalKeyframe.styles.styles);
	        var extraFinalKeyframeStyles = {};
	        var hasExtraFinalStyles = false;
	        Object.keys(keyframeCollectedStyles).forEach(function (prop) {
	            if (!isPresent(flatenedFinalKeyframeStyles[prop])) {
	                extraFinalKeyframeStyles[prop] = AUTO_STYLE;
	                hasExtraFinalStyles = true;
	            }
	        });
	        if (hasExtraFinalStyles) {
	            finalKeyframe.styles.styles.push(extraFinalKeyframeStyles);
	        }
	        Object.keys(flatenedFinalKeyframeStyles).forEach(function (prop) {
	            if (!isPresent(flatenedFirstKeyframeStyles[prop])) {
	                extraFirstKeyframeStyles[prop] = AUTO_STYLE;
	                hasExtraFirstStyles = true;
	            }
	        });
	        if (hasExtraFirstStyles) {
	            firstKeyframe.styles.styles.push(extraFirstKeyframeStyles);
	        }
	        return keyframes;
	    }
	    function clearStyles(styles) {
	        var finalStyles = {};
	        Object.keys(styles).forEach(function (key) { finalStyles[key] = null; });
	        return finalStyles;
	    }
	    function collectAndResolveStyles(collection, styles) {
	        return styles.map(function (entry) {
	            var stylesObj = {};
	            Object.keys(entry).forEach(function (prop) {
	                var value = entry[prop];
	                if (value == FILL_STYLE_FLAG) {
	                    value = collection[prop];
	                    if (!isPresent(value)) {
	                        value = AUTO_STYLE;
	                    }
	                }
	                collection[prop] = value;
	                stylesObj[prop] = value;
	            });
	            return stylesObj;
	        });
	    }
	    function renderStyles(element, renderer, styles) {
	        Object.keys(styles).forEach(function (prop) { renderer.setElementStyle(element, prop, styles[prop]); });
	    }
	    function flattenStyles(styles) {
	        var finalStyles = {};
	        styles.forEach(function (entry) {
	            Object.keys(entry).forEach(function (prop) { finalStyles[prop] = entry[prop]; });
	        });
	        return finalStyles;
	    }

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var AnimationStyles = (function () {
	        function AnimationStyles(styles) {
	            this.styles = styles;
	        }
	        return AnimationStyles;
	    }());

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    /**
	     * An instance of this class is returned as an event parameter when an animation
	     * callback is captured for an animation either during the start or done phase.
	     *
	     * ```typescript
	     * @Component({
	     *   host: {
	     *     '[@myAnimationTrigger]': 'someExpression',
	     *     '(@myAnimationTrigger.start)': 'captureStartEvent($event)',
	     *     '(@myAnimationTrigger.done)': 'captureDoneEvent($event)',
	     *   },
	     *   animations: [
	     *     trigger("myAnimationTrigger", [
	     *        // ...
	     *     ])
	     *   ]
	     * })
	     * class MyComponent {
	     *   someExpression: any = false;
	     *   captureStartEvent(event: AnimationTransitionEvent) {
	     *     // the toState, fromState and totalTime data is accessible from the event variable
	     *   }
	     *
	     *   captureDoneEvent(event: AnimationTransitionEvent) {
	     *     // the toState, fromState and totalTime data is accessible from the event variable
	     *   }
	     * }
	     * ```
	     *
	     * @experimental Animation support is experimental.
	     */
	    var AnimationTransitionEvent = (function () {
	        function AnimationTransitionEvent(_a) {
	            var fromState = _a.fromState, toState = _a.toState, totalTime = _a.totalTime, phaseName = _a.phaseName;
	            this.fromState = fromState;
	            this.toState = toState;
	            this.totalTime = totalTime;
	            this.phaseName = phaseName;
	        }
	        return AnimationTransitionEvent;
	    }());

	    var AnimationTransition = (function () {
	        function AnimationTransition(_player, _fromState, _toState, _totalTime) {
	            this._player = _player;
	            this._fromState = _fromState;
	            this._toState = _toState;
	            this._totalTime = _totalTime;
	        }
	        AnimationTransition.prototype._createEvent = function (phaseName) {
	            return new AnimationTransitionEvent({
	                fromState: this._fromState,
	                toState: this._toState,
	                totalTime: this._totalTime,
	                phaseName: phaseName
	            });
	        };
	        AnimationTransition.prototype.onStart = function (callback) {
	            var event = this._createEvent('start');
	            this._player.onStart(function () { return callback(event); });
	        };
	        AnimationTransition.prototype.onDone = function (callback) {
	            var event = this._createEvent('done');
	            this._player.onDone(function () { return callback(event); });
	        };
	        return AnimationTransition;
	    }());

	    var DebugDomRootRenderer = (function () {
	        function DebugDomRootRenderer(_delegate) {
	            this._delegate = _delegate;
	        }
	        DebugDomRootRenderer.prototype.renderComponent = function (componentProto) {
	            return new DebugDomRenderer(this._delegate.renderComponent(componentProto));
	        };
	        return DebugDomRootRenderer;
	    }());
	    var DebugDomRenderer = (function () {
	        function DebugDomRenderer(_delegate) {
	            this._delegate = _delegate;
	        }
	        DebugDomRenderer.prototype.selectRootElement = function (selectorOrNode, debugInfo) {
	            var nativeEl = this._delegate.selectRootElement(selectorOrNode, debugInfo);
	            var debugEl = new DebugElement(nativeEl, null, debugInfo);
	            indexDebugNode(debugEl);
	            return nativeEl;
	        };
	        DebugDomRenderer.prototype.createElement = function (parentElement, name, debugInfo) {
	            var nativeEl = this._delegate.createElement(parentElement, name, debugInfo);
	            var debugEl = new DebugElement(nativeEl, getDebugNode(parentElement), debugInfo);
	            debugEl.name = name;
	            indexDebugNode(debugEl);
	            return nativeEl;
	        };
	        DebugDomRenderer.prototype.createViewRoot = function (hostElement) { return this._delegate.createViewRoot(hostElement); };
	        DebugDomRenderer.prototype.createTemplateAnchor = function (parentElement, debugInfo) {
	            var comment = this._delegate.createTemplateAnchor(parentElement, debugInfo);
	            var debugEl = new DebugNode(comment, getDebugNode(parentElement), debugInfo);
	            indexDebugNode(debugEl);
	            return comment;
	        };
	        DebugDomRenderer.prototype.createText = function (parentElement, value, debugInfo) {
	            var text = this._delegate.createText(parentElement, value, debugInfo);
	            var debugEl = new DebugNode(text, getDebugNode(parentElement), debugInfo);
	            indexDebugNode(debugEl);
	            return text;
	        };
	        DebugDomRenderer.prototype.projectNodes = function (parentElement, nodes) {
	            var debugParent = getDebugNode(parentElement);
	            if (isPresent(debugParent) && debugParent instanceof DebugElement) {
	                var debugElement_1 = debugParent;
	                nodes.forEach(function (node) { debugElement_1.addChild(getDebugNode(node)); });
	            }
	            this._delegate.projectNodes(parentElement, nodes);
	        };
	        DebugDomRenderer.prototype.attachViewAfter = function (node, viewRootNodes) {
	            var debugNode = getDebugNode(node);
	            if (isPresent(debugNode)) {
	                var debugParent = debugNode.parent;
	                if (viewRootNodes.length > 0 && isPresent(debugParent)) {
	                    var debugViewRootNodes = [];
	                    viewRootNodes.forEach(function (rootNode) { return debugViewRootNodes.push(getDebugNode(rootNode)); });
	                    debugParent.insertChildrenAfter(debugNode, debugViewRootNodes);
	                }
	            }
	            this._delegate.attachViewAfter(node, viewRootNodes);
	        };
	        DebugDomRenderer.prototype.detachView = function (viewRootNodes) {
	            viewRootNodes.forEach(function (node) {
	                var debugNode = getDebugNode(node);
	                if (isPresent(debugNode) && isPresent(debugNode.parent)) {
	                    debugNode.parent.removeChild(debugNode);
	                }
	            });
	            this._delegate.detachView(viewRootNodes);
	        };
	        DebugDomRenderer.prototype.destroyView = function (hostElement, viewAllNodes) {
	            viewAllNodes.forEach(function (node) { removeDebugNodeFromIndex(getDebugNode(node)); });
	            this._delegate.destroyView(hostElement, viewAllNodes);
	        };
	        DebugDomRenderer.prototype.listen = function (renderElement, name, callback) {
	            var debugEl = getDebugNode(renderElement);
	            if (isPresent(debugEl)) {
	                debugEl.listeners.push(new EventListener(name, callback));
	            }
	            return this._delegate.listen(renderElement, name, callback);
	        };
	        DebugDomRenderer.prototype.listenGlobal = function (target, name, callback) {
	            return this._delegate.listenGlobal(target, name, callback);
	        };
	        DebugDomRenderer.prototype.setElementProperty = function (renderElement, propertyName, propertyValue) {
	            var debugEl = getDebugNode(renderElement);
	            if (isPresent(debugEl) && debugEl instanceof DebugElement) {
	                debugEl.properties[propertyName] = propertyValue;
	            }
	            this._delegate.setElementProperty(renderElement, propertyName, propertyValue);
	        };
	        DebugDomRenderer.prototype.setElementAttribute = function (renderElement, attributeName, attributeValue) {
	            var debugEl = getDebugNode(renderElement);
	            if (isPresent(debugEl) && debugEl instanceof DebugElement) {
	                debugEl.attributes[attributeName] = attributeValue;
	            }
	            this._delegate.setElementAttribute(renderElement, attributeName, attributeValue);
	        };
	        DebugDomRenderer.prototype.setBindingDebugInfo = function (renderElement, propertyName, propertyValue) {
	            this._delegate.setBindingDebugInfo(renderElement, propertyName, propertyValue);
	        };
	        DebugDomRenderer.prototype.setElementClass = function (renderElement, className, isAdd) {
	            var debugEl = getDebugNode(renderElement);
	            if (isPresent(debugEl) && debugEl instanceof DebugElement) {
	                debugEl.classes[className] = isAdd;
	            }
	            this._delegate.setElementClass(renderElement, className, isAdd);
	        };
	        DebugDomRenderer.prototype.setElementStyle = function (renderElement, styleName, styleValue) {
	            var debugEl = getDebugNode(renderElement);
	            if (isPresent(debugEl) && debugEl instanceof DebugElement) {
	                debugEl.styles[styleName] = styleValue;
	            }
	            this._delegate.setElementStyle(renderElement, styleName, styleValue);
	        };
	        DebugDomRenderer.prototype.invokeElementMethod = function (renderElement, methodName, args) {
	            this._delegate.invokeElementMethod(renderElement, methodName, args);
	        };
	        DebugDomRenderer.prototype.setText = function (renderNode, text) { this._delegate.setText(renderNode, text); };
	        DebugDomRenderer.prototype.animate = function (element, startingStyles, keyframes, duration, delay, easing) {
	            return this._delegate.animate(element, startingStyles, keyframes, duration, delay, easing);
	        };
	        return DebugDomRenderer;
	    }());

	    var StaticNodeDebugInfo = (function () {
	        function StaticNodeDebugInfo(providerTokens, componentToken, refTokens) {
	            this.providerTokens = providerTokens;
	            this.componentToken = componentToken;
	            this.refTokens = refTokens;
	        }
	        return StaticNodeDebugInfo;
	    }());
	    var DebugContext = (function () {
	        function DebugContext(_view, _nodeIndex, _tplRow, _tplCol) {
	            this._view = _view;
	            this._nodeIndex = _nodeIndex;
	            this._tplRow = _tplRow;
	            this._tplCol = _tplCol;
	        }
	        Object.defineProperty(DebugContext.prototype, "_staticNodeInfo", {
	            get: function () {
	                return isPresent(this._nodeIndex) ? this._view.staticNodeDebugInfos[this._nodeIndex] : null;
	            },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(DebugContext.prototype, "context", {
	            get: function () { return this._view.context; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(DebugContext.prototype, "component", {
	            get: function () {
	                var staticNodeInfo = this._staticNodeInfo;
	                if (isPresent(staticNodeInfo) && isPresent(staticNodeInfo.componentToken)) {
	                    return this.injector.get(staticNodeInfo.componentToken);
	                }
	                return null;
	            },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(DebugContext.prototype, "componentRenderElement", {
	            get: function () {
	                var componentView = this._view;
	                while (isPresent(componentView.declarationAppElement) &&
	                    componentView.type !== ViewType.COMPONENT) {
	                    componentView = componentView.declarationAppElement.parentView;
	                }
	                return isPresent(componentView.declarationAppElement) ?
	                    componentView.declarationAppElement.nativeElement :
	                    null;
	            },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(DebugContext.prototype, "injector", {
	            get: function () { return this._view.injector(this._nodeIndex); },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(DebugContext.prototype, "renderNode", {
	            get: function () {
	                if (isPresent(this._nodeIndex) && this._view.allNodes) {
	                    return this._view.allNodes[this._nodeIndex];
	                }
	                else {
	                    return null;
	                }
	            },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(DebugContext.prototype, "providerTokens", {
	            get: function () {
	                var staticNodeInfo = this._staticNodeInfo;
	                return isPresent(staticNodeInfo) ? staticNodeInfo.providerTokens : null;
	            },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(DebugContext.prototype, "source", {
	            get: function () {
	                return this._view.componentType.templateUrl + ":" + this._tplRow + ":" + this._tplCol;
	            },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(DebugContext.prototype, "references", {
	            get: function () {
	                var _this = this;
	                var varValues = {};
	                var staticNodeInfo = this._staticNodeInfo;
	                if (isPresent(staticNodeInfo)) {
	                    var refs = staticNodeInfo.refTokens;
	                    Object.keys(refs).forEach(function (refName) {
	                        var refToken = refs[refName];
	                        var varValue;
	                        if (isBlank(refToken)) {
	                            varValue = _this._view.allNodes ? _this._view.allNodes[_this._nodeIndex] : null;
	                        }
	                        else {
	                            varValue = _this._view.injectorGet(refToken, _this._nodeIndex, null);
	                        }
	                        varValues[refName] = varValue;
	                    });
	                }
	                return varValues;
	            },
	            enumerable: true,
	            configurable: true
	        });
	        return DebugContext;
	    }());

	    var ViewAnimationMap = (function () {
	        function ViewAnimationMap() {
	            this._map = new Map();
	            this._allPlayers = [];
	        }
	        ViewAnimationMap.prototype.find = function (element, animationName) {
	            var playersByAnimation = this._map.get(element);
	            if (isPresent(playersByAnimation)) {
	                return playersByAnimation[animationName];
	            }
	        };
	        ViewAnimationMap.prototype.findAllPlayersByElement = function (element) {
	            var el = this._map.get(element);
	            return el ? Object.keys(el).map(function (k) { return el[k]; }) : [];
	        };
	        ViewAnimationMap.prototype.set = function (element, animationName, player) {
	            var playersByAnimation = this._map.get(element);
	            if (!isPresent(playersByAnimation)) {
	                playersByAnimation = {};
	            }
	            var existingEntry = playersByAnimation[animationName];
	            if (isPresent(existingEntry)) {
	                this.remove(element, animationName);
	            }
	            playersByAnimation[animationName] = player;
	            this._allPlayers.push(player);
	            this._map.set(element, playersByAnimation);
	        };
	        ViewAnimationMap.prototype.getAllPlayers = function () { return this._allPlayers; };
	        ViewAnimationMap.prototype.remove = function (element, animationName) {
	            var playersByAnimation = this._map.get(element);
	            if (playersByAnimation) {
	                var player = playersByAnimation[animationName];
	                delete playersByAnimation[animationName];
	                var index = this._allPlayers.indexOf(player);
	                this._allPlayers.splice(index, 1);
	                if (Object.keys(playersByAnimation).length === 0) {
	                    this._map.delete(element);
	                }
	            }
	        };
	        return ViewAnimationMap;
	    }());

	    var AnimationViewContext = (function () {
	        function AnimationViewContext() {
	            this._players = new ViewAnimationMap();
	        }
	        AnimationViewContext.prototype.onAllActiveAnimationsDone = function (callback) {
	            var activeAnimationPlayers = this._players.getAllPlayers();
	            // we check for the length to avoid having GroupAnimationPlayer
	            // issue an unnecessary microtask when zero players are passed in
	            if (activeAnimationPlayers.length) {
	                new AnimationGroupPlayer(activeAnimationPlayers).onDone(function () { return callback(); });
	            }
	            else {
	                callback();
	            }
	        };
	        AnimationViewContext.prototype.queueAnimation = function (element, animationName, player) {
	            queueAnimationGlobally(player);
	            this._players.set(element, animationName, player);
	        };
	        AnimationViewContext.prototype.cancelActiveAnimation = function (element, animationName, removeAllAnimations) {
	            if (removeAllAnimations === void 0) { removeAllAnimations = false; }
	            if (removeAllAnimations) {
	                this._players.findAllPlayersByElement(element).forEach(function (player) { return player.destroy(); });
	            }
	            else {
	                var player = this._players.find(element, animationName);
	                if (player) {
	                    player.destroy();
	                }
	            }
	        };
	        return AnimationViewContext;
	    }());

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$15 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    var _UNDEFINED$1 = new Object();
	    var ElementInjector = (function (_super) {
	        __extends$15(ElementInjector, _super);
	        function ElementInjector(_view, _nodeIndex) {
	            _super.call(this);
	            this._view = _view;
	            this._nodeIndex = _nodeIndex;
	        }
	        ElementInjector.prototype.get = function (token, notFoundValue) {
	            if (notFoundValue === void 0) { notFoundValue = THROW_IF_NOT_FOUND; }
	            var result = _UNDEFINED$1;
	            if (result === _UNDEFINED$1) {
	                result = this._view.injectorGet(token, this._nodeIndex, _UNDEFINED$1);
	            }
	            if (result === _UNDEFINED$1) {
	                result = this._view.parentInjector.get(token, notFoundValue);
	            }
	            return result;
	        };
	        return ElementInjector;
	    }(Injector));

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$14 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    var _scope_check = wtfCreateScope("AppView#check(ascii id)");
	    /**
	     * Cost of making objects: http://jsperf.com/instantiate-size-of-object
	     *
	     */
	    var AppView = (function () {
	        function AppView(clazz, componentType, type, viewUtils, parentInjector, declarationAppElement, cdMode) {
	            this.clazz = clazz;
	            this.componentType = componentType;
	            this.type = type;
	            this.viewUtils = viewUtils;
	            this.parentInjector = parentInjector;
	            this.declarationAppElement = declarationAppElement;
	            this.cdMode = cdMode;
	            this.contentChildren = [];
	            this.viewChildren = [];
	            this.viewContainerElement = null;
	            this.numberOfChecks = 0;
	            this.ref = new ViewRef_(this);
	            if (type === ViewType.COMPONENT || type === ViewType.HOST) {
	                this.renderer = viewUtils.renderComponent(componentType);
	            }
	            else {
	                this.renderer = declarationAppElement.parentView.renderer;
	            }
	        }
	        Object.defineProperty(AppView.prototype, "animationContext", {
	            get: function () {
	                if (!this._animationContext) {
	                    this._animationContext = new AnimationViewContext();
	                }
	                return this._animationContext;
	            },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AppView.prototype, "destroyed", {
	            get: function () { return this.cdMode === ChangeDetectorStatus.Destroyed; },
	            enumerable: true,
	            configurable: true
	        });
	        AppView.prototype.create = function (context, givenProjectableNodes, rootSelectorOrNode) {
	            this.context = context;
	            var projectableNodes;
	            switch (this.type) {
	                case ViewType.COMPONENT:
	                    projectableNodes = ensureSlotCount(givenProjectableNodes, this.componentType.slotCount);
	                    break;
	                case ViewType.EMBEDDED:
	                    projectableNodes = this.declarationAppElement.parentView.projectableNodes;
	                    break;
	                case ViewType.HOST:
	                    // Note: Don't ensure the slot count for the projectableNodes as we store
	                    // them only for the contained component view (which will later check the slot count...)
	                    projectableNodes = givenProjectableNodes;
	                    break;
	            }
	            this._hasExternalHostElement = isPresent(rootSelectorOrNode);
	            this.projectableNodes = projectableNodes;
	            return this.createInternal(rootSelectorOrNode);
	        };
	        /**
	         * Overwritten by implementations.
	         * Returns the AppElement for the host element for ViewType.HOST.
	         */
	        AppView.prototype.createInternal = function (rootSelectorOrNode) { return null; };
	        AppView.prototype.init = function (rootNodesOrAppElements, allNodes, disposables, subscriptions) {
	            this.rootNodesOrAppElements = rootNodesOrAppElements;
	            this.allNodes = allNodes;
	            this.disposables = disposables;
	            this.subscriptions = subscriptions;
	            if (this.type === ViewType.COMPONENT) {
	                // Note: the render nodes have been attached to their host element
	                // in the ViewFactory already.
	                this.declarationAppElement.parentView.viewChildren.push(this);
	                this.dirtyParentQueriesInternal();
	            }
	        };
	        AppView.prototype.injectorGet = function (token, nodeIndex, notFoundResult) {
	            return this.injectorGetInternal(token, nodeIndex, notFoundResult);
	        };
	        /**
	         * Overwritten by implementations
	         */
	        AppView.prototype.injectorGetInternal = function (token, nodeIndex, notFoundResult) {
	            return notFoundResult;
	        };
	        AppView.prototype.injector = function (nodeIndex) {
	            if (isPresent(nodeIndex)) {
	                return new ElementInjector(this, nodeIndex);
	            }
	            else {
	                return this.parentInjector;
	            }
	        };
	        AppView.prototype.destroy = function () {
	            if (this._hasExternalHostElement) {
	                this.renderer.detachView(this.flatRootNodes);
	            }
	            else if (isPresent(this.viewContainerElement)) {
	                this.viewContainerElement.detachView(this.viewContainerElement.nestedViews.indexOf(this));
	            }
	            this._destroyRecurse();
	        };
	        AppView.prototype._destroyRecurse = function () {
	            if (this.cdMode === ChangeDetectorStatus.Destroyed) {
	                return;
	            }
	            var children = this.contentChildren;
	            for (var i = 0; i < children.length; i++) {
	                children[i]._destroyRecurse();
	            }
	            children = this.viewChildren;
	            for (var i = 0; i < children.length; i++) {
	                children[i]._destroyRecurse();
	            }
	            this.destroyLocal();
	            this.cdMode = ChangeDetectorStatus.Destroyed;
	        };
	        AppView.prototype.destroyLocal = function () {
	            var _this = this;
	            var hostElement = this.type === ViewType.COMPONENT ? this.declarationAppElement.nativeElement : null;
	            for (var i = 0; i < this.disposables.length; i++) {
	                this.disposables[i]();
	            }
	            for (var i = 0; i < this.subscriptions.length; i++) {
	                this.subscriptions[i].unsubscribe();
	            }
	            this.destroyInternal();
	            this.dirtyParentQueriesInternal();
	            if (this._animationContext) {
	                this._animationContext.onAllActiveAnimationsDone(function () { return _this.renderer.destroyView(hostElement, _this.allNodes); });
	            }
	            else {
	                this.renderer.destroyView(hostElement, this.allNodes);
	            }
	        };
	        /**
	         * Overwritten by implementations
	         */
	        AppView.prototype.destroyInternal = function () { };
	        /**
	         * Overwritten by implementations
	         */
	        AppView.prototype.detachInternal = function () { };
	        AppView.prototype.detach = function () {
	            var _this = this;
	            this.detachInternal();
	            if (this._animationContext) {
	                this._animationContext.onAllActiveAnimationsDone(function () { return _this.renderer.detachView(_this.flatRootNodes); });
	            }
	            else {
	                this.renderer.detachView(this.flatRootNodes);
	            }
	        };
	        Object.defineProperty(AppView.prototype, "changeDetectorRef", {
	            get: function () { return this.ref; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AppView.prototype, "parent", {
	            get: function () {
	                return isPresent(this.declarationAppElement) ? this.declarationAppElement.parentView : null;
	            },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AppView.prototype, "flatRootNodes", {
	            get: function () { return flattenNestedViewRenderNodes(this.rootNodesOrAppElements); },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AppView.prototype, "lastRootNode", {
	            get: function () {
	                var lastNode = this.rootNodesOrAppElements.length > 0 ?
	                    this.rootNodesOrAppElements[this.rootNodesOrAppElements.length - 1] :
	                    null;
	                return _findLastRenderNode(lastNode);
	            },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * Overwritten by implementations
	         */
	        AppView.prototype.dirtyParentQueriesInternal = function () { };
	        AppView.prototype.detectChanges = function (throwOnChange) {
	            var s = _scope_check(this.clazz);
	            if (this.cdMode === ChangeDetectorStatus.Checked ||
	                this.cdMode === ChangeDetectorStatus.Errored)
	                return;
	            if (this.cdMode === ChangeDetectorStatus.Destroyed) {
	                this.throwDestroyedError('detectChanges');
	            }
	            this.detectChangesInternal(throwOnChange);
	            if (this.cdMode === ChangeDetectorStatus.CheckOnce)
	                this.cdMode = ChangeDetectorStatus.Checked;
	            this.numberOfChecks++;
	            wtfLeave(s);
	        };
	        /**
	         * Overwritten by implementations
	         */
	        AppView.prototype.detectChangesInternal = function (throwOnChange) {
	            this.detectContentChildrenChanges(throwOnChange);
	            this.detectViewChildrenChanges(throwOnChange);
	        };
	        AppView.prototype.detectContentChildrenChanges = function (throwOnChange) {
	            for (var i = 0; i < this.contentChildren.length; ++i) {
	                var child = this.contentChildren[i];
	                if (child.cdMode === ChangeDetectorStatus.Detached)
	                    continue;
	                child.detectChanges(throwOnChange);
	            }
	        };
	        AppView.prototype.detectViewChildrenChanges = function (throwOnChange) {
	            for (var i = 0; i < this.viewChildren.length; ++i) {
	                var child = this.viewChildren[i];
	                if (child.cdMode === ChangeDetectorStatus.Detached)
	                    continue;
	                child.detectChanges(throwOnChange);
	            }
	        };
	        AppView.prototype.markContentChildAsMoved = function (renderAppElement) { this.dirtyParentQueriesInternal(); };
	        AppView.prototype.addToContentChildren = function (renderAppElement) {
	            renderAppElement.parentView.contentChildren.push(this);
	            this.viewContainerElement = renderAppElement;
	            this.dirtyParentQueriesInternal();
	        };
	        AppView.prototype.removeFromContentChildren = function (renderAppElement) {
	            ListWrapper.remove(renderAppElement.parentView.contentChildren, this);
	            this.dirtyParentQueriesInternal();
	            this.viewContainerElement = null;
	        };
	        AppView.prototype.markAsCheckOnce = function () { this.cdMode = ChangeDetectorStatus.CheckOnce; };
	        AppView.prototype.markPathToRootAsCheckOnce = function () {
	            var c = this;
	            while (isPresent(c) && c.cdMode !== ChangeDetectorStatus.Detached) {
	                if (c.cdMode === ChangeDetectorStatus.Checked) {
	                    c.cdMode = ChangeDetectorStatus.CheckOnce;
	                }
	                var parentEl = c.type === ViewType.COMPONENT ? c.declarationAppElement : c.viewContainerElement;
	                c = isPresent(parentEl) ? parentEl.parentView : null;
	            }
	        };
	        AppView.prototype.eventHandler = function (cb) { return cb; };
	        AppView.prototype.throwDestroyedError = function (details) { throw new ViewDestroyedError(details); };
	        return AppView;
	    }());
	    var DebugAppView = (function (_super) {
	        __extends$14(DebugAppView, _super);
	        function DebugAppView(clazz, componentType, type, viewUtils, parentInjector, declarationAppElement, cdMode, staticNodeDebugInfos) {
	            _super.call(this, clazz, componentType, type, viewUtils, parentInjector, declarationAppElement, cdMode);
	            this.staticNodeDebugInfos = staticNodeDebugInfos;
	            this._currentDebugContext = null;
	        }
	        DebugAppView.prototype.create = function (context, givenProjectableNodes, rootSelectorOrNode) {
	            this._resetDebug();
	            try {
	                return _super.prototype.create.call(this, context, givenProjectableNodes, rootSelectorOrNode);
	            }
	            catch (e) {
	                this._rethrowWithContext(e);
	                throw e;
	            }
	        };
	        DebugAppView.prototype.injectorGet = function (token, nodeIndex, notFoundResult) {
	            this._resetDebug();
	            try {
	                return _super.prototype.injectorGet.call(this, token, nodeIndex, notFoundResult);
	            }
	            catch (e) {
	                this._rethrowWithContext(e);
	                throw e;
	            }
	        };
	        DebugAppView.prototype.detach = function () {
	            this._resetDebug();
	            try {
	                _super.prototype.detach.call(this);
	            }
	            catch (e) {
	                this._rethrowWithContext(e);
	                throw e;
	            }
	        };
	        DebugAppView.prototype.destroyLocal = function () {
	            this._resetDebug();
	            try {
	                _super.prototype.destroyLocal.call(this);
	            }
	            catch (e) {
	                this._rethrowWithContext(e);
	                throw e;
	            }
	        };
	        DebugAppView.prototype.detectChanges = function (throwOnChange) {
	            this._resetDebug();
	            try {
	                _super.prototype.detectChanges.call(this, throwOnChange);
	            }
	            catch (e) {
	                this._rethrowWithContext(e);
	                throw e;
	            }
	        };
	        DebugAppView.prototype._resetDebug = function () { this._currentDebugContext = null; };
	        DebugAppView.prototype.debug = function (nodeIndex, rowNum, colNum) {
	            return this._currentDebugContext = new DebugContext(this, nodeIndex, rowNum, colNum);
	        };
	        DebugAppView.prototype._rethrowWithContext = function (e) {
	            if (!(e instanceof ViewWrappedError)) {
	                if (!(e instanceof ExpressionChangedAfterItHasBeenCheckedError)) {
	                    this.cdMode = ChangeDetectorStatus.Errored;
	                }
	                if (isPresent(this._currentDebugContext)) {
	                    throw new ViewWrappedError(e, this._currentDebugContext);
	                }
	            }
	        };
	        DebugAppView.prototype.eventHandler = function (cb) {
	            var _this = this;
	            var superHandler = _super.prototype.eventHandler.call(this, cb);
	            return function (event) {
	                _this._resetDebug();
	                try {
	                    return superHandler(event);
	                }
	                catch (e) {
	                    _this._rethrowWithContext(e);
	                    throw e;
	                }
	            };
	        };
	        return DebugAppView;
	    }(AppView));
	    function _findLastRenderNode(node) {
	        var lastNode;
	        if (node instanceof AppElement) {
	            var appEl = node;
	            lastNode = appEl.nativeElement;
	            if (isPresent(appEl.nestedViews)) {
	                // Note: Views might have no root nodes at all!
	                for (var i = appEl.nestedViews.length - 1; i >= 0; i--) {
	                    var nestedView = appEl.nestedViews[i];
	                    if (nestedView.rootNodesOrAppElements.length > 0) {
	                        lastNode = _findLastRenderNode(nestedView.rootNodesOrAppElements[nestedView.rootNodesOrAppElements.length - 1]);
	                    }
	                }
	            }
	        }
	        else {
	            lastNode = node;
	        }
	        return lastNode;
	    }

	    var __core_private__ = {
	        isDefaultChangeDetectionStrategy: isDefaultChangeDetectionStrategy,
	        ChangeDetectorStatus: ChangeDetectorStatus,
	        constructDependencies: constructDependencies,
	        LifecycleHooks: LifecycleHooks,
	        LIFECYCLE_HOOKS_VALUES: LIFECYCLE_HOOKS_VALUES,
	        ReflectorReader: ReflectorReader,
	        CodegenComponentFactoryResolver: CodegenComponentFactoryResolver,
	        AppElement: AppElement,
	        AppView: AppView,
	        DebugAppView: DebugAppView,
	        NgModuleInjector: NgModuleInjector,
	        registerModuleFactory: registerModuleFactory,
	        ViewType: ViewType,
	        view_utils: view_utils,
	        ViewMetadata: ViewMetadata,
	        DebugContext: DebugContext,
	        StaticNodeDebugInfo: StaticNodeDebugInfo,
	        devModeEqual: devModeEqual,
	        UNINITIALIZED: UNINITIALIZED,
	        ValueUnwrapper: ValueUnwrapper,
	        RenderDebugInfo: RenderDebugInfo,
	        TemplateRef_: TemplateRef_,
	        ReflectionCapabilities: ReflectionCapabilities,
	        makeDecorator: makeDecorator,
	        DebugDomRootRenderer: DebugDomRootRenderer,
	        Console: Console,
	        reflector: reflector,
	        Reflector: Reflector,
	        NoOpAnimationPlayer: NoOpAnimationPlayer,
	        AnimationPlayer: AnimationPlayer,
	        AnimationSequencePlayer: AnimationSequencePlayer,
	        AnimationGroupPlayer: AnimationGroupPlayer,
	        AnimationKeyframe: AnimationKeyframe,
	        prepareFinalAnimationStyles: prepareFinalAnimationStyles,
	        balanceAnimationKeyframes: balanceAnimationKeyframes,
	        flattenStyles: flattenStyles,
	        clearStyles: clearStyles,
	        renderStyles: renderStyles,
	        collectAndResolveStyles: collectAndResolveStyles,
	        AnimationStyles: AnimationStyles,
	        ANY_STATE: ANY_STATE,
	        DEFAULT_STATE: DEFAULT_STATE,
	        EMPTY_STATE: EMPTY_STATE,
	        FILL_STYLE_FLAG: FILL_STYLE_FLAG,
	        ComponentStillLoadingError: ComponentStillLoadingError,
	        isPromise: isPromise,
	        AnimationTransition: AnimationTransition
	    };

	    exports.createPlatform = createPlatform;
	    exports.assertPlatform = assertPlatform;
	    exports.destroyPlatform = destroyPlatform;
	    exports.getPlatform = getPlatform;
	    exports.PlatformRef = PlatformRef;
	    exports.ApplicationRef = ApplicationRef;
	    exports.enableProdMode = enableProdMode;
	    exports.isDevMode = isDevMode;
	    exports.createPlatformFactory = createPlatformFactory;
	    exports.APP_ID = APP_ID;
	    exports.PACKAGE_ROOT_URL = PACKAGE_ROOT_URL;
	    exports.PLATFORM_INITIALIZER = PLATFORM_INITIALIZER;
	    exports.APP_BOOTSTRAP_LISTENER = APP_BOOTSTRAP_LISTENER;
	    exports.APP_INITIALIZER = APP_INITIALIZER;
	    exports.ApplicationInitStatus = ApplicationInitStatus;
	    exports.DebugElement = DebugElement;
	    exports.DebugNode = DebugNode;
	    exports.asNativeElements = asNativeElements;
	    exports.getDebugNode = getDebugNode;
	    exports.Testability = Testability;
	    exports.TestabilityRegistry = TestabilityRegistry;
	    exports.setTestabilityGetter = setTestabilityGetter;
	    exports.TRANSLATIONS = TRANSLATIONS;
	    exports.TRANSLATIONS_FORMAT = TRANSLATIONS_FORMAT;
	    exports.LOCALE_ID = LOCALE_ID;
	    exports.ApplicationModule = ApplicationModule;
	    exports.wtfCreateScope = wtfCreateScope;
	    exports.wtfLeave = wtfLeave;
	    exports.wtfStartTimeRange = wtfStartTimeRange;
	    exports.wtfEndTimeRange = wtfEndTimeRange;
	    exports.Type = Type;
	    exports.EventEmitter = EventEmitter;
	    exports.ErrorHandler = ErrorHandler;
	    exports.AnimationTransitionEvent = AnimationTransitionEvent;
	    exports.AnimationPlayer = AnimationPlayer;
	    exports.Sanitizer = Sanitizer;
	    exports.ANALYZE_FOR_ENTRY_COMPONENTS = ANALYZE_FOR_ENTRY_COMPONENTS;
	    exports.Attribute = Attribute;
	    exports.ContentChild = ContentChild;
	    exports.ContentChildren = ContentChildren;
	    exports.Query = Query;
	    exports.ViewChild = ViewChild;
	    exports.ViewChildren = ViewChildren;
	    exports.Component = Component;
	    exports.Directive = Directive;
	    exports.HostBinding = HostBinding;
	    exports.HostListener = HostListener;
	    exports.Input = Input;
	    exports.Output = Output;
	    exports.Pipe = Pipe;
	    exports.AfterContentChecked = AfterContentChecked;
	    exports.AfterContentInit = AfterContentInit;
	    exports.AfterViewChecked = AfterViewChecked;
	    exports.AfterViewInit = AfterViewInit;
	    exports.DoCheck = DoCheck;
	    exports.OnChanges = OnChanges;
	    exports.OnDestroy = OnDestroy;
	    exports.OnInit = OnInit;
	    exports.CUSTOM_ELEMENTS_SCHEMA = CUSTOM_ELEMENTS_SCHEMA;
	    exports.NO_ERRORS_SCHEMA = NO_ERRORS_SCHEMA;
	    exports.NgModule = NgModule;
	    exports.Class = Class;
	    exports.forwardRef = forwardRef;
	    exports.resolveForwardRef = resolveForwardRef;
	    exports.Injector = Injector;
	    exports.ReflectiveInjector = ReflectiveInjector;
	    exports.ResolvedReflectiveFactory = ResolvedReflectiveFactory;
	    exports.ReflectiveKey = ReflectiveKey;
	    exports.OpaqueToken = OpaqueToken;
	    exports.Inject = Inject;
	    exports.Optional = Optional;
	    exports.Injectable = Injectable;
	    exports.Self = Self;
	    exports.SkipSelf = SkipSelf;
	    exports.Host = Host;
	    exports.NgZone = NgZone;
	    exports.RenderComponentType = RenderComponentType;
	    exports.Renderer = Renderer;
	    exports.RootRenderer = RootRenderer;
	    exports.COMPILER_OPTIONS = COMPILER_OPTIONS;
	    exports.Compiler = Compiler;
	    exports.CompilerFactory = CompilerFactory;
	    exports.ModuleWithComponentFactories = ModuleWithComponentFactories;
	    exports.ComponentFactory = ComponentFactory;
	    exports.ComponentRef = ComponentRef;
	    exports.ComponentFactoryResolver = ComponentFactoryResolver;
	    exports.ElementRef = ElementRef;
	    exports.NgModuleFactory = NgModuleFactory;
	    exports.NgModuleRef = NgModuleRef;
	    exports.NgModuleFactoryLoader = NgModuleFactoryLoader;
	    exports.getModuleFactory = getModuleFactory;
	    exports.QueryList = QueryList;
	    exports.SystemJsNgModuleLoader = SystemJsNgModuleLoader;
	    exports.SystemJsNgModuleLoaderConfig = SystemJsNgModuleLoaderConfig;
	    exports.TemplateRef = TemplateRef;
	    exports.ViewContainerRef = ViewContainerRef;
	    exports.EmbeddedViewRef = EmbeddedViewRef;
	    exports.ViewRef = ViewRef;
	    exports.ChangeDetectorRef = ChangeDetectorRef;
	    exports.CollectionChangeRecord = CollectionChangeRecord;
	    exports.DefaultIterableDiffer = DefaultIterableDiffer;
	    exports.IterableDiffers = IterableDiffers;
	    exports.KeyValueChangeRecord = KeyValueChangeRecord;
	    exports.KeyValueDiffers = KeyValueDiffers;
	    exports.SimpleChange = SimpleChange;
	    exports.WrappedValue = WrappedValue;
	    exports.platformCore = platformCore;
	    exports.__core_private__ = __core_private__;
	    exports.AUTO_STYLE = AUTO_STYLE;
	    exports.AnimationEntryMetadata = AnimationEntryMetadata;
	    exports.AnimationStateMetadata = AnimationStateMetadata;
	    exports.AnimationStateDeclarationMetadata = AnimationStateDeclarationMetadata;
	    exports.AnimationStateTransitionMetadata = AnimationStateTransitionMetadata;
	    exports.AnimationMetadata = AnimationMetadata;
	    exports.AnimationKeyframesSequenceMetadata = AnimationKeyframesSequenceMetadata;
	    exports.AnimationStyleMetadata = AnimationStyleMetadata;
	    exports.AnimationAnimateMetadata = AnimationAnimateMetadata;
	    exports.AnimationWithStepsMetadata = AnimationWithStepsMetadata;
	    exports.AnimationSequenceMetadata = AnimationSequenceMetadata;
	    exports.AnimationGroupMetadata = AnimationGroupMetadata;
	    exports.animate = animate;
	    exports.group = group;
	    exports.sequence = sequence;
	    exports.style = style;
	    exports.state = state;
	    exports.keyframes = keyframes;
	    exports.transition = transition;
	    exports.trigger = trigger;

	}));

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Observable_1 = __webpack_require__(5);
	var Subscriber_1 = __webpack_require__(8);
	var Subscription_1 = __webpack_require__(10);
	var ObjectUnsubscribedError_1 = __webpack_require__(19);
	var SubjectSubscription_1 = __webpack_require__(20);
	var rxSubscriber_1 = __webpack_require__(17);
	/**
	 * @class SubjectSubscriber<T>
	 */
	var SubjectSubscriber = (function (_super) {
	    __extends(SubjectSubscriber, _super);
	    function SubjectSubscriber(destination) {
	        _super.call(this, destination);
	        this.destination = destination;
	    }
	    return SubjectSubscriber;
	}(Subscriber_1.Subscriber));
	exports.SubjectSubscriber = SubjectSubscriber;
	/**
	 * @class Subject<T>
	 */
	var Subject = (function (_super) {
	    __extends(Subject, _super);
	    function Subject() {
	        _super.call(this);
	        this.observers = [];
	        this.closed = false;
	        this.isStopped = false;
	        this.hasError = false;
	        this.thrownError = null;
	    }
	    Subject.prototype[rxSubscriber_1.$$rxSubscriber] = function () {
	        return new SubjectSubscriber(this);
	    };
	    Subject.prototype.lift = function (operator) {
	        var subject = new AnonymousSubject(this, this);
	        subject.operator = operator;
	        return subject;
	    };
	    Subject.prototype.next = function (value) {
	        if (this.closed) {
	            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
	        }
	        if (!this.isStopped) {
	            var observers = this.observers;
	            var len = observers.length;
	            var copy = observers.slice();
	            for (var i = 0; i < len; i++) {
	                copy[i].next(value);
	            }
	        }
	    };
	    Subject.prototype.error = function (err) {
	        if (this.closed) {
	            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
	        }
	        this.hasError = true;
	        this.thrownError = err;
	        this.isStopped = true;
	        var observers = this.observers;
	        var len = observers.length;
	        var copy = observers.slice();
	        for (var i = 0; i < len; i++) {
	            copy[i].error(err);
	        }
	        this.observers.length = 0;
	    };
	    Subject.prototype.complete = function () {
	        if (this.closed) {
	            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
	        }
	        this.isStopped = true;
	        var observers = this.observers;
	        var len = observers.length;
	        var copy = observers.slice();
	        for (var i = 0; i < len; i++) {
	            copy[i].complete();
	        }
	        this.observers.length = 0;
	    };
	    Subject.prototype.unsubscribe = function () {
	        this.isStopped = true;
	        this.closed = true;
	        this.observers = null;
	    };
	    Subject.prototype._subscribe = function (subscriber) {
	        if (this.closed) {
	            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
	        }
	        else if (this.hasError) {
	            subscriber.error(this.thrownError);
	            return Subscription_1.Subscription.EMPTY;
	        }
	        else if (this.isStopped) {
	            subscriber.complete();
	            return Subscription_1.Subscription.EMPTY;
	        }
	        else {
	            this.observers.push(subscriber);
	            return new SubjectSubscription_1.SubjectSubscription(this, subscriber);
	        }
	    };
	    Subject.prototype.asObservable = function () {
	        var observable = new Observable_1.Observable();
	        observable.source = this;
	        return observable;
	    };
	    Subject.create = function (destination, source) {
	        return new AnonymousSubject(destination, source);
	    };
	    return Subject;
	}(Observable_1.Observable));
	exports.Subject = Subject;
	/**
	 * @class AnonymousSubject<T>
	 */
	var AnonymousSubject = (function (_super) {
	    __extends(AnonymousSubject, _super);
	    function AnonymousSubject(destination, source) {
	        _super.call(this);
	        this.destination = destination;
	        this.source = source;
	    }
	    AnonymousSubject.prototype.next = function (value) {
	        var destination = this.destination;
	        if (destination && destination.next) {
	            destination.next(value);
	        }
	    };
	    AnonymousSubject.prototype.error = function (err) {
	        var destination = this.destination;
	        if (destination && destination.error) {
	            this.destination.error(err);
	        }
	    };
	    AnonymousSubject.prototype.complete = function () {
	        var destination = this.destination;
	        if (destination && destination.complete) {
	            this.destination.complete();
	        }
	    };
	    AnonymousSubject.prototype._subscribe = function (subscriber) {
	        var source = this.source;
	        if (source) {
	            return this.source.subscribe(subscriber);
	        }
	        else {
	            return Subscription_1.Subscription.EMPTY;
	        }
	    };
	    return AnonymousSubject;
	}(Subject));
	exports.AnonymousSubject = AnonymousSubject;
	//# sourceMappingURL=Subject.js.map

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var root_1 = __webpack_require__(6);
	var toSubscriber_1 = __webpack_require__(7);
	var observable_1 = __webpack_require__(18);
	/**
	 * A representation of any set of values over any amount of time. This the most basic building block
	 * of RxJS.
	 *
	 * @class Observable<T>
	 */
	var Observable = (function () {
	    /**
	     * @constructor
	     * @param {Function} subscribe the function that is  called when the Observable is
	     * initially subscribed to. This function is given a Subscriber, to which new values
	     * can be `next`ed, or an `error` method can be called to raise an error, or
	     * `complete` can be called to notify of a successful completion.
	     */
	    function Observable(subscribe) {
	        this._isScalar = false;
	        if (subscribe) {
	            this._subscribe = subscribe;
	        }
	    }
	    /**
	     * Creates a new Observable, with this Observable as the source, and the passed
	     * operator defined as the new observable's operator.
	     * @method lift
	     * @param {Operator} operator the operator defining the operation to take on the observable
	     * @return {Observable} a new observable with the Operator applied
	     */
	    Observable.prototype.lift = function (operator) {
	        var observable = new Observable();
	        observable.source = this;
	        observable.operator = operator;
	        return observable;
	    };
	    /**
	     * Registers handlers for handling emitted values, error and completions from the observable, and
	     *  executes the observable's subscriber function, which will take action to set up the underlying data stream
	     * @method subscribe
	     * @param {PartialObserver|Function} observerOrNext (optional) either an observer defining all functions to be called,
	     *  or the first of three possible handlers, which is the handler for each value emitted from the observable.
	     * @param {Function} error (optional) a handler for a terminal event resulting from an error. If no error handler is provided,
	     *  the error will be thrown as unhandled
	     * @param {Function} complete (optional) a handler for a terminal event resulting from successful completion.
	     * @return {ISubscription} a subscription reference to the registered handlers
	     */
	    Observable.prototype.subscribe = function (observerOrNext, error, complete) {
	        var operator = this.operator;
	        var sink = toSubscriber_1.toSubscriber(observerOrNext, error, complete);
	        if (operator) {
	            operator.call(sink, this);
	        }
	        else {
	            sink.add(this._subscribe(sink));
	        }
	        if (sink.syncErrorThrowable) {
	            sink.syncErrorThrowable = false;
	            if (sink.syncErrorThrown) {
	                throw sink.syncErrorValue;
	            }
	        }
	        return sink;
	    };
	    /**
	     * @method forEach
	     * @param {Function} next a handler for each value emitted by the observable
	     * @param {PromiseConstructor} [PromiseCtor] a constructor function used to instantiate the Promise
	     * @return {Promise} a promise that either resolves on observable completion or
	     *  rejects with the handled error
	     */
	    Observable.prototype.forEach = function (next, PromiseCtor) {
	        var _this = this;
	        if (!PromiseCtor) {
	            if (root_1.root.Rx && root_1.root.Rx.config && root_1.root.Rx.config.Promise) {
	                PromiseCtor = root_1.root.Rx.config.Promise;
	            }
	            else if (root_1.root.Promise) {
	                PromiseCtor = root_1.root.Promise;
	            }
	        }
	        if (!PromiseCtor) {
	            throw new Error('no Promise impl found');
	        }
	        return new PromiseCtor(function (resolve, reject) {
	            var subscription = _this.subscribe(function (value) {
	                if (subscription) {
	                    // if there is a subscription, then we can surmise
	                    // the next handling is asynchronous. Any errors thrown
	                    // need to be rejected explicitly and unsubscribe must be
	                    // called manually
	                    try {
	                        next(value);
	                    }
	                    catch (err) {
	                        reject(err);
	                        subscription.unsubscribe();
	                    }
	                }
	                else {
	                    // if there is NO subscription, then we're getting a nexted
	                    // value synchronously during subscription. We can just call it.
	                    // If it errors, Observable's `subscribe` will ensure the
	                    // unsubscription logic is called, then synchronously rethrow the error.
	                    // After that, Promise will trap the error and send it
	                    // down the rejection path.
	                    next(value);
	                }
	            }, reject, resolve);
	        });
	    };
	    Observable.prototype._subscribe = function (subscriber) {
	        return this.source.subscribe(subscriber);
	    };
	    /**
	     * An interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable
	     * @method Symbol.observable
	     * @return {Observable} this instance of the observable
	     */
	    Observable.prototype[observable_1.$$observable] = function () {
	        return this;
	    };
	    // HACK: Since TypeScript inherits static properties too, we have to
	    // fight against TypeScript here so Subject can have a different static create signature
	    /**
	     * Creates a new cold Observable by calling the Observable constructor
	     * @static true
	     * @owner Observable
	     * @method create
	     * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor
	     * @return {Observable} a new cold observable
	     */
	    Observable.create = function (subscribe) {
	        return new Observable(subscribe);
	    };
	    return Observable;
	}());
	exports.Observable = Observable;
	//# sourceMappingURL=Observable.js.map

/***/ },
/* 6 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {"use strict";
	var objectTypes = {
	    'boolean': false,
	    'function': true,
	    'object': true,
	    'number': false,
	    'string': false,
	    'undefined': false
	};
	exports.root = (objectTypes[typeof self] && self) || (objectTypes[typeof window] && window);
	var freeGlobal = objectTypes[typeof global] && global;
	if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
	    exports.root = freeGlobal;
	}
	//# sourceMappingURL=root.js.map
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Subscriber_1 = __webpack_require__(8);
	var rxSubscriber_1 = __webpack_require__(17);
	function toSubscriber(nextOrObserver, error, complete) {
	    if (nextOrObserver) {
	        if (nextOrObserver instanceof Subscriber_1.Subscriber) {
	            return nextOrObserver;
	        }
	        if (nextOrObserver[rxSubscriber_1.$$rxSubscriber]) {
	            return nextOrObserver[rxSubscriber_1.$$rxSubscriber]();
	        }
	    }
	    if (!nextOrObserver && !error && !complete) {
	        return new Subscriber_1.Subscriber();
	    }
	    return new Subscriber_1.Subscriber(nextOrObserver, error, complete);
	}
	exports.toSubscriber = toSubscriber;
	//# sourceMappingURL=toSubscriber.js.map

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var isFunction_1 = __webpack_require__(9);
	var Subscription_1 = __webpack_require__(10);
	var Observer_1 = __webpack_require__(16);
	var rxSubscriber_1 = __webpack_require__(17);
	/**
	 * Implements the {@link Observer} interface and extends the
	 * {@link Subscription} class. While the {@link Observer} is the public API for
	 * consuming the values of an {@link Observable}, all Observers get converted to
	 * a Subscriber, in order to provide Subscription-like capabilities such as
	 * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for
	 * implementing operators, but it is rarely used as a public API.
	 *
	 * @class Subscriber<T>
	 */
	var Subscriber = (function (_super) {
	    __extends(Subscriber, _super);
	    /**
	     * @param {Observer|function(value: T): void} [destinationOrNext] A partially
	     * defined Observer or a `next` callback function.
	     * @param {function(e: ?any): void} [error] The `error` callback of an
	     * Observer.
	     * @param {function(): void} [complete] The `complete` callback of an
	     * Observer.
	     */
	    function Subscriber(destinationOrNext, error, complete) {
	        _super.call(this);
	        this.syncErrorValue = null;
	        this.syncErrorThrown = false;
	        this.syncErrorThrowable = false;
	        this.isStopped = false;
	        switch (arguments.length) {
	            case 0:
	                this.destination = Observer_1.empty;
	                break;
	            case 1:
	                if (!destinationOrNext) {
	                    this.destination = Observer_1.empty;
	                    break;
	                }
	                if (typeof destinationOrNext === 'object') {
	                    if (destinationOrNext instanceof Subscriber) {
	                        this.destination = destinationOrNext;
	                        this.destination.add(this);
	                    }
	                    else {
	                        this.syncErrorThrowable = true;
	                        this.destination = new SafeSubscriber(this, destinationOrNext);
	                    }
	                    break;
	                }
	            default:
	                this.syncErrorThrowable = true;
	                this.destination = new SafeSubscriber(this, destinationOrNext, error, complete);
	                break;
	        }
	    }
	    Subscriber.prototype[rxSubscriber_1.$$rxSubscriber] = function () { return this; };
	    /**
	     * A static factory for a Subscriber, given a (potentially partial) definition
	     * of an Observer.
	     * @param {function(x: ?T): void} [next] The `next` callback of an Observer.
	     * @param {function(e: ?any): void} [error] The `error` callback of an
	     * Observer.
	     * @param {function(): void} [complete] The `complete` callback of an
	     * Observer.
	     * @return {Subscriber<T>} A Subscriber wrapping the (partially defined)
	     * Observer represented by the given arguments.
	     */
	    Subscriber.create = function (next, error, complete) {
	        var subscriber = new Subscriber(next, error, complete);
	        subscriber.syncErrorThrowable = false;
	        return subscriber;
	    };
	    /**
	     * The {@link Observer} callback to receive notifications of type `next` from
	     * the Observable, with a value. The Observable may call this method 0 or more
	     * times.
	     * @param {T} [value] The `next` value.
	     * @return {void}
	     */
	    Subscriber.prototype.next = function (value) {
	        if (!this.isStopped) {
	            this._next(value);
	        }
	    };
	    /**
	     * The {@link Observer} callback to receive notifications of type `error` from
	     * the Observable, with an attached {@link Error}. Notifies the Observer that
	     * the Observable has experienced an error condition.
	     * @param {any} [err] The `error` exception.
	     * @return {void}
	     */
	    Subscriber.prototype.error = function (err) {
	        if (!this.isStopped) {
	            this.isStopped = true;
	            this._error(err);
	        }
	    };
	    /**
	     * The {@link Observer} callback to receive a valueless notification of type
	     * `complete` from the Observable. Notifies the Observer that the Observable
	     * has finished sending push-based notifications.
	     * @return {void}
	     */
	    Subscriber.prototype.complete = function () {
	        if (!this.isStopped) {
	            this.isStopped = true;
	            this._complete();
	        }
	    };
	    Subscriber.prototype.unsubscribe = function () {
	        if (this.closed) {
	            return;
	        }
	        this.isStopped = true;
	        _super.prototype.unsubscribe.call(this);
	    };
	    Subscriber.prototype._next = function (value) {
	        this.destination.next(value);
	    };
	    Subscriber.prototype._error = function (err) {
	        this.destination.error(err);
	        this.unsubscribe();
	    };
	    Subscriber.prototype._complete = function () {
	        this.destination.complete();
	        this.unsubscribe();
	    };
	    return Subscriber;
	}(Subscription_1.Subscription));
	exports.Subscriber = Subscriber;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var SafeSubscriber = (function (_super) {
	    __extends(SafeSubscriber, _super);
	    function SafeSubscriber(_parent, observerOrNext, error, complete) {
	        _super.call(this);
	        this._parent = _parent;
	        var next;
	        var context = this;
	        if (isFunction_1.isFunction(observerOrNext)) {
	            next = observerOrNext;
	        }
	        else if (observerOrNext) {
	            context = observerOrNext;
	            next = observerOrNext.next;
	            error = observerOrNext.error;
	            complete = observerOrNext.complete;
	            if (isFunction_1.isFunction(context.unsubscribe)) {
	                this.add(context.unsubscribe.bind(context));
	            }
	            context.unsubscribe = this.unsubscribe.bind(this);
	        }
	        this._context = context;
	        this._next = next;
	        this._error = error;
	        this._complete = complete;
	    }
	    SafeSubscriber.prototype.next = function (value) {
	        if (!this.isStopped && this._next) {
	            var _parent = this._parent;
	            if (!_parent.syncErrorThrowable) {
	                this.__tryOrUnsub(this._next, value);
	            }
	            else if (this.__tryOrSetError(_parent, this._next, value)) {
	                this.unsubscribe();
	            }
	        }
	    };
	    SafeSubscriber.prototype.error = function (err) {
	        if (!this.isStopped) {
	            var _parent = this._parent;
	            if (this._error) {
	                if (!_parent.syncErrorThrowable) {
	                    this.__tryOrUnsub(this._error, err);
	                    this.unsubscribe();
	                }
	                else {
	                    this.__tryOrSetError(_parent, this._error, err);
	                    this.unsubscribe();
	                }
	            }
	            else if (!_parent.syncErrorThrowable) {
	                this.unsubscribe();
	                throw err;
	            }
	            else {
	                _parent.syncErrorValue = err;
	                _parent.syncErrorThrown = true;
	                this.unsubscribe();
	            }
	        }
	    };
	    SafeSubscriber.prototype.complete = function () {
	        if (!this.isStopped) {
	            var _parent = this._parent;
	            if (this._complete) {
	                if (!_parent.syncErrorThrowable) {
	                    this.__tryOrUnsub(this._complete);
	                    this.unsubscribe();
	                }
	                else {
	                    this.__tryOrSetError(_parent, this._complete);
	                    this.unsubscribe();
	                }
	            }
	            else {
	                this.unsubscribe();
	            }
	        }
	    };
	    SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {
	        try {
	            fn.call(this._context, value);
	        }
	        catch (err) {
	            this.unsubscribe();
	            throw err;
	        }
	    };
	    SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {
	        try {
	            fn.call(this._context, value);
	        }
	        catch (err) {
	            parent.syncErrorValue = err;
	            parent.syncErrorThrown = true;
	            return true;
	        }
	        return false;
	    };
	    SafeSubscriber.prototype._unsubscribe = function () {
	        var _parent = this._parent;
	        this._context = null;
	        this._parent = null;
	        _parent.unsubscribe();
	    };
	    return SafeSubscriber;
	}(Subscriber));
	//# sourceMappingURL=Subscriber.js.map

/***/ },
/* 9 */
/***/ function(module, exports) {

	"use strict";
	function isFunction(x) {
	    return typeof x === 'function';
	}
	exports.isFunction = isFunction;
	//# sourceMappingURL=isFunction.js.map

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var isArray_1 = __webpack_require__(11);
	var isObject_1 = __webpack_require__(12);
	var isFunction_1 = __webpack_require__(9);
	var tryCatch_1 = __webpack_require__(13);
	var errorObject_1 = __webpack_require__(14);
	var UnsubscriptionError_1 = __webpack_require__(15);
	/**
	 * Represents a disposable resource, such as the execution of an Observable. A
	 * Subscription has one important method, `unsubscribe`, that takes no argument
	 * and just disposes the resource held by the subscription.
	 *
	 * Additionally, subscriptions may be grouped together through the `add()`
	 * method, which will attach a child Subscription to the current Subscription.
	 * When a Subscription is unsubscribed, all its children (and its grandchildren)
	 * will be unsubscribed as well.
	 *
	 * @class Subscription
	 */
	var Subscription = (function () {
	    /**
	     * @param {function(): void} [unsubscribe] A function describing how to
	     * perform the disposal of resources when the `unsubscribe` method is called.
	     */
	    function Subscription(unsubscribe) {
	        /**
	         * A flag to indicate whether this Subscription has already been unsubscribed.
	         * @type {boolean}
	         */
	        this.closed = false;
	        if (unsubscribe) {
	            this._unsubscribe = unsubscribe;
	        }
	    }
	    /**
	     * Disposes the resources held by the subscription. May, for instance, cancel
	     * an ongoing Observable execution or cancel any other type of work that
	     * started when the Subscription was created.
	     * @return {void}
	     */
	    Subscription.prototype.unsubscribe = function () {
	        var hasErrors = false;
	        var errors;
	        if (this.closed) {
	            return;
	        }
	        this.closed = true;
	        var _a = this, _unsubscribe = _a._unsubscribe, _subscriptions = _a._subscriptions;
	        this._subscriptions = null;
	        if (isFunction_1.isFunction(_unsubscribe)) {
	            var trial = tryCatch_1.tryCatch(_unsubscribe).call(this);
	            if (trial === errorObject_1.errorObject) {
	                hasErrors = true;
	                (errors = errors || []).push(errorObject_1.errorObject.e);
	            }
	        }
	        if (isArray_1.isArray(_subscriptions)) {
	            var index = -1;
	            var len = _subscriptions.length;
	            while (++index < len) {
	                var sub = _subscriptions[index];
	                if (isObject_1.isObject(sub)) {
	                    var trial = tryCatch_1.tryCatch(sub.unsubscribe).call(sub);
	                    if (trial === errorObject_1.errorObject) {
	                        hasErrors = true;
	                        errors = errors || [];
	                        var err = errorObject_1.errorObject.e;
	                        if (err instanceof UnsubscriptionError_1.UnsubscriptionError) {
	                            errors = errors.concat(err.errors);
	                        }
	                        else {
	                            errors.push(err);
	                        }
	                    }
	                }
	            }
	        }
	        if (hasErrors) {
	            throw new UnsubscriptionError_1.UnsubscriptionError(errors);
	        }
	    };
	    /**
	     * Adds a tear down to be called during the unsubscribe() of this
	     * Subscription.
	     *
	     * If the tear down being added is a subscription that is already
	     * unsubscribed, is the same reference `add` is being called on, or is
	     * `Subscription.EMPTY`, it will not be added.
	     *
	     * If this subscription is already in an `closed` state, the passed
	     * tear down logic will be executed immediately.
	     *
	     * @param {TeardownLogic} teardown The additional logic to execute on
	     * teardown.
	     * @return {Subscription} Returns the Subscription used or created to be
	     * added to the inner subscriptions list. This Subscription can be used with
	     * `remove()` to remove the passed teardown logic from the inner subscriptions
	     * list.
	     */
	    Subscription.prototype.add = function (teardown) {
	        if (!teardown || (teardown === Subscription.EMPTY)) {
	            return Subscription.EMPTY;
	        }
	        if (teardown === this) {
	            return this;
	        }
	        var sub = teardown;
	        switch (typeof teardown) {
	            case 'function':
	                sub = new Subscription(teardown);
	            case 'object':
	                if (sub.closed || typeof sub.unsubscribe !== 'function') {
	                    break;
	                }
	                else if (this.closed) {
	                    sub.unsubscribe();
	                }
	                else {
	                    (this._subscriptions || (this._subscriptions = [])).push(sub);
	                }
	                break;
	            default:
	                throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');
	        }
	        return sub;
	    };
	    /**
	     * Removes a Subscription from the internal list of subscriptions that will
	     * unsubscribe during the unsubscribe process of this Subscription.
	     * @param {Subscription} subscription The subscription to remove.
	     * @return {void}
	     */
	    Subscription.prototype.remove = function (subscription) {
	        // HACK: This might be redundant because of the logic in `add()`
	        if (subscription == null || (subscription === this) || (subscription === Subscription.EMPTY)) {
	            return;
	        }
	        var subscriptions = this._subscriptions;
	        if (subscriptions) {
	            var subscriptionIndex = subscriptions.indexOf(subscription);
	            if (subscriptionIndex !== -1) {
	                subscriptions.splice(subscriptionIndex, 1);
	            }
	        }
	    };
	    Subscription.EMPTY = (function (empty) {
	        empty.closed = true;
	        return empty;
	    }(new Subscription()));
	    return Subscription;
	}());
	exports.Subscription = Subscription;
	//# sourceMappingURL=Subscription.js.map

/***/ },
/* 11 */
/***/ function(module, exports) {

	"use strict";
	exports.isArray = Array.isArray || (function (x) { return x && typeof x.length === 'number'; });
	//# sourceMappingURL=isArray.js.map

/***/ },
/* 12 */
/***/ function(module, exports) {

	"use strict";
	function isObject(x) {
	    return x != null && typeof x === 'object';
	}
	exports.isObject = isObject;
	//# sourceMappingURL=isObject.js.map

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var errorObject_1 = __webpack_require__(14);
	var tryCatchTarget;
	function tryCatcher() {
	    try {
	        return tryCatchTarget.apply(this, arguments);
	    }
	    catch (e) {
	        errorObject_1.errorObject.e = e;
	        return errorObject_1.errorObject;
	    }
	}
	function tryCatch(fn) {
	    tryCatchTarget = fn;
	    return tryCatcher;
	}
	exports.tryCatch = tryCatch;
	;
	//# sourceMappingURL=tryCatch.js.map

/***/ },
/* 14 */
/***/ function(module, exports) {

	"use strict";
	// typeof any so that it we don't have to cast when comparing a result to the error object
	exports.errorObject = { e: {} };
	//# sourceMappingURL=errorObject.js.map

/***/ },
/* 15 */
/***/ function(module, exports) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/**
	 * An error thrown when one or more errors have occurred during the
	 * `unsubscribe` of a {@link Subscription}.
	 */
	var UnsubscriptionError = (function (_super) {
	    __extends(UnsubscriptionError, _super);
	    function UnsubscriptionError(errors) {
	        _super.call(this);
	        this.errors = errors;
	        var err = Error.call(this, errors ?
	            errors.length + " errors occurred during unsubscription:\n  " + errors.map(function (err, i) { return ((i + 1) + ") " + err.toString()); }).join('\n  ') : '');
	        this.name = err.name = 'UnsubscriptionError';
	        this.stack = err.stack;
	        this.message = err.message;
	    }
	    return UnsubscriptionError;
	}(Error));
	exports.UnsubscriptionError = UnsubscriptionError;
	//# sourceMappingURL=UnsubscriptionError.js.map

/***/ },
/* 16 */
/***/ function(module, exports) {

	"use strict";
	exports.empty = {
	    closed: true,
	    next: function (value) { },
	    error: function (err) { throw err; },
	    complete: function () { }
	};
	//# sourceMappingURL=Observer.js.map

/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var root_1 = __webpack_require__(6);
	var Symbol = root_1.root.Symbol;
	exports.$$rxSubscriber = (typeof Symbol === 'function' && typeof Symbol.for === 'function') ?
	    Symbol.for('rxSubscriber') : '@@rxSubscriber';
	//# sourceMappingURL=rxSubscriber.js.map

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var root_1 = __webpack_require__(6);
	function getSymbolObservable(context) {
	    var $$observable;
	    var Symbol = context.Symbol;
	    if (typeof Symbol === 'function') {
	        if (Symbol.observable) {
	            $$observable = Symbol.observable;
	        }
	        else {
	            $$observable = Symbol('observable');
	            Symbol.observable = $$observable;
	        }
	    }
	    else {
	        $$observable = '@@observable';
	    }
	    return $$observable;
	}
	exports.getSymbolObservable = getSymbolObservable;
	exports.$$observable = getSymbolObservable(root_1.root);
	//# sourceMappingURL=observable.js.map

/***/ },
/* 19 */
/***/ function(module, exports) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/**
	 * An error thrown when an action is invalid because the object has been
	 * unsubscribed.
	 *
	 * @see {@link Subject}
	 * @see {@link BehaviorSubject}
	 *
	 * @class ObjectUnsubscribedError
	 */
	var ObjectUnsubscribedError = (function (_super) {
	    __extends(ObjectUnsubscribedError, _super);
	    function ObjectUnsubscribedError() {
	        var err = _super.call(this, 'object unsubscribed');
	        this.name = err.name = 'ObjectUnsubscribedError';
	        this.stack = err.stack;
	        this.message = err.message;
	    }
	    return ObjectUnsubscribedError;
	}(Error));
	exports.ObjectUnsubscribedError = ObjectUnsubscribedError;
	//# sourceMappingURL=ObjectUnsubscribedError.js.map

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscription_1 = __webpack_require__(10);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var SubjectSubscription = (function (_super) {
	    __extends(SubjectSubscription, _super);
	    function SubjectSubscription(subject, subscriber) {
	        _super.call(this);
	        this.subject = subject;
	        this.subscriber = subscriber;
	        this.closed = false;
	    }
	    SubjectSubscription.prototype.unsubscribe = function () {
	        if (this.closed) {
	            return;
	        }
	        this.closed = true;
	        var subject = this.subject;
	        var observers = subject.observers;
	        this.subject = null;
	        if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {
	            return;
	        }
	        var subscriberIndex = observers.indexOf(this.subscriber);
	        if (subscriberIndex !== -1) {
	            observers.splice(subscriberIndex, 1);
	        }
	    };
	    return SubjectSubscription;
	}(Subscription_1.Subscription));
	exports.SubjectSubscription = SubjectSubscription;
	//# sourceMappingURL=SubjectSubscription.js.map

/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/**
	 * @license Angular v2.1.2
	 * (c) 2010-2016 Google, Inc. https://angular.io/
	 * License: MIT
	 */
	(function (global, factory) {
	     true ? factory(exports, __webpack_require__(22), __webpack_require__(3)) :
	    typeof define === 'function' && define.amd ? define(['exports', '@angular/common', '@angular/core'], factory) :
	    (factory((global.ng = global.ng || {}, global.ng.platformBrowser = global.ng.platformBrowser || {}),global.ng.common,global.ng.core));
	}(this, function (exports,_angular_common,_angular_core) { 'use strict';

	    var DebugDomRootRenderer = _angular_core.__core_private__.DebugDomRootRenderer;
	    var NoOpAnimationPlayer = _angular_core.__core_private__.NoOpAnimationPlayer;

	    var _NoOpAnimationDriver = (function () {
	        function _NoOpAnimationDriver() {
	        }
	        _NoOpAnimationDriver.prototype.animate = function (element, startingStyles, keyframes, duration, delay, easing) {
	            return new NoOpAnimationPlayer();
	        };
	        return _NoOpAnimationDriver;
	    }());
	    /**
	     * @experimental
	     */
	    var AnimationDriver = (function () {
	        function AnimationDriver() {
	        }
	        AnimationDriver.NOOP = new _NoOpAnimationDriver();
	        return AnimationDriver;
	    }());

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var globalScope;
	    if (typeof window === 'undefined') {
	        if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) {
	            // TODO: Replace any with WorkerGlobalScope from lib.webworker.d.ts #3492
	            globalScope = self;
	        }
	        else {
	            globalScope = global;
	        }
	    }
	    else {
	        globalScope = window;
	    }
	    // Need to declare a new variable for global here since TypeScript
	    // exports the original value of the symbol.
	    var global$1 = globalScope;
	    // TODO: remove calls to assert in production environment
	    // Note: Can't just export this and import in in other files
	    // as `assert` is a reserved keyword in Dart
	    global$1.assert = function assert(condition) {
	        // TODO: to be fixed properly via #2830, noop for now
	    };
	    function isPresent(obj) {
	        return obj != null;
	    }
	    function isBlank(obj) {
	        return obj == null;
	    }
	    function stringify(token) {
	        if (typeof token === 'string') {
	            return token;
	        }
	        if (token === undefined || token === null) {
	            return '' + token;
	        }
	        if (token.overriddenName) {
	            return token.overriddenName;
	        }
	        if (token.name) {
	            return token.name;
	        }
	        var res = token.toString();
	        var newLineIndex = res.indexOf('\n');
	        return newLineIndex === -1 ? res : res.substring(0, newLineIndex);
	    }
	    function setValueOnPath(global, path, value) {
	        var parts = path.split('.');
	        var obj = global;
	        while (parts.length > 1) {
	            var name = parts.shift();
	            if (obj.hasOwnProperty(name) && isPresent(obj[name])) {
	                obj = obj[name];
	            }
	            else {
	                obj = obj[name] = {};
	            }
	        }
	        if (obj === undefined || obj === null) {
	            obj = {};
	        }
	        obj[parts.shift()] = value;
	    }

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var CAMEL_CASE_REGEXP = /([A-Z])/g;
	    var DASH_CASE_REGEXP = /-([a-z])/g;
	    function camelCaseToDashCase(input) {
	        return input.replace(CAMEL_CASE_REGEXP, function () {
	            var m = [];
	            for (var _i = 0; _i < arguments.length; _i++) {
	                m[_i - 0] = arguments[_i];
	            }
	            return '-' + m[1].toLowerCase();
	        });
	    }
	    function dashCaseToCamelCase(input) {
	        return input.replace(DASH_CASE_REGEXP, function () {
	            var m = [];
	            for (var _i = 0; _i < arguments.length; _i++) {
	                m[_i - 0] = arguments[_i];
	            }
	            return m[1].toUpperCase();
	        });
	    }

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var _DOM = null;
	    function getDOM() {
	        return _DOM;
	    }
	    function setRootDomAdapter(adapter) {
	        if (!_DOM) {
	            _DOM = adapter;
	        }
	    }
	    /* tslint:disable:requireParameterType */
	    /**
	     * Provides DOM operations in an environment-agnostic way.
	     *
	     * @security Tread carefully! Interacting with the DOM directly is dangerous and
	     * can introduce XSS risks.
	     */
	    var DomAdapter = (function () {
	        function DomAdapter() {
	            this.resourceLoaderType = null;
	        }
	        Object.defineProperty(DomAdapter.prototype, "attrToPropMap", {
	            /**
	             * Maps attribute names to their corresponding property names for cases
	             * where attribute name doesn't match property name.
	             */
	            get: function () { return this._attrToPropMap; },
	            set: function (value) { this._attrToPropMap = value; },
	            enumerable: true,
	            configurable: true
	        });
	        ;
	        ;
	        return DomAdapter;
	    }());

	    var WebAnimationsPlayer = (function () {
	        function WebAnimationsPlayer(element, keyframes, options) {
	            this.element = element;
	            this.keyframes = keyframes;
	            this.options = options;
	            this._onDoneFns = [];
	            this._onStartFns = [];
	            this._finished = false;
	            this._initialized = false;
	            this._started = false;
	            this.parentPlayer = null;
	            this._duration = options['duration'];
	        }
	        WebAnimationsPlayer.prototype._onFinish = function () {
	            if (!this._finished) {
	                this._finished = true;
	                if (!isPresent(this.parentPlayer)) {
	                    this.destroy();
	                }
	                this._onDoneFns.forEach(function (fn) { return fn(); });
	                this._onDoneFns = [];
	            }
	        };
	        WebAnimationsPlayer.prototype.init = function () {
	            var _this = this;
	            if (this._initialized)
	                return;
	            this._initialized = true;
	            var keyframes = this.keyframes.map(function (styles) {
	                var formattedKeyframe = {};
	                Object.keys(styles).forEach(function (prop) {
	                    var value = styles[prop];
	                    formattedKeyframe[prop] = value == _angular_core.AUTO_STYLE ? _computeStyle(_this.element, prop) : value;
	                });
	                return formattedKeyframe;
	            });
	            this._player = this._triggerWebAnimation(this.element, keyframes, this.options);
	            // this is required so that the player doesn't start to animate right away
	            this.reset();
	            this._player.onfinish = function () { return _this._onFinish(); };
	        };
	        /** @internal */
	        WebAnimationsPlayer.prototype._triggerWebAnimation = function (element, keyframes, options) {
	            return element.animate(keyframes, options);
	        };
	        WebAnimationsPlayer.prototype.onStart = function (fn) { this._onStartFns.push(fn); };
	        WebAnimationsPlayer.prototype.onDone = function (fn) { this._onDoneFns.push(fn); };
	        WebAnimationsPlayer.prototype.play = function () {
	            this.init();
	            if (!this.hasStarted()) {
	                this._onStartFns.forEach(function (fn) { return fn(); });
	                this._onStartFns = [];
	                this._started = true;
	            }
	            this._player.play();
	        };
	        WebAnimationsPlayer.prototype.pause = function () {
	            this.init();
	            this._player.pause();
	        };
	        WebAnimationsPlayer.prototype.finish = function () {
	            this.init();
	            this._onFinish();
	            this._player.finish();
	        };
	        WebAnimationsPlayer.prototype.reset = function () { this._player.cancel(); };
	        WebAnimationsPlayer.prototype.restart = function () {
	            this.reset();
	            this.play();
	        };
	        WebAnimationsPlayer.prototype.hasStarted = function () { return this._started; };
	        WebAnimationsPlayer.prototype.destroy = function () {
	            this.reset();
	            this._onFinish();
	        };
	        Object.defineProperty(WebAnimationsPlayer.prototype, "totalTime", {
	            get: function () { return this._duration; },
	            enumerable: true,
	            configurable: true
	        });
	        WebAnimationsPlayer.prototype.setPosition = function (p) { this._player.currentTime = p * this.totalTime; };
	        WebAnimationsPlayer.prototype.getPosition = function () { return this._player.currentTime / this.totalTime; };
	        return WebAnimationsPlayer;
	    }());
	    function _computeStyle(element, prop) {
	        return getDOM().getComputedStyle(element)[prop];
	    }

	    var WebAnimationsDriver = (function () {
	        function WebAnimationsDriver() {
	        }
	        WebAnimationsDriver.prototype.animate = function (element, startingStyles, keyframes, duration, delay, easing) {
	            var formattedSteps = [];
	            var startingStyleLookup = {};
	            if (isPresent(startingStyles) && startingStyles.styles.length > 0) {
	                startingStyleLookup = _populateStyles(element, startingStyles, {});
	                startingStyleLookup['offset'] = 0;
	                formattedSteps.push(startingStyleLookup);
	            }
	            keyframes.forEach(function (keyframe) {
	                var data = _populateStyles(element, keyframe.styles, startingStyleLookup);
	                data['offset'] = keyframe.offset;
	                formattedSteps.push(data);
	            });
	            // this is a special case when only styles are applied as an
	            // animation. When this occurs we want to animate from start to
	            // end with the same values. Removing the offset and having only
	            // start/end values is suitable enough for the web-animations API
	            if (formattedSteps.length == 1) {
	                var start = formattedSteps[0];
	                start['offset'] = null;
	                formattedSteps = [start, start];
	            }
	            var playerOptions = {
	                'duration': duration,
	                'delay': delay,
	                'fill': 'both' // we use `both` because it allows for styling at 0% to work with `delay`
	            };
	            // we check for this to avoid having a null|undefined value be present
	            // for the easing (which results in an error for certain browsers #9752)
	            if (easing) {
	                playerOptions['easing'] = easing;
	            }
	            return new WebAnimationsPlayer(element, formattedSteps, playerOptions);
	        };
	        return WebAnimationsDriver;
	    }());
	    function _populateStyles(element, styles, defaultStyles) {
	        var data = {};
	        styles.styles.forEach(function (entry) {
	            Object.keys(entry).forEach(function (prop) {
	                var val = entry[prop];
	                var formattedProp = dashCaseToCamelCase(prop);
	                data[formattedProp] =
	                    val == _angular_core.AUTO_STYLE ? val : val.toString() + _resolveStyleUnit(val, prop, formattedProp);
	            });
	        });
	        Object.keys(defaultStyles).forEach(function (prop) {
	            if (!isPresent(data[prop])) {
	                data[prop] = defaultStyles[prop];
	            }
	        });
	        return data;
	    }
	    function _resolveStyleUnit(val, userProvidedProp, formattedProp) {
	        var unit = '';
	        if (_isPixelDimensionStyle(formattedProp) && val != 0 && val != '0') {
	            if (typeof val === 'number') {
	                unit = 'px';
	            }
	            else if (_findDimensionalSuffix(val.toString()).length == 0) {
	                throw new Error('Please provide a CSS unit value for ' + userProvidedProp + ':' + val);
	            }
	        }
	        return unit;
	    }
	    var _$0 = 48;
	    var _$9 = 57;
	    var _$PERIOD = 46;
	    function _findDimensionalSuffix(value) {
	        for (var i = 0; i < value.length; i++) {
	            var c = value.charCodeAt(i);
	            if ((c >= _$0 && c <= _$9) || c == _$PERIOD)
	                continue;
	            return value.substring(i, value.length);
	        }
	        return '';
	    }
	    function _isPixelDimensionStyle(prop) {
	        switch (prop) {
	            case 'width':
	            case 'height':
	            case 'minWidth':
	            case 'minHeight':
	            case 'maxWidth':
	            case 'maxHeight':
	            case 'left':
	            case 'top':
	            case 'bottom':
	            case 'right':
	            case 'fontSize':
	            case 'outlineWidth':
	            case 'outlineOffset':
	            case 'paddingTop':
	            case 'paddingLeft':
	            case 'paddingBottom':
	            case 'paddingRight':
	            case 'marginTop':
	            case 'marginLeft':
	            case 'marginBottom':
	            case 'marginRight':
	            case 'borderRadius':
	            case 'borderWidth':
	            case 'borderTopWidth':
	            case 'borderLeftWidth':
	            case 'borderRightWidth':
	            case 'borderBottomWidth':
	            case 'textIndent':
	                return true;
	            default:
	                return false;
	        }
	    }

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$1 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    /**
	     * Provides DOM operations in any browser environment.
	     *
	     * @security Tread carefully! Interacting with the DOM directly is dangerous and
	     * can introduce XSS risks.
	     */
	    var GenericBrowserDomAdapter = (function (_super) {
	        __extends$1(GenericBrowserDomAdapter, _super);
	        function GenericBrowserDomAdapter() {
	            var _this = this;
	            _super.call(this);
	            this._animationPrefix = null;
	            this._transitionEnd = null;
	            try {
	                var element_1 = this.createElement('div', this.defaultDoc());
	                if (isPresent(this.getStyle(element_1, 'animationName'))) {
	                    this._animationPrefix = '';
	                }
	                else {
	                    var domPrefixes = ['Webkit', 'Moz', 'O', 'ms'];
	                    for (var i = 0; i < domPrefixes.length; i++) {
	                        if (isPresent(this.getStyle(element_1, domPrefixes[i] + 'AnimationName'))) {
	                            this._animationPrefix = '-' + domPrefixes[i].toLowerCase() + '-';
	                            break;
	                        }
	                    }
	                }
	                var transEndEventNames_1 = {
	                    WebkitTransition: 'webkitTransitionEnd',
	                    MozTransition: 'transitionend',
	                    OTransition: 'oTransitionEnd otransitionend',
	                    transition: 'transitionend'
	                };
	                Object.keys(transEndEventNames_1).forEach(function (key) {
	                    if (isPresent(_this.getStyle(element_1, key))) {
	                        _this._transitionEnd = transEndEventNames_1[key];
	                    }
	                });
	            }
	            catch (e) {
	                this._animationPrefix = null;
	                this._transitionEnd = null;
	            }
	        }
	        GenericBrowserDomAdapter.prototype.getDistributedNodes = function (el) { return el.getDistributedNodes(); };
	        GenericBrowserDomAdapter.prototype.resolveAndSetHref = function (el, baseUrl, href) {
	            el.href = href == null ? baseUrl : baseUrl + '/../' + href;
	        };
	        GenericBrowserDomAdapter.prototype.supportsDOMEvents = function () { return true; };
	        GenericBrowserDomAdapter.prototype.supportsNativeShadowDOM = function () {
	            return typeof this.defaultDoc().body.createShadowRoot === 'function';
	        };
	        GenericBrowserDomAdapter.prototype.getAnimationPrefix = function () { return this._animationPrefix ? this._animationPrefix : ''; };
	        GenericBrowserDomAdapter.prototype.getTransitionEnd = function () { return this._transitionEnd ? this._transitionEnd : ''; };
	        GenericBrowserDomAdapter.prototype.supportsAnimation = function () {
	            return isPresent(this._animationPrefix) && isPresent(this._transitionEnd);
	        };
	        return GenericBrowserDomAdapter;
	    }(DomAdapter));

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    var _attrToPropMap = {
	        'class': 'className',
	        'innerHtml': 'innerHTML',
	        'readonly': 'readOnly',
	        'tabindex': 'tabIndex',
	    };
	    var DOM_KEY_LOCATION_NUMPAD = 3;
	    // Map to convert some key or keyIdentifier values to what will be returned by getEventKey
	    var _keyMap = {
	        // The following values are here for cross-browser compatibility and to match the W3C standard
	        // cf http://www.w3.org/TR/DOM-Level-3-Events-key/
	        '\b': 'Backspace',
	        '\t': 'Tab',
	        '\x7F': 'Delete',
	        '\x1B': 'Escape',
	        'Del': 'Delete',
	        'Esc': 'Escape',
	        'Left': 'ArrowLeft',
	        'Right': 'ArrowRight',
	        'Up': 'ArrowUp',
	        'Down': 'ArrowDown',
	        'Menu': 'ContextMenu',
	        'Scroll': 'ScrollLock',
	        'Win': 'OS'
	    };
	    // There is a bug in Chrome for numeric keypad keys:
	    // https://code.google.com/p/chromium/issues/detail?id=155654
	    // 1, 2, 3 ... are reported as A, B, C ...
	    var _chromeNumKeyPadMap = {
	        'A': '1',
	        'B': '2',
	        'C': '3',
	        'D': '4',
	        'E': '5',
	        'F': '6',
	        'G': '7',
	        'H': '8',
	        'I': '9',
	        'J': '*',
	        'K': '+',
	        'M': '-',
	        'N': '.',
	        'O': '/',
	        '\x60': '0',
	        '\x90': 'NumLock'
	    };
	    /**
	     * A `DomAdapter` powered by full browser DOM APIs.
	     *
	     * @security Tread carefully! Interacting with the DOM directly is dangerous and
	     * can introduce XSS risks.
	     */
	    /* tslint:disable:requireParameterType */
	    var BrowserDomAdapter = (function (_super) {
	        __extends(BrowserDomAdapter, _super);
	        function BrowserDomAdapter() {
	            _super.apply(this, arguments);
	        }
	        BrowserDomAdapter.prototype.parse = function (templateHtml) { throw new Error('parse not implemented'); };
	        BrowserDomAdapter.makeCurrent = function () { setRootDomAdapter(new BrowserDomAdapter()); };
	        BrowserDomAdapter.prototype.hasProperty = function (element, name) { return name in element; };
	        BrowserDomAdapter.prototype.setProperty = function (el, name, value) { el[name] = value; };
	        BrowserDomAdapter.prototype.getProperty = function (el, name) { return el[name]; };
	        BrowserDomAdapter.prototype.invoke = function (el, methodName, args) { (_a = el)[methodName].apply(_a, args); var _a; };
	        // TODO(tbosch): move this into a separate environment class once we have it
	        BrowserDomAdapter.prototype.logError = function (error) { (window.console.error || window.console.log)(error); };
	        BrowserDomAdapter.prototype.log = function (error) { window.console.log(error); };
	        BrowserDomAdapter.prototype.logGroup = function (error) {
	            window.console.group && window.console.group(error);
	            this.logError(error);
	        };
	        BrowserDomAdapter.prototype.logGroupEnd = function () { window.console.groupEnd && window.console.groupEnd(); };
	        Object.defineProperty(BrowserDomAdapter.prototype, "attrToPropMap", {
	            get: function () { return _attrToPropMap; },
	            enumerable: true,
	            configurable: true
	        });
	        BrowserDomAdapter.prototype.query = function (selector) { return document.querySelector(selector); };
	        BrowserDomAdapter.prototype.querySelector = function (el, selector) {
	            return el.querySelector(selector);
	        };
	        BrowserDomAdapter.prototype.querySelectorAll = function (el, selector) { return el.querySelectorAll(selector); };
	        BrowserDomAdapter.prototype.on = function (el, evt, listener) { el.addEventListener(evt, listener, false); };
	        BrowserDomAdapter.prototype.onAndCancel = function (el, evt, listener) {
	            el.addEventListener(evt, listener, false);
	            // Needed to follow Dart's subscription semantic, until fix of
	            // https://code.google.com/p/dart/issues/detail?id=17406
	            return function () { el.removeEventListener(evt, listener, false); };
	        };
	        BrowserDomAdapter.prototype.dispatchEvent = function (el, evt) { el.dispatchEvent(evt); };
	        BrowserDomAdapter.prototype.createMouseEvent = function (eventType) {
	            var evt = document.createEvent('MouseEvent');
	            evt.initEvent(eventType, true, true);
	            return evt;
	        };
	        BrowserDomAdapter.prototype.createEvent = function (eventType) {
	            var evt = document.createEvent('Event');
	            evt.initEvent(eventType, true, true);
	            return evt;
	        };
	        BrowserDomAdapter.prototype.preventDefault = function (evt) {
	            evt.preventDefault();
	            evt.returnValue = false;
	        };
	        BrowserDomAdapter.prototype.isPrevented = function (evt) {
	            return evt.defaultPrevented || isPresent(evt.returnValue) && !evt.returnValue;
	        };
	        BrowserDomAdapter.prototype.getInnerHTML = function (el) { return el.innerHTML; };
	        BrowserDomAdapter.prototype.getTemplateContent = function (el) {
	            return 'content' in el && el instanceof HTMLTemplateElement ? el.content : null;
	        };
	        BrowserDomAdapter.prototype.getOuterHTML = function (el) { return el.outerHTML; };
	        BrowserDomAdapter.prototype.nodeName = function (node) { return node.nodeName; };
	        BrowserDomAdapter.prototype.nodeValue = function (node) { return node.nodeValue; };
	        BrowserDomAdapter.prototype.type = function (node) { return node.type; };
	        BrowserDomAdapter.prototype.content = function (node) {
	            if (this.hasProperty(node, 'content')) {
	                return node.content;
	            }
	            else {
	                return node;
	            }
	        };
	        BrowserDomAdapter.prototype.firstChild = function (el) { return el.firstChild; };
	        BrowserDomAdapter.prototype.nextSibling = function (el) { return el.nextSibling; };
	        BrowserDomAdapter.prototype.parentElement = function (el) { return el.parentNode; };
	        BrowserDomAdapter.prototype.childNodes = function (el) { return el.childNodes; };
	        BrowserDomAdapter.prototype.childNodesAsList = function (el) {
	            var childNodes = el.childNodes;
	            var res = new Array(childNodes.length);
	            for (var i = 0; i < childNodes.length; i++) {
	                res[i] = childNodes[i];
	            }
	            return res;
	        };
	        BrowserDomAdapter.prototype.clearNodes = function (el) {
	            while (el.firstChild) {
	                el.removeChild(el.firstChild);
	            }
	        };
	        BrowserDomAdapter.prototype.appendChild = function (el, node) { el.appendChild(node); };
	        BrowserDomAdapter.prototype.removeChild = function (el, node) { el.removeChild(node); };
	        BrowserDomAdapter.prototype.replaceChild = function (el, newChild, oldChild) { el.replaceChild(newChild, oldChild); };
	        BrowserDomAdapter.prototype.remove = function (node) {
	            if (node.parentNode) {
	                node.parentNode.removeChild(node);
	            }
	            return node;
	        };
	        BrowserDomAdapter.prototype.insertBefore = function (el, node) { el.parentNode.insertBefore(node, el); };
	        BrowserDomAdapter.prototype.insertAllBefore = function (el, nodes) {
	            nodes.forEach(function (n) { return el.parentNode.insertBefore(n, el); });
	        };
	        BrowserDomAdapter.prototype.insertAfter = function (el, node) { el.parentNode.insertBefore(node, el.nextSibling); };
	        BrowserDomAdapter.prototype.setInnerHTML = function (el, value) { el.innerHTML = value; };
	        BrowserDomAdapter.prototype.getText = function (el) { return el.textContent; };
	        BrowserDomAdapter.prototype.setText = function (el, value) { el.textContent = value; };
	        BrowserDomAdapter.prototype.getValue = function (el) { return el.value; };
	        BrowserDomAdapter.prototype.setValue = function (el, value) { el.value = value; };
	        BrowserDomAdapter.prototype.getChecked = function (el) { return el.checked; };
	        BrowserDomAdapter.prototype.setChecked = function (el, value) { el.checked = value; };
	        BrowserDomAdapter.prototype.createComment = function (text) { return document.createComment(text); };
	        BrowserDomAdapter.prototype.createTemplate = function (html) {
	            var t = document.createElement('template');
	            t.innerHTML = html;
	            return t;
	        };
	        BrowserDomAdapter.prototype.createElement = function (tagName, doc) {
	            if (doc === void 0) { doc = document; }
	            return doc.createElement(tagName);
	        };
	        BrowserDomAdapter.prototype.createElementNS = function (ns, tagName, doc) {
	            if (doc === void 0) { doc = document; }
	            return doc.createElementNS(ns, tagName);
	        };
	        BrowserDomAdapter.prototype.createTextNode = function (text, doc) {
	            if (doc === void 0) { doc = document; }
	            return doc.createTextNode(text);
	        };
	        BrowserDomAdapter.prototype.createScriptTag = function (attrName, attrValue, doc) {
	            if (doc === void 0) { doc = document; }
	            var el = doc.createElement('SCRIPT');
	            el.setAttribute(attrName, attrValue);
	            return el;
	        };
	        BrowserDomAdapter.prototype.createStyleElement = function (css, doc) {
	            if (doc === void 0) { doc = document; }
	            var style = doc.createElement('style');
	            this.appendChild(style, this.createTextNode(css));
	            return style;
	        };
	        BrowserDomAdapter.prototype.createShadowRoot = function (el) { return el.createShadowRoot(); };
	        BrowserDomAdapter.prototype.getShadowRoot = function (el) { return el.shadowRoot; };
	        BrowserDomAdapter.prototype.getHost = function (el) { return el.host; };
	        BrowserDomAdapter.prototype.clone = function (node) { return node.cloneNode(true); };
	        BrowserDomAdapter.prototype.getElementsByClassName = function (element, name) {
	            return element.getElementsByClassName(name);
	        };
	        BrowserDomAdapter.prototype.getElementsByTagName = function (element, name) {
	            return element.getElementsByTagName(name);
	        };
	        BrowserDomAdapter.prototype.classList = function (element) { return Array.prototype.slice.call(element.classList, 0); };
	        BrowserDomAdapter.prototype.addClass = function (element, className) { element.classList.add(className); };
	        BrowserDomAdapter.prototype.removeClass = function (element, className) { element.classList.remove(className); };
	        BrowserDomAdapter.prototype.hasClass = function (element, className) {
	            return element.classList.contains(className);
	        };
	        BrowserDomAdapter.prototype.setStyle = function (element, styleName, styleValue) {
	            element.style[styleName] = styleValue;
	        };
	        BrowserDomAdapter.prototype.removeStyle = function (element, stylename) {
	            // IE requires '' instead of null
	            // see https://github.com/angular/angular/issues/7916
	            element.style[stylename] = '';
	        };
	        BrowserDomAdapter.prototype.getStyle = function (element, stylename) { return element.style[stylename]; };
	        BrowserDomAdapter.prototype.hasStyle = function (element, styleName, styleValue) {
	            if (styleValue === void 0) { styleValue = null; }
	            var value = this.getStyle(element, styleName) || '';
	            return styleValue ? value == styleValue : value.length > 0;
	        };
	        BrowserDomAdapter.prototype.tagName = function (element) { return element.tagName; };
	        BrowserDomAdapter.prototype.attributeMap = function (element) {
	            var res = new Map();
	            var elAttrs = element.attributes;
	            for (var i = 0; i < elAttrs.length; i++) {
	                var attrib = elAttrs[i];
	                res.set(attrib.name, attrib.value);
	            }
	            return res;
	        };
	        BrowserDomAdapter.prototype.hasAttribute = function (element, attribute) {
	            return element.hasAttribute(attribute);
	        };
	        BrowserDomAdapter.prototype.hasAttributeNS = function (element, ns, attribute) {
	            return element.hasAttributeNS(ns, attribute);
	        };
	        BrowserDomAdapter.prototype.getAttribute = function (element, attribute) {
	            return element.getAttribute(attribute);
	        };
	        BrowserDomAdapter.prototype.getAttributeNS = function (element, ns, name) {
	            return element.getAttributeNS(ns, name);
	        };
	        BrowserDomAdapter.prototype.setAttribute = function (element, name, value) { element.setAttribute(name, value); };
	        BrowserDomAdapter.prototype.setAttributeNS = function (element, ns, name, value) {
	            element.setAttributeNS(ns, name, value);
	        };
	        BrowserDomAdapter.prototype.removeAttribute = function (element, attribute) { element.removeAttribute(attribute); };
	        BrowserDomAdapter.prototype.removeAttributeNS = function (element, ns, name) {
	            element.removeAttributeNS(ns, name);
	        };
	        BrowserDomAdapter.prototype.templateAwareRoot = function (el) { return this.isTemplateElement(el) ? this.content(el) : el; };
	        BrowserDomAdapter.prototype.createHtmlDocument = function () {
	            return document.implementation.createHTMLDocument('fakeTitle');
	        };
	        BrowserDomAdapter.prototype.defaultDoc = function () { return document; };
	        BrowserDomAdapter.prototype.getBoundingClientRect = function (el) {
	            try {
	                return el.getBoundingClientRect();
	            }
	            catch (e) {
	                return { top: 0, bottom: 0, left: 0, right: 0, width: 0, height: 0 };
	            }
	        };
	        BrowserDomAdapter.prototype.getTitle = function () { return document.title; };
	        BrowserDomAdapter.prototype.setTitle = function (newTitle) { document.title = newTitle || ''; };
	        BrowserDomAdapter.prototype.elementMatches = function (n, selector) {
	            if (n instanceof HTMLElement) {
	                return n.matches && n.matches(selector) ||
	                    n.msMatchesSelector && n.msMatchesSelector(selector) ||
	                    n.webkitMatchesSelector && n.webkitMatchesSelector(selector);
	            }
	            return false;
	        };
	        BrowserDomAdapter.prototype.isTemplateElement = function (el) {
	            return el instanceof HTMLElement && el.nodeName == 'TEMPLATE';
	        };
	        BrowserDomAdapter.prototype.isTextNode = function (node) { return node.nodeType === Node.TEXT_NODE; };
	        BrowserDomAdapter.prototype.isCommentNode = function (node) { return node.nodeType === Node.COMMENT_NODE; };
	        BrowserDomAdapter.prototype.isElementNode = function (node) { return node.nodeType === Node.ELEMENT_NODE; };
	        BrowserDomAdapter.prototype.hasShadowRoot = function (node) {
	            return isPresent(node.shadowRoot) && node instanceof HTMLElement;
	        };
	        BrowserDomAdapter.prototype.isShadowRoot = function (node) { return node instanceof DocumentFragment; };
	        BrowserDomAdapter.prototype.importIntoDoc = function (node) { return document.importNode(this.templateAwareRoot(node), true); };
	        BrowserDomAdapter.prototype.adoptNode = function (node) { return document.adoptNode(node); };
	        BrowserDomAdapter.prototype.getHref = function (el) { return el.href; };
	        BrowserDomAdapter.prototype.getEventKey = function (event) {
	            var key = event.key;
	            if (isBlank(key)) {
	                key = event.keyIdentifier;
	                // keyIdentifier is defined in the old draft of DOM Level 3 Events implemented by Chrome and
	                // Safari cf
	                // http://www.w3.org/TR/2007/WD-DOM-Level-3-Events-20071221/events.html#Events-KeyboardEvents-Interfaces
	                if (isBlank(key)) {
	                    return 'Unidentified';
	                }
	                if (key.startsWith('U+')) {
	                    key = String.fromCharCode(parseInt(key.substring(2), 16));
	                    if (event.location === DOM_KEY_LOCATION_NUMPAD && _chromeNumKeyPadMap.hasOwnProperty(key)) {
	                        // There is a bug in Chrome for numeric keypad keys:
	                        // https://code.google.com/p/chromium/issues/detail?id=155654
	                        // 1, 2, 3 ... are reported as A, B, C ...
	                        key = _chromeNumKeyPadMap[key];
	                    }
	                }
	            }
	            return _keyMap[key] || key;
	        };
	        BrowserDomAdapter.prototype.getGlobalEventTarget = function (target) {
	            if (target === 'window') {
	                return window;
	            }
	            if (target === 'document') {
	                return document;
	            }
	            if (target === 'body') {
	                return document.body;
	            }
	        };
	        BrowserDomAdapter.prototype.getHistory = function () { return window.history; };
	        BrowserDomAdapter.prototype.getLocation = function () { return window.location; };
	        BrowserDomAdapter.prototype.getBaseHref = function () {
	            var href = getBaseElementHref();
	            return isBlank(href) ? null : relativePath(href);
	        };
	        BrowserDomAdapter.prototype.resetBaseElement = function () { baseElement = null; };
	        BrowserDomAdapter.prototype.getUserAgent = function () { return window.navigator.userAgent; };
	        BrowserDomAdapter.prototype.setData = function (element, name, value) {
	            this.setAttribute(element, 'data-' + name, value);
	        };
	        BrowserDomAdapter.prototype.getData = function (element, name) {
	            return this.getAttribute(element, 'data-' + name);
	        };
	        BrowserDomAdapter.prototype.getComputedStyle = function (element) { return getComputedStyle(element); };
	        // TODO(tbosch): move this into a separate environment class once we have it
	        BrowserDomAdapter.prototype.setGlobalVar = function (path, value) { setValueOnPath(global$1, path, value); };
	        BrowserDomAdapter.prototype.supportsWebAnimation = function () {
	            return typeof Element.prototype['animate'] === 'function';
	        };
	        BrowserDomAdapter.prototype.performanceNow = function () {
	            // performance.now() is not available in all browsers, see
	            // http://caniuse.com/#search=performance.now
	            return window.performance && window.performance.now ? window.performance.now() :
	                new Date().getTime();
	        };
	        BrowserDomAdapter.prototype.supportsCookies = function () { return true; };
	        BrowserDomAdapter.prototype.getCookie = function (name) { return parseCookieValue(document.cookie, name); };
	        BrowserDomAdapter.prototype.setCookie = function (name, value) {
	            // document.cookie is magical, assigning into it assigns/overrides one cookie value, but does
	            // not clear other cookies.
	            document.cookie = encodeURIComponent(name) + '=' + encodeURIComponent(value);
	        };
	        return BrowserDomAdapter;
	    }(GenericBrowserDomAdapter));
	    var baseElement = null;
	    function getBaseElementHref() {
	        if (!baseElement) {
	            baseElement = document.querySelector('base');
	            if (!baseElement) {
	                return null;
	            }
	        }
	        return baseElement.getAttribute('href');
	    }
	    // based on urlUtils.js in AngularJS 1
	    var urlParsingNode;
	    function relativePath(url) {
	        if (!urlParsingNode) {
	            urlParsingNode = document.createElement('a');
	        }
	        urlParsingNode.setAttribute('href', url);
	        return (urlParsingNode.pathname.charAt(0) === '/') ? urlParsingNode.pathname :
	            '/' + urlParsingNode.pathname;
	    }
	    function parseCookieValue(cookieStr, name) {
	        name = encodeURIComponent(name);
	        for (var _i = 0, _a = cookieStr.split(';'); _i < _a.length; _i++) {
	            var cookie = _a[_i];
	            var eqIndex = cookie.indexOf('=');
	            var _b = eqIndex == -1 ? [cookie, ''] : [cookie.slice(0, eqIndex), cookie.slice(eqIndex + 1)], cookieName = _b[0], cookieValue = _b[1];
	            if (cookieName.trim() === name) {
	                return decodeURIComponent(cookieValue);
	            }
	        }
	        return null;
	    }

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    function supportsState() {
	        return !!window.history.pushState;
	    }

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$2 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    /**
	     * `PlatformLocation` encapsulates all of the direct calls to platform APIs.
	     * This class should not be used directly by an application developer. Instead, use
	     * {@link Location}.
	     */
	    var BrowserPlatformLocation = (function (_super) {
	        __extends$2(BrowserPlatformLocation, _super);
	        function BrowserPlatformLocation() {
	            _super.call(this);
	            this._init();
	        }
	        // This is moved to its own method so that `MockPlatformLocationStrategy` can overwrite it
	        /** @internal */
	        BrowserPlatformLocation.prototype._init = function () {
	            this._location = getDOM().getLocation();
	            this._history = getDOM().getHistory();
	        };
	        Object.defineProperty(BrowserPlatformLocation.prototype, "location", {
	            get: function () { return this._location; },
	            enumerable: true,
	            configurable: true
	        });
	        BrowserPlatformLocation.prototype.getBaseHrefFromDOM = function () { return getDOM().getBaseHref(); };
	        BrowserPlatformLocation.prototype.onPopState = function (fn) {
	            getDOM().getGlobalEventTarget('window').addEventListener('popstate', fn, false);
	        };
	        BrowserPlatformLocation.prototype.onHashChange = function (fn) {
	            getDOM().getGlobalEventTarget('window').addEventListener('hashchange', fn, false);
	        };
	        Object.defineProperty(BrowserPlatformLocation.prototype, "pathname", {
	            get: function () { return this._location.pathname; },
	            set: function (newPath) { this._location.pathname = newPath; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(BrowserPlatformLocation.prototype, "search", {
	            get: function () { return this._location.search; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(BrowserPlatformLocation.prototype, "hash", {
	            get: function () { return this._location.hash; },
	            enumerable: true,
	            configurable: true
	        });
	        BrowserPlatformLocation.prototype.pushState = function (state, title, url) {
	            if (supportsState()) {
	                this._history.pushState(state, title, url);
	            }
	            else {
	                this._location.hash = url;
	            }
	        };
	        BrowserPlatformLocation.prototype.replaceState = function (state, title, url) {
	            if (supportsState()) {
	                this._history.replaceState(state, title, url);
	            }
	            else {
	                this._location.hash = url;
	            }
	        };
	        BrowserPlatformLocation.prototype.forward = function () { this._history.forward(); };
	        BrowserPlatformLocation.prototype.back = function () { this._history.back(); };
	        BrowserPlatformLocation.decorators = [
	            { type: _angular_core.Injectable },
	        ];
	        /** @nocollapse */
	        BrowserPlatformLocation.ctorParameters = [];
	        return BrowserPlatformLocation;
	    }(_angular_common.PlatformLocation));

	    var BrowserGetTestability = (function () {
	        function BrowserGetTestability() {
	        }
	        BrowserGetTestability.init = function () { _angular_core.setTestabilityGetter(new BrowserGetTestability()); };
	        BrowserGetTestability.prototype.addToWindow = function (registry) {
	            global$1.getAngularTestability = function (elem, findInAncestors) {
	                if (findInAncestors === void 0) { findInAncestors = true; }
	                var testability = registry.findTestabilityInTree(elem, findInAncestors);
	                if (testability == null) {
	                    throw new Error('Could not find testability for element.');
	                }
	                return testability;
	            };
	            global$1.getAllAngularTestabilities = function () { return registry.getAllTestabilities(); };
	            global$1.getAllAngularRootElements = function () { return registry.getAllRootElements(); };
	            var whenAllStable = function (callback /** TODO #9100 */) {
	                var testabilities = global$1.getAllAngularTestabilities();
	                var count = testabilities.length;
	                var didWork = false;
	                var decrement = function (didWork_ /** TODO #9100 */) {
	                    didWork = didWork || didWork_;
	                    count--;
	                    if (count == 0) {
	                        callback(didWork);
	                    }
	                };
	                testabilities.forEach(function (testability /** TODO #9100 */) {
	                    testability.whenStable(decrement);
	                });
	            };
	            if (!global$1['frameworkStabilizers']) {
	                global$1['frameworkStabilizers'] = [];
	            }
	            global$1['frameworkStabilizers'].push(whenAllStable);
	        };
	        BrowserGetTestability.prototype.findTestabilityInTree = function (registry, elem, findInAncestors) {
	            if (elem == null) {
	                return null;
	            }
	            var t = registry.getTestability(elem);
	            if (isPresent(t)) {
	                return t;
	            }
	            else if (!findInAncestors) {
	                return null;
	            }
	            if (getDOM().isShadowRoot(elem)) {
	                return this.findTestabilityInTree(registry, getDOM().getHost(elem), true);
	            }
	            return this.findTestabilityInTree(registry, getDOM().parentElement(elem), true);
	        };
	        return BrowserGetTestability;
	    }());

	    /**
	     * A service that can be used to get and set the title of a current HTML document.
	     *
	     * Since an Angular 2 application can't be bootstrapped on the entire HTML document (`<html>` tag)
	     * it is not possible to bind to the `text` property of the `HTMLTitleElement` elements
	     * (representing the `<title>` tag). Instead, this service can be used to set and get the current
	     * title value.
	     *
	     * @experimental
	     */
	    var Title = (function () {
	        function Title() {
	        }
	        /**
	         * Get the title of the current HTML document.
	         * @returns {string}
	         */
	        Title.prototype.getTitle = function () { return getDOM().getTitle(); };
	        /**
	         * Set the title of the current HTML document.
	         * @param newTitle
	         */
	        Title.prototype.setTitle = function (newTitle) { getDOM().setTitle(newTitle); };
	        return Title;
	    }());

	    // Safari doesn't implement MapIterator.next(), which is used is Traceur's polyfill of Array.from
	    // TODO(mlaval): remove the work around once we have a working polyfill of Array.from
	    var _arrayFromMap = (function () {
	        try {
	            if ((new Map()).values().next) {
	                return function createArrayFromMap(m, getValues) {
	                    return getValues ? Array.from(m.values()) : Array.from(m.keys());
	                };
	            }
	        }
	        catch (e) {
	        }
	        return function createArrayFromMapWithForeach(m, getValues) {
	            var res = new Array(m.size), i = 0;
	            m.forEach(function (v, k) {
	                res[i] = getValues ? v : k;
	                i++;
	            });
	            return res;
	        };
	    })();
	    /**
	     * Wraps Javascript Objects
	     */
	    var StringMapWrapper = (function () {
	        function StringMapWrapper() {
	        }
	        StringMapWrapper.merge = function (m1, m2) {
	            var m = {};
	            for (var _i = 0, _a = Object.keys(m1); _i < _a.length; _i++) {
	                var k = _a[_i];
	                m[k] = m1[k];
	            }
	            for (var _b = 0, _c = Object.keys(m2); _b < _c.length; _b++) {
	                var k = _c[_b];
	                m[k] = m2[k];
	            }
	            return m;
	        };
	        StringMapWrapper.equals = function (m1, m2) {
	            var k1 = Object.keys(m1);
	            var k2 = Object.keys(m2);
	            if (k1.length != k2.length) {
	                return false;
	            }
	            for (var i = 0; i < k1.length; i++) {
	                var key = k1[i];
	                if (m1[key] !== m2[key]) {
	                    return false;
	                }
	            }
	            return true;
	        };
	        return StringMapWrapper;
	    }());
	    var ListWrapper = (function () {
	        function ListWrapper() {
	        }
	        ListWrapper.removeAll = function (list, items) {
	            for (var i = 0; i < items.length; ++i) {
	                var index = list.indexOf(items[i]);
	                list.splice(index, 1);
	            }
	        };
	        ListWrapper.remove = function (list, el) {
	            var index = list.indexOf(el);
	            if (index > -1) {
	                list.splice(index, 1);
	                return true;
	            }
	            return false;
	        };
	        ListWrapper.equals = function (a, b) {
	            if (a.length != b.length)
	                return false;
	            for (var i = 0; i < a.length; ++i) {
	                if (a[i] !== b[i])
	                    return false;
	            }
	            return true;
	        };
	        ListWrapper.maximum = function (list, predicate) {
	            if (list.length == 0) {
	                return null;
	            }
	            var solution = null;
	            var maxValue = -Infinity;
	            for (var index = 0; index < list.length; index++) {
	                var candidate = list[index];
	                if (candidate == null) {
	                    continue;
	                }
	                var candidateValue = predicate(candidate);
	                if (candidateValue > maxValue) {
	                    solution = candidate;
	                    maxValue = candidateValue;
	                }
	            }
	            return solution;
	        };
	        ListWrapper.flatten = function (list) {
	            var target = [];
	            _flattenArray(list, target);
	            return target;
	        };
	        return ListWrapper;
	    }());
	    function _flattenArray(source, target) {
	        if (isPresent(source)) {
	            for (var i = 0; i < source.length; i++) {
	                var item = source[i];
	                if (Array.isArray(item)) {
	                    _flattenArray(item, target);
	                }
	                else {
	                    target.push(item);
	                }
	            }
	        }
	        return target;
	    }

	    /**
	     * A DI Token representing the main rendering context. In a browser this is the DOM Document.
	     *
	     * Note: Document might not be available in the Application Context when Application and Rendering
	     * Contexts are not the same (e.g. when running the application into a Web Worker).
	     *
	     * @stable
	     */
	    var DOCUMENT = new _angular_core.OpaqueToken('DocumentToken');

	    /**
	     * @stable
	     */
	    var EVENT_MANAGER_PLUGINS = new _angular_core.OpaqueToken('EventManagerPlugins');
	    /**
	     * @stable
	     */
	    var EventManager = (function () {
	        function EventManager(plugins, _zone) {
	            var _this = this;
	            this._zone = _zone;
	            plugins.forEach(function (p) { return p.manager = _this; });
	            this._plugins = plugins.slice().reverse();
	        }
	        EventManager.prototype.addEventListener = function (element, eventName, handler) {
	            var plugin = this._findPluginFor(eventName);
	            return plugin.addEventListener(element, eventName, handler);
	        };
	        EventManager.prototype.addGlobalEventListener = function (target, eventName, handler) {
	            var plugin = this._findPluginFor(eventName);
	            return plugin.addGlobalEventListener(target, eventName, handler);
	        };
	        EventManager.prototype.getZone = function () { return this._zone; };
	        /** @internal */
	        EventManager.prototype._findPluginFor = function (eventName) {
	            var plugins = this._plugins;
	            for (var i = 0; i < plugins.length; i++) {
	                var plugin = plugins[i];
	                if (plugin.supports(eventName)) {
	                    return plugin;
	                }
	            }
	            throw new Error("No event manager plugin found for event " + eventName);
	        };
	        EventManager.decorators = [
	            { type: _angular_core.Injectable },
	        ];
	        /** @nocollapse */
	        EventManager.ctorParameters = [
	            { type: Array, decorators: [{ type: _angular_core.Inject, args: [EVENT_MANAGER_PLUGINS,] },] },
	            { type: _angular_core.NgZone, },
	        ];
	        return EventManager;
	    }());
	    var EventManagerPlugin = (function () {
	        function EventManagerPlugin() {
	        }
	        // That is equivalent to having supporting $event.target
	        EventManagerPlugin.prototype.supports = function (eventName) { return false; };
	        EventManagerPlugin.prototype.addEventListener = function (element, eventName, handler) {
	            throw 'not implemented';
	        };
	        EventManagerPlugin.prototype.addGlobalEventListener = function (element, eventName, handler) {
	            throw 'not implemented';
	        };
	        return EventManagerPlugin;
	    }());

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$4 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    var SharedStylesHost = (function () {
	        function SharedStylesHost() {
	            /** @internal */
	            this._styles = [];
	            /** @internal */
	            this._stylesSet = new Set();
	        }
	        SharedStylesHost.prototype.addStyles = function (styles) {
	            var _this = this;
	            var additions = [];
	            styles.forEach(function (style) {
	                if (!_this._stylesSet.has(style)) {
	                    _this._stylesSet.add(style);
	                    _this._styles.push(style);
	                    additions.push(style);
	                }
	            });
	            this.onStylesAdded(additions);
	        };
	        SharedStylesHost.prototype.onStylesAdded = function (additions) { };
	        SharedStylesHost.prototype.getAllStyles = function () { return this._styles; };
	        SharedStylesHost.decorators = [
	            { type: _angular_core.Injectable },
	        ];
	        /** @nocollapse */
	        SharedStylesHost.ctorParameters = [];
	        return SharedStylesHost;
	    }());
	    var DomSharedStylesHost = (function (_super) {
	        __extends$4(DomSharedStylesHost, _super);
	        function DomSharedStylesHost(doc) {
	            _super.call(this);
	            this._hostNodes = new Set();
	            this._hostNodes.add(doc.head);
	        }
	        /** @internal */
	        DomSharedStylesHost.prototype._addStylesToHost = function (styles, host) {
	            for (var i = 0; i < styles.length; i++) {
	                var style = styles[i];
	                getDOM().appendChild(host, getDOM().createStyleElement(style));
	            }
	        };
	        DomSharedStylesHost.prototype.addHost = function (hostNode) {
	            this._addStylesToHost(this._styles, hostNode);
	            this._hostNodes.add(hostNode);
	        };
	        DomSharedStylesHost.prototype.removeHost = function (hostNode) { this._hostNodes.delete(hostNode); };
	        DomSharedStylesHost.prototype.onStylesAdded = function (additions) {
	            var _this = this;
	            this._hostNodes.forEach(function (hostNode) { _this._addStylesToHost(additions, hostNode); });
	        };
	        DomSharedStylesHost.decorators = [
	            { type: _angular_core.Injectable },
	        ];
	        /** @nocollapse */
	        DomSharedStylesHost.ctorParameters = [
	            { type: undefined, decorators: [{ type: _angular_core.Inject, args: [DOCUMENT,] },] },
	        ];
	        return DomSharedStylesHost;
	    }(SharedStylesHost));

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$3 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    var NAMESPACE_URIS = {
	        'xlink': 'http://www.w3.org/1999/xlink',
	        'svg': 'http://www.w3.org/2000/svg',
	        'xhtml': 'http://www.w3.org/1999/xhtml'
	    };
	    var TEMPLATE_COMMENT_TEXT = 'template bindings={}';
	    var TEMPLATE_BINDINGS_EXP = /^template bindings=(.*)$/;
	    var DomRootRenderer = (function () {
	        function DomRootRenderer(document, eventManager, sharedStylesHost, animationDriver) {
	            this.document = document;
	            this.eventManager = eventManager;
	            this.sharedStylesHost = sharedStylesHost;
	            this.animationDriver = animationDriver;
	            this.registeredComponents = new Map();
	        }
	        DomRootRenderer.prototype.renderComponent = function (componentProto) {
	            var renderer = this.registeredComponents.get(componentProto.id);
	            if (!renderer) {
	                renderer = new DomRenderer(this, componentProto, this.animationDriver);
	                this.registeredComponents.set(componentProto.id, renderer);
	            }
	            return renderer;
	        };
	        return DomRootRenderer;
	    }());
	    var DomRootRenderer_ = (function (_super) {
	        __extends$3(DomRootRenderer_, _super);
	        function DomRootRenderer_(_document, _eventManager, sharedStylesHost, animationDriver) {
	            _super.call(this, _document, _eventManager, sharedStylesHost, animationDriver);
	        }
	        DomRootRenderer_.decorators = [
	            { type: _angular_core.Injectable },
	        ];
	        /** @nocollapse */
	        DomRootRenderer_.ctorParameters = [
	            { type: undefined, decorators: [{ type: _angular_core.Inject, args: [DOCUMENT,] },] },
	            { type: EventManager, },
	            { type: DomSharedStylesHost, },
	            { type: AnimationDriver, },
	        ];
	        return DomRootRenderer_;
	    }(DomRootRenderer));
	    var DomRenderer = (function () {
	        function DomRenderer(_rootRenderer, componentProto, _animationDriver) {
	            this._rootRenderer = _rootRenderer;
	            this.componentProto = componentProto;
	            this._animationDriver = _animationDriver;
	            this._styles = _flattenStyles(componentProto.id, componentProto.styles, []);
	            if (componentProto.encapsulation !== _angular_core.ViewEncapsulation.Native) {
	                this._rootRenderer.sharedStylesHost.addStyles(this._styles);
	            }
	            if (this.componentProto.encapsulation === _angular_core.ViewEncapsulation.Emulated) {
	                this._contentAttr = _shimContentAttribute(componentProto.id);
	                this._hostAttr = _shimHostAttribute(componentProto.id);
	            }
	            else {
	                this._contentAttr = null;
	                this._hostAttr = null;
	            }
	        }
	        DomRenderer.prototype.selectRootElement = function (selectorOrNode, debugInfo) {
	            var el;
	            if (typeof selectorOrNode === 'string') {
	                el = getDOM().querySelector(this._rootRenderer.document, selectorOrNode);
	                if (isBlank(el)) {
	                    throw new Error("The selector \"" + selectorOrNode + "\" did not match any elements");
	                }
	            }
	            else {
	                el = selectorOrNode;
	            }
	            getDOM().clearNodes(el);
	            return el;
	        };
	        DomRenderer.prototype.createElement = function (parent, name, debugInfo) {
	            var nsAndName = splitNamespace(name);
	            var el = isPresent(nsAndName[0]) ?
	                getDOM().createElementNS(NAMESPACE_URIS[nsAndName[0]], nsAndName[1]) :
	                getDOM().createElement(nsAndName[1]);
	            if (isPresent(this._contentAttr)) {
	                getDOM().setAttribute(el, this._contentAttr, '');
	            }
	            if (isPresent(parent)) {
	                getDOM().appendChild(parent, el);
	            }
	            return el;
	        };
	        DomRenderer.prototype.createViewRoot = function (hostElement) {
	            var nodesParent;
	            if (this.componentProto.encapsulation === _angular_core.ViewEncapsulation.Native) {
	                nodesParent = getDOM().createShadowRoot(hostElement);
	                this._rootRenderer.sharedStylesHost.addHost(nodesParent);
	                for (var i = 0; i < this._styles.length; i++) {
	                    getDOM().appendChild(nodesParent, getDOM().createStyleElement(this._styles[i]));
	                }
	            }
	            else {
	                if (isPresent(this._hostAttr)) {
	                    getDOM().setAttribute(hostElement, this._hostAttr, '');
	                }
	                nodesParent = hostElement;
	            }
	            return nodesParent;
	        };
	        DomRenderer.prototype.createTemplateAnchor = function (parentElement, debugInfo) {
	            var comment = getDOM().createComment(TEMPLATE_COMMENT_TEXT);
	            if (isPresent(parentElement)) {
	                getDOM().appendChild(parentElement, comment);
	            }
	            return comment;
	        };
	        DomRenderer.prototype.createText = function (parentElement, value, debugInfo) {
	            var node = getDOM().createTextNode(value);
	            if (isPresent(parentElement)) {
	                getDOM().appendChild(parentElement, node);
	            }
	            return node;
	        };
	        DomRenderer.prototype.projectNodes = function (parentElement, nodes) {
	            if (isBlank(parentElement))
	                return;
	            appendNodes(parentElement, nodes);
	        };
	        DomRenderer.prototype.attachViewAfter = function (node, viewRootNodes) { moveNodesAfterSibling(node, viewRootNodes); };
	        DomRenderer.prototype.detachView = function (viewRootNodes) {
	            for (var i = 0; i < viewRootNodes.length; i++) {
	                getDOM().remove(viewRootNodes[i]);
	            }
	        };
	        DomRenderer.prototype.destroyView = function (hostElement, viewAllNodes) {
	            if (this.componentProto.encapsulation === _angular_core.ViewEncapsulation.Native && isPresent(hostElement)) {
	                this._rootRenderer.sharedStylesHost.removeHost(getDOM().getShadowRoot(hostElement));
	            }
	        };
	        DomRenderer.prototype.listen = function (renderElement, name, callback) {
	            return this._rootRenderer.eventManager.addEventListener(renderElement, name, decoratePreventDefault(callback));
	        };
	        DomRenderer.prototype.listenGlobal = function (target, name, callback) {
	            return this._rootRenderer.eventManager.addGlobalEventListener(target, name, decoratePreventDefault(callback));
	        };
	        DomRenderer.prototype.setElementProperty = function (renderElement, propertyName, propertyValue) {
	            getDOM().setProperty(renderElement, propertyName, propertyValue);
	        };
	        DomRenderer.prototype.setElementAttribute = function (renderElement, attributeName, attributeValue) {
	            var attrNs;
	            var nsAndName = splitNamespace(attributeName);
	            if (isPresent(nsAndName[0])) {
	                attributeName = nsAndName[0] + ':' + nsAndName[1];
	                attrNs = NAMESPACE_URIS[nsAndName[0]];
	            }
	            if (isPresent(attributeValue)) {
	                if (isPresent(attrNs)) {
	                    getDOM().setAttributeNS(renderElement, attrNs, attributeName, attributeValue);
	                }
	                else {
	                    getDOM().setAttribute(renderElement, attributeName, attributeValue);
	                }
	            }
	            else {
	                if (isPresent(attrNs)) {
	                    getDOM().removeAttributeNS(renderElement, attrNs, nsAndName[1]);
	                }
	                else {
	                    getDOM().removeAttribute(renderElement, attributeName);
	                }
	            }
	        };
	        DomRenderer.prototype.setBindingDebugInfo = function (renderElement, propertyName, propertyValue) {
	            var dashCasedPropertyName = camelCaseToDashCase(propertyName);
	            if (getDOM().isCommentNode(renderElement)) {
	                var existingBindings = getDOM().getText(renderElement).replace(/\n/g, '').match(TEMPLATE_BINDINGS_EXP);
	                var parsedBindings = JSON.parse(existingBindings[1]);
	                parsedBindings[dashCasedPropertyName] = propertyValue;
	                getDOM().setText(renderElement, TEMPLATE_COMMENT_TEXT.replace('{}', JSON.stringify(parsedBindings, null, 2)));
	            }
	            else {
	                this.setElementAttribute(renderElement, propertyName, propertyValue);
	            }
	        };
	        DomRenderer.prototype.setElementClass = function (renderElement, className, isAdd) {
	            if (isAdd) {
	                getDOM().addClass(renderElement, className);
	            }
	            else {
	                getDOM().removeClass(renderElement, className);
	            }
	        };
	        DomRenderer.prototype.setElementStyle = function (renderElement, styleName, styleValue) {
	            if (isPresent(styleValue)) {
	                getDOM().setStyle(renderElement, styleName, stringify(styleValue));
	            }
	            else {
	                getDOM().removeStyle(renderElement, styleName);
	            }
	        };
	        DomRenderer.prototype.invokeElementMethod = function (renderElement, methodName, args) {
	            getDOM().invoke(renderElement, methodName, args);
	        };
	        DomRenderer.prototype.setText = function (renderNode, text) { getDOM().setText(renderNode, text); };
	        DomRenderer.prototype.animate = function (element, startingStyles, keyframes, duration, delay, easing) {
	            return this._animationDriver.animate(element, startingStyles, keyframes, duration, delay, easing);
	        };
	        return DomRenderer;
	    }());
	    function moveNodesAfterSibling(sibling /** TODO #9100 */, nodes /** TODO #9100 */) {
	        var parent = getDOM().parentElement(sibling);
	        if (nodes.length > 0 && isPresent(parent)) {
	            var nextSibling = getDOM().nextSibling(sibling);
	            if (isPresent(nextSibling)) {
	                for (var i = 0; i < nodes.length; i++) {
	                    getDOM().insertBefore(nextSibling, nodes[i]);
	                }
	            }
	            else {
	                for (var i = 0; i < nodes.length; i++) {
	                    getDOM().appendChild(parent, nodes[i]);
	                }
	            }
	        }
	    }
	    function appendNodes(parent /** TODO #9100 */, nodes /** TODO #9100 */) {
	        for (var i = 0; i < nodes.length; i++) {
	            getDOM().appendChild(parent, nodes[i]);
	        }
	    }
	    function decoratePreventDefault(eventHandler) {
	        return function (event /** TODO #9100 */) {
	            var allowDefaultBehavior = eventHandler(event);
	            if (allowDefaultBehavior === false) {
	                // TODO(tbosch): move preventDefault into event plugins...
	                getDOM().preventDefault(event);
	            }
	        };
	    }
	    var COMPONENT_REGEX = /%COMP%/g;
	    var COMPONENT_VARIABLE = '%COMP%';
	    var HOST_ATTR = "_nghost-" + COMPONENT_VARIABLE;
	    var CONTENT_ATTR = "_ngcontent-" + COMPONENT_VARIABLE;
	    function _shimContentAttribute(componentShortId) {
	        return CONTENT_ATTR.replace(COMPONENT_REGEX, componentShortId);
	    }
	    function _shimHostAttribute(componentShortId) {
	        return HOST_ATTR.replace(COMPONENT_REGEX, componentShortId);
	    }
	    function _flattenStyles(compId, styles, target) {
	        for (var i = 0; i < styles.length; i++) {
	            var style = styles[i];
	            if (Array.isArray(style)) {
	                _flattenStyles(compId, style, target);
	            }
	            else {
	                style = style.replace(COMPONENT_REGEX, compId);
	                target.push(style);
	            }
	        }
	        return target;
	    }
	    var NS_PREFIX_RE = /^:([^:]+):(.+)$/;
	    function splitNamespace(name) {
	        if (name[0] != ':') {
	            return [null, name];
	        }
	        var match = name.match(NS_PREFIX_RE);
	        return [match[1], match[2]];
	    }

	    var CORE_TOKENS = {
	        'ApplicationRef': _angular_core.ApplicationRef,
	        'NgZone': _angular_core.NgZone
	    };
	    var INSPECT_GLOBAL_NAME = 'ng.probe';
	    var CORE_TOKENS_GLOBAL_NAME = 'ng.coreTokens';
	    /**
	     * Returns a {@link DebugElement} for the given native DOM element, or
	     * null if the given native element does not have an Angular view associated
	     * with it.
	     */
	    function inspectNativeElement(element /** TODO #9100 */) {
	        return _angular_core.getDebugNode(element);
	    }
	    /**
	     * @experimental
	     */
	    var NgProbeToken = (function () {
	        function NgProbeToken(name, token) {
	            this.name = name;
	            this.token = token;
	        }
	        return NgProbeToken;
	    }());
	    function _createConditionalRootRenderer(rootRenderer /** TODO #9100 */, extraTokens) {
	        if (_angular_core.isDevMode()) {
	            return _createRootRenderer(rootRenderer, extraTokens);
	        }
	        return rootRenderer;
	    }
	    function _createRootRenderer(rootRenderer /** TODO #9100 */, extraTokens) {
	        getDOM().setGlobalVar(INSPECT_GLOBAL_NAME, inspectNativeElement);
	        getDOM().setGlobalVar(CORE_TOKENS_GLOBAL_NAME, StringMapWrapper.merge(CORE_TOKENS, _ngProbeTokensToMap(extraTokens || [])));
	        return new DebugDomRootRenderer(rootRenderer);
	    }
	    function _ngProbeTokensToMap(tokens) {
	        return tokens.reduce(function (prev, t) { return (prev[t.name] = t.token, prev); }, {});
	    }
	    /**
	     * Providers which support debugging Angular applications (e.g. via `ng.probe`).
	     */
	    var ELEMENT_PROBE_PROVIDERS = [{
	            provide: _angular_core.RootRenderer,
	            useFactory: _createConditionalRootRenderer,
	            deps: [DomRootRenderer, [NgProbeToken, new _angular_core.Optional()]]
	        }];
	    var ELEMENT_PROBE_PROVIDERS_PROD_MODE = [{
	            provide: _angular_core.RootRenderer,
	            useFactory: _createRootRenderer,
	            deps: [DomRootRenderer, [NgProbeToken, new _angular_core.Optional()]]
	        }];

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$5 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    var DomEventsPlugin = (function (_super) {
	        __extends$5(DomEventsPlugin, _super);
	        function DomEventsPlugin() {
	            _super.apply(this, arguments);
	        }
	        // This plugin should come last in the list of plugins, because it accepts all
	        // events.
	        DomEventsPlugin.prototype.supports = function (eventName) { return true; };
	        DomEventsPlugin.prototype.addEventListener = function (element, eventName, handler) {
	            var zone = this.manager.getZone();
	            var outsideHandler = function (event /** TODO #9100 */) { return zone.runGuarded(function () { return handler(event); }); };
	            return this.manager.getZone().runOutsideAngular(function () { return getDOM().onAndCancel(element, eventName, outsideHandler); });
	        };
	        DomEventsPlugin.prototype.addGlobalEventListener = function (target, eventName, handler) {
	            var element = getDOM().getGlobalEventTarget(target);
	            var zone = this.manager.getZone();
	            var outsideHandler = function (event /** TODO #9100 */) { return zone.runGuarded(function () { return handler(event); }); };
	            return this.manager.getZone().runOutsideAngular(function () { return getDOM().onAndCancel(element, eventName, outsideHandler); });
	        };
	        DomEventsPlugin.decorators = [
	            { type: _angular_core.Injectable },
	        ];
	        /** @nocollapse */
	        DomEventsPlugin.ctorParameters = [];
	        return DomEventsPlugin;
	    }(EventManagerPlugin));

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$7 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    var _eventNames = {
	        // pan
	        'pan': true,
	        'panstart': true,
	        'panmove': true,
	        'panend': true,
	        'pancancel': true,
	        'panleft': true,
	        'panright': true,
	        'panup': true,
	        'pandown': true,
	        // pinch
	        'pinch': true,
	        'pinchstart': true,
	        'pinchmove': true,
	        'pinchend': true,
	        'pinchcancel': true,
	        'pinchin': true,
	        'pinchout': true,
	        // press
	        'press': true,
	        'pressup': true,
	        // rotate
	        'rotate': true,
	        'rotatestart': true,
	        'rotatemove': true,
	        'rotateend': true,
	        'rotatecancel': true,
	        // swipe
	        'swipe': true,
	        'swipeleft': true,
	        'swiperight': true,
	        'swipeup': true,
	        'swipedown': true,
	        // tap
	        'tap': true,
	    };
	    var HammerGesturesPluginCommon = (function (_super) {
	        __extends$7(HammerGesturesPluginCommon, _super);
	        function HammerGesturesPluginCommon() {
	            _super.call(this);
	        }
	        HammerGesturesPluginCommon.prototype.supports = function (eventName) {
	            return _eventNames.hasOwnProperty(eventName.toLowerCase());
	        };
	        return HammerGesturesPluginCommon;
	    }(EventManagerPlugin));

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$6 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    /**
	     * A DI token that you can use to provide{@link HammerGestureConfig} to Angular. Use it to configure
	     * Hammer gestures.
	     *
	     * @experimental
	     */
	    var HAMMER_GESTURE_CONFIG = new _angular_core.OpaqueToken('HammerGestureConfig');
	    /**
	     * @experimental
	     */
	    var HammerGestureConfig = (function () {
	        function HammerGestureConfig() {
	            this.events = [];
	            this.overrides = {};
	        }
	        HammerGestureConfig.prototype.buildHammer = function (element) {
	            var mc = new Hammer(element);
	            mc.get('pinch').set({ enable: true });
	            mc.get('rotate').set({ enable: true });
	            for (var eventName in this.overrides) {
	                mc.get(eventName).set(this.overrides[eventName]);
	            }
	            return mc;
	        };
	        HammerGestureConfig.decorators = [
	            { type: _angular_core.Injectable },
	        ];
	        /** @nocollapse */
	        HammerGestureConfig.ctorParameters = [];
	        return HammerGestureConfig;
	    }());
	    var HammerGesturesPlugin = (function (_super) {
	        __extends$6(HammerGesturesPlugin, _super);
	        function HammerGesturesPlugin(_config) {
	            _super.call(this);
	            this._config = _config;
	        }
	        HammerGesturesPlugin.prototype.supports = function (eventName) {
	            if (!_super.prototype.supports.call(this, eventName) && !this.isCustomEvent(eventName))
	                return false;
	            if (!isPresent(window['Hammer'])) {
	                throw new Error("Hammer.js is not loaded, can not bind " + eventName + " event");
	            }
	            return true;
	        };
	        HammerGesturesPlugin.prototype.addEventListener = function (element, eventName, handler) {
	            var _this = this;
	            var zone = this.manager.getZone();
	            eventName = eventName.toLowerCase();
	            return zone.runOutsideAngular(function () {
	                // Creating the manager bind events, must be done outside of angular
	                var mc = _this._config.buildHammer(element);
	                var callback = function (eventObj /** TODO #???? */) {
	                    zone.runGuarded(function () { handler(eventObj); });
	                };
	                mc.on(eventName, callback);
	                return function () { mc.off(eventName, callback); };
	            });
	        };
	        HammerGesturesPlugin.prototype.isCustomEvent = function (eventName) { return this._config.events.indexOf(eventName) > -1; };
	        HammerGesturesPlugin.decorators = [
	            { type: _angular_core.Injectable },
	        ];
	        /** @nocollapse */
	        HammerGesturesPlugin.ctorParameters = [
	            { type: HammerGestureConfig, decorators: [{ type: _angular_core.Inject, args: [HAMMER_GESTURE_CONFIG,] },] },
	        ];
	        return HammerGesturesPlugin;
	    }(HammerGesturesPluginCommon));

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$8 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    var modifierKeys = ['alt', 'control', 'meta', 'shift'];
	    var modifierKeyGetters = {
	        'alt': function (event) { return event.altKey; },
	        'control': function (event) { return event.ctrlKey; },
	        'meta': function (event) { return event.metaKey; },
	        'shift': function (event) { return event.shiftKey; }
	    };
	    /**
	     * @experimental
	     */
	    var KeyEventsPlugin = (function (_super) {
	        __extends$8(KeyEventsPlugin, _super);
	        function KeyEventsPlugin() {
	            _super.call(this);
	        }
	        KeyEventsPlugin.prototype.supports = function (eventName) {
	            return isPresent(KeyEventsPlugin.parseEventName(eventName));
	        };
	        KeyEventsPlugin.prototype.addEventListener = function (element, eventName, handler) {
	            var parsedEvent = KeyEventsPlugin.parseEventName(eventName);
	            var outsideHandler = KeyEventsPlugin.eventCallback(element, parsedEvent['fullKey'], handler, this.manager.getZone());
	            return this.manager.getZone().runOutsideAngular(function () {
	                return getDOM().onAndCancel(element, parsedEvent['domEventName'], outsideHandler);
	            });
	        };
	        KeyEventsPlugin.parseEventName = function (eventName) {
	            var parts = eventName.toLowerCase().split('.');
	            var domEventName = parts.shift();
	            if ((parts.length === 0) || !(domEventName === 'keydown' || domEventName === 'keyup')) {
	                return null;
	            }
	            var key = KeyEventsPlugin._normalizeKey(parts.pop());
	            var fullKey = '';
	            modifierKeys.forEach(function (modifierName) {
	                if (parts.indexOf(modifierName) > -1) {
	                    ListWrapper.remove(parts, modifierName);
	                    fullKey += modifierName + '.';
	                }
	            });
	            fullKey += key;
	            if (parts.length != 0 || key.length === 0) {
	                // returning null instead of throwing to let another plugin process the event
	                return null;
	            }
	            var result = {};
	            result['domEventName'] = domEventName;
	            result['fullKey'] = fullKey;
	            return result;
	        };
	        KeyEventsPlugin.getEventFullKey = function (event) {
	            var fullKey = '';
	            var key = getDOM().getEventKey(event);
	            key = key.toLowerCase();
	            if (key === ' ') {
	                key = 'space'; // for readability
	            }
	            else if (key === '.') {
	                key = 'dot'; // because '.' is used as a separator in event names
	            }
	            modifierKeys.forEach(function (modifierName) {
	                if (modifierName != key) {
	                    var modifierGetter = modifierKeyGetters[modifierName];
	                    if (modifierGetter(event)) {
	                        fullKey += modifierName + '.';
	                    }
	                }
	            });
	            fullKey += key;
	            return fullKey;
	        };
	        KeyEventsPlugin.eventCallback = function (element, fullKey, handler, zone) {
	            return function (event /** TODO #9100 */) {
	                if (KeyEventsPlugin.getEventFullKey(event) === fullKey) {
	                    zone.runGuarded(function () { return handler(event); });
	                }
	            };
	        };
	        /** @internal */
	        KeyEventsPlugin._normalizeKey = function (keyName) {
	            // TODO: switch to a StringMap if the mapping grows too much
	            switch (keyName) {
	                case 'esc':
	                    return 'escape';
	                default:
	                    return keyName;
	            }
	        };
	        KeyEventsPlugin.decorators = [
	            { type: _angular_core.Injectable },
	        ];
	        /** @nocollapse */
	        KeyEventsPlugin.ctorParameters = [];
	        return KeyEventsPlugin;
	    }(EventManagerPlugin));

	    /**
	     * A pattern that recognizes a commonly useful subset of URLs that are safe.
	     *
	     * This regular expression matches a subset of URLs that will not cause script
	     * execution if used in URL context within a HTML document. Specifically, this
	     * regular expression matches if (comment from here on and regex copied from
	     * Soy's EscapingConventions):
	     * (1) Either a protocol in a whitelist (http, https, mailto or ftp).
	     * (2) or no protocol.  A protocol must be followed by a colon. The below
	     *     allows that by allowing colons only after one of the characters [/?#].
	     *     A colon after a hash (#) must be in the fragment.
	     *     Otherwise, a colon after a (?) must be in a query.
	     *     Otherwise, a colon after a single solidus (/) must be in a path.
	     *     Otherwise, a colon after a double solidus (//) must be in the authority
	     *     (before port).
	     *
	     * The pattern disallows &, used in HTML entity declarations before
	     * one of the characters in [/?#]. This disallows HTML entities used in the
	     * protocol name, which should never happen, e.g. "h&#116;tp" for "http".
	     * It also disallows HTML entities in the first path part of a relative path,
	     * e.g. "foo&lt;bar/baz".  Our existing escaping functions should not produce
	     * that. More importantly, it disallows masking of a colon,
	     * e.g. "javascript&#58;...".
	     *
	     * This regular expression was taken from the Closure sanitization library.
	     */
	    var SAFE_URL_PATTERN = /^(?:(?:https?|mailto|ftp|tel|file):|[^&:/?#]*(?:[/?#]|$))/gi;
	    /** A pattern that matches safe data URLs. Only matches image, video and audio types. */
	    var DATA_URL_PATTERN = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[a-z0-9+\/]+=*$/i;
	    function sanitizeUrl(url) {
	        url = String(url);
	        if (url.match(SAFE_URL_PATTERN) || url.match(DATA_URL_PATTERN))
	            return url;
	        if (_angular_core.isDevMode()) {
	            getDOM().log("WARNING: sanitizing unsafe URL value " + url + " (see http://g.co/ng/security#xss)");
	        }
	        return 'unsafe:' + url;
	    }
	    function sanitizeSrcset(srcset) {
	        srcset = String(srcset);
	        return srcset.split(',').map(function (srcset) { return sanitizeUrl(srcset.trim()); }).join(', ');
	    }

	    /** A <body> element that can be safely used to parse untrusted HTML. Lazily initialized below. */
	    var inertElement = null;
	    /** Lazily initialized to make sure the DOM adapter gets set before use. */
	    var DOM = null;
	    /** Returns an HTML element that is guaranteed to not execute code when creating elements in it. */
	    function getInertElement() {
	        if (inertElement)
	            return inertElement;
	        DOM = getDOM();
	        // Prefer using <template> element if supported.
	        var templateEl = DOM.createElement('template');
	        if ('content' in templateEl)
	            return templateEl;
	        var doc = DOM.createHtmlDocument();
	        inertElement = DOM.querySelector(doc, 'body');
	        if (inertElement == null) {
	            // usually there should be only one body element in the document, but IE doesn't have any, so we
	            // need to create one.
	            var html = DOM.createElement('html', doc);
	            inertElement = DOM.createElement('body', doc);
	            DOM.appendChild(html, inertElement);
	            DOM.appendChild(doc, html);
	        }
	        return inertElement;
	    }
	    function tagSet(tags) {
	        var res = {};
	        for (var _i = 0, _a = tags.split(','); _i < _a.length; _i++) {
	            var t = _a[_i];
	            res[t] = true;
	        }
	        return res;
	    }
	    function merge() {
	        var sets = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            sets[_i - 0] = arguments[_i];
	        }
	        var res = {};
	        for (var _a = 0, sets_1 = sets; _a < sets_1.length; _a++) {
	            var s = sets_1[_a];
	            for (var v in s) {
	                if (s.hasOwnProperty(v))
	                    res[v] = true;
	            }
	        }
	        return res;
	    }
	    // Good source of info about elements and attributes
	    // http://dev.w3.org/html5/spec/Overview.html#semantics
	    // http://simon.html5.org/html-elements
	    // Safe Void Elements - HTML5
	    // http://dev.w3.org/html5/spec/Overview.html#void-elements
	    var VOID_ELEMENTS = tagSet('area,br,col,hr,img,wbr');
	    // Elements that you can, intentionally, leave open (and which close themselves)
	    // http://dev.w3.org/html5/spec/Overview.html#optional-tags
	    var OPTIONAL_END_TAG_BLOCK_ELEMENTS = tagSet('colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr');
	    var OPTIONAL_END_TAG_INLINE_ELEMENTS = tagSet('rp,rt');
	    var OPTIONAL_END_TAG_ELEMENTS = merge(OPTIONAL_END_TAG_INLINE_ELEMENTS, OPTIONAL_END_TAG_BLOCK_ELEMENTS);
	    // Safe Block Elements - HTML5
	    var BLOCK_ELEMENTS = merge(OPTIONAL_END_TAG_BLOCK_ELEMENTS, tagSet('address,article,' +
	        'aside,blockquote,caption,center,del,details,dialog,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,' +
	        'h6,header,hgroup,hr,ins,main,map,menu,nav,ol,pre,section,summary,table,ul'));
	    // Inline Elements - HTML5
	    var INLINE_ELEMENTS = merge(OPTIONAL_END_TAG_INLINE_ELEMENTS, tagSet('a,abbr,acronym,audio,b,' +
	        'bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,picture,q,ruby,rp,rt,s,' +
	        'samp,small,source,span,strike,strong,sub,sup,time,track,tt,u,var,video'));
	    var VALID_ELEMENTS = merge(VOID_ELEMENTS, BLOCK_ELEMENTS, INLINE_ELEMENTS, OPTIONAL_END_TAG_ELEMENTS);
	    // Attributes that have href and hence need to be sanitized
	    var URI_ATTRS = tagSet('background,cite,href,itemtype,longdesc,poster,src,xlink:href');
	    // Attributes that have special href set hence need to be sanitized
	    var SRCSET_ATTRS = tagSet('srcset');
	    var HTML_ATTRS = tagSet('abbr,accesskey,align,alt,autoplay,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,' +
	        'compact,controls,coords,datetime,default,dir,download,face,headers,height,hidden,hreflang,hspace,' +
	        'ismap,itemscope,itemprop,kind,label,lang,language,loop,media,muted,nohref,nowrap,open,preload,rel,rev,role,rows,rowspan,rules,' +
	        'scope,scrolling,shape,size,sizes,span,srclang,start,summary,tabindex,target,title,translate,type,usemap,' +
	        'valign,value,vspace,width');
	    // NB: This currently conciously doesn't support SVG. SVG sanitization has had several security
	    // issues in the past, so it seems safer to leave it out if possible. If support for binding SVG via
	    // innerHTML is required, SVG attributes should be added here.
	    // NB: Sanitization does not allow <form> elements or other active elements (<button> etc). Those
	    // can be sanitized, but they increase security surface area without a legitimate use case, so they
	    // are left out here.
	    var VALID_ATTRS = merge(URI_ATTRS, SRCSET_ATTRS, HTML_ATTRS);
	    /**
	     * SanitizingHtmlSerializer serializes a DOM fragment, stripping out any unsafe elements and unsafe
	     * attributes.
	     */
	    var SanitizingHtmlSerializer = (function () {
	        function SanitizingHtmlSerializer() {
	            // Explicitly track if something was stripped, to avoid accidentally warning of sanitization just
	            // because characters were re-encoded.
	            this.sanitizedSomething = false;
	            this.buf = [];
	        }
	        SanitizingHtmlSerializer.prototype.sanitizeChildren = function (el) {
	            // This cannot use a TreeWalker, as it has to run on Angular's various DOM adapters.
	            // However this code never accesses properties off of `document` before deleting its contents
	            // again, so it shouldn't be vulnerable to DOM clobbering.
	            var current = el.firstChild;
	            while (current) {
	                if (DOM.isElementNode(current)) {
	                    this.startElement(current);
	                }
	                else if (DOM.isTextNode(current)) {
	                    this.chars(DOM.nodeValue(current));
	                }
	                else {
	                    // Strip non-element, non-text nodes.
	                    this.sanitizedSomething = true;
	                }
	                if (DOM.firstChild(current)) {
	                    current = DOM.firstChild(current);
	                    continue;
	                }
	                while (current) {
	                    // Leaving the element. Walk up and to the right, closing tags as we go.
	                    if (DOM.isElementNode(current)) {
	                        this.endElement(current);
	                    }
	                    if (DOM.nextSibling(current)) {
	                        current = DOM.nextSibling(current);
	                        break;
	                    }
	                    current = DOM.parentElement(current);
	                }
	            }
	            return this.buf.join('');
	        };
	        SanitizingHtmlSerializer.prototype.startElement = function (element) {
	            var _this = this;
	            var tagName = DOM.nodeName(element).toLowerCase();
	            if (!VALID_ELEMENTS.hasOwnProperty(tagName)) {
	                this.sanitizedSomething = true;
	                return;
	            }
	            this.buf.push('<');
	            this.buf.push(tagName);
	            DOM.attributeMap(element).forEach(function (value, attrName) {
	                var lower = attrName.toLowerCase();
	                if (!VALID_ATTRS.hasOwnProperty(lower)) {
	                    _this.sanitizedSomething = true;
	                    return;
	                }
	                // TODO(martinprobst): Special case image URIs for data:image/...
	                if (URI_ATTRS[lower])
	                    value = sanitizeUrl(value);
	                if (SRCSET_ATTRS[lower])
	                    value = sanitizeSrcset(value);
	                _this.buf.push(' ');
	                _this.buf.push(attrName);
	                _this.buf.push('="');
	                _this.buf.push(encodeEntities(value));
	                _this.buf.push('"');
	            });
	            this.buf.push('>');
	        };
	        SanitizingHtmlSerializer.prototype.endElement = function (current) {
	            var tagName = DOM.nodeName(current).toLowerCase();
	            if (VALID_ELEMENTS.hasOwnProperty(tagName) && !VOID_ELEMENTS.hasOwnProperty(tagName)) {
	                this.buf.push('</');
	                this.buf.push(tagName);
	                this.buf.push('>');
	            }
	        };
	        SanitizingHtmlSerializer.prototype.chars = function (chars /** TODO #9100 */) { this.buf.push(encodeEntities(chars)); };
	        return SanitizingHtmlSerializer;
	    }());
	    // Regular Expressions for parsing tags and attributes
	    var SURROGATE_PAIR_REGEXP = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
	    // ! to ~ is the ASCII range.
	    var NON_ALPHANUMERIC_REGEXP = /([^\#-~ |!])/g;
	    /**
	     * Escapes all potentially dangerous characters, so that the
	     * resulting string can be safely inserted into attribute or
	     * element text.
	     * @param value
	     * @returns {string} escaped text
	     */
	    function encodeEntities(value) {
	        return value.replace(/&/g, '&amp;')
	            .replace(SURROGATE_PAIR_REGEXP, function (match) {
	            var hi = match.charCodeAt(0);
	            var low = match.charCodeAt(1);
	            return '&#' + (((hi - 0xD800) * 0x400) + (low - 0xDC00) + 0x10000) + ';';
	        })
	            .replace(NON_ALPHANUMERIC_REGEXP, function (match) { return '&#' + match.charCodeAt(0) + ';'; })
	            .replace(/</g, '&lt;')
	            .replace(/>/g, '&gt;');
	    }
	    /**
	     * When IE9-11 comes across an unknown namespaced attribute e.g. 'xlink:foo' it adds 'xmlns:ns1'
	     * attribute to declare ns1 namespace and prefixes the attribute with 'ns1' (e.g. 'ns1:xlink:foo').
	     *
	     * This is undesirable since we don't want to allow any of these custom attributes. This method
	     * strips them all.
	     */
	    function stripCustomNsAttrs(el) {
	        DOM.attributeMap(el).forEach(function (_, attrName) {
	            if (attrName === 'xmlns:ns1' || attrName.indexOf('ns1:') === 0) {
	                DOM.removeAttribute(el, attrName);
	            }
	        });
	        for (var _i = 0, _a = DOM.childNodesAsList(el); _i < _a.length; _i++) {
	            var n = _a[_i];
	            if (DOM.isElementNode(n))
	                stripCustomNsAttrs(n);
	        }
	    }
	    /**
	     * Sanitizes the given unsafe, untrusted HTML fragment, and returns HTML text that is safe to add to
	     * the DOM in a browser environment.
	     */
	    function sanitizeHtml(unsafeHtmlInput) {
	        try {
	            var containerEl = getInertElement();
	            // Make sure unsafeHtml is actually a string (TypeScript types are not enforced at runtime).
	            var unsafeHtml = unsafeHtmlInput ? String(unsafeHtmlInput) : '';
	            // mXSS protection. Repeatedly parse the document to make sure it stabilizes, so that a browser
	            // trying to auto-correct incorrect HTML cannot cause formerly inert HTML to become dangerous.
	            var mXSSAttempts = 5;
	            var parsedHtml = unsafeHtml;
	            do {
	                if (mXSSAttempts === 0) {
	                    throw new Error('Failed to sanitize html because the input is unstable');
	                }
	                mXSSAttempts--;
	                unsafeHtml = parsedHtml;
	                DOM.setInnerHTML(containerEl, unsafeHtml);
	                if (DOM.defaultDoc().documentMode) {
	                    // strip custom-namespaced attributes on IE<=11
	                    stripCustomNsAttrs(containerEl);
	                }
	                parsedHtml = DOM.getInnerHTML(containerEl);
	            } while (unsafeHtml !== parsedHtml);
	            var sanitizer = new SanitizingHtmlSerializer();
	            var safeHtml = sanitizer.sanitizeChildren(DOM.getTemplateContent(containerEl) || containerEl);
	            // Clear out the body element.
	            var parent_1 = DOM.getTemplateContent(containerEl) || containerEl;
	            for (var _i = 0, _a = DOM.childNodesAsList(parent_1); _i < _a.length; _i++) {
	                var child = _a[_i];
	                DOM.removeChild(parent_1, child);
	            }
	            if (_angular_core.isDevMode() && sanitizer.sanitizedSomething) {
	                DOM.log('WARNING: sanitizing HTML stripped some content (see http://g.co/ng/security#xss).');
	            }
	            return safeHtml;
	        }
	        catch (e) {
	            // In case anything goes wrong, clear out inertElement to reset the entire DOM structure.
	            inertElement = null;
	            throw e;
	        }
	    }

	    /**
	     * Regular expression for safe style values.
	     *
	     * Quotes (" and ') are allowed, but a check must be done elsewhere to ensure they're balanced.
	     *
	     * ',' allows multiple values to be assigned to the same property (e.g. background-attachment or
	     * font-family) and hence could allow multiple values to get injected, but that should pose no risk
	     * of XSS.
	     *
	     * The function expression checks only for XSS safety, not for CSS validity.
	     *
	     * This regular expression was taken from the Closure sanitization library, and augmented for
	     * transformation values.
	     */
	    var VALUES = '[-,."\'%_!# a-zA-Z0-9]+';
	    var TRANSFORMATION_FNS = '(?:matrix|translate|scale|rotate|skew|perspective)(?:X|Y|3d)?';
	    var COLOR_FNS = '(?:rgb|hsl)a?';
	    var FN_ARGS = '\\([-0-9.%, a-zA-Z]+\\)';
	    var SAFE_STYLE_VALUE = new RegExp("^(" + VALUES + "|(?:" + TRANSFORMATION_FNS + "|" + COLOR_FNS + ")" + FN_ARGS + ")$", 'g');
	    /**
	     * Matches a `url(...)` value with an arbitrary argument as long as it does
	     * not contain parentheses.
	     *
	     * The URL value still needs to be sanitized separately.
	     *
	     * `url(...)` values are a very common use case, e.g. for `background-image`. With carefully crafted
	     * CSS style rules, it is possible to construct an information leak with `url` values in CSS, e.g.
	     * by observing whether scroll bars are displayed, or character ranges used by a font face
	     * definition.
	     *
	     * Angular only allows binding CSS values (as opposed to entire CSS rules), so it is unlikely that
	     * binding a URL value without further cooperation from the page will cause an information leak, and
	     * if so, it is just a leak, not a full blown XSS vulnerability.
	     *
	     * Given the common use case, low likelihood of attack vector, and low impact of an attack, this
	     * code is permissive and allows URLs that sanitize otherwise.
	     */
	    var URL_RE = /^url\(([^)]+)\)$/;
	    /**
	     * Checks that quotes (" and ') are properly balanced inside a string. Assumes
	     * that neither escape (\) nor any other character that could result in
	     * breaking out of a string parsing context are allowed;
	     * see http://www.w3.org/TR/css3-syntax/#string-token-diagram.
	     *
	     * This code was taken from the Closure sanitization library.
	     */
	    function hasBalancedQuotes(value) {
	        var outsideSingle = true;
	        var outsideDouble = true;
	        for (var i = 0; i < value.length; i++) {
	            var c = value.charAt(i);
	            if (c === '\'' && outsideDouble) {
	                outsideSingle = !outsideSingle;
	            }
	            else if (c === '"' && outsideSingle) {
	                outsideDouble = !outsideDouble;
	            }
	        }
	        return outsideSingle && outsideDouble;
	    }
	    /**
	     * Sanitizes the given untrusted CSS style property value (i.e. not an entire object, just a single
	     * value) and returns a value that is safe to use in a browser environment.
	     */
	    function sanitizeStyle(value) {
	        value = String(value).trim(); // Make sure it's actually a string.
	        if (!value)
	            return '';
	        // Single url(...) values are supported, but only for URLs that sanitize cleanly. See above for
	        // reasoning behind this.
	        var urlMatch = value.match(URL_RE);
	        if ((urlMatch && sanitizeUrl(urlMatch[1]) === urlMatch[1]) ||
	            value.match(SAFE_STYLE_VALUE) && hasBalancedQuotes(value)) {
	            return value; // Safe style values.
	        }
	        if (_angular_core.isDevMode()) {
	            getDOM().log("WARNING: sanitizing unsafe style value " + value + " (see http://g.co/ng/security#xss).");
	        }
	        return 'unsafe';
	    }

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$9 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    /**
	     * DomSanitizer helps preventing Cross Site Scripting Security bugs (XSS) by sanitizing
	     * values to be safe to use in the different DOM contexts.
	     *
	     * For example, when binding a URL in an `<a [href]="someValue">` hyperlink, `someValue` will be
	     * sanitized so that an attacker cannot inject e.g. a `javascript:` URL that would execute code on
	     * the website.
	     *
	     * In specific situations, it might be necessary to disable sanitization, for example if the
	     * application genuinely needs to produce a `javascript:` style link with a dynamic value in it.
	     * Users can bypass security by constructing a value with one of the `bypassSecurityTrust...`
	     * methods, and then binding to that value from the template.
	     *
	     * These situations should be very rare, and extraordinary care must be taken to avoid creating a
	     * Cross Site Scripting (XSS) security bug!
	     *
	     * When using `bypassSecurityTrust...`, make sure to call the method as early as possible and as
	     * close as possible to the source of the value, to make it easy to verify no security bug is
	     * created by its use.
	     *
	     * It is not required (and not recommended) to bypass security if the value is safe, e.g. a URL that
	     * does not start with a suspicious protocol, or an HTML snippet that does not contain dangerous
	     * code. The sanitizer leaves safe values intact.
	     *
	     * @security Calling any of the `bypassSecurityTrust...` APIs disables Angular's built-in
	     * sanitization for the value passed in. Carefully check and audit all values and code paths going
	     * into this call. Make sure any user data is appropriately escaped for this security context.
	     * For more detail, see the [Security Guide](http://g.co/ng/security).
	     *
	     * @stable
	     */
	    var DomSanitizer = (function () {
	        function DomSanitizer() {
	        }
	        return DomSanitizer;
	    }());
	    var DomSanitizerImpl = (function (_super) {
	        __extends$9(DomSanitizerImpl, _super);
	        function DomSanitizerImpl() {
	            _super.apply(this, arguments);
	        }
	        DomSanitizerImpl.prototype.sanitize = function (ctx, value) {
	            if (value == null)
	                return null;
	            switch (ctx) {
	                case _angular_core.SecurityContext.NONE:
	                    return value;
	                case _angular_core.SecurityContext.HTML:
	                    if (value instanceof SafeHtmlImpl)
	                        return value.changingThisBreaksApplicationSecurity;
	                    this.checkNotSafeValue(value, 'HTML');
	                    return sanitizeHtml(String(value));
	                case _angular_core.SecurityContext.STYLE:
	                    if (value instanceof SafeStyleImpl)
	                        return value.changingThisBreaksApplicationSecurity;
	                    this.checkNotSafeValue(value, 'Style');
	                    return sanitizeStyle(value);
	                case _angular_core.SecurityContext.SCRIPT:
	                    if (value instanceof SafeScriptImpl)
	                        return value.changingThisBreaksApplicationSecurity;
	                    this.checkNotSafeValue(value, 'Script');
	                    throw new Error('unsafe value used in a script context');
	                case _angular_core.SecurityContext.URL:
	                    if (value instanceof SafeResourceUrlImpl || value instanceof SafeUrlImpl) {
	                        // Allow resource URLs in URL contexts, they are strictly more trusted.
	                        return value.changingThisBreaksApplicationSecurity;
	                    }
	                    this.checkNotSafeValue(value, 'URL');
	                    return sanitizeUrl(String(value));
	                case _angular_core.SecurityContext.RESOURCE_URL:
	                    if (value instanceof SafeResourceUrlImpl) {
	                        return value.changingThisBreaksApplicationSecurity;
	                    }
	                    this.checkNotSafeValue(value, 'ResourceURL');
	                    throw new Error('unsafe value used in a resource URL context (see http://g.co/ng/security#xss)');
	                default:
	                    throw new Error("Unexpected SecurityContext " + ctx + " (see http://g.co/ng/security#xss)");
	            }
	        };
	        DomSanitizerImpl.prototype.checkNotSafeValue = function (value, expectedType) {
	            if (value instanceof SafeValueImpl) {
	                throw new Error(("Required a safe " + expectedType + ", got a " + value.getTypeName() + " ") +
	                    "(see http://g.co/ng/security#xss)");
	            }
	        };
	        DomSanitizerImpl.prototype.bypassSecurityTrustHtml = function (value) { return new SafeHtmlImpl(value); };
	        DomSanitizerImpl.prototype.bypassSecurityTrustStyle = function (value) { return new SafeStyleImpl(value); };
	        DomSanitizerImpl.prototype.bypassSecurityTrustScript = function (value) { return new SafeScriptImpl(value); };
	        DomSanitizerImpl.prototype.bypassSecurityTrustUrl = function (value) { return new SafeUrlImpl(value); };
	        DomSanitizerImpl.prototype.bypassSecurityTrustResourceUrl = function (value) {
	            return new SafeResourceUrlImpl(value);
	        };
	        DomSanitizerImpl.decorators = [
	            { type: _angular_core.Injectable },
	        ];
	        /** @nocollapse */
	        DomSanitizerImpl.ctorParameters = [];
	        return DomSanitizerImpl;
	    }(DomSanitizer));
	    var SafeValueImpl = (function () {
	        function SafeValueImpl(changingThisBreaksApplicationSecurity) {
	            this.changingThisBreaksApplicationSecurity = changingThisBreaksApplicationSecurity;
	            // empty
	        }
	        SafeValueImpl.prototype.toString = function () {
	            return ("SafeValue must use [property]=binding: " + this.changingThisBreaksApplicationSecurity) +
	                " (see http://g.co/ng/security#xss)";
	        };
	        return SafeValueImpl;
	    }());
	    var SafeHtmlImpl = (function (_super) {
	        __extends$9(SafeHtmlImpl, _super);
	        function SafeHtmlImpl() {
	            _super.apply(this, arguments);
	        }
	        SafeHtmlImpl.prototype.getTypeName = function () { return 'HTML'; };
	        return SafeHtmlImpl;
	    }(SafeValueImpl));
	    var SafeStyleImpl = (function (_super) {
	        __extends$9(SafeStyleImpl, _super);
	        function SafeStyleImpl() {
	            _super.apply(this, arguments);
	        }
	        SafeStyleImpl.prototype.getTypeName = function () { return 'Style'; };
	        return SafeStyleImpl;
	    }(SafeValueImpl));
	    var SafeScriptImpl = (function (_super) {
	        __extends$9(SafeScriptImpl, _super);
	        function SafeScriptImpl() {
	            _super.apply(this, arguments);
	        }
	        SafeScriptImpl.prototype.getTypeName = function () { return 'Script'; };
	        return SafeScriptImpl;
	    }(SafeValueImpl));
	    var SafeUrlImpl = (function (_super) {
	        __extends$9(SafeUrlImpl, _super);
	        function SafeUrlImpl() {
	            _super.apply(this, arguments);
	        }
	        SafeUrlImpl.prototype.getTypeName = function () { return 'URL'; };
	        return SafeUrlImpl;
	    }(SafeValueImpl));
	    var SafeResourceUrlImpl = (function (_super) {
	        __extends$9(SafeResourceUrlImpl, _super);
	        function SafeResourceUrlImpl() {
	            _super.apply(this, arguments);
	        }
	        SafeResourceUrlImpl.prototype.getTypeName = function () { return 'ResourceURL'; };
	        return SafeResourceUrlImpl;
	    }(SafeValueImpl));

	    var INTERNAL_BROWSER_PLATFORM_PROVIDERS = [
	        { provide: _angular_core.PLATFORM_INITIALIZER, useValue: initDomAdapter, multi: true },
	        { provide: _angular_common.PlatformLocation, useClass: BrowserPlatformLocation }
	    ];
	    /**
	     * @security Replacing built-in sanitization providers exposes the application to XSS risks.
	     * Attacker-controlled data introduced by an unsanitized provider could expose your
	     * application to XSS risks. For more detail, see the [Security Guide](http://g.co/ng/security).
	     * @experimental
	     */
	    var BROWSER_SANITIZATION_PROVIDERS = [
	        { provide: _angular_core.Sanitizer, useExisting: DomSanitizer },
	        { provide: DomSanitizer, useClass: DomSanitizerImpl },
	    ];
	    /**
	     * @stable
	     */
	    var platformBrowser = _angular_core.createPlatformFactory(_angular_core.platformCore, 'browser', INTERNAL_BROWSER_PLATFORM_PROVIDERS);
	    function initDomAdapter() {
	        BrowserDomAdapter.makeCurrent();
	        BrowserGetTestability.init();
	    }
	    function errorHandler() {
	        return new _angular_core.ErrorHandler();
	    }
	    function _document() {
	        return getDOM().defaultDoc();
	    }
	    function _resolveDefaultAnimationDriver() {
	        if (getDOM().supportsWebAnimation()) {
	            return new WebAnimationsDriver();
	        }
	        return AnimationDriver.NOOP;
	    }
	    /**
	     * The ng module for the browser.
	     *
	     * @stable
	     */
	    var BrowserModule = (function () {
	        function BrowserModule(parentModule) {
	            if (parentModule) {
	                throw new Error("BrowserModule has already been loaded. If you need access to common directives such as NgIf and NgFor from a lazy loaded module, import CommonModule instead.");
	            }
	        }
	        BrowserModule.decorators = [
	            { type: _angular_core.NgModule, args: [{
	                        providers: [
	                            BROWSER_SANITIZATION_PROVIDERS, { provide: _angular_core.ErrorHandler, useFactory: errorHandler, deps: [] },
	                            { provide: DOCUMENT, useFactory: _document, deps: [] },
	                            { provide: EVENT_MANAGER_PLUGINS, useClass: DomEventsPlugin, multi: true },
	                            { provide: EVENT_MANAGER_PLUGINS, useClass: KeyEventsPlugin, multi: true },
	                            { provide: EVENT_MANAGER_PLUGINS, useClass: HammerGesturesPlugin, multi: true },
	                            { provide: HAMMER_GESTURE_CONFIG, useClass: HammerGestureConfig },
	                            { provide: DomRootRenderer, useClass: DomRootRenderer_ },
	                            { provide: _angular_core.RootRenderer, useExisting: DomRootRenderer },
	                            { provide: SharedStylesHost, useExisting: DomSharedStylesHost },
	                            { provide: AnimationDriver, useFactory: _resolveDefaultAnimationDriver }, DomSharedStylesHost,
	                            _angular_core.Testability, EventManager, ELEMENT_PROBE_PROVIDERS, Title
	                        ],
	                        exports: [_angular_common.CommonModule, _angular_core.ApplicationModule]
	                    },] },
	        ];
	        /** @nocollapse */
	        BrowserModule.ctorParameters = [
	            { type: BrowserModule, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.SkipSelf },] },
	        ];
	        return BrowserModule;
	    }());

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    /**
	     * JS version of browser APIs. This library can only run in the browser.
	     */
	    var win = typeof window !== 'undefined' && window || {};

	    var ChangeDetectionPerfRecord = (function () {
	        function ChangeDetectionPerfRecord(msPerTick, numTicks) {
	            this.msPerTick = msPerTick;
	            this.numTicks = numTicks;
	        }
	        return ChangeDetectionPerfRecord;
	    }());
	    /**
	     * Entry point for all Angular debug tools. This object corresponds to the `ng`
	     * global variable accessible in the dev console.
	     */
	    var AngularTools = (function () {
	        function AngularTools(ref) {
	            this.profiler = new AngularProfiler(ref);
	        }
	        return AngularTools;
	    }());
	    /**
	     * Entry point for all Angular profiling-related debug tools. This object
	     * corresponds to the `ng.profiler` in the dev console.
	     */
	    var AngularProfiler = (function () {
	        function AngularProfiler(ref) {
	            this.appRef = ref.injector.get(_angular_core.ApplicationRef);
	        }
	        /**
	         * Exercises change detection in a loop and then prints the average amount of
	         * time in milliseconds how long a single round of change detection takes for
	         * the current state of the UI. It runs a minimum of 5 rounds for a minimum
	         * of 500 milliseconds.
	         *
	         * Optionally, a user may pass a `config` parameter containing a map of
	         * options. Supported options are:
	         *
	         * `record` (boolean) - causes the profiler to record a CPU profile while
	         * it exercises the change detector. Example:
	         *
	         * ```
	         * ng.profiler.timeChangeDetection({record: true})
	         * ```
	         */
	        AngularProfiler.prototype.timeChangeDetection = function (config) {
	            var record = config && config['record'];
	            var profileName = 'Change Detection';
	            // Profiler is not available in Android browsers, nor in IE 9 without dev tools opened
	            var isProfilerAvailable = isPresent(win.console.profile);
	            if (record && isProfilerAvailable) {
	                win.console.profile(profileName);
	            }
	            var start = getDOM().performanceNow();
	            var numTicks = 0;
	            while (numTicks < 5 || (getDOM().performanceNow() - start) < 500) {
	                this.appRef.tick();
	                numTicks++;
	            }
	            var end = getDOM().performanceNow();
	            if (record && isProfilerAvailable) {
	                // need to cast to <any> because type checker thinks there's no argument
	                // while in fact there is:
	                //
	                // https://developer.mozilla.org/en-US/docs/Web/API/Console/profileEnd
	                win.console.profileEnd(profileName);
	            }
	            var msPerTick = (end - start) / numTicks;
	            win.console.log("ran " + numTicks + " change detection cycles");
	            win.console.log(msPerTick.toFixed(2) + " ms per check");
	            return new ChangeDetectionPerfRecord(msPerTick, numTicks);
	        };
	        return AngularProfiler;
	    }());

	    var context = global$1;
	    /**
	     * Enabled Angular 2 debug tools that are accessible via your browser's
	     * developer console.
	     *
	     * Usage:
	     *
	     * 1. Open developer console (e.g. in Chrome Ctrl + Shift + j)
	     * 1. Type `ng.` (usually the console will show auto-complete suggestion)
	     * 1. Try the change detection profiler `ng.profiler.timeChangeDetection()`
	     *    then hit Enter.
	     *
	     * @experimental All debugging apis are currently experimental.
	     */
	    function enableDebugTools(ref) {
	        context.ng = new AngularTools(ref);
	        return ref;
	    }
	    /**
	     * Disables Angular 2 tools.
	     *
	     * @experimental All debugging apis are currently experimental.
	     */
	    function disableDebugTools() {
	        delete context.ng;
	    }

	    /**
	     * Predicates for use with {@link DebugElement}'s query functions.
	     *
	     * @experimental All debugging apis are currently experimental.
	     */
	    var By = (function () {
	        function By() {
	        }
	        /**
	         * Match all elements.
	         *
	         * ## Example
	         *
	         * {@example platform-browser/dom/debug/ts/by/by.ts region='by_all'}
	         */
	        By.all = function () { return function (debugElement) { return true; }; };
	        /**
	         * Match elements by the given CSS selector.
	         *
	         * ## Example
	         *
	         * {@example platform-browser/dom/debug/ts/by/by.ts region='by_css'}
	         */
	        By.css = function (selector) {
	            return function (debugElement) {
	                return isPresent(debugElement.nativeElement) ?
	                    getDOM().elementMatches(debugElement.nativeElement, selector) :
	                    false;
	            };
	        };
	        /**
	         * Match elements that have the given directive present.
	         *
	         * ## Example
	         *
	         * {@example platform-browser/dom/debug/ts/by/by.ts region='by_directive'}
	         */
	        By.directive = function (type) {
	            return function (debugElement) { return debugElement.providerTokens.indexOf(type) !== -1; };
	        };
	        return By;
	    }());

	    var __platform_browser_private__ = {
	        BrowserPlatformLocation: BrowserPlatformLocation,
	        DomAdapter: DomAdapter,
	        BrowserDomAdapter: BrowserDomAdapter,
	        BrowserGetTestability: BrowserGetTestability,
	        getDOM: getDOM,
	        setRootDomAdapter: setRootDomAdapter,
	        DomRootRenderer_: DomRootRenderer_,
	        DomRootRenderer: DomRootRenderer,
	        DomSharedStylesHost: DomSharedStylesHost,
	        SharedStylesHost: SharedStylesHost,
	        ELEMENT_PROBE_PROVIDERS: ELEMENT_PROBE_PROVIDERS,
	        DomEventsPlugin: DomEventsPlugin,
	        KeyEventsPlugin: KeyEventsPlugin,
	        HammerGesturesPlugin: HammerGesturesPlugin,
	        initDomAdapter: initDomAdapter,
	        INTERNAL_BROWSER_PLATFORM_PROVIDERS: INTERNAL_BROWSER_PLATFORM_PROVIDERS,
	        BROWSER_SANITIZATION_PROVIDERS: BROWSER_SANITIZATION_PROVIDERS
	    };

	    exports.BrowserModule = BrowserModule;
	    exports.platformBrowser = platformBrowser;
	    exports.Title = Title;
	    exports.disableDebugTools = disableDebugTools;
	    exports.enableDebugTools = enableDebugTools;
	    exports.AnimationDriver = AnimationDriver;
	    exports.By = By;
	    exports.NgProbeToken = NgProbeToken;
	    exports.DOCUMENT = DOCUMENT;
	    exports.EVENT_MANAGER_PLUGINS = EVENT_MANAGER_PLUGINS;
	    exports.EventManager = EventManager;
	    exports.HAMMER_GESTURE_CONFIG = HAMMER_GESTURE_CONFIG;
	    exports.HammerGestureConfig = HammerGestureConfig;
	    exports.DomSanitizer = DomSanitizer;
	    exports.__platform_browser_private__ = __platform_browser_private__;

	}));

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/**
	 * @license Angular v2.1.2
	 * (c) 2010-2016 Google, Inc. https://angular.io/
	 * License: MIT
	 */
	(function (global, factory) {
	     true ? factory(exports, __webpack_require__(3)) :
	    typeof define === 'function' && define.amd ? define(['exports', '@angular/core'], factory) :
	    (factory((global.ng = global.ng || {}, global.ng.common = global.ng.common || {}),global.ng.core));
	}(this, function (exports,_angular_core) { 'use strict';

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    /**
	     * This class should not be used directly by an application developer. Instead, use
	     * {@link Location}.
	     *
	     * `PlatformLocation` encapsulates all calls to DOM apis, which allows the Router to be platform
	     * agnostic.
	     * This means that we can have different implementation of `PlatformLocation` for the different
	     * platforms
	     * that angular supports. For example, the default `PlatformLocation` is {@link
	     * BrowserPlatformLocation},
	     * however when you run your app in a WebWorker you use {@link WebWorkerPlatformLocation}.
	     *
	     * The `PlatformLocation` class is used directly by all implementations of {@link LocationStrategy}
	     * when
	     * they need to interact with the DOM apis like pushState, popState, etc...
	     *
	     * {@link LocationStrategy} in turn is used by the {@link Location} service which is used directly
	     * by
	     * the {@link Router} in order to navigate between routes. Since all interactions between {@link
	     * Router} /
	     * {@link Location} / {@link LocationStrategy} and DOM apis flow through the `PlatformLocation`
	     * class
	     * they are all platform independent.
	     *
	     * @stable
	     */
	    var PlatformLocation = (function () {
	        function PlatformLocation() {
	        }
	        Object.defineProperty(PlatformLocation.prototype, "pathname", {
	            get: function () { return null; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(PlatformLocation.prototype, "search", {
	            get: function () { return null; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(PlatformLocation.prototype, "hash", {
	            get: function () { return null; },
	            enumerable: true,
	            configurable: true
	        });
	        return PlatformLocation;
	    }());

	    /**
	     * `LocationStrategy` is responsible for representing and reading route state
	     * from the browser's URL. Angular provides two strategies:
	     * {@link HashLocationStrategy} and {@link PathLocationStrategy} (default).
	     *
	     * This is used under the hood of the {@link Location} service.
	     *
	     * Applications should use the {@link Router} or {@link Location} services to
	     * interact with application route state.
	     *
	     * For instance, {@link HashLocationStrategy} produces URLs like
	     * `http://example.com#/foo`, and {@link PathLocationStrategy} produces
	     * `http://example.com/foo` as an equivalent URL.
	     *
	     * See these two classes for more.
	     *
	     * @stable
	     */
	    var LocationStrategy = (function () {
	        function LocationStrategy() {
	        }
	        return LocationStrategy;
	    }());
	    /**
	     * The `APP_BASE_HREF` token represents the base href to be used with the
	     * {@link PathLocationStrategy}.
	     *
	     * If you're using {@link PathLocationStrategy}, you must provide a provider to a string
	     * representing the URL prefix that should be preserved when generating and recognizing
	     * URLs.
	     *
	     * ### Example
	     *
	     * ```typescript
	     * import {Component, NgModule} from '@angular/core';
	     * import {APP_BASE_HREF} from '@angular/common';
	     *
	     * @NgModule({
	     *   providers: [{provide: APP_BASE_HREF, useValue: '/my/app'}]
	     * })
	     * class AppModule {}
	     * ```
	     *
	     * @stable
	     */
	    var APP_BASE_HREF = new _angular_core.OpaqueToken('appBaseHref');

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var globalScope;
	    if (typeof window === 'undefined') {
	        if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) {
	            // TODO: Replace any with WorkerGlobalScope from lib.webworker.d.ts #3492
	            globalScope = self;
	        }
	        else {
	            globalScope = global;
	        }
	    }
	    else {
	        globalScope = window;
	    }
	    // Need to declare a new variable for global here since TypeScript
	    // exports the original value of the symbol.
	    var _global = globalScope;
	    function getTypeNameForDebugging(type) {
	        return type['name'] || typeof type;
	    }
	    // TODO: remove calls to assert in production environment
	    // Note: Can't just export this and import in in other files
	    // as `assert` is a reserved keyword in Dart
	    _global.assert = function assert(condition) {
	        // TODO: to be fixed properly via #2830, noop for now
	    };
	    function isPresent(obj) {
	        return obj != null;
	    }
	    function isBlank(obj) {
	        return obj == null;
	    }
	    function isDate(obj) {
	        return obj instanceof Date && !isNaN(obj.valueOf());
	    }
	    function stringify(token) {
	        if (typeof token === 'string') {
	            return token;
	        }
	        if (token === undefined || token === null) {
	            return '' + token;
	        }
	        if (token.overriddenName) {
	            return token.overriddenName;
	        }
	        if (token.name) {
	            return token.name;
	        }
	        var res = token.toString();
	        var newLineIndex = res.indexOf('\n');
	        return newLineIndex === -1 ? res : res.substring(0, newLineIndex);
	    }
	    var NumberWrapper = (function () {
	        function NumberWrapper() {
	        }
	        NumberWrapper.parseIntAutoRadix = function (text) {
	            var result = parseInt(text);
	            if (isNaN(result)) {
	                throw new Error('Invalid integer literal when parsing ' + text);
	            }
	            return result;
	        };
	        NumberWrapper.parseInt = function (text, radix) {
	            if (radix == 10) {
	                if (/^(\-|\+)?[0-9]+$/.test(text)) {
	                    return parseInt(text, radix);
	                }
	            }
	            else if (radix == 16) {
	                if (/^(\-|\+)?[0-9ABCDEFabcdef]+$/.test(text)) {
	                    return parseInt(text, radix);
	                }
	            }
	            else {
	                var result = parseInt(text, radix);
	                if (!isNaN(result)) {
	                    return result;
	                }
	            }
	            throw new Error('Invalid integer literal when parsing ' + text + ' in base ' + radix);
	        };
	        NumberWrapper.isNumeric = function (value) { return !isNaN(value - parseFloat(value)); };
	        return NumberWrapper;
	    }());
	    function isJsObject(o) {
	        return o !== null && (typeof o === 'function' || typeof o === 'object');
	    }
	    var _symbolIterator = null;
	    function getSymbolIterator() {
	        if (!_symbolIterator) {
	            if (globalScope.Symbol && Symbol.iterator) {
	                _symbolIterator = Symbol.iterator;
	            }
	            else {
	                // es6-shim specific logic
	                var keys = Object.getOwnPropertyNames(Map.prototype);
	                for (var i = 0; i < keys.length; ++i) {
	                    var key = keys[i];
	                    if (key !== 'entries' && key !== 'size' &&
	                        Map.prototype[key] === Map.prototype['entries']) {
	                        _symbolIterator = key;
	                    }
	                }
	            }
	        }
	        return _symbolIterator;
	    }

	    /**
	     * `Location` is a service that applications can use to interact with a browser's URL.
	     * Depending on which {@link LocationStrategy} is used, `Location` will either persist
	     * to the URL's path or the URL's hash segment.
	     *
	     * Note: it's better to use {@link Router#navigate} service to trigger route changes. Use
	     * `Location` only if you need to interact with or create normalized URLs outside of
	     * routing.
	     *
	     * `Location` is responsible for normalizing the URL against the application's base href.
	     * A normalized URL is absolute from the URL host, includes the application's base href, and has no
	     * trailing slash:
	     * - `/my/app/user/123` is normalized
	     * - `my/app/user/123` **is not** normalized
	     * - `/my/app/user/123/` **is not** normalized
	     *
	     * ### Example
	     *
	     * ```
	     * import {Component} from '@angular/core';
	     * import {Location} from '@angular/common';
	     *
	     * @Component({selector: 'app-component'})
	     * class AppCmp {
	     *   constructor(location: Location) {
	     *     location.go('/foo');
	     *   }
	     * }
	     * ```
	     *
	     * @stable
	     */
	    var Location = (function () {
	        function Location(platformStrategy) {
	            var _this = this;
	            /** @internal */
	            this._subject = new _angular_core.EventEmitter();
	            this._platformStrategy = platformStrategy;
	            var browserBaseHref = this._platformStrategy.getBaseHref();
	            this._baseHref = Location.stripTrailingSlash(_stripIndexHtml(browserBaseHref));
	            this._platformStrategy.onPopState(function (ev) {
	                _this._subject.emit({
	                    'url': _this.path(true),
	                    'pop': true,
	                    'type': ev.type,
	                });
	            });
	        }
	        /**
	         * Returns the normalized URL path.
	         */
	        // TODO: vsavkin. Remove the boolean flag and always include hash once the deprecated router is
	        // removed.
	        Location.prototype.path = function (includeHash) {
	            if (includeHash === void 0) { includeHash = false; }
	            return this.normalize(this._platformStrategy.path(includeHash));
	        };
	        /**
	         * Normalizes the given path and compares to the current normalized path.
	         */
	        Location.prototype.isCurrentPathEqualTo = function (path, query) {
	            if (query === void 0) { query = ''; }
	            return this.path() == this.normalize(path + Location.normalizeQueryParams(query));
	        };
	        /**
	         * Given a string representing a URL, returns the normalized URL path without leading or
	         * trailing slashes.
	         */
	        Location.prototype.normalize = function (url) {
	            return Location.stripTrailingSlash(_stripBaseHref(this._baseHref, _stripIndexHtml(url)));
	        };
	        /**
	         * Given a string representing a URL, returns the platform-specific external URL path.
	         * If the given URL doesn't begin with a leading slash (`'/'`), this method adds one
	         * before normalizing. This method will also add a hash if `HashLocationStrategy` is
	         * used, or the `APP_BASE_HREF` if the `PathLocationStrategy` is in use.
	         */
	        Location.prototype.prepareExternalUrl = function (url) {
	            if (url.length > 0 && !url.startsWith('/')) {
	                url = '/' + url;
	            }
	            return this._platformStrategy.prepareExternalUrl(url);
	        };
	        // TODO: rename this method to pushState
	        /**
	         * Changes the browsers URL to the normalized version of the given URL, and pushes a
	         * new item onto the platform's history.
	         */
	        Location.prototype.go = function (path, query) {
	            if (query === void 0) { query = ''; }
	            this._platformStrategy.pushState(null, '', path, query);
	        };
	        /**
	         * Changes the browsers URL to the normalized version of the given URL, and replaces
	         * the top item on the platform's history stack.
	         */
	        Location.prototype.replaceState = function (path, query) {
	            if (query === void 0) { query = ''; }
	            this._platformStrategy.replaceState(null, '', path, query);
	        };
	        /**
	         * Navigates forward in the platform's history.
	         */
	        Location.prototype.forward = function () { this._platformStrategy.forward(); };
	        /**
	         * Navigates back in the platform's history.
	         */
	        Location.prototype.back = function () { this._platformStrategy.back(); };
	        /**
	         * Subscribe to the platform's `popState` events.
	         */
	        Location.prototype.subscribe = function (onNext, onThrow, onReturn) {
	            if (onThrow === void 0) { onThrow = null; }
	            if (onReturn === void 0) { onReturn = null; }
	            return this._subject.subscribe({ next: onNext, error: onThrow, complete: onReturn });
	        };
	        /**
	         * Given a string of url parameters, prepend with '?' if needed, otherwise return parameters as
	         * is.
	         */
	        Location.normalizeQueryParams = function (params) {
	            return (params.length > 0 && params.substring(0, 1) != '?') ? ('?' + params) : params;
	        };
	        /**
	         * Given 2 parts of a url, join them with a slash if needed.
	         */
	        Location.joinWithSlash = function (start, end) {
	            if (start.length == 0) {
	                return end;
	            }
	            if (end.length == 0) {
	                return start;
	            }
	            var slashes = 0;
	            if (start.endsWith('/')) {
	                slashes++;
	            }
	            if (end.startsWith('/')) {
	                slashes++;
	            }
	            if (slashes == 2) {
	                return start + end.substring(1);
	            }
	            if (slashes == 1) {
	                return start + end;
	            }
	            return start + '/' + end;
	        };
	        /**
	         * If url has a trailing slash, remove it, otherwise return url as is.
	         */
	        Location.stripTrailingSlash = function (url) {
	            if (/\/$/g.test(url)) {
	                url = url.substring(0, url.length - 1);
	            }
	            return url;
	        };
	        Location.decorators = [
	            { type: _angular_core.Injectable },
	        ];
	        /** @nocollapse */
	        Location.ctorParameters = [
	            { type: LocationStrategy, },
	        ];
	        return Location;
	    }());
	    function _stripBaseHref(baseHref, url) {
	        if (baseHref.length > 0 && url.startsWith(baseHref)) {
	            return url.substring(baseHref.length);
	        }
	        return url;
	    }
	    function _stripIndexHtml(url) {
	        if (/\/index.html$/g.test(url)) {
	            // '/index.html'.length == 11
	            return url.substring(0, url.length - 11);
	        }
	        return url;
	    }

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    /**
	     * `HashLocationStrategy` is a {@link LocationStrategy} used to configure the
	     * {@link Location} service to represent its state in the
	     * [hash fragment](https://en.wikipedia.org/wiki/Uniform_Resource_Locator#Syntax)
	     * of the browser's URL.
	     *
	     * For instance, if you call `location.go('/foo')`, the browser's URL will become
	     * `example.com#/foo`.
	     *
	     * ### Example
	     *
	     * ```
	     * import {Component, NgModule} from '@angular/core';
	     * import {
	     *   LocationStrategy,
	     *   HashLocationStrategy
	     * } from '@angular/common';
	     *
	     * @NgModule({
	     *   providers: [{provide: LocationStrategy, useClass: HashLocationStrategy}]
	     * })
	     * class AppModule {}
	     * ```
	     *
	     * @stable
	     */
	    var HashLocationStrategy = (function (_super) {
	        __extends(HashLocationStrategy, _super);
	        function HashLocationStrategy(_platformLocation, _baseHref) {
	            _super.call(this);
	            this._platformLocation = _platformLocation;
	            this._baseHref = '';
	            if (isPresent(_baseHref)) {
	                this._baseHref = _baseHref;
	            }
	        }
	        HashLocationStrategy.prototype.onPopState = function (fn) {
	            this._platformLocation.onPopState(fn);
	            this._platformLocation.onHashChange(fn);
	        };
	        HashLocationStrategy.prototype.getBaseHref = function () { return this._baseHref; };
	        HashLocationStrategy.prototype.path = function (includeHash) {
	            if (includeHash === void 0) { includeHash = false; }
	            // the hash value is always prefixed with a `#`
	            // and if it is empty then it will stay empty
	            var path = this._platformLocation.hash;
	            if (!isPresent(path))
	                path = '#';
	            return path.length > 0 ? path.substring(1) : path;
	        };
	        HashLocationStrategy.prototype.prepareExternalUrl = function (internal) {
	            var url = Location.joinWithSlash(this._baseHref, internal);
	            return url.length > 0 ? ('#' + url) : url;
	        };
	        HashLocationStrategy.prototype.pushState = function (state, title, path, queryParams) {
	            var url = this.prepareExternalUrl(path + Location.normalizeQueryParams(queryParams));
	            if (url.length == 0) {
	                url = this._platformLocation.pathname;
	            }
	            this._platformLocation.pushState(state, title, url);
	        };
	        HashLocationStrategy.prototype.replaceState = function (state, title, path, queryParams) {
	            var url = this.prepareExternalUrl(path + Location.normalizeQueryParams(queryParams));
	            if (url.length == 0) {
	                url = this._platformLocation.pathname;
	            }
	            this._platformLocation.replaceState(state, title, url);
	        };
	        HashLocationStrategy.prototype.forward = function () { this._platformLocation.forward(); };
	        HashLocationStrategy.prototype.back = function () { this._platformLocation.back(); };
	        HashLocationStrategy.decorators = [
	            { type: _angular_core.Injectable },
	        ];
	        /** @nocollapse */
	        HashLocationStrategy.ctorParameters = [
	            { type: PlatformLocation, },
	            { type: undefined, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Inject, args: [APP_BASE_HREF,] },] },
	        ];
	        return HashLocationStrategy;
	    }(LocationStrategy));

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$1 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    /**
	     * `PathLocationStrategy` is a {@link LocationStrategy} used to configure the
	     * {@link Location} service to represent its state in the
	     * [path](https://en.wikipedia.org/wiki/Uniform_Resource_Locator#Syntax) of the
	     * browser's URL.
	     *
	     * `PathLocationStrategy` is the default binding for {@link LocationStrategy}
	     * provided in {@link ROUTER_PROVIDERS}.
	     *
	     * If you're using `PathLocationStrategy`, you must provide a {@link APP_BASE_HREF}
	     * or add a base element to the document. This URL prefix that will be preserved
	     * when generating and recognizing URLs.
	     *
	     * For instance, if you provide an `APP_BASE_HREF` of `'/my/app'` and call
	     * `location.go('/foo')`, the browser's URL will become
	     * `example.com/my/app/foo`.
	     *
	     * Similarly, if you add `<base href='/my/app'/>` to the document and call
	     * `location.go('/foo')`, the browser's URL will become
	     * `example.com/my/app/foo`.
	     *
	     * @stable
	     */
	    var PathLocationStrategy = (function (_super) {
	        __extends$1(PathLocationStrategy, _super);
	        function PathLocationStrategy(_platformLocation, href) {
	            _super.call(this);
	            this._platformLocation = _platformLocation;
	            if (isBlank(href)) {
	                href = this._platformLocation.getBaseHrefFromDOM();
	            }
	            if (isBlank(href)) {
	                throw new Error("No base href set. Please provide a value for the APP_BASE_HREF token or add a base element to the document.");
	            }
	            this._baseHref = href;
	        }
	        PathLocationStrategy.prototype.onPopState = function (fn) {
	            this._platformLocation.onPopState(fn);
	            this._platformLocation.onHashChange(fn);
	        };
	        PathLocationStrategy.prototype.getBaseHref = function () { return this._baseHref; };
	        PathLocationStrategy.prototype.prepareExternalUrl = function (internal) {
	            return Location.joinWithSlash(this._baseHref, internal);
	        };
	        PathLocationStrategy.prototype.path = function (includeHash) {
	            if (includeHash === void 0) { includeHash = false; }
	            var pathname = this._platformLocation.pathname +
	                Location.normalizeQueryParams(this._platformLocation.search);
	            var hash = this._platformLocation.hash;
	            return hash && includeHash ? "" + pathname + hash : pathname;
	        };
	        PathLocationStrategy.prototype.pushState = function (state, title, url, queryParams) {
	            var externalUrl = this.prepareExternalUrl(url + Location.normalizeQueryParams(queryParams));
	            this._platformLocation.pushState(state, title, externalUrl);
	        };
	        PathLocationStrategy.prototype.replaceState = function (state, title, url, queryParams) {
	            var externalUrl = this.prepareExternalUrl(url + Location.normalizeQueryParams(queryParams));
	            this._platformLocation.replaceState(state, title, externalUrl);
	        };
	        PathLocationStrategy.prototype.forward = function () { this._platformLocation.forward(); };
	        PathLocationStrategy.prototype.back = function () { this._platformLocation.back(); };
	        PathLocationStrategy.decorators = [
	            { type: _angular_core.Injectable },
	        ];
	        /** @nocollapse */
	        PathLocationStrategy.ctorParameters = [
	            { type: PlatformLocation, },
	            { type: undefined, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Inject, args: [APP_BASE_HREF,] },] },
	        ];
	        return PathLocationStrategy;
	    }(LocationStrategy));

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$2 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    /**
	     * @experimental
	     */
	    var NgLocalization = (function () {
	        function NgLocalization() {
	        }
	        return NgLocalization;
	    }());
	    /**
	     * Returns the plural category for a given value.
	     * - "=value" when the case exists,
	     * - the plural category otherwise
	     *
	     * @internal
	     */
	    function getPluralCategory(value, cases, ngLocalization) {
	        var nbCase = "=" + value;
	        return cases.indexOf(nbCase) > -1 ? nbCase : ngLocalization.getPluralCategory(value);
	    }
	    /**
	     * Returns the plural case based on the locale
	     *
	     * @experimental
	     */
	    var NgLocaleLocalization = (function (_super) {
	        __extends$2(NgLocaleLocalization, _super);
	        function NgLocaleLocalization(_locale) {
	            _super.call(this);
	            this._locale = _locale;
	        }
	        NgLocaleLocalization.prototype.getPluralCategory = function (value) {
	            var plural = getPluralCase(this._locale, value);
	            switch (plural) {
	                case Plural.Zero:
	                    return 'zero';
	                case Plural.One:
	                    return 'one';
	                case Plural.Two:
	                    return 'two';
	                case Plural.Few:
	                    return 'few';
	                case Plural.Many:
	                    return 'many';
	                default:
	                    return 'other';
	            }
	        };
	        NgLocaleLocalization.decorators = [
	            { type: _angular_core.Injectable },
	        ];
	        /** @nocollapse */
	        NgLocaleLocalization.ctorParameters = [
	            { type: undefined, decorators: [{ type: _angular_core.Inject, args: [_angular_core.LOCALE_ID,] },] },
	        ];
	        return NgLocaleLocalization;
	    }(NgLocalization));
	    // This is generated code DO NOT MODIFY
	    // see angular2/script/cldr/gen_plural_rules.js
	    /** @experimental */
	    var Plural;
	    (function (Plural) {
	        Plural[Plural["Zero"] = 0] = "Zero";
	        Plural[Plural["One"] = 1] = "One";
	        Plural[Plural["Two"] = 2] = "Two";
	        Plural[Plural["Few"] = 3] = "Few";
	        Plural[Plural["Many"] = 4] = "Many";
	        Plural[Plural["Other"] = 5] = "Other";
	    })(Plural || (Plural = {}));
	    /**
	     * Returns the plural case based on the locale
	     *
	     * @experimental
	     */
	    function getPluralCase(locale, nLike) {
	        // TODO(vicb): lazy compute
	        if (typeof nLike === 'string') {
	            nLike = parseInt(nLike, 10);
	        }
	        var n = nLike;
	        var nDecimal = n.toString().replace(/^[^.]*\.?/, '');
	        var i = Math.floor(Math.abs(n));
	        var v = nDecimal.length;
	        var f = parseInt(nDecimal, 10);
	        var t = parseInt(n.toString().replace(/^[^.]*\.?|0+$/g, ''), 10) || 0;
	        var lang = locale.split('-')[0].toLowerCase();
	        switch (lang) {
	            case 'af':
	            case 'asa':
	            case 'az':
	            case 'bem':
	            case 'bez':
	            case 'bg':
	            case 'brx':
	            case 'ce':
	            case 'cgg':
	            case 'chr':
	            case 'ckb':
	            case 'ee':
	            case 'el':
	            case 'eo':
	            case 'es':
	            case 'eu':
	            case 'fo':
	            case 'fur':
	            case 'gsw':
	            case 'ha':
	            case 'haw':
	            case 'hu':
	            case 'jgo':
	            case 'jmc':
	            case 'ka':
	            case 'kk':
	            case 'kkj':
	            case 'kl':
	            case 'ks':
	            case 'ksb':
	            case 'ky':
	            case 'lb':
	            case 'lg':
	            case 'mas':
	            case 'mgo':
	            case 'ml':
	            case 'mn':
	            case 'nb':
	            case 'nd':
	            case 'ne':
	            case 'nn':
	            case 'nnh':
	            case 'nyn':
	            case 'om':
	            case 'or':
	            case 'os':
	            case 'ps':
	            case 'rm':
	            case 'rof':
	            case 'rwk':
	            case 'saq':
	            case 'seh':
	            case 'sn':
	            case 'so':
	            case 'sq':
	            case 'ta':
	            case 'te':
	            case 'teo':
	            case 'tk':
	            case 'tr':
	            case 'ug':
	            case 'uz':
	            case 'vo':
	            case 'vun':
	            case 'wae':
	            case 'xog':
	                if (n === 1)
	                    return Plural.One;
	                return Plural.Other;
	            case 'agq':
	            case 'bas':
	            case 'cu':
	            case 'dav':
	            case 'dje':
	            case 'dua':
	            case 'dyo':
	            case 'ebu':
	            case 'ewo':
	            case 'guz':
	            case 'kam':
	            case 'khq':
	            case 'ki':
	            case 'kln':
	            case 'kok':
	            case 'ksf':
	            case 'lrc':
	            case 'lu':
	            case 'luo':
	            case 'luy':
	            case 'mer':
	            case 'mfe':
	            case 'mgh':
	            case 'mua':
	            case 'mzn':
	            case 'nmg':
	            case 'nus':
	            case 'qu':
	            case 'rn':
	            case 'rw':
	            case 'sbp':
	            case 'twq':
	            case 'vai':
	            case 'yav':
	            case 'yue':
	            case 'zgh':
	            case 'ak':
	            case 'ln':
	            case 'mg':
	            case 'pa':
	            case 'ti':
	                if (n === Math.floor(n) && n >= 0 && n <= 1)
	                    return Plural.One;
	                return Plural.Other;
	            case 'am':
	            case 'as':
	            case 'bn':
	            case 'fa':
	            case 'gu':
	            case 'hi':
	            case 'kn':
	            case 'mr':
	            case 'zu':
	                if (i === 0 || n === 1)
	                    return Plural.One;
	                return Plural.Other;
	            case 'ar':
	                if (n === 0)
	                    return Plural.Zero;
	                if (n === 1)
	                    return Plural.One;
	                if (n === 2)
	                    return Plural.Two;
	                if (n % 100 === Math.floor(n % 100) && n % 100 >= 3 && n % 100 <= 10)
	                    return Plural.Few;
	                if (n % 100 === Math.floor(n % 100) && n % 100 >= 11 && n % 100 <= 99)
	                    return Plural.Many;
	                return Plural.Other;
	            case 'ast':
	            case 'ca':
	            case 'de':
	            case 'en':
	            case 'et':
	            case 'fi':
	            case 'fy':
	            case 'gl':
	            case 'it':
	            case 'nl':
	            case 'sv':
	            case 'sw':
	            case 'ur':
	            case 'yi':
	                if (i === 1 && v === 0)
	                    return Plural.One;
	                return Plural.Other;
	            case 'be':
	                if (n % 10 === 1 && !(n % 100 === 11))
	                    return Plural.One;
	                if (n % 10 === Math.floor(n % 10) && n % 10 >= 2 && n % 10 <= 4 &&
	                    !(n % 100 >= 12 && n % 100 <= 14))
	                    return Plural.Few;
	                if (n % 10 === 0 || n % 10 === Math.floor(n % 10) && n % 10 >= 5 && n % 10 <= 9 ||
	                    n % 100 === Math.floor(n % 100) && n % 100 >= 11 && n % 100 <= 14)
	                    return Plural.Many;
	                return Plural.Other;
	            case 'br':
	                if (n % 10 === 1 && !(n % 100 === 11 || n % 100 === 71 || n % 100 === 91))
	                    return Plural.One;
	                if (n % 10 === 2 && !(n % 100 === 12 || n % 100 === 72 || n % 100 === 92))
	                    return Plural.Two;
	                if (n % 10 === Math.floor(n % 10) && (n % 10 >= 3 && n % 10 <= 4 || n % 10 === 9) &&
	                    !(n % 100 >= 10 && n % 100 <= 19 || n % 100 >= 70 && n % 100 <= 79 ||
	                        n % 100 >= 90 && n % 100 <= 99))
	                    return Plural.Few;
	                if (!(n === 0) && n % 1e6 === 0)
	                    return Plural.Many;
	                return Plural.Other;
	            case 'bs':
	            case 'hr':
	            case 'sr':
	                if (v === 0 && i % 10 === 1 && !(i % 100 === 11) || f % 10 === 1 && !(f % 100 === 11))
	                    return Plural.One;
	                if (v === 0 && i % 10 === Math.floor(i % 10) && i % 10 >= 2 && i % 10 <= 4 &&
	                    !(i % 100 >= 12 && i % 100 <= 14) ||
	                    f % 10 === Math.floor(f % 10) && f % 10 >= 2 && f % 10 <= 4 &&
	                        !(f % 100 >= 12 && f % 100 <= 14))
	                    return Plural.Few;
	                return Plural.Other;
	            case 'cs':
	            case 'sk':
	                if (i === 1 && v === 0)
	                    return Plural.One;
	                if (i === Math.floor(i) && i >= 2 && i <= 4 && v === 0)
	                    return Plural.Few;
	                if (!(v === 0))
	                    return Plural.Many;
	                return Plural.Other;
	            case 'cy':
	                if (n === 0)
	                    return Plural.Zero;
	                if (n === 1)
	                    return Plural.One;
	                if (n === 2)
	                    return Plural.Two;
	                if (n === 3)
	                    return Plural.Few;
	                if (n === 6)
	                    return Plural.Many;
	                return Plural.Other;
	            case 'da':
	                if (n === 1 || !(t === 0) && (i === 0 || i === 1))
	                    return Plural.One;
	                return Plural.Other;
	            case 'dsb':
	            case 'hsb':
	                if (v === 0 && i % 100 === 1 || f % 100 === 1)
	                    return Plural.One;
	                if (v === 0 && i % 100 === 2 || f % 100 === 2)
	                    return Plural.Two;
	                if (v === 0 && i % 100 === Math.floor(i % 100) && i % 100 >= 3 && i % 100 <= 4 ||
	                    f % 100 === Math.floor(f % 100) && f % 100 >= 3 && f % 100 <= 4)
	                    return Plural.Few;
	                return Plural.Other;
	            case 'ff':
	            case 'fr':
	            case 'hy':
	            case 'kab':
	                if (i === 0 || i === 1)
	                    return Plural.One;
	                return Plural.Other;
	            case 'fil':
	                if (v === 0 && (i === 1 || i === 2 || i === 3) ||
	                    v === 0 && !(i % 10 === 4 || i % 10 === 6 || i % 10 === 9) ||
	                    !(v === 0) && !(f % 10 === 4 || f % 10 === 6 || f % 10 === 9))
	                    return Plural.One;
	                return Plural.Other;
	            case 'ga':
	                if (n === 1)
	                    return Plural.One;
	                if (n === 2)
	                    return Plural.Two;
	                if (n === Math.floor(n) && n >= 3 && n <= 6)
	                    return Plural.Few;
	                if (n === Math.floor(n) && n >= 7 && n <= 10)
	                    return Plural.Many;
	                return Plural.Other;
	            case 'gd':
	                if (n === 1 || n === 11)
	                    return Plural.One;
	                if (n === 2 || n === 12)
	                    return Plural.Two;
	                if (n === Math.floor(n) && (n >= 3 && n <= 10 || n >= 13 && n <= 19))
	                    return Plural.Few;
	                return Plural.Other;
	            case 'gv':
	                if (v === 0 && i % 10 === 1)
	                    return Plural.One;
	                if (v === 0 && i % 10 === 2)
	                    return Plural.Two;
	                if (v === 0 &&
	                    (i % 100 === 0 || i % 100 === 20 || i % 100 === 40 || i % 100 === 60 || i % 100 === 80))
	                    return Plural.Few;
	                if (!(v === 0))
	                    return Plural.Many;
	                return Plural.Other;
	            case 'he':
	                if (i === 1 && v === 0)
	                    return Plural.One;
	                if (i === 2 && v === 0)
	                    return Plural.Two;
	                if (v === 0 && !(n >= 0 && n <= 10) && n % 10 === 0)
	                    return Plural.Many;
	                return Plural.Other;
	            case 'is':
	                if (t === 0 && i % 10 === 1 && !(i % 100 === 11) || !(t === 0))
	                    return Plural.One;
	                return Plural.Other;
	            case 'ksh':
	                if (n === 0)
	                    return Plural.Zero;
	                if (n === 1)
	                    return Plural.One;
	                return Plural.Other;
	            case 'kw':
	            case 'naq':
	            case 'se':
	            case 'smn':
	                if (n === 1)
	                    return Plural.One;
	                if (n === 2)
	                    return Plural.Two;
	                return Plural.Other;
	            case 'lag':
	                if (n === 0)
	                    return Plural.Zero;
	                if ((i === 0 || i === 1) && !(n === 0))
	                    return Plural.One;
	                return Plural.Other;
	            case 'lt':
	                if (n % 10 === 1 && !(n % 100 >= 11 && n % 100 <= 19))
	                    return Plural.One;
	                if (n % 10 === Math.floor(n % 10) && n % 10 >= 2 && n % 10 <= 9 &&
	                    !(n % 100 >= 11 && n % 100 <= 19))
	                    return Plural.Few;
	                if (!(f === 0))
	                    return Plural.Many;
	                return Plural.Other;
	            case 'lv':
	            case 'prg':
	                if (n % 10 === 0 || n % 100 === Math.floor(n % 100) && n % 100 >= 11 && n % 100 <= 19 ||
	                    v === 2 && f % 100 === Math.floor(f % 100) && f % 100 >= 11 && f % 100 <= 19)
	                    return Plural.Zero;
	                if (n % 10 === 1 && !(n % 100 === 11) || v === 2 && f % 10 === 1 && !(f % 100 === 11) ||
	                    !(v === 2) && f % 10 === 1)
	                    return Plural.One;
	                return Plural.Other;
	            case 'mk':
	                if (v === 0 && i % 10 === 1 || f % 10 === 1)
	                    return Plural.One;
	                return Plural.Other;
	            case 'mt':
	                if (n === 1)
	                    return Plural.One;
	                if (n === 0 || n % 100 === Math.floor(n % 100) && n % 100 >= 2 && n % 100 <= 10)
	                    return Plural.Few;
	                if (n % 100 === Math.floor(n % 100) && n % 100 >= 11 && n % 100 <= 19)
	                    return Plural.Many;
	                return Plural.Other;
	            case 'pl':
	                if (i === 1 && v === 0)
	                    return Plural.One;
	                if (v === 0 && i % 10 === Math.floor(i % 10) && i % 10 >= 2 && i % 10 <= 4 &&
	                    !(i % 100 >= 12 && i % 100 <= 14))
	                    return Plural.Few;
	                if (v === 0 && !(i === 1) && i % 10 === Math.floor(i % 10) && i % 10 >= 0 && i % 10 <= 1 ||
	                    v === 0 && i % 10 === Math.floor(i % 10) && i % 10 >= 5 && i % 10 <= 9 ||
	                    v === 0 && i % 100 === Math.floor(i % 100) && i % 100 >= 12 && i % 100 <= 14)
	                    return Plural.Many;
	                return Plural.Other;
	            case 'pt':
	                if (n === Math.floor(n) && n >= 0 && n <= 2 && !(n === 2))
	                    return Plural.One;
	                return Plural.Other;
	            case 'ro':
	                if (i === 1 && v === 0)
	                    return Plural.One;
	                if (!(v === 0) || n === 0 ||
	                    !(n === 1) && n % 100 === Math.floor(n % 100) && n % 100 >= 1 && n % 100 <= 19)
	                    return Plural.Few;
	                return Plural.Other;
	            case 'ru':
	            case 'uk':
	                if (v === 0 && i % 10 === 1 && !(i % 100 === 11))
	                    return Plural.One;
	                if (v === 0 && i % 10 === Math.floor(i % 10) && i % 10 >= 2 && i % 10 <= 4 &&
	                    !(i % 100 >= 12 && i % 100 <= 14))
	                    return Plural.Few;
	                if (v === 0 && i % 10 === 0 ||
	                    v === 0 && i % 10 === Math.floor(i % 10) && i % 10 >= 5 && i % 10 <= 9 ||
	                    v === 0 && i % 100 === Math.floor(i % 100) && i % 100 >= 11 && i % 100 <= 14)
	                    return Plural.Many;
	                return Plural.Other;
	            case 'shi':
	                if (i === 0 || n === 1)
	                    return Plural.One;
	                if (n === Math.floor(n) && n >= 2 && n <= 10)
	                    return Plural.Few;
	                return Plural.Other;
	            case 'si':
	                if (n === 0 || n === 1 || i === 0 && f === 1)
	                    return Plural.One;
	                return Plural.Other;
	            case 'sl':
	                if (v === 0 && i % 100 === 1)
	                    return Plural.One;
	                if (v === 0 && i % 100 === 2)
	                    return Plural.Two;
	                if (v === 0 && i % 100 === Math.floor(i % 100) && i % 100 >= 3 && i % 100 <= 4 || !(v === 0))
	                    return Plural.Few;
	                return Plural.Other;
	            case 'tzm':
	                if (n === Math.floor(n) && n >= 0 && n <= 1 || n === Math.floor(n) && n >= 11 && n <= 99)
	                    return Plural.One;
	                return Plural.Other;
	            default:
	                return Plural.Other;
	        }
	    }

	    // Safari doesn't implement MapIterator.next(), which is used is Traceur's polyfill of Array.from
	    // TODO(mlaval): remove the work around once we have a working polyfill of Array.from
	    var _arrayFromMap = (function () {
	        try {
	            if ((new Map()).values().next) {
	                return function createArrayFromMap(m, getValues) {
	                    return getValues ? Array.from(m.values()) : Array.from(m.keys());
	                };
	            }
	        }
	        catch (e) {
	        }
	        return function createArrayFromMapWithForeach(m, getValues) {
	            var res = new Array(m.size), i = 0;
	            m.forEach(function (v, k) {
	                res[i] = getValues ? v : k;
	                i++;
	            });
	            return res;
	        };
	    })();
	    var ListWrapper = (function () {
	        function ListWrapper() {
	        }
	        ListWrapper.removeAll = function (list, items) {
	            for (var i = 0; i < items.length; ++i) {
	                var index = list.indexOf(items[i]);
	                list.splice(index, 1);
	            }
	        };
	        ListWrapper.remove = function (list, el) {
	            var index = list.indexOf(el);
	            if (index > -1) {
	                list.splice(index, 1);
	                return true;
	            }
	            return false;
	        };
	        ListWrapper.equals = function (a, b) {
	            if (a.length != b.length)
	                return false;
	            for (var i = 0; i < a.length; ++i) {
	                if (a[i] !== b[i])
	                    return false;
	            }
	            return true;
	        };
	        ListWrapper.maximum = function (list, predicate) {
	            if (list.length == 0) {
	                return null;
	            }
	            var solution = null;
	            var maxValue = -Infinity;
	            for (var index = 0; index < list.length; index++) {
	                var candidate = list[index];
	                if (candidate == null) {
	                    continue;
	                }
	                var candidateValue = predicate(candidate);
	                if (candidateValue > maxValue) {
	                    solution = candidate;
	                    maxValue = candidateValue;
	                }
	            }
	            return solution;
	        };
	        ListWrapper.flatten = function (list) {
	            var target = [];
	            _flattenArray(list, target);
	            return target;
	        };
	        return ListWrapper;
	    }());
	    function _flattenArray(source, target) {
	        if (isPresent(source)) {
	            for (var i = 0; i < source.length; i++) {
	                var item = source[i];
	                if (Array.isArray(item)) {
	                    _flattenArray(item, target);
	                }
	                else {
	                    target.push(item);
	                }
	            }
	        }
	        return target;
	    }
	    function isListLikeIterable(obj) {
	        if (!isJsObject(obj))
	            return false;
	        return Array.isArray(obj) ||
	            (!(obj instanceof Map) &&
	                getSymbolIterator() in obj); // JS Iterable have a Symbol.iterator prop
	    }

	    /**
	     * @ngModule CommonModule
	     *
	     * @whatItDoes Adds and removes CSS classes on an HTML element.
	     *
	     * @howToUse
	     * ```
	     *     <some-element [ngClass]="'first second'">...</some-element>
	     *
	     *     <some-element [ngClass]="['first', 'second']">...</some-element>
	     *
	     *     <some-element [ngClass]="{'first': true, 'second': true, 'third': false}">...</some-element>
	     *
	     *     <some-element [ngClass]="stringExp|arrayExp|objExp">...</some-element>
	     * ```
	     *
	     * @description
	     *
	     * The CSS classes are updated as follows, depending on the type of the expression evaluation:
	     * - `string` - the CSS classes listed in the string (space delimited) are added,
	     * - `Array` - the CSS classes declared as Array elements are added,
	     * - `Object` - keys are CSS classes that get added when the expression given in the value
	     *              evaluates to a truthy value, otherwise they are removed.
	     *
	     * @stable
	     */
	    var NgClass = (function () {
	        function NgClass(_iterableDiffers, _keyValueDiffers, _ngEl, _renderer) {
	            this._iterableDiffers = _iterableDiffers;
	            this._keyValueDiffers = _keyValueDiffers;
	            this._ngEl = _ngEl;
	            this._renderer = _renderer;
	            this._initialClasses = [];
	        }
	        Object.defineProperty(NgClass.prototype, "klass", {
	            set: function (v) {
	                this._applyInitialClasses(true);
	                this._initialClasses = typeof v === 'string' ? v.split(/\s+/) : [];
	                this._applyInitialClasses(false);
	                this._applyClasses(this._rawClass, false);
	            },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(NgClass.prototype, "ngClass", {
	            set: function (v) {
	                this._cleanupClasses(this._rawClass);
	                this._iterableDiffer = null;
	                this._keyValueDiffer = null;
	                this._rawClass = typeof v === 'string' ? v.split(/\s+/) : v;
	                if (this._rawClass) {
	                    if (isListLikeIterable(this._rawClass)) {
	                        this._iterableDiffer = this._iterableDiffers.find(this._rawClass).create(null);
	                    }
	                    else {
	                        this._keyValueDiffer = this._keyValueDiffers.find(this._rawClass).create(null);
	                    }
	                }
	            },
	            enumerable: true,
	            configurable: true
	        });
	        NgClass.prototype.ngDoCheck = function () {
	            if (this._iterableDiffer) {
	                var changes = this._iterableDiffer.diff(this._rawClass);
	                if (changes) {
	                    this._applyIterableChanges(changes);
	                }
	            }
	            else if (this._keyValueDiffer) {
	                var changes = this._keyValueDiffer.diff(this._rawClass);
	                if (changes) {
	                    this._applyKeyValueChanges(changes);
	                }
	            }
	        };
	        NgClass.prototype._cleanupClasses = function (rawClassVal) {
	            this._applyClasses(rawClassVal, true);
	            this._applyInitialClasses(false);
	        };
	        NgClass.prototype._applyKeyValueChanges = function (changes) {
	            var _this = this;
	            changes.forEachAddedItem(function (record) { return _this._toggleClass(record.key, record.currentValue); });
	            changes.forEachChangedItem(function (record) { return _this._toggleClass(record.key, record.currentValue); });
	            changes.forEachRemovedItem(function (record) {
	                if (record.previousValue) {
	                    _this._toggleClass(record.key, false);
	                }
	            });
	        };
	        NgClass.prototype._applyIterableChanges = function (changes) {
	            var _this = this;
	            changes.forEachAddedItem(function (record) { return _this._toggleClass(record.item, true); });
	            changes.forEachRemovedItem(function (record) { return _this._toggleClass(record.item, false); });
	        };
	        NgClass.prototype._applyInitialClasses = function (isCleanup) {
	            var _this = this;
	            this._initialClasses.forEach(function (klass) { return _this._toggleClass(klass, !isCleanup); });
	        };
	        NgClass.prototype._applyClasses = function (rawClassVal, isCleanup) {
	            var _this = this;
	            if (rawClassVal) {
	                if (Array.isArray(rawClassVal) || rawClassVal instanceof Set) {
	                    rawClassVal.forEach(function (klass) { return _this._toggleClass(klass, !isCleanup); });
	                }
	                else {
	                    Object.keys(rawClassVal).forEach(function (klass) {
	                        if (isPresent(rawClassVal[klass]))
	                            _this._toggleClass(klass, !isCleanup);
	                    });
	                }
	            }
	        };
	        NgClass.prototype._toggleClass = function (klass, enabled) {
	            var _this = this;
	            klass = klass.trim();
	            if (klass) {
	                klass.split(/\s+/g).forEach(function (klass) { _this._renderer.setElementClass(_this._ngEl.nativeElement, klass, enabled); });
	            }
	        };
	        NgClass.decorators = [
	            { type: _angular_core.Directive, args: [{ selector: '[ngClass]' },] },
	        ];
	        /** @nocollapse */
	        NgClass.ctorParameters = [
	            { type: _angular_core.IterableDiffers, },
	            { type: _angular_core.KeyValueDiffers, },
	            { type: _angular_core.ElementRef, },
	            { type: _angular_core.Renderer, },
	        ];
	        NgClass.propDecorators = {
	            'klass': [{ type: _angular_core.Input, args: ['class',] },],
	            'ngClass': [{ type: _angular_core.Input },],
	        };
	        return NgClass;
	    }());

	    var NgForRow = (function () {
	        function NgForRow($implicit, index, count) {
	            this.$implicit = $implicit;
	            this.index = index;
	            this.count = count;
	        }
	        Object.defineProperty(NgForRow.prototype, "first", {
	            get: function () { return this.index === 0; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(NgForRow.prototype, "last", {
	            get: function () { return this.index === this.count - 1; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(NgForRow.prototype, "even", {
	            get: function () { return this.index % 2 === 0; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(NgForRow.prototype, "odd", {
	            get: function () { return !this.even; },
	            enumerable: true,
	            configurable: true
	        });
	        return NgForRow;
	    }());
	    /**
	     * The `NgFor` directive instantiates a template once per item from an iterable. The context for
	     * each instantiated template inherits from the outer context with the given loop variable set
	     * to the current item from the iterable.
	     *
	     * ### Local Variables
	     *
	     * `NgFor` provides several exported values that can be aliased to local variables:
	     *
	     * * `index` will be set to the current loop iteration for each template context.
	     * * `first` will be set to a boolean value indicating whether the item is the first one in the
	     *   iteration.
	     * * `last` will be set to a boolean value indicating whether the item is the last one in the
	     *   iteration.
	     * * `even` will be set to a boolean value indicating whether this item has an even index.
	     * * `odd` will be set to a boolean value indicating whether this item has an odd index.
	     *
	     * ### Change Propagation
	     *
	     * When the contents of the iterator changes, `NgFor` makes the corresponding changes to the DOM:
	     *
	     * * When an item is added, a new instance of the template is added to the DOM.
	     * * When an item is removed, its template instance is removed from the DOM.
	     * * When items are reordered, their respective templates are reordered in the DOM.
	     * * Otherwise, the DOM element for that item will remain the same.
	     *
	     * Angular uses object identity to track insertions and deletions within the iterator and reproduce
	     * those changes in the DOM. This has important implications for animations and any stateful
	     * controls
	     * (such as `<input>` elements which accept user input) that are present. Inserted rows can be
	     * animated in, deleted rows can be animated out, and unchanged rows retain any unsaved state such
	     * as user input.
	     *
	     * It is possible for the identities of elements in the iterator to change while the data does not.
	     * This can happen, for example, if the iterator produced from an RPC to the server, and that
	     * RPC is re-run. Even if the data hasn't changed, the second response will produce objects with
	     * different identities, and Angular will tear down the entire DOM and rebuild it (as if all old
	     * elements were deleted and all new elements inserted). This is an expensive operation and should
	     * be avoided if possible.
	     *
	     * To customize the default tracking algorithm, `NgFor` supports `trackBy` option.
	     * `trackBy` takes a function which has two arguments: `index` and `item`.
	     * If `trackBy` is given, Angular tracks changes by the return value of the function.
	     *
	     * ### Syntax
	     *
	     * - `<li *ngFor="let item of items; let i = index; trackBy: trackByFn">...</li>`
	     * - `<li template="ngFor let item of items; let i = index; trackBy: trackByFn">...</li>`
	     *
	     * With `<template>` element:
	     *
	     * ```
	     * <template ngFor let-item [ngForOf]="items" let-i="index" [ngForTrackBy]="trackByFn">
	     *   <li>...</li>
	     * </template>
	     * ```
	     *
	     * ### Example
	     *
	     * See a [live demo](http://plnkr.co/edit/KVuXxDp0qinGDyo307QW?p=preview) for a more detailed
	     * example.
	     *
	     * @stable
	     */
	    var NgFor = (function () {
	        function NgFor(_viewContainer, _template, _differs, _cdr) {
	            this._viewContainer = _viewContainer;
	            this._template = _template;
	            this._differs = _differs;
	            this._cdr = _cdr;
	            this._differ = null;
	        }
	        Object.defineProperty(NgFor.prototype, "ngForTemplate", {
	            set: function (value) {
	                if (value) {
	                    this._template = value;
	                }
	            },
	            enumerable: true,
	            configurable: true
	        });
	        NgFor.prototype.ngOnChanges = function (changes) {
	            if ('ngForOf' in changes) {
	                // React on ngForOf changes only once all inputs have been initialized
	                var value = changes['ngForOf'].currentValue;
	                if (!this._differ && value) {
	                    try {
	                        this._differ = this._differs.find(value).create(this._cdr, this.ngForTrackBy);
	                    }
	                    catch (e) {
	                        throw new Error("Cannot find a differ supporting object '" + value + "' of type '" + getTypeNameForDebugging(value) + "'. NgFor only supports binding to Iterables such as Arrays.");
	                    }
	                }
	            }
	        };
	        NgFor.prototype.ngDoCheck = function () {
	            if (this._differ) {
	                var changes = this._differ.diff(this.ngForOf);
	                if (changes)
	                    this._applyChanges(changes);
	            }
	        };
	        NgFor.prototype._applyChanges = function (changes) {
	            var _this = this;
	            var insertTuples = [];
	            changes.forEachOperation(function (item, adjustedPreviousIndex, currentIndex) {
	                if (item.previousIndex == null) {
	                    var view = _this._viewContainer.createEmbeddedView(_this._template, new NgForRow(null, null, null), currentIndex);
	                    var tuple = new RecordViewTuple(item, view);
	                    insertTuples.push(tuple);
	                }
	                else if (currentIndex == null) {
	                    _this._viewContainer.remove(adjustedPreviousIndex);
	                }
	                else {
	                    var view = _this._viewContainer.get(adjustedPreviousIndex);
	                    _this._viewContainer.move(view, currentIndex);
	                    var tuple = new RecordViewTuple(item, view);
	                    insertTuples.push(tuple);
	                }
	            });
	            for (var i = 0; i < insertTuples.length; i++) {
	                this._perViewChange(insertTuples[i].view, insertTuples[i].record);
	            }
	            for (var i = 0, ilen = this._viewContainer.length; i < ilen; i++) {
	                var viewRef = this._viewContainer.get(i);
	                viewRef.context.index = i;
	                viewRef.context.count = ilen;
	            }
	            changes.forEachIdentityChange(function (record) {
	                var viewRef = _this._viewContainer.get(record.currentIndex);
	                viewRef.context.$implicit = record.item;
	            });
	        };
	        NgFor.prototype._perViewChange = function (view, record) {
	            view.context.$implicit = record.item;
	        };
	        NgFor.decorators = [
	            { type: _angular_core.Directive, args: [{ selector: '[ngFor][ngForOf]' },] },
	        ];
	        /** @nocollapse */
	        NgFor.ctorParameters = [
	            { type: _angular_core.ViewContainerRef, },
	            { type: _angular_core.TemplateRef, },
	            { type: _angular_core.IterableDiffers, },
	            { type: _angular_core.ChangeDetectorRef, },
	        ];
	        NgFor.propDecorators = {
	            'ngForOf': [{ type: _angular_core.Input },],
	            'ngForTrackBy': [{ type: _angular_core.Input },],
	            'ngForTemplate': [{ type: _angular_core.Input },],
	        };
	        return NgFor;
	    }());
	    var RecordViewTuple = (function () {
	        function RecordViewTuple(record, view) {
	            this.record = record;
	            this.view = view;
	        }
	        return RecordViewTuple;
	    }());

	    /**
	     * Removes or recreates a portion of the DOM tree based on an {expression}.
	     *
	     * If the expression assigned to `ngIf` evaluates to a falsy value then the element
	     * is removed from the DOM, otherwise a clone of the element is reinserted into the DOM.
	     *
	     * ### Example ([live demo](http://plnkr.co/edit/fe0kgemFBtmQOY31b4tw?p=preview)):
	     *
	     * ```
	     * <div *ngIf="errorCount > 0" class="error">
	     *   <!-- Error message displayed when the errorCount property in the current context is greater
	     * than 0. -->
	     *   {{errorCount}} errors detected
	     * </div>
	     * ```
	     *
	     * ### Syntax
	     *
	     * - `<div *ngIf="condition">...</div>`
	     * - `<div template="ngIf condition">...</div>`
	     * - `<template [ngIf]="condition"><div>...</div></template>`
	     *
	     * @stable
	     */
	    var NgIf = (function () {
	        function NgIf(_viewContainer, _template) {
	            this._viewContainer = _viewContainer;
	            this._template = _template;
	            this._hasView = false;
	        }
	        Object.defineProperty(NgIf.prototype, "ngIf", {
	            set: function (condition) {
	                if (condition && !this._hasView) {
	                    this._hasView = true;
	                    this._viewContainer.createEmbeddedView(this._template);
	                }
	                else if (!condition && this._hasView) {
	                    this._hasView = false;
	                    this._viewContainer.clear();
	                }
	            },
	            enumerable: true,
	            configurable: true
	        });
	        NgIf.decorators = [
	            { type: _angular_core.Directive, args: [{ selector: '[ngIf]' },] },
	        ];
	        /** @nocollapse */
	        NgIf.ctorParameters = [
	            { type: _angular_core.ViewContainerRef, },
	            { type: _angular_core.TemplateRef, },
	        ];
	        NgIf.propDecorators = {
	            'ngIf': [{ type: _angular_core.Input },],
	        };
	        return NgIf;
	    }());

	    var _CASE_DEFAULT = {};
	    var SwitchView = (function () {
	        function SwitchView(_viewContainerRef, _templateRef) {
	            this._viewContainerRef = _viewContainerRef;
	            this._templateRef = _templateRef;
	        }
	        SwitchView.prototype.create = function () { this._viewContainerRef.createEmbeddedView(this._templateRef); };
	        SwitchView.prototype.destroy = function () { this._viewContainerRef.clear(); };
	        return SwitchView;
	    }());
	    /**
	     * @ngModule CommonModule
	     *
	     * @whatItDoes Adds / removes DOM sub-trees when the nest match expressions matches the switch
	     *             expression.
	     *
	     * @howToUse
	     * ```
	     *     <container-element [ngSwitch]="switch_expression">
	     *       <some-element *ngSwitchCase="match_expression_1">...</some-element>
	     *       <some-element *ngSwitchCase="match_expression_2">...</some-element>
	     *       <some-other-element *ngSwitchCase="match_expression_3">...</some-other-element>
	     *       <ng-container *ngSwitchCase="match_expression_3">
	     *         <!-- use a ng-container to group multiple root nodes -->
	     *         <inner-element></inner-element>
	     *         <inner-other-element></inner-other-element>
	     *       </ng-container>
	     *       <some-element *ngSwitchDefault>...</some-element>
	     *     </container-element>
	     * ```
	     * @description
	     *
	     * `NgSwitch` stamps out nested views when their match expression value matches the value of the
	     * switch expression.
	     *
	     * In other words:
	     * - you define a container element (where you place the directive with a switch expression on the
	     * `[ngSwitch]="..."` attribute)
	     * - you define inner views inside the `NgSwitch` and place a `*ngSwitchCase` attribute on the view
	     * root elements.
	     *
	     * Elements within `NgSwitch` but outside of a `NgSwitchCase` or `NgSwitchDefault` directives will
	     * be preserved at the location.
	     *
	     * The `ngSwitchCase` directive informs the parent `NgSwitch` of which view to display when the
	     * expression is evaluated.
	     * When no matching expression is found on a `ngSwitchCase` view, the `ngSwitchDefault` view is
	     * stamped out.
	     *
	     * @stable
	     */
	    var NgSwitch = (function () {
	        function NgSwitch() {
	            this._useDefault = false;
	            this._valueViews = new Map();
	            this._activeViews = [];
	        }
	        Object.defineProperty(NgSwitch.prototype, "ngSwitch", {
	            set: function (value) {
	                // Set of views to display for this value
	                var views = this._valueViews.get(value);
	                if (views) {
	                    this._useDefault = false;
	                }
	                else {
	                    // No view to display for the current value -> default case
	                    // Nothing to do if the default case was already active
	                    if (this._useDefault) {
	                        return;
	                    }
	                    this._useDefault = true;
	                    views = this._valueViews.get(_CASE_DEFAULT);
	                }
	                this._emptyAllActiveViews();
	                this._activateViews(views);
	                this._switchValue = value;
	            },
	            enumerable: true,
	            configurable: true
	        });
	        /** @internal */
	        NgSwitch.prototype._onCaseValueChanged = function (oldCase, newCase, view) {
	            this._deregisterView(oldCase, view);
	            this._registerView(newCase, view);
	            if (oldCase === this._switchValue) {
	                view.destroy();
	                ListWrapper.remove(this._activeViews, view);
	            }
	            else if (newCase === this._switchValue) {
	                if (this._useDefault) {
	                    this._useDefault = false;
	                    this._emptyAllActiveViews();
	                }
	                view.create();
	                this._activeViews.push(view);
	            }
	            // Switch to default when there is no more active ViewContainers
	            if (this._activeViews.length === 0 && !this._useDefault) {
	                this._useDefault = true;
	                this._activateViews(this._valueViews.get(_CASE_DEFAULT));
	            }
	        };
	        NgSwitch.prototype._emptyAllActiveViews = function () {
	            var activeContainers = this._activeViews;
	            for (var i = 0; i < activeContainers.length; i++) {
	                activeContainers[i].destroy();
	            }
	            this._activeViews = [];
	        };
	        NgSwitch.prototype._activateViews = function (views) {
	            if (views) {
	                for (var i = 0; i < views.length; i++) {
	                    views[i].create();
	                }
	                this._activeViews = views;
	            }
	        };
	        /** @internal */
	        NgSwitch.prototype._registerView = function (value, view) {
	            var views = this._valueViews.get(value);
	            if (!views) {
	                views = [];
	                this._valueViews.set(value, views);
	            }
	            views.push(view);
	        };
	        NgSwitch.prototype._deregisterView = function (value, view) {
	            // `_CASE_DEFAULT` is used a marker for non-registered cases
	            if (value === _CASE_DEFAULT)
	                return;
	            var views = this._valueViews.get(value);
	            if (views.length == 1) {
	                this._valueViews.delete(value);
	            }
	            else {
	                ListWrapper.remove(views, view);
	            }
	        };
	        NgSwitch.decorators = [
	            { type: _angular_core.Directive, args: [{ selector: '[ngSwitch]' },] },
	        ];
	        /** @nocollapse */
	        NgSwitch.ctorParameters = [];
	        NgSwitch.propDecorators = {
	            'ngSwitch': [{ type: _angular_core.Input },],
	        };
	        return NgSwitch;
	    }());
	    /**
	     * @ngModule CommonModule
	     *
	     * @whatItDoes Creates a view that will be added/removed from the parent {@link NgSwitch} when the
	     *             given expression evaluate to respectively the same/different value as the switch
	     *             expression.
	     *
	     * @howToUse
	     * ```
	     * <container-element [ngSwitch]="switch_expression">
	     *   <some-element *ngSwitchCase="match_expression_1">...</some-element>
	     * </container-element>
	     *```
	     * @description
	     *
	     * Insert the sub-tree when the expression evaluates to the same value as the enclosing switch
	     * expression.
	     *
	     * If multiple match expressions match the switch expression value, all of them are displayed.
	     *
	     * See {@link NgSwitch} for more details and example.
	     *
	     * @stable
	     */
	    var NgSwitchCase = (function () {
	        function NgSwitchCase(viewContainer, templateRef, ngSwitch) {
	            // `_CASE_DEFAULT` is used as a marker for a not yet initialized value
	            this._value = _CASE_DEFAULT;
	            this._switch = ngSwitch;
	            this._view = new SwitchView(viewContainer, templateRef);
	        }
	        Object.defineProperty(NgSwitchCase.prototype, "ngSwitchCase", {
	            set: function (value) {
	                this._switch._onCaseValueChanged(this._value, value, this._view);
	                this._value = value;
	            },
	            enumerable: true,
	            configurable: true
	        });
	        NgSwitchCase.decorators = [
	            { type: _angular_core.Directive, args: [{ selector: '[ngSwitchCase]' },] },
	        ];
	        /** @nocollapse */
	        NgSwitchCase.ctorParameters = [
	            { type: _angular_core.ViewContainerRef, },
	            { type: _angular_core.TemplateRef, },
	            { type: NgSwitch, decorators: [{ type: _angular_core.Host },] },
	        ];
	        NgSwitchCase.propDecorators = {
	            'ngSwitchCase': [{ type: _angular_core.Input },],
	        };
	        return NgSwitchCase;
	    }());
	    /**
	     * @ngModule CommonModule
	     * @whatItDoes Creates a view that is added to the parent {@link NgSwitch} when no case expressions
	     * match the
	     *             switch expression.
	     *
	     * @howToUse
	     * ```
	     * <container-element [ngSwitch]="switch_expression">
	     *   <some-element *ngSwitchCase="match_expression_1">...</some-element>
	     *   <some-other-element *ngSwitchDefault>...</some-other-element>
	     * </container-element>
	     * ```
	     *
	     * @description
	     *
	     * Insert the sub-tree when no case expressions evaluate to the same value as the enclosing switch
	     * expression.
	     *
	     * See {@link NgSwitch} for more details and example.
	     *
	     * @stable
	     */
	    var NgSwitchDefault = (function () {
	        function NgSwitchDefault(viewContainer, templateRef, sswitch) {
	            sswitch._registerView(_CASE_DEFAULT, new SwitchView(viewContainer, templateRef));
	        }
	        NgSwitchDefault.decorators = [
	            { type: _angular_core.Directive, args: [{ selector: '[ngSwitchDefault]' },] },
	        ];
	        /** @nocollapse */
	        NgSwitchDefault.ctorParameters = [
	            { type: _angular_core.ViewContainerRef, },
	            { type: _angular_core.TemplateRef, },
	            { type: NgSwitch, decorators: [{ type: _angular_core.Host },] },
	        ];
	        return NgSwitchDefault;
	    }());

	    /**
	     * @ngModule CommonModule
	     *
	     * @whatItDoes Adds / removes DOM sub-trees based on a numeric value. Tailored for pluralization.
	     *
	     * @howToUse
	     * ```
	     * <some-element [ngPlural]="value">
	     *   <ng-container *ngPluralCase="'=0'">there is nothing</ng-container>
	     *   <ng-container *ngPluralCase="'=1'">there is one</ng-container>
	     *   <ng-container *ngPluralCase="'few'">there are a few</ng-container>
	     *   <ng-container *ngPluralCase="'other'">there are exactly #</ng-container>
	     * </some-element>
	     * ```
	     *
	     * @description
	     *
	     * Displays DOM sub-trees that match the switch expression value, or failing that, DOM sub-trees
	     * that match the switch expression's pluralization category.
	     *
	     * To use this directive you must provide a container element that sets the `[ngPlural]` attribute
	     * to a switch expression. Inner elements with a `[ngPluralCase]` will display based on their
	     * expression:
	     * - if `[ngPluralCase]` is set to a value starting with `=`, it will only display if the value
	     *   matches the switch expression exactly,
	     * - otherwise, the view will be treated as a "category match", and will only display if exact
	     *   value matches aren't found and the value maps to its category for the defined locale.
	     *
	     * See http://cldr.unicode.org/index/cldr-spec/plural-rules
	     *
	     * @experimental
	     */
	    var NgPlural = (function () {
	        function NgPlural(_localization) {
	            this._localization = _localization;
	            this._caseViews = {};
	        }
	        Object.defineProperty(NgPlural.prototype, "ngPlural", {
	            set: function (value) {
	                this._switchValue = value;
	                this._updateView();
	            },
	            enumerable: true,
	            configurable: true
	        });
	        NgPlural.prototype.addCase = function (value, switchView) { this._caseViews[value] = switchView; };
	        NgPlural.prototype._updateView = function () {
	            this._clearViews();
	            var cases = Object.keys(this._caseViews);
	            var key = getPluralCategory(this._switchValue, cases, this._localization);
	            this._activateView(this._caseViews[key]);
	        };
	        NgPlural.prototype._clearViews = function () {
	            if (this._activeView)
	                this._activeView.destroy();
	        };
	        NgPlural.prototype._activateView = function (view) {
	            if (view) {
	                this._activeView = view;
	                this._activeView.create();
	            }
	        };
	        NgPlural.decorators = [
	            { type: _angular_core.Directive, args: [{ selector: '[ngPlural]' },] },
	        ];
	        /** @nocollapse */
	        NgPlural.ctorParameters = [
	            { type: NgLocalization, },
	        ];
	        NgPlural.propDecorators = {
	            'ngPlural': [{ type: _angular_core.Input },],
	        };
	        return NgPlural;
	    }());
	    /**
	     * @ngModule CommonModule
	     *
	     * @whatItDoes Creates a view that will be added/removed from the parent {@link NgPlural} when the
	     *             given expression matches the plural expression according to CLDR rules.
	     *
	     * @howToUse
	     * ```
	     * <some-element [ngPlural]="value">
	     *   <ng-container *ngPluralCase="'=0'">...</ng-container>
	     *   <ng-container *ngPluralCase="'other'">...</ng-container>
	     * </some-element>
	     *```
	     *
	     * See {@link NgPlural} for more details and example.
	     *
	     * @experimental
	     */
	    var NgPluralCase = (function () {
	        function NgPluralCase(value, template, viewContainer, ngPlural) {
	            this.value = value;
	            ngPlural.addCase(value, new SwitchView(viewContainer, template));
	        }
	        NgPluralCase.decorators = [
	            { type: _angular_core.Directive, args: [{ selector: '[ngPluralCase]' },] },
	        ];
	        /** @nocollapse */
	        NgPluralCase.ctorParameters = [
	            { type: undefined, decorators: [{ type: _angular_core.Attribute, args: ['ngPluralCase',] },] },
	            { type: _angular_core.TemplateRef, },
	            { type: _angular_core.ViewContainerRef, },
	            { type: NgPlural, decorators: [{ type: _angular_core.Host },] },
	        ];
	        return NgPluralCase;
	    }());

	    /**
	     * @ngModule CommonModule
	     *
	     * @whatItDoes Update an HTML element styles.
	     *
	     * @howToUse
	     * ```
	     * <some-element [ngStyle]="{'font-style': styleExp}">...</some-element>
	     *
	     * <some-element [ngStyle]="{'max-width.px': widthExp}">...</some-element>
	     *
	     * <some-element [ngStyle]="objExp">...</some-element>
	     * ```
	     *
	     * @description
	     *
	     * The styles are updated according to the value of the expression evaluation:
	     * - keys are style names with an option `.<unit>` suffix (ie 'top.px', 'font-style.em'),
	     * - values are the values assigned to those properties (expressed in the given unit).
	     *
	     * @stable
	     */
	    var NgStyle = (function () {
	        function NgStyle(_differs, _ngEl, _renderer) {
	            this._differs = _differs;
	            this._ngEl = _ngEl;
	            this._renderer = _renderer;
	        }
	        Object.defineProperty(NgStyle.prototype, "ngStyle", {
	            set: function (v) {
	                this._ngStyle = v;
	                if (!this._differ && v) {
	                    this._differ = this._differs.find(v).create(null);
	                }
	            },
	            enumerable: true,
	            configurable: true
	        });
	        NgStyle.prototype.ngDoCheck = function () {
	            if (this._differ) {
	                var changes = this._differ.diff(this._ngStyle);
	                if (changes) {
	                    this._applyChanges(changes);
	                }
	            }
	        };
	        NgStyle.prototype._applyChanges = function (changes) {
	            var _this = this;
	            changes.forEachRemovedItem(function (record) { return _this._setStyle(record.key, null); });
	            changes.forEachAddedItem(function (record) { return _this._setStyle(record.key, record.currentValue); });
	            changes.forEachChangedItem(function (record) { return _this._setStyle(record.key, record.currentValue); });
	        };
	        NgStyle.prototype._setStyle = function (nameAndUnit, value) {
	            var _a = nameAndUnit.split('.'), name = _a[0], unit = _a[1];
	            value = value && unit ? "" + value + unit : value;
	            this._renderer.setElementStyle(this._ngEl.nativeElement, name, value);
	        };
	        NgStyle.decorators = [
	            { type: _angular_core.Directive, args: [{ selector: '[ngStyle]' },] },
	        ];
	        /** @nocollapse */
	        NgStyle.ctorParameters = [
	            { type: _angular_core.KeyValueDiffers, },
	            { type: _angular_core.ElementRef, },
	            { type: _angular_core.Renderer, },
	        ];
	        NgStyle.propDecorators = {
	            'ngStyle': [{ type: _angular_core.Input },],
	        };
	        return NgStyle;
	    }());

	    /**
	     * @ngModule CommonModule
	     *
	     * @whatItDoes Inserts an embedded view from a prepared `TemplateRef`
	     *
	     * @howToUse
	     * ```
	     * <template [ngTemplateOutlet]="templateRefExpression"
	     *           [ngOutletContext]="objectExpression">
	     * </template>
	     * ```
	     *
	     * @description
	     *
	     * You can attach a context object to the `EmbeddedViewRef` by setting `[ngOutletContext]`.
	     * `[ngOutletContext]` should be an object, the object's keys will be the local template variables
	     * available within the `TemplateRef`.
	     *
	     * Note: using the key `$implicit` in the context object will set it's value as default.
	     *
	     * @experimental
	     */
	    var NgTemplateOutlet = (function () {
	        function NgTemplateOutlet(_viewContainerRef) {
	            this._viewContainerRef = _viewContainerRef;
	        }
	        Object.defineProperty(NgTemplateOutlet.prototype, "ngOutletContext", {
	            set: function (context) { this._context = context; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(NgTemplateOutlet.prototype, "ngTemplateOutlet", {
	            set: function (templateRef) { this._templateRef = templateRef; },
	            enumerable: true,
	            configurable: true
	        });
	        NgTemplateOutlet.prototype.ngOnChanges = function (changes) {
	            if (this._viewRef) {
	                this._viewContainerRef.remove(this._viewContainerRef.indexOf(this._viewRef));
	            }
	            if (this._templateRef) {
	                this._viewRef = this._viewContainerRef.createEmbeddedView(this._templateRef, this._context);
	            }
	        };
	        NgTemplateOutlet.decorators = [
	            { type: _angular_core.Directive, args: [{ selector: '[ngTemplateOutlet]' },] },
	        ];
	        /** @nocollapse */
	        NgTemplateOutlet.ctorParameters = [
	            { type: _angular_core.ViewContainerRef, },
	        ];
	        NgTemplateOutlet.propDecorators = {
	            'ngOutletContext': [{ type: _angular_core.Input },],
	            'ngTemplateOutlet': [{ type: _angular_core.Input },],
	        };
	        return NgTemplateOutlet;
	    }());

	    /**
	     * A collection of Angular directives that are likely to be used in each and every Angular
	     * application.
	     */
	    var COMMON_DIRECTIVES = [
	        NgClass,
	        NgFor,
	        NgIf,
	        NgTemplateOutlet,
	        NgStyle,
	        NgSwitch,
	        NgSwitchCase,
	        NgSwitchDefault,
	        NgPlural,
	        NgPluralCase,
	    ];

	    var isPromise = _angular_core.__core_private__.isPromise;

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$4 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    /**
	     * @stable
	     */
	    var BaseError = (function (_super) {
	        __extends$4(BaseError, _super);
	        function BaseError(message) {
	            // Errors don't use current this, instead they create a new instance.
	            // We have to do forward all of our api to the nativeInstance.
	            var nativeError = _super.call(this, message);
	            this._nativeError = nativeError;
	        }
	        Object.defineProperty(BaseError.prototype, "message", {
	            get: function () { return this._nativeError.message; },
	            set: function (message) { this._nativeError.message = message; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(BaseError.prototype, "name", {
	            get: function () { return this._nativeError.name; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(BaseError.prototype, "stack", {
	            get: function () { return this._nativeError.stack; },
	            set: function (value) { this._nativeError.stack = value; },
	            enumerable: true,
	            configurable: true
	        });
	        BaseError.prototype.toString = function () { return this._nativeError.toString(); };
	        return BaseError;
	    }(Error));
	    /**
	     * @stable
	     */
	    var WrappedError = (function (_super) {
	        __extends$4(WrappedError, _super);
	        function WrappedError(message, error) {
	            _super.call(this, message + " caused by: " + (error instanceof Error ? error.message : error));
	            this.originalError = error;
	        }
	        Object.defineProperty(WrappedError.prototype, "stack", {
	            get: function () {
	                return (this.originalError instanceof Error ? this.originalError : this._nativeError)
	                    .stack;
	            },
	            enumerable: true,
	            configurable: true
	        });
	        return WrappedError;
	    }(BaseError));

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$3 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    var InvalidPipeArgumentError = (function (_super) {
	        __extends$3(InvalidPipeArgumentError, _super);
	        function InvalidPipeArgumentError(type, value) {
	            _super.call(this, "Invalid argument '" + value + "' for pipe '" + stringify(type) + "'");
	        }
	        return InvalidPipeArgumentError;
	    }(BaseError));

	    var ObservableStrategy = (function () {
	        function ObservableStrategy() {
	        }
	        ObservableStrategy.prototype.createSubscription = function (async, updateLatestValue) {
	            return async.subscribe({ next: updateLatestValue, error: function (e) { throw e; } });
	        };
	        ObservableStrategy.prototype.dispose = function (subscription) { subscription.unsubscribe(); };
	        ObservableStrategy.prototype.onDestroy = function (subscription) { subscription.unsubscribe(); };
	        return ObservableStrategy;
	    }());
	    var PromiseStrategy = (function () {
	        function PromiseStrategy() {
	        }
	        PromiseStrategy.prototype.createSubscription = function (async, updateLatestValue) {
	            return async.then(updateLatestValue, function (e) { throw e; });
	        };
	        PromiseStrategy.prototype.dispose = function (subscription) { };
	        PromiseStrategy.prototype.onDestroy = function (subscription) { };
	        return PromiseStrategy;
	    }());
	    var _promiseStrategy = new PromiseStrategy();
	    var _observableStrategy = new ObservableStrategy();
	    /**
	     * @ngModule CommonModule
	     * @whatItDoes Unwraps a value from an asynchronous primitive.
	     * @howToUse `observable_or_promise_expression | async`
	     * @description
	     * The `async` pipe subscribes to an `Observable` or `Promise` and returns the latest value it has
	     * emitted. When a new value is emitted, the `async` pipe marks the component to be checked for
	     * changes. When the component gets destroyed, the `async` pipe unsubscribes automatically to avoid
	     * potential memory leaks.
	     *
	     *
	     * ## Examples
	     *
	     * This example binds a `Promise` to the view. Clicking the `Resolve` button resolves the
	     * promise.
	     *
	     * {@example common/pipes/ts/async_pipe.ts region='AsyncPipePromise'}
	     *
	     * It's also possible to use `async` with Observables. The example below binds the `time` Observable
	     * to the view. The Observable continuesly updates the view with the current time.
	     *
	     * {@example common/pipes/ts/async_pipe.ts region='AsyncPipeObservable'}
	     *
	     * @stable
	     */
	    var AsyncPipe = (function () {
	        function AsyncPipe(_ref) {
	            this._ref = _ref;
	            this._latestValue = null;
	            this._latestReturnedValue = null;
	            this._subscription = null;
	            this._obj = null;
	            this._strategy = null;
	        }
	        AsyncPipe.prototype.ngOnDestroy = function () {
	            if (this._subscription) {
	                this._dispose();
	            }
	        };
	        AsyncPipe.prototype.transform = function (obj) {
	            if (!this._obj) {
	                if (obj) {
	                    this._subscribe(obj);
	                }
	                this._latestReturnedValue = this._latestValue;
	                return this._latestValue;
	            }
	            if (obj !== this._obj) {
	                this._dispose();
	                return this.transform(obj);
	            }
	            if (this._latestValue === this._latestReturnedValue) {
	                return this._latestReturnedValue;
	            }
	            this._latestReturnedValue = this._latestValue;
	            return _angular_core.WrappedValue.wrap(this._latestValue);
	        };
	        AsyncPipe.prototype._subscribe = function (obj) {
	            var _this = this;
	            this._obj = obj;
	            this._strategy = this._selectStrategy(obj);
	            this._subscription = this._strategy.createSubscription(obj, function (value) { return _this._updateLatestValue(obj, value); });
	        };
	        AsyncPipe.prototype._selectStrategy = function (obj) {
	            if (isPromise(obj)) {
	                return _promiseStrategy;
	            }
	            if (obj.subscribe) {
	                return _observableStrategy;
	            }
	            throw new InvalidPipeArgumentError(AsyncPipe, obj);
	        };
	        AsyncPipe.prototype._dispose = function () {
	            this._strategy.dispose(this._subscription);
	            this._latestValue = null;
	            this._latestReturnedValue = null;
	            this._subscription = null;
	            this._obj = null;
	        };
	        AsyncPipe.prototype._updateLatestValue = function (async, value) {
	            if (async === this._obj) {
	                this._latestValue = value;
	                this._ref.markForCheck();
	            }
	        };
	        AsyncPipe.decorators = [
	            { type: _angular_core.Pipe, args: [{ name: 'async', pure: false },] },
	        ];
	        /** @nocollapse */
	        AsyncPipe.ctorParameters = [
	            { type: _angular_core.ChangeDetectorRef, },
	        ];
	        return AsyncPipe;
	    }());

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var NumberFormatStyle;
	    (function (NumberFormatStyle) {
	        NumberFormatStyle[NumberFormatStyle["Decimal"] = 0] = "Decimal";
	        NumberFormatStyle[NumberFormatStyle["Percent"] = 1] = "Percent";
	        NumberFormatStyle[NumberFormatStyle["Currency"] = 2] = "Currency";
	    })(NumberFormatStyle || (NumberFormatStyle = {}));
	    var NumberFormatter = (function () {
	        function NumberFormatter() {
	        }
	        NumberFormatter.format = function (num, locale, style, _a) {
	            var _b = _a === void 0 ? {} : _a, minimumIntegerDigits = _b.minimumIntegerDigits, minimumFractionDigits = _b.minimumFractionDigits, maximumFractionDigits = _b.maximumFractionDigits, currency = _b.currency, _c = _b.currencyAsSymbol, currencyAsSymbol = _c === void 0 ? false : _c;
	            var options = {
	                minimumIntegerDigits: minimumIntegerDigits,
	                minimumFractionDigits: minimumFractionDigits,
	                maximumFractionDigits: maximumFractionDigits,
	                style: NumberFormatStyle[style].toLowerCase()
	            };
	            if (style == NumberFormatStyle.Currency) {
	                options.currency = currency;
	                options.currencyDisplay = currencyAsSymbol ? 'symbol' : 'code';
	            }
	            return new Intl.NumberFormat(locale, options).format(num);
	        };
	        return NumberFormatter;
	    }());
	    var DATE_FORMATS_SPLIT = /((?:[^yMLdHhmsazZEwGjJ']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|L+|d+|H+|h+|J+|j+|m+|s+|a|z|Z|G+|w+))(.*)/;
	    var PATTERN_ALIASES = {
	        yMMMdjms: datePartGetterFactory(combine([
	            digitCondition('year', 1),
	            nameCondition('month', 3),
	            digitCondition('day', 1),
	            digitCondition('hour', 1),
	            digitCondition('minute', 1),
	            digitCondition('second', 1),
	        ])),
	        yMdjm: datePartGetterFactory(combine([
	            digitCondition('year', 1), digitCondition('month', 1), digitCondition('day', 1),
	            digitCondition('hour', 1), digitCondition('minute', 1)
	        ])),
	        yMMMMEEEEd: datePartGetterFactory(combine([
	            digitCondition('year', 1), nameCondition('month', 4), nameCondition('weekday', 4),
	            digitCondition('day', 1)
	        ])),
	        yMMMMd: datePartGetterFactory(combine([digitCondition('year', 1), nameCondition('month', 4), digitCondition('day', 1)])),
	        yMMMd: datePartGetterFactory(combine([digitCondition('year', 1), nameCondition('month', 3), digitCondition('day', 1)])),
	        yMd: datePartGetterFactory(combine([digitCondition('year', 1), digitCondition('month', 1), digitCondition('day', 1)])),
	        jms: datePartGetterFactory(combine([digitCondition('hour', 1), digitCondition('second', 1), digitCondition('minute', 1)])),
	        jm: datePartGetterFactory(combine([digitCondition('hour', 1), digitCondition('minute', 1)]))
	    };
	    var DATE_FORMATS = {
	        yyyy: datePartGetterFactory(digitCondition('year', 4)),
	        yy: datePartGetterFactory(digitCondition('year', 2)),
	        y: datePartGetterFactory(digitCondition('year', 1)),
	        MMMM: datePartGetterFactory(nameCondition('month', 4)),
	        MMM: datePartGetterFactory(nameCondition('month', 3)),
	        MM: datePartGetterFactory(digitCondition('month', 2)),
	        M: datePartGetterFactory(digitCondition('month', 1)),
	        LLLL: datePartGetterFactory(nameCondition('month', 4)),
	        dd: datePartGetterFactory(digitCondition('day', 2)),
	        d: datePartGetterFactory(digitCondition('day', 1)),
	        HH: digitModifier(hourExtracter(datePartGetterFactory(hour12Modify(digitCondition('hour', 2), false)))),
	        H: hourExtracter(datePartGetterFactory(hour12Modify(digitCondition('hour', 1), false))),
	        hh: digitModifier(hourExtracter(datePartGetterFactory(hour12Modify(digitCondition('hour', 2), true)))),
	        h: hourExtracter(datePartGetterFactory(hour12Modify(digitCondition('hour', 1), true))),
	        jj: datePartGetterFactory(digitCondition('hour', 2)),
	        j: datePartGetterFactory(digitCondition('hour', 1)),
	        mm: digitModifier(datePartGetterFactory(digitCondition('minute', 2))),
	        m: datePartGetterFactory(digitCondition('minute', 1)),
	        ss: digitModifier(datePartGetterFactory(digitCondition('second', 2))),
	        s: datePartGetterFactory(digitCondition('second', 1)),
	        // while ISO 8601 requires fractions to be prefixed with `.` or `,`
	        // we can be just safely rely on using `sss` since we currently don't support single or two digit
	        // fractions
	        sss: datePartGetterFactory(digitCondition('second', 3)),
	        EEEE: datePartGetterFactory(nameCondition('weekday', 4)),
	        EEE: datePartGetterFactory(nameCondition('weekday', 3)),
	        EE: datePartGetterFactory(nameCondition('weekday', 2)),
	        E: datePartGetterFactory(nameCondition('weekday', 1)),
	        a: hourClockExtracter(datePartGetterFactory(hour12Modify(digitCondition('hour', 1), true))),
	        Z: timeZoneGetter('short'),
	        z: timeZoneGetter('long'),
	        ww: datePartGetterFactory({}),
	        // first Thursday of the year. not support ?
	        w: datePartGetterFactory({}),
	        // of the year not support ?
	        G: datePartGetterFactory(nameCondition('era', 1)),
	        GG: datePartGetterFactory(nameCondition('era', 2)),
	        GGG: datePartGetterFactory(nameCondition('era', 3)),
	        GGGG: datePartGetterFactory(nameCondition('era', 4))
	    };
	    function digitModifier(inner) {
	        return function (date, locale) {
	            var result = inner(date, locale);
	            return result.length == 1 ? '0' + result : result;
	        };
	    }
	    function hourClockExtracter(inner) {
	        return function (date, locale) {
	            var result = inner(date, locale);
	            return result.split(' ')[1];
	        };
	    }
	    function hourExtracter(inner) {
	        return function (date, locale) {
	            var result = inner(date, locale);
	            return result.split(' ')[0];
	        };
	    }
	    function intlDateFormat(date, locale, options) {
	        return new Intl.DateTimeFormat(locale, options).format(date).replace(/[\u200e\u200f]/g, '');
	    }
	    function timeZoneGetter(timezone) {
	        // To workaround `Intl` API restriction for single timezone let format with 24 hours
	        var options = { hour: '2-digit', hour12: false, timeZoneName: timezone };
	        return function (date, locale) {
	            var result = intlDateFormat(date, locale, options);
	            // Then extract first 3 letters that related to hours
	            return result ? result.substring(3) : '';
	        };
	    }
	    function hour12Modify(options, value) {
	        options.hour12 = value;
	        return options;
	    }
	    function digitCondition(prop, len) {
	        var result = {};
	        result[prop] = len == 2 ? '2-digit' : 'numeric';
	        return result;
	    }
	    function nameCondition(prop, len) {
	        var result = {};
	        result[prop] = len < 4 ? 'short' : 'long';
	        return result;
	    }
	    function combine(options) {
	        var result = {};
	        options.forEach(function (option) { Object.assign(result, option); });
	        return result;
	    }
	    function datePartGetterFactory(ret) {
	        return function (date, locale) { return intlDateFormat(date, locale, ret); };
	    }
	    var datePartsFormatterCache = new Map();
	    function dateFormatter(format, date, locale) {
	        var text = '';
	        var match;
	        var fn;
	        var parts = [];
	        if (PATTERN_ALIASES[format]) {
	            return PATTERN_ALIASES[format](date, locale);
	        }
	        if (datePartsFormatterCache.has(format)) {
	            parts = datePartsFormatterCache.get(format);
	        }
	        else {
	            var matches = DATE_FORMATS_SPLIT.exec(format);
	            while (format) {
	                match = DATE_FORMATS_SPLIT.exec(format);
	                if (match) {
	                    parts = concat(parts, match, 1);
	                    format = parts.pop();
	                }
	                else {
	                    parts.push(format);
	                    format = null;
	                }
	            }
	            datePartsFormatterCache.set(format, parts);
	        }
	        parts.forEach(function (part) {
	            fn = DATE_FORMATS[part];
	            text += fn ? fn(date, locale) :
	                part === '\'\'' ? '\'' : part.replace(/(^'|'$)/g, '').replace(/''/g, '\'');
	        });
	        return text;
	    }
	    var slice = [].slice;
	    function concat(array1 /** TODO #9100 */, array2 /** TODO #9100 */, index /** TODO #9100 */) {
	        return array1.concat(slice.call(array2, index));
	    }
	    var DateFormatter = (function () {
	        function DateFormatter() {
	        }
	        DateFormatter.format = function (date, locale, pattern) {
	            return dateFormatter(pattern, date, locale);
	        };
	        return DateFormatter;
	    }());

	    /**
	     * @ngModule CommonModule
	     * @whatItDoes Formats a date according to locale rules.
	     * @howToUse `date_expression | date[:format]`
	     * @description
	     *
	     * Where:
	     * - `expression` is a date object or a number (milliseconds since UTC epoch) or an ISO string
	     * (https://www.w3.org/TR/NOTE-datetime).
	     * - `format` indicates which date/time components to include. The format can be predifined as
	     *   shown below or custom as shown in the table.
	     *   - `'medium'`: equivalent to `'yMMMdjms'` (e.g. `Sep 3, 2010, 12:05:08 PM` for `en-US`)
	     *   - `'short'`: equivalent to `'yMdjm'` (e.g. `9/3/2010, 12:05 PM` for `en-US`)
	     *   - `'fullDate'`: equivalent to `'yMMMMEEEEd'` (e.g. `Friday, September 3, 2010` for `en-US`)
	     *   - `'longDate'`: equivalent to `'yMMMMd'` (e.g. `September 3, 2010` for `en-US`)
	     *   - `'mediumDate'`: equivalent to `'yMMMd'` (e.g. `Sep 3, 2010` for `en-US`)
	     *   - `'shortDate'`: equivalent to `'yMd'` (e.g. `9/3/2010` for `en-US`)
	     *   - `'mediumTime'`: equivalent to `'jms'` (e.g. `12:05:08 PM` for `en-US`)
	     *   - `'shortTime'`: equivalent to `'jm'` (e.g. `12:05 PM` for `en-US`)
	     *
	     *
	     *  | Component | Symbol | Short Form   | Long Form         | Numeric   | 2-digit   |
	     *  |-----------|:------:|--------------|-------------------|-----------|-----------|
	     *  | era       |   G    | G (AD)       | GGGG (Anno Domini)| -         | -         |
	     *  | year      |   y    | -            | -                 | y (2015)  | yy (15)   |
	     *  | month     |   M    | MMM (Sep)    | MMMM (September)  | M (9)     | MM (09)   |
	     *  | day       |   d    | -            | -                 | d (3)     | dd (03)   |
	     *  | weekday   |   E    | EEE (Sun)    | EEEE (Sunday)     | -         | -         |
	     *  | hour      |   j    | -            | -                 | j (13)    | jj (13)   |
	     *  | hour12    |   h    | -            | -                 | h (1 PM)  | hh (01 PM)|
	     *  | hour24    |   H    | -            | -                 | H (13)    | HH (13)   |
	     *  | minute    |   m    | -            | -                 | m (5)     | mm (05)   |
	     *  | second    |   s    | -            | -                 | s (9)     | ss (09)   |
	     *  | timezone  |   z    | -            | z (Pacific Standard Time)| -  | -         |
	     *  | timezone  |   Z    | Z (GMT-8:00) | -                 | -         | -         |
	     *  | timezone  |   a    | a (PM)       | -                 | -         | -         |
	     *
	     * In javascript, only the components specified will be respected (not the ordering,
	     * punctuations, ...) and details of the formatting will be dependent on the locale.
	     *
	     * Timezone of the formatted text will be the local system timezone of the end-user's machine.
	     *
	     * WARNINGS:
	     * - this pipe is marked as pure hence it will not be re-evaluated when the input is mutated.
	     *   Instead users should treat the date as an immutable object and change the reference when the
	     *   pipe needs to re-run (this is to avoid reformatting the date on every change detection run
	     *   which would be an expensive operation).
	     * - this pipe uses the Internationalization API. Therefore it is only reliable in Chrome and Opera
	     *   browsers.
	     *
	     * ### Examples
	     *
	     * Assuming `dateObj` is (year: 2015, month: 6, day: 15, hour: 21, minute: 43, second: 11)
	     * in the _local_ time and locale is 'en-US':
	     *
	     * ```
	     *     {{ dateObj | date }}               // output is 'Jun 15, 2015'
	     *     {{ dateObj | date:'medium' }}      // output is 'Jun 15, 2015, 9:43:11 PM'
	     *     {{ dateObj | date:'shortTime' }}   // output is '9:43 PM'
	     *     {{ dateObj | date:'mmss' }}        // output is '43:11'
	     * ```
	     *
	     * {@example common/pipes/ts/date_pipe.ts region='DatePipe'}
	     *
	     * @stable
	     */
	    var DatePipe = (function () {
	        function DatePipe(_locale) {
	            this._locale = _locale;
	        }
	        DatePipe.prototype.transform = function (value, pattern) {
	            if (pattern === void 0) { pattern = 'mediumDate'; }
	            if (isBlank(value))
	                return null;
	            if (!this.supports(value)) {
	                throw new InvalidPipeArgumentError(DatePipe, value);
	            }
	            if (NumberWrapper.isNumeric(value)) {
	                value = parseFloat(value);
	            }
	            return DateFormatter.format(new Date(value), this._locale, DatePipe._ALIASES[pattern] || pattern);
	        };
	        DatePipe.prototype.supports = function (obj) {
	            return isDate(obj) || NumberWrapper.isNumeric(obj) ||
	                (typeof obj === 'string' && isDate(new Date(obj)));
	        };
	        /** @internal */
	        DatePipe._ALIASES = {
	            'medium': 'yMMMdjms',
	            'short': 'yMdjm',
	            'fullDate': 'yMMMMEEEEd',
	            'longDate': 'yMMMMd',
	            'mediumDate': 'yMMMd',
	            'shortDate': 'yMd',
	            'mediumTime': 'jms',
	            'shortTime': 'jm'
	        };
	        DatePipe.decorators = [
	            { type: _angular_core.Pipe, args: [{ name: 'date', pure: true },] },
	        ];
	        /** @nocollapse */
	        DatePipe.ctorParameters = [
	            { type: undefined, decorators: [{ type: _angular_core.Inject, args: [_angular_core.LOCALE_ID,] },] },
	        ];
	        return DatePipe;
	    }());

	    var _INTERPOLATION_REGEXP = /#/g;
	    /**
	     * @ngModule CommonModule
	     * @whatItDoes Maps a value to a string that pluralizes the value according to locale rules.
	     * @howToUse `expression | i18nPlural:mapping`
	     * @description
	     *
	     *  Where:
	     *  - `expression` is a number.
	     *  - `mapping` is an object that mimics the ICU format, see
	     *    http://userguide.icu-project.org/formatparse/messages
	     *
	     *  ## Example
	     *
	     * {@example common/pipes/ts/i18n_pipe.ts region='I18nPluralPipeComponent'}
	     *
	     * @experimental
	     */
	    var I18nPluralPipe = (function () {
	        function I18nPluralPipe(_localization) {
	            this._localization = _localization;
	        }
	        I18nPluralPipe.prototype.transform = function (value, pluralMap) {
	            if (isBlank(value))
	                return '';
	            if (typeof pluralMap !== 'object' || pluralMap === null) {
	                throw new InvalidPipeArgumentError(I18nPluralPipe, pluralMap);
	            }
	            var key = getPluralCategory(value, Object.keys(pluralMap), this._localization);
	            return pluralMap[key].replace(_INTERPOLATION_REGEXP, value.toString());
	        };
	        I18nPluralPipe.decorators = [
	            { type: _angular_core.Pipe, args: [{ name: 'i18nPlural', pure: true },] },
	        ];
	        /** @nocollapse */
	        I18nPluralPipe.ctorParameters = [
	            { type: NgLocalization, },
	        ];
	        return I18nPluralPipe;
	    }());

	    /**
	     * @ngModule CommonModule
	     * @whatItDoes Generic selector that displays the string that matches the current value.
	     * @howToUse `expression | i18nSelect:mapping`
	     * @description
	     *
	     *  Where:
	     *  - `mapping`: is an object that indicates the text that should be displayed
	     *  for different values of the provided `expression`.
	     *
	     *  ## Example
	     *
	     * {@example common/pipes/ts/i18n_pipe.ts region='I18nSelectPipeComponent'}
	     *
	     *  @experimental
	     */
	    var I18nSelectPipe = (function () {
	        function I18nSelectPipe() {
	        }
	        I18nSelectPipe.prototype.transform = function (value, mapping) {
	            if (isBlank(value))
	                return '';
	            if (typeof mapping !== 'object' || mapping === null) {
	                throw new InvalidPipeArgumentError(I18nSelectPipe, mapping);
	            }
	            return mapping[value] || '';
	        };
	        I18nSelectPipe.decorators = [
	            { type: _angular_core.Pipe, args: [{ name: 'i18nSelect', pure: true },] },
	        ];
	        /** @nocollapse */
	        I18nSelectPipe.ctorParameters = [];
	        return I18nSelectPipe;
	    }());

	    /**
	     * @ngModule CommonModule
	     * @whatItDoes Converts value into JSON string.
	     * @howToUse `expression | json`
	     * @description
	     *
	     * Converts value into string using `JSON.stringify`. Useful for debugging.
	     *
	     * ### Example
	     * {@example common/pipes/ts/json_pipe.ts region='JsonPipe'}
	     *
	     * @stable
	     */
	    var JsonPipe = (function () {
	        function JsonPipe() {
	        }
	        JsonPipe.prototype.transform = function (value) { return JSON.stringify(value, null, 2); };
	        JsonPipe.decorators = [
	            { type: _angular_core.Pipe, args: [{ name: 'json', pure: false },] },
	        ];
	        /** @nocollapse */
	        JsonPipe.ctorParameters = [];
	        return JsonPipe;
	    }());

	    /**
	     * @ngModule CommonModule
	     * @whatItDoes Transforms string to lowercase.
	     * @howToUse `expression | lowercase`
	     * @description
	     *
	     * Converts value into lowercase string using `String.prototype.toLowerCase()`.
	     *
	     * ### Example
	     *
	     * {@example common/pipes/ts/lowerupper_pipe.ts region='LowerUpperPipe'}
	     *
	     * @stable
	     */
	    var LowerCasePipe = (function () {
	        function LowerCasePipe() {
	        }
	        LowerCasePipe.prototype.transform = function (value) {
	            if (isBlank(value))
	                return value;
	            if (typeof value !== 'string') {
	                throw new InvalidPipeArgumentError(LowerCasePipe, value);
	            }
	            return value.toLowerCase();
	        };
	        LowerCasePipe.decorators = [
	            { type: _angular_core.Pipe, args: [{ name: 'lowercase' },] },
	        ];
	        /** @nocollapse */
	        LowerCasePipe.ctorParameters = [];
	        return LowerCasePipe;
	    }());

	    var _NUMBER_FORMAT_REGEXP = /^(\d+)?\.((\d+)(-(\d+))?)?$/;
	    function formatNumber(pipe, locale, value, style, digits, currency, currencyAsSymbol) {
	        if (currency === void 0) { currency = null; }
	        if (currencyAsSymbol === void 0) { currencyAsSymbol = false; }
	        if (isBlank(value))
	            return null;
	        // Convert strings to numbers
	        value = typeof value === 'string' && NumberWrapper.isNumeric(value) ? +value : value;
	        if (typeof value !== 'number') {
	            throw new InvalidPipeArgumentError(pipe, value);
	        }
	        var minInt;
	        var minFraction;
	        var maxFraction;
	        if (style !== NumberFormatStyle.Currency) {
	            // rely on Intl default for currency
	            minInt = 1;
	            minFraction = 0;
	            maxFraction = 3;
	        }
	        if (digits) {
	            var parts = digits.match(_NUMBER_FORMAT_REGEXP);
	            if (parts === null) {
	                throw new Error(digits + " is not a valid digit info for number pipes");
	            }
	            if (isPresent(parts[1])) {
	                minInt = NumberWrapper.parseIntAutoRadix(parts[1]);
	            }
	            if (isPresent(parts[3])) {
	                minFraction = NumberWrapper.parseIntAutoRadix(parts[3]);
	            }
	            if (isPresent(parts[5])) {
	                maxFraction = NumberWrapper.parseIntAutoRadix(parts[5]);
	            }
	        }
	        return NumberFormatter.format(value, locale, style, {
	            minimumIntegerDigits: minInt,
	            minimumFractionDigits: minFraction,
	            maximumFractionDigits: maxFraction,
	            currency: currency,
	            currencyAsSymbol: currencyAsSymbol,
	        });
	    }
	    /**
	     * @ngModule CommonModule
	     * @whatItDoes Formats a number according to locale rules.
	     * @howToUse `number_expression | number[:digitInfo]`
	     *
	     * Formats a number as text. Group sizing and separator and other locale-specific
	     * configurations are based on the active locale.
	     *
	     * where `expression` is a number:
	     *  - `digitInfo` is a `string` which has a following format: <br>
	     *     <code>{minIntegerDigits}.{minFractionDigits}-{maxFractionDigits}</code>
	     *   - `minIntegerDigits` is the minimum number of integer digits to use. Defaults to `1`.
	     *   - `minFractionDigits` is the minimum number of digits after fraction. Defaults to `0`.
	     *   - `maxFractionDigits` is the maximum number of digits after fraction. Defaults to `3`.
	     *
	     * For more information on the acceptable range for each of these numbers and other
	     * details see your native internationalization library.
	     *
	     * WARNING: this pipe uses the Internationalization API which is not yet available in all browsers
	     * and may require a polyfill. See {@linkDocs guide/browser-support} for details.
	     *
	     * ### Example
	     *
	     * {@example common/pipes/ts/number_pipe.ts region='NumberPipe'}
	     *
	     * @stable
	     */
	    var DecimalPipe = (function () {
	        function DecimalPipe(_locale) {
	            this._locale = _locale;
	        }
	        DecimalPipe.prototype.transform = function (value, digits) {
	            if (digits === void 0) { digits = null; }
	            return formatNumber(DecimalPipe, this._locale, value, NumberFormatStyle.Decimal, digits);
	        };
	        DecimalPipe.decorators = [
	            { type: _angular_core.Pipe, args: [{ name: 'number' },] },
	        ];
	        /** @nocollapse */
	        DecimalPipe.ctorParameters = [
	            { type: undefined, decorators: [{ type: _angular_core.Inject, args: [_angular_core.LOCALE_ID,] },] },
	        ];
	        return DecimalPipe;
	    }());
	    /**
	     * @ngModule CommonModule
	     * @whatItDoes Formats a number as a percentage according to locale rules.
	     * @howToUse `number_expression | percent[:digitInfo]`
	     *
	     * @description
	     *
	     * Formats a number as percentage.
	     *
	     * - `digitInfo` See {@link DecimalPipe} for detailed description.
	     *
	     * WARNING: this pipe uses the Internationalization API which is not yet available in all browsers
	     * and may require a polyfill. See {@linkDocs guide/browser-support} for details.
	     *
	     * ### Example
	     *
	     * {@example common/pipes/ts/number_pipe.ts region='PercentPipe'}
	     *
	     * @stable
	     */
	    var PercentPipe = (function () {
	        function PercentPipe(_locale) {
	            this._locale = _locale;
	        }
	        PercentPipe.prototype.transform = function (value, digits) {
	            if (digits === void 0) { digits = null; }
	            return formatNumber(PercentPipe, this._locale, value, NumberFormatStyle.Percent, digits);
	        };
	        PercentPipe.decorators = [
	            { type: _angular_core.Pipe, args: [{ name: 'percent' },] },
	        ];
	        /** @nocollapse */
	        PercentPipe.ctorParameters = [
	            { type: undefined, decorators: [{ type: _angular_core.Inject, args: [_angular_core.LOCALE_ID,] },] },
	        ];
	        return PercentPipe;
	    }());
	    /**
	     * @ngModule CommonModule
	     * @whatItDoes Formats a number as currency using locale rules.
	     * @howToUse `number_expression | currency[:currencyCode[:symbolDisplay[:digitInfo]]]`
	     * @description
	     *
	     * Use `currency` to format a number as currency.
	     *
	     * - `currencyCode` is the [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) currency code, such
	     *    as `USD` for the US dollar and `EUR` for the euro.
	     * - `symbolDisplay` is a boolean indicating whether to use the currency symbol or code.
	     *   - `true`: use symbol (e.g. `$`).
	     *   - `false`(default): use code (e.g. `USD`).
	     * - `digitInfo` See {@link DecimalPipe} for detailed description.
	     *
	     * WARNING: this pipe uses the Internationalization API which is not yet available in all browsers
	     * and may require a polyfill. See {@linkDocs guide/browser-support} for details.
	     *
	     * ### Example
	     *
	     * {@example common/pipes/ts/number_pipe.ts region='CurrencyPipe'}
	     *
	     * @stable
	     */
	    var CurrencyPipe = (function () {
	        function CurrencyPipe(_locale) {
	            this._locale = _locale;
	        }
	        CurrencyPipe.prototype.transform = function (value, currencyCode, symbolDisplay, digits) {
	            if (currencyCode === void 0) { currencyCode = 'USD'; }
	            if (symbolDisplay === void 0) { symbolDisplay = false; }
	            if (digits === void 0) { digits = null; }
	            return formatNumber(CurrencyPipe, this._locale, value, NumberFormatStyle.Currency, digits, currencyCode, symbolDisplay);
	        };
	        CurrencyPipe.decorators = [
	            { type: _angular_core.Pipe, args: [{ name: 'currency' },] },
	        ];
	        /** @nocollapse */
	        CurrencyPipe.ctorParameters = [
	            { type: undefined, decorators: [{ type: _angular_core.Inject, args: [_angular_core.LOCALE_ID,] },] },
	        ];
	        return CurrencyPipe;
	    }());

	    /**
	     * @ngModule CommonModule
	     * @whatItDoes Creates a new List or String containing a subset (slice) of the elements.
	     * @howToUse `array_or_string_expression | slice:start[:end]`
	     * @description
	     *
	     * Where the input expression is a `List` or `String`, and:
	     * - `start`: The starting index of the subset to return.
	     *   - **a positive integer**: return the item at `start` index and all items after
	     *     in the list or string expression.
	     *   - **a negative integer**: return the item at `start` index from the end and all items after
	     *     in the list or string expression.
	     *   - **if positive and greater than the size of the expression**: return an empty list or string.
	     *   - **if negative and greater than the size of the expression**: return entire list or string.
	     * - `end`: The ending index of the subset to return.
	     *   - **omitted**: return all items until the end.
	     *   - **if positive**: return all items before `end` index of the list or string.
	     *   - **if negative**: return all items before `end` index from the end of the list or string.
	     *
	     * All behavior is based on the expected behavior of the JavaScript API `Array.prototype.slice()`
	     * and `String.prototype.slice()`.
	     *
	     * When operating on a [List], the returned list is always a copy even when all
	     * the elements are being returned.
	     *
	     * When operating on a blank value, the pipe returns the blank value.
	     *
	     * ## List Example
	     *
	     * This `ngFor` example:
	     *
	     * {@example common/pipes/ts/slice_pipe.ts region='SlicePipe_list'}
	     *
	     * produces the following:
	     *
	     *     <li>b</li>
	     *     <li>c</li>
	     *
	     * ## String Examples
	     *
	     * {@example common/pipes/ts/slice_pipe.ts region='SlicePipe_string'}
	     *
	     * @stable
	     */
	    var SlicePipe = (function () {
	        function SlicePipe() {
	        }
	        SlicePipe.prototype.transform = function (value, start, end) {
	            if (isBlank(value))
	                return value;
	            if (!this.supports(value)) {
	                throw new InvalidPipeArgumentError(SlicePipe, value);
	            }
	            return value.slice(start, end);
	        };
	        SlicePipe.prototype.supports = function (obj) { return typeof obj === 'string' || Array.isArray(obj); };
	        SlicePipe.decorators = [
	            { type: _angular_core.Pipe, args: [{ name: 'slice', pure: false },] },
	        ];
	        /** @nocollapse */
	        SlicePipe.ctorParameters = [];
	        return SlicePipe;
	    }());

	    /**
	     * @ngModule CommonModule
	     * @whatItDoes Transforms string to uppercase.
	     * @howToUse `expression | uppercase`
	     * @description
	     *
	     * Converts value into lowercase string using `String.prototype.toUpperCase()`.
	     *
	     * ### Example
	     *
	     * {@example common/pipes/ts/lowerupper_pipe.ts region='LowerUpperPipe'}
	     *
	     * @stable
	     */
	    var UpperCasePipe = (function () {
	        function UpperCasePipe() {
	        }
	        UpperCasePipe.prototype.transform = function (value) {
	            if (isBlank(value))
	                return value;
	            if (typeof value !== 'string') {
	                throw new InvalidPipeArgumentError(UpperCasePipe, value);
	            }
	            return value.toUpperCase();
	        };
	        UpperCasePipe.decorators = [
	            { type: _angular_core.Pipe, args: [{ name: 'uppercase' },] },
	        ];
	        /** @nocollapse */
	        UpperCasePipe.ctorParameters = [];
	        return UpperCasePipe;
	    }());

	    /**
	     * A collection of Angular pipes that are likely to be used in each and every application.
	     */
	    var COMMON_PIPES = [
	        AsyncPipe,
	        UpperCasePipe,
	        LowerCasePipe,
	        JsonPipe,
	        SlicePipe,
	        DecimalPipe,
	        PercentPipe,
	        CurrencyPipe,
	        DatePipe,
	        I18nPluralPipe,
	        I18nSelectPipe,
	    ];

	    // Note: This does not contain the location providers,
	    // as they need some platform specific implementations to work.
	    /**
	     * The module that includes all the basic Angular directives like {@link NgIf}, {@link NgFor}, ...
	     *
	     * @stable
	     */
	    var CommonModule = (function () {
	        function CommonModule() {
	        }
	        CommonModule.decorators = [
	            { type: _angular_core.NgModule, args: [{
	                        declarations: [COMMON_DIRECTIVES, COMMON_PIPES],
	                        exports: [COMMON_DIRECTIVES, COMMON_PIPES],
	                        providers: [
	                            { provide: NgLocalization, useClass: NgLocaleLocalization },
	                        ],
	                    },] },
	        ];
	        /** @nocollapse */
	        CommonModule.ctorParameters = [];
	        return CommonModule;
	    }());

	    exports.NgLocalization = NgLocalization;
	    exports.CommonModule = CommonModule;
	    exports.NgClass = NgClass;
	    exports.NgFor = NgFor;
	    exports.NgIf = NgIf;
	    exports.NgPlural = NgPlural;
	    exports.NgPluralCase = NgPluralCase;
	    exports.NgStyle = NgStyle;
	    exports.NgSwitch = NgSwitch;
	    exports.NgSwitchCase = NgSwitchCase;
	    exports.NgSwitchDefault = NgSwitchDefault;
	    exports.NgTemplateOutlet = NgTemplateOutlet;
	    exports.AsyncPipe = AsyncPipe;
	    exports.DatePipe = DatePipe;
	    exports.I18nPluralPipe = I18nPluralPipe;
	    exports.I18nSelectPipe = I18nSelectPipe;
	    exports.JsonPipe = JsonPipe;
	    exports.LowerCasePipe = LowerCasePipe;
	    exports.CurrencyPipe = CurrencyPipe;
	    exports.DecimalPipe = DecimalPipe;
	    exports.PercentPipe = PercentPipe;
	    exports.SlicePipe = SlicePipe;
	    exports.UpperCasePipe = UpperCasePipe;
	    exports.PlatformLocation = PlatformLocation;
	    exports.LocationStrategy = LocationStrategy;
	    exports.APP_BASE_HREF = APP_BASE_HREF;
	    exports.HashLocationStrategy = HashLocationStrategy;
	    exports.PathLocationStrategy = PathLocationStrategy;
	    exports.Location = Location;

	}));

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.AppModule = undefined;

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	var _core = __webpack_require__(3);

	var _platformBrowser = __webpack_require__(21);

	var _app = __webpack_require__(24);

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
	    var c = arguments.length,
	        r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
	        d;
	    if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
	        if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    }return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = undefined && undefined.__metadata || function (k, v) {
	    if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var AppModule = exports.AppModule = function AppModule() {
	    _classCallCheck(this, AppModule);
	};
	exports.AppModule = AppModule = __decorate([(0, _core.NgModule)({
	    imports: [_platformBrowser.BrowserModule],
	    declarations: [_app.AppComponent],
	    bootstrap: [_app.AppComponent]
		}), __metadata('design:paramtypes', [])], AppModule);

/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.AppComponent = undefined;

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	var _core = __webpack_require__(3);

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
	    var c = arguments.length,
	        r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
	        d;
	    if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
	        if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    }return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = undefined && undefined.__metadata || function (k, v) {
	    if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var AppComponent = exports.AppComponent = function AppComponent() {
	    _classCallCheck(this, AppComponent);

	    this.name = 'Third';
	};
	exports.AppComponent = AppComponent = __decorate([(0, _core.Component)({
	    selector: 'my-app',
	    template: '<h1>My {{name}} Angular App</h1>'
		}), __metadata('design:paramtypes', [])], AppComponent);

/***/ }
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXBwLWJ1bmRsZS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy93ZWJwYWNrL2Jvb3RzdHJhcCBlYzcxOGQ1YTIwNmE5NzE5ZWY2OCIsIndlYnBhY2s6Ly8vLi9hcHAvbWFpbi50cyIsIndlYnBhY2s6Ly8vLi9+L0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXItZHluYW1pYy9idW5kbGVzL3BsYXRmb3JtLWJyb3dzZXItZHluYW1pYy51bWQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9AYW5ndWxhci9jb21waWxlci9idW5kbGVzL2NvbXBpbGVyLnVtZC5qcyIsIndlYnBhY2s6Ly8vLi9+L0Bhbmd1bGFyL2NvcmUvYnVuZGxlcy9jb3JlLnVtZC5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvU3ViamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvT2JzZXJ2YWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvdXRpbC9yb290LmpzIiwid2VicGFjazovLy8uL34vcnhqcy91dGlsL3RvU3Vic2NyaWJlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvU3Vic2NyaWJlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvdXRpbC9pc0Z1bmN0aW9uLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9TdWJzY3JpcHRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3V0aWwvaXNBcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvdXRpbC9pc09iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvdXRpbC90cnlDYXRjaC5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvdXRpbC9lcnJvck9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvdXRpbC9VbnN1YnNjcmlwdGlvbkVycm9yLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9PYnNlcnZlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3ltYm9sL3J4U3Vic2NyaWJlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3ltYm9sL29ic2VydmFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3V0aWwvT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL1N1YmplY3RTdWJzY3JpcHRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9AYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyL2J1bmRsZXMvcGxhdGZvcm0tYnJvd3Nlci51bWQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9AYW5ndWxhci9jb21tb24vYnVuZGxlcy9jb21tb24udW1kLmpzIiwid2VicGFjazovLy8uL2FwcC9hcHAubW9kdWxlLnRzIiwid2VicGFjazovLy8uL2FwcC9hcHAuY29tcG9uZW50LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuXG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRleHBvcnRzOiB7fSxcbiBcdFx0XHRpZDogbW9kdWxlSWQsXG4gXHRcdFx0bG9hZGVkOiBmYWxzZVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2svYm9vdHN0cmFwIGVjNzE4ZDVhMjA2YTk3MTllZjY4IiwiaW1wb3J0IHsgcGxhdGZvcm1Ccm93c2VyRHluYW1pYyB9IGZyb20gJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXItZHluYW1pYyc7XHJcbmltcG9ydCB7IEFwcE1vZHVsZSB9IGZyb20gJy4vYXBwLm1vZHVsZSc7XHJcblxyXG5jb25zdCBwbGF0Zm9ybSA9IHBsYXRmb3JtQnJvd3NlckR5bmFtaWMoKTtcclxucGxhdGZvcm0uYm9vdHN0cmFwTW9kdWxlKEFwcE1vZHVsZSk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYXBwL21haW4udHMiLCIvKipcbiAqIEBsaWNlbnNlIEFuZ3VsYXIgdjIuMS4yXG4gKiAoYykgMjAxMC0yMDE2IEdvb2dsZSwgSW5jLiBodHRwczovL2FuZ3VsYXIuaW8vXG4gKiBMaWNlbnNlOiBNSVRcbiAqL1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMsIHJlcXVpcmUoJ0Bhbmd1bGFyL2NvbXBpbGVyJyksIHJlcXVpcmUoJ0Bhbmd1bGFyL2NvcmUnKSwgcmVxdWlyZSgnQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3NlcicpKSA6XG4gICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cycsICdAYW5ndWxhci9jb21waWxlcicsICdAYW5ndWxhci9jb3JlJywgJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXInXSwgZmFjdG9yeSkgOlxuICAgIChmYWN0b3J5KChnbG9iYWwubmcgPSBnbG9iYWwubmcgfHwge30sIGdsb2JhbC5uZy5wbGF0Zm9ybUJyb3dzZXJEeW5hbWljID0gZ2xvYmFsLm5nLnBsYXRmb3JtQnJvd3NlckR5bmFtaWMgfHwge30pLGdsb2JhbC5uZy5jb21waWxlcixnbG9iYWwubmcuY29yZSxnbG9iYWwubmcucGxhdGZvcm1Ccm93c2VyKSk7XG59KHRoaXMsIGZ1bmN0aW9uIChleHBvcnRzLF9hbmd1bGFyX2NvbXBpbGVyLF9hbmd1bGFyX2NvcmUsX2FuZ3VsYXJfcGxhdGZvcm1Ccm93c2VyKSB7ICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBJTlRFUk5BTF9CUk9XU0VSX1BMQVRGT1JNX1BST1ZJREVSUyA9IF9hbmd1bGFyX3BsYXRmb3JtQnJvd3Nlci5fX3BsYXRmb3JtX2Jyb3dzZXJfcHJpdmF0ZV9fLklOVEVSTkFMX0JST1dTRVJfUExBVEZPUk1fUFJPVklERVJTO1xuXG4gICAgdmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xuICAgIHZhciBSZXNvdXJjZUxvYWRlckltcGwgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMoUmVzb3VyY2VMb2FkZXJJbXBsLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBSZXNvdXJjZUxvYWRlckltcGwoKSB7XG4gICAgICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBSZXNvdXJjZUxvYWRlckltcGwucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICh1cmwpIHtcbiAgICAgICAgICAgIHZhciByZXNvbHZlO1xuICAgICAgICAgICAgdmFyIHJlamVjdDtcbiAgICAgICAgICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlcywgcmVqKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSA9IHJlcztcbiAgICAgICAgICAgICAgICByZWplY3QgPSByZWo7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgICAgIHhoci5vcGVuKCdHRVQnLCB1cmwsIHRydWUpO1xuICAgICAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICd0ZXh0JztcbiAgICAgICAgICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgLy8gcmVzcG9uc2VUZXh0IGlzIHRoZSBvbGQtc2Nob29sIHdheSBvZiByZXRyaWV2aW5nIHJlc3BvbnNlIChzdXBwb3J0ZWQgYnkgSUU4ICYgOSlcbiAgICAgICAgICAgICAgICAvLyByZXNwb25zZS9yZXNwb25zZVR5cGUgcHJvcGVydGllcyB3ZXJlIGludHJvZHVjZWQgaW4gUmVzb3VyY2VMb2FkZXIgTGV2ZWwyIHNwZWMgKHN1cHBvcnRlZFxuICAgICAgICAgICAgICAgIC8vIGJ5IElFMTApXG4gICAgICAgICAgICAgICAgdmFyIHJlc3BvbnNlID0geGhyLnJlc3BvbnNlIHx8IHhoci5yZXNwb25zZVRleHQ7XG4gICAgICAgICAgICAgICAgLy8gbm9ybWFsaXplIElFOSBidWcgKGh0dHA6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzE0NTApXG4gICAgICAgICAgICAgICAgdmFyIHN0YXR1cyA9IHhoci5zdGF0dXMgPT09IDEyMjMgPyAyMDQgOiB4aHIuc3RhdHVzO1xuICAgICAgICAgICAgICAgIC8vIGZpeCBzdGF0dXMgY29kZSB3aGVuIGl0IGlzIDAgKDAgc3RhdHVzIGlzIHVuZG9jdW1lbnRlZCkuXG4gICAgICAgICAgICAgICAgLy8gT2NjdXJzIHdoZW4gYWNjZXNzaW5nIGZpbGUgcmVzb3VyY2VzIG9yIG9uIEFuZHJvaWQgNC4xIHN0b2NrIGJyb3dzZXJcbiAgICAgICAgICAgICAgICAvLyB3aGlsZSByZXRyaWV2aW5nIGZpbGVzIGZyb20gYXBwbGljYXRpb24gY2FjaGUuXG4gICAgICAgICAgICAgICAgaWYgKHN0YXR1cyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMgPSByZXNwb25zZSA/IDIwMCA6IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgyMDAgPD0gc3RhdHVzICYmIHN0YXR1cyA8PSAzMDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoXCJGYWlsZWQgdG8gbG9hZCBcIiArIHVybCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24gKCkgeyByZWplY3QoXCJGYWlsZWQgdG8gbG9hZCBcIiArIHVybCk7IH07XG4gICAgICAgICAgICB4aHIuc2VuZCgpO1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICAgIH07XG4gICAgICAgIFJlc291cmNlTG9hZGVySW1wbC5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdGFibGUgfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIFJlc291cmNlTG9hZGVySW1wbC5jdG9yUGFyYW1ldGVycyA9IFtdO1xuICAgICAgICByZXR1cm4gUmVzb3VyY2VMb2FkZXJJbXBsO1xuICAgIH0oX2FuZ3VsYXJfY29tcGlsZXIuUmVzb3VyY2VMb2FkZXIpKTtcblxuICAgIHZhciBJTlRFUk5BTF9CUk9XU0VSX0RZTkFNSUNfUExBVEZPUk1fUFJPVklERVJTID0gW1xuICAgICAgICBJTlRFUk5BTF9CUk9XU0VSX1BMQVRGT1JNX1BST1ZJREVSUyxcbiAgICAgICAge1xuICAgICAgICAgICAgcHJvdmlkZTogX2FuZ3VsYXJfY29yZS5DT01QSUxFUl9PUFRJT05TLFxuICAgICAgICAgICAgdXNlVmFsdWU6IHsgcHJvdmlkZXJzOiBbeyBwcm92aWRlOiBfYW5ndWxhcl9jb21waWxlci5SZXNvdXJjZUxvYWRlciwgdXNlQ2xhc3M6IFJlc291cmNlTG9hZGVySW1wbCB9XSB9LFxuICAgICAgICAgICAgbXVsdGk6IHRydWVcbiAgICAgICAgfSxcbiAgICBdO1xuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIHZhciBnbG9iYWxTY29wZTtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBXb3JrZXJHbG9iYWxTY29wZSAhPT0gJ3VuZGVmaW5lZCcgJiYgc2VsZiBpbnN0YW5jZW9mIFdvcmtlckdsb2JhbFNjb3BlKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBSZXBsYWNlIGFueSB3aXRoIFdvcmtlckdsb2JhbFNjb3BlIGZyb20gbGliLndlYndvcmtlci5kLnRzICMzNDkyXG4gICAgICAgICAgICBnbG9iYWxTY29wZSA9IHNlbGY7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBnbG9iYWxTY29wZSA9IGdsb2JhbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZ2xvYmFsU2NvcGUgPSB3aW5kb3c7XG4gICAgfVxuICAgIC8vIE5lZWQgdG8gZGVjbGFyZSBhIG5ldyB2YXJpYWJsZSBmb3IgZ2xvYmFsIGhlcmUgc2luY2UgVHlwZVNjcmlwdFxuICAgIC8vIGV4cG9ydHMgdGhlIG9yaWdpbmFsIHZhbHVlIG9mIHRoZSBzeW1ib2wuXG4gICAgdmFyIF9nbG9iYWwgPSBnbG9iYWxTY29wZTtcbiAgICAvLyBUT0RPOiByZW1vdmUgY2FsbHMgdG8gYXNzZXJ0IGluIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRcbiAgICAvLyBOb3RlOiBDYW4ndCBqdXN0IGV4cG9ydCB0aGlzIGFuZCBpbXBvcnQgaW4gaW4gb3RoZXIgZmlsZXNcbiAgICAvLyBhcyBgYXNzZXJ0YCBpcyBhIHJlc2VydmVkIGtleXdvcmQgaW4gRGFydFxuICAgIF9nbG9iYWwuYXNzZXJ0ID0gZnVuY3Rpb24gYXNzZXJ0KGNvbmRpdGlvbikge1xuICAgICAgICAvLyBUT0RPOiB0byBiZSBmaXhlZCBwcm9wZXJseSB2aWEgIzI4MzAsIG5vb3AgZm9yIG5vd1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgdmFyIF9fZXh0ZW5kcyQxID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQW4gaW1wbGVtZW50YXRpb24gb2YgUmVzb3VyY2VMb2FkZXIgdGhhdCB1c2VzIGEgdGVtcGxhdGUgY2FjaGUgdG8gYXZvaWQgZG9pbmcgYW4gYWN0dWFsXG4gICAgICogUmVzb3VyY2VMb2FkZXIuXG4gICAgICpcbiAgICAgKiBUaGUgdGVtcGxhdGUgY2FjaGUgbmVlZHMgdG8gYmUgYnVpbHQgYW5kIGxvYWRlZCBpbnRvIHdpbmRvdy4kdGVtcGxhdGVDYWNoZVxuICAgICAqIHZpYSBhIHNlcGFyYXRlIG1lY2hhbmlzbS5cbiAgICAgKi9cbiAgICB2YXIgQ2FjaGVkUmVzb3VyY2VMb2FkZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMkMShDYWNoZWRSZXNvdXJjZUxvYWRlciwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gQ2FjaGVkUmVzb3VyY2VMb2FkZXIoKSB7XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuX2NhY2hlID0gX2dsb2JhbC4kdGVtcGxhdGVDYWNoZTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jYWNoZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYWNoZWRSZXNvdXJjZUxvYWRlcjogVGVtcGxhdGUgY2FjaGUgd2FzIG5vdCBmb3VuZCBpbiAkdGVtcGxhdGVDYWNoZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBDYWNoZWRSZXNvdXJjZUxvYWRlci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHVybCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2NhY2hlLmhhc093blByb3BlcnR5KHVybCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2NhY2hlW3VybF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCdDYWNoZWRSZXNvdXJjZUxvYWRlcjogRGlkIG5vdCBmaW5kIGNhY2hlZCB0ZW1wbGF0ZSBmb3IgJyArIHVybCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBDYWNoZWRSZXNvdXJjZUxvYWRlcjtcbiAgICB9KF9hbmd1bGFyX2NvbXBpbGVyLlJlc291cmNlTG9hZGVyKSk7XG5cbiAgICB2YXIgX19wbGF0Zm9ybV9icm93c2VyX2R5bmFtaWNfcHJpdmF0ZV9fID0ge1xuICAgICAgICBJTlRFUk5BTF9CUk9XU0VSX0RZTkFNSUNfUExBVEZPUk1fUFJPVklERVJTOiBJTlRFUk5BTF9CUk9XU0VSX0RZTkFNSUNfUExBVEZPUk1fUFJPVklERVJTLFxuICAgICAgICBSZXNvdXJjZUxvYWRlckltcGw6IFJlc291cmNlTG9hZGVySW1wbFxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgdmFyIFJFU09VUkNFX0NBQ0hFX1BST1ZJREVSID0gW3sgcHJvdmlkZTogX2FuZ3VsYXJfY29tcGlsZXIuUmVzb3VyY2VMb2FkZXIsIHVzZUNsYXNzOiBDYWNoZWRSZXNvdXJjZUxvYWRlciB9XTtcbiAgICAvKipcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIHBsYXRmb3JtQnJvd3NlckR5bmFtaWMgPSBfYW5ndWxhcl9jb3JlLmNyZWF0ZVBsYXRmb3JtRmFjdG9yeShfYW5ndWxhcl9jb21waWxlci5wbGF0Zm9ybUNvcmVEeW5hbWljLCAnYnJvd3NlckR5bmFtaWMnLCBJTlRFUk5BTF9CUk9XU0VSX0RZTkFNSUNfUExBVEZPUk1fUFJPVklERVJTKTtcblxuICAgIGV4cG9ydHMuUkVTT1VSQ0VfQ0FDSEVfUFJPVklERVIgPSBSRVNPVVJDRV9DQUNIRV9QUk9WSURFUjtcbiAgICBleHBvcnRzLnBsYXRmb3JtQnJvd3NlckR5bmFtaWMgPSBwbGF0Zm9ybUJyb3dzZXJEeW5hbWljO1xuICAgIGV4cG9ydHMuX19wbGF0Zm9ybV9icm93c2VyX2R5bmFtaWNfcHJpdmF0ZV9fID0gX19wbGF0Zm9ybV9icm93c2VyX2R5bmFtaWNfcHJpdmF0ZV9fO1xuXG59KSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlci1keW5hbWljL2J1bmRsZXMvcGxhdGZvcm0tYnJvd3Nlci1keW5hbWljLnVtZC5qc1xuLy8gbW9kdWxlIGlkID0gMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIEBsaWNlbnNlIEFuZ3VsYXIgdjIuMS4yXG4gKiAoYykgMjAxMC0yMDE2IEdvb2dsZSwgSW5jLiBodHRwczovL2FuZ3VsYXIuaW8vXG4gKiBMaWNlbnNlOiBNSVRcbiAqL1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzLCByZXF1aXJlKCdAYW5ndWxhci9jb3JlJykpIDpcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cycsICdAYW5ndWxhci9jb3JlJ10sIGZhY3RvcnkpIDpcbiAgKGZhY3RvcnkoKGdsb2JhbC5uZyA9IGdsb2JhbC5uZyB8fCB7fSwgZ2xvYmFsLm5nLmNvbXBpbGVyID0gZ2xvYmFsLm5nLmNvbXBpbGVyIHx8IHt9KSxnbG9iYWwubmcuY29yZSkpO1xufSh0aGlzLCBmdW5jdGlvbiAoZXhwb3J0cyxfYW5ndWxhcl9jb3JlKSB7ICd1c2Ugc3RyaWN0JztcblxuICAvKipcbiAgICogQGxpY2Vuc2VcbiAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAqXG4gICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICovXG4gIC8qKlxuICAgKiBBIHNlZ21lbnQgb2YgdGV4dCB3aXRoaW4gdGhlIHRlbXBsYXRlLlxuICAgKi9cbiAgdmFyIFRleHRBc3QgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gVGV4dEFzdCh2YWx1ZSwgbmdDb250ZW50SW5kZXgsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgdGhpcy5uZ0NvbnRlbnRJbmRleCA9IG5nQ29udGVudEluZGV4O1xuICAgICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgICB9XG4gICAgICBUZXh0QXN0LnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7IHJldHVybiB2aXNpdG9yLnZpc2l0VGV4dCh0aGlzLCBjb250ZXh0KTsgfTtcbiAgICAgIHJldHVybiBUZXh0QXN0O1xuICB9KCkpO1xuICAvKipcbiAgICogQSBib3VuZCBleHByZXNzaW9uIHdpdGhpbiB0aGUgdGV4dCBvZiBhIHRlbXBsYXRlLlxuICAgKi9cbiAgdmFyIEJvdW5kVGV4dEFzdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBCb3VuZFRleHRBc3QodmFsdWUsIG5nQ29udGVudEluZGV4LCBzb3VyY2VTcGFuKSB7XG4gICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgIHRoaXMubmdDb250ZW50SW5kZXggPSBuZ0NvbnRlbnRJbmRleDtcbiAgICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgICAgfVxuICAgICAgQm91bmRUZXh0QXN0LnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRCb3VuZFRleHQodGhpcywgY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIEJvdW5kVGV4dEFzdDtcbiAgfSgpKTtcbiAgLyoqXG4gICAqIEEgcGxhaW4gYXR0cmlidXRlIG9uIGFuIGVsZW1lbnQuXG4gICAqL1xuICB2YXIgQXR0ckFzdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBBdHRyQXN0KG5hbWUsIHZhbHVlLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICAgIH1cbiAgICAgIEF0dHJBc3QucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHsgcmV0dXJuIHZpc2l0b3IudmlzaXRBdHRyKHRoaXMsIGNvbnRleHQpOyB9O1xuICAgICAgcmV0dXJuIEF0dHJBc3Q7XG4gIH0oKSk7XG4gIC8qKlxuICAgKiBBIGJpbmRpbmcgZm9yIGFuIGVsZW1lbnQgcHJvcGVydHkgKGUuZy4gYFtwcm9wZXJ0eV09XCJleHByZXNzaW9uXCJgKSBvciBhbiBhbmltYXRpb24gdHJpZ2dlciAoZS5nLlxuICAgKiBgW0B0cmlnZ2VyXT1cInN0YXRlRXhwXCJgKVxuICAgKi9cbiAgdmFyIEJvdW5kRWxlbWVudFByb3BlcnR5QXN0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIEJvdW5kRWxlbWVudFByb3BlcnR5QXN0KG5hbWUsIHR5cGUsIHNlY3VyaXR5Q29udGV4dCwgbmVlZHNSdW50aW1lU2VjdXJpdHlDb250ZXh0LCB2YWx1ZSwgdW5pdCwgc291cmNlU3Bhbikge1xuICAgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgICB0aGlzLnNlY3VyaXR5Q29udGV4dCA9IHNlY3VyaXR5Q29udGV4dDtcbiAgICAgICAgICB0aGlzLm5lZWRzUnVudGltZVNlY3VyaXR5Q29udGV4dCA9IG5lZWRzUnVudGltZVNlY3VyaXR5Q29udGV4dDtcbiAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgdGhpcy51bml0ID0gdW5pdDtcbiAgICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgICAgfVxuICAgICAgQm91bmRFbGVtZW50UHJvcGVydHlBc3QucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEVsZW1lbnRQcm9wZXJ0eSh0aGlzLCBjb250ZXh0KTtcbiAgICAgIH07XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQm91bmRFbGVtZW50UHJvcGVydHlBc3QucHJvdG90eXBlLCBcImlzQW5pbWF0aW9uXCIsIHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMudHlwZSA9PT0gZXhwb3J0cy5Qcm9wZXJ0eUJpbmRpbmdUeXBlLkFuaW1hdGlvbjsgfSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gQm91bmRFbGVtZW50UHJvcGVydHlBc3Q7XG4gIH0oKSk7XG4gIC8qKlxuICAgKiBBIGJpbmRpbmcgZm9yIGFuIGVsZW1lbnQgZXZlbnQgKGUuZy4gYChldmVudCk9XCJoYW5kbGVyKClcImApIG9yIGFuIGFuaW1hdGlvbiB0cmlnZ2VyIGV2ZW50IChlLmcuXG4gICAqIGAoQHRyaWdnZXIucGhhc2UpPVwiY2FsbGJhY2soJGV2ZW50KVwiYCkuXG4gICAqL1xuICB2YXIgQm91bmRFdmVudEFzdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBCb3VuZEV2ZW50QXN0KG5hbWUsIHRhcmdldCwgcGhhc2UsIGhhbmRsZXIsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICAgIHRoaXMucGhhc2UgPSBwaGFzZTtcbiAgICAgICAgICB0aGlzLmhhbmRsZXIgPSBoYW5kbGVyO1xuICAgICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgICB9XG4gICAgICBCb3VuZEV2ZW50QXN0LnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRFdmVudCh0aGlzLCBjb250ZXh0KTtcbiAgICAgIH07XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQm91bmRFdmVudEFzdC5wcm90b3R5cGUsIFwiZnVsbE5hbWVcIiwge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBpZiAodGhpcy50YXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRhcmdldCArIFwiOlwiICsgdGhpcy5uYW1lO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubmFtZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJvdW5kRXZlbnRBc3QucHJvdG90eXBlLCBcImlzQW5pbWF0aW9uXCIsIHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuICEhdGhpcy5waGFzZTsgfSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gQm91bmRFdmVudEFzdDtcbiAgfSgpKTtcbiAgLyoqXG4gICAqIEEgcmVmZXJlbmNlIGRlY2xhcmF0aW9uIG9uIGFuIGVsZW1lbnQgKGUuZy4gYGxldCBzb21lTmFtZT1cImV4cHJlc3Npb25cImApLlxuICAgKi9cbiAgdmFyIFJlZmVyZW5jZUFzdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBSZWZlcmVuY2VBc3QobmFtZSwgdmFsdWUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgICAgfVxuICAgICAgUmVmZXJlbmNlQXN0LnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRSZWZlcmVuY2UodGhpcywgY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIFJlZmVyZW5jZUFzdDtcbiAgfSgpKTtcbiAgLyoqXG4gICAqIEEgdmFyaWFibGUgZGVjbGFyYXRpb24gb24gYSA8dGVtcGxhdGU+IChlLmcuIGB2YXItc29tZU5hbWU9XCJzb21lTG9jYWxOYW1lXCJgKS5cbiAgICovXG4gIHZhciBWYXJpYWJsZUFzdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBWYXJpYWJsZUFzdChuYW1lLCB2YWx1ZSwgc291cmNlU3Bhbikge1xuICAgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgICB9XG4gICAgICBWYXJpYWJsZUFzdC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0VmFyaWFibGUodGhpcywgY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIFZhcmlhYmxlQXN0O1xuICB9KCkpO1xuICAvKipcbiAgICogQW4gZWxlbWVudCBkZWNsYXJhdGlvbiBpbiBhIHRlbXBsYXRlLlxuICAgKi9cbiAgdmFyIEVsZW1lbnRBc3QgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gRWxlbWVudEFzdChuYW1lLCBhdHRycywgaW5wdXRzLCBvdXRwdXRzLCByZWZlcmVuY2VzLCBkaXJlY3RpdmVzLCBwcm92aWRlcnMsIGhhc1ZpZXdDb250YWluZXIsIGNoaWxkcmVuLCBuZ0NvbnRlbnRJbmRleCwgc291cmNlU3BhbiwgZW5kU291cmNlU3Bhbikge1xuICAgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgICAgdGhpcy5hdHRycyA9IGF0dHJzO1xuICAgICAgICAgIHRoaXMuaW5wdXRzID0gaW5wdXRzO1xuICAgICAgICAgIHRoaXMub3V0cHV0cyA9IG91dHB1dHM7XG4gICAgICAgICAgdGhpcy5yZWZlcmVuY2VzID0gcmVmZXJlbmNlcztcbiAgICAgICAgICB0aGlzLmRpcmVjdGl2ZXMgPSBkaXJlY3RpdmVzO1xuICAgICAgICAgIHRoaXMucHJvdmlkZXJzID0gcHJvdmlkZXJzO1xuICAgICAgICAgIHRoaXMuaGFzVmlld0NvbnRhaW5lciA9IGhhc1ZpZXdDb250YWluZXI7XG4gICAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgICAgIHRoaXMubmdDb250ZW50SW5kZXggPSBuZ0NvbnRlbnRJbmRleDtcbiAgICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgICAgICAgIHRoaXMuZW5kU291cmNlU3BhbiA9IGVuZFNvdXJjZVNwYW47XG4gICAgICB9XG4gICAgICBFbGVtZW50QXN0LnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRFbGVtZW50KHRoaXMsIGNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBFbGVtZW50QXN0O1xuICB9KCkpO1xuICAvKipcbiAgICogQSBgPHRlbXBsYXRlPmAgZWxlbWVudCBpbmNsdWRlZCBpbiBhbiBBbmd1bGFyIHRlbXBsYXRlLlxuICAgKi9cbiAgdmFyIEVtYmVkZGVkVGVtcGxhdGVBc3QgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gRW1iZWRkZWRUZW1wbGF0ZUFzdChhdHRycywgb3V0cHV0cywgcmVmZXJlbmNlcywgdmFyaWFibGVzLCBkaXJlY3RpdmVzLCBwcm92aWRlcnMsIGhhc1ZpZXdDb250YWluZXIsIGNoaWxkcmVuLCBuZ0NvbnRlbnRJbmRleCwgc291cmNlU3Bhbikge1xuICAgICAgICAgIHRoaXMuYXR0cnMgPSBhdHRycztcbiAgICAgICAgICB0aGlzLm91dHB1dHMgPSBvdXRwdXRzO1xuICAgICAgICAgIHRoaXMucmVmZXJlbmNlcyA9IHJlZmVyZW5jZXM7XG4gICAgICAgICAgdGhpcy52YXJpYWJsZXMgPSB2YXJpYWJsZXM7XG4gICAgICAgICAgdGhpcy5kaXJlY3RpdmVzID0gZGlyZWN0aXZlcztcbiAgICAgICAgICB0aGlzLnByb3ZpZGVycyA9IHByb3ZpZGVycztcbiAgICAgICAgICB0aGlzLmhhc1ZpZXdDb250YWluZXIgPSBoYXNWaWV3Q29udGFpbmVyO1xuICAgICAgICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICAgICAgICB0aGlzLm5nQ29udGVudEluZGV4ID0gbmdDb250ZW50SW5kZXg7XG4gICAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICAgIH1cbiAgICAgIEVtYmVkZGVkVGVtcGxhdGVBc3QucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEVtYmVkZGVkVGVtcGxhdGUodGhpcywgY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIEVtYmVkZGVkVGVtcGxhdGVBc3Q7XG4gIH0oKSk7XG4gIC8qKlxuICAgKiBBIGRpcmVjdGl2ZSBwcm9wZXJ0eSB3aXRoIGEgYm91bmQgdmFsdWUgKGUuZy4gYCpuZ0lmPVwiY29uZGl0aW9uXCIpLlxuICAgKi9cbiAgdmFyIEJvdW5kRGlyZWN0aXZlUHJvcGVydHlBc3QgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gQm91bmREaXJlY3RpdmVQcm9wZXJ0eUFzdChkaXJlY3RpdmVOYW1lLCB0ZW1wbGF0ZU5hbWUsIHZhbHVlLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgICAgdGhpcy5kaXJlY3RpdmVOYW1lID0gZGlyZWN0aXZlTmFtZTtcbiAgICAgICAgICB0aGlzLnRlbXBsYXRlTmFtZSA9IHRlbXBsYXRlTmFtZTtcbiAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICAgIH1cbiAgICAgIEJvdW5kRGlyZWN0aXZlUHJvcGVydHlBc3QucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdERpcmVjdGl2ZVByb3BlcnR5KHRoaXMsIGNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBCb3VuZERpcmVjdGl2ZVByb3BlcnR5QXN0O1xuICB9KCkpO1xuICAvKipcbiAgICogQSBkaXJlY3RpdmUgZGVjbGFyZWQgb24gYW4gZWxlbWVudC5cbiAgICovXG4gIHZhciBEaXJlY3RpdmVBc3QgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gRGlyZWN0aXZlQXN0KGRpcmVjdGl2ZSwgaW5wdXRzLCBob3N0UHJvcGVydGllcywgaG9zdEV2ZW50cywgc291cmNlU3Bhbikge1xuICAgICAgICAgIHRoaXMuZGlyZWN0aXZlID0gZGlyZWN0aXZlO1xuICAgICAgICAgIHRoaXMuaW5wdXRzID0gaW5wdXRzO1xuICAgICAgICAgIHRoaXMuaG9zdFByb3BlcnRpZXMgPSBob3N0UHJvcGVydGllcztcbiAgICAgICAgICB0aGlzLmhvc3RFdmVudHMgPSBob3N0RXZlbnRzO1xuICAgICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgICB9XG4gICAgICBEaXJlY3RpdmVBc3QucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdERpcmVjdGl2ZSh0aGlzLCBjb250ZXh0KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gRGlyZWN0aXZlQXN0O1xuICB9KCkpO1xuICAvKipcbiAgICogQSBwcm92aWRlciBkZWNsYXJlZCBvbiBhbiBlbGVtZW50XG4gICAqL1xuICB2YXIgUHJvdmlkZXJBc3QgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gUHJvdmlkZXJBc3QodG9rZW4sIG11bHRpUHJvdmlkZXIsIGVhZ2VyLCBwcm92aWRlcnMsIHByb3ZpZGVyVHlwZSwgbGlmZWN5Y2xlSG9va3MsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgICB0aGlzLnRva2VuID0gdG9rZW47XG4gICAgICAgICAgdGhpcy5tdWx0aVByb3ZpZGVyID0gbXVsdGlQcm92aWRlcjtcbiAgICAgICAgICB0aGlzLmVhZ2VyID0gZWFnZXI7XG4gICAgICAgICAgdGhpcy5wcm92aWRlcnMgPSBwcm92aWRlcnM7XG4gICAgICAgICAgdGhpcy5wcm92aWRlclR5cGUgPSBwcm92aWRlclR5cGU7XG4gICAgICAgICAgdGhpcy5saWZlY3ljbGVIb29rcyA9IGxpZmVjeWNsZUhvb2tzO1xuICAgICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgICB9XG4gICAgICBQcm92aWRlckFzdC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICAgIC8vIE5vIHZpc2l0IG1ldGhvZCBpbiB0aGUgdmlzaXRvciBmb3Igbm93Li4uXG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIFByb3ZpZGVyQXN0O1xuICB9KCkpO1xuICBleHBvcnRzLlByb3ZpZGVyQXN0VHlwZTtcbiAgKGZ1bmN0aW9uIChQcm92aWRlckFzdFR5cGUpIHtcbiAgICAgIFByb3ZpZGVyQXN0VHlwZVtQcm92aWRlckFzdFR5cGVbXCJQdWJsaWNTZXJ2aWNlXCJdID0gMF0gPSBcIlB1YmxpY1NlcnZpY2VcIjtcbiAgICAgIFByb3ZpZGVyQXN0VHlwZVtQcm92aWRlckFzdFR5cGVbXCJQcml2YXRlU2VydmljZVwiXSA9IDFdID0gXCJQcml2YXRlU2VydmljZVwiO1xuICAgICAgUHJvdmlkZXJBc3RUeXBlW1Byb3ZpZGVyQXN0VHlwZVtcIkNvbXBvbmVudFwiXSA9IDJdID0gXCJDb21wb25lbnRcIjtcbiAgICAgIFByb3ZpZGVyQXN0VHlwZVtQcm92aWRlckFzdFR5cGVbXCJEaXJlY3RpdmVcIl0gPSAzXSA9IFwiRGlyZWN0aXZlXCI7XG4gICAgICBQcm92aWRlckFzdFR5cGVbUHJvdmlkZXJBc3RUeXBlW1wiQnVpbHRpblwiXSA9IDRdID0gXCJCdWlsdGluXCI7XG4gIH0pKGV4cG9ydHMuUHJvdmlkZXJBc3RUeXBlIHx8IChleHBvcnRzLlByb3ZpZGVyQXN0VHlwZSA9IHt9KSk7XG4gIC8qKlxuICAgKiBQb3NpdGlvbiB3aGVyZSBjb250ZW50IGlzIHRvIGJlIHByb2plY3RlZCAoaW5zdGFuY2Ugb2YgYDxuZy1jb250ZW50PmAgaW4gYSB0ZW1wbGF0ZSkuXG4gICAqL1xuICB2YXIgTmdDb250ZW50QXN0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIE5nQ29udGVudEFzdChpbmRleCwgbmdDb250ZW50SW5kZXgsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgdGhpcy5uZ0NvbnRlbnRJbmRleCA9IG5nQ29udGVudEluZGV4O1xuICAgICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgICB9XG4gICAgICBOZ0NvbnRlbnRBc3QucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdE5nQ29udGVudCh0aGlzLCBjb250ZXh0KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gTmdDb250ZW50QXN0O1xuICB9KCkpO1xuICAvKipcbiAgICogRW51bWVyYXRpb24gb2YgdHlwZXMgb2YgcHJvcGVydHkgYmluZGluZ3MuXG4gICAqL1xuICBleHBvcnRzLlByb3BlcnR5QmluZGluZ1R5cGU7XG4gIChmdW5jdGlvbiAoUHJvcGVydHlCaW5kaW5nVHlwZSkge1xuICAgICAgLyoqXG4gICAgICAgKiBBIG5vcm1hbCBiaW5kaW5nIHRvIGEgcHJvcGVydHkgKGUuZy4gYFtwcm9wZXJ0eV09XCJleHByZXNzaW9uXCJgKS5cbiAgICAgICAqL1xuICAgICAgUHJvcGVydHlCaW5kaW5nVHlwZVtQcm9wZXJ0eUJpbmRpbmdUeXBlW1wiUHJvcGVydHlcIl0gPSAwXSA9IFwiUHJvcGVydHlcIjtcbiAgICAgIC8qKlxuICAgICAgICogQSBiaW5kaW5nIHRvIGFuIGVsZW1lbnQgYXR0cmlidXRlIChlLmcuIGBbYXR0ci5uYW1lXT1cImV4cHJlc3Npb25cImApLlxuICAgICAgICovXG4gICAgICBQcm9wZXJ0eUJpbmRpbmdUeXBlW1Byb3BlcnR5QmluZGluZ1R5cGVbXCJBdHRyaWJ1dGVcIl0gPSAxXSA9IFwiQXR0cmlidXRlXCI7XG4gICAgICAvKipcbiAgICAgICAqIEEgYmluZGluZyB0byBhIENTUyBjbGFzcyAoZS5nLiBgW2NsYXNzLm5hbWVdPVwiY29uZGl0aW9uXCJgKS5cbiAgICAgICAqL1xuICAgICAgUHJvcGVydHlCaW5kaW5nVHlwZVtQcm9wZXJ0eUJpbmRpbmdUeXBlW1wiQ2xhc3NcIl0gPSAyXSA9IFwiQ2xhc3NcIjtcbiAgICAgIC8qKlxuICAgICAgICogQSBiaW5kaW5nIHRvIGEgc3R5bGUgcnVsZSAoZS5nLiBgW3N0eWxlLnJ1bGVdPVwiZXhwcmVzc2lvblwiYCkuXG4gICAgICAgKi9cbiAgICAgIFByb3BlcnR5QmluZGluZ1R5cGVbUHJvcGVydHlCaW5kaW5nVHlwZVtcIlN0eWxlXCJdID0gM10gPSBcIlN0eWxlXCI7XG4gICAgICAvKipcbiAgICAgICAqIEEgYmluZGluZyB0byBhbiBhbmltYXRpb24gcmVmZXJlbmNlIChlLmcuIGBbYW5pbWF0ZS5rZXldPVwiZXhwcmVzc2lvblwiYCkuXG4gICAgICAgKi9cbiAgICAgIFByb3BlcnR5QmluZGluZ1R5cGVbUHJvcGVydHlCaW5kaW5nVHlwZVtcIkFuaW1hdGlvblwiXSA9IDRdID0gXCJBbmltYXRpb25cIjtcbiAgfSkoZXhwb3J0cy5Qcm9wZXJ0eUJpbmRpbmdUeXBlIHx8IChleHBvcnRzLlByb3BlcnR5QmluZGluZ1R5cGUgPSB7fSkpO1xuICAvKipcbiAgICogVmlzaXQgZXZlcnkgbm9kZSBpbiBhIGxpc3Qgb2Yge0BsaW5rIFRlbXBsYXRlQXN0fXMgd2l0aCB0aGUgZ2l2ZW4ge0BsaW5rIFRlbXBsYXRlQXN0VmlzaXRvcn0uXG4gICAqL1xuICBmdW5jdGlvbiB0ZW1wbGF0ZVZpc2l0QWxsKHZpc2l0b3IsIGFzdHMsIGNvbnRleHQpIHtcbiAgICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHsgY29udGV4dCA9IG51bGw7IH1cbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIHZhciB2aXNpdCA9IHZpc2l0b3IudmlzaXQgP1xuICAgICAgICAgIGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIHZpc2l0b3IudmlzaXQoYXN0LCBjb250ZXh0KSB8fCBhc3QudmlzaXQodmlzaXRvciwgY29udGV4dCk7IH0gOlxuICAgICAgICAgIGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIGFzdC52aXNpdCh2aXNpdG9yLCBjb250ZXh0KTsgfTtcbiAgICAgIGFzdHMuZm9yRWFjaChmdW5jdGlvbiAoYXN0KSB7XG4gICAgICAgICAgdmFyIGFzdFJlc3VsdCA9IHZpc2l0KGFzdCk7XG4gICAgICAgICAgaWYgKGFzdFJlc3VsdCkge1xuICAgICAgICAgICAgICByZXN1bHQucHVzaChhc3RSZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzUHJlc2VudChvYmopIHtcbiAgICAgIHJldHVybiBvYmogIT0gbnVsbDtcbiAgfVxuICBmdW5jdGlvbiBpc0JsYW5rKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiA9PSBudWxsO1xuICB9XG4gIHZhciBTVFJJTkdfTUFQX1BST1RPID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHt9KTtcbiAgZnVuY3Rpb24gaXNTdHJpY3RTdHJpbmdNYXAob2JqKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgb2JqICE9PSBudWxsICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmopID09PSBTVFJJTkdfTUFQX1BST1RPO1xuICB9XG4gIGZ1bmN0aW9uIHN0cmluZ2lmeSh0b2tlbikge1xuICAgICAgaWYgKHR5cGVvZiB0b2tlbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICB9XG4gICAgICBpZiAodG9rZW4gPT09IHVuZGVmaW5lZCB8fCB0b2tlbiA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiAnJyArIHRva2VuO1xuICAgICAgfVxuICAgICAgaWYgKHRva2VuLm92ZXJyaWRkZW5OYW1lKSB7XG4gICAgICAgICAgcmV0dXJuIHRva2VuLm92ZXJyaWRkZW5OYW1lO1xuICAgICAgfVxuICAgICAgaWYgKHRva2VuLm5hbWUpIHtcbiAgICAgICAgICByZXR1cm4gdG9rZW4ubmFtZTtcbiAgICAgIH1cbiAgICAgIHZhciByZXMgPSB0b2tlbi50b1N0cmluZygpO1xuICAgICAgdmFyIG5ld0xpbmVJbmRleCA9IHJlcy5pbmRleE9mKCdcXG4nKTtcbiAgICAgIHJldHVybiBuZXdMaW5lSW5kZXggPT09IC0xID8gcmVzIDogcmVzLnN1YnN0cmluZygwLCBuZXdMaW5lSW5kZXgpO1xuICB9XG4gIHZhciBOdW1iZXJXcmFwcGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIE51bWJlcldyYXBwZXIoKSB7XG4gICAgICB9XG4gICAgICBOdW1iZXJXcmFwcGVyLnBhcnNlSW50QXV0b1JhZGl4ID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gcGFyc2VJbnQodGV4dCk7XG4gICAgICAgICAgaWYgKGlzTmFOKHJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGludGVnZXIgbGl0ZXJhbCB3aGVuIHBhcnNpbmcgJyArIHRleHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICAgIE51bWJlcldyYXBwZXIucGFyc2VJbnQgPSBmdW5jdGlvbiAodGV4dCwgcmFkaXgpIHtcbiAgICAgICAgICBpZiAocmFkaXggPT0gMTApIHtcbiAgICAgICAgICAgICAgaWYgKC9eKFxcLXxcXCspP1swLTldKyQvLnRlc3QodGV4dCkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUludCh0ZXh0LCByYWRpeCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAocmFkaXggPT0gMTYpIHtcbiAgICAgICAgICAgICAgaWYgKC9eKFxcLXxcXCspP1swLTlBQkNERUZhYmNkZWZdKyQvLnRlc3QodGV4dCkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUludCh0ZXh0LCByYWRpeCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHZhciByZXN1bHQgPSBwYXJzZUludCh0ZXh0LCByYWRpeCk7XG4gICAgICAgICAgICAgIGlmICghaXNOYU4ocmVzdWx0KSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW50ZWdlciBsaXRlcmFsIHdoZW4gcGFyc2luZyAnICsgdGV4dCArICcgaW4gYmFzZSAnICsgcmFkaXgpO1xuICAgICAgfTtcbiAgICAgIE51bWJlcldyYXBwZXIuaXNOdW1lcmljID0gZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiAhaXNOYU4odmFsdWUgLSBwYXJzZUZsb2F0KHZhbHVlKSk7IH07XG4gICAgICByZXR1cm4gTnVtYmVyV3JhcHBlcjtcbiAgfSgpKTtcbiAgZnVuY3Rpb24gaXNKc09iamVjdChvKSB7XG4gICAgICByZXR1cm4gbyAhPT0gbnVsbCAmJiAodHlwZW9mIG8gPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIG8gPT09ICdvYmplY3QnKTtcbiAgfVxuICBmdW5jdGlvbiBpc1ByaW1pdGl2ZShvYmopIHtcbiAgICAgIHJldHVybiAhaXNKc09iamVjdChvYmopO1xuICB9XG4gIGZ1bmN0aW9uIGVzY2FwZVJlZ0V4cChzKSB7XG4gICAgICByZXR1cm4gcy5yZXBsYWNlKC8oWy4qKz9ePSE6JHt9KCl8W1xcXVxcL1xcXFxdKS9nLCAnXFxcXCQxJyk7XG4gIH1cblxuICAvLyBTYWZhcmkgZG9lc24ndCBpbXBsZW1lbnQgTWFwSXRlcmF0b3IubmV4dCgpLCB3aGljaCBpcyB1c2VkIGlzIFRyYWNldXIncyBwb2x5ZmlsbCBvZiBBcnJheS5mcm9tXG4gIC8vIFRPRE8obWxhdmFsKTogcmVtb3ZlIHRoZSB3b3JrIGFyb3VuZCBvbmNlIHdlIGhhdmUgYSB3b3JraW5nIHBvbHlmaWxsIG9mIEFycmF5LmZyb21cbiAgdmFyIF9hcnJheUZyb21NYXAgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoKG5ldyBNYXAoKSkudmFsdWVzKCkubmV4dCkge1xuICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlQXJyYXlGcm9tTWFwKG0sIGdldFZhbHVlcykge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldFZhbHVlcyA/IEFycmF5LmZyb20obS52YWx1ZXMoKSkgOiBBcnJheS5mcm9tKG0ua2V5cygpKTtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICBjYXRjaCAoZSkge1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZUFycmF5RnJvbU1hcFdpdGhGb3JlYWNoKG0sIGdldFZhbHVlcykge1xuICAgICAgICAgIHZhciByZXMgPSBuZXcgQXJyYXkobS5zaXplKSwgaSA9IDA7XG4gICAgICAgICAgbS5mb3JFYWNoKGZ1bmN0aW9uICh2LCBrKSB7XG4gICAgICAgICAgICAgIHJlc1tpXSA9IGdldFZhbHVlcyA/IHYgOiBrO1xuICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH07XG4gIH0pKCk7XG4gIHZhciBNYXBXcmFwcGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIE1hcFdyYXBwZXIoKSB7XG4gICAgICB9XG4gICAgICBNYXBXcmFwcGVyLmNyZWF0ZUZyb21TdHJpbmdNYXAgPSBmdW5jdGlvbiAoc3RyaW5nTWFwKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBNYXAoKTtcbiAgICAgICAgICBmb3IgKHZhciBwcm9wIGluIHN0cmluZ01hcCkge1xuICAgICAgICAgICAgICByZXN1bHQuc2V0KHByb3AsIHN0cmluZ01hcFtwcm9wXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgICAgTWFwV3JhcHBlci5rZXlzID0gZnVuY3Rpb24gKG0pIHsgcmV0dXJuIF9hcnJheUZyb21NYXAobSwgZmFsc2UpOyB9O1xuICAgICAgTWFwV3JhcHBlci52YWx1ZXMgPSBmdW5jdGlvbiAobSkgeyByZXR1cm4gX2FycmF5RnJvbU1hcChtLCB0cnVlKTsgfTtcbiAgICAgIHJldHVybiBNYXBXcmFwcGVyO1xuICB9KCkpO1xuICAvKipcbiAgICogV3JhcHMgSmF2YXNjcmlwdCBPYmplY3RzXG4gICAqL1xuICB2YXIgU3RyaW5nTWFwV3JhcHBlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBTdHJpbmdNYXBXcmFwcGVyKCkge1xuICAgICAgfVxuICAgICAgU3RyaW5nTWFwV3JhcHBlci5tZXJnZSA9IGZ1bmN0aW9uIChtMSwgbTIpIHtcbiAgICAgICAgICB2YXIgbSA9IHt9O1xuICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBPYmplY3Qua2V5cyhtMSk7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgIHZhciBrID0gX2FbX2ldO1xuICAgICAgICAgICAgICBtW2tdID0gbTFba107XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAodmFyIF9iID0gMCwgX2MgPSBPYmplY3Qua2V5cyhtMik7IF9iIDwgX2MubGVuZ3RoOyBfYisrKSB7XG4gICAgICAgICAgICAgIHZhciBrID0gX2NbX2JdO1xuICAgICAgICAgICAgICBtW2tdID0gbTJba107XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBtO1xuICAgICAgfTtcbiAgICAgIFN0cmluZ01hcFdyYXBwZXIuZXF1YWxzID0gZnVuY3Rpb24gKG0xLCBtMikge1xuICAgICAgICAgIHZhciBrMSA9IE9iamVjdC5rZXlzKG0xKTtcbiAgICAgICAgICB2YXIgazIgPSBPYmplY3Qua2V5cyhtMik7XG4gICAgICAgICAgaWYgKGsxLmxlbmd0aCAhPSBrMi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGsxLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIHZhciBrZXkgPSBrMVtpXTtcbiAgICAgICAgICAgICAgaWYgKG0xW2tleV0gIT09IG0yW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gU3RyaW5nTWFwV3JhcHBlcjtcbiAgfSgpKTtcbiAgdmFyIExpc3RXcmFwcGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIExpc3RXcmFwcGVyKCkge1xuICAgICAgfVxuICAgICAgTGlzdFdyYXBwZXIucmVtb3ZlQWxsID0gZnVuY3Rpb24gKGxpc3QsIGl0ZW1zKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICB2YXIgaW5kZXggPSBsaXN0LmluZGV4T2YoaXRlbXNbaV0pO1xuICAgICAgICAgICAgICBsaXN0LnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIExpc3RXcmFwcGVyLnJlbW92ZSA9IGZ1bmN0aW9uIChsaXN0LCBlbCkge1xuICAgICAgICAgIHZhciBpbmRleCA9IGxpc3QuaW5kZXhPZihlbCk7XG4gICAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgbGlzdC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfTtcbiAgICAgIExpc3RXcmFwcGVyLmVxdWFscyA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgaWYgKGEubGVuZ3RoICE9IGIubGVuZ3RoKVxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgIGlmIChhW2ldICE9PSBiW2ldKVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH07XG4gICAgICBMaXN0V3JhcHBlci5tYXhpbXVtID0gZnVuY3Rpb24gKGxpc3QsIHByZWRpY2F0ZSkge1xuICAgICAgICAgIGlmIChsaXN0Lmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgc29sdXRpb24gPSBudWxsO1xuICAgICAgICAgIHZhciBtYXhWYWx1ZSA9IC1JbmZpbml0eTtcbiAgICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGlzdC5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IGxpc3RbaW5kZXhdO1xuICAgICAgICAgICAgICBpZiAoY2FuZGlkYXRlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhciBjYW5kaWRhdGVWYWx1ZSA9IHByZWRpY2F0ZShjYW5kaWRhdGUpO1xuICAgICAgICAgICAgICBpZiAoY2FuZGlkYXRlVmFsdWUgPiBtYXhWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgc29sdXRpb24gPSBjYW5kaWRhdGU7XG4gICAgICAgICAgICAgICAgICBtYXhWYWx1ZSA9IGNhbmRpZGF0ZVZhbHVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBzb2x1dGlvbjtcbiAgICAgIH07XG4gICAgICBMaXN0V3JhcHBlci5mbGF0dGVuID0gZnVuY3Rpb24gKGxpc3QpIHtcbiAgICAgICAgICB2YXIgdGFyZ2V0ID0gW107XG4gICAgICAgICAgX2ZsYXR0ZW5BcnJheShsaXN0LCB0YXJnZXQpO1xuICAgICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIExpc3RXcmFwcGVyO1xuICB9KCkpO1xuICBmdW5jdGlvbiBfZmxhdHRlbkFycmF5KHNvdXJjZSwgdGFyZ2V0KSB7XG4gICAgICBpZiAoaXNQcmVzZW50KHNvdXJjZSkpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNvdXJjZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICB2YXIgaXRlbSA9IHNvdXJjZVtpXTtcbiAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICAgIF9mbGF0dGVuQXJyYXkoaXRlbSwgdGFyZ2V0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHRhcmdldC5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbGljZW5zZVxuICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICpcbiAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgKi9cbiAgdmFyIFRhZ0NvbnRlbnRUeXBlO1xuICAoZnVuY3Rpb24gKFRhZ0NvbnRlbnRUeXBlKSB7XG4gICAgICBUYWdDb250ZW50VHlwZVtUYWdDb250ZW50VHlwZVtcIlJBV19URVhUXCJdID0gMF0gPSBcIlJBV19URVhUXCI7XG4gICAgICBUYWdDb250ZW50VHlwZVtUYWdDb250ZW50VHlwZVtcIkVTQ0FQQUJMRV9SQVdfVEVYVFwiXSA9IDFdID0gXCJFU0NBUEFCTEVfUkFXX1RFWFRcIjtcbiAgICAgIFRhZ0NvbnRlbnRUeXBlW1RhZ0NvbnRlbnRUeXBlW1wiUEFSU0FCTEVfREFUQVwiXSA9IDJdID0gXCJQQVJTQUJMRV9EQVRBXCI7XG4gIH0pKFRhZ0NvbnRlbnRUeXBlIHx8IChUYWdDb250ZW50VHlwZSA9IHt9KSk7XG4gIGZ1bmN0aW9uIHNwbGl0TnNOYW1lKGVsZW1lbnROYW1lKSB7XG4gICAgICBpZiAoZWxlbWVudE5hbWVbMF0gIT0gJzonKSB7XG4gICAgICAgICAgcmV0dXJuIFtudWxsLCBlbGVtZW50TmFtZV07XG4gICAgICB9XG4gICAgICB2YXIgY29sb25JbmRleCA9IGVsZW1lbnROYW1lLmluZGV4T2YoJzonLCAxKTtcbiAgICAgIGlmIChjb2xvbkluZGV4ID09IC0xKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgZm9ybWF0IFxcXCJcIiArIGVsZW1lbnROYW1lICsgXCJcXFwiIGV4cGVjdGluZyBcXFwiOm5hbWVzcGFjZTpuYW1lXFxcIlwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbZWxlbWVudE5hbWUuc2xpY2UoMSwgY29sb25JbmRleCksIGVsZW1lbnROYW1lLnNsaWNlKGNvbG9uSW5kZXggKyAxKV07XG4gIH1cbiAgZnVuY3Rpb24gZ2V0TnNQcmVmaXgoZnVsbE5hbWUpIHtcbiAgICAgIHJldHVybiBmdWxsTmFtZSA9PT0gbnVsbCA/IG51bGwgOiBzcGxpdE5zTmFtZShmdWxsTmFtZSlbMF07XG4gIH1cbiAgZnVuY3Rpb24gbWVyZ2VOc0FuZE5hbWUocHJlZml4LCBsb2NhbE5hbWUpIHtcbiAgICAgIHJldHVybiBwcmVmaXggPyBcIjpcIiArIHByZWZpeCArIFwiOlwiICsgbG9jYWxOYW1lIDogbG9jYWxOYW1lO1xuICB9XG4gIC8vIHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNTEvc3ludGF4Lmh0bWwjbmFtZWQtY2hhcmFjdGVyLXJlZmVyZW5jZXNcbiAgLy8gc2VlIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2VudGl0aWVzLmpzb25cbiAgLy8gVGhpcyBsaXN0IGlzIG5vdCBleGhhdXN0aXZlIHRvIGtlZXAgdGhlIGNvbXBpbGVyIGZvb3RwcmludCBsb3cuXG4gIC8vIFRoZSBgJiMxMjM7YCAvIGAmI3gxYWI7YCBzeW50YXggc2hvdWxkIGJlIHVzZWQgd2hlbiB0aGUgbmFtZWQgY2hhcmFjdGVyIHJlZmVyZW5jZSBkb2VzIG5vdCBleGlzdC5cbiAgdmFyIE5BTUVEX0VOVElUSUVTID0ge1xuICAgICAgJ0FhY3V0ZSc6ICdcXHUwMEMxJyxcbiAgICAgICdhYWN1dGUnOiAnXFx1MDBFMScsXG4gICAgICAnQWNpcmMnOiAnXFx1MDBDMicsXG4gICAgICAnYWNpcmMnOiAnXFx1MDBFMicsXG4gICAgICAnYWN1dGUnOiAnXFx1MDBCNCcsXG4gICAgICAnQUVsaWcnOiAnXFx1MDBDNicsXG4gICAgICAnYWVsaWcnOiAnXFx1MDBFNicsXG4gICAgICAnQWdyYXZlJzogJ1xcdTAwQzAnLFxuICAgICAgJ2FncmF2ZSc6ICdcXHUwMEUwJyxcbiAgICAgICdhbGVmc3ltJzogJ1xcdTIxMzUnLFxuICAgICAgJ0FscGhhJzogJ1xcdTAzOTEnLFxuICAgICAgJ2FscGhhJzogJ1xcdTAzQjEnLFxuICAgICAgJ2FtcCc6ICcmJyxcbiAgICAgICdhbmQnOiAnXFx1MjIyNycsXG4gICAgICAnYW5nJzogJ1xcdTIyMjAnLFxuICAgICAgJ2Fwb3MnOiAnXFx1MDAyNycsXG4gICAgICAnQXJpbmcnOiAnXFx1MDBDNScsXG4gICAgICAnYXJpbmcnOiAnXFx1MDBFNScsXG4gICAgICAnYXN5bXAnOiAnXFx1MjI0OCcsXG4gICAgICAnQXRpbGRlJzogJ1xcdTAwQzMnLFxuICAgICAgJ2F0aWxkZSc6ICdcXHUwMEUzJyxcbiAgICAgICdBdW1sJzogJ1xcdTAwQzQnLFxuICAgICAgJ2F1bWwnOiAnXFx1MDBFNCcsXG4gICAgICAnYmRxdW8nOiAnXFx1MjAxRScsXG4gICAgICAnQmV0YSc6ICdcXHUwMzkyJyxcbiAgICAgICdiZXRhJzogJ1xcdTAzQjInLFxuICAgICAgJ2JydmJhcic6ICdcXHUwMEE2JyxcbiAgICAgICdidWxsJzogJ1xcdTIwMjInLFxuICAgICAgJ2NhcCc6ICdcXHUyMjI5JyxcbiAgICAgICdDY2VkaWwnOiAnXFx1MDBDNycsXG4gICAgICAnY2NlZGlsJzogJ1xcdTAwRTcnLFxuICAgICAgJ2NlZGlsJzogJ1xcdTAwQjgnLFxuICAgICAgJ2NlbnQnOiAnXFx1MDBBMicsXG4gICAgICAnQ2hpJzogJ1xcdTAzQTcnLFxuICAgICAgJ2NoaSc6ICdcXHUwM0M3JyxcbiAgICAgICdjaXJjJzogJ1xcdTAyQzYnLFxuICAgICAgJ2NsdWJzJzogJ1xcdTI2NjMnLFxuICAgICAgJ2NvbmcnOiAnXFx1MjI0NScsXG4gICAgICAnY29weSc6ICdcXHUwMEE5JyxcbiAgICAgICdjcmFycic6ICdcXHUyMUI1JyxcbiAgICAgICdjdXAnOiAnXFx1MjIyQScsXG4gICAgICAnY3VycmVuJzogJ1xcdTAwQTQnLFxuICAgICAgJ2RhZ2dlcic6ICdcXHUyMDIwJyxcbiAgICAgICdEYWdnZXInOiAnXFx1MjAyMScsXG4gICAgICAnZGFycic6ICdcXHUyMTkzJyxcbiAgICAgICdkQXJyJzogJ1xcdTIxRDMnLFxuICAgICAgJ2RlZyc6ICdcXHUwMEIwJyxcbiAgICAgICdEZWx0YSc6ICdcXHUwMzk0JyxcbiAgICAgICdkZWx0YSc6ICdcXHUwM0I0JyxcbiAgICAgICdkaWFtcyc6ICdcXHUyNjY2JyxcbiAgICAgICdkaXZpZGUnOiAnXFx1MDBGNycsXG4gICAgICAnRWFjdXRlJzogJ1xcdTAwQzknLFxuICAgICAgJ2VhY3V0ZSc6ICdcXHUwMEU5JyxcbiAgICAgICdFY2lyYyc6ICdcXHUwMENBJyxcbiAgICAgICdlY2lyYyc6ICdcXHUwMEVBJyxcbiAgICAgICdFZ3JhdmUnOiAnXFx1MDBDOCcsXG4gICAgICAnZWdyYXZlJzogJ1xcdTAwRTgnLFxuICAgICAgJ2VtcHR5JzogJ1xcdTIyMDUnLFxuICAgICAgJ2Vtc3AnOiAnXFx1MjAwMycsXG4gICAgICAnZW5zcCc6ICdcXHUyMDAyJyxcbiAgICAgICdFcHNpbG9uJzogJ1xcdTAzOTUnLFxuICAgICAgJ2Vwc2lsb24nOiAnXFx1MDNCNScsXG4gICAgICAnZXF1aXYnOiAnXFx1MjI2MScsXG4gICAgICAnRXRhJzogJ1xcdTAzOTcnLFxuICAgICAgJ2V0YSc6ICdcXHUwM0I3JyxcbiAgICAgICdFVEgnOiAnXFx1MDBEMCcsXG4gICAgICAnZXRoJzogJ1xcdTAwRjAnLFxuICAgICAgJ0V1bWwnOiAnXFx1MDBDQicsXG4gICAgICAnZXVtbCc6ICdcXHUwMEVCJyxcbiAgICAgICdldXJvJzogJ1xcdTIwQUMnLFxuICAgICAgJ2V4aXN0JzogJ1xcdTIyMDMnLFxuICAgICAgJ2Zub2YnOiAnXFx1MDE5MicsXG4gICAgICAnZm9yYWxsJzogJ1xcdTIyMDAnLFxuICAgICAgJ2ZyYWMxMic6ICdcXHUwMEJEJyxcbiAgICAgICdmcmFjMTQnOiAnXFx1MDBCQycsXG4gICAgICAnZnJhYzM0JzogJ1xcdTAwQkUnLFxuICAgICAgJ2ZyYXNsJzogJ1xcdTIwNDQnLFxuICAgICAgJ0dhbW1hJzogJ1xcdTAzOTMnLFxuICAgICAgJ2dhbW1hJzogJ1xcdTAzQjMnLFxuICAgICAgJ2dlJzogJ1xcdTIyNjUnLFxuICAgICAgJ2d0JzogJz4nLFxuICAgICAgJ2hhcnInOiAnXFx1MjE5NCcsXG4gICAgICAnaEFycic6ICdcXHUyMUQ0JyxcbiAgICAgICdoZWFydHMnOiAnXFx1MjY2NScsXG4gICAgICAnaGVsbGlwJzogJ1xcdTIwMjYnLFxuICAgICAgJ0lhY3V0ZSc6ICdcXHUwMENEJyxcbiAgICAgICdpYWN1dGUnOiAnXFx1MDBFRCcsXG4gICAgICAnSWNpcmMnOiAnXFx1MDBDRScsXG4gICAgICAnaWNpcmMnOiAnXFx1MDBFRScsXG4gICAgICAnaWV4Y2wnOiAnXFx1MDBBMScsXG4gICAgICAnSWdyYXZlJzogJ1xcdTAwQ0MnLFxuICAgICAgJ2lncmF2ZSc6ICdcXHUwMEVDJyxcbiAgICAgICdpbWFnZSc6ICdcXHUyMTExJyxcbiAgICAgICdpbmZpbic6ICdcXHUyMjFFJyxcbiAgICAgICdpbnQnOiAnXFx1MjIyQicsXG4gICAgICAnSW90YSc6ICdcXHUwMzk5JyxcbiAgICAgICdpb3RhJzogJ1xcdTAzQjknLFxuICAgICAgJ2lxdWVzdCc6ICdcXHUwMEJGJyxcbiAgICAgICdpc2luJzogJ1xcdTIyMDgnLFxuICAgICAgJ0l1bWwnOiAnXFx1MDBDRicsXG4gICAgICAnaXVtbCc6ICdcXHUwMEVGJyxcbiAgICAgICdLYXBwYSc6ICdcXHUwMzlBJyxcbiAgICAgICdrYXBwYSc6ICdcXHUwM0JBJyxcbiAgICAgICdMYW1iZGEnOiAnXFx1MDM5QicsXG4gICAgICAnbGFtYmRhJzogJ1xcdTAzQkInLFxuICAgICAgJ2xhbmcnOiAnXFx1MjdFOCcsXG4gICAgICAnbGFxdW8nOiAnXFx1MDBBQicsXG4gICAgICAnbGFycic6ICdcXHUyMTkwJyxcbiAgICAgICdsQXJyJzogJ1xcdTIxRDAnLFxuICAgICAgJ2xjZWlsJzogJ1xcdTIzMDgnLFxuICAgICAgJ2xkcXVvJzogJ1xcdTIwMUMnLFxuICAgICAgJ2xlJzogJ1xcdTIyNjQnLFxuICAgICAgJ2xmbG9vcic6ICdcXHUyMzBBJyxcbiAgICAgICdsb3dhc3QnOiAnXFx1MjIxNycsXG4gICAgICAnbG96JzogJ1xcdTI1Q0EnLFxuICAgICAgJ2xybSc6ICdcXHUyMDBFJyxcbiAgICAgICdsc2FxdW8nOiAnXFx1MjAzOScsXG4gICAgICAnbHNxdW8nOiAnXFx1MjAxOCcsXG4gICAgICAnbHQnOiAnPCcsXG4gICAgICAnbWFjcic6ICdcXHUwMEFGJyxcbiAgICAgICdtZGFzaCc6ICdcXHUyMDE0JyxcbiAgICAgICdtaWNybyc6ICdcXHUwMEI1JyxcbiAgICAgICdtaWRkb3QnOiAnXFx1MDBCNycsXG4gICAgICAnbWludXMnOiAnXFx1MjIxMicsXG4gICAgICAnTXUnOiAnXFx1MDM5QycsXG4gICAgICAnbXUnOiAnXFx1MDNCQycsXG4gICAgICAnbmFibGEnOiAnXFx1MjIwNycsXG4gICAgICAnbmJzcCc6ICdcXHUwMEEwJyxcbiAgICAgICduZGFzaCc6ICdcXHUyMDEzJyxcbiAgICAgICduZSc6ICdcXHUyMjYwJyxcbiAgICAgICduaSc6ICdcXHUyMjBCJyxcbiAgICAgICdub3QnOiAnXFx1MDBBQycsXG4gICAgICAnbm90aW4nOiAnXFx1MjIwOScsXG4gICAgICAnbnN1Yic6ICdcXHUyMjg0JyxcbiAgICAgICdOdGlsZGUnOiAnXFx1MDBEMScsXG4gICAgICAnbnRpbGRlJzogJ1xcdTAwRjEnLFxuICAgICAgJ051JzogJ1xcdTAzOUQnLFxuICAgICAgJ251JzogJ1xcdTAzQkQnLFxuICAgICAgJ09hY3V0ZSc6ICdcXHUwMEQzJyxcbiAgICAgICdvYWN1dGUnOiAnXFx1MDBGMycsXG4gICAgICAnT2NpcmMnOiAnXFx1MDBENCcsXG4gICAgICAnb2NpcmMnOiAnXFx1MDBGNCcsXG4gICAgICAnT0VsaWcnOiAnXFx1MDE1MicsXG4gICAgICAnb2VsaWcnOiAnXFx1MDE1MycsXG4gICAgICAnT2dyYXZlJzogJ1xcdTAwRDInLFxuICAgICAgJ29ncmF2ZSc6ICdcXHUwMEYyJyxcbiAgICAgICdvbGluZSc6ICdcXHUyMDNFJyxcbiAgICAgICdPbWVnYSc6ICdcXHUwM0E5JyxcbiAgICAgICdvbWVnYSc6ICdcXHUwM0M5JyxcbiAgICAgICdPbWljcm9uJzogJ1xcdTAzOUYnLFxuICAgICAgJ29taWNyb24nOiAnXFx1MDNCRicsXG4gICAgICAnb3BsdXMnOiAnXFx1MjI5NScsXG4gICAgICAnb3InOiAnXFx1MjIyOCcsXG4gICAgICAnb3JkZic6ICdcXHUwMEFBJyxcbiAgICAgICdvcmRtJzogJ1xcdTAwQkEnLFxuICAgICAgJ09zbGFzaCc6ICdcXHUwMEQ4JyxcbiAgICAgICdvc2xhc2gnOiAnXFx1MDBGOCcsXG4gICAgICAnT3RpbGRlJzogJ1xcdTAwRDUnLFxuICAgICAgJ290aWxkZSc6ICdcXHUwMEY1JyxcbiAgICAgICdvdGltZXMnOiAnXFx1MjI5NycsXG4gICAgICAnT3VtbCc6ICdcXHUwMEQ2JyxcbiAgICAgICdvdW1sJzogJ1xcdTAwRjYnLFxuICAgICAgJ3BhcmEnOiAnXFx1MDBCNicsXG4gICAgICAncGVybWlsJzogJ1xcdTIwMzAnLFxuICAgICAgJ3BlcnAnOiAnXFx1MjJBNScsXG4gICAgICAnUGhpJzogJ1xcdTAzQTYnLFxuICAgICAgJ3BoaSc6ICdcXHUwM0M2JyxcbiAgICAgICdQaSc6ICdcXHUwM0EwJyxcbiAgICAgICdwaSc6ICdcXHUwM0MwJyxcbiAgICAgICdwaXYnOiAnXFx1MDNENicsXG4gICAgICAncGx1c21uJzogJ1xcdTAwQjEnLFxuICAgICAgJ3BvdW5kJzogJ1xcdTAwQTMnLFxuICAgICAgJ3ByaW1lJzogJ1xcdTIwMzInLFxuICAgICAgJ1ByaW1lJzogJ1xcdTIwMzMnLFxuICAgICAgJ3Byb2QnOiAnXFx1MjIwRicsXG4gICAgICAncHJvcCc6ICdcXHUyMjFEJyxcbiAgICAgICdQc2knOiAnXFx1MDNBOCcsXG4gICAgICAncHNpJzogJ1xcdTAzQzgnLFxuICAgICAgJ3F1b3QnOiAnXFx1MDAyMicsXG4gICAgICAncmFkaWMnOiAnXFx1MjIxQScsXG4gICAgICAncmFuZyc6ICdcXHUyN0U5JyxcbiAgICAgICdyYXF1byc6ICdcXHUwMEJCJyxcbiAgICAgICdyYXJyJzogJ1xcdTIxOTInLFxuICAgICAgJ3JBcnInOiAnXFx1MjFEMicsXG4gICAgICAncmNlaWwnOiAnXFx1MjMwOScsXG4gICAgICAncmRxdW8nOiAnXFx1MjAxRCcsXG4gICAgICAncmVhbCc6ICdcXHUyMTFDJyxcbiAgICAgICdyZWcnOiAnXFx1MDBBRScsXG4gICAgICAncmZsb29yJzogJ1xcdTIzMEInLFxuICAgICAgJ1Jobyc6ICdcXHUwM0ExJyxcbiAgICAgICdyaG8nOiAnXFx1MDNDMScsXG4gICAgICAncmxtJzogJ1xcdTIwMEYnLFxuICAgICAgJ3JzYXF1byc6ICdcXHUyMDNBJyxcbiAgICAgICdyc3F1byc6ICdcXHUyMDE5JyxcbiAgICAgICdzYnF1byc6ICdcXHUyMDFBJyxcbiAgICAgICdTY2Fyb24nOiAnXFx1MDE2MCcsXG4gICAgICAnc2Nhcm9uJzogJ1xcdTAxNjEnLFxuICAgICAgJ3Nkb3QnOiAnXFx1MjJDNScsXG4gICAgICAnc2VjdCc6ICdcXHUwMEE3JyxcbiAgICAgICdzaHknOiAnXFx1MDBBRCcsXG4gICAgICAnU2lnbWEnOiAnXFx1MDNBMycsXG4gICAgICAnc2lnbWEnOiAnXFx1MDNDMycsXG4gICAgICAnc2lnbWFmJzogJ1xcdTAzQzInLFxuICAgICAgJ3NpbSc6ICdcXHUyMjNDJyxcbiAgICAgICdzcGFkZXMnOiAnXFx1MjY2MCcsXG4gICAgICAnc3ViJzogJ1xcdTIyODInLFxuICAgICAgJ3N1YmUnOiAnXFx1MjI4NicsXG4gICAgICAnc3VtJzogJ1xcdTIyMTEnLFxuICAgICAgJ3N1cCc6ICdcXHUyMjgzJyxcbiAgICAgICdzdXAxJzogJ1xcdTAwQjknLFxuICAgICAgJ3N1cDInOiAnXFx1MDBCMicsXG4gICAgICAnc3VwMyc6ICdcXHUwMEIzJyxcbiAgICAgICdzdXBlJzogJ1xcdTIyODcnLFxuICAgICAgJ3N6bGlnJzogJ1xcdTAwREYnLFxuICAgICAgJ1RhdSc6ICdcXHUwM0E0JyxcbiAgICAgICd0YXUnOiAnXFx1MDNDNCcsXG4gICAgICAndGhlcmU0JzogJ1xcdTIyMzQnLFxuICAgICAgJ1RoZXRhJzogJ1xcdTAzOTgnLFxuICAgICAgJ3RoZXRhJzogJ1xcdTAzQjgnLFxuICAgICAgJ3RoZXRhc3ltJzogJ1xcdTAzRDEnLFxuICAgICAgJ3RoaW5zcCc6ICdcXHUyMDA5JyxcbiAgICAgICdUSE9STic6ICdcXHUwMERFJyxcbiAgICAgICd0aG9ybic6ICdcXHUwMEZFJyxcbiAgICAgICd0aWxkZSc6ICdcXHUwMkRDJyxcbiAgICAgICd0aW1lcyc6ICdcXHUwMEQ3JyxcbiAgICAgICd0cmFkZSc6ICdcXHUyMTIyJyxcbiAgICAgICdVYWN1dGUnOiAnXFx1MDBEQScsXG4gICAgICAndWFjdXRlJzogJ1xcdTAwRkEnLFxuICAgICAgJ3VhcnInOiAnXFx1MjE5MScsXG4gICAgICAndUFycic6ICdcXHUyMUQxJyxcbiAgICAgICdVY2lyYyc6ICdcXHUwMERCJyxcbiAgICAgICd1Y2lyYyc6ICdcXHUwMEZCJyxcbiAgICAgICdVZ3JhdmUnOiAnXFx1MDBEOScsXG4gICAgICAndWdyYXZlJzogJ1xcdTAwRjknLFxuICAgICAgJ3VtbCc6ICdcXHUwMEE4JyxcbiAgICAgICd1cHNpaCc6ICdcXHUwM0QyJyxcbiAgICAgICdVcHNpbG9uJzogJ1xcdTAzQTUnLFxuICAgICAgJ3Vwc2lsb24nOiAnXFx1MDNDNScsXG4gICAgICAnVXVtbCc6ICdcXHUwMERDJyxcbiAgICAgICd1dW1sJzogJ1xcdTAwRkMnLFxuICAgICAgJ3dlaWVycCc6ICdcXHUyMTE4JyxcbiAgICAgICdYaSc6ICdcXHUwMzlFJyxcbiAgICAgICd4aSc6ICdcXHUwM0JFJyxcbiAgICAgICdZYWN1dGUnOiAnXFx1MDBERCcsXG4gICAgICAneWFjdXRlJzogJ1xcdTAwRkQnLFxuICAgICAgJ3llbic6ICdcXHUwMEE1JyxcbiAgICAgICd5dW1sJzogJ1xcdTAwRkYnLFxuICAgICAgJ1l1bWwnOiAnXFx1MDE3OCcsXG4gICAgICAnWmV0YSc6ICdcXHUwMzk2JyxcbiAgICAgICd6ZXRhJzogJ1xcdTAzQjYnLFxuICAgICAgJ3p3aic6ICdcXHUyMDBEJyxcbiAgICAgICd6d25qJzogJ1xcdTIwMEMnLFxuICB9O1xuXG4gIHZhciBIdG1sVGFnRGVmaW5pdGlvbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBIdG1sVGFnRGVmaW5pdGlvbihfYSkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIGNsb3NlZEJ5Q2hpbGRyZW4gPSBfYi5jbG9zZWRCeUNoaWxkcmVuLCByZXF1aXJlZFBhcmVudHMgPSBfYi5yZXF1aXJlZFBhcmVudHMsIGltcGxpY2l0TmFtZXNwYWNlUHJlZml4ID0gX2IuaW1wbGljaXROYW1lc3BhY2VQcmVmaXgsIF9jID0gX2IuY29udGVudFR5cGUsIGNvbnRlbnRUeXBlID0gX2MgPT09IHZvaWQgMCA/IFRhZ0NvbnRlbnRUeXBlLlBBUlNBQkxFX0RBVEEgOiBfYywgX2QgPSBfYi5jbG9zZWRCeVBhcmVudCwgY2xvc2VkQnlQYXJlbnQgPSBfZCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfZCwgX2UgPSBfYi5pc1ZvaWQsIGlzVm9pZCA9IF9lID09PSB2b2lkIDAgPyBmYWxzZSA6IF9lLCBfZiA9IF9iLmlnbm9yZUZpcnN0TGYsIGlnbm9yZUZpcnN0TGYgPSBfZiA9PT0gdm9pZCAwID8gZmFsc2UgOiBfZjtcbiAgICAgICAgICB0aGlzLmNsb3NlZEJ5Q2hpbGRyZW4gPSB7fTtcbiAgICAgICAgICB0aGlzLmNsb3NlZEJ5UGFyZW50ID0gZmFsc2U7XG4gICAgICAgICAgdGhpcy5jYW5TZWxmQ2xvc2UgPSBmYWxzZTtcbiAgICAgICAgICBpZiAoY2xvc2VkQnlDaGlsZHJlbiAmJiBjbG9zZWRCeUNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgY2xvc2VkQnlDaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uICh0YWdOYW1lKSB7IHJldHVybiBfdGhpcy5jbG9zZWRCeUNoaWxkcmVuW3RhZ05hbWVdID0gdHJ1ZTsgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuaXNWb2lkID0gaXNWb2lkO1xuICAgICAgICAgIHRoaXMuY2xvc2VkQnlQYXJlbnQgPSBjbG9zZWRCeVBhcmVudCB8fCBpc1ZvaWQ7XG4gICAgICAgICAgaWYgKHJlcXVpcmVkUGFyZW50cyAmJiByZXF1aXJlZFBhcmVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICB0aGlzLnJlcXVpcmVkUGFyZW50cyA9IHt9O1xuICAgICAgICAgICAgICAvLyBUaGUgZmlyc3QgcGFyZW50IGlzIHRoZSBsaXN0IGlzIGF1dG9tYXRpY2FsbHkgd2hlbiBub25lIG9mIHRoZSBsaXN0ZWQgcGFyZW50cyBhcmUgcHJlc2VudFxuICAgICAgICAgICAgICB0aGlzLnBhcmVudFRvQWRkID0gcmVxdWlyZWRQYXJlbnRzWzBdO1xuICAgICAgICAgICAgICByZXF1aXJlZFBhcmVudHMuZm9yRWFjaChmdW5jdGlvbiAodGFnTmFtZSkgeyByZXR1cm4gX3RoaXMucmVxdWlyZWRQYXJlbnRzW3RhZ05hbWVdID0gdHJ1ZTsgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuaW1wbGljaXROYW1lc3BhY2VQcmVmaXggPSBpbXBsaWNpdE5hbWVzcGFjZVByZWZpeDtcbiAgICAgICAgICB0aGlzLmNvbnRlbnRUeXBlID0gY29udGVudFR5cGU7XG4gICAgICAgICAgdGhpcy5pZ25vcmVGaXJzdExmID0gaWdub3JlRmlyc3RMZjtcbiAgICAgIH1cbiAgICAgIEh0bWxUYWdEZWZpbml0aW9uLnByb3RvdHlwZS5yZXF1aXJlRXh0cmFQYXJlbnQgPSBmdW5jdGlvbiAoY3VycmVudFBhcmVudCkge1xuICAgICAgICAgIGlmICghdGhpcy5yZXF1aXJlZFBhcmVudHMpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWN1cnJlbnRQYXJlbnQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBsY1BhcmVudCA9IGN1cnJlbnRQYXJlbnQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5yZXF1aXJlZFBhcmVudHNbbGNQYXJlbnRdICE9IHRydWUgJiYgbGNQYXJlbnQgIT0gJ3RlbXBsYXRlJztcbiAgICAgIH07XG4gICAgICBIdG1sVGFnRGVmaW5pdGlvbi5wcm90b3R5cGUuaXNDbG9zZWRCeUNoaWxkID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5pc1ZvaWQgfHwgbmFtZS50b0xvd2VyQ2FzZSgpIGluIHRoaXMuY2xvc2VkQnlDaGlsZHJlbjtcbiAgICAgIH07XG4gICAgICByZXR1cm4gSHRtbFRhZ0RlZmluaXRpb247XG4gIH0oKSk7XG4gIC8vIHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNTEvc3ludGF4Lmh0bWwjb3B0aW9uYWwtdGFnc1xuICAvLyBUaGlzIGltcGxlbWVudGF0aW9uIGRvZXMgbm90IGZ1bGx5IGNvbmZvcm0gdG8gdGhlIEhUTUw1IHNwZWMuXG4gIHZhciBUQUdfREVGSU5JVElPTlMgPSB7XG4gICAgICAnYmFzZSc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGlzVm9pZDogdHJ1ZSB9KSxcbiAgICAgICdtZXRhJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgaXNWb2lkOiB0cnVlIH0pLFxuICAgICAgJ2FyZWEnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBpc1ZvaWQ6IHRydWUgfSksXG4gICAgICAnZW1iZWQnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBpc1ZvaWQ6IHRydWUgfSksXG4gICAgICAnbGluayc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGlzVm9pZDogdHJ1ZSB9KSxcbiAgICAgICdpbWcnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBpc1ZvaWQ6IHRydWUgfSksXG4gICAgICAnaW5wdXQnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBpc1ZvaWQ6IHRydWUgfSksXG4gICAgICAncGFyYW0nOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBpc1ZvaWQ6IHRydWUgfSksXG4gICAgICAnaHInOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBpc1ZvaWQ6IHRydWUgfSksXG4gICAgICAnYnInOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBpc1ZvaWQ6IHRydWUgfSksXG4gICAgICAnc291cmNlJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgaXNWb2lkOiB0cnVlIH0pLFxuICAgICAgJ3RyYWNrJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgaXNWb2lkOiB0cnVlIH0pLFxuICAgICAgJ3dicic6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGlzVm9pZDogdHJ1ZSB9KSxcbiAgICAgICdwJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHtcbiAgICAgICAgICBjbG9zZWRCeUNoaWxkcmVuOiBbXG4gICAgICAgICAgICAgICdhZGRyZXNzJywgJ2FydGljbGUnLCAnYXNpZGUnLCAnYmxvY2txdW90ZScsICdkaXYnLCAnZGwnLCAnZmllbGRzZXQnLCAnZm9vdGVyJywgJ2Zvcm0nLFxuICAgICAgICAgICAgICAnaDEnLCAnaDInLCAnaDMnLCAnaDQnLCAnaDUnLCAnaDYnLCAnaGVhZGVyJywgJ2hncm91cCcsICdocicsXG4gICAgICAgICAgICAgICdtYWluJywgJ25hdicsICdvbCcsICdwJywgJ3ByZScsICdzZWN0aW9uJywgJ3RhYmxlJywgJ3VsJ1xuICAgICAgICAgIF0sXG4gICAgICAgICAgY2xvc2VkQnlQYXJlbnQ6IHRydWVcbiAgICAgIH0pLFxuICAgICAgJ3RoZWFkJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgY2xvc2VkQnlDaGlsZHJlbjogWyd0Ym9keScsICd0Zm9vdCddIH0pLFxuICAgICAgJ3Rib2R5JzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgY2xvc2VkQnlDaGlsZHJlbjogWyd0Ym9keScsICd0Zm9vdCddLCBjbG9zZWRCeVBhcmVudDogdHJ1ZSB9KSxcbiAgICAgICd0Zm9vdCc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGNsb3NlZEJ5Q2hpbGRyZW46IFsndGJvZHknXSwgY2xvc2VkQnlQYXJlbnQ6IHRydWUgfSksXG4gICAgICAndHInOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oe1xuICAgICAgICAgIGNsb3NlZEJ5Q2hpbGRyZW46IFsndHInXSxcbiAgICAgICAgICByZXF1aXJlZFBhcmVudHM6IFsndGJvZHknLCAndGZvb3QnLCAndGhlYWQnXSxcbiAgICAgICAgICBjbG9zZWRCeVBhcmVudDogdHJ1ZVxuICAgICAgfSksXG4gICAgICAndGQnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBjbG9zZWRCeUNoaWxkcmVuOiBbJ3RkJywgJ3RoJ10sIGNsb3NlZEJ5UGFyZW50OiB0cnVlIH0pLFxuICAgICAgJ3RoJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgY2xvc2VkQnlDaGlsZHJlbjogWyd0ZCcsICd0aCddLCBjbG9zZWRCeVBhcmVudDogdHJ1ZSB9KSxcbiAgICAgICdjb2wnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyByZXF1aXJlZFBhcmVudHM6IFsnY29sZ3JvdXAnXSwgaXNWb2lkOiB0cnVlIH0pLFxuICAgICAgJ3N2Zyc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGltcGxpY2l0TmFtZXNwYWNlUHJlZml4OiAnc3ZnJyB9KSxcbiAgICAgICdtYXRoJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgaW1wbGljaXROYW1lc3BhY2VQcmVmaXg6ICdtYXRoJyB9KSxcbiAgICAgICdsaSc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGNsb3NlZEJ5Q2hpbGRyZW46IFsnbGknXSwgY2xvc2VkQnlQYXJlbnQ6IHRydWUgfSksXG4gICAgICAnZHQnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBjbG9zZWRCeUNoaWxkcmVuOiBbJ2R0JywgJ2RkJ10gfSksXG4gICAgICAnZGQnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBjbG9zZWRCeUNoaWxkcmVuOiBbJ2R0JywgJ2RkJ10sIGNsb3NlZEJ5UGFyZW50OiB0cnVlIH0pLFxuICAgICAgJ3JiJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgY2xvc2VkQnlDaGlsZHJlbjogWydyYicsICdydCcsICdydGMnLCAncnAnXSwgY2xvc2VkQnlQYXJlbnQ6IHRydWUgfSksXG4gICAgICAncnQnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBjbG9zZWRCeUNoaWxkcmVuOiBbJ3JiJywgJ3J0JywgJ3J0YycsICdycCddLCBjbG9zZWRCeVBhcmVudDogdHJ1ZSB9KSxcbiAgICAgICdydGMnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBjbG9zZWRCeUNoaWxkcmVuOiBbJ3JiJywgJ3J0YycsICdycCddLCBjbG9zZWRCeVBhcmVudDogdHJ1ZSB9KSxcbiAgICAgICdycCc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGNsb3NlZEJ5Q2hpbGRyZW46IFsncmInLCAncnQnLCAncnRjJywgJ3JwJ10sIGNsb3NlZEJ5UGFyZW50OiB0cnVlIH0pLFxuICAgICAgJ29wdGdyb3VwJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgY2xvc2VkQnlDaGlsZHJlbjogWydvcHRncm91cCddLCBjbG9zZWRCeVBhcmVudDogdHJ1ZSB9KSxcbiAgICAgICdvcHRpb24nOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBjbG9zZWRCeUNoaWxkcmVuOiBbJ29wdGlvbicsICdvcHRncm91cCddLCBjbG9zZWRCeVBhcmVudDogdHJ1ZSB9KSxcbiAgICAgICdwcmUnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBpZ25vcmVGaXJzdExmOiB0cnVlIH0pLFxuICAgICAgJ2xpc3RpbmcnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBpZ25vcmVGaXJzdExmOiB0cnVlIH0pLFxuICAgICAgJ3N0eWxlJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgY29udGVudFR5cGU6IFRhZ0NvbnRlbnRUeXBlLlJBV19URVhUIH0pLFxuICAgICAgJ3NjcmlwdCc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGNvbnRlbnRUeXBlOiBUYWdDb250ZW50VHlwZS5SQVdfVEVYVCB9KSxcbiAgICAgICd0aXRsZSc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGNvbnRlbnRUeXBlOiBUYWdDb250ZW50VHlwZS5FU0NBUEFCTEVfUkFXX1RFWFQgfSksXG4gICAgICAndGV4dGFyZWEnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBjb250ZW50VHlwZTogVGFnQ29udGVudFR5cGUuRVNDQVBBQkxFX1JBV19URVhULCBpZ25vcmVGaXJzdExmOiB0cnVlIH0pLFxuICB9O1xuICB2YXIgX0RFRkFVTFRfVEFHX0RFRklOSVRJT04gPSBuZXcgSHRtbFRhZ0RlZmluaXRpb24oKTtcbiAgZnVuY3Rpb24gZ2V0SHRtbFRhZ0RlZmluaXRpb24odGFnTmFtZSkge1xuICAgICAgcmV0dXJuIFRBR19ERUZJTklUSU9OU1t0YWdOYW1lLnRvTG93ZXJDYXNlKCldIHx8IF9ERUZBVUxUX1RBR19ERUZJTklUSU9OO1xuICB9XG5cbiAgdmFyIF9TRUxFQ1RPUl9SRUdFWFAgPSBuZXcgUmVnRXhwKCcoXFxcXDpub3RcXFxcKCl8JyArXG4gICAgICAnKFstXFxcXHddKyl8JyArXG4gICAgICAnKD86XFxcXC4oWy1cXFxcd10rKSl8JyArXG4gICAgICAnKD86XFxcXFsoWy1cXFxcdypdKykoPzo9KFteXFxcXF1dKikpP1xcXFxdKXwnICtcbiAgICAgICcoXFxcXCkpfCcgK1xuICAgICAgJyhcXFxccyosXFxcXHMqKScsIC8vIFwiLFwiXG4gICdnJyk7XG4gIC8qKlxuICAgKiBBIGNzcyBzZWxlY3RvciBjb250YWlucyBhbiBlbGVtZW50IG5hbWUsXG4gICAqIGNzcyBjbGFzc2VzIGFuZCBhdHRyaWJ1dGUvdmFsdWUgcGFpcnMgd2l0aCB0aGUgcHVycG9zZVxuICAgKiBvZiBzZWxlY3Rpbmcgc3Vic2V0cyBvdXQgb2YgdGhlbS5cbiAgICovXG4gIHZhciBDc3NTZWxlY3RvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBDc3NTZWxlY3RvcigpIHtcbiAgICAgICAgICB0aGlzLmVsZW1lbnQgPSBudWxsO1xuICAgICAgICAgIHRoaXMuY2xhc3NOYW1lcyA9IFtdO1xuICAgICAgICAgIHRoaXMuYXR0cnMgPSBbXTtcbiAgICAgICAgICB0aGlzLm5vdFNlbGVjdG9ycyA9IFtdO1xuICAgICAgfVxuICAgICAgQ3NzU2VsZWN0b3IucGFyc2UgPSBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgIHZhciBfYWRkUmVzdWx0ID0gZnVuY3Rpb24gKHJlcywgY3NzU2VsKSB7XG4gICAgICAgICAgICAgIGlmIChjc3NTZWwubm90U2VsZWN0b3JzLmxlbmd0aCA+IDAgJiYgIWNzc1NlbC5lbGVtZW50ICYmIGNzc1NlbC5jbGFzc05hbWVzLmxlbmd0aCA9PSAwICYmXG4gICAgICAgICAgICAgICAgICBjc3NTZWwuYXR0cnMubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICAgIGNzc1NlbC5lbGVtZW50ID0gJyonO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlcy5wdXNoKGNzc1NlbCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICB2YXIgY3NzU2VsZWN0b3IgPSBuZXcgQ3NzU2VsZWN0b3IoKTtcbiAgICAgICAgICB2YXIgbWF0Y2g7XG4gICAgICAgICAgdmFyIGN1cnJlbnQgPSBjc3NTZWxlY3RvcjtcbiAgICAgICAgICB2YXIgaW5Ob3QgPSBmYWxzZTtcbiAgICAgICAgICBfU0VMRUNUT1JfUkVHRVhQLmxhc3RJbmRleCA9IDA7XG4gICAgICAgICAgd2hpbGUgKG1hdGNoID0gX1NFTEVDVE9SX1JFR0VYUC5leGVjKHNlbGVjdG9yKSkge1xuICAgICAgICAgICAgICBpZiAobWF0Y2hbMV0pIHtcbiAgICAgICAgICAgICAgICAgIGlmIChpbk5vdCkge1xuICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTmVzdGluZyA6bm90IGlzIG5vdCBhbGxvd2VkIGluIGEgc2VsZWN0b3InKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGluTm90ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBuZXcgQ3NzU2VsZWN0b3IoKTtcbiAgICAgICAgICAgICAgICAgIGNzc1NlbGVjdG9yLm5vdFNlbGVjdG9ycy5wdXNoKGN1cnJlbnQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChtYXRjaFsyXSkge1xuICAgICAgICAgICAgICAgICAgY3VycmVudC5zZXRFbGVtZW50KG1hdGNoWzJdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAobWF0Y2hbM10pIHtcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnQuYWRkQ2xhc3NOYW1lKG1hdGNoWzNdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAobWF0Y2hbNF0pIHtcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnQuYWRkQXR0cmlidXRlKG1hdGNoWzRdLCBtYXRjaFs1XSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKG1hdGNoWzZdKSB7XG4gICAgICAgICAgICAgICAgICBpbk5vdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgY3VycmVudCA9IGNzc1NlbGVjdG9yO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChtYXRjaFs3XSkge1xuICAgICAgICAgICAgICAgICAgaWYgKGluTm90KSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNdWx0aXBsZSBzZWxlY3RvcnMgaW4gOm5vdCBhcmUgbm90IHN1cHBvcnRlZCcpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgX2FkZFJlc3VsdChyZXN1bHRzLCBjc3NTZWxlY3Rvcik7XG4gICAgICAgICAgICAgICAgICBjc3NTZWxlY3RvciA9IGN1cnJlbnQgPSBuZXcgQ3NzU2VsZWN0b3IoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBfYWRkUmVzdWx0KHJlc3VsdHMsIGNzc1NlbGVjdG9yKTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgIH07XG4gICAgICBDc3NTZWxlY3Rvci5wcm90b3R5cGUuaXNFbGVtZW50U2VsZWN0b3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuaGFzRWxlbWVudFNlbGVjdG9yKCkgJiYgdGhpcy5jbGFzc05hbWVzLmxlbmd0aCA9PSAwICYmIHRoaXMuYXR0cnMubGVuZ3RoID09IDAgJiZcbiAgICAgICAgICAgICAgdGhpcy5ub3RTZWxlY3RvcnMubGVuZ3RoID09PSAwO1xuICAgICAgfTtcbiAgICAgIENzc1NlbGVjdG9yLnByb3RvdHlwZS5oYXNFbGVtZW50U2VsZWN0b3IgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAhIXRoaXMuZWxlbWVudDsgfTtcbiAgICAgIENzc1NlbGVjdG9yLnByb3RvdHlwZS5zZXRFbGVtZW50ID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgICBpZiAoZWxlbWVudCA9PT0gdm9pZCAwKSB7IGVsZW1lbnQgPSBudWxsOyB9XG4gICAgICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgIH07XG4gICAgICAvKiogR2V0cyBhIHRlbXBsYXRlIHN0cmluZyBmb3IgYW4gZWxlbWVudCB0aGF0IG1hdGNoZXMgdGhlIHNlbGVjdG9yLiAqL1xuICAgICAgQ3NzU2VsZWN0b3IucHJvdG90eXBlLmdldE1hdGNoaW5nRWxlbWVudFRlbXBsYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciB0YWdOYW1lID0gdGhpcy5lbGVtZW50IHx8ICdkaXYnO1xuICAgICAgICAgIHZhciBjbGFzc0F0dHIgPSB0aGlzLmNsYXNzTmFtZXMubGVuZ3RoID4gMCA/IFwiIGNsYXNzPVxcXCJcIiArIHRoaXMuY2xhc3NOYW1lcy5qb2luKCcgJykgKyBcIlxcXCJcIiA6ICcnO1xuICAgICAgICAgIHZhciBhdHRycyA9ICcnO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5hdHRycy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgICB2YXIgYXR0ck5hbWUgPSB0aGlzLmF0dHJzW2ldO1xuICAgICAgICAgICAgICB2YXIgYXR0clZhbHVlID0gdGhpcy5hdHRyc1tpICsgMV0gIT09ICcnID8gXCI9XFxcIlwiICsgdGhpcy5hdHRyc1tpICsgMV0gKyBcIlxcXCJcIiA6ICcnO1xuICAgICAgICAgICAgICBhdHRycyArPSBcIiBcIiArIGF0dHJOYW1lICsgYXR0clZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZ2V0SHRtbFRhZ0RlZmluaXRpb24odGFnTmFtZSkuaXNWb2lkID8gXCI8XCIgKyB0YWdOYW1lICsgY2xhc3NBdHRyICsgYXR0cnMgKyBcIi8+XCIgOlxuICAgICAgICAgICAgICBcIjxcIiArIHRhZ05hbWUgKyBjbGFzc0F0dHIgKyBhdHRycyArIFwiPjwvXCIgKyB0YWdOYW1lICsgXCI+XCI7XG4gICAgICB9O1xuICAgICAgQ3NzU2VsZWN0b3IucHJvdG90eXBlLmFkZEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSB7IHZhbHVlID0gJyc7IH1cbiAgICAgICAgICB0aGlzLmF0dHJzLnB1c2gobmFtZSwgdmFsdWUgJiYgdmFsdWUudG9Mb3dlckNhc2UoKSB8fCAnJyk7XG4gICAgICB9O1xuICAgICAgQ3NzU2VsZWN0b3IucHJvdG90eXBlLmFkZENsYXNzTmFtZSA9IGZ1bmN0aW9uIChuYW1lKSB7IHRoaXMuY2xhc3NOYW1lcy5wdXNoKG5hbWUudG9Mb3dlckNhc2UoKSk7IH07XG4gICAgICBDc3NTZWxlY3Rvci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHJlcyA9IHRoaXMuZWxlbWVudCB8fCAnJztcbiAgICAgICAgICBpZiAodGhpcy5jbGFzc05hbWVzKSB7XG4gICAgICAgICAgICAgIHRoaXMuY2xhc3NOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChrbGFzcykgeyByZXR1cm4gcmVzICs9IFwiLlwiICsga2xhc3M7IH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy5hdHRycykge1xuICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYXR0cnMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBuYW1lXzEgPSB0aGlzLmF0dHJzW2ldO1xuICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5hdHRyc1tpICsgMV07XG4gICAgICAgICAgICAgICAgICByZXMgKz0gXCJbXCIgKyBuYW1lXzEgKyAodmFsdWUgPyAnPScgKyB2YWx1ZSA6ICcnKSArIFwiXVwiO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMubm90U2VsZWN0b3JzLmZvckVhY2goZnVuY3Rpb24gKG5vdFNlbGVjdG9yKSB7IHJldHVybiByZXMgKz0gXCI6bm90KFwiICsgbm90U2VsZWN0b3IgKyBcIilcIjsgfSk7XG4gICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH07XG4gICAgICByZXR1cm4gQ3NzU2VsZWN0b3I7XG4gIH0oKSk7XG4gIC8qKlxuICAgKiBSZWFkcyBhIGxpc3Qgb2YgQ3NzU2VsZWN0b3JzIGFuZCBhbGxvd3MgdG8gY2FsY3VsYXRlIHdoaWNoIG9uZXNcbiAgICogYXJlIGNvbnRhaW5lZCBpbiBhIGdpdmVuIENzc1NlbGVjdG9yLlxuICAgKi9cbiAgdmFyIFNlbGVjdG9yTWF0Y2hlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBTZWxlY3Rvck1hdGNoZXIoKSB7XG4gICAgICAgICAgdGhpcy5fZWxlbWVudE1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgICB0aGlzLl9lbGVtZW50UGFydGlhbE1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgICB0aGlzLl9jbGFzc01hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgICB0aGlzLl9jbGFzc1BhcnRpYWxNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgdGhpcy5fYXR0clZhbHVlTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICAgIHRoaXMuX2F0dHJWYWx1ZVBhcnRpYWxNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgdGhpcy5fbGlzdENvbnRleHRzID0gW107XG4gICAgICB9XG4gICAgICBTZWxlY3Rvck1hdGNoZXIuY3JlYXRlTm90TWF0Y2hlciA9IGZ1bmN0aW9uIChub3RTZWxlY3RvcnMpIHtcbiAgICAgICAgICB2YXIgbm90TWF0Y2hlciA9IG5ldyBTZWxlY3Rvck1hdGNoZXIoKTtcbiAgICAgICAgICBub3RNYXRjaGVyLmFkZFNlbGVjdGFibGVzKG5vdFNlbGVjdG9ycywgbnVsbCk7XG4gICAgICAgICAgcmV0dXJuIG5vdE1hdGNoZXI7XG4gICAgICB9O1xuICAgICAgU2VsZWN0b3JNYXRjaGVyLnByb3RvdHlwZS5hZGRTZWxlY3RhYmxlcyA9IGZ1bmN0aW9uIChjc3NTZWxlY3RvcnMsIGNhbGxiYWNrQ3R4dCkge1xuICAgICAgICAgIHZhciBsaXN0Q29udGV4dCA9IG51bGw7XG4gICAgICAgICAgaWYgKGNzc1NlbGVjdG9ycy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgIGxpc3RDb250ZXh0ID0gbmV3IFNlbGVjdG9yTGlzdENvbnRleHQoY3NzU2VsZWN0b3JzKTtcbiAgICAgICAgICAgICAgdGhpcy5fbGlzdENvbnRleHRzLnB1c2gobGlzdENvbnRleHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNzc1NlbGVjdG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICB0aGlzLl9hZGRTZWxlY3RhYmxlKGNzc1NlbGVjdG9yc1tpXSwgY2FsbGJhY2tDdHh0LCBsaXN0Q29udGV4dCk7XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIC8qKlxuICAgICAgICogQWRkIGFuIG9iamVjdCB0aGF0IGNhbiBiZSBmb3VuZCBsYXRlciBvbiBieSBjYWxsaW5nIGBtYXRjaGAuXG4gICAgICAgKiBAcGFyYW0gY3NzU2VsZWN0b3IgQSBjc3Mgc2VsZWN0b3JcbiAgICAgICAqIEBwYXJhbSBjYWxsYmFja0N0eHQgQW4gb3BhcXVlIG9iamVjdCB0aGF0IHdpbGwgYmUgZ2l2ZW4gdG8gdGhlIGNhbGxiYWNrIG9mIHRoZSBgbWF0Y2hgIGZ1bmN0aW9uXG4gICAgICAgKi9cbiAgICAgIFNlbGVjdG9yTWF0Y2hlci5wcm90b3R5cGUuX2FkZFNlbGVjdGFibGUgPSBmdW5jdGlvbiAoY3NzU2VsZWN0b3IsIGNhbGxiYWNrQ3R4dCwgbGlzdENvbnRleHQpIHtcbiAgICAgICAgICB2YXIgbWF0Y2hlciA9IHRoaXM7XG4gICAgICAgICAgdmFyIGVsZW1lbnQgPSBjc3NTZWxlY3Rvci5lbGVtZW50O1xuICAgICAgICAgIHZhciBjbGFzc05hbWVzID0gY3NzU2VsZWN0b3IuY2xhc3NOYW1lcztcbiAgICAgICAgICB2YXIgYXR0cnMgPSBjc3NTZWxlY3Rvci5hdHRycztcbiAgICAgICAgICB2YXIgc2VsZWN0YWJsZSA9IG5ldyBTZWxlY3RvckNvbnRleHQoY3NzU2VsZWN0b3IsIGNhbGxiYWNrQ3R4dCwgbGlzdENvbnRleHQpO1xuICAgICAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgICAgICAgIHZhciBpc1Rlcm1pbmFsID0gYXR0cnMubGVuZ3RoID09PSAwICYmIGNsYXNzTmFtZXMubGVuZ3RoID09PSAwO1xuICAgICAgICAgICAgICBpZiAoaXNUZXJtaW5hbCkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkVGVybWluYWwobWF0Y2hlci5fZWxlbWVudE1hcCwgZWxlbWVudCwgc2VsZWN0YWJsZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICBtYXRjaGVyID0gdGhpcy5fYWRkUGFydGlhbChtYXRjaGVyLl9lbGVtZW50UGFydGlhbE1hcCwgZWxlbWVudCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNsYXNzTmFtZXMpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbGFzc05hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgaXNUZXJtaW5hbCA9IGF0dHJzLmxlbmd0aCA9PT0gMCAmJiBpID09PSBjbGFzc05hbWVzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgICB2YXIgY2xhc3NOYW1lID0gY2xhc3NOYW1lc1tpXTtcbiAgICAgICAgICAgICAgICAgIGlmIChpc1Rlcm1pbmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkVGVybWluYWwobWF0Y2hlci5fY2xhc3NNYXAsIGNsYXNzTmFtZSwgc2VsZWN0YWJsZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVyID0gdGhpcy5fYWRkUGFydGlhbChtYXRjaGVyLl9jbGFzc1BhcnRpYWxNYXAsIGNsYXNzTmFtZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGF0dHJzKSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXR0cnMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBpc1Rlcm1pbmFsID0gaSA9PT0gYXR0cnMubGVuZ3RoIC0gMjtcbiAgICAgICAgICAgICAgICAgIHZhciBuYW1lXzIgPSBhdHRyc1tpXTtcbiAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGF0dHJzW2kgKyAxXTtcbiAgICAgICAgICAgICAgICAgIGlmIChpc1Rlcm1pbmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIHRlcm1pbmFsTWFwID0gbWF0Y2hlci5fYXR0clZhbHVlTWFwO1xuICAgICAgICAgICAgICAgICAgICAgIHZhciB0ZXJtaW5hbFZhbHVlc01hcCA9IHRlcm1pbmFsTWFwLmdldChuYW1lXzIpO1xuICAgICAgICAgICAgICAgICAgICAgIGlmICghdGVybWluYWxWYWx1ZXNNYXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGVybWluYWxWYWx1ZXNNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRlcm1pbmFsTWFwLnNldChuYW1lXzIsIHRlcm1pbmFsVmFsdWVzTWFwKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkVGVybWluYWwodGVybWluYWxWYWx1ZXNNYXAsIHZhbHVlLCBzZWxlY3RhYmxlKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJ0aWFsTWFwID0gbWF0Y2hlci5fYXR0clZhbHVlUGFydGlhbE1hcDtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFydGlhbFZhbHVlc01hcCA9IHBhcnRpYWxNYXAuZ2V0KG5hbWVfMik7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXJ0aWFsVmFsdWVzTWFwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRpYWxWYWx1ZXNNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRpYWxNYXAuc2V0KG5hbWVfMiwgcGFydGlhbFZhbHVlc01hcCk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZXIgPSB0aGlzLl9hZGRQYXJ0aWFsKHBhcnRpYWxWYWx1ZXNNYXAsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICBTZWxlY3Rvck1hdGNoZXIucHJvdG90eXBlLl9hZGRUZXJtaW5hbCA9IGZ1bmN0aW9uIChtYXAsIG5hbWUsIHNlbGVjdGFibGUpIHtcbiAgICAgICAgICB2YXIgdGVybWluYWxMaXN0ID0gbWFwLmdldChuYW1lKTtcbiAgICAgICAgICBpZiAoIXRlcm1pbmFsTGlzdCkge1xuICAgICAgICAgICAgICB0ZXJtaW5hbExpc3QgPSBbXTtcbiAgICAgICAgICAgICAgbWFwLnNldChuYW1lLCB0ZXJtaW5hbExpc3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0ZXJtaW5hbExpc3QucHVzaChzZWxlY3RhYmxlKTtcbiAgICAgIH07XG4gICAgICBTZWxlY3Rvck1hdGNoZXIucHJvdG90eXBlLl9hZGRQYXJ0aWFsID0gZnVuY3Rpb24gKG1hcCwgbmFtZSkge1xuICAgICAgICAgIHZhciBtYXRjaGVyID0gbWFwLmdldChuYW1lKTtcbiAgICAgICAgICBpZiAoIW1hdGNoZXIpIHtcbiAgICAgICAgICAgICAgbWF0Y2hlciA9IG5ldyBTZWxlY3Rvck1hdGNoZXIoKTtcbiAgICAgICAgICAgICAgbWFwLnNldChuYW1lLCBtYXRjaGVyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG1hdGNoZXI7XG4gICAgICB9O1xuICAgICAgLyoqXG4gICAgICAgKiBGaW5kIHRoZSBvYmplY3RzIHRoYXQgaGF2ZSBiZWVuIGFkZGVkIHZpYSBgYWRkU2VsZWN0YWJsZWBcbiAgICAgICAqIHdob3NlIGNzcyBzZWxlY3RvciBpcyBjb250YWluZWQgaW4gdGhlIGdpdmVuIGNzcyBzZWxlY3Rvci5cbiAgICAgICAqIEBwYXJhbSBjc3NTZWxlY3RvciBBIGNzcyBzZWxlY3RvclxuICAgICAgICogQHBhcmFtIG1hdGNoZWRDYWxsYmFjayBUaGlzIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIHdpdGggdGhlIG9iamVjdCBoYW5kZWQgaW50byBgYWRkU2VsZWN0YWJsZWBcbiAgICAgICAqIEByZXR1cm4gYm9vbGVhbiB0cnVlIGlmIGEgbWF0Y2ggd2FzIGZvdW5kXG4gICAgICAqL1xuICAgICAgU2VsZWN0b3JNYXRjaGVyLnByb3RvdHlwZS5tYXRjaCA9IGZ1bmN0aW9uIChjc3NTZWxlY3RvciwgbWF0Y2hlZENhbGxiYWNrKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICAgIHZhciBlbGVtZW50ID0gY3NzU2VsZWN0b3IuZWxlbWVudDtcbiAgICAgICAgICB2YXIgY2xhc3NOYW1lcyA9IGNzc1NlbGVjdG9yLmNsYXNzTmFtZXM7XG4gICAgICAgICAgdmFyIGF0dHJzID0gY3NzU2VsZWN0b3IuYXR0cnM7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9saXN0Q29udGV4dHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdGhpcy5fbGlzdENvbnRleHRzW2ldLmFscmVhZHlNYXRjaGVkID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdCA9IHRoaXMuX21hdGNoVGVybWluYWwodGhpcy5fZWxlbWVudE1hcCwgZWxlbWVudCwgY3NzU2VsZWN0b3IsIG1hdGNoZWRDYWxsYmFjaykgfHwgcmVzdWx0O1xuICAgICAgICAgIHJlc3VsdCA9IHRoaXMuX21hdGNoUGFydGlhbCh0aGlzLl9lbGVtZW50UGFydGlhbE1hcCwgZWxlbWVudCwgY3NzU2VsZWN0b3IsIG1hdGNoZWRDYWxsYmFjaykgfHxcbiAgICAgICAgICAgICAgcmVzdWx0O1xuICAgICAgICAgIGlmIChjbGFzc05hbWVzKSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2xhc3NOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgdmFyIGNsYXNzTmFtZSA9IGNsYXNzTmFtZXNbaV07XG4gICAgICAgICAgICAgICAgICByZXN1bHQgPVxuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX21hdGNoVGVybWluYWwodGhpcy5fY2xhc3NNYXAsIGNsYXNzTmFtZSwgY3NzU2VsZWN0b3IsIG1hdGNoZWRDYWxsYmFjaykgfHwgcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgcmVzdWx0ID1cbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9tYXRjaFBhcnRpYWwodGhpcy5fY2xhc3NQYXJ0aWFsTWFwLCBjbGFzc05hbWUsIGNzc1NlbGVjdG9yLCBtYXRjaGVkQ2FsbGJhY2spIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYXR0cnMpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhdHRycy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgICAgICAgdmFyIG5hbWVfMyA9IGF0dHJzW2ldO1xuICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gYXR0cnNbaSArIDFdO1xuICAgICAgICAgICAgICAgICAgdmFyIHRlcm1pbmFsVmFsdWVzTWFwID0gdGhpcy5fYXR0clZhbHVlTWFwLmdldChuYW1lXzMpO1xuICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWF0Y2hUZXJtaW5hbCh0ZXJtaW5hbFZhbHVlc01hcCwgJycsIGNzc1NlbGVjdG9yLCBtYXRjaGVkQ2FsbGJhY2spIHx8IHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHJlc3VsdCA9XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWF0Y2hUZXJtaW5hbCh0ZXJtaW5hbFZhbHVlc01hcCwgdmFsdWUsIGNzc1NlbGVjdG9yLCBtYXRjaGVkQ2FsbGJhY2spIHx8IHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgIHZhciBwYXJ0aWFsVmFsdWVzTWFwID0gdGhpcy5fYXR0clZhbHVlUGFydGlhbE1hcC5nZXQobmFtZV8zKTtcbiAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuX21hdGNoUGFydGlhbChwYXJ0aWFsVmFsdWVzTWFwLCAnJywgY3NzU2VsZWN0b3IsIG1hdGNoZWRDYWxsYmFjaykgfHwgcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgcmVzdWx0ID1cbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9tYXRjaFBhcnRpYWwocGFydGlhbFZhbHVlc01hcCwgdmFsdWUsIGNzc1NlbGVjdG9yLCBtYXRjaGVkQ2FsbGJhY2spIHx8IHJlc3VsdDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgIFNlbGVjdG9yTWF0Y2hlci5wcm90b3R5cGUuX21hdGNoVGVybWluYWwgPSBmdW5jdGlvbiAobWFwLCBuYW1lLCBjc3NTZWxlY3RvciwgbWF0Y2hlZENhbGxiYWNrKSB7XG4gICAgICAgICAgaWYgKCFtYXAgfHwgdHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHNlbGVjdGFibGVzID0gbWFwLmdldChuYW1lKTtcbiAgICAgICAgICB2YXIgc3RhclNlbGVjdGFibGVzID0gbWFwLmdldCgnKicpO1xuICAgICAgICAgIGlmIChzdGFyU2VsZWN0YWJsZXMpIHtcbiAgICAgICAgICAgICAgc2VsZWN0YWJsZXMgPSBzZWxlY3RhYmxlcy5jb25jYXQoc3RhclNlbGVjdGFibGVzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFzZWxlY3RhYmxlcykge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBzZWxlY3RhYmxlO1xuICAgICAgICAgIHZhciByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGVjdGFibGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIHNlbGVjdGFibGUgPSBzZWxlY3RhYmxlc1tpXTtcbiAgICAgICAgICAgICAgcmVzdWx0ID0gc2VsZWN0YWJsZS5maW5hbGl6ZShjc3NTZWxlY3RvciwgbWF0Y2hlZENhbGxiYWNrKSB8fCByZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgU2VsZWN0b3JNYXRjaGVyLnByb3RvdHlwZS5fbWF0Y2hQYXJ0aWFsID0gZnVuY3Rpb24gKG1hcCwgbmFtZSwgY3NzU2VsZWN0b3IsIG1hdGNoZWRDYWxsYmFjaykge1xuICAgICAgICAgIGlmICghbWFwIHx8IHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBuZXN0ZWRTZWxlY3RvciA9IG1hcC5nZXQobmFtZSk7XG4gICAgICAgICAgaWYgKCFuZXN0ZWRTZWxlY3Rvcikge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFRPRE8ocGVyZik6IGdldCByaWQgb2YgcmVjdXJzaW9uIGFuZCBtZWFzdXJlIGFnYWluXG4gICAgICAgICAgLy8gVE9ETyhwZXJmKTogZG9uJ3QgcGFzcyB0aGUgd2hvbGUgc2VsZWN0b3IgaW50byB0aGUgcmVjdXJzaW9uLFxuICAgICAgICAgIC8vIGJ1dCBvbmx5IHRoZSBub3QgcHJvY2Vzc2VkIHBhcnRzXG4gICAgICAgICAgcmV0dXJuIG5lc3RlZFNlbGVjdG9yLm1hdGNoKGNzc1NlbGVjdG9yLCBtYXRjaGVkQ2FsbGJhY2spO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBTZWxlY3Rvck1hdGNoZXI7XG4gIH0oKSk7XG4gIHZhciBTZWxlY3Rvckxpc3RDb250ZXh0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIFNlbGVjdG9yTGlzdENvbnRleHQoc2VsZWN0b3JzKSB7XG4gICAgICAgICAgdGhpcy5zZWxlY3RvcnMgPSBzZWxlY3RvcnM7XG4gICAgICAgICAgdGhpcy5hbHJlYWR5TWF0Y2hlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFNlbGVjdG9yTGlzdENvbnRleHQ7XG4gIH0oKSk7XG4gIC8vIFN0b3JlIGNvbnRleHQgdG8gcGFzcyBiYWNrIHNlbGVjdG9yIGFuZCBjb250ZXh0IHdoZW4gYSBzZWxlY3RvciBpcyBtYXRjaGVkXG4gIHZhciBTZWxlY3RvckNvbnRleHQgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gU2VsZWN0b3JDb250ZXh0KHNlbGVjdG9yLCBjYkNvbnRleHQsIGxpc3RDb250ZXh0KSB7XG4gICAgICAgICAgdGhpcy5zZWxlY3RvciA9IHNlbGVjdG9yO1xuICAgICAgICAgIHRoaXMuY2JDb250ZXh0ID0gY2JDb250ZXh0O1xuICAgICAgICAgIHRoaXMubGlzdENvbnRleHQgPSBsaXN0Q29udGV4dDtcbiAgICAgICAgICB0aGlzLm5vdFNlbGVjdG9ycyA9IHNlbGVjdG9yLm5vdFNlbGVjdG9ycztcbiAgICAgIH1cbiAgICAgIFNlbGVjdG9yQ29udGV4dC5wcm90b3R5cGUuZmluYWxpemUgPSBmdW5jdGlvbiAoY3NzU2VsZWN0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IHRydWU7XG4gICAgICAgICAgaWYgKHRoaXMubm90U2VsZWN0b3JzLmxlbmd0aCA+IDAgJiYgKCF0aGlzLmxpc3RDb250ZXh0IHx8ICF0aGlzLmxpc3RDb250ZXh0LmFscmVhZHlNYXRjaGVkKSkge1xuICAgICAgICAgICAgICB2YXIgbm90TWF0Y2hlciA9IFNlbGVjdG9yTWF0Y2hlci5jcmVhdGVOb3RNYXRjaGVyKHRoaXMubm90U2VsZWN0b3JzKTtcbiAgICAgICAgICAgICAgcmVzdWx0ID0gIW5vdE1hdGNoZXIubWF0Y2goY3NzU2VsZWN0b3IsIG51bGwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmVzdWx0ICYmIGNhbGxiYWNrICYmICghdGhpcy5saXN0Q29udGV4dCB8fCAhdGhpcy5saXN0Q29udGV4dC5hbHJlYWR5TWF0Y2hlZCkpIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMubGlzdENvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMubGlzdENvbnRleHQuYWxyZWFkeU1hdGNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNhbGxiYWNrKHRoaXMuc2VsZWN0b3IsIHRoaXMuY2JDb250ZXh0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgICByZXR1cm4gU2VsZWN0b3JDb250ZXh0O1xuICB9KCkpO1xuXG4gIHZhciBNT0RVTEVfU1VGRklYID0gJyc7XG4gIGZ1bmN0aW9uIHNwbGl0QXRDb2xvbihpbnB1dCwgZGVmYXVsdFZhbHVlcykge1xuICAgICAgcmV0dXJuIF9zcGxpdEF0KGlucHV0LCAnOicsIGRlZmF1bHRWYWx1ZXMpO1xuICB9XG4gIGZ1bmN0aW9uIHNwbGl0QXRQZXJpb2QoaW5wdXQsIGRlZmF1bHRWYWx1ZXMpIHtcbiAgICAgIHJldHVybiBfc3BsaXRBdChpbnB1dCwgJy4nLCBkZWZhdWx0VmFsdWVzKTtcbiAgfVxuICBmdW5jdGlvbiBfc3BsaXRBdChpbnB1dCwgY2hhcmFjdGVyLCBkZWZhdWx0VmFsdWVzKSB7XG4gICAgICB2YXIgY2hhcmFjdGVySW5kZXggPSBpbnB1dC5pbmRleE9mKGNoYXJhY3Rlcik7XG4gICAgICBpZiAoY2hhcmFjdGVySW5kZXggPT0gLTEpXG4gICAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZXM7XG4gICAgICByZXR1cm4gW2lucHV0LnNsaWNlKDAsIGNoYXJhY3RlckluZGV4KS50cmltKCksIGlucHV0LnNsaWNlKGNoYXJhY3RlckluZGV4ICsgMSkudHJpbSgpXTtcbiAgfVxuICBmdW5jdGlvbiBzYW5pdGl6ZUlkZW50aWZpZXIobmFtZSkge1xuICAgICAgcmV0dXJuIG5hbWUucmVwbGFjZSgvXFxXL2csICdfJyk7XG4gIH1cbiAgZnVuY3Rpb24gdmlzaXRWYWx1ZSh2YWx1ZSwgdmlzaXRvciwgY29udGV4dCkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRBcnJheSh2YWx1ZSwgY29udGV4dCk7XG4gICAgICB9XG4gICAgICBpZiAoaXNTdHJpY3RTdHJpbmdNYXAodmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRTdHJpbmdNYXAodmFsdWUsIGNvbnRleHQpO1xuICAgICAgfVxuICAgICAgaWYgKGlzQmxhbmsodmFsdWUpIHx8IGlzUHJpbWl0aXZlKHZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0UHJpbWl0aXZlKHZhbHVlLCBjb250ZXh0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0T3RoZXIodmFsdWUsIGNvbnRleHQpO1xuICB9XG4gIHZhciBWYWx1ZVRyYW5zZm9ybWVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIFZhbHVlVHJhbnNmb3JtZXIoKSB7XG4gICAgICB9XG4gICAgICBWYWx1ZVRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdEFycmF5ID0gZnVuY3Rpb24gKGFyciwgY29udGV4dCkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgcmV0dXJuIGFyci5tYXAoZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiB2aXNpdFZhbHVlKHZhbHVlLCBfdGhpcywgY29udGV4dCk7IH0pO1xuICAgICAgfTtcbiAgICAgIFZhbHVlVHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0U3RyaW5nTWFwID0gZnVuY3Rpb24gKG1hcCwgY29udGV4dCkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgICAgIE9iamVjdC5rZXlzKG1hcCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IHJlc3VsdFtrZXldID0gdmlzaXRWYWx1ZShtYXBba2V5XSwgX3RoaXMsIGNvbnRleHQpOyB9KTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICAgIFZhbHVlVHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0UHJpbWl0aXZlID0gZnVuY3Rpb24gKHZhbHVlLCBjb250ZXh0KSB7IHJldHVybiB2YWx1ZTsgfTtcbiAgICAgIFZhbHVlVHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0T3RoZXIgPSBmdW5jdGlvbiAodmFsdWUsIGNvbnRleHQpIHsgcmV0dXJuIHZhbHVlOyB9O1xuICAgICAgcmV0dXJuIFZhbHVlVHJhbnNmb3JtZXI7XG4gIH0oKSk7XG4gIHZhciBTeW5jQXN5bmNSZXN1bHQgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gU3luY0FzeW5jUmVzdWx0KHN5bmNSZXN1bHQsIGFzeW5jUmVzdWx0KSB7XG4gICAgICAgICAgaWYgKGFzeW5jUmVzdWx0ID09PSB2b2lkIDApIHsgYXN5bmNSZXN1bHQgPSBudWxsOyB9XG4gICAgICAgICAgdGhpcy5zeW5jUmVzdWx0ID0gc3luY1Jlc3VsdDtcbiAgICAgICAgICB0aGlzLmFzeW5jUmVzdWx0ID0gYXN5bmNSZXN1bHQ7XG4gICAgICAgICAgaWYgKCFhc3luY1Jlc3VsdCkge1xuICAgICAgICAgICAgICB0aGlzLmFzeW5jUmVzdWx0ID0gUHJvbWlzZS5yZXNvbHZlKHN5bmNSZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBTeW5jQXN5bmNSZXN1bHQ7XG4gIH0oKSk7XG5cbiAgLyoqXG4gICAqIEBsaWNlbnNlXG4gICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgKlxuICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAqL1xuICB2YXIgX19leHRlbmRzJDEgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gIH07XG4gIGZ1bmN0aW9uIHVuaW1wbGVtZW50ZWQoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VuaW1wbGVtZW50ZWQnKTtcbiAgfVxuICAvLyBncm91cCAwOiBcIltwcm9wXSBvciAoZXZlbnQpIG9yIEB0cmlnZ2VyXCJcbiAgLy8gZ3JvdXAgMTogXCJwcm9wXCIgZnJvbSBcIltwcm9wXVwiXG4gIC8vIGdyb3VwIDI6IFwiZXZlbnRcIiBmcm9tIFwiKGV2ZW50KVwiXG4gIC8vIGdyb3VwIDM6IFwiQHRyaWdnZXJcIiBmcm9tIFwiQHRyaWdnZXJcIlxuICB2YXIgSE9TVF9SRUdfRVhQID0gL14oPzooPzpcXFsoW15cXF1dKylcXF0pfCg/OlxcKChbXlxcKV0rKVxcKSkpfChcXEBbLVxcd10rKSQvO1xuICB2YXIgQ29tcGlsZU1ldGFkYXRhV2l0aElkZW50aWZpZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gQ29tcGlsZU1ldGFkYXRhV2l0aElkZW50aWZpZXIoKSB7XG4gICAgICB9XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tcGlsZU1ldGFkYXRhV2l0aElkZW50aWZpZXIucHJvdG90eXBlLCBcImlkZW50aWZpZXJcIiwge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdW5pbXBsZW1lbnRlZCgpOyB9LFxuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBDb21waWxlTWV0YWRhdGFXaXRoSWRlbnRpZmllcjtcbiAgfSgpKTtcbiAgdmFyIENvbXBpbGVBbmltYXRpb25FbnRyeU1ldGFkYXRhID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIENvbXBpbGVBbmltYXRpb25FbnRyeU1ldGFkYXRhKG5hbWUsIGRlZmluaXRpb25zKSB7XG4gICAgICAgICAgaWYgKG5hbWUgPT09IHZvaWQgMCkgeyBuYW1lID0gbnVsbDsgfVxuICAgICAgICAgIGlmIChkZWZpbml0aW9ucyA9PT0gdm9pZCAwKSB7IGRlZmluaXRpb25zID0gbnVsbDsgfVxuICAgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgICAgdGhpcy5kZWZpbml0aW9ucyA9IGRlZmluaXRpb25zO1xuICAgICAgfVxuICAgICAgcmV0dXJuIENvbXBpbGVBbmltYXRpb25FbnRyeU1ldGFkYXRhO1xuICB9KCkpO1xuICB2YXIgQ29tcGlsZUFuaW1hdGlvblN0YXRlTWV0YWRhdGEgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gQ29tcGlsZUFuaW1hdGlvblN0YXRlTWV0YWRhdGEoKSB7XG4gICAgICB9XG4gICAgICByZXR1cm4gQ29tcGlsZUFuaW1hdGlvblN0YXRlTWV0YWRhdGE7XG4gIH0oKSk7XG4gIHZhciBDb21waWxlQW5pbWF0aW9uU3RhdGVEZWNsYXJhdGlvbk1ldGFkYXRhID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQxKENvbXBpbGVBbmltYXRpb25TdGF0ZURlY2xhcmF0aW9uTWV0YWRhdGEsIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBDb21waWxlQW5pbWF0aW9uU3RhdGVEZWNsYXJhdGlvbk1ldGFkYXRhKHN0YXRlTmFtZUV4cHIsIHN0eWxlcykge1xuICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgIHRoaXMuc3RhdGVOYW1lRXhwciA9IHN0YXRlTmFtZUV4cHI7XG4gICAgICAgICAgdGhpcy5zdHlsZXMgPSBzdHlsZXM7XG4gICAgICB9XG4gICAgICByZXR1cm4gQ29tcGlsZUFuaW1hdGlvblN0YXRlRGVjbGFyYXRpb25NZXRhZGF0YTtcbiAgfShDb21waWxlQW5pbWF0aW9uU3RhdGVNZXRhZGF0YSkpO1xuICB2YXIgQ29tcGlsZUFuaW1hdGlvblN0YXRlVHJhbnNpdGlvbk1ldGFkYXRhID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQxKENvbXBpbGVBbmltYXRpb25TdGF0ZVRyYW5zaXRpb25NZXRhZGF0YSwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIENvbXBpbGVBbmltYXRpb25TdGF0ZVRyYW5zaXRpb25NZXRhZGF0YShzdGF0ZUNoYW5nZUV4cHIsIHN0ZXBzKSB7XG4gICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgdGhpcy5zdGF0ZUNoYW5nZUV4cHIgPSBzdGF0ZUNoYW5nZUV4cHI7XG4gICAgICAgICAgdGhpcy5zdGVwcyA9IHN0ZXBzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIENvbXBpbGVBbmltYXRpb25TdGF0ZVRyYW5zaXRpb25NZXRhZGF0YTtcbiAgfShDb21waWxlQW5pbWF0aW9uU3RhdGVNZXRhZGF0YSkpO1xuICB2YXIgQ29tcGlsZUFuaW1hdGlvbk1ldGFkYXRhID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIENvbXBpbGVBbmltYXRpb25NZXRhZGF0YSgpIHtcbiAgICAgIH1cbiAgICAgIHJldHVybiBDb21waWxlQW5pbWF0aW9uTWV0YWRhdGE7XG4gIH0oKSk7XG4gIHZhciBDb21waWxlQW5pbWF0aW9uS2V5ZnJhbWVzU2VxdWVuY2VNZXRhZGF0YSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkMShDb21waWxlQW5pbWF0aW9uS2V5ZnJhbWVzU2VxdWVuY2VNZXRhZGF0YSwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIENvbXBpbGVBbmltYXRpb25LZXlmcmFtZXNTZXF1ZW5jZU1ldGFkYXRhKHN0ZXBzKSB7XG4gICAgICAgICAgaWYgKHN0ZXBzID09PSB2b2lkIDApIHsgc3RlcHMgPSBbXTsgfVxuICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgIHRoaXMuc3RlcHMgPSBzdGVwcztcbiAgICAgIH1cbiAgICAgIHJldHVybiBDb21waWxlQW5pbWF0aW9uS2V5ZnJhbWVzU2VxdWVuY2VNZXRhZGF0YTtcbiAgfShDb21waWxlQW5pbWF0aW9uTWV0YWRhdGEpKTtcbiAgdmFyIENvbXBpbGVBbmltYXRpb25TdHlsZU1ldGFkYXRhID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQxKENvbXBpbGVBbmltYXRpb25TdHlsZU1ldGFkYXRhLCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gQ29tcGlsZUFuaW1hdGlvblN0eWxlTWV0YWRhdGEob2Zmc2V0LCBzdHlsZXMpIHtcbiAgICAgICAgICBpZiAoc3R5bGVzID09PSB2b2lkIDApIHsgc3R5bGVzID0gbnVsbDsgfVxuICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICAgIHRoaXMuc3R5bGVzID0gc3R5bGVzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIENvbXBpbGVBbmltYXRpb25TdHlsZU1ldGFkYXRhO1xuICB9KENvbXBpbGVBbmltYXRpb25NZXRhZGF0YSkpO1xuICB2YXIgQ29tcGlsZUFuaW1hdGlvbkFuaW1hdGVNZXRhZGF0YSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkMShDb21waWxlQW5pbWF0aW9uQW5pbWF0ZU1ldGFkYXRhLCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gQ29tcGlsZUFuaW1hdGlvbkFuaW1hdGVNZXRhZGF0YSh0aW1pbmdzLCBzdHlsZXMpIHtcbiAgICAgICAgICBpZiAodGltaW5ncyA9PT0gdm9pZCAwKSB7IHRpbWluZ3MgPSAwOyB9XG4gICAgICAgICAgaWYgKHN0eWxlcyA9PT0gdm9pZCAwKSB7IHN0eWxlcyA9IG51bGw7IH1cbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICB0aGlzLnRpbWluZ3MgPSB0aW1pbmdzO1xuICAgICAgICAgIHRoaXMuc3R5bGVzID0gc3R5bGVzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIENvbXBpbGVBbmltYXRpb25BbmltYXRlTWV0YWRhdGE7XG4gIH0oQ29tcGlsZUFuaW1hdGlvbk1ldGFkYXRhKSk7XG4gIHZhciBDb21waWxlQW5pbWF0aW9uV2l0aFN0ZXBzTWV0YWRhdGEgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDEoQ29tcGlsZUFuaW1hdGlvbldpdGhTdGVwc01ldGFkYXRhLCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gQ29tcGlsZUFuaW1hdGlvbldpdGhTdGVwc01ldGFkYXRhKHN0ZXBzKSB7XG4gICAgICAgICAgaWYgKHN0ZXBzID09PSB2b2lkIDApIHsgc3RlcHMgPSBudWxsOyB9XG4gICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgdGhpcy5zdGVwcyA9IHN0ZXBzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIENvbXBpbGVBbmltYXRpb25XaXRoU3RlcHNNZXRhZGF0YTtcbiAgfShDb21waWxlQW5pbWF0aW9uTWV0YWRhdGEpKTtcbiAgdmFyIENvbXBpbGVBbmltYXRpb25TZXF1ZW5jZU1ldGFkYXRhID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQxKENvbXBpbGVBbmltYXRpb25TZXF1ZW5jZU1ldGFkYXRhLCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gQ29tcGlsZUFuaW1hdGlvblNlcXVlbmNlTWV0YWRhdGEoc3RlcHMpIHtcbiAgICAgICAgICBpZiAoc3RlcHMgPT09IHZvaWQgMCkgeyBzdGVwcyA9IG51bGw7IH1cbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBzdGVwcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gQ29tcGlsZUFuaW1hdGlvblNlcXVlbmNlTWV0YWRhdGE7XG4gIH0oQ29tcGlsZUFuaW1hdGlvbldpdGhTdGVwc01ldGFkYXRhKSk7XG4gIHZhciBDb21waWxlQW5pbWF0aW9uR3JvdXBNZXRhZGF0YSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkMShDb21waWxlQW5pbWF0aW9uR3JvdXBNZXRhZGF0YSwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIENvbXBpbGVBbmltYXRpb25Hcm91cE1ldGFkYXRhKHN0ZXBzKSB7XG4gICAgICAgICAgaWYgKHN0ZXBzID09PSB2b2lkIDApIHsgc3RlcHMgPSBudWxsOyB9XG4gICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgc3RlcHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIENvbXBpbGVBbmltYXRpb25Hcm91cE1ldGFkYXRhO1xuICB9KENvbXBpbGVBbmltYXRpb25XaXRoU3RlcHNNZXRhZGF0YSkpO1xuICB2YXIgQ29tcGlsZUlkZW50aWZpZXJNZXRhZGF0YSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBDb21waWxlSWRlbnRpZmllck1ldGFkYXRhKF9hKSB7XG4gICAgICAgICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIHJlZmVyZW5jZSA9IF9iLnJlZmVyZW5jZSwgbmFtZSA9IF9iLm5hbWUsIG1vZHVsZVVybCA9IF9iLm1vZHVsZVVybCwgcHJlZml4ID0gX2IucHJlZml4LCB2YWx1ZSA9IF9iLnZhbHVlO1xuICAgICAgICAgIHRoaXMucmVmZXJlbmNlID0gcmVmZXJlbmNlO1xuICAgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgICAgdGhpcy5wcmVmaXggPSBwcmVmaXg7XG4gICAgICAgICAgdGhpcy5tb2R1bGVVcmwgPSBtb2R1bGVVcmw7XG4gICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbXBpbGVJZGVudGlmaWVyTWV0YWRhdGEucHJvdG90eXBlLCBcImlkZW50aWZpZXJcIiwge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gQ29tcGlsZUlkZW50aWZpZXJNZXRhZGF0YTtcbiAgfSgpKTtcbiAgdmFyIENvbXBpbGVEaURlcGVuZGVuY3lNZXRhZGF0YSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBDb21waWxlRGlEZXBlbmRlbmN5TWV0YWRhdGEoX2EpIHtcbiAgICAgICAgICB2YXIgX2IgPSBfYSA9PT0gdm9pZCAwID8ge30gOiBfYSwgaXNBdHRyaWJ1dGUgPSBfYi5pc0F0dHJpYnV0ZSwgaXNTZWxmID0gX2IuaXNTZWxmLCBpc0hvc3QgPSBfYi5pc0hvc3QsIGlzU2tpcFNlbGYgPSBfYi5pc1NraXBTZWxmLCBpc09wdGlvbmFsID0gX2IuaXNPcHRpb25hbCwgaXNWYWx1ZSA9IF9iLmlzVmFsdWUsIHF1ZXJ5ID0gX2IucXVlcnksIHZpZXdRdWVyeSA9IF9iLnZpZXdRdWVyeSwgdG9rZW4gPSBfYi50b2tlbiwgdmFsdWUgPSBfYi52YWx1ZTtcbiAgICAgICAgICB0aGlzLmlzQXR0cmlidXRlID0gISFpc0F0dHJpYnV0ZTtcbiAgICAgICAgICB0aGlzLmlzU2VsZiA9ICEhaXNTZWxmO1xuICAgICAgICAgIHRoaXMuaXNIb3N0ID0gISFpc0hvc3Q7XG4gICAgICAgICAgdGhpcy5pc1NraXBTZWxmID0gISFpc1NraXBTZWxmO1xuICAgICAgICAgIHRoaXMuaXNPcHRpb25hbCA9ICEhaXNPcHRpb25hbDtcbiAgICAgICAgICB0aGlzLmlzVmFsdWUgPSAhIWlzVmFsdWU7XG4gICAgICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5O1xuICAgICAgICAgIHRoaXMudmlld1F1ZXJ5ID0gdmlld1F1ZXJ5O1xuICAgICAgICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcbiAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gQ29tcGlsZURpRGVwZW5kZW5jeU1ldGFkYXRhO1xuICB9KCkpO1xuICB2YXIgQ29tcGlsZVByb3ZpZGVyTWV0YWRhdGEgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gQ29tcGlsZVByb3ZpZGVyTWV0YWRhdGEoX2EpIHtcbiAgICAgICAgICB2YXIgdG9rZW4gPSBfYS50b2tlbiwgdXNlQ2xhc3MgPSBfYS51c2VDbGFzcywgdXNlVmFsdWUgPSBfYS51c2VWYWx1ZSwgdXNlRXhpc3RpbmcgPSBfYS51c2VFeGlzdGluZywgdXNlRmFjdG9yeSA9IF9hLnVzZUZhY3RvcnksIGRlcHMgPSBfYS5kZXBzLCBtdWx0aSA9IF9hLm11bHRpO1xuICAgICAgICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcbiAgICAgICAgICB0aGlzLnVzZUNsYXNzID0gdXNlQ2xhc3M7XG4gICAgICAgICAgdGhpcy51c2VWYWx1ZSA9IHVzZVZhbHVlO1xuICAgICAgICAgIHRoaXMudXNlRXhpc3RpbmcgPSB1c2VFeGlzdGluZztcbiAgICAgICAgICB0aGlzLnVzZUZhY3RvcnkgPSB1c2VGYWN0b3J5O1xuICAgICAgICAgIHRoaXMuZGVwcyA9IGRlcHMgfHwgbnVsbDtcbiAgICAgICAgICB0aGlzLm11bHRpID0gISFtdWx0aTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBDb21waWxlUHJvdmlkZXJNZXRhZGF0YTtcbiAgfSgpKTtcbiAgdmFyIENvbXBpbGVGYWN0b3J5TWV0YWRhdGEgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDEoQ29tcGlsZUZhY3RvcnlNZXRhZGF0YSwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIENvbXBpbGVGYWN0b3J5TWV0YWRhdGEoX2EpIHtcbiAgICAgICAgICB2YXIgcmVmZXJlbmNlID0gX2EucmVmZXJlbmNlLCBuYW1lID0gX2EubmFtZSwgbW9kdWxlVXJsID0gX2EubW9kdWxlVXJsLCBwcmVmaXggPSBfYS5wcmVmaXgsIGRpRGVwcyA9IF9hLmRpRGVwcywgdmFsdWUgPSBfYS52YWx1ZTtcbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCB7IHJlZmVyZW5jZTogcmVmZXJlbmNlLCBuYW1lOiBuYW1lLCBwcmVmaXg6IHByZWZpeCwgbW9kdWxlVXJsOiBtb2R1bGVVcmwsIHZhbHVlOiB2YWx1ZSB9KTtcbiAgICAgICAgICB0aGlzLmRpRGVwcyA9IF9ub3JtYWxpemVBcnJheShkaURlcHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIENvbXBpbGVGYWN0b3J5TWV0YWRhdGE7XG4gIH0oQ29tcGlsZUlkZW50aWZpZXJNZXRhZGF0YSkpO1xuICB2YXIgQ29tcGlsZVRva2VuTWV0YWRhdGEgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gQ29tcGlsZVRva2VuTWV0YWRhdGEoX2EpIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBfYS52YWx1ZSwgaWRlbnRpZmllciA9IF9hLmlkZW50aWZpZXIsIGlkZW50aWZpZXJJc0luc3RhbmNlID0gX2EuaWRlbnRpZmllcklzSW5zdGFuY2U7XG4gICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgIHRoaXMuaWRlbnRpZmllciA9IGlkZW50aWZpZXI7XG4gICAgICAgICAgdGhpcy5pZGVudGlmaWVySXNJbnN0YW5jZSA9ICEhaWRlbnRpZmllcklzSW5zdGFuY2U7XG4gICAgICB9XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tcGlsZVRva2VuTWV0YWRhdGEucHJvdG90eXBlLCBcInJlZmVyZW5jZVwiLCB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5pZGVudGlmaWVyKSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaWRlbnRpZmllci5yZWZlcmVuY2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbXBpbGVUb2tlbk1ldGFkYXRhLnByb3RvdHlwZSwgXCJuYW1lXCIsIHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGlzUHJlc2VudCh0aGlzLnZhbHVlKSA/IHNhbml0aXplSWRlbnRpZmllcih0aGlzLnZhbHVlKSA6IHRoaXMuaWRlbnRpZmllci5uYW1lO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIENvbXBpbGVUb2tlbk1ldGFkYXRhO1xuICB9KCkpO1xuICAvKipcbiAgICogTWV0YWRhdGEgcmVnYXJkaW5nIGNvbXBpbGF0aW9uIG9mIGEgdHlwZS5cbiAgICovXG4gIHZhciBDb21waWxlVHlwZU1ldGFkYXRhID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQxKENvbXBpbGVUeXBlTWV0YWRhdGEsIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBDb21waWxlVHlwZU1ldGFkYXRhKF9hKSB7XG4gICAgICAgICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIHJlZmVyZW5jZSA9IF9iLnJlZmVyZW5jZSwgbmFtZSA9IF9iLm5hbWUsIG1vZHVsZVVybCA9IF9iLm1vZHVsZVVybCwgcHJlZml4ID0gX2IucHJlZml4LCBpc0hvc3QgPSBfYi5pc0hvc3QsIHZhbHVlID0gX2IudmFsdWUsIGRpRGVwcyA9IF9iLmRpRGVwcywgbGlmZWN5Y2xlSG9va3MgPSBfYi5saWZlY3ljbGVIb29rcztcbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCB7IHJlZmVyZW5jZTogcmVmZXJlbmNlLCBuYW1lOiBuYW1lLCBtb2R1bGVVcmw6IG1vZHVsZVVybCwgcHJlZml4OiBwcmVmaXgsIHZhbHVlOiB2YWx1ZSB9KTtcbiAgICAgICAgICB0aGlzLmlzSG9zdCA9ICEhaXNIb3N0O1xuICAgICAgICAgIHRoaXMuZGlEZXBzID0gX25vcm1hbGl6ZUFycmF5KGRpRGVwcyk7XG4gICAgICAgICAgdGhpcy5saWZlY3ljbGVIb29rcyA9IF9ub3JtYWxpemVBcnJheShsaWZlY3ljbGVIb29rcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gQ29tcGlsZVR5cGVNZXRhZGF0YTtcbiAgfShDb21waWxlSWRlbnRpZmllck1ldGFkYXRhKSk7XG4gIHZhciBDb21waWxlUXVlcnlNZXRhZGF0YSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBDb21waWxlUXVlcnlNZXRhZGF0YShfYSkge1xuICAgICAgICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLCBzZWxlY3RvcnMgPSBfYi5zZWxlY3RvcnMsIGRlc2NlbmRhbnRzID0gX2IuZGVzY2VuZGFudHMsIGZpcnN0ID0gX2IuZmlyc3QsIHByb3BlcnR5TmFtZSA9IF9iLnByb3BlcnR5TmFtZSwgcmVhZCA9IF9iLnJlYWQ7XG4gICAgICAgICAgdGhpcy5zZWxlY3RvcnMgPSBzZWxlY3RvcnM7XG4gICAgICAgICAgdGhpcy5kZXNjZW5kYW50cyA9ICEhZGVzY2VuZGFudHM7XG4gICAgICAgICAgdGhpcy5maXJzdCA9ICEhZmlyc3Q7XG4gICAgICAgICAgdGhpcy5wcm9wZXJ0eU5hbWUgPSBwcm9wZXJ0eU5hbWU7XG4gICAgICAgICAgdGhpcy5yZWFkID0gcmVhZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBDb21waWxlUXVlcnlNZXRhZGF0YTtcbiAgfSgpKTtcbiAgLyoqXG4gICAqIE1ldGFkYXRhIGFib3V0IGEgc3R5bGVzaGVldFxuICAgKi9cbiAgdmFyIENvbXBpbGVTdHlsZXNoZWV0TWV0YWRhdGEgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gQ29tcGlsZVN0eWxlc2hlZXRNZXRhZGF0YShfYSkge1xuICAgICAgICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLCBtb2R1bGVVcmwgPSBfYi5tb2R1bGVVcmwsIHN0eWxlcyA9IF9iLnN0eWxlcywgc3R5bGVVcmxzID0gX2Iuc3R5bGVVcmxzO1xuICAgICAgICAgIHRoaXMubW9kdWxlVXJsID0gbW9kdWxlVXJsO1xuICAgICAgICAgIHRoaXMuc3R5bGVzID0gX25vcm1hbGl6ZUFycmF5KHN0eWxlcyk7XG4gICAgICAgICAgdGhpcy5zdHlsZVVybHMgPSBfbm9ybWFsaXplQXJyYXkoc3R5bGVVcmxzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBDb21waWxlU3R5bGVzaGVldE1ldGFkYXRhO1xuICB9KCkpO1xuICAvKipcbiAgICogTWV0YWRhdGEgcmVnYXJkaW5nIGNvbXBpbGF0aW9uIG9mIGEgdGVtcGxhdGUuXG4gICAqL1xuICB2YXIgQ29tcGlsZVRlbXBsYXRlTWV0YWRhdGEgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gQ29tcGlsZVRlbXBsYXRlTWV0YWRhdGEoX2EpIHtcbiAgICAgICAgICB2YXIgX2IgPSBfYSA9PT0gdm9pZCAwID8ge30gOiBfYSwgZW5jYXBzdWxhdGlvbiA9IF9iLmVuY2Fwc3VsYXRpb24sIHRlbXBsYXRlID0gX2IudGVtcGxhdGUsIHRlbXBsYXRlVXJsID0gX2IudGVtcGxhdGVVcmwsIHN0eWxlcyA9IF9iLnN0eWxlcywgc3R5bGVVcmxzID0gX2Iuc3R5bGVVcmxzLCBleHRlcm5hbFN0eWxlc2hlZXRzID0gX2IuZXh0ZXJuYWxTdHlsZXNoZWV0cywgYW5pbWF0aW9ucyA9IF9iLmFuaW1hdGlvbnMsIG5nQ29udGVudFNlbGVjdG9ycyA9IF9iLm5nQ29udGVudFNlbGVjdG9ycywgaW50ZXJwb2xhdGlvbiA9IF9iLmludGVycG9sYXRpb247XG4gICAgICAgICAgdGhpcy5lbmNhcHN1bGF0aW9uID0gZW5jYXBzdWxhdGlvbjtcbiAgICAgICAgICB0aGlzLnRlbXBsYXRlID0gdGVtcGxhdGU7XG4gICAgICAgICAgdGhpcy50ZW1wbGF0ZVVybCA9IHRlbXBsYXRlVXJsO1xuICAgICAgICAgIHRoaXMuc3R5bGVzID0gX25vcm1hbGl6ZUFycmF5KHN0eWxlcyk7XG4gICAgICAgICAgdGhpcy5zdHlsZVVybHMgPSBfbm9ybWFsaXplQXJyYXkoc3R5bGVVcmxzKTtcbiAgICAgICAgICB0aGlzLmV4dGVybmFsU3R5bGVzaGVldHMgPSBfbm9ybWFsaXplQXJyYXkoZXh0ZXJuYWxTdHlsZXNoZWV0cyk7XG4gICAgICAgICAgdGhpcy5hbmltYXRpb25zID0gYW5pbWF0aW9ucyA/IExpc3RXcmFwcGVyLmZsYXR0ZW4oYW5pbWF0aW9ucykgOiBbXTtcbiAgICAgICAgICB0aGlzLm5nQ29udGVudFNlbGVjdG9ycyA9IG5nQ29udGVudFNlbGVjdG9ycyB8fCBbXTtcbiAgICAgICAgICBpZiAoaW50ZXJwb2xhdGlvbiAmJiBpbnRlcnBvbGF0aW9uLmxlbmd0aCAhPSAyKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIidpbnRlcnBvbGF0aW9uJyBzaG91bGQgaGF2ZSBhIHN0YXJ0IGFuZCBhbiBlbmQgc3ltYm9sLlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5pbnRlcnBvbGF0aW9uID0gaW50ZXJwb2xhdGlvbjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBDb21waWxlVGVtcGxhdGVNZXRhZGF0YTtcbiAgfSgpKTtcbiAgLyoqXG4gICAqIE1ldGFkYXRhIHJlZ2FyZGluZyBjb21waWxhdGlvbiBvZiBhIGRpcmVjdGl2ZS5cbiAgICovXG4gIHZhciBDb21waWxlRGlyZWN0aXZlTWV0YWRhdGEgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gQ29tcGlsZURpcmVjdGl2ZU1ldGFkYXRhKF9hKSB7XG4gICAgICAgICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIHR5cGUgPSBfYi50eXBlLCBpc0NvbXBvbmVudCA9IF9iLmlzQ29tcG9uZW50LCBzZWxlY3RvciA9IF9iLnNlbGVjdG9yLCBleHBvcnRBcyA9IF9iLmV4cG9ydEFzLCBjaGFuZ2VEZXRlY3Rpb24gPSBfYi5jaGFuZ2VEZXRlY3Rpb24sIGlucHV0cyA9IF9iLmlucHV0cywgb3V0cHV0cyA9IF9iLm91dHB1dHMsIGhvc3RMaXN0ZW5lcnMgPSBfYi5ob3N0TGlzdGVuZXJzLCBob3N0UHJvcGVydGllcyA9IF9iLmhvc3RQcm9wZXJ0aWVzLCBob3N0QXR0cmlidXRlcyA9IF9iLmhvc3RBdHRyaWJ1dGVzLCBwcm92aWRlcnMgPSBfYi5wcm92aWRlcnMsIHZpZXdQcm92aWRlcnMgPSBfYi52aWV3UHJvdmlkZXJzLCBxdWVyaWVzID0gX2IucXVlcmllcywgdmlld1F1ZXJpZXMgPSBfYi52aWV3UXVlcmllcywgZW50cnlDb21wb25lbnRzID0gX2IuZW50cnlDb21wb25lbnRzLCB0ZW1wbGF0ZSA9IF9iLnRlbXBsYXRlO1xuICAgICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgICAgdGhpcy5pc0NvbXBvbmVudCA9IGlzQ29tcG9uZW50O1xuICAgICAgICAgIHRoaXMuc2VsZWN0b3IgPSBzZWxlY3RvcjtcbiAgICAgICAgICB0aGlzLmV4cG9ydEFzID0gZXhwb3J0QXM7XG4gICAgICAgICAgdGhpcy5jaGFuZ2VEZXRlY3Rpb24gPSBjaGFuZ2VEZXRlY3Rpb247XG4gICAgICAgICAgdGhpcy5pbnB1dHMgPSBpbnB1dHM7XG4gICAgICAgICAgdGhpcy5vdXRwdXRzID0gb3V0cHV0cztcbiAgICAgICAgICB0aGlzLmhvc3RMaXN0ZW5lcnMgPSBob3N0TGlzdGVuZXJzO1xuICAgICAgICAgIHRoaXMuaG9zdFByb3BlcnRpZXMgPSBob3N0UHJvcGVydGllcztcbiAgICAgICAgICB0aGlzLmhvc3RBdHRyaWJ1dGVzID0gaG9zdEF0dHJpYnV0ZXM7XG4gICAgICAgICAgdGhpcy5wcm92aWRlcnMgPSBfbm9ybWFsaXplQXJyYXkocHJvdmlkZXJzKTtcbiAgICAgICAgICB0aGlzLnZpZXdQcm92aWRlcnMgPSBfbm9ybWFsaXplQXJyYXkodmlld1Byb3ZpZGVycyk7XG4gICAgICAgICAgdGhpcy5xdWVyaWVzID0gX25vcm1hbGl6ZUFycmF5KHF1ZXJpZXMpO1xuICAgICAgICAgIHRoaXMudmlld1F1ZXJpZXMgPSBfbm9ybWFsaXplQXJyYXkodmlld1F1ZXJpZXMpO1xuICAgICAgICAgIHRoaXMuZW50cnlDb21wb25lbnRzID0gX25vcm1hbGl6ZUFycmF5KGVudHJ5Q29tcG9uZW50cyk7XG4gICAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IHRlbXBsYXRlO1xuICAgICAgfVxuICAgICAgQ29tcGlsZURpcmVjdGl2ZU1ldGFkYXRhLmNyZWF0ZSA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLCB0eXBlID0gX2IudHlwZSwgaXNDb21wb25lbnQgPSBfYi5pc0NvbXBvbmVudCwgc2VsZWN0b3IgPSBfYi5zZWxlY3RvciwgZXhwb3J0QXMgPSBfYi5leHBvcnRBcywgY2hhbmdlRGV0ZWN0aW9uID0gX2IuY2hhbmdlRGV0ZWN0aW9uLCBpbnB1dHMgPSBfYi5pbnB1dHMsIG91dHB1dHMgPSBfYi5vdXRwdXRzLCBob3N0ID0gX2IuaG9zdCwgcHJvdmlkZXJzID0gX2IucHJvdmlkZXJzLCB2aWV3UHJvdmlkZXJzID0gX2Iudmlld1Byb3ZpZGVycywgcXVlcmllcyA9IF9iLnF1ZXJpZXMsIHZpZXdRdWVyaWVzID0gX2Iudmlld1F1ZXJpZXMsIGVudHJ5Q29tcG9uZW50cyA9IF9iLmVudHJ5Q29tcG9uZW50cywgdGVtcGxhdGUgPSBfYi50ZW1wbGF0ZTtcbiAgICAgICAgICB2YXIgaG9zdExpc3RlbmVycyA9IHt9O1xuICAgICAgICAgIHZhciBob3N0UHJvcGVydGllcyA9IHt9O1xuICAgICAgICAgIHZhciBob3N0QXR0cmlidXRlcyA9IHt9O1xuICAgICAgICAgIGlmIChpc1ByZXNlbnQoaG9zdCkpIHtcbiAgICAgICAgICAgICAgT2JqZWN0LmtleXMoaG9zdCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBob3N0W2tleV07XG4gICAgICAgICAgICAgICAgICB2YXIgbWF0Y2hlcyA9IGtleS5tYXRjaChIT1NUX1JFR19FWFApO1xuICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoZXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICBob3N0QXR0cmlidXRlc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBlbHNlIGlmIChpc1ByZXNlbnQobWF0Y2hlc1sxXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICBob3N0UHJvcGVydGllc1ttYXRjaGVzWzFdXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNQcmVzZW50KG1hdGNoZXNbMl0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaG9zdExpc3RlbmVyc1ttYXRjaGVzWzJdXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGlucHV0c01hcCA9IHt9O1xuICAgICAgICAgIGlmIChpc1ByZXNlbnQoaW5wdXRzKSkge1xuICAgICAgICAgICAgICBpbnB1dHMuZm9yRWFjaChmdW5jdGlvbiAoYmluZENvbmZpZykge1xuICAgICAgICAgICAgICAgICAgLy8gY2Fub25pY2FsIHN5bnRheDogYGRpclByb3A6IGVsUHJvcGBcbiAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIG5vIGA6YCwgdXNlIGRpclByb3AgPSBlbFByb3BcbiAgICAgICAgICAgICAgICAgIHZhciBwYXJ0cyA9IHNwbGl0QXRDb2xvbihiaW5kQ29uZmlnLCBbYmluZENvbmZpZywgYmluZENvbmZpZ10pO1xuICAgICAgICAgICAgICAgICAgaW5wdXRzTWFwW3BhcnRzWzBdXSA9IHBhcnRzWzFdO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIG91dHB1dHNNYXAgPSB7fTtcbiAgICAgICAgICBpZiAoaXNQcmVzZW50KG91dHB1dHMpKSB7XG4gICAgICAgICAgICAgIG91dHB1dHMuZm9yRWFjaChmdW5jdGlvbiAoYmluZENvbmZpZykge1xuICAgICAgICAgICAgICAgICAgLy8gY2Fub25pY2FsIHN5bnRheDogYGRpclByb3A6IGVsUHJvcGBcbiAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIG5vIGA6YCwgdXNlIGRpclByb3AgPSBlbFByb3BcbiAgICAgICAgICAgICAgICAgIHZhciBwYXJ0cyA9IHNwbGl0QXRDb2xvbihiaW5kQ29uZmlnLCBbYmluZENvbmZpZywgYmluZENvbmZpZ10pO1xuICAgICAgICAgICAgICAgICAgb3V0cHV0c01hcFtwYXJ0c1swXV0gPSBwYXJ0c1sxXTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuZXcgQ29tcGlsZURpcmVjdGl2ZU1ldGFkYXRhKHtcbiAgICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgICAgaXNDb21wb25lbnQ6ICEhaXNDb21wb25lbnQsIHNlbGVjdG9yOiBzZWxlY3RvciwgZXhwb3J0QXM6IGV4cG9ydEFzLCBjaGFuZ2VEZXRlY3Rpb246IGNoYW5nZURldGVjdGlvbixcbiAgICAgICAgICAgICAgaW5wdXRzOiBpbnB1dHNNYXAsXG4gICAgICAgICAgICAgIG91dHB1dHM6IG91dHB1dHNNYXAsXG4gICAgICAgICAgICAgIGhvc3RMaXN0ZW5lcnM6IGhvc3RMaXN0ZW5lcnMsXG4gICAgICAgICAgICAgIGhvc3RQcm9wZXJ0aWVzOiBob3N0UHJvcGVydGllcyxcbiAgICAgICAgICAgICAgaG9zdEF0dHJpYnV0ZXM6IGhvc3RBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICBwcm92aWRlcnM6IHByb3ZpZGVycyxcbiAgICAgICAgICAgICAgdmlld1Byb3ZpZGVyczogdmlld1Byb3ZpZGVycyxcbiAgICAgICAgICAgICAgcXVlcmllczogcXVlcmllcyxcbiAgICAgICAgICAgICAgdmlld1F1ZXJpZXM6IHZpZXdRdWVyaWVzLFxuICAgICAgICAgICAgICBlbnRyeUNvbXBvbmVudHM6IGVudHJ5Q29tcG9uZW50cyxcbiAgICAgICAgICAgICAgdGVtcGxhdGU6IHRlbXBsYXRlLFxuICAgICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21waWxlRGlyZWN0aXZlTWV0YWRhdGEucHJvdG90eXBlLCBcImlkZW50aWZpZXJcIiwge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy50eXBlOyB9LFxuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBDb21waWxlRGlyZWN0aXZlTWV0YWRhdGE7XG4gIH0oKSk7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3Qge0BsaW5rIENvbXBpbGVEaXJlY3RpdmVNZXRhZGF0YX0gZnJvbSB7QGxpbmsgQ29tcG9uZW50VHlwZU1ldGFkYXRhfSBhbmQgYSBzZWxlY3Rvci5cbiAgICovXG4gIGZ1bmN0aW9uIGNyZWF0ZUhvc3RDb21wb25lbnRNZXRhKGNvbXBNZXRhKSB7XG4gICAgICB2YXIgdGVtcGxhdGUgPSBDc3NTZWxlY3Rvci5wYXJzZShjb21wTWV0YS5zZWxlY3RvcilbMF0uZ2V0TWF0Y2hpbmdFbGVtZW50VGVtcGxhdGUoKTtcbiAgICAgIHJldHVybiBDb21waWxlRGlyZWN0aXZlTWV0YWRhdGEuY3JlYXRlKHtcbiAgICAgICAgICB0eXBlOiBuZXcgQ29tcGlsZVR5cGVNZXRhZGF0YSh7XG4gICAgICAgICAgICAgIHJlZmVyZW5jZTogT2JqZWN0LFxuICAgICAgICAgICAgICBuYW1lOiBjb21wTWV0YS50eXBlLm5hbWUgKyBcIl9Ib3N0XCIsXG4gICAgICAgICAgICAgIG1vZHVsZVVybDogY29tcE1ldGEudHlwZS5tb2R1bGVVcmwsXG4gICAgICAgICAgICAgIGlzSG9zdDogdHJ1ZVxuICAgICAgICAgIH0pLFxuICAgICAgICAgIHRlbXBsYXRlOiBuZXcgQ29tcGlsZVRlbXBsYXRlTWV0YWRhdGEoe1xuICAgICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiBfYW5ndWxhcl9jb3JlLlZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG4gICAgICAgICAgICAgIHRlbXBsYXRlOiB0ZW1wbGF0ZSxcbiAgICAgICAgICAgICAgdGVtcGxhdGVVcmw6ICcnLFxuICAgICAgICAgICAgICBzdHlsZXM6IFtdLFxuICAgICAgICAgICAgICBzdHlsZVVybHM6IFtdLFxuICAgICAgICAgICAgICBuZ0NvbnRlbnRTZWxlY3RvcnM6IFtdLFxuICAgICAgICAgICAgICBhbmltYXRpb25zOiBbXVxuICAgICAgICAgIH0pLFxuICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogX2FuZ3VsYXJfY29yZS5DaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5EZWZhdWx0LFxuICAgICAgICAgIGlucHV0czogW10sXG4gICAgICAgICAgb3V0cHV0czogW10sXG4gICAgICAgICAgaG9zdDoge30sXG4gICAgICAgICAgaXNDb21wb25lbnQ6IHRydWUsXG4gICAgICAgICAgc2VsZWN0b3I6ICcqJyxcbiAgICAgICAgICBwcm92aWRlcnM6IFtdLFxuICAgICAgICAgIHZpZXdQcm92aWRlcnM6IFtdLFxuICAgICAgICAgIHF1ZXJpZXM6IFtdLFxuICAgICAgICAgIHZpZXdRdWVyaWVzOiBbXVxuICAgICAgfSk7XG4gIH1cbiAgdmFyIENvbXBpbGVQaXBlTWV0YWRhdGEgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gQ29tcGlsZVBpcGVNZXRhZGF0YShfYSkge1xuICAgICAgICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLCB0eXBlID0gX2IudHlwZSwgbmFtZSA9IF9iLm5hbWUsIHB1cmUgPSBfYi5wdXJlO1xuICAgICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgICB0aGlzLnB1cmUgPSAhIXB1cmU7XG4gICAgICB9XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tcGlsZVBpcGVNZXRhZGF0YS5wcm90b3R5cGUsIFwiaWRlbnRpZmllclwiLCB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnR5cGU7IH0sXG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIENvbXBpbGVQaXBlTWV0YWRhdGE7XG4gIH0oKSk7XG4gIC8qKlxuICAgKiBNZXRhZGF0YSByZWdhcmRpbmcgY29tcGlsYXRpb24gb2YgYSBtb2R1bGUuXG4gICAqL1xuICB2YXIgQ29tcGlsZU5nTW9kdWxlTWV0YWRhdGEgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gQ29tcGlsZU5nTW9kdWxlTWV0YWRhdGEoX2EpIHtcbiAgICAgICAgICB2YXIgX2IgPSBfYSA9PT0gdm9pZCAwID8ge30gOiBfYSwgdHlwZSA9IF9iLnR5cGUsIHByb3ZpZGVycyA9IF9iLnByb3ZpZGVycywgZGVjbGFyZWREaXJlY3RpdmVzID0gX2IuZGVjbGFyZWREaXJlY3RpdmVzLCBleHBvcnRlZERpcmVjdGl2ZXMgPSBfYi5leHBvcnRlZERpcmVjdGl2ZXMsIGRlY2xhcmVkUGlwZXMgPSBfYi5kZWNsYXJlZFBpcGVzLCBleHBvcnRlZFBpcGVzID0gX2IuZXhwb3J0ZWRQaXBlcywgZW50cnlDb21wb25lbnRzID0gX2IuZW50cnlDb21wb25lbnRzLCBib290c3RyYXBDb21wb25lbnRzID0gX2IuYm9vdHN0cmFwQ29tcG9uZW50cywgaW1wb3J0ZWRNb2R1bGVzID0gX2IuaW1wb3J0ZWRNb2R1bGVzLCBleHBvcnRlZE1vZHVsZXMgPSBfYi5leHBvcnRlZE1vZHVsZXMsIHNjaGVtYXMgPSBfYi5zY2hlbWFzLCB0cmFuc2l0aXZlTW9kdWxlID0gX2IudHJhbnNpdGl2ZU1vZHVsZSwgaWQgPSBfYi5pZDtcbiAgICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICAgIHRoaXMuZGVjbGFyZWREaXJlY3RpdmVzID0gX25vcm1hbGl6ZUFycmF5KGRlY2xhcmVkRGlyZWN0aXZlcyk7XG4gICAgICAgICAgdGhpcy5leHBvcnRlZERpcmVjdGl2ZXMgPSBfbm9ybWFsaXplQXJyYXkoZXhwb3J0ZWREaXJlY3RpdmVzKTtcbiAgICAgICAgICB0aGlzLmRlY2xhcmVkUGlwZXMgPSBfbm9ybWFsaXplQXJyYXkoZGVjbGFyZWRQaXBlcyk7XG4gICAgICAgICAgdGhpcy5leHBvcnRlZFBpcGVzID0gX25vcm1hbGl6ZUFycmF5KGV4cG9ydGVkUGlwZXMpO1xuICAgICAgICAgIHRoaXMucHJvdmlkZXJzID0gX25vcm1hbGl6ZUFycmF5KHByb3ZpZGVycyk7XG4gICAgICAgICAgdGhpcy5lbnRyeUNvbXBvbmVudHMgPSBfbm9ybWFsaXplQXJyYXkoZW50cnlDb21wb25lbnRzKTtcbiAgICAgICAgICB0aGlzLmJvb3RzdHJhcENvbXBvbmVudHMgPSBfbm9ybWFsaXplQXJyYXkoYm9vdHN0cmFwQ29tcG9uZW50cyk7XG4gICAgICAgICAgdGhpcy5pbXBvcnRlZE1vZHVsZXMgPSBfbm9ybWFsaXplQXJyYXkoaW1wb3J0ZWRNb2R1bGVzKTtcbiAgICAgICAgICB0aGlzLmV4cG9ydGVkTW9kdWxlcyA9IF9ub3JtYWxpemVBcnJheShleHBvcnRlZE1vZHVsZXMpO1xuICAgICAgICAgIHRoaXMuc2NoZW1hcyA9IF9ub3JtYWxpemVBcnJheShzY2hlbWFzKTtcbiAgICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgICAgdGhpcy50cmFuc2l0aXZlTW9kdWxlID0gdHJhbnNpdGl2ZU1vZHVsZTtcbiAgICAgIH1cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21waWxlTmdNb2R1bGVNZXRhZGF0YS5wcm90b3R5cGUsIFwiaWRlbnRpZmllclwiLCB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnR5cGU7IH0sXG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIENvbXBpbGVOZ01vZHVsZU1ldGFkYXRhO1xuICB9KCkpO1xuICB2YXIgVHJhbnNpdGl2ZUNvbXBpbGVOZ01vZHVsZU1ldGFkYXRhID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIFRyYW5zaXRpdmVDb21waWxlTmdNb2R1bGVNZXRhZGF0YShtb2R1bGVzLCBwcm92aWRlcnMsIGVudHJ5Q29tcG9uZW50cywgZGlyZWN0aXZlcywgcGlwZXMpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHRoaXMubW9kdWxlcyA9IG1vZHVsZXM7XG4gICAgICAgICAgdGhpcy5wcm92aWRlcnMgPSBwcm92aWRlcnM7XG4gICAgICAgICAgdGhpcy5lbnRyeUNvbXBvbmVudHMgPSBlbnRyeUNvbXBvbmVudHM7XG4gICAgICAgICAgdGhpcy5kaXJlY3RpdmVzID0gZGlyZWN0aXZlcztcbiAgICAgICAgICB0aGlzLnBpcGVzID0gcGlwZXM7XG4gICAgICAgICAgdGhpcy5kaXJlY3RpdmVzU2V0ID0gbmV3IFNldCgpO1xuICAgICAgICAgIHRoaXMucGlwZXNTZXQgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgZGlyZWN0aXZlcy5mb3JFYWNoKGZ1bmN0aW9uIChkaXIpIHsgcmV0dXJuIF90aGlzLmRpcmVjdGl2ZXNTZXQuYWRkKGRpci50eXBlLnJlZmVyZW5jZSk7IH0pO1xuICAgICAgICAgIHBpcGVzLmZvckVhY2goZnVuY3Rpb24gKHBpcGUpIHsgcmV0dXJuIF90aGlzLnBpcGVzU2V0LmFkZChwaXBlLnR5cGUucmVmZXJlbmNlKTsgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gVHJhbnNpdGl2ZUNvbXBpbGVOZ01vZHVsZU1ldGFkYXRhO1xuICB9KCkpO1xuICBmdW5jdGlvbiByZW1vdmVJZGVudGlmaWVyRHVwbGljYXRlcyhpdGVtcykge1xuICAgICAgdmFyIG1hcCA9IG5ldyBNYXAoKTtcbiAgICAgIGl0ZW1zLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICBpZiAoIW1hcC5nZXQoaXRlbS5pZGVudGlmaWVyLnJlZmVyZW5jZSkpIHtcbiAgICAgICAgICAgICAgbWFwLnNldChpdGVtLmlkZW50aWZpZXIucmVmZXJlbmNlLCBpdGVtKTtcbiAgICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBNYXBXcmFwcGVyLnZhbHVlcyhtYXApO1xuICB9XG4gIGZ1bmN0aW9uIF9ub3JtYWxpemVBcnJheShvYmopIHtcbiAgICAgIHJldHVybiBvYmogfHwgW107XG4gIH1cbiAgZnVuY3Rpb24gaXNTdGF0aWNTeW1ib2wodmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsICYmIHZhbHVlWyduYW1lJ10gJiYgdmFsdWVbJ2ZpbGVQYXRoJ107XG4gIH1cbiAgdmFyIFByb3ZpZGVyTWV0YSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBQcm92aWRlck1ldGEodG9rZW4sIF9hKSB7XG4gICAgICAgICAgdmFyIHVzZUNsYXNzID0gX2EudXNlQ2xhc3MsIHVzZVZhbHVlID0gX2EudXNlVmFsdWUsIHVzZUV4aXN0aW5nID0gX2EudXNlRXhpc3RpbmcsIHVzZUZhY3RvcnkgPSBfYS51c2VGYWN0b3J5LCBkZXBzID0gX2EuZGVwcywgbXVsdGkgPSBfYS5tdWx0aTtcbiAgICAgICAgICB0aGlzLnRva2VuID0gdG9rZW47XG4gICAgICAgICAgdGhpcy51c2VDbGFzcyA9IHVzZUNsYXNzO1xuICAgICAgICAgIHRoaXMudXNlVmFsdWUgPSB1c2VWYWx1ZTtcbiAgICAgICAgICB0aGlzLnVzZUV4aXN0aW5nID0gdXNlRXhpc3Rpbmc7XG4gICAgICAgICAgdGhpcy51c2VGYWN0b3J5ID0gdXNlRmFjdG9yeTtcbiAgICAgICAgICB0aGlzLmRlcGVuZGVuY2llcyA9IGRlcHM7XG4gICAgICAgICAgdGhpcy5tdWx0aSA9ICEhbXVsdGk7XG4gICAgICB9XG4gICAgICByZXR1cm4gUHJvdmlkZXJNZXRhO1xuICB9KCkpO1xuXG4gIC8qKlxuICAgKiBAbGljZW5zZVxuICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICpcbiAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgKi9cbiAgdmFyICRFT0YgPSAwO1xuICB2YXIgJFRBQiA9IDk7XG4gIHZhciAkTEYgPSAxMDtcbiAgdmFyICRWVEFCID0gMTE7XG4gIHZhciAkRkYgPSAxMjtcbiAgdmFyICRDUiA9IDEzO1xuICB2YXIgJFNQQUNFID0gMzI7XG4gIHZhciAkQkFORyA9IDMzO1xuICB2YXIgJERRID0gMzQ7XG4gIHZhciAkSEFTSCA9IDM1O1xuICB2YXIgJCQgPSAzNjtcbiAgdmFyICRQRVJDRU5UID0gMzc7XG4gIHZhciAkQU1QRVJTQU5EID0gMzg7XG4gIHZhciAkU1EgPSAzOTtcbiAgdmFyICRMUEFSRU4gPSA0MDtcbiAgdmFyICRSUEFSRU4gPSA0MTtcbiAgdmFyICRTVEFSID0gNDI7XG4gIHZhciAkUExVUyA9IDQzO1xuICB2YXIgJENPTU1BID0gNDQ7XG4gIHZhciAkTUlOVVMgPSA0NTtcbiAgdmFyICRQRVJJT0QgPSA0NjtcbiAgdmFyICRTTEFTSCA9IDQ3O1xuICB2YXIgJENPTE9OID0gNTg7XG4gIHZhciAkU0VNSUNPTE9OID0gNTk7XG4gIHZhciAkTFQgPSA2MDtcbiAgdmFyICRFUSA9IDYxO1xuICB2YXIgJEdUID0gNjI7XG4gIHZhciAkUVVFU1RJT04gPSA2MztcbiAgdmFyICQwID0gNDg7XG4gIHZhciAkOSA9IDU3O1xuICB2YXIgJEEgPSA2NTtcbiAgdmFyICRFID0gNjk7XG4gIHZhciAkRiA9IDcwO1xuICB2YXIgJFggPSA4ODtcbiAgdmFyICRaID0gOTA7XG4gIHZhciAkTEJSQUNLRVQgPSA5MTtcbiAgdmFyICRCQUNLU0xBU0ggPSA5MjtcbiAgdmFyICRSQlJBQ0tFVCA9IDkzO1xuICB2YXIgJENBUkVUID0gOTQ7XG4gIHZhciAkXyA9IDk1O1xuICB2YXIgJGEgPSA5NztcbiAgdmFyICRlID0gMTAxO1xuICB2YXIgJGYgPSAxMDI7XG4gIHZhciAkbiA9IDExMDtcbiAgdmFyICRyID0gMTE0O1xuICB2YXIgJHQgPSAxMTY7XG4gIHZhciAkdSA9IDExNztcbiAgdmFyICR2ID0gMTE4O1xuICB2YXIgJHggPSAxMjA7XG4gIHZhciAkeiA9IDEyMjtcbiAgdmFyICRMQlJBQ0UgPSAxMjM7XG4gIHZhciAkQkFSID0gMTI0O1xuICB2YXIgJFJCUkFDRSA9IDEyNTtcbiAgdmFyICROQlNQID0gMTYwO1xuICB2YXIgJEJUID0gOTY7XG4gIGZ1bmN0aW9uIGlzV2hpdGVzcGFjZShjb2RlKSB7XG4gICAgICByZXR1cm4gKGNvZGUgPj0gJFRBQiAmJiBjb2RlIDw9ICRTUEFDRSkgfHwgKGNvZGUgPT0gJE5CU1ApO1xuICB9XG4gIGZ1bmN0aW9uIGlzRGlnaXQoY29kZSkge1xuICAgICAgcmV0dXJuICQwIDw9IGNvZGUgJiYgY29kZSA8PSAkOTtcbiAgfVxuICBmdW5jdGlvbiBpc0FzY2lpTGV0dGVyKGNvZGUpIHtcbiAgICAgIHJldHVybiBjb2RlID49ICRhICYmIGNvZGUgPD0gJHogfHwgY29kZSA+PSAkQSAmJiBjb2RlIDw9ICRaO1xuICB9XG4gIGZ1bmN0aW9uIGlzQXNjaWlIZXhEaWdpdChjb2RlKSB7XG4gICAgICByZXR1cm4gY29kZSA+PSAkYSAmJiBjb2RlIDw9ICRmIHx8IGNvZGUgPj0gJEEgJiYgY29kZSA8PSAkRiB8fCBpc0RpZ2l0KGNvZGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gYXNzZXJ0QXJyYXlPZlN0cmluZ3MoaWRlbnRpZmllciwgdmFsdWUpIHtcbiAgICAgIGlmICghX2FuZ3VsYXJfY29yZS5pc0Rldk1vZGUoKSB8fCBpc0JsYW5rKHZhbHVlKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCAnXCIgKyBpZGVudGlmaWVyICsgXCInIHRvIGJlIGFuIGFycmF5IG9mIHN0cmluZ3MuXCIpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWVbaV0gIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkICdcIiArIGlkZW50aWZpZXIgKyBcIicgdG8gYmUgYW4gYXJyYXkgb2Ygc3RyaW5ncy5cIik7XG4gICAgICAgICAgfVxuICAgICAgfVxuICB9XG4gIHZhciBJTlRFUlBPTEFUSU9OX0JMQUNLTElTVF9SRUdFWFBTID0gW1xuICAgICAgL15cXHMqJC8sXG4gICAgICAvWzw+XS8sXG4gICAgICAvXlt7fV0kLyxcbiAgICAgIC8mKCN8W2Etel0pL2ksXG4gICAgICAvXlxcL1xcLy8sXG4gIF07XG4gIGZ1bmN0aW9uIGFzc2VydEludGVycG9sYXRpb25TeW1ib2xzKGlkZW50aWZpZXIsIHZhbHVlKSB7XG4gICAgICBpZiAoaXNQcmVzZW50KHZhbHVlKSAmJiAhKEFycmF5LmlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmxlbmd0aCA9PSAyKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkICdcIiArIGlkZW50aWZpZXIgKyBcIicgdG8gYmUgYW4gYXJyYXksIFtzdGFydCwgZW5kXS5cIik7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChfYW5ndWxhcl9jb3JlLmlzRGV2TW9kZSgpICYmICFpc0JsYW5rKHZhbHVlKSkge1xuICAgICAgICAgIHZhciBzdGFydF8xID0gdmFsdWVbMF07XG4gICAgICAgICAgdmFyIGVuZF8xID0gdmFsdWVbMV07XG4gICAgICAgICAgLy8gYmxhY2sgbGlzdCBjaGVja2luZ1xuICAgICAgICAgIElOVEVSUE9MQVRJT05fQkxBQ0tMSVNUX1JFR0VYUFMuZm9yRWFjaChmdW5jdGlvbiAocmVnZXhwKSB7XG4gICAgICAgICAgICAgIGlmIChyZWdleHAudGVzdChzdGFydF8xKSB8fCByZWdleHAudGVzdChlbmRfMSkpIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlsnXCIgKyBzdGFydF8xICsgXCInLCAnXCIgKyBlbmRfMSArIFwiJ10gY29udGFpbnMgdW51c2FibGUgaW50ZXJwb2xhdGlvbiBzeW1ib2wuXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICB9XG4gIH1cblxuICB2YXIgSW50ZXJwb2xhdGlvbkNvbmZpZyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBJbnRlcnBvbGF0aW9uQ29uZmlnKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgICAgdGhpcy5lbmQgPSBlbmQ7XG4gICAgICB9XG4gICAgICBJbnRlcnBvbGF0aW9uQ29uZmlnLmZyb21BcnJheSA9IGZ1bmN0aW9uIChtYXJrZXJzKSB7XG4gICAgICAgICAgaWYgKCFtYXJrZXJzKSB7XG4gICAgICAgICAgICAgIHJldHVybiBERUZBVUxUX0lOVEVSUE9MQVRJT05fQ09ORklHO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhc3NlcnRJbnRlcnBvbGF0aW9uU3ltYm9scygnaW50ZXJwb2xhdGlvbicsIG1hcmtlcnMpO1xuICAgICAgICAgIHJldHVybiBuZXcgSW50ZXJwb2xhdGlvbkNvbmZpZyhtYXJrZXJzWzBdLCBtYXJrZXJzWzFdKTtcbiAgICAgIH07XG4gICAgICA7XG4gICAgICByZXR1cm4gSW50ZXJwb2xhdGlvbkNvbmZpZztcbiAgfSgpKTtcbiAgdmFyIERFRkFVTFRfSU5URVJQT0xBVElPTl9DT05GSUcgPSBuZXcgSW50ZXJwb2xhdGlvbkNvbmZpZygne3snLCAnfX0nKTtcblxuICAvKipcbiAgICogQGxpY2Vuc2VcbiAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAqXG4gICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICovXG4gIHZhciBfX2V4dGVuZHMkMiA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgfTtcbiAgdmFyIFBhcnNlckVycm9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIFBhcnNlckVycm9yKG1lc3NhZ2UsIGlucHV0LCBlcnJMb2NhdGlvbiwgY3R4TG9jYXRpb24pIHtcbiAgICAgICAgICB0aGlzLmlucHV0ID0gaW5wdXQ7XG4gICAgICAgICAgdGhpcy5lcnJMb2NhdGlvbiA9IGVyckxvY2F0aW9uO1xuICAgICAgICAgIHRoaXMuY3R4TG9jYXRpb24gPSBjdHhMb2NhdGlvbjtcbiAgICAgICAgICB0aGlzLm1lc3NhZ2UgPSBcIlBhcnNlciBFcnJvcjogXCIgKyBtZXNzYWdlICsgXCIgXCIgKyBlcnJMb2NhdGlvbiArIFwiIFtcIiArIGlucHV0ICsgXCJdIGluIFwiICsgY3R4TG9jYXRpb247XG4gICAgICB9XG4gICAgICByZXR1cm4gUGFyc2VyRXJyb3I7XG4gIH0oKSk7XG4gIHZhciBQYXJzZVNwYW4gPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gUGFyc2VTcGFuKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgICAgdGhpcy5lbmQgPSBlbmQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gUGFyc2VTcGFuO1xuICB9KCkpO1xuICB2YXIgQVNUID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIEFTVChzcGFuKSB7XG4gICAgICAgICAgdGhpcy5zcGFuID0gc3BhbjtcbiAgICAgIH1cbiAgICAgIEFTVC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHsgY29udGV4dCA9IG51bGw7IH1cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICBBU1QucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJ0FTVCc7IH07XG4gICAgICByZXR1cm4gQVNUO1xuICB9KCkpO1xuICAvKipcbiAgICogUmVwcmVzZW50cyBhIHF1b3RlZCBleHByZXNzaW9uIG9mIHRoZSBmb3JtOlxuICAgKlxuICAgKiBxdW90ZSA9IHByZWZpeCBgOmAgdW5pbnRlcnByZXRlZEV4cHJlc3Npb25cbiAgICogcHJlZml4ID0gaWRlbnRpZmllclxuICAgKiB1bmludGVycHJldGVkRXhwcmVzc2lvbiA9IGFyYml0cmFyeSBzdHJpbmdcbiAgICpcbiAgICogQSBxdW90ZWQgZXhwcmVzc2lvbiBpcyBtZWFudCB0byBiZSBwcmUtcHJvY2Vzc2VkIGJ5IGFuIEFTVCB0cmFuc2Zvcm1lciB0aGF0XG4gICAqIGNvbnZlcnRzIGl0IGludG8gYW5vdGhlciBBU1QgdGhhdCBubyBsb25nZXIgY29udGFpbnMgcXVvdGVkIGV4cHJlc3Npb25zLlxuICAgKiBJdCBpcyBtZWFudCB0byBhbGxvdyB0aGlyZC1wYXJ0eSBkZXZlbG9wZXJzIHRvIGV4dGVuZCBBbmd1bGFyIHRlbXBsYXRlXG4gICAqIGV4cHJlc3Npb24gbGFuZ3VhZ2UuIFRoZSBgdW5pbnRlcnByZXRlZEV4cHJlc3Npb25gIHBhcnQgb2YgdGhlIHF1b3RlIGlzXG4gICAqIHRoZXJlZm9yZSBub3QgaW50ZXJwcmV0ZWQgYnkgdGhlIEFuZ3VsYXIncyBvd24gZXhwcmVzc2lvbiBwYXJzZXIuXG4gICAqL1xuICB2YXIgUXVvdGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDIoUXVvdGUsIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBRdW90ZShzcGFuLCBwcmVmaXgsIHVuaW50ZXJwcmV0ZWRFeHByZXNzaW9uLCBsb2NhdGlvbikge1xuICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIHNwYW4pO1xuICAgICAgICAgIHRoaXMucHJlZml4ID0gcHJlZml4O1xuICAgICAgICAgIHRoaXMudW5pbnRlcnByZXRlZEV4cHJlc3Npb24gPSB1bmludGVycHJldGVkRXhwcmVzc2lvbjtcbiAgICAgICAgICB0aGlzLmxvY2F0aW9uID0gbG9jYXRpb247XG4gICAgICB9XG4gICAgICBRdW90ZS5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHsgY29udGV4dCA9IG51bGw7IH1cbiAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFF1b3RlKHRoaXMsIGNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIFF1b3RlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICdRdW90ZSc7IH07XG4gICAgICByZXR1cm4gUXVvdGU7XG4gIH0oQVNUKSk7XG4gIHZhciBFbXB0eUV4cHIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDIoRW1wdHlFeHByLCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gRW1wdHlFeHByKCkge1xuICAgICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgRW1wdHlFeHByLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgeyBjb250ZXh0ID0gbnVsbDsgfVxuICAgICAgICAgIC8vIGRvIG5vdGhpbmdcbiAgICAgIH07XG4gICAgICByZXR1cm4gRW1wdHlFeHByO1xuICB9KEFTVCkpO1xuICB2YXIgSW1wbGljaXRSZWNlaXZlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkMihJbXBsaWNpdFJlY2VpdmVyLCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gSW1wbGljaXRSZWNlaXZlcigpIHtcbiAgICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICAgIEltcGxpY2l0UmVjZWl2ZXIucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7IGNvbnRleHQgPSBudWxsOyB9XG4gICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRJbXBsaWNpdFJlY2VpdmVyKHRoaXMsIGNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBJbXBsaWNpdFJlY2VpdmVyO1xuICB9KEFTVCkpO1xuICAvKipcbiAgICogTXVsdGlwbGUgZXhwcmVzc2lvbnMgc2VwYXJhdGVkIGJ5IGEgc2VtaWNvbG9uLlxuICAgKi9cbiAgdmFyIENoYWluID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQyKENoYWluLCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gQ2hhaW4oc3BhbiwgZXhwcmVzc2lvbnMpIHtcbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBzcGFuKTtcbiAgICAgICAgICB0aGlzLmV4cHJlc3Npb25zID0gZXhwcmVzc2lvbnM7XG4gICAgICB9XG4gICAgICBDaGFpbi5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHsgY29udGV4dCA9IG51bGw7IH1cbiAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdENoYWluKHRoaXMsIGNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBDaGFpbjtcbiAgfShBU1QpKTtcbiAgdmFyIENvbmRpdGlvbmFsID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQyKENvbmRpdGlvbmFsLCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gQ29uZGl0aW9uYWwoc3BhbiwgY29uZGl0aW9uLCB0cnVlRXhwLCBmYWxzZUV4cCkge1xuICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIHNwYW4pO1xuICAgICAgICAgIHRoaXMuY29uZGl0aW9uID0gY29uZGl0aW9uO1xuICAgICAgICAgIHRoaXMudHJ1ZUV4cCA9IHRydWVFeHA7XG4gICAgICAgICAgdGhpcy5mYWxzZUV4cCA9IGZhbHNlRXhwO1xuICAgICAgfVxuICAgICAgQ29uZGl0aW9uYWwucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7IGNvbnRleHQgPSBudWxsOyB9XG4gICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRDb25kaXRpb25hbCh0aGlzLCBjb250ZXh0KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gQ29uZGl0aW9uYWw7XG4gIH0oQVNUKSk7XG4gIHZhciBQcm9wZXJ0eVJlYWQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDIoUHJvcGVydHlSZWFkLCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gUHJvcGVydHlSZWFkKHNwYW4sIHJlY2VpdmVyLCBuYW1lKSB7XG4gICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgc3Bhbik7XG4gICAgICAgICAgdGhpcy5yZWNlaXZlciA9IHJlY2VpdmVyO1xuICAgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICB9XG4gICAgICBQcm9wZXJ0eVJlYWQucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7IGNvbnRleHQgPSBudWxsOyB9XG4gICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRQcm9wZXJ0eVJlYWQodGhpcywgY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIFByb3BlcnR5UmVhZDtcbiAgfShBU1QpKTtcbiAgdmFyIFByb3BlcnR5V3JpdGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDIoUHJvcGVydHlXcml0ZSwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIFByb3BlcnR5V3JpdGUoc3BhbiwgcmVjZWl2ZXIsIG5hbWUsIHZhbHVlKSB7XG4gICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgc3Bhbik7XG4gICAgICAgICAgdGhpcy5yZWNlaXZlciA9IHJlY2VpdmVyO1xuICAgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgUHJvcGVydHlXcml0ZS5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHsgY29udGV4dCA9IG51bGw7IH1cbiAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFByb3BlcnR5V3JpdGUodGhpcywgY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIFByb3BlcnR5V3JpdGU7XG4gIH0oQVNUKSk7XG4gIHZhciBTYWZlUHJvcGVydHlSZWFkID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQyKFNhZmVQcm9wZXJ0eVJlYWQsIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBTYWZlUHJvcGVydHlSZWFkKHNwYW4sIHJlY2VpdmVyLCBuYW1lKSB7XG4gICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgc3Bhbik7XG4gICAgICAgICAgdGhpcy5yZWNlaXZlciA9IHJlY2VpdmVyO1xuICAgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICB9XG4gICAgICBTYWZlUHJvcGVydHlSZWFkLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgeyBjb250ZXh0ID0gbnVsbDsgfVxuICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0U2FmZVByb3BlcnR5UmVhZCh0aGlzLCBjb250ZXh0KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gU2FmZVByb3BlcnR5UmVhZDtcbiAgfShBU1QpKTtcbiAgdmFyIEtleWVkUmVhZCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkMihLZXllZFJlYWQsIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBLZXllZFJlYWQoc3Bhbiwgb2JqLCBrZXkpIHtcbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBzcGFuKTtcbiAgICAgICAgICB0aGlzLm9iaiA9IG9iajtcbiAgICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgIH1cbiAgICAgIEtleWVkUmVhZC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHsgY29udGV4dCA9IG51bGw7IH1cbiAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEtleWVkUmVhZCh0aGlzLCBjb250ZXh0KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gS2V5ZWRSZWFkO1xuICB9KEFTVCkpO1xuICB2YXIgS2V5ZWRXcml0ZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkMihLZXllZFdyaXRlLCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gS2V5ZWRXcml0ZShzcGFuLCBvYmosIGtleSwgdmFsdWUpIHtcbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBzcGFuKTtcbiAgICAgICAgICB0aGlzLm9iaiA9IG9iajtcbiAgICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICB9XG4gICAgICBLZXllZFdyaXRlLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgeyBjb250ZXh0ID0gbnVsbDsgfVxuICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0S2V5ZWRXcml0ZSh0aGlzLCBjb250ZXh0KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gS2V5ZWRXcml0ZTtcbiAgfShBU1QpKTtcbiAgdmFyIEJpbmRpbmdQaXBlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQyKEJpbmRpbmdQaXBlLCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gQmluZGluZ1BpcGUoc3BhbiwgZXhwLCBuYW1lLCBhcmdzKSB7XG4gICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgc3Bhbik7XG4gICAgICAgICAgdGhpcy5leHAgPSBleHA7XG4gICAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgICB0aGlzLmFyZ3MgPSBhcmdzO1xuICAgICAgfVxuICAgICAgQmluZGluZ1BpcGUucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7IGNvbnRleHQgPSBudWxsOyB9XG4gICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRQaXBlKHRoaXMsIGNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBCaW5kaW5nUGlwZTtcbiAgfShBU1QpKTtcbiAgdmFyIExpdGVyYWxQcmltaXRpdmUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDIoTGl0ZXJhbFByaW1pdGl2ZSwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIExpdGVyYWxQcmltaXRpdmUoc3BhbiwgdmFsdWUpIHtcbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBzcGFuKTtcbiAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICB9XG4gICAgICBMaXRlcmFsUHJpbWl0aXZlLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgeyBjb250ZXh0ID0gbnVsbDsgfVxuICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0TGl0ZXJhbFByaW1pdGl2ZSh0aGlzLCBjb250ZXh0KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gTGl0ZXJhbFByaW1pdGl2ZTtcbiAgfShBU1QpKTtcbiAgdmFyIExpdGVyYWxBcnJheSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkMihMaXRlcmFsQXJyYXksIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBMaXRlcmFsQXJyYXkoc3BhbiwgZXhwcmVzc2lvbnMpIHtcbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBzcGFuKTtcbiAgICAgICAgICB0aGlzLmV4cHJlc3Npb25zID0gZXhwcmVzc2lvbnM7XG4gICAgICB9XG4gICAgICBMaXRlcmFsQXJyYXkucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7IGNvbnRleHQgPSBudWxsOyB9XG4gICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRMaXRlcmFsQXJyYXkodGhpcywgY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIExpdGVyYWxBcnJheTtcbiAgfShBU1QpKTtcbiAgdmFyIExpdGVyYWxNYXAgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDIoTGl0ZXJhbE1hcCwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIExpdGVyYWxNYXAoc3Bhbiwga2V5cywgdmFsdWVzKSB7XG4gICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgc3Bhbik7XG4gICAgICAgICAgdGhpcy5rZXlzID0ga2V5cztcbiAgICAgICAgICB0aGlzLnZhbHVlcyA9IHZhbHVlcztcbiAgICAgIH1cbiAgICAgIExpdGVyYWxNYXAucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7IGNvbnRleHQgPSBudWxsOyB9XG4gICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRMaXRlcmFsTWFwKHRoaXMsIGNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBMaXRlcmFsTWFwO1xuICB9KEFTVCkpO1xuICB2YXIgSW50ZXJwb2xhdGlvbiA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkMihJbnRlcnBvbGF0aW9uLCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gSW50ZXJwb2xhdGlvbihzcGFuLCBzdHJpbmdzLCBleHByZXNzaW9ucykge1xuICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIHNwYW4pO1xuICAgICAgICAgIHRoaXMuc3RyaW5ncyA9IHN0cmluZ3M7XG4gICAgICAgICAgdGhpcy5leHByZXNzaW9ucyA9IGV4cHJlc3Npb25zO1xuICAgICAgfVxuICAgICAgSW50ZXJwb2xhdGlvbi5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHsgY29udGV4dCA9IG51bGw7IH1cbiAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEludGVycG9sYXRpb24odGhpcywgY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIEludGVycG9sYXRpb247XG4gIH0oQVNUKSk7XG4gIHZhciBCaW5hcnkgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDIoQmluYXJ5LCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gQmluYXJ5KHNwYW4sIG9wZXJhdGlvbiwgbGVmdCwgcmlnaHQpIHtcbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBzcGFuKTtcbiAgICAgICAgICB0aGlzLm9wZXJhdGlvbiA9IG9wZXJhdGlvbjtcbiAgICAgICAgICB0aGlzLmxlZnQgPSBsZWZ0O1xuICAgICAgICAgIHRoaXMucmlnaHQgPSByaWdodDtcbiAgICAgIH1cbiAgICAgIEJpbmFyeS5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHsgY29udGV4dCA9IG51bGw7IH1cbiAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEJpbmFyeSh0aGlzLCBjb250ZXh0KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gQmluYXJ5O1xuICB9KEFTVCkpO1xuICB2YXIgUHJlZml4Tm90ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQyKFByZWZpeE5vdCwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIFByZWZpeE5vdChzcGFuLCBleHByZXNzaW9uKSB7XG4gICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgc3Bhbik7XG4gICAgICAgICAgdGhpcy5leHByZXNzaW9uID0gZXhwcmVzc2lvbjtcbiAgICAgIH1cbiAgICAgIFByZWZpeE5vdC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHsgY29udGV4dCA9IG51bGw7IH1cbiAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFByZWZpeE5vdCh0aGlzLCBjb250ZXh0KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gUHJlZml4Tm90O1xuICB9KEFTVCkpO1xuICB2YXIgTWV0aG9kQ2FsbCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkMihNZXRob2RDYWxsLCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gTWV0aG9kQ2FsbChzcGFuLCByZWNlaXZlciwgbmFtZSwgYXJncykge1xuICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIHNwYW4pO1xuICAgICAgICAgIHRoaXMucmVjZWl2ZXIgPSByZWNlaXZlcjtcbiAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICAgIHRoaXMuYXJncyA9IGFyZ3M7XG4gICAgICB9XG4gICAgICBNZXRob2RDYWxsLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgeyBjb250ZXh0ID0gbnVsbDsgfVxuICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0TWV0aG9kQ2FsbCh0aGlzLCBjb250ZXh0KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gTWV0aG9kQ2FsbDtcbiAgfShBU1QpKTtcbiAgdmFyIFNhZmVNZXRob2RDYWxsID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQyKFNhZmVNZXRob2RDYWxsLCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gU2FmZU1ldGhvZENhbGwoc3BhbiwgcmVjZWl2ZXIsIG5hbWUsIGFyZ3MpIHtcbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBzcGFuKTtcbiAgICAgICAgICB0aGlzLnJlY2VpdmVyID0gcmVjZWl2ZXI7XG4gICAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgICB0aGlzLmFyZ3MgPSBhcmdzO1xuICAgICAgfVxuICAgICAgU2FmZU1ldGhvZENhbGwucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7IGNvbnRleHQgPSBudWxsOyB9XG4gICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRTYWZlTWV0aG9kQ2FsbCh0aGlzLCBjb250ZXh0KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gU2FmZU1ldGhvZENhbGw7XG4gIH0oQVNUKSk7XG4gIHZhciBGdW5jdGlvbkNhbGwgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDIoRnVuY3Rpb25DYWxsLCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gRnVuY3Rpb25DYWxsKHNwYW4sIHRhcmdldCwgYXJncykge1xuICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIHNwYW4pO1xuICAgICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICAgIHRoaXMuYXJncyA9IGFyZ3M7XG4gICAgICB9XG4gICAgICBGdW5jdGlvbkNhbGwucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7IGNvbnRleHQgPSBudWxsOyB9XG4gICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRGdW5jdGlvbkNhbGwodGhpcywgY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIEZ1bmN0aW9uQ2FsbDtcbiAgfShBU1QpKTtcbiAgdmFyIEFTVFdpdGhTb3VyY2UgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDIoQVNUV2l0aFNvdXJjZSwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIEFTVFdpdGhTb3VyY2UoYXN0LCBzb3VyY2UsIGxvY2F0aW9uLCBlcnJvcnMpIHtcbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBuZXcgUGFyc2VTcGFuKDAsIGlzQmxhbmsoc291cmNlKSA/IDAgOiBzb3VyY2UubGVuZ3RoKSk7XG4gICAgICAgICAgdGhpcy5hc3QgPSBhc3Q7XG4gICAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgICAgdGhpcy5sb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgICAgICAgIHRoaXMuZXJyb3JzID0gZXJyb3JzO1xuICAgICAgfVxuICAgICAgQVNUV2l0aFNvdXJjZS5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHsgY29udGV4dCA9IG51bGw7IH1cbiAgICAgICAgICByZXR1cm4gdGhpcy5hc3QudmlzaXQodmlzaXRvciwgY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgQVNUV2l0aFNvdXJjZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnNvdXJjZSArIFwiIGluIFwiICsgdGhpcy5sb2NhdGlvbjsgfTtcbiAgICAgIHJldHVybiBBU1RXaXRoU291cmNlO1xuICB9KEFTVCkpO1xuICB2YXIgVGVtcGxhdGVCaW5kaW5nID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIFRlbXBsYXRlQmluZGluZyhrZXksIGtleUlzVmFyLCBuYW1lLCBleHByZXNzaW9uKSB7XG4gICAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICAgICAgdGhpcy5rZXlJc1ZhciA9IGtleUlzVmFyO1xuICAgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgICAgdGhpcy5leHByZXNzaW9uID0gZXhwcmVzc2lvbjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBUZW1wbGF0ZUJpbmRpbmc7XG4gIH0oKSk7XG4gIHZhciBSZWN1cnNpdmVBc3RWaXNpdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIFJlY3Vyc2l2ZUFzdFZpc2l0b3IoKSB7XG4gICAgICB9XG4gICAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdEJpbmFyeSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgICBhc3QubGVmdC52aXNpdCh0aGlzKTtcbiAgICAgICAgICBhc3QucmlnaHQudmlzaXQodGhpcyk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRDaGFpbiA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgcmV0dXJuIHRoaXMudmlzaXRBbGwoYXN0LmV4cHJlc3Npb25zLCBjb250ZXh0KTsgfTtcbiAgICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0Q29uZGl0aW9uYWwgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgICAgYXN0LmNvbmRpdGlvbi52aXNpdCh0aGlzKTtcbiAgICAgICAgICBhc3QudHJ1ZUV4cC52aXNpdCh0aGlzKTtcbiAgICAgICAgICBhc3QuZmFsc2VFeHAudmlzaXQodGhpcyk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRQaXBlID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICAgIGFzdC5leHAudmlzaXQodGhpcyk7XG4gICAgICAgICAgdGhpcy52aXNpdEFsbChhc3QuYXJncywgY29udGV4dCk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRGdW5jdGlvbkNhbGwgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgICAgYXN0LnRhcmdldC52aXNpdCh0aGlzKTtcbiAgICAgICAgICB0aGlzLnZpc2l0QWxsKGFzdC5hcmdzLCBjb250ZXh0KTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdEltcGxpY2l0UmVjZWl2ZXIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IHJldHVybiBudWxsOyB9O1xuICAgICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRJbnRlcnBvbGF0aW9uID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnZpc2l0QWxsKGFzdC5leHByZXNzaW9ucywgY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRLZXllZFJlYWQgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgICAgYXN0Lm9iai52aXNpdCh0aGlzKTtcbiAgICAgICAgICBhc3Qua2V5LnZpc2l0KHRoaXMpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcbiAgICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0S2V5ZWRXcml0ZSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgICBhc3Qub2JqLnZpc2l0KHRoaXMpO1xuICAgICAgICAgIGFzdC5rZXkudmlzaXQodGhpcyk7XG4gICAgICAgICAgYXN0LnZhbHVlLnZpc2l0KHRoaXMpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcbiAgICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0TGl0ZXJhbEFycmF5ID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnZpc2l0QWxsKGFzdC5leHByZXNzaW9ucywgY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRMaXRlcmFsTWFwID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyByZXR1cm4gdGhpcy52aXNpdEFsbChhc3QudmFsdWVzLCBjb250ZXh0KTsgfTtcbiAgICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0TGl0ZXJhbFByaW1pdGl2ZSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgcmV0dXJuIG51bGw7IH07XG4gICAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdE1ldGhvZENhbGwgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgICAgYXN0LnJlY2VpdmVyLnZpc2l0KHRoaXMpO1xuICAgICAgICAgIHJldHVybiB0aGlzLnZpc2l0QWxsKGFzdC5hcmdzLCBjb250ZXh0KTtcbiAgICAgIH07XG4gICAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdFByZWZpeE5vdCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgICBhc3QuZXhwcmVzc2lvbi52aXNpdCh0aGlzKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdFByb3BlcnR5UmVhZCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgICBhc3QucmVjZWl2ZXIudmlzaXQodGhpcyk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRQcm9wZXJ0eVdyaXRlID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICAgIGFzdC5yZWNlaXZlci52aXNpdCh0aGlzKTtcbiAgICAgICAgICBhc3QudmFsdWUudmlzaXQodGhpcyk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRTYWZlUHJvcGVydHlSZWFkID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICAgIGFzdC5yZWNlaXZlci52aXNpdCh0aGlzKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdFNhZmVNZXRob2RDYWxsID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICAgIGFzdC5yZWNlaXZlci52aXNpdCh0aGlzKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy52aXNpdEFsbChhc3QuYXJncywgY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRBbGwgPSBmdW5jdGlvbiAoYXN0cywgY29udGV4dCkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgYXN0cy5mb3JFYWNoKGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIGFzdC52aXNpdChfdGhpcywgY29udGV4dCk7IH0pO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcbiAgICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0UXVvdGUgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IHJldHVybiBudWxsOyB9O1xuICAgICAgcmV0dXJuIFJlY3Vyc2l2ZUFzdFZpc2l0b3I7XG4gIH0oKSk7XG5cbiAgZXhwb3J0cy5Ub2tlblR5cGU7XG4gIChmdW5jdGlvbiAoVG9rZW5UeXBlKSB7XG4gICAgICBUb2tlblR5cGVbVG9rZW5UeXBlW1wiQ2hhcmFjdGVyXCJdID0gMF0gPSBcIkNoYXJhY3RlclwiO1xuICAgICAgVG9rZW5UeXBlW1Rva2VuVHlwZVtcIklkZW50aWZpZXJcIl0gPSAxXSA9IFwiSWRlbnRpZmllclwiO1xuICAgICAgVG9rZW5UeXBlW1Rva2VuVHlwZVtcIktleXdvcmRcIl0gPSAyXSA9IFwiS2V5d29yZFwiO1xuICAgICAgVG9rZW5UeXBlW1Rva2VuVHlwZVtcIlN0cmluZ1wiXSA9IDNdID0gXCJTdHJpbmdcIjtcbiAgICAgIFRva2VuVHlwZVtUb2tlblR5cGVbXCJPcGVyYXRvclwiXSA9IDRdID0gXCJPcGVyYXRvclwiO1xuICAgICAgVG9rZW5UeXBlW1Rva2VuVHlwZVtcIk51bWJlclwiXSA9IDVdID0gXCJOdW1iZXJcIjtcbiAgICAgIFRva2VuVHlwZVtUb2tlblR5cGVbXCJFcnJvclwiXSA9IDZdID0gXCJFcnJvclwiO1xuICB9KShleHBvcnRzLlRva2VuVHlwZSB8fCAoZXhwb3J0cy5Ub2tlblR5cGUgPSB7fSkpO1xuICB2YXIgS0VZV09SRFMgPSBbJ3ZhcicsICdsZXQnLCAnbnVsbCcsICd1bmRlZmluZWQnLCAndHJ1ZScsICdmYWxzZScsICdpZicsICdlbHNlJywgJ3RoaXMnXTtcbiAgdmFyIExleGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIExleGVyKCkge1xuICAgICAgfVxuICAgICAgTGV4ZXIucHJvdG90eXBlLnRva2VuaXplID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgICAgICAgICB2YXIgc2Nhbm5lciA9IG5ldyBfU2Nhbm5lcih0ZXh0KTtcbiAgICAgICAgICB2YXIgdG9rZW5zID0gW107XG4gICAgICAgICAgdmFyIHRva2VuID0gc2Nhbm5lci5zY2FuVG9rZW4oKTtcbiAgICAgICAgICB3aGlsZSAodG9rZW4gIT0gbnVsbCkge1xuICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgIHRva2VuID0gc2Nhbm5lci5zY2FuVG9rZW4oKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRva2VucztcbiAgICAgIH07XG4gICAgICBMZXhlci5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3RhYmxlIH0sXG4gICAgICBdO1xuICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICBMZXhlci5jdG9yUGFyYW1ldGVycyA9IFtdO1xuICAgICAgcmV0dXJuIExleGVyO1xuICB9KCkpO1xuICB2YXIgVG9rZW4gPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gVG9rZW4oaW5kZXgsIHR5cGUsIG51bVZhbHVlLCBzdHJWYWx1ZSkge1xuICAgICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICAgIHRoaXMubnVtVmFsdWUgPSBudW1WYWx1ZTtcbiAgICAgICAgICB0aGlzLnN0clZhbHVlID0gc3RyVmFsdWU7XG4gICAgICB9XG4gICAgICBUb2tlbi5wcm90b3R5cGUuaXNDaGFyYWN0ZXIgPSBmdW5jdGlvbiAoY29kZSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnR5cGUgPT0gZXhwb3J0cy5Ub2tlblR5cGUuQ2hhcmFjdGVyICYmIHRoaXMubnVtVmFsdWUgPT0gY29kZTtcbiAgICAgIH07XG4gICAgICBUb2tlbi5wcm90b3R5cGUuaXNOdW1iZXIgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnR5cGUgPT0gZXhwb3J0cy5Ub2tlblR5cGUuTnVtYmVyOyB9O1xuICAgICAgVG9rZW4ucHJvdG90eXBlLmlzU3RyaW5nID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy50eXBlID09IGV4cG9ydHMuVG9rZW5UeXBlLlN0cmluZzsgfTtcbiAgICAgIFRva2VuLnByb3RvdHlwZS5pc09wZXJhdG9yID0gZnVuY3Rpb24gKG9wZXJhdGVyKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PSBleHBvcnRzLlRva2VuVHlwZS5PcGVyYXRvciAmJiB0aGlzLnN0clZhbHVlID09IG9wZXJhdGVyO1xuICAgICAgfTtcbiAgICAgIFRva2VuLnByb3RvdHlwZS5pc0lkZW50aWZpZXIgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnR5cGUgPT0gZXhwb3J0cy5Ub2tlblR5cGUuSWRlbnRpZmllcjsgfTtcbiAgICAgIFRva2VuLnByb3RvdHlwZS5pc0tleXdvcmQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnR5cGUgPT0gZXhwb3J0cy5Ub2tlblR5cGUuS2V5d29yZDsgfTtcbiAgICAgIFRva2VuLnByb3RvdHlwZS5pc0tleXdvcmRMZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnR5cGUgPT0gZXhwb3J0cy5Ub2tlblR5cGUuS2V5d29yZCAmJiB0aGlzLnN0clZhbHVlID09ICdsZXQnOyB9O1xuICAgICAgVG9rZW4ucHJvdG90eXBlLmlzS2V5d29yZE51bGwgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnR5cGUgPT0gZXhwb3J0cy5Ub2tlblR5cGUuS2V5d29yZCAmJiB0aGlzLnN0clZhbHVlID09ICdudWxsJzsgfTtcbiAgICAgIFRva2VuLnByb3RvdHlwZS5pc0tleXdvcmRVbmRlZmluZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PSBleHBvcnRzLlRva2VuVHlwZS5LZXl3b3JkICYmIHRoaXMuc3RyVmFsdWUgPT0gJ3VuZGVmaW5lZCc7XG4gICAgICB9O1xuICAgICAgVG9rZW4ucHJvdG90eXBlLmlzS2V5d29yZFRydWUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnR5cGUgPT0gZXhwb3J0cy5Ub2tlblR5cGUuS2V5d29yZCAmJiB0aGlzLnN0clZhbHVlID09ICd0cnVlJzsgfTtcbiAgICAgIFRva2VuLnByb3RvdHlwZS5pc0tleXdvcmRGYWxzZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMudHlwZSA9PSBleHBvcnRzLlRva2VuVHlwZS5LZXl3b3JkICYmIHRoaXMuc3RyVmFsdWUgPT0gJ2ZhbHNlJzsgfTtcbiAgICAgIFRva2VuLnByb3RvdHlwZS5pc0tleXdvcmRUaGlzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy50eXBlID09IGV4cG9ydHMuVG9rZW5UeXBlLktleXdvcmQgJiYgdGhpcy5zdHJWYWx1ZSA9PSAndGhpcyc7IH07XG4gICAgICBUb2tlbi5wcm90b3R5cGUuaXNFcnJvciA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMudHlwZSA9PSBleHBvcnRzLlRva2VuVHlwZS5FcnJvcjsgfTtcbiAgICAgIFRva2VuLnByb3RvdHlwZS50b051bWJlciA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMudHlwZSA9PSBleHBvcnRzLlRva2VuVHlwZS5OdW1iZXIgPyB0aGlzLm51bVZhbHVlIDogLTE7IH07XG4gICAgICBUb2tlbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgc3dpdGNoICh0aGlzLnR5cGUpIHtcbiAgICAgICAgICAgICAgY2FzZSBleHBvcnRzLlRva2VuVHlwZS5DaGFyYWN0ZXI6XG4gICAgICAgICAgICAgIGNhc2UgZXhwb3J0cy5Ub2tlblR5cGUuSWRlbnRpZmllcjpcbiAgICAgICAgICAgICAgY2FzZSBleHBvcnRzLlRva2VuVHlwZS5LZXl3b3JkOlxuICAgICAgICAgICAgICBjYXNlIGV4cG9ydHMuVG9rZW5UeXBlLk9wZXJhdG9yOlxuICAgICAgICAgICAgICBjYXNlIGV4cG9ydHMuVG9rZW5UeXBlLlN0cmluZzpcbiAgICAgICAgICAgICAgY2FzZSBleHBvcnRzLlRva2VuVHlwZS5FcnJvcjpcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN0clZhbHVlO1xuICAgICAgICAgICAgICBjYXNlIGV4cG9ydHMuVG9rZW5UeXBlLk51bWJlcjpcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm51bVZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgcmV0dXJuIFRva2VuO1xuICB9KCkpO1xuICBmdW5jdGlvbiBuZXdDaGFyYWN0ZXJUb2tlbihpbmRleCwgY29kZSkge1xuICAgICAgcmV0dXJuIG5ldyBUb2tlbihpbmRleCwgZXhwb3J0cy5Ub2tlblR5cGUuQ2hhcmFjdGVyLCBjb2RlLCBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpKTtcbiAgfVxuICBmdW5jdGlvbiBuZXdJZGVudGlmaWVyVG9rZW4oaW5kZXgsIHRleHQpIHtcbiAgICAgIHJldHVybiBuZXcgVG9rZW4oaW5kZXgsIGV4cG9ydHMuVG9rZW5UeXBlLklkZW50aWZpZXIsIDAsIHRleHQpO1xuICB9XG4gIGZ1bmN0aW9uIG5ld0tleXdvcmRUb2tlbihpbmRleCwgdGV4dCkge1xuICAgICAgcmV0dXJuIG5ldyBUb2tlbihpbmRleCwgZXhwb3J0cy5Ub2tlblR5cGUuS2V5d29yZCwgMCwgdGV4dCk7XG4gIH1cbiAgZnVuY3Rpb24gbmV3T3BlcmF0b3JUb2tlbihpbmRleCwgdGV4dCkge1xuICAgICAgcmV0dXJuIG5ldyBUb2tlbihpbmRleCwgZXhwb3J0cy5Ub2tlblR5cGUuT3BlcmF0b3IsIDAsIHRleHQpO1xuICB9XG4gIGZ1bmN0aW9uIG5ld1N0cmluZ1Rva2VuKGluZGV4LCB0ZXh0KSB7XG4gICAgICByZXR1cm4gbmV3IFRva2VuKGluZGV4LCBleHBvcnRzLlRva2VuVHlwZS5TdHJpbmcsIDAsIHRleHQpO1xuICB9XG4gIGZ1bmN0aW9uIG5ld051bWJlclRva2VuKGluZGV4LCBuKSB7XG4gICAgICByZXR1cm4gbmV3IFRva2VuKGluZGV4LCBleHBvcnRzLlRva2VuVHlwZS5OdW1iZXIsIG4sICcnKTtcbiAgfVxuICBmdW5jdGlvbiBuZXdFcnJvclRva2VuKGluZGV4LCBtZXNzYWdlKSB7XG4gICAgICByZXR1cm4gbmV3IFRva2VuKGluZGV4LCBleHBvcnRzLlRva2VuVHlwZS5FcnJvciwgMCwgbWVzc2FnZSk7XG4gIH1cbiAgdmFyIEVPRiA9IG5ldyBUb2tlbigtMSwgZXhwb3J0cy5Ub2tlblR5cGUuQ2hhcmFjdGVyLCAwLCAnJyk7XG4gIHZhciBfU2Nhbm5lciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBfU2Nhbm5lcihpbnB1dCkge1xuICAgICAgICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcbiAgICAgICAgICB0aGlzLnBlZWsgPSAwO1xuICAgICAgICAgIHRoaXMuaW5kZXggPSAtMTtcbiAgICAgICAgICB0aGlzLmxlbmd0aCA9IGlucHV0Lmxlbmd0aDtcbiAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgIH1cbiAgICAgIF9TY2FubmVyLnByb3RvdHlwZS5hZHZhbmNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoaXMucGVlayA9ICsrdGhpcy5pbmRleCA+PSB0aGlzLmxlbmd0aCA/ICRFT0YgOiB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5pbmRleCk7XG4gICAgICB9O1xuICAgICAgX1NjYW5uZXIucHJvdG90eXBlLnNjYW5Ub2tlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgaW5wdXQgPSB0aGlzLmlucHV0LCBsZW5ndGggPSB0aGlzLmxlbmd0aCwgcGVlayA9IHRoaXMucGVlaywgaW5kZXggPSB0aGlzLmluZGV4O1xuICAgICAgICAgIC8vIFNraXAgd2hpdGVzcGFjZS5cbiAgICAgICAgICB3aGlsZSAocGVlayA8PSAkU1BBQ0UpIHtcbiAgICAgICAgICAgICAgaWYgKCsraW5kZXggPj0gbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICBwZWVrID0gJEVPRjtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcGVlayA9IGlucHV0LmNoYXJDb2RlQXQoaW5kZXgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMucGVlayA9IHBlZWs7XG4gICAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICAgIGlmIChpbmRleCA+PSBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIEhhbmRsZSBpZGVudGlmaWVycyBhbmQgbnVtYmVycy5cbiAgICAgICAgICBpZiAoaXNJZGVudGlmaWVyU3RhcnQocGVlaykpXG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYW5JZGVudGlmaWVyKCk7XG4gICAgICAgICAgaWYgKGlzRGlnaXQocGVlaykpXG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYW5OdW1iZXIoaW5kZXgpO1xuICAgICAgICAgIHZhciBzdGFydCA9IGluZGV4O1xuICAgICAgICAgIHN3aXRjaCAocGVlaykge1xuICAgICAgICAgICAgICBjYXNlICRQRVJJT0Q6XG4gICAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBpc0RpZ2l0KHRoaXMucGVlaykgPyB0aGlzLnNjYW5OdW1iZXIoc3RhcnQpIDpcbiAgICAgICAgICAgICAgICAgICAgICBuZXdDaGFyYWN0ZXJUb2tlbihzdGFydCwgJFBFUklPRCk7XG4gICAgICAgICAgICAgIGNhc2UgJExQQVJFTjpcbiAgICAgICAgICAgICAgY2FzZSAkUlBBUkVOOlxuICAgICAgICAgICAgICBjYXNlICRMQlJBQ0U6XG4gICAgICAgICAgICAgIGNhc2UgJFJCUkFDRTpcbiAgICAgICAgICAgICAgY2FzZSAkTEJSQUNLRVQ6XG4gICAgICAgICAgICAgIGNhc2UgJFJCUkFDS0VUOlxuICAgICAgICAgICAgICBjYXNlICRDT01NQTpcbiAgICAgICAgICAgICAgY2FzZSAkQ09MT046XG4gICAgICAgICAgICAgIGNhc2UgJFNFTUlDT0xPTjpcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYW5DaGFyYWN0ZXIoc3RhcnQsIHBlZWspO1xuICAgICAgICAgICAgICBjYXNlICRTUTpcbiAgICAgICAgICAgICAgY2FzZSAkRFE6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FuU3RyaW5nKCk7XG4gICAgICAgICAgICAgIGNhc2UgJEhBU0g6XG4gICAgICAgICAgICAgIGNhc2UgJFBMVVM6XG4gICAgICAgICAgICAgIGNhc2UgJE1JTlVTOlxuICAgICAgICAgICAgICBjYXNlICRTVEFSOlxuICAgICAgICAgICAgICBjYXNlICRTTEFTSDpcbiAgICAgICAgICAgICAgY2FzZSAkUEVSQ0VOVDpcbiAgICAgICAgICAgICAgY2FzZSAkQ0FSRVQ6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FuT3BlcmF0b3Ioc3RhcnQsIFN0cmluZy5mcm9tQ2hhckNvZGUocGVlaykpO1xuICAgICAgICAgICAgICBjYXNlICRRVUVTVElPTjpcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYW5Db21wbGV4T3BlcmF0b3Ioc3RhcnQsICc/JywgJFBFUklPRCwgJy4nKTtcbiAgICAgICAgICAgICAgY2FzZSAkTFQ6XG4gICAgICAgICAgICAgIGNhc2UgJEdUOlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NhbkNvbXBsZXhPcGVyYXRvcihzdGFydCwgU3RyaW5nLmZyb21DaGFyQ29kZShwZWVrKSwgJEVRLCAnPScpO1xuICAgICAgICAgICAgICBjYXNlICRCQU5HOlxuICAgICAgICAgICAgICBjYXNlICRFUTpcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYW5Db21wbGV4T3BlcmF0b3Ioc3RhcnQsIFN0cmluZy5mcm9tQ2hhckNvZGUocGVlayksICRFUSwgJz0nLCAkRVEsICc9Jyk7XG4gICAgICAgICAgICAgIGNhc2UgJEFNUEVSU0FORDpcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYW5Db21wbGV4T3BlcmF0b3Ioc3RhcnQsICcmJywgJEFNUEVSU0FORCwgJyYnKTtcbiAgICAgICAgICAgICAgY2FzZSAkQkFSOlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NhbkNvbXBsZXhPcGVyYXRvcihzdGFydCwgJ3wnLCAkQkFSLCAnfCcpO1xuICAgICAgICAgICAgICBjYXNlICROQlNQOlxuICAgICAgICAgICAgICAgICAgd2hpbGUgKGlzV2hpdGVzcGFjZSh0aGlzLnBlZWspKVxuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NhblRva2VuKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgIHJldHVybiB0aGlzLmVycm9yKFwiVW5leHBlY3RlZCBjaGFyYWN0ZXIgW1wiICsgU3RyaW5nLmZyb21DaGFyQ29kZShwZWVrKSArIFwiXVwiLCAwKTtcbiAgICAgIH07XG4gICAgICBfU2Nhbm5lci5wcm90b3R5cGUuc2NhbkNoYXJhY3RlciA9IGZ1bmN0aW9uIChzdGFydCwgY29kZSkge1xuICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgIHJldHVybiBuZXdDaGFyYWN0ZXJUb2tlbihzdGFydCwgY29kZSk7XG4gICAgICB9O1xuICAgICAgX1NjYW5uZXIucHJvdG90eXBlLnNjYW5PcGVyYXRvciA9IGZ1bmN0aW9uIChzdGFydCwgc3RyKSB7XG4gICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgcmV0dXJuIG5ld09wZXJhdG9yVG9rZW4oc3RhcnQsIHN0cik7XG4gICAgICB9O1xuICAgICAgLyoqXG4gICAgICAgKiBUb2tlbml6ZSBhIDIvMyBjaGFyIGxvbmcgb3BlcmF0b3JcbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0gc3RhcnQgc3RhcnQgaW5kZXggaW4gdGhlIGV4cHJlc3Npb25cbiAgICAgICAqIEBwYXJhbSBvbmUgZmlyc3Qgc3ltYm9sIChhbHdheXMgcGFydCBvZiB0aGUgb3BlcmF0b3IpXG4gICAgICAgKiBAcGFyYW0gdHdvQ29kZSBjb2RlIHBvaW50IGZvciB0aGUgc2Vjb25kIHN5bWJvbFxuICAgICAgICogQHBhcmFtIHR3byBzZWNvbmQgc3ltYm9sIChwYXJ0IG9mIHRoZSBvcGVyYXRvciB3aGVuIHRoZSBzZWNvbmQgY29kZSBwb2ludCBtYXRjaGVzKVxuICAgICAgICogQHBhcmFtIHRocmVlQ29kZSBjb2RlIHBvaW50IGZvciB0aGUgdGhpcmQgc3ltYm9sXG4gICAgICAgKiBAcGFyYW0gdGhyZWUgdGhpcmQgc3ltYm9sIChwYXJ0IG9mIHRoZSBvcGVyYXRvciB3aGVuIHByb3ZpZGVkIGFuZCBtYXRjaGVzIHNvdXJjZSBleHByZXNzaW9uKVxuICAgICAgICogQHJldHVybnMge1Rva2VufVxuICAgICAgICovXG4gICAgICBfU2Nhbm5lci5wcm90b3R5cGUuc2NhbkNvbXBsZXhPcGVyYXRvciA9IGZ1bmN0aW9uIChzdGFydCwgb25lLCB0d29Db2RlLCB0d28sIHRocmVlQ29kZSwgdGhyZWUpIHtcbiAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICB2YXIgc3RyID0gb25lO1xuICAgICAgICAgIGlmICh0aGlzLnBlZWsgPT0gdHdvQ29kZSkge1xuICAgICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgc3RyICs9IHR3bztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzUHJlc2VudCh0aHJlZUNvZGUpICYmIHRoaXMucGVlayA9PSB0aHJlZUNvZGUpIHtcbiAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICAgIHN0ciArPSB0aHJlZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5ld09wZXJhdG9yVG9rZW4oc3RhcnQsIHN0cik7XG4gICAgICB9O1xuICAgICAgX1NjYW5uZXIucHJvdG90eXBlLnNjYW5JZGVudGlmaWVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBzdGFydCA9IHRoaXMuaW5kZXg7XG4gICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgd2hpbGUgKGlzSWRlbnRpZmllclBhcnQodGhpcy5wZWVrKSlcbiAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgdmFyIHN0ciA9IHRoaXMuaW5wdXQuc3Vic3RyaW5nKHN0YXJ0LCB0aGlzLmluZGV4KTtcbiAgICAgICAgICByZXR1cm4gS0VZV09SRFMuaW5kZXhPZihzdHIpID4gLTEgPyBuZXdLZXl3b3JkVG9rZW4oc3RhcnQsIHN0cikgOlxuICAgICAgICAgICAgICBuZXdJZGVudGlmaWVyVG9rZW4oc3RhcnQsIHN0cik7XG4gICAgICB9O1xuICAgICAgX1NjYW5uZXIucHJvdG90eXBlLnNjYW5OdW1iZXIgPSBmdW5jdGlvbiAoc3RhcnQpIHtcbiAgICAgICAgICB2YXIgc2ltcGxlID0gKHRoaXMuaW5kZXggPT09IHN0YXJ0KTtcbiAgICAgICAgICB0aGlzLmFkdmFuY2UoKTsgLy8gU2tpcCBpbml0aWFsIGRpZ2l0LlxuICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgIGlmIChpc0RpZ2l0KHRoaXMucGVlaykpIHtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLnBlZWsgPT0gJFBFUklPRCkge1xuICAgICAgICAgICAgICAgICAgc2ltcGxlID0gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSBpZiAoaXNFeHBvbmVudFN0YXJ0KHRoaXMucGVlaykpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgICAgICAgaWYgKGlzRXhwb25lbnRTaWduKHRoaXMucGVlaykpXG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICAgICAgICBpZiAoIWlzRGlnaXQodGhpcy5wZWVrKSlcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lcnJvcignSW52YWxpZCBleHBvbmVudCcsIC0xKTtcbiAgICAgICAgICAgICAgICAgIHNpbXBsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBzdHIgPSB0aGlzLmlucHV0LnN1YnN0cmluZyhzdGFydCwgdGhpcy5pbmRleCk7XG4gICAgICAgICAgdmFyIHZhbHVlID0gc2ltcGxlID8gTnVtYmVyV3JhcHBlci5wYXJzZUludEF1dG9SYWRpeChzdHIpIDogcGFyc2VGbG9hdChzdHIpO1xuICAgICAgICAgIHJldHVybiBuZXdOdW1iZXJUb2tlbihzdGFydCwgdmFsdWUpO1xuICAgICAgfTtcbiAgICAgIF9TY2FubmVyLnByb3RvdHlwZS5zY2FuU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBzdGFydCA9IHRoaXMuaW5kZXg7XG4gICAgICAgICAgdmFyIHF1b3RlID0gdGhpcy5wZWVrO1xuICAgICAgICAgIHRoaXMuYWR2YW5jZSgpOyAvLyBTa2lwIGluaXRpYWwgcXVvdGUuXG4gICAgICAgICAgdmFyIGJ1ZmZlciA9ICcnO1xuICAgICAgICAgIHZhciBtYXJrZXIgPSB0aGlzLmluZGV4O1xuICAgICAgICAgIHZhciBpbnB1dCA9IHRoaXMuaW5wdXQ7XG4gICAgICAgICAgd2hpbGUgKHRoaXMucGVlayAhPSBxdW90ZSkge1xuICAgICAgICAgICAgICBpZiAodGhpcy5wZWVrID09ICRCQUNLU0xBU0gpIHtcbiAgICAgICAgICAgICAgICAgIGJ1ZmZlciArPSBpbnB1dC5zdWJzdHJpbmcobWFya2VyLCB0aGlzLmluZGV4KTtcbiAgICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgICAgICAgdmFyIHVuZXNjYXBlZENvZGUgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICBpZiAodGhpcy5wZWVrID09ICR1KSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gNCBjaGFyYWN0ZXIgaGV4IGNvZGUgZm9yIHVuaWNvZGUgY2hhcmFjdGVyLlxuICAgICAgICAgICAgICAgICAgICAgIHZhciBoZXggPSBpbnB1dC5zdWJzdHJpbmcodGhpcy5pbmRleCArIDEsIHRoaXMuaW5kZXggKyA1KTtcbiAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICB1bmVzY2FwZWRDb2RlID0gTnVtYmVyV3JhcHBlci5wYXJzZUludChoZXgsIDE2KTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3IoXCJJbnZhbGlkIHVuaWNvZGUgZXNjYXBlIFtcXFxcdVwiICsgaGV4ICsgXCJdXCIsIDApO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDU7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICB1bmVzY2FwZWRDb2RlID0gdW5lc2NhcGUodGhpcy5wZWVrKTtcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGJ1ZmZlciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHVuZXNjYXBlZENvZGUpO1xuICAgICAgICAgICAgICAgICAgbWFya2VyID0gdGhpcy5pbmRleDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLnBlZWsgPT0gJEVPRikge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3IoJ1VudGVybWluYXRlZCBxdW90ZScsIDApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGxhc3QgPSBpbnB1dC5zdWJzdHJpbmcobWFya2VyLCB0aGlzLmluZGV4KTtcbiAgICAgICAgICB0aGlzLmFkdmFuY2UoKTsgLy8gU2tpcCB0ZXJtaW5hdGluZyBxdW90ZS5cbiAgICAgICAgICByZXR1cm4gbmV3U3RyaW5nVG9rZW4oc3RhcnQsIGJ1ZmZlciArIGxhc3QpO1xuICAgICAgfTtcbiAgICAgIF9TY2FubmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChtZXNzYWdlLCBvZmZzZXQpIHtcbiAgICAgICAgICB2YXIgcG9zaXRpb24gPSB0aGlzLmluZGV4ICsgb2Zmc2V0O1xuICAgICAgICAgIHJldHVybiBuZXdFcnJvclRva2VuKHBvc2l0aW9uLCBcIkxleGVyIEVycm9yOiBcIiArIG1lc3NhZ2UgKyBcIiBhdCBjb2x1bW4gXCIgKyBwb3NpdGlvbiArIFwiIGluIGV4cHJlc3Npb24gW1wiICsgdGhpcy5pbnB1dCArIFwiXVwiKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gX1NjYW5uZXI7XG4gIH0oKSk7XG4gIGZ1bmN0aW9uIGlzSWRlbnRpZmllclN0YXJ0KGNvZGUpIHtcbiAgICAgIHJldHVybiAoJGEgPD0gY29kZSAmJiBjb2RlIDw9ICR6KSB8fCAoJEEgPD0gY29kZSAmJiBjb2RlIDw9ICRaKSB8fFxuICAgICAgICAgIChjb2RlID09ICRfKSB8fCAoY29kZSA9PSAkJCk7XG4gIH1cbiAgZnVuY3Rpb24gaXNJZGVudGlmaWVyKGlucHV0KSB7XG4gICAgICBpZiAoaW5wdXQubGVuZ3RoID09IDApXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgdmFyIHNjYW5uZXIgPSBuZXcgX1NjYW5uZXIoaW5wdXQpO1xuICAgICAgaWYgKCFpc0lkZW50aWZpZXJTdGFydChzY2FubmVyLnBlZWspKVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIHNjYW5uZXIuYWR2YW5jZSgpO1xuICAgICAgd2hpbGUgKHNjYW5uZXIucGVlayAhPT0gJEVPRikge1xuICAgICAgICAgIGlmICghaXNJZGVudGlmaWVyUGFydChzY2FubmVyLnBlZWspKVxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgc2Nhbm5lci5hZHZhbmNlKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBmdW5jdGlvbiBpc0lkZW50aWZpZXJQYXJ0KGNvZGUpIHtcbiAgICAgIHJldHVybiBpc0FzY2lpTGV0dGVyKGNvZGUpIHx8IGlzRGlnaXQoY29kZSkgfHwgKGNvZGUgPT0gJF8pIHx8XG4gICAgICAgICAgKGNvZGUgPT0gJCQpO1xuICB9XG4gIGZ1bmN0aW9uIGlzRXhwb25lbnRTdGFydChjb2RlKSB7XG4gICAgICByZXR1cm4gY29kZSA9PSAkZSB8fCBjb2RlID09ICRFO1xuICB9XG4gIGZ1bmN0aW9uIGlzRXhwb25lbnRTaWduKGNvZGUpIHtcbiAgICAgIHJldHVybiBjb2RlID09ICRNSU5VUyB8fCBjb2RlID09ICRQTFVTO1xuICB9XG4gIGZ1bmN0aW9uIGlzUXVvdGUoY29kZSkge1xuICAgICAgcmV0dXJuIGNvZGUgPT09ICRTUSB8fCBjb2RlID09PSAkRFEgfHwgY29kZSA9PT0gJEJUO1xuICB9XG4gIGZ1bmN0aW9uIHVuZXNjYXBlKGNvZGUpIHtcbiAgICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgICAgIGNhc2UgJG46XG4gICAgICAgICAgICAgIHJldHVybiAkTEY7XG4gICAgICAgICAgY2FzZSAkZjpcbiAgICAgICAgICAgICAgcmV0dXJuICRGRjtcbiAgICAgICAgICBjYXNlICRyOlxuICAgICAgICAgICAgICByZXR1cm4gJENSO1xuICAgICAgICAgIGNhc2UgJHQ6XG4gICAgICAgICAgICAgIHJldHVybiAkVEFCO1xuICAgICAgICAgIGNhc2UgJHY6XG4gICAgICAgICAgICAgIHJldHVybiAkVlRBQjtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICByZXR1cm4gY29kZTtcbiAgICAgIH1cbiAgfVxuXG4gIHZhciBTcGxpdEludGVycG9sYXRpb24gPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gU3BsaXRJbnRlcnBvbGF0aW9uKHN0cmluZ3MsIGV4cHJlc3Npb25zLCBvZmZzZXRzKSB7XG4gICAgICAgICAgdGhpcy5zdHJpbmdzID0gc3RyaW5ncztcbiAgICAgICAgICB0aGlzLmV4cHJlc3Npb25zID0gZXhwcmVzc2lvbnM7XG4gICAgICAgICAgdGhpcy5vZmZzZXRzID0gb2Zmc2V0cztcbiAgICAgIH1cbiAgICAgIHJldHVybiBTcGxpdEludGVycG9sYXRpb247XG4gIH0oKSk7XG4gIHZhciBUZW1wbGF0ZUJpbmRpbmdQYXJzZVJlc3VsdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBUZW1wbGF0ZUJpbmRpbmdQYXJzZVJlc3VsdCh0ZW1wbGF0ZUJpbmRpbmdzLCB3YXJuaW5ncywgZXJyb3JzKSB7XG4gICAgICAgICAgdGhpcy50ZW1wbGF0ZUJpbmRpbmdzID0gdGVtcGxhdGVCaW5kaW5ncztcbiAgICAgICAgICB0aGlzLndhcm5pbmdzID0gd2FybmluZ3M7XG4gICAgICAgICAgdGhpcy5lcnJvcnMgPSBlcnJvcnM7XG4gICAgICB9XG4gICAgICByZXR1cm4gVGVtcGxhdGVCaW5kaW5nUGFyc2VSZXN1bHQ7XG4gIH0oKSk7XG4gIGZ1bmN0aW9uIF9jcmVhdGVJbnRlcnBvbGF0ZVJlZ0V4cChjb25maWcpIHtcbiAgICAgIHZhciBwYXR0ZXJuID0gZXNjYXBlUmVnRXhwKGNvbmZpZy5zdGFydCkgKyAnKFtcXFxcc1xcXFxTXSo/KScgKyBlc2NhcGVSZWdFeHAoY29uZmlnLmVuZCk7XG4gICAgICByZXR1cm4gbmV3IFJlZ0V4cChwYXR0ZXJuLCAnZycpO1xuICB9XG4gIHZhciBQYXJzZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gUGFyc2VyKF9sZXhlcikge1xuICAgICAgICAgIHRoaXMuX2xleGVyID0gX2xleGVyO1xuICAgICAgICAgIHRoaXMuZXJyb3JzID0gW107XG4gICAgICB9XG4gICAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlQWN0aW9uID0gZnVuY3Rpb24gKGlucHV0LCBsb2NhdGlvbiwgaW50ZXJwb2xhdGlvbkNvbmZpZykge1xuICAgICAgICAgIGlmIChpbnRlcnBvbGF0aW9uQ29uZmlnID09PSB2b2lkIDApIHsgaW50ZXJwb2xhdGlvbkNvbmZpZyA9IERFRkFVTFRfSU5URVJQT0xBVElPTl9DT05GSUc7IH1cbiAgICAgICAgICB0aGlzLl9jaGVja05vSW50ZXJwb2xhdGlvbihpbnB1dCwgbG9jYXRpb24sIGludGVycG9sYXRpb25Db25maWcpO1xuICAgICAgICAgIHZhciBzb3VyY2VUb0xleCA9IHRoaXMuX3N0cmlwQ29tbWVudHMoaW5wdXQpO1xuICAgICAgICAgIHZhciB0b2tlbnMgPSB0aGlzLl9sZXhlci50b2tlbml6ZSh0aGlzLl9zdHJpcENvbW1lbnRzKGlucHV0KSk7XG4gICAgICAgICAgdmFyIGFzdCA9IG5ldyBfUGFyc2VBU1QoaW5wdXQsIGxvY2F0aW9uLCB0b2tlbnMsIHNvdXJjZVRvTGV4Lmxlbmd0aCwgdHJ1ZSwgdGhpcy5lcnJvcnMsIGlucHV0Lmxlbmd0aCAtIHNvdXJjZVRvTGV4Lmxlbmd0aClcbiAgICAgICAgICAgICAgLnBhcnNlQ2hhaW4oKTtcbiAgICAgICAgICByZXR1cm4gbmV3IEFTVFdpdGhTb3VyY2UoYXN0LCBpbnB1dCwgbG9jYXRpb24sIHRoaXMuZXJyb3JzKTtcbiAgICAgIH07XG4gICAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlQmluZGluZyA9IGZ1bmN0aW9uIChpbnB1dCwgbG9jYXRpb24sIGludGVycG9sYXRpb25Db25maWcpIHtcbiAgICAgICAgICBpZiAoaW50ZXJwb2xhdGlvbkNvbmZpZyA9PT0gdm9pZCAwKSB7IGludGVycG9sYXRpb25Db25maWcgPSBERUZBVUxUX0lOVEVSUE9MQVRJT05fQ09ORklHOyB9XG4gICAgICAgICAgdmFyIGFzdCA9IHRoaXMuX3BhcnNlQmluZGluZ0FzdChpbnB1dCwgbG9jYXRpb24sIGludGVycG9sYXRpb25Db25maWcpO1xuICAgICAgICAgIHJldHVybiBuZXcgQVNUV2l0aFNvdXJjZShhc3QsIGlucHV0LCBsb2NhdGlvbiwgdGhpcy5lcnJvcnMpO1xuICAgICAgfTtcbiAgICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VTaW1wbGVCaW5kaW5nID0gZnVuY3Rpb24gKGlucHV0LCBsb2NhdGlvbiwgaW50ZXJwb2xhdGlvbkNvbmZpZykge1xuICAgICAgICAgIGlmIChpbnRlcnBvbGF0aW9uQ29uZmlnID09PSB2b2lkIDApIHsgaW50ZXJwb2xhdGlvbkNvbmZpZyA9IERFRkFVTFRfSU5URVJQT0xBVElPTl9DT05GSUc7IH1cbiAgICAgICAgICB2YXIgYXN0ID0gdGhpcy5fcGFyc2VCaW5kaW5nQXN0KGlucHV0LCBsb2NhdGlvbiwgaW50ZXJwb2xhdGlvbkNvbmZpZyk7XG4gICAgICAgICAgdmFyIGVycm9ycyA9IFNpbXBsZUV4cHJlc3Npb25DaGVja2VyLmNoZWNrKGFzdCk7XG4gICAgICAgICAgaWYgKGVycm9ycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKFwiSG9zdCBiaW5kaW5nIGV4cHJlc3Npb24gY2Fubm90IGNvbnRhaW4gXCIgKyBlcnJvcnMuam9pbignICcpLCBpbnB1dCwgbG9jYXRpb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3IEFTVFdpdGhTb3VyY2UoYXN0LCBpbnB1dCwgbG9jYXRpb24sIHRoaXMuZXJyb3JzKTtcbiAgICAgIH07XG4gICAgICBQYXJzZXIucHJvdG90eXBlLl9yZXBvcnRFcnJvciA9IGZ1bmN0aW9uIChtZXNzYWdlLCBpbnB1dCwgZXJyTG9jYXRpb24sIGN0eExvY2F0aW9uKSB7XG4gICAgICAgICAgdGhpcy5lcnJvcnMucHVzaChuZXcgUGFyc2VyRXJyb3IobWVzc2FnZSwgaW5wdXQsIGVyckxvY2F0aW9uLCBjdHhMb2NhdGlvbikpO1xuICAgICAgfTtcbiAgICAgIFBhcnNlci5wcm90b3R5cGUuX3BhcnNlQmluZGluZ0FzdCA9IGZ1bmN0aW9uIChpbnB1dCwgbG9jYXRpb24sIGludGVycG9sYXRpb25Db25maWcpIHtcbiAgICAgICAgICAvLyBRdW90ZXMgZXhwcmVzc2lvbnMgdXNlIDNyZC1wYXJ0eSBleHByZXNzaW9uIGxhbmd1YWdlLiBXZSBkb24ndCB3YW50IHRvIHVzZVxuICAgICAgICAgIC8vIG91ciBsZXhlciBvciBwYXJzZXIgZm9yIHRoYXQsIHNvIHdlIGNoZWNrIGZvciB0aGF0IGFoZWFkIG9mIHRpbWUuXG4gICAgICAgICAgdmFyIHF1b3RlID0gdGhpcy5fcGFyc2VRdW90ZShpbnB1dCwgbG9jYXRpb24pO1xuICAgICAgICAgIGlmIChpc1ByZXNlbnQocXVvdGUpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBxdW90ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fY2hlY2tOb0ludGVycG9sYXRpb24oaW5wdXQsIGxvY2F0aW9uLCBpbnRlcnBvbGF0aW9uQ29uZmlnKTtcbiAgICAgICAgICB2YXIgc291cmNlVG9MZXggPSB0aGlzLl9zdHJpcENvbW1lbnRzKGlucHV0KTtcbiAgICAgICAgICB2YXIgdG9rZW5zID0gdGhpcy5fbGV4ZXIudG9rZW5pemUoc291cmNlVG9MZXgpO1xuICAgICAgICAgIHJldHVybiBuZXcgX1BhcnNlQVNUKGlucHV0LCBsb2NhdGlvbiwgdG9rZW5zLCBzb3VyY2VUb0xleC5sZW5ndGgsIGZhbHNlLCB0aGlzLmVycm9ycywgaW5wdXQubGVuZ3RoIC0gc291cmNlVG9MZXgubGVuZ3RoKVxuICAgICAgICAgICAgICAucGFyc2VDaGFpbigpO1xuICAgICAgfTtcbiAgICAgIFBhcnNlci5wcm90b3R5cGUuX3BhcnNlUXVvdGUgPSBmdW5jdGlvbiAoaW5wdXQsIGxvY2F0aW9uKSB7XG4gICAgICAgICAgaWYgKGlzQmxhbmsoaW5wdXQpKVxuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB2YXIgcHJlZml4U2VwYXJhdG9ySW5kZXggPSBpbnB1dC5pbmRleE9mKCc6Jyk7XG4gICAgICAgICAgaWYgKHByZWZpeFNlcGFyYXRvckluZGV4ID09IC0xKVxuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB2YXIgcHJlZml4ID0gaW5wdXQuc3Vic3RyaW5nKDAsIHByZWZpeFNlcGFyYXRvckluZGV4KS50cmltKCk7XG4gICAgICAgICAgaWYgKCFpc0lkZW50aWZpZXIocHJlZml4KSlcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgdmFyIHVuaW50ZXJwcmV0ZWRFeHByZXNzaW9uID0gaW5wdXQuc3Vic3RyaW5nKHByZWZpeFNlcGFyYXRvckluZGV4ICsgMSk7XG4gICAgICAgICAgcmV0dXJuIG5ldyBRdW90ZShuZXcgUGFyc2VTcGFuKDAsIGlucHV0Lmxlbmd0aCksIHByZWZpeCwgdW5pbnRlcnByZXRlZEV4cHJlc3Npb24sIGxvY2F0aW9uKTtcbiAgICAgIH07XG4gICAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlVGVtcGxhdGVCaW5kaW5ncyA9IGZ1bmN0aW9uIChpbnB1dCwgbG9jYXRpb24pIHtcbiAgICAgICAgICB2YXIgdG9rZW5zID0gdGhpcy5fbGV4ZXIudG9rZW5pemUoaW5wdXQpO1xuICAgICAgICAgIHJldHVybiBuZXcgX1BhcnNlQVNUKGlucHV0LCBsb2NhdGlvbiwgdG9rZW5zLCBpbnB1dC5sZW5ndGgsIGZhbHNlLCB0aGlzLmVycm9ycywgMClcbiAgICAgICAgICAgICAgLnBhcnNlVGVtcGxhdGVCaW5kaW5ncygpO1xuICAgICAgfTtcbiAgICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VJbnRlcnBvbGF0aW9uID0gZnVuY3Rpb24gKGlucHV0LCBsb2NhdGlvbiwgaW50ZXJwb2xhdGlvbkNvbmZpZykge1xuICAgICAgICAgIGlmIChpbnRlcnBvbGF0aW9uQ29uZmlnID09PSB2b2lkIDApIHsgaW50ZXJwb2xhdGlvbkNvbmZpZyA9IERFRkFVTFRfSU5URVJQT0xBVElPTl9DT05GSUc7IH1cbiAgICAgICAgICB2YXIgc3BsaXQgPSB0aGlzLnNwbGl0SW50ZXJwb2xhdGlvbihpbnB1dCwgbG9jYXRpb24sIGludGVycG9sYXRpb25Db25maWcpO1xuICAgICAgICAgIGlmIChzcGxpdCA9PSBudWxsKVxuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB2YXIgZXhwcmVzc2lvbnMgPSBbXTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNwbGl0LmV4cHJlc3Npb25zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgIHZhciBleHByZXNzaW9uVGV4dCA9IHNwbGl0LmV4cHJlc3Npb25zW2ldO1xuICAgICAgICAgICAgICB2YXIgc291cmNlVG9MZXggPSB0aGlzLl9zdHJpcENvbW1lbnRzKGV4cHJlc3Npb25UZXh0KTtcbiAgICAgICAgICAgICAgdmFyIHRva2VucyA9IHRoaXMuX2xleGVyLnRva2VuaXplKHRoaXMuX3N0cmlwQ29tbWVudHMoc3BsaXQuZXhwcmVzc2lvbnNbaV0pKTtcbiAgICAgICAgICAgICAgdmFyIGFzdCA9IG5ldyBfUGFyc2VBU1QoaW5wdXQsIGxvY2F0aW9uLCB0b2tlbnMsIHNvdXJjZVRvTGV4Lmxlbmd0aCwgZmFsc2UsIHRoaXMuZXJyb3JzLCBzcGxpdC5vZmZzZXRzW2ldICsgKGV4cHJlc3Npb25UZXh0Lmxlbmd0aCAtIHNvdXJjZVRvTGV4Lmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAucGFyc2VDaGFpbigpO1xuICAgICAgICAgICAgICBleHByZXNzaW9ucy5wdXNoKGFzdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuZXcgQVNUV2l0aFNvdXJjZShuZXcgSW50ZXJwb2xhdGlvbihuZXcgUGFyc2VTcGFuKDAsIGlzQmxhbmsoaW5wdXQpID8gMCA6IGlucHV0Lmxlbmd0aCksIHNwbGl0LnN0cmluZ3MsIGV4cHJlc3Npb25zKSwgaW5wdXQsIGxvY2F0aW9uLCB0aGlzLmVycm9ycyk7XG4gICAgICB9O1xuICAgICAgUGFyc2VyLnByb3RvdHlwZS5zcGxpdEludGVycG9sYXRpb24gPSBmdW5jdGlvbiAoaW5wdXQsIGxvY2F0aW9uLCBpbnRlcnBvbGF0aW9uQ29uZmlnKSB7XG4gICAgICAgICAgaWYgKGludGVycG9sYXRpb25Db25maWcgPT09IHZvaWQgMCkgeyBpbnRlcnBvbGF0aW9uQ29uZmlnID0gREVGQVVMVF9JTlRFUlBPTEFUSU9OX0NPTkZJRzsgfVxuICAgICAgICAgIHZhciByZWdleHAgPSBfY3JlYXRlSW50ZXJwb2xhdGVSZWdFeHAoaW50ZXJwb2xhdGlvbkNvbmZpZyk7XG4gICAgICAgICAgdmFyIHBhcnRzID0gaW5wdXQuc3BsaXQocmVnZXhwKTtcbiAgICAgICAgICBpZiAocGFydHMubGVuZ3RoIDw9IDEpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBzdHJpbmdzID0gW107XG4gICAgICAgICAgdmFyIGV4cHJlc3Npb25zID0gW107XG4gICAgICAgICAgdmFyIG9mZnNldHMgPSBbXTtcbiAgICAgICAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIHZhciBwYXJ0ID0gcGFydHNbaV07XG4gICAgICAgICAgICAgIGlmIChpICUgMiA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgLy8gZml4ZWQgc3RyaW5nXG4gICAgICAgICAgICAgICAgICBzdHJpbmdzLnB1c2gocGFydCk7XG4gICAgICAgICAgICAgICAgICBvZmZzZXQgKz0gcGFydC5sZW5ndGg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSBpZiAocGFydC50cmltKCkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgb2Zmc2V0ICs9IGludGVycG9sYXRpb25Db25maWcuc3RhcnQubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbnMucHVzaChwYXJ0KTtcbiAgICAgICAgICAgICAgICAgIG9mZnNldHMucHVzaChvZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgb2Zmc2V0ICs9IHBhcnQubGVuZ3RoICsgaW50ZXJwb2xhdGlvbkNvbmZpZy5lbmQubGVuZ3RoO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoJ0JsYW5rIGV4cHJlc3Npb25zIGFyZSBub3QgYWxsb3dlZCBpbiBpbnRlcnBvbGF0ZWQgc3RyaW5ncycsIGlucHV0LCBcImF0IGNvbHVtbiBcIiArIHRoaXMuX2ZpbmRJbnRlcnBvbGF0aW9uRXJyb3JDb2x1bW4ocGFydHMsIGksIGludGVycG9sYXRpb25Db25maWcpICsgXCIgaW5cIiwgbG9jYXRpb24pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuZXcgU3BsaXRJbnRlcnBvbGF0aW9uKHN0cmluZ3MsIGV4cHJlc3Npb25zLCBvZmZzZXRzKTtcbiAgICAgIH07XG4gICAgICBQYXJzZXIucHJvdG90eXBlLndyYXBMaXRlcmFsUHJpbWl0aXZlID0gZnVuY3Rpb24gKGlucHV0LCBsb2NhdGlvbikge1xuICAgICAgICAgIHJldHVybiBuZXcgQVNUV2l0aFNvdXJjZShuZXcgTGl0ZXJhbFByaW1pdGl2ZShuZXcgUGFyc2VTcGFuKDAsIGlzQmxhbmsoaW5wdXQpID8gMCA6IGlucHV0Lmxlbmd0aCksIGlucHV0KSwgaW5wdXQsIGxvY2F0aW9uLCB0aGlzLmVycm9ycyk7XG4gICAgICB9O1xuICAgICAgUGFyc2VyLnByb3RvdHlwZS5fc3RyaXBDb21tZW50cyA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICAgIHZhciBpID0gdGhpcy5fY29tbWVudFN0YXJ0KGlucHV0KTtcbiAgICAgICAgICByZXR1cm4gaXNQcmVzZW50KGkpID8gaW5wdXQuc3Vic3RyaW5nKDAsIGkpLnRyaW0oKSA6IGlucHV0O1xuICAgICAgfTtcbiAgICAgIFBhcnNlci5wcm90b3R5cGUuX2NvbW1lbnRTdGFydCA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICAgIHZhciBvdXRlclF1b3RlID0gbnVsbDtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgICB2YXIgY2hhciA9IGlucHV0LmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICAgIHZhciBuZXh0Q2hhciA9IGlucHV0LmNoYXJDb2RlQXQoaSArIDEpO1xuICAgICAgICAgICAgICBpZiAoY2hhciA9PT0gJFNMQVNIICYmIG5leHRDaGFyID09ICRTTEFTSCAmJiBpc0JsYW5rKG91dGVyUXVvdGUpKVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICAgIGlmIChvdXRlclF1b3RlID09PSBjaGFyKSB7XG4gICAgICAgICAgICAgICAgICBvdXRlclF1b3RlID0gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIGlmIChpc0JsYW5rKG91dGVyUXVvdGUpICYmIGlzUXVvdGUoY2hhcikpIHtcbiAgICAgICAgICAgICAgICAgIG91dGVyUXVvdGUgPSBjaGFyO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcbiAgICAgIFBhcnNlci5wcm90b3R5cGUuX2NoZWNrTm9JbnRlcnBvbGF0aW9uID0gZnVuY3Rpb24gKGlucHV0LCBsb2NhdGlvbiwgaW50ZXJwb2xhdGlvbkNvbmZpZykge1xuICAgICAgICAgIHZhciByZWdleHAgPSBfY3JlYXRlSW50ZXJwb2xhdGVSZWdFeHAoaW50ZXJwb2xhdGlvbkNvbmZpZyk7XG4gICAgICAgICAgdmFyIHBhcnRzID0gaW5wdXQuc3BsaXQocmVnZXhwKTtcbiAgICAgICAgICBpZiAocGFydHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihcIkdvdCBpbnRlcnBvbGF0aW9uIChcIiArIGludGVycG9sYXRpb25Db25maWcuc3RhcnQgKyBpbnRlcnBvbGF0aW9uQ29uZmlnLmVuZCArIFwiKSB3aGVyZSBleHByZXNzaW9uIHdhcyBleHBlY3RlZFwiLCBpbnB1dCwgXCJhdCBjb2x1bW4gXCIgKyB0aGlzLl9maW5kSW50ZXJwb2xhdGlvbkVycm9yQ29sdW1uKHBhcnRzLCAxLCBpbnRlcnBvbGF0aW9uQ29uZmlnKSArIFwiIGluXCIsIGxvY2F0aW9uKTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgUGFyc2VyLnByb3RvdHlwZS5fZmluZEludGVycG9sYXRpb25FcnJvckNvbHVtbiA9IGZ1bmN0aW9uIChwYXJ0cywgcGFydEluRXJySWR4LCBpbnRlcnBvbGF0aW9uQ29uZmlnKSB7XG4gICAgICAgICAgdmFyIGVyckxvY2F0aW9uID0gJyc7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBwYXJ0SW5FcnJJZHg7IGorKykge1xuICAgICAgICAgICAgICBlcnJMb2NhdGlvbiArPSBqICUgMiA9PT0gMCA/XG4gICAgICAgICAgICAgICAgICBwYXJ0c1tqXSA6XG4gICAgICAgICAgICAgICAgICBcIlwiICsgaW50ZXJwb2xhdGlvbkNvbmZpZy5zdGFydCArIHBhcnRzW2pdICsgaW50ZXJwb2xhdGlvbkNvbmZpZy5lbmQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBlcnJMb2NhdGlvbi5sZW5ndGg7XG4gICAgICB9O1xuICAgICAgUGFyc2VyLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdGFibGUgfSxcbiAgICAgIF07XG4gICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgIFBhcnNlci5jdG9yUGFyYW1ldGVycyA9IFtcbiAgICAgICAgICB7IHR5cGU6IExleGVyLCB9LFxuICAgICAgXTtcbiAgICAgIHJldHVybiBQYXJzZXI7XG4gIH0oKSk7XG4gIHZhciBfUGFyc2VBU1QgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gX1BhcnNlQVNUKGlucHV0LCBsb2NhdGlvbiwgdG9rZW5zLCBpbnB1dExlbmd0aCwgcGFyc2VBY3Rpb24sIGVycm9ycywgb2Zmc2V0KSB7XG4gICAgICAgICAgdGhpcy5pbnB1dCA9IGlucHV0O1xuICAgICAgICAgIHRoaXMubG9jYXRpb24gPSBsb2NhdGlvbjtcbiAgICAgICAgICB0aGlzLnRva2VucyA9IHRva2VucztcbiAgICAgICAgICB0aGlzLmlucHV0TGVuZ3RoID0gaW5wdXRMZW5ndGg7XG4gICAgICAgICAgdGhpcy5wYXJzZUFjdGlvbiA9IHBhcnNlQWN0aW9uO1xuICAgICAgICAgIHRoaXMuZXJyb3JzID0gZXJyb3JzO1xuICAgICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICAgIHRoaXMucnBhcmVuc0V4cGVjdGVkID0gMDtcbiAgICAgICAgICB0aGlzLnJicmFja2V0c0V4cGVjdGVkID0gMDtcbiAgICAgICAgICB0aGlzLnJicmFjZXNFeHBlY3RlZCA9IDA7XG4gICAgICAgICAgdGhpcy5pbmRleCA9IDA7XG4gICAgICB9XG4gICAgICBfUGFyc2VBU1QucHJvdG90eXBlLnBlZWsgPSBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgICAgICAgdmFyIGkgPSB0aGlzLmluZGV4ICsgb2Zmc2V0O1xuICAgICAgICAgIHJldHVybiBpIDwgdGhpcy50b2tlbnMubGVuZ3RoID8gdGhpcy50b2tlbnNbaV0gOiBFT0Y7XG4gICAgICB9O1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9QYXJzZUFTVC5wcm90b3R5cGUsIFwibmV4dFwiLCB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnBlZWsoMCk7IH0sXG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9QYXJzZUFTVC5wcm90b3R5cGUsIFwiaW5wdXRJbmRleFwiLCB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiAodGhpcy5pbmRleCA8IHRoaXMudG9rZW5zLmxlbmd0aCkgPyB0aGlzLm5leHQuaW5kZXggKyB0aGlzLm9mZnNldCA6XG4gICAgICAgICAgICAgICAgICB0aGlzLmlucHV0TGVuZ3RoICsgdGhpcy5vZmZzZXQ7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBfUGFyc2VBU1QucHJvdG90eXBlLnNwYW4gPSBmdW5jdGlvbiAoc3RhcnQpIHsgcmV0dXJuIG5ldyBQYXJzZVNwYW4oc3RhcnQsIHRoaXMuaW5wdXRJbmRleCk7IH07XG4gICAgICBfUGFyc2VBU1QucHJvdG90eXBlLmFkdmFuY2UgPSBmdW5jdGlvbiAoKSB7IHRoaXMuaW5kZXgrKzsgfTtcbiAgICAgIF9QYXJzZUFTVC5wcm90b3R5cGUub3B0aW9uYWxDaGFyYWN0ZXIgPSBmdW5jdGlvbiAoY29kZSkge1xuICAgICAgICAgIGlmICh0aGlzLm5leHQuaXNDaGFyYWN0ZXIoY29kZSkpIHtcbiAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICBfUGFyc2VBU1QucHJvdG90eXBlLnBlZWtLZXl3b3JkTGV0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5uZXh0LmlzS2V5d29yZExldCgpOyB9O1xuICAgICAgX1BhcnNlQVNULnByb3RvdHlwZS5leHBlY3RDaGFyYWN0ZXIgPSBmdW5jdGlvbiAoY29kZSkge1xuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbmFsQ2hhcmFjdGVyKGNvZGUpKVxuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgdGhpcy5lcnJvcihcIk1pc3NpbmcgZXhwZWN0ZWQgXCIgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpKTtcbiAgICAgIH07XG4gICAgICBfUGFyc2VBU1QucHJvdG90eXBlLm9wdGlvbmFsT3BlcmF0b3IgPSBmdW5jdGlvbiAob3ApIHtcbiAgICAgICAgICBpZiAodGhpcy5uZXh0LmlzT3BlcmF0b3Iob3ApKSB7XG4gICAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgX1BhcnNlQVNULnByb3RvdHlwZS5leHBlY3RPcGVyYXRvciA9IGZ1bmN0aW9uIChvcGVyYXRvcikge1xuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbmFsT3BlcmF0b3Iob3BlcmF0b3IpKVxuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgdGhpcy5lcnJvcihcIk1pc3NpbmcgZXhwZWN0ZWQgb3BlcmF0b3IgXCIgKyBvcGVyYXRvcik7XG4gICAgICB9O1xuICAgICAgX1BhcnNlQVNULnByb3RvdHlwZS5leHBlY3RJZGVudGlmaWVyT3JLZXl3b3JkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBuID0gdGhpcy5uZXh0O1xuICAgICAgICAgIGlmICghbi5pc0lkZW50aWZpZXIoKSAmJiAhbi5pc0tleXdvcmQoKSkge1xuICAgICAgICAgICAgICB0aGlzLmVycm9yKFwiVW5leHBlY3RlZCB0b2tlbiBcIiArIG4gKyBcIiwgZXhwZWN0ZWQgaWRlbnRpZmllciBvciBrZXl3b3JkXCIpO1xuICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgIHJldHVybiBuLnRvU3RyaW5nKCk7XG4gICAgICB9O1xuICAgICAgX1BhcnNlQVNULnByb3RvdHlwZS5leHBlY3RJZGVudGlmaWVyT3JLZXl3b3JkT3JTdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIG4gPSB0aGlzLm5leHQ7XG4gICAgICAgICAgaWYgKCFuLmlzSWRlbnRpZmllcigpICYmICFuLmlzS2V5d29yZCgpICYmICFuLmlzU3RyaW5nKCkpIHtcbiAgICAgICAgICAgICAgdGhpcy5lcnJvcihcIlVuZXhwZWN0ZWQgdG9rZW4gXCIgKyBuICsgXCIsIGV4cGVjdGVkIGlkZW50aWZpZXIsIGtleXdvcmQsIG9yIHN0cmluZ1wiKTtcbiAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICByZXR1cm4gbi50b1N0cmluZygpO1xuICAgICAgfTtcbiAgICAgIF9QYXJzZUFTVC5wcm90b3R5cGUucGFyc2VDaGFpbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgZXhwcnMgPSBbXTtcbiAgICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLmlucHV0SW5kZXg7XG4gICAgICAgICAgd2hpbGUgKHRoaXMuaW5kZXggPCB0aGlzLnRva2Vucy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgdmFyIGV4cHIgPSB0aGlzLnBhcnNlUGlwZSgpO1xuICAgICAgICAgICAgICBleHBycy5wdXNoKGV4cHIpO1xuICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25hbENoYXJhY3RlcigkU0VNSUNPTE9OKSkge1xuICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnBhcnNlQWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvcignQmluZGluZyBleHByZXNzaW9uIGNhbm5vdCBjb250YWluIGNoYWluZWQgZXhwcmVzc2lvbicpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgd2hpbGUgKHRoaXMub3B0aW9uYWxDaGFyYWN0ZXIoJFNFTUlDT0xPTikpIHtcbiAgICAgICAgICAgICAgICAgIH0gLy8gcmVhZCBhbGwgc2VtaWNvbG9uc1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuaW5kZXggPCB0aGlzLnRva2Vucy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IoXCJVbmV4cGVjdGVkIHRva2VuICdcIiArIHRoaXMubmV4dCArIFwiJ1wiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZXhwcnMubGVuZ3RoID09IDApXG4gICAgICAgICAgICAgIHJldHVybiBuZXcgRW1wdHlFeHByKHRoaXMuc3BhbihzdGFydCkpO1xuICAgICAgICAgIGlmIChleHBycy5sZW5ndGggPT0gMSlcbiAgICAgICAgICAgICAgcmV0dXJuIGV4cHJzWzBdO1xuICAgICAgICAgIHJldHVybiBuZXcgQ2hhaW4odGhpcy5zcGFuKHN0YXJ0KSwgZXhwcnMpO1xuICAgICAgfTtcbiAgICAgIF9QYXJzZUFTVC5wcm90b3R5cGUucGFyc2VQaXBlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbmFsT3BlcmF0b3IoJ3wnKSkge1xuICAgICAgICAgICAgICBpZiAodGhpcy5wYXJzZUFjdGlvbikge1xuICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvcignQ2Fubm90IGhhdmUgYSBwaXBlIGluIGFuIGFjdGlvbiBleHByZXNzaW9uJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgdmFyIG5hbWUgPSB0aGlzLmV4cGVjdElkZW50aWZpZXJPcktleXdvcmQoKTtcbiAgICAgICAgICAgICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgICAgICAgICAgICB3aGlsZSAodGhpcy5vcHRpb25hbENoYXJhY3RlcigkQ09MT04pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgYXJncy5wdXNoKHRoaXMucGFyc2VFeHByZXNzaW9uKCkpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IEJpbmRpbmdQaXBlKHRoaXMuc3BhbihyZXN1bHQuc3Bhbi5zdGFydCAtIHRoaXMub2Zmc2V0KSwgcmVzdWx0LCBuYW1lLCBhcmdzKTtcbiAgICAgICAgICAgICAgfSB3aGlsZSAodGhpcy5vcHRpb25hbE9wZXJhdG9yKCd8JykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICAgIF9QYXJzZUFTVC5wcm90b3R5cGUucGFyc2VFeHByZXNzaW9uID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5wYXJzZUNvbmRpdGlvbmFsKCk7IH07XG4gICAgICBfUGFyc2VBU1QucHJvdG90eXBlLnBhcnNlQ29uZGl0aW9uYWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5pbnB1dEluZGV4O1xuICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLnBhcnNlTG9naWNhbE9yKCk7XG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9uYWxPcGVyYXRvcignPycpKSB7XG4gICAgICAgICAgICAgIHZhciB5ZXMgPSB0aGlzLnBhcnNlUGlwZSgpO1xuICAgICAgICAgICAgICB2YXIgbm8gPSB2b2lkIDA7XG4gICAgICAgICAgICAgIGlmICghdGhpcy5vcHRpb25hbENoYXJhY3RlcigkQ09MT04pKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgZW5kID0gdGhpcy5pbnB1dEluZGV4O1xuICAgICAgICAgICAgICAgICAgdmFyIGV4cHJlc3Npb24gPSB0aGlzLmlucHV0LnN1YnN0cmluZyhzdGFydCwgZW5kKTtcbiAgICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IoXCJDb25kaXRpb25hbCBleHByZXNzaW9uIFwiICsgZXhwcmVzc2lvbiArIFwiIHJlcXVpcmVzIGFsbCAzIGV4cHJlc3Npb25zXCIpO1xuICAgICAgICAgICAgICAgICAgbm8gPSBuZXcgRW1wdHlFeHByKHRoaXMuc3BhbihzdGFydCkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgbm8gPSB0aGlzLnBhcnNlUGlwZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgQ29uZGl0aW9uYWwodGhpcy5zcGFuKHN0YXJ0KSwgcmVzdWx0LCB5ZXMsIG5vKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIF9QYXJzZUFTVC5wcm90b3R5cGUucGFyc2VMb2dpY2FsT3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgLy8gJ3x8J1xuICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLnBhcnNlTG9naWNhbEFuZCgpO1xuICAgICAgICAgIHdoaWxlICh0aGlzLm9wdGlvbmFsT3BlcmF0b3IoJ3x8JykpIHtcbiAgICAgICAgICAgICAgdmFyIHJpZ2h0ID0gdGhpcy5wYXJzZUxvZ2ljYWxBbmQoKTtcbiAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IEJpbmFyeSh0aGlzLnNwYW4ocmVzdWx0LnNwYW4uc3RhcnQpLCAnfHwnLCByZXN1bHQsIHJpZ2h0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgICBfUGFyc2VBU1QucHJvdG90eXBlLnBhcnNlTG9naWNhbEFuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvLyAnJiYnXG4gICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMucGFyc2VFcXVhbGl0eSgpO1xuICAgICAgICAgIHdoaWxlICh0aGlzLm9wdGlvbmFsT3BlcmF0b3IoJyYmJykpIHtcbiAgICAgICAgICAgICAgdmFyIHJpZ2h0ID0gdGhpcy5wYXJzZUVxdWFsaXR5KCk7XG4gICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBCaW5hcnkodGhpcy5zcGFuKHJlc3VsdC5zcGFuLnN0YXJ0KSwgJyYmJywgcmVzdWx0LCByaWdodCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgICAgX1BhcnNlQVNULnByb3RvdHlwZS5wYXJzZUVxdWFsaXR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8vICc9PScsJyE9JywnPT09JywnIT09J1xuICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLnBhcnNlUmVsYXRpb25hbCgpO1xuICAgICAgICAgIHdoaWxlICh0aGlzLm5leHQudHlwZSA9PSBleHBvcnRzLlRva2VuVHlwZS5PcGVyYXRvcikge1xuICAgICAgICAgICAgICB2YXIgb3BlcmF0b3IgPSB0aGlzLm5leHQuc3RyVmFsdWU7XG4gICAgICAgICAgICAgIHN3aXRjaCAob3BlcmF0b3IpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgJz09JzpcbiAgICAgICAgICAgICAgICAgIGNhc2UgJz09PSc6XG4gICAgICAgICAgICAgICAgICBjYXNlICchPSc6XG4gICAgICAgICAgICAgICAgICBjYXNlICchPT0nOlxuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgICAgICAgICAgIHZhciByaWdodCA9IHRoaXMucGFyc2VSZWxhdGlvbmFsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IEJpbmFyeSh0aGlzLnNwYW4ocmVzdWx0LnNwYW4uc3RhcnQpLCBvcGVyYXRvciwgcmVzdWx0LCByaWdodCk7XG4gICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgICAgX1BhcnNlQVNULnByb3RvdHlwZS5wYXJzZVJlbGF0aW9uYWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgLy8gJzwnLCAnPicsICc8PScsICc+PSdcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5wYXJzZUFkZGl0aXZlKCk7XG4gICAgICAgICAgd2hpbGUgKHRoaXMubmV4dC50eXBlID09IGV4cG9ydHMuVG9rZW5UeXBlLk9wZXJhdG9yKSB7XG4gICAgICAgICAgICAgIHZhciBvcGVyYXRvciA9IHRoaXMubmV4dC5zdHJWYWx1ZTtcbiAgICAgICAgICAgICAgc3dpdGNoIChvcGVyYXRvcikge1xuICAgICAgICAgICAgICAgICAgY2FzZSAnPCc6XG4gICAgICAgICAgICAgICAgICBjYXNlICc+JzpcbiAgICAgICAgICAgICAgICAgIGNhc2UgJzw9JzpcbiAgICAgICAgICAgICAgICAgIGNhc2UgJz49JzpcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgcmlnaHQgPSB0aGlzLnBhcnNlQWRkaXRpdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgQmluYXJ5KHRoaXMuc3BhbihyZXN1bHQuc3Bhbi5zdGFydCksIG9wZXJhdG9yLCByZXN1bHQsIHJpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgICBfUGFyc2VBU1QucHJvdG90eXBlLnBhcnNlQWRkaXRpdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgLy8gJysnLCAnLSdcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5wYXJzZU11bHRpcGxpY2F0aXZlKCk7XG4gICAgICAgICAgd2hpbGUgKHRoaXMubmV4dC50eXBlID09IGV4cG9ydHMuVG9rZW5UeXBlLk9wZXJhdG9yKSB7XG4gICAgICAgICAgICAgIHZhciBvcGVyYXRvciA9IHRoaXMubmV4dC5zdHJWYWx1ZTtcbiAgICAgICAgICAgICAgc3dpdGNoIChvcGVyYXRvcikge1xuICAgICAgICAgICAgICAgICAgY2FzZSAnKyc6XG4gICAgICAgICAgICAgICAgICBjYXNlICctJzpcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgcmlnaHQgPSB0aGlzLnBhcnNlTXVsdGlwbGljYXRpdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgQmluYXJ5KHRoaXMuc3BhbihyZXN1bHQuc3Bhbi5zdGFydCksIG9wZXJhdG9yLCByZXN1bHQsIHJpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgICBfUGFyc2VBU1QucHJvdG90eXBlLnBhcnNlTXVsdGlwbGljYXRpdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgLy8gJyonLCAnJScsICcvJ1xuICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLnBhcnNlUHJlZml4KCk7XG4gICAgICAgICAgd2hpbGUgKHRoaXMubmV4dC50eXBlID09IGV4cG9ydHMuVG9rZW5UeXBlLk9wZXJhdG9yKSB7XG4gICAgICAgICAgICAgIHZhciBvcGVyYXRvciA9IHRoaXMubmV4dC5zdHJWYWx1ZTtcbiAgICAgICAgICAgICAgc3dpdGNoIChvcGVyYXRvcikge1xuICAgICAgICAgICAgICAgICAgY2FzZSAnKic6XG4gICAgICAgICAgICAgICAgICBjYXNlICclJzpcbiAgICAgICAgICAgICAgICAgIGNhc2UgJy8nOlxuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgICAgICAgICAgIHZhciByaWdodCA9IHRoaXMucGFyc2VQcmVmaXgoKTtcbiAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgQmluYXJ5KHRoaXMuc3BhbihyZXN1bHQuc3Bhbi5zdGFydCksIG9wZXJhdG9yLCByZXN1bHQsIHJpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgICBfUGFyc2VBU1QucHJvdG90eXBlLnBhcnNlUHJlZml4ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmICh0aGlzLm5leHQudHlwZSA9PSBleHBvcnRzLlRva2VuVHlwZS5PcGVyYXRvcikge1xuICAgICAgICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLmlucHV0SW5kZXg7XG4gICAgICAgICAgICAgIHZhciBvcGVyYXRvciA9IHRoaXMubmV4dC5zdHJWYWx1ZTtcbiAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgc3dpdGNoIChvcGVyYXRvcikge1xuICAgICAgICAgICAgICAgICAgY2FzZSAnKyc6XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VQcmVmaXgoKTtcbiAgICAgICAgICAgICAgICAgIGNhc2UgJy0nOlxuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMucGFyc2VQcmVmaXgoKTtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJpbmFyeSh0aGlzLnNwYW4oc3RhcnQpLCBvcGVyYXRvciwgbmV3IExpdGVyYWxQcmltaXRpdmUobmV3IFBhcnNlU3BhbihzdGFydCwgc3RhcnQpLCAwKSwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgIGNhc2UgJyEnOlxuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMucGFyc2VQcmVmaXgoKTtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByZWZpeE5vdCh0aGlzLnNwYW4oc3RhcnQpLCByZXN1bHQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlQ2FsbENoYWluKCk7XG4gICAgICB9O1xuICAgICAgX1BhcnNlQVNULnByb3RvdHlwZS5wYXJzZUNhbGxDaGFpbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5wYXJzZVByaW1hcnkoKTtcbiAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25hbENoYXJhY3RlcigkUEVSSU9EKSkge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5wYXJzZUFjY2Vzc01lbWJlck9yTWV0aG9kQ2FsbChyZXN1bHQsIGZhbHNlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLm9wdGlvbmFsT3BlcmF0b3IoJz8uJykpIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMucGFyc2VBY2Nlc3NNZW1iZXJPck1ldGhvZENhbGwocmVzdWx0LCB0cnVlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLm9wdGlvbmFsQ2hhcmFjdGVyKCRMQlJBQ0tFVCkpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMucmJyYWNrZXRzRXhwZWN0ZWQrKztcbiAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSB0aGlzLnBhcnNlUGlwZSgpO1xuICAgICAgICAgICAgICAgICAgdGhpcy5yYnJhY2tldHNFeHBlY3RlZC0tO1xuICAgICAgICAgICAgICAgICAgdGhpcy5leHBlY3RDaGFyYWN0ZXIoJFJCUkFDS0VUKTtcbiAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbmFsT3BlcmF0b3IoJz0nKSkge1xuICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMucGFyc2VDb25kaXRpb25hbCgpO1xuICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBLZXllZFdyaXRlKHRoaXMuc3BhbihyZXN1bHQuc3Bhbi5zdGFydCksIHJlc3VsdCwga2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgS2V5ZWRSZWFkKHRoaXMuc3BhbihyZXN1bHQuc3Bhbi5zdGFydCksIHJlc3VsdCwga2V5KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLm9wdGlvbmFsQ2hhcmFjdGVyKCRMUEFSRU4pKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLnJwYXJlbnNFeHBlY3RlZCsrO1xuICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSB0aGlzLnBhcnNlQ2FsbEFyZ3VtZW50cygpO1xuICAgICAgICAgICAgICAgICAgdGhpcy5ycGFyZW5zRXhwZWN0ZWQtLTtcbiAgICAgICAgICAgICAgICAgIHRoaXMuZXhwZWN0Q2hhcmFjdGVyKCRSUEFSRU4pO1xuICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IEZ1bmN0aW9uQ2FsbCh0aGlzLnNwYW4ocmVzdWx0LnNwYW4uc3RhcnQpLCByZXN1bHQsIGFyZ3MpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICBfUGFyc2VBU1QucHJvdG90eXBlLnBhcnNlUHJpbWFyeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLmlucHV0SW5kZXg7XG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9uYWxDaGFyYWN0ZXIoJExQQVJFTikpIHtcbiAgICAgICAgICAgICAgdGhpcy5ycGFyZW5zRXhwZWN0ZWQrKztcbiAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMucGFyc2VQaXBlKCk7XG4gICAgICAgICAgICAgIHRoaXMucnBhcmVuc0V4cGVjdGVkLS07XG4gICAgICAgICAgICAgIHRoaXMuZXhwZWN0Q2hhcmFjdGVyKCRSUEFSRU4pO1xuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmICh0aGlzLm5leHQuaXNLZXl3b3JkTnVsbCgpKSB7XG4gICAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgICByZXR1cm4gbmV3IExpdGVyYWxQcmltaXRpdmUodGhpcy5zcGFuKHN0YXJ0KSwgbnVsbCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKHRoaXMubmV4dC5pc0tleXdvcmRVbmRlZmluZWQoKSkge1xuICAgICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBMaXRlcmFsUHJpbWl0aXZlKHRoaXMuc3BhbihzdGFydCksIHZvaWQgMCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKHRoaXMubmV4dC5pc0tleXdvcmRUcnVlKCkpIHtcbiAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgTGl0ZXJhbFByaW1pdGl2ZSh0aGlzLnNwYW4oc3RhcnQpLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAodGhpcy5uZXh0LmlzS2V5d29yZEZhbHNlKCkpIHtcbiAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgTGl0ZXJhbFByaW1pdGl2ZSh0aGlzLnNwYW4oc3RhcnQpLCBmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKHRoaXMubmV4dC5pc0tleXdvcmRUaGlzKCkpIHtcbiAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgSW1wbGljaXRSZWNlaXZlcih0aGlzLnNwYW4oc3RhcnQpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAodGhpcy5vcHRpb25hbENoYXJhY3RlcigkTEJSQUNLRVQpKSB7XG4gICAgICAgICAgICAgIHRoaXMucmJyYWNrZXRzRXhwZWN0ZWQrKztcbiAgICAgICAgICAgICAgdmFyIGVsZW1lbnRzID0gdGhpcy5wYXJzZUV4cHJlc3Npb25MaXN0KCRSQlJBQ0tFVCk7XG4gICAgICAgICAgICAgIHRoaXMucmJyYWNrZXRzRXhwZWN0ZWQtLTtcbiAgICAgICAgICAgICAgdGhpcy5leHBlY3RDaGFyYWN0ZXIoJFJCUkFDS0VUKTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBMaXRlcmFsQXJyYXkodGhpcy5zcGFuKHN0YXJ0KSwgZWxlbWVudHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmICh0aGlzLm5leHQuaXNDaGFyYWN0ZXIoJExCUkFDRSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VMaXRlcmFsTWFwKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKHRoaXMubmV4dC5pc0lkZW50aWZpZXIoKSkge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUFjY2Vzc01lbWJlck9yTWV0aG9kQ2FsbChuZXcgSW1wbGljaXRSZWNlaXZlcih0aGlzLnNwYW4oc3RhcnQpKSwgZmFsc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmICh0aGlzLm5leHQuaXNOdW1iZXIoKSkge1xuICAgICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLm5leHQudG9OdW1iZXIoKTtcbiAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgTGl0ZXJhbFByaW1pdGl2ZSh0aGlzLnNwYW4oc3RhcnQpLCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKHRoaXMubmV4dC5pc1N0cmluZygpKSB7XG4gICAgICAgICAgICAgIHZhciBsaXRlcmFsVmFsdWUgPSB0aGlzLm5leHQudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgTGl0ZXJhbFByaW1pdGl2ZSh0aGlzLnNwYW4oc3RhcnQpLCBsaXRlcmFsVmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmICh0aGlzLmluZGV4ID49IHRoaXMudG9rZW5zLmxlbmd0aCkge1xuICAgICAgICAgICAgICB0aGlzLmVycm9yKFwiVW5leHBlY3RlZCBlbmQgb2YgZXhwcmVzc2lvbjogXCIgKyB0aGlzLmlucHV0KTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBFbXB0eUV4cHIodGhpcy5zcGFuKHN0YXJ0KSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLmVycm9yKFwiVW5leHBlY3RlZCB0b2tlbiBcIiArIHRoaXMubmV4dCk7XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgRW1wdHlFeHByKHRoaXMuc3BhbihzdGFydCkpO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICBfUGFyc2VBU1QucHJvdG90eXBlLnBhcnNlRXhwcmVzc2lvbkxpc3QgPSBmdW5jdGlvbiAodGVybWluYXRvcikge1xuICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgICBpZiAoIXRoaXMubmV4dC5pc0NoYXJhY3Rlcih0ZXJtaW5hdG9yKSkge1xuICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLnBhcnNlUGlwZSgpKTtcbiAgICAgICAgICAgICAgfSB3aGlsZSAodGhpcy5vcHRpb25hbENoYXJhY3RlcigkQ09NTUEpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgICBfUGFyc2VBU1QucHJvdG90eXBlLnBhcnNlTGl0ZXJhbE1hcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIga2V5cyA9IFtdO1xuICAgICAgICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLmlucHV0SW5kZXg7XG4gICAgICAgICAgdGhpcy5leHBlY3RDaGFyYWN0ZXIoJExCUkFDRSk7XG4gICAgICAgICAgaWYgKCF0aGlzLm9wdGlvbmFsQ2hhcmFjdGVyKCRSQlJBQ0UpKSB7XG4gICAgICAgICAgICAgIHRoaXMucmJyYWNlc0V4cGVjdGVkKys7XG4gICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSB0aGlzLmV4cGVjdElkZW50aWZpZXJPcktleXdvcmRPclN0cmluZygpO1xuICAgICAgICAgICAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgICAgICAgICB0aGlzLmV4cGVjdENoYXJhY3RlcigkQ09MT04pO1xuICAgICAgICAgICAgICAgICAgdmFsdWVzLnB1c2godGhpcy5wYXJzZVBpcGUoKSk7XG4gICAgICAgICAgICAgIH0gd2hpbGUgKHRoaXMub3B0aW9uYWxDaGFyYWN0ZXIoJENPTU1BKSk7XG4gICAgICAgICAgICAgIHRoaXMucmJyYWNlc0V4cGVjdGVkLS07XG4gICAgICAgICAgICAgIHRoaXMuZXhwZWN0Q2hhcmFjdGVyKCRSQlJBQ0UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3IExpdGVyYWxNYXAodGhpcy5zcGFuKHN0YXJ0KSwga2V5cywgdmFsdWVzKTtcbiAgICAgIH07XG4gICAgICBfUGFyc2VBU1QucHJvdG90eXBlLnBhcnNlQWNjZXNzTWVtYmVyT3JNZXRob2RDYWxsID0gZnVuY3Rpb24gKHJlY2VpdmVyLCBpc1NhZmUpIHtcbiAgICAgICAgICBpZiAoaXNTYWZlID09PSB2b2lkIDApIHsgaXNTYWZlID0gZmFsc2U7IH1cbiAgICAgICAgICB2YXIgc3RhcnQgPSByZWNlaXZlci5zcGFuLnN0YXJ0O1xuICAgICAgICAgIHZhciBpZCA9IHRoaXMuZXhwZWN0SWRlbnRpZmllck9yS2V5d29yZCgpO1xuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbmFsQ2hhcmFjdGVyKCRMUEFSRU4pKSB7XG4gICAgICAgICAgICAgIHRoaXMucnBhcmVuc0V4cGVjdGVkKys7XG4gICAgICAgICAgICAgIHZhciBhcmdzID0gdGhpcy5wYXJzZUNhbGxBcmd1bWVudHMoKTtcbiAgICAgICAgICAgICAgdGhpcy5leHBlY3RDaGFyYWN0ZXIoJFJQQVJFTik7XG4gICAgICAgICAgICAgIHRoaXMucnBhcmVuc0V4cGVjdGVkLS07XG4gICAgICAgICAgICAgIHZhciBzcGFuID0gdGhpcy5zcGFuKHN0YXJ0KTtcbiAgICAgICAgICAgICAgcmV0dXJuIGlzU2FmZSA/IG5ldyBTYWZlTWV0aG9kQ2FsbChzcGFuLCByZWNlaXZlciwgaWQsIGFyZ3MpIDpcbiAgICAgICAgICAgICAgICAgIG5ldyBNZXRob2RDYWxsKHNwYW4sIHJlY2VpdmVyLCBpZCwgYXJncyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoaXNTYWZlKSB7XG4gICAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25hbE9wZXJhdG9yKCc9JykpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVycm9yKCdUaGUgXFwnPy5cXCcgb3BlcmF0b3IgY2Fubm90IGJlIHVzZWQgaW4gdGhlIGFzc2lnbm1lbnQnKTtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEVtcHR5RXhwcih0aGlzLnNwYW4oc3RhcnQpKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU2FmZVByb3BlcnR5UmVhZCh0aGlzLnNwYW4oc3RhcnQpLCByZWNlaXZlciwgaWQpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9uYWxPcGVyYXRvcignPScpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnBhcnNlQWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IoJ0JpbmRpbmdzIGNhbm5vdCBjb250YWluIGFzc2lnbm1lbnRzJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRW1wdHlFeHByKHRoaXMuc3BhbihzdGFydCkpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLnBhcnNlQ29uZGl0aW9uYWwoKTtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb3BlcnR5V3JpdGUodGhpcy5zcGFuKHN0YXJ0KSwgcmVjZWl2ZXIsIGlkLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb3BlcnR5UmVhZCh0aGlzLnNwYW4oc3RhcnQpLCByZWNlaXZlciwgaWQpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIF9QYXJzZUFTVC5wcm90b3R5cGUucGFyc2VDYWxsQXJndW1lbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmICh0aGlzLm5leHQuaXNDaGFyYWN0ZXIoJFJQQVJFTikpXG4gICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICB2YXIgcG9zaXRpb25hbHMgPSBbXTtcbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgIHBvc2l0aW9uYWxzLnB1c2godGhpcy5wYXJzZVBpcGUoKSk7XG4gICAgICAgICAgfSB3aGlsZSAodGhpcy5vcHRpb25hbENoYXJhY3RlcigkQ09NTUEpKTtcbiAgICAgICAgICByZXR1cm4gcG9zaXRpb25hbHM7XG4gICAgICB9O1xuICAgICAgLyoqXG4gICAgICAgKiBBbiBpZGVudGlmaWVyLCBhIGtleXdvcmQsIGEgc3RyaW5nIHdpdGggYW4gb3B0aW9uYWwgYC1gIGluYmV0d2Vlbi5cbiAgICAgICAqL1xuICAgICAgX1BhcnNlQVNULnByb3RvdHlwZS5leHBlY3RUZW1wbGF0ZUJpbmRpbmdLZXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgICAgICAgIHZhciBvcGVyYXRvckZvdW5kID0gZmFsc2U7XG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICByZXN1bHQgKz0gdGhpcy5leHBlY3RJZGVudGlmaWVyT3JLZXl3b3JkT3JTdHJpbmcoKTtcbiAgICAgICAgICAgICAgb3BlcmF0b3JGb3VuZCA9IHRoaXMub3B0aW9uYWxPcGVyYXRvcignLScpO1xuICAgICAgICAgICAgICBpZiAob3BlcmF0b3JGb3VuZCkge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9ICctJztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0gd2hpbGUgKG9wZXJhdG9yRm91bmQpO1xuICAgICAgICAgIHJldHVybiByZXN1bHQudG9TdHJpbmcoKTtcbiAgICAgIH07XG4gICAgICBfUGFyc2VBU1QucHJvdG90eXBlLnBhcnNlVGVtcGxhdGVCaW5kaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgYmluZGluZ3MgPSBbXTtcbiAgICAgICAgICB2YXIgcHJlZml4ID0gbnVsbDtcbiAgICAgICAgICB2YXIgd2FybmluZ3MgPSBbXTtcbiAgICAgICAgICB3aGlsZSAodGhpcy5pbmRleCA8IHRoaXMudG9rZW5zLmxlbmd0aCkge1xuICAgICAgICAgICAgICB2YXIga2V5SXNWYXIgPSB0aGlzLnBlZWtLZXl3b3JkTGV0KCk7XG4gICAgICAgICAgICAgIGlmIChrZXlJc1Zhcikge1xuICAgICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFyIGtleSA9IHRoaXMuZXhwZWN0VGVtcGxhdGVCaW5kaW5nS2V5KCk7XG4gICAgICAgICAgICAgIGlmICgha2V5SXNWYXIpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChwcmVmaXggPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgIHByZWZpeCA9IGtleTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIGtleSA9IHByZWZpeCArIGtleVswXS50b1VwcGVyQ2FzZSgpICsga2V5LnN1YnN0cmluZygxKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aGlzLm9wdGlvbmFsQ2hhcmFjdGVyKCRDT0xPTik7XG4gICAgICAgICAgICAgIHZhciBuYW1lID0gbnVsbDtcbiAgICAgICAgICAgICAgdmFyIGV4cHJlc3Npb24gPSBudWxsO1xuICAgICAgICAgICAgICBpZiAoa2V5SXNWYXIpIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbmFsT3BlcmF0b3IoJz0nKSkge1xuICAgICAgICAgICAgICAgICAgICAgIG5hbWUgPSB0aGlzLmV4cGVjdFRlbXBsYXRlQmluZGluZ0tleSgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgbmFtZSA9ICdcXCRpbXBsaWNpdCc7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5uZXh0ICE9PSBFT0YgJiYgIXRoaXMucGVla0tleXdvcmRMZXQoKSkge1xuICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5pbnB1dEluZGV4O1xuICAgICAgICAgICAgICAgICAgdmFyIGFzdCA9IHRoaXMucGFyc2VQaXBlKCk7XG4gICAgICAgICAgICAgICAgICB2YXIgc291cmNlID0gdGhpcy5pbnB1dC5zdWJzdHJpbmcoc3RhcnQsIHRoaXMuaW5wdXRJbmRleCk7XG4gICAgICAgICAgICAgICAgICBleHByZXNzaW9uID0gbmV3IEFTVFdpdGhTb3VyY2UoYXN0LCBzb3VyY2UsIHRoaXMubG9jYXRpb24sIHRoaXMuZXJyb3JzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBiaW5kaW5ncy5wdXNoKG5ldyBUZW1wbGF0ZUJpbmRpbmcoa2V5LCBrZXlJc1ZhciwgbmFtZSwgZXhwcmVzc2lvbikpO1xuICAgICAgICAgICAgICBpZiAoIXRoaXMub3B0aW9uYWxDaGFyYWN0ZXIoJFNFTUlDT0xPTikpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9uYWxDaGFyYWN0ZXIoJENPTU1BKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3IFRlbXBsYXRlQmluZGluZ1BhcnNlUmVzdWx0KGJpbmRpbmdzLCB3YXJuaW5ncywgdGhpcy5lcnJvcnMpO1xuICAgICAgfTtcbiAgICAgIF9QYXJzZUFTVC5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAobWVzc2FnZSwgaW5kZXgpIHtcbiAgICAgICAgICBpZiAoaW5kZXggPT09IHZvaWQgMCkgeyBpbmRleCA9IG51bGw7IH1cbiAgICAgICAgICB0aGlzLmVycm9ycy5wdXNoKG5ldyBQYXJzZXJFcnJvcihtZXNzYWdlLCB0aGlzLmlucHV0LCB0aGlzLmxvY2F0aW9uVGV4dChpbmRleCksIHRoaXMubG9jYXRpb24pKTtcbiAgICAgICAgICB0aGlzLnNraXAoKTtcbiAgICAgIH07XG4gICAgICBfUGFyc2VBU1QucHJvdG90eXBlLmxvY2F0aW9uVGV4dCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgIGlmIChpbmRleCA9PT0gdm9pZCAwKSB7IGluZGV4ID0gbnVsbDsgfVxuICAgICAgICAgIGlmIChpc0JsYW5rKGluZGV4KSlcbiAgICAgICAgICAgICAgaW5kZXggPSB0aGlzLmluZGV4O1xuICAgICAgICAgIHJldHVybiAoaW5kZXggPCB0aGlzLnRva2Vucy5sZW5ndGgpID8gXCJhdCBjb2x1bW4gXCIgKyAodGhpcy50b2tlbnNbaW5kZXhdLmluZGV4ICsgMSkgKyBcIiBpblwiIDpcbiAgICAgICAgICAgICAgXCJhdCB0aGUgZW5kIG9mIHRoZSBleHByZXNzaW9uXCI7XG4gICAgICB9O1xuICAgICAgLy8gRXJyb3IgcmVjb3Zlcnkgc2hvdWxkIHNraXAgdG9rZW5zIHVudGlsIGl0IGVuY291bnRlcnMgYSByZWNvdmVyeSBwb2ludC4gc2tpcCgpIHRyZWF0c1xuICAgICAgLy8gdGhlIGVuZCBvZiBpbnB1dCBhbmQgYSAnOycgYXMgdW5jb25kaXRpb25hbGx5IGEgcmVjb3ZlcnkgcG9pbnQuIEl0IGFsc28gdHJlYXRzICcpJyxcbiAgICAgIC8vICd9JyBhbmQgJ10nIGFzIGNvbmRpdGlvbmFsIHJlY292ZXJ5IHBvaW50cyBpZiBvbmUgb2YgY2FsbGluZyBwcm9kdWN0aW9ucyBpcyBleHBlY3RpbmdcbiAgICAgIC8vIG9uZSBvZiB0aGVzZSBzeW1ib2xzLiBUaGlzIGFsbG93cyBza2lwKCkgdG8gcmVjb3ZlciBmcm9tIGVycm9ycyBzdWNoIGFzICcoYS4pICsgMScgYWxsb3dpbmdcbiAgICAgIC8vIG1vcmUgb2YgdGhlIEFTVCB0byBiZSByZXRhaW5lZCAoaXQgZG9lc24ndCBza2lwIGFueSB0b2tlbnMgYXMgdGhlICcpJyBpcyByZXRhaW5lZCBiZWNhdXNlXG4gICAgICAvLyBvZiB0aGUgJygnIGJlZ2lucyBhbiAnKCcgPGV4cHI+ICcpJyBwcm9kdWN0aW9uKS4gVGhlIHJlY292ZXJ5IHBvaW50cyBvZiBncm91cGluZyBzeW1ib2xzXG4gICAgICAvLyBtdXN0IGJlIGNvbmRpdGlvbmFsIGFzIHRoZXkgbXVzdCBiZSBza2lwcGVkIGlmIG5vbmUgb2YgdGhlIGNhbGxpbmcgcHJvZHVjdGlvbnMgYXJlIG5vdFxuICAgICAgLy8gZXhwZWN0aW5nIHRoZSBjbG9zaW5nIHRva2VuIGVsc2Ugd2Ugd2lsbCBuZXZlciBtYWtlIHByb2dyZXNzIGluIHRoZSBjYXNlIG9mIGFuXG4gICAgICAvLyBleHRyYW5lb3VzIGdyb3VwIGNsb3Npbmcgc3ltYm9sIChzdWNoIGFzIGEgc3RyYXkgJyknKS4gVGhpcyBpcyBub3QgdGhlIGNhc2UgZm9yICc7JyBiZWNhdXNlXG4gICAgICAvLyBwYXJzZUNoYWluKCkgaXMgYWx3YXlzIHRoZSByb290IHByb2R1Y3Rpb24gYW5kIGl0IGV4cGVjdHMgYSAnOycuXG4gICAgICAvLyBJZiBhIHByb2R1Y3Rpb24gZXhwZWN0cyBvbmUgb2YgdGhlc2UgdG9rZW4gaXQgaW5jcmVtZW50cyB0aGUgY29ycmVzcG9uZGluZyBuZXN0aW5nIGNvdW50LFxuICAgICAgLy8gYW5kIHRoZW4gZGVjcmVtZW50cyBpdCBqdXN0IHByaW9yIHRvIGNoZWNraW5nIGlmIHRoZSB0b2tlbiBpcyBpbiB0aGUgaW5wdXQuXG4gICAgICBfUGFyc2VBU1QucHJvdG90eXBlLnNraXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIG4gPSB0aGlzLm5leHQ7XG4gICAgICAgICAgd2hpbGUgKHRoaXMuaW5kZXggPCB0aGlzLnRva2Vucy5sZW5ndGggJiYgIW4uaXNDaGFyYWN0ZXIoJFNFTUlDT0xPTikgJiZcbiAgICAgICAgICAgICAgKHRoaXMucnBhcmVuc0V4cGVjdGVkIDw9IDAgfHwgIW4uaXNDaGFyYWN0ZXIoJFJQQVJFTikpICYmXG4gICAgICAgICAgICAgICh0aGlzLnJicmFjZXNFeHBlY3RlZCA8PSAwIHx8ICFuLmlzQ2hhcmFjdGVyKCRSQlJBQ0UpKSAmJlxuICAgICAgICAgICAgICAodGhpcy5yYnJhY2tldHNFeHBlY3RlZCA8PSAwIHx8ICFuLmlzQ2hhcmFjdGVyKCRSQlJBQ0tFVCkpKSB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLm5leHQuaXNFcnJvcigpKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLmVycm9ycy5wdXNoKG5ldyBQYXJzZXJFcnJvcih0aGlzLm5leHQudG9TdHJpbmcoKSwgdGhpcy5pbnB1dCwgdGhpcy5sb2NhdGlvblRleHQoKSwgdGhpcy5sb2NhdGlvbikpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgICBuID0gdGhpcy5uZXh0O1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICByZXR1cm4gX1BhcnNlQVNUO1xuICB9KCkpO1xuICB2YXIgU2ltcGxlRXhwcmVzc2lvbkNoZWNrZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gU2ltcGxlRXhwcmVzc2lvbkNoZWNrZXIoKSB7XG4gICAgICAgICAgdGhpcy5lcnJvcnMgPSBbXTtcbiAgICAgIH1cbiAgICAgIFNpbXBsZUV4cHJlc3Npb25DaGVja2VyLmNoZWNrID0gZnVuY3Rpb24gKGFzdCkge1xuICAgICAgICAgIHZhciBzID0gbmV3IFNpbXBsZUV4cHJlc3Npb25DaGVja2VyKCk7XG4gICAgICAgICAgYXN0LnZpc2l0KHMpO1xuICAgICAgICAgIHJldHVybiBzLmVycm9ycztcbiAgICAgIH07XG4gICAgICBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlci5wcm90b3R5cGUudmlzaXRJbXBsaWNpdFJlY2VpdmVyID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyB9O1xuICAgICAgU2ltcGxlRXhwcmVzc2lvbkNoZWNrZXIucHJvdG90eXBlLnZpc2l0SW50ZXJwb2xhdGlvbiA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgfTtcbiAgICAgIFNpbXBsZUV4cHJlc3Npb25DaGVja2VyLnByb3RvdHlwZS52aXNpdExpdGVyYWxQcmltaXRpdmUgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IH07XG4gICAgICBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlci5wcm90b3R5cGUudmlzaXRQcm9wZXJ0eVJlYWQgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IH07XG4gICAgICBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlci5wcm90b3R5cGUudmlzaXRQcm9wZXJ0eVdyaXRlID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyB9O1xuICAgICAgU2ltcGxlRXhwcmVzc2lvbkNoZWNrZXIucHJvdG90eXBlLnZpc2l0U2FmZVByb3BlcnR5UmVhZCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgfTtcbiAgICAgIFNpbXBsZUV4cHJlc3Npb25DaGVja2VyLnByb3RvdHlwZS52aXNpdE1ldGhvZENhbGwgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IH07XG4gICAgICBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlci5wcm90b3R5cGUudmlzaXRTYWZlTWV0aG9kQ2FsbCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgfTtcbiAgICAgIFNpbXBsZUV4cHJlc3Npb25DaGVja2VyLnByb3RvdHlwZS52aXNpdEZ1bmN0aW9uQ2FsbCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgfTtcbiAgICAgIFNpbXBsZUV4cHJlc3Npb25DaGVja2VyLnByb3RvdHlwZS52aXNpdExpdGVyYWxBcnJheSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgdGhpcy52aXNpdEFsbChhc3QuZXhwcmVzc2lvbnMpOyB9O1xuICAgICAgU2ltcGxlRXhwcmVzc2lvbkNoZWNrZXIucHJvdG90eXBlLnZpc2l0TGl0ZXJhbE1hcCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgdGhpcy52aXNpdEFsbChhc3QudmFsdWVzKTsgfTtcbiAgICAgIFNpbXBsZUV4cHJlc3Npb25DaGVja2VyLnByb3RvdHlwZS52aXNpdEJpbmFyeSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgfTtcbiAgICAgIFNpbXBsZUV4cHJlc3Npb25DaGVja2VyLnByb3RvdHlwZS52aXNpdFByZWZpeE5vdCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgfTtcbiAgICAgIFNpbXBsZUV4cHJlc3Npb25DaGVja2VyLnByb3RvdHlwZS52aXNpdENvbmRpdGlvbmFsID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyB9O1xuICAgICAgU2ltcGxlRXhwcmVzc2lvbkNoZWNrZXIucHJvdG90eXBlLnZpc2l0UGlwZSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgdGhpcy5lcnJvcnMucHVzaCgncGlwZXMnKTsgfTtcbiAgICAgIFNpbXBsZUV4cHJlc3Npb25DaGVja2VyLnByb3RvdHlwZS52aXNpdEtleWVkUmVhZCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgfTtcbiAgICAgIFNpbXBsZUV4cHJlc3Npb25DaGVja2VyLnByb3RvdHlwZS52aXNpdEtleWVkV3JpdGUgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IH07XG4gICAgICBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlci5wcm90b3R5cGUudmlzaXRBbGwgPSBmdW5jdGlvbiAoYXN0cykge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgcmV0dXJuIGFzdHMubWFwKGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBub2RlLnZpc2l0KF90aGlzKTsgfSk7XG4gICAgICB9O1xuICAgICAgU2ltcGxlRXhwcmVzc2lvbkNoZWNrZXIucHJvdG90eXBlLnZpc2l0Q2hhaW4gPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IH07XG4gICAgICBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlci5wcm90b3R5cGUudmlzaXRRdW90ZSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgfTtcbiAgICAgIHJldHVybiBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlcjtcbiAgfSgpKTtcblxuICB2YXIgUGFyc2VMb2NhdGlvbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBQYXJzZUxvY2F0aW9uKGZpbGUsIG9mZnNldCwgbGluZSwgY29sKSB7XG4gICAgICAgICAgdGhpcy5maWxlID0gZmlsZTtcbiAgICAgICAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgICB0aGlzLmxpbmUgPSBsaW5lO1xuICAgICAgICAgIHRoaXMuY29sID0gY29sO1xuICAgICAgfVxuICAgICAgUGFyc2VMb2NhdGlvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGlzUHJlc2VudCh0aGlzLm9mZnNldCkgPyB0aGlzLmZpbGUudXJsICsgXCJAXCIgKyB0aGlzLmxpbmUgKyBcIjpcIiArIHRoaXMuY29sIDogdGhpcy5maWxlLnVybDtcbiAgICAgIH07XG4gICAgICByZXR1cm4gUGFyc2VMb2NhdGlvbjtcbiAgfSgpKTtcbiAgdmFyIFBhcnNlU291cmNlRmlsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBQYXJzZVNvdXJjZUZpbGUoY29udGVudCwgdXJsKSB7XG4gICAgICAgICAgdGhpcy5jb250ZW50ID0gY29udGVudDtcbiAgICAgICAgICB0aGlzLnVybCA9IHVybDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBQYXJzZVNvdXJjZUZpbGU7XG4gIH0oKSk7XG4gIHZhciBQYXJzZVNvdXJjZVNwYW4gPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gUGFyc2VTb3VyY2VTcGFuKHN0YXJ0LCBlbmQsIGRldGFpbHMpIHtcbiAgICAgICAgICBpZiAoZGV0YWlscyA9PT0gdm9pZCAwKSB7IGRldGFpbHMgPSBudWxsOyB9XG4gICAgICAgICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xuICAgICAgICAgIHRoaXMuZW5kID0gZW5kO1xuICAgICAgICAgIHRoaXMuZGV0YWlscyA9IGRldGFpbHM7XG4gICAgICB9XG4gICAgICBQYXJzZVNvdXJjZVNwYW4ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnN0YXJ0LmZpbGUuY29udGVudC5zdWJzdHJpbmcodGhpcy5zdGFydC5vZmZzZXQsIHRoaXMuZW5kLm9mZnNldCk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIFBhcnNlU291cmNlU3BhbjtcbiAgfSgpKTtcbiAgZXhwb3J0cy5QYXJzZUVycm9yTGV2ZWw7XG4gIChmdW5jdGlvbiAoUGFyc2VFcnJvckxldmVsKSB7XG4gICAgICBQYXJzZUVycm9yTGV2ZWxbUGFyc2VFcnJvckxldmVsW1wiV0FSTklOR1wiXSA9IDBdID0gXCJXQVJOSU5HXCI7XG4gICAgICBQYXJzZUVycm9yTGV2ZWxbUGFyc2VFcnJvckxldmVsW1wiRkFUQUxcIl0gPSAxXSA9IFwiRkFUQUxcIjtcbiAgfSkoZXhwb3J0cy5QYXJzZUVycm9yTGV2ZWwgfHwgKGV4cG9ydHMuUGFyc2VFcnJvckxldmVsID0ge30pKTtcbiAgdmFyIFBhcnNlRXJyb3IgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gUGFyc2VFcnJvcihzcGFuLCBtc2csIGxldmVsKSB7XG4gICAgICAgICAgaWYgKGxldmVsID09PSB2b2lkIDApIHsgbGV2ZWwgPSBleHBvcnRzLlBhcnNlRXJyb3JMZXZlbC5GQVRBTDsgfVxuICAgICAgICAgIHRoaXMuc3BhbiA9IHNwYW47XG4gICAgICAgICAgdGhpcy5tc2cgPSBtc2c7XG4gICAgICAgICAgdGhpcy5sZXZlbCA9IGxldmVsO1xuICAgICAgfVxuICAgICAgUGFyc2VFcnJvci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHNvdXJjZSA9IHRoaXMuc3Bhbi5zdGFydC5maWxlLmNvbnRlbnQ7XG4gICAgICAgICAgdmFyIGN0eFN0YXJ0ID0gdGhpcy5zcGFuLnN0YXJ0Lm9mZnNldDtcbiAgICAgICAgICB2YXIgY29udGV4dFN0ciA9ICcnO1xuICAgICAgICAgIHZhciBkZXRhaWxzID0gJyc7XG4gICAgICAgICAgaWYgKGlzUHJlc2VudChjdHhTdGFydCkpIHtcbiAgICAgICAgICAgICAgaWYgKGN0eFN0YXJ0ID4gc291cmNlLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgIGN0eFN0YXJ0ID0gc291cmNlLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFyIGN0eEVuZCA9IGN0eFN0YXJ0O1xuICAgICAgICAgICAgICB2YXIgY3R4TGVuID0gMDtcbiAgICAgICAgICAgICAgdmFyIGN0eExpbmVzID0gMDtcbiAgICAgICAgICAgICAgd2hpbGUgKGN0eExlbiA8IDEwMCAmJiBjdHhTdGFydCA+IDApIHtcbiAgICAgICAgICAgICAgICAgIGN0eFN0YXJ0LS07XG4gICAgICAgICAgICAgICAgICBjdHhMZW4rKztcbiAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2VbY3R4U3RhcnRdID09ICdcXG4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKCsrY3R4TGluZXMgPT0gMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY3R4TGVuID0gMDtcbiAgICAgICAgICAgICAgY3R4TGluZXMgPSAwO1xuICAgICAgICAgICAgICB3aGlsZSAoY3R4TGVuIDwgMTAwICYmIGN0eEVuZCA8IHNvdXJjZS5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICBjdHhFbmQrKztcbiAgICAgICAgICAgICAgICAgIGN0eExlbisrO1xuICAgICAgICAgICAgICAgICAgaWYgKHNvdXJjZVtjdHhFbmRdID09ICdcXG4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKCsrY3R4TGluZXMgPT0gMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFyIGNvbnRleHQgPSBzb3VyY2Uuc3Vic3RyaW5nKGN0eFN0YXJ0LCB0aGlzLnNwYW4uc3RhcnQub2Zmc2V0KSArICdbRVJST1IgLT5dJyArXG4gICAgICAgICAgICAgICAgICBzb3VyY2Uuc3Vic3RyaW5nKHRoaXMuc3Bhbi5zdGFydC5vZmZzZXQsIGN0eEVuZCArIDEpO1xuICAgICAgICAgICAgICBjb250ZXh0U3RyID0gXCIgKFxcXCJcIiArIGNvbnRleHQgKyBcIlxcXCIpXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLnNwYW4uZGV0YWlscykge1xuICAgICAgICAgICAgICBkZXRhaWxzID0gXCIsIFwiICsgdGhpcy5zcGFuLmRldGFpbHM7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBcIlwiICsgdGhpcy5tc2cgKyBjb250ZXh0U3RyICsgXCI6IFwiICsgdGhpcy5zcGFuLnN0YXJ0ICsgZGV0YWlscztcbiAgICAgIH07XG4gICAgICByZXR1cm4gUGFyc2VFcnJvcjtcbiAgfSgpKTtcblxuICAvKipcbiAgICogQGxpY2Vuc2VcbiAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAqXG4gICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICovXG4gIHZhciBUZXh0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIFRleHQodmFsdWUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICAgIH1cbiAgICAgIFRleHQucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHsgcmV0dXJuIHZpc2l0b3IudmlzaXRUZXh0KHRoaXMsIGNvbnRleHQpOyB9O1xuICAgICAgcmV0dXJuIFRleHQ7XG4gIH0oKSk7XG4gIHZhciBFeHBhbnNpb24gPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gRXhwYW5zaW9uKHN3aXRjaFZhbHVlLCB0eXBlLCBjYXNlcywgc291cmNlU3Bhbiwgc3dpdGNoVmFsdWVTb3VyY2VTcGFuKSB7XG4gICAgICAgICAgdGhpcy5zd2l0Y2hWYWx1ZSA9IHN3aXRjaFZhbHVlO1xuICAgICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgICAgdGhpcy5jYXNlcyA9IGNhc2VzO1xuICAgICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgICAgICAgdGhpcy5zd2l0Y2hWYWx1ZVNvdXJjZVNwYW4gPSBzd2l0Y2hWYWx1ZVNvdXJjZVNwYW47XG4gICAgICB9XG4gICAgICBFeHBhbnNpb24ucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHsgcmV0dXJuIHZpc2l0b3IudmlzaXRFeHBhbnNpb24odGhpcywgY29udGV4dCk7IH07XG4gICAgICByZXR1cm4gRXhwYW5zaW9uO1xuICB9KCkpO1xuICB2YXIgRXhwYW5zaW9uQ2FzZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBFeHBhbnNpb25DYXNlKHZhbHVlLCBleHByZXNzaW9uLCBzb3VyY2VTcGFuLCB2YWx1ZVNvdXJjZVNwYW4sIGV4cFNvdXJjZVNwYW4pIHtcbiAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgdGhpcy5leHByZXNzaW9uID0gZXhwcmVzc2lvbjtcbiAgICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgICAgICAgIHRoaXMudmFsdWVTb3VyY2VTcGFuID0gdmFsdWVTb3VyY2VTcGFuO1xuICAgICAgICAgIHRoaXMuZXhwU291cmNlU3BhbiA9IGV4cFNvdXJjZVNwYW47XG4gICAgICB9XG4gICAgICBFeHBhbnNpb25DYXNlLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7IHJldHVybiB2aXNpdG9yLnZpc2l0RXhwYW5zaW9uQ2FzZSh0aGlzLCBjb250ZXh0KTsgfTtcbiAgICAgIHJldHVybiBFeHBhbnNpb25DYXNlO1xuICB9KCkpO1xuICB2YXIgQXR0cmlidXRlJDEgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gQXR0cmlidXRlKG5hbWUsIHZhbHVlLCBzb3VyY2VTcGFuLCB2YWx1ZVNwYW4pIHtcbiAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgICAgICAgIHRoaXMudmFsdWVTcGFuID0gdmFsdWVTcGFuO1xuICAgICAgfVxuICAgICAgQXR0cmlidXRlLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7IHJldHVybiB2aXNpdG9yLnZpc2l0QXR0cmlidXRlKHRoaXMsIGNvbnRleHQpOyB9O1xuICAgICAgcmV0dXJuIEF0dHJpYnV0ZTtcbiAgfSgpKTtcbiAgdmFyIEVsZW1lbnQgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gRWxlbWVudChuYW1lLCBhdHRycywgY2hpbGRyZW4sIHNvdXJjZVNwYW4sIHN0YXJ0U291cmNlU3BhbiwgZW5kU291cmNlU3Bhbikge1xuICAgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgICAgdGhpcy5hdHRycyA9IGF0dHJzO1xuICAgICAgICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgICAgICAgIHRoaXMuc3RhcnRTb3VyY2VTcGFuID0gc3RhcnRTb3VyY2VTcGFuO1xuICAgICAgICAgIHRoaXMuZW5kU291cmNlU3BhbiA9IGVuZFNvdXJjZVNwYW47XG4gICAgICB9XG4gICAgICBFbGVtZW50LnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7IHJldHVybiB2aXNpdG9yLnZpc2l0RWxlbWVudCh0aGlzLCBjb250ZXh0KTsgfTtcbiAgICAgIHJldHVybiBFbGVtZW50O1xuICB9KCkpO1xuICB2YXIgQ29tbWVudCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBDb21tZW50KHZhbHVlLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgICB9XG4gICAgICBDb21tZW50LnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7IHJldHVybiB2aXNpdG9yLnZpc2l0Q29tbWVudCh0aGlzLCBjb250ZXh0KTsgfTtcbiAgICAgIHJldHVybiBDb21tZW50O1xuICB9KCkpO1xuICBmdW5jdGlvbiB2aXNpdEFsbCh2aXNpdG9yLCBub2RlcywgY29udGV4dCkge1xuICAgICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgeyBjb250ZXh0ID0gbnVsbDsgfVxuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgdmFyIHZpc2l0ID0gdmlzaXRvci52aXNpdCA/XG4gICAgICAgICAgZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gdmlzaXRvci52aXNpdChhc3QsIGNvbnRleHQpIHx8IGFzdC52aXNpdCh2aXNpdG9yLCBjb250ZXh0KTsgfSA6XG4gICAgICAgICAgZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gYXN0LnZpc2l0KHZpc2l0b3IsIGNvbnRleHQpOyB9O1xuICAgICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbiAoYXN0KSB7XG4gICAgICAgICAgdmFyIGFzdFJlc3VsdCA9IHZpc2l0KGFzdCk7XG4gICAgICAgICAgaWYgKGFzdFJlc3VsdCkge1xuICAgICAgICAgICAgICByZXN1bHQucHVzaChhc3RSZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbGljZW5zZVxuICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICpcbiAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgKi9cbiAgdmFyIF9fZXh0ZW5kcyQ0ID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICB9O1xuICB2YXIgVG9rZW5UeXBlJDE7XG4gIChmdW5jdGlvbiAoVG9rZW5UeXBlKSB7XG4gICAgICBUb2tlblR5cGVbVG9rZW5UeXBlW1wiVEFHX09QRU5fU1RBUlRcIl0gPSAwXSA9IFwiVEFHX09QRU5fU1RBUlRcIjtcbiAgICAgIFRva2VuVHlwZVtUb2tlblR5cGVbXCJUQUdfT1BFTl9FTkRcIl0gPSAxXSA9IFwiVEFHX09QRU5fRU5EXCI7XG4gICAgICBUb2tlblR5cGVbVG9rZW5UeXBlW1wiVEFHX09QRU5fRU5EX1ZPSURcIl0gPSAyXSA9IFwiVEFHX09QRU5fRU5EX1ZPSURcIjtcbiAgICAgIFRva2VuVHlwZVtUb2tlblR5cGVbXCJUQUdfQ0xPU0VcIl0gPSAzXSA9IFwiVEFHX0NMT1NFXCI7XG4gICAgICBUb2tlblR5cGVbVG9rZW5UeXBlW1wiVEVYVFwiXSA9IDRdID0gXCJURVhUXCI7XG4gICAgICBUb2tlblR5cGVbVG9rZW5UeXBlW1wiRVNDQVBBQkxFX1JBV19URVhUXCJdID0gNV0gPSBcIkVTQ0FQQUJMRV9SQVdfVEVYVFwiO1xuICAgICAgVG9rZW5UeXBlW1Rva2VuVHlwZVtcIlJBV19URVhUXCJdID0gNl0gPSBcIlJBV19URVhUXCI7XG4gICAgICBUb2tlblR5cGVbVG9rZW5UeXBlW1wiQ09NTUVOVF9TVEFSVFwiXSA9IDddID0gXCJDT01NRU5UX1NUQVJUXCI7XG4gICAgICBUb2tlblR5cGVbVG9rZW5UeXBlW1wiQ09NTUVOVF9FTkRcIl0gPSA4XSA9IFwiQ09NTUVOVF9FTkRcIjtcbiAgICAgIFRva2VuVHlwZVtUb2tlblR5cGVbXCJDREFUQV9TVEFSVFwiXSA9IDldID0gXCJDREFUQV9TVEFSVFwiO1xuICAgICAgVG9rZW5UeXBlW1Rva2VuVHlwZVtcIkNEQVRBX0VORFwiXSA9IDEwXSA9IFwiQ0RBVEFfRU5EXCI7XG4gICAgICBUb2tlblR5cGVbVG9rZW5UeXBlW1wiQVRUUl9OQU1FXCJdID0gMTFdID0gXCJBVFRSX05BTUVcIjtcbiAgICAgIFRva2VuVHlwZVtUb2tlblR5cGVbXCJBVFRSX1ZBTFVFXCJdID0gMTJdID0gXCJBVFRSX1ZBTFVFXCI7XG4gICAgICBUb2tlblR5cGVbVG9rZW5UeXBlW1wiRE9DX1RZUEVcIl0gPSAxM10gPSBcIkRPQ19UWVBFXCI7XG4gICAgICBUb2tlblR5cGVbVG9rZW5UeXBlW1wiRVhQQU5TSU9OX0ZPUk1fU1RBUlRcIl0gPSAxNF0gPSBcIkVYUEFOU0lPTl9GT1JNX1NUQVJUXCI7XG4gICAgICBUb2tlblR5cGVbVG9rZW5UeXBlW1wiRVhQQU5TSU9OX0NBU0VfVkFMVUVcIl0gPSAxNV0gPSBcIkVYUEFOU0lPTl9DQVNFX1ZBTFVFXCI7XG4gICAgICBUb2tlblR5cGVbVG9rZW5UeXBlW1wiRVhQQU5TSU9OX0NBU0VfRVhQX1NUQVJUXCJdID0gMTZdID0gXCJFWFBBTlNJT05fQ0FTRV9FWFBfU1RBUlRcIjtcbiAgICAgIFRva2VuVHlwZVtUb2tlblR5cGVbXCJFWFBBTlNJT05fQ0FTRV9FWFBfRU5EXCJdID0gMTddID0gXCJFWFBBTlNJT05fQ0FTRV9FWFBfRU5EXCI7XG4gICAgICBUb2tlblR5cGVbVG9rZW5UeXBlW1wiRVhQQU5TSU9OX0ZPUk1fRU5EXCJdID0gMThdID0gXCJFWFBBTlNJT05fRk9STV9FTkRcIjtcbiAgICAgIFRva2VuVHlwZVtUb2tlblR5cGVbXCJFT0ZcIl0gPSAxOV0gPSBcIkVPRlwiO1xuICB9KShUb2tlblR5cGUkMSB8fCAoVG9rZW5UeXBlJDEgPSB7fSkpO1xuICB2YXIgVG9rZW4kMSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBUb2tlbih0eXBlLCBwYXJ0cywgc291cmNlU3Bhbikge1xuICAgICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgICAgdGhpcy5wYXJ0cyA9IHBhcnRzO1xuICAgICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgICB9XG4gICAgICByZXR1cm4gVG9rZW47XG4gIH0oKSk7XG4gIHZhciBUb2tlbkVycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQ0KFRva2VuRXJyb3IsIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBUb2tlbkVycm9yKGVycm9yTXNnLCB0b2tlblR5cGUsIHNwYW4pIHtcbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBzcGFuLCBlcnJvck1zZyk7XG4gICAgICAgICAgdGhpcy50b2tlblR5cGUgPSB0b2tlblR5cGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gVG9rZW5FcnJvcjtcbiAgfShQYXJzZUVycm9yKSk7XG4gIHZhciBUb2tlbml6ZVJlc3VsdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBUb2tlbml6ZVJlc3VsdCh0b2tlbnMsIGVycm9ycykge1xuICAgICAgICAgIHRoaXMudG9rZW5zID0gdG9rZW5zO1xuICAgICAgICAgIHRoaXMuZXJyb3JzID0gZXJyb3JzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFRva2VuaXplUmVzdWx0O1xuICB9KCkpO1xuICBmdW5jdGlvbiB0b2tlbml6ZShzb3VyY2UsIHVybCwgZ2V0VGFnRGVmaW5pdGlvbiwgdG9rZW5pemVFeHBhbnNpb25Gb3JtcywgaW50ZXJwb2xhdGlvbkNvbmZpZykge1xuICAgICAgaWYgKHRva2VuaXplRXhwYW5zaW9uRm9ybXMgPT09IHZvaWQgMCkgeyB0b2tlbml6ZUV4cGFuc2lvbkZvcm1zID0gZmFsc2U7IH1cbiAgICAgIGlmIChpbnRlcnBvbGF0aW9uQ29uZmlnID09PSB2b2lkIDApIHsgaW50ZXJwb2xhdGlvbkNvbmZpZyA9IERFRkFVTFRfSU5URVJQT0xBVElPTl9DT05GSUc7IH1cbiAgICAgIHJldHVybiBuZXcgX1Rva2VuaXplcihuZXcgUGFyc2VTb3VyY2VGaWxlKHNvdXJjZSwgdXJsKSwgZ2V0VGFnRGVmaW5pdGlvbiwgdG9rZW5pemVFeHBhbnNpb25Gb3JtcywgaW50ZXJwb2xhdGlvbkNvbmZpZylcbiAgICAgICAgICAudG9rZW5pemUoKTtcbiAgfVxuICB2YXIgX0NSX09SX0NSTEZfUkVHRVhQID0gL1xcclxcbj8vZztcbiAgZnVuY3Rpb24gX3VuZXhwZWN0ZWRDaGFyYWN0ZXJFcnJvck1zZyhjaGFyQ29kZSkge1xuICAgICAgdmFyIGNoYXIgPSBjaGFyQ29kZSA9PT0gJEVPRiA/ICdFT0YnIDogU3RyaW5nLmZyb21DaGFyQ29kZShjaGFyQ29kZSk7XG4gICAgICByZXR1cm4gXCJVbmV4cGVjdGVkIGNoYXJhY3RlciBcXFwiXCIgKyBjaGFyICsgXCJcXFwiXCI7XG4gIH1cbiAgZnVuY3Rpb24gX3Vua25vd25FbnRpdHlFcnJvck1zZyhlbnRpdHlTcmMpIHtcbiAgICAgIHJldHVybiBcIlVua25vd24gZW50aXR5IFxcXCJcIiArIGVudGl0eVNyYyArIFwiXFxcIiAtIHVzZSB0aGUgXFxcIiYjPGRlY2ltYWw+O1xcXCIgb3IgIFxcXCImI3g8aGV4PjtcXFwiIHN5bnRheFwiO1xuICB9XG4gIHZhciBfQ29udHJvbEZsb3dFcnJvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBfQ29udHJvbEZsb3dFcnJvcihlcnJvcikge1xuICAgICAgICAgIHRoaXMuZXJyb3IgPSBlcnJvcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfQ29udHJvbEZsb3dFcnJvcjtcbiAgfSgpKTtcbiAgLy8gU2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1MS9zeW50YXguaHRtbCN3cml0aW5nXG4gIHZhciBfVG9rZW5pemVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIF9maWxlIFRoZSBodG1sIHNvdXJjZVxuICAgICAgICogQHBhcmFtIF9nZXRUYWdEZWZpbml0aW9uXG4gICAgICAgKiBAcGFyYW0gX3Rva2VuaXplSWN1IFdoZXRoZXIgdG8gdG9rZW5pemUgSUNVIG1lc3NhZ2VzIChjb25zaWRlcmVkIGFzIHRleHQgbm9kZXMgd2hlbiBmYWxzZSlcbiAgICAgICAqIEBwYXJhbSBfaW50ZXJwb2xhdGlvbkNvbmZpZ1xuICAgICAgICovXG4gICAgICBmdW5jdGlvbiBfVG9rZW5pemVyKF9maWxlLCBfZ2V0VGFnRGVmaW5pdGlvbiwgX3Rva2VuaXplSWN1LCBfaW50ZXJwb2xhdGlvbkNvbmZpZykge1xuICAgICAgICAgIGlmIChfaW50ZXJwb2xhdGlvbkNvbmZpZyA9PT0gdm9pZCAwKSB7IF9pbnRlcnBvbGF0aW9uQ29uZmlnID0gREVGQVVMVF9JTlRFUlBPTEFUSU9OX0NPTkZJRzsgfVxuICAgICAgICAgIHRoaXMuX2ZpbGUgPSBfZmlsZTtcbiAgICAgICAgICB0aGlzLl9nZXRUYWdEZWZpbml0aW9uID0gX2dldFRhZ0RlZmluaXRpb247XG4gICAgICAgICAgdGhpcy5fdG9rZW5pemVJY3UgPSBfdG9rZW5pemVJY3U7XG4gICAgICAgICAgdGhpcy5faW50ZXJwb2xhdGlvbkNvbmZpZyA9IF9pbnRlcnBvbGF0aW9uQ29uZmlnO1xuICAgICAgICAgIC8vIE5vdGU6IHRoaXMgaXMgYWx3YXlzIGxvd2VyY2FzZSFcbiAgICAgICAgICB0aGlzLl9wZWVrID0gLTE7XG4gICAgICAgICAgdGhpcy5fbmV4dFBlZWsgPSAtMTtcbiAgICAgICAgICB0aGlzLl9pbmRleCA9IC0xO1xuICAgICAgICAgIHRoaXMuX2xpbmUgPSAwO1xuICAgICAgICAgIHRoaXMuX2NvbHVtbiA9IC0xO1xuICAgICAgICAgIHRoaXMuX2V4cGFuc2lvbkNhc2VTdGFjayA9IFtdO1xuICAgICAgICAgIHRoaXMuX2luSW50ZXJwb2xhdGlvbiA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMudG9rZW5zID0gW107XG4gICAgICAgICAgdGhpcy5lcnJvcnMgPSBbXTtcbiAgICAgICAgICB0aGlzLl9pbnB1dCA9IF9maWxlLmNvbnRlbnQ7XG4gICAgICAgICAgdGhpcy5fbGVuZ3RoID0gX2ZpbGUuY29udGVudC5sZW5ndGg7XG4gICAgICAgICAgdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgfVxuICAgICAgX1Rva2VuaXplci5wcm90b3R5cGUuX3Byb2Nlc3NDYXJyaWFnZVJldHVybnMgPSBmdW5jdGlvbiAoY29udGVudCkge1xuICAgICAgICAgIC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L3N5bnRheC5odG1sI3ByZXByb2Nlc3NpbmctdGhlLWlucHV0LXN0cmVhbVxuICAgICAgICAgIC8vIEluIG9yZGVyIHRvIGtlZXAgdGhlIG9yaWdpbmFsIHBvc2l0aW9uIGluIHRoZSBzb3VyY2UsIHdlIGNhbiBub3RcbiAgICAgICAgICAvLyBwcmUtcHJvY2VzcyBpdC5cbiAgICAgICAgICAvLyBJbnN0ZWFkIENScyBhcmUgcHJvY2Vzc2VkIHJpZ2h0IGJlZm9yZSBpbnN0YW50aWF0aW5nIHRoZSB0b2tlbnMuXG4gICAgICAgICAgcmV0dXJuIGNvbnRlbnQucmVwbGFjZShfQ1JfT1JfQ1JMRl9SRUdFWFAsICdcXG4nKTtcbiAgICAgIH07XG4gICAgICBfVG9rZW5pemVyLnByb3RvdHlwZS50b2tlbml6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB3aGlsZSAodGhpcy5fcGVlayAhPT0gJEVPRikge1xuICAgICAgICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLl9nZXRMb2NhdGlvbigpO1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2F0dGVtcHRDaGFyQ29kZSgkTFQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2F0dGVtcHRDaGFyQ29kZSgkQkFORykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2F0dGVtcHRDaGFyQ29kZSgkTEJSQUNLRVQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb25zdW1lQ2RhdGEoc3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX2F0dGVtcHRDaGFyQ29kZSgkTUlOVVMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb25zdW1lQ29tbWVudChzdGFydCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb25zdW1lRG9jVHlwZShzdGFydCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fYXR0ZW1wdENoYXJDb2RlKCRTTEFTSCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29uc3VtZVRhZ0Nsb3NlKHN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVUYWdPcGVuKHN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBlbHNlIGlmICghdGhpcy5fdG9rZW5pemVJY3UgfHwgIXRoaXMuX3Rva2VuaXplRXhwYW5zaW9uRm9ybSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29uc3VtZVRleHQoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBfQ29udHJvbEZsb3dFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZXJyb3JzLnB1c2goZS5lcnJvcik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX2JlZ2luVG9rZW4oVG9rZW5UeXBlJDEuRU9GKTtcbiAgICAgICAgICB0aGlzLl9lbmRUb2tlbihbXSk7XG4gICAgICAgICAgcmV0dXJuIG5ldyBUb2tlbml6ZVJlc3VsdChtZXJnZVRleHRUb2tlbnModGhpcy50b2tlbnMpLCB0aGlzLmVycm9ycyk7XG4gICAgICB9O1xuICAgICAgLyoqXG4gICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gd2hldGhlciBhbiBJQ1UgdG9rZW4gaGFzIGJlZW4gY3JlYXRlZFxuICAgICAgICogQGludGVybmFsXG4gICAgICAgKi9cbiAgICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl90b2tlbml6ZUV4cGFuc2lvbkZvcm0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKGlzRXhwYW5zaW9uRm9ybVN0YXJ0KHRoaXMuX2lucHV0LCB0aGlzLl9pbmRleCwgdGhpcy5faW50ZXJwb2xhdGlvbkNvbmZpZykpIHtcbiAgICAgICAgICAgICAgdGhpcy5fY29uc3VtZUV4cGFuc2lvbkZvcm1TdGFydCgpO1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzRXhwYW5zaW9uQ2FzZVN0YXJ0KHRoaXMuX3BlZWspICYmIHRoaXMuX2lzSW5FeHBhbnNpb25Gb3JtKCkpIHtcbiAgICAgICAgICAgICAgdGhpcy5fY29uc3VtZUV4cGFuc2lvbkNhc2VTdGFydCgpO1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRoaXMuX3BlZWsgPT09ICRSQlJBQ0UpIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuX2lzSW5FeHBhbnNpb25DYXNlKCkpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVFeHBhbnNpb25DYXNlRW5kKCk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAodGhpcy5faXNJbkV4cGFuc2lvbkZvcm0oKSkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5fY29uc3VtZUV4cGFuc2lvbkZvcm1FbmQoKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH07XG4gICAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fZ2V0TG9jYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBQYXJzZUxvY2F0aW9uKHRoaXMuX2ZpbGUsIHRoaXMuX2luZGV4LCB0aGlzLl9saW5lLCB0aGlzLl9jb2x1bW4pO1xuICAgICAgfTtcbiAgICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9nZXRTcGFuID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgICBpZiAoc3RhcnQgPT09IHZvaWQgMCkgeyBzdGFydCA9IHRoaXMuX2dldExvY2F0aW9uKCk7IH1cbiAgICAgICAgICBpZiAoZW5kID09PSB2b2lkIDApIHsgZW5kID0gdGhpcy5fZ2V0TG9jYXRpb24oKTsgfVxuICAgICAgICAgIHJldHVybiBuZXcgUGFyc2VTb3VyY2VTcGFuKHN0YXJ0LCBlbmQpO1xuICAgICAgfTtcbiAgICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9iZWdpblRva2VuID0gZnVuY3Rpb24gKHR5cGUsIHN0YXJ0KSB7XG4gICAgICAgICAgaWYgKHN0YXJ0ID09PSB2b2lkIDApIHsgc3RhcnQgPSB0aGlzLl9nZXRMb2NhdGlvbigpOyB9XG4gICAgICAgICAgdGhpcy5fY3VycmVudFRva2VuU3RhcnQgPSBzdGFydDtcbiAgICAgICAgICB0aGlzLl9jdXJyZW50VG9rZW5UeXBlID0gdHlwZTtcbiAgICAgIH07XG4gICAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fZW5kVG9rZW4gPSBmdW5jdGlvbiAocGFydHMsIGVuZCkge1xuICAgICAgICAgIGlmIChlbmQgPT09IHZvaWQgMCkgeyBlbmQgPSB0aGlzLl9nZXRMb2NhdGlvbigpOyB9XG4gICAgICAgICAgdmFyIHRva2VuID0gbmV3IFRva2VuJDEodGhpcy5fY3VycmVudFRva2VuVHlwZSwgcGFydHMsIG5ldyBQYXJzZVNvdXJjZVNwYW4odGhpcy5fY3VycmVudFRva2VuU3RhcnQsIGVuZCkpO1xuICAgICAgICAgIHRoaXMudG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgIHRoaXMuX2N1cnJlbnRUb2tlblN0YXJ0ID0gbnVsbDtcbiAgICAgICAgICB0aGlzLl9jdXJyZW50VG9rZW5UeXBlID0gbnVsbDtcbiAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICB9O1xuICAgICAgX1Rva2VuaXplci5wcm90b3R5cGUuX2NyZWF0ZUVycm9yID0gZnVuY3Rpb24gKG1zZywgc3Bhbikge1xuICAgICAgICAgIGlmICh0aGlzLl9pc0luRXhwYW5zaW9uRm9ybSgpKSB7XG4gICAgICAgICAgICAgIG1zZyArPSBcIiAoRG8geW91IGhhdmUgYW4gdW5lc2NhcGVkIFxcXCJ7XFxcIiBpbiB5b3VyIHRlbXBsYXRlPyBVc2UgXFxcInt7ICd7JyB9fVxcXCIpIHRvIGVzY2FwZSBpdC4pXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBlcnJvciA9IG5ldyBUb2tlbkVycm9yKG1zZywgdGhpcy5fY3VycmVudFRva2VuVHlwZSwgc3Bhbik7XG4gICAgICAgICAgdGhpcy5fY3VycmVudFRva2VuU3RhcnQgPSBudWxsO1xuICAgICAgICAgIHRoaXMuX2N1cnJlbnRUb2tlblR5cGUgPSBudWxsO1xuICAgICAgICAgIHJldHVybiBuZXcgX0NvbnRyb2xGbG93RXJyb3IoZXJyb3IpO1xuICAgICAgfTtcbiAgICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9hZHZhbmNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmICh0aGlzLl9pbmRleCA+PSB0aGlzLl9sZW5ndGgpIHtcbiAgICAgICAgICAgICAgdGhyb3cgdGhpcy5fY3JlYXRlRXJyb3IoX3VuZXhwZWN0ZWRDaGFyYWN0ZXJFcnJvck1zZygkRU9GKSwgdGhpcy5fZ2V0U3BhbigpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRoaXMuX3BlZWsgPT09ICRMRikge1xuICAgICAgICAgICAgICB0aGlzLl9saW5lKys7XG4gICAgICAgICAgICAgIHRoaXMuX2NvbHVtbiA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX3BlZWsgIT09ICRMRiAmJiB0aGlzLl9wZWVrICE9PSAkQ1IpIHtcbiAgICAgICAgICAgICAgdGhpcy5fY29sdW1uKys7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX2luZGV4Kys7XG4gICAgICAgICAgdGhpcy5fcGVlayA9IHRoaXMuX2luZGV4ID49IHRoaXMuX2xlbmd0aCA/ICRFT0YgOiB0aGlzLl9pbnB1dC5jaGFyQ29kZUF0KHRoaXMuX2luZGV4KTtcbiAgICAgICAgICB0aGlzLl9uZXh0UGVlayA9XG4gICAgICAgICAgICAgIHRoaXMuX2luZGV4ICsgMSA+PSB0aGlzLl9sZW5ndGggPyAkRU9GIDogdGhpcy5faW5wdXQuY2hhckNvZGVBdCh0aGlzLl9pbmRleCArIDEpO1xuICAgICAgfTtcbiAgICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9hdHRlbXB0Q2hhckNvZGUgPSBmdW5jdGlvbiAoY2hhckNvZGUpIHtcbiAgICAgICAgICBpZiAodGhpcy5fcGVlayA9PT0gY2hhckNvZGUpIHtcbiAgICAgICAgICAgICAgdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfTtcbiAgICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9hdHRlbXB0Q2hhckNvZGVDYXNlSW5zZW5zaXRpdmUgPSBmdW5jdGlvbiAoY2hhckNvZGUpIHtcbiAgICAgICAgICBpZiAoY29tcGFyZUNoYXJDb2RlQ2FzZUluc2Vuc2l0aXZlKHRoaXMuX3BlZWssIGNoYXJDb2RlKSkge1xuICAgICAgICAgICAgICB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9O1xuICAgICAgX1Rva2VuaXplci5wcm90b3R5cGUuX3JlcXVpcmVDaGFyQ29kZSA9IGZ1bmN0aW9uIChjaGFyQ29kZSkge1xuICAgICAgICAgIHZhciBsb2NhdGlvbiA9IHRoaXMuX2dldExvY2F0aW9uKCk7XG4gICAgICAgICAgaWYgKCF0aGlzLl9hdHRlbXB0Q2hhckNvZGUoY2hhckNvZGUpKSB7XG4gICAgICAgICAgICAgIHRocm93IHRoaXMuX2NyZWF0ZUVycm9yKF91bmV4cGVjdGVkQ2hhcmFjdGVyRXJyb3JNc2codGhpcy5fcGVlayksIHRoaXMuX2dldFNwYW4obG9jYXRpb24sIGxvY2F0aW9uKSk7XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9hdHRlbXB0U3RyID0gZnVuY3Rpb24gKGNoYXJzKSB7XG4gICAgICAgICAgdmFyIGxlbiA9IGNoYXJzLmxlbmd0aDtcbiAgICAgICAgICBpZiAodGhpcy5faW5kZXggKyBsZW4gPiB0aGlzLl9sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgaW5pdGlhbFBvc2l0aW9uID0gdGhpcy5fc2F2ZVBvc2l0aW9uKCk7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICBpZiAoIXRoaXMuX2F0dGVtcHRDaGFyQ29kZShjaGFycy5jaGFyQ29kZUF0KGkpKSkge1xuICAgICAgICAgICAgICAgICAgLy8gSWYgYXR0ZW1wdGluZyB0byBwYXJzZSB0aGUgc3RyaW5nIGZhaWxzLCB3ZSB3YW50IHRvIHJlc2V0IHRoZSBwYXJzZXJcbiAgICAgICAgICAgICAgICAgIC8vIHRvIHdoZXJlIGl0IHdhcyBiZWZvcmUgdGhlIGF0dGVtcHRcbiAgICAgICAgICAgICAgICAgIHRoaXMuX3Jlc3RvcmVQb3NpdGlvbihpbml0aWFsUG9zaXRpb24pO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfTtcbiAgICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9hdHRlbXB0U3RyQ2FzZUluc2Vuc2l0aXZlID0gZnVuY3Rpb24gKGNoYXJzKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBpZiAoIXRoaXMuX2F0dGVtcHRDaGFyQ29kZUNhc2VJbnNlbnNpdGl2ZShjaGFycy5jaGFyQ29kZUF0KGkpKSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfTtcbiAgICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9yZXF1aXJlU3RyID0gZnVuY3Rpb24gKGNoYXJzKSB7XG4gICAgICAgICAgdmFyIGxvY2F0aW9uID0gdGhpcy5fZ2V0TG9jYXRpb24oKTtcbiAgICAgICAgICBpZiAoIXRoaXMuX2F0dGVtcHRTdHIoY2hhcnMpKSB7XG4gICAgICAgICAgICAgIHRocm93IHRoaXMuX2NyZWF0ZUVycm9yKF91bmV4cGVjdGVkQ2hhcmFjdGVyRXJyb3JNc2codGhpcy5fcGVlayksIHRoaXMuX2dldFNwYW4obG9jYXRpb24pKTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgX1Rva2VuaXplci5wcm90b3R5cGUuX2F0dGVtcHRDaGFyQ29kZVVudGlsRm4gPSBmdW5jdGlvbiAocHJlZGljYXRlKSB7XG4gICAgICAgICAgd2hpbGUgKCFwcmVkaWNhdGUodGhpcy5fcGVlaykpIHtcbiAgICAgICAgICAgICAgdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fcmVxdWlyZUNoYXJDb2RlVW50aWxGbiA9IGZ1bmN0aW9uIChwcmVkaWNhdGUsIGxlbikge1xuICAgICAgICAgIHZhciBzdGFydCA9IHRoaXMuX2dldExvY2F0aW9uKCk7XG4gICAgICAgICAgdGhpcy5fYXR0ZW1wdENoYXJDb2RlVW50aWxGbihwcmVkaWNhdGUpO1xuICAgICAgICAgIGlmICh0aGlzLl9pbmRleCAtIHN0YXJ0Lm9mZnNldCA8IGxlbikge1xuICAgICAgICAgICAgICB0aHJvdyB0aGlzLl9jcmVhdGVFcnJvcihfdW5leHBlY3RlZENoYXJhY3RlckVycm9yTXNnKHRoaXMuX3BlZWspLCB0aGlzLl9nZXRTcGFuKHN0YXJ0LCBzdGFydCkpO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fYXR0ZW1wdFVudGlsQ2hhciA9IGZ1bmN0aW9uIChjaGFyKSB7XG4gICAgICAgICAgd2hpbGUgKHRoaXMuX3BlZWsgIT09IGNoYXIpIHtcbiAgICAgICAgICAgICAgdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fcmVhZENoYXIgPSBmdW5jdGlvbiAoZGVjb2RlRW50aXRpZXMpIHtcbiAgICAgICAgICBpZiAoZGVjb2RlRW50aXRpZXMgJiYgdGhpcy5fcGVlayA9PT0gJEFNUEVSU0FORCkge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVjb2RlRW50aXR5KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLl9pbmRleDtcbiAgICAgICAgICAgICAgdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faW5wdXRbaW5kZXhdO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fZGVjb2RlRW50aXR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBzdGFydCA9IHRoaXMuX2dldExvY2F0aW9uKCk7XG4gICAgICAgICAgdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICAgIGlmICh0aGlzLl9hdHRlbXB0Q2hhckNvZGUoJEhBU0gpKSB7XG4gICAgICAgICAgICAgIHZhciBpc0hleCA9IHRoaXMuX2F0dGVtcHRDaGFyQ29kZSgkeCkgfHwgdGhpcy5fYXR0ZW1wdENoYXJDb2RlKCRYKTtcbiAgICAgICAgICAgICAgdmFyIG51bWJlclN0YXJ0ID0gdGhpcy5fZ2V0TG9jYXRpb24oKS5vZmZzZXQ7XG4gICAgICAgICAgICAgIHRoaXMuX2F0dGVtcHRDaGFyQ29kZVVudGlsRm4oaXNEaWdpdEVudGl0eUVuZCk7XG4gICAgICAgICAgICAgIGlmICh0aGlzLl9wZWVrICE9ICRTRU1JQ09MT04pIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IHRoaXMuX2NyZWF0ZUVycm9yKF91bmV4cGVjdGVkQ2hhcmFjdGVyRXJyb3JNc2codGhpcy5fcGVlayksIHRoaXMuX2dldFNwYW4oKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICAgICAgICB2YXIgc3RyTnVtID0gdGhpcy5faW5wdXQuc3Vic3RyaW5nKG51bWJlclN0YXJ0LCB0aGlzLl9pbmRleCAtIDEpO1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgdmFyIGNoYXJDb2RlID0gcGFyc2VJbnQoc3RyTnVtLCBpc0hleCA/IDE2IDogMTApO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY2hhckNvZGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgZW50aXR5ID0gdGhpcy5faW5wdXQuc3Vic3RyaW5nKHN0YXJ0Lm9mZnNldCArIDEsIHRoaXMuX2luZGV4IC0gMSk7XG4gICAgICAgICAgICAgICAgICB0aHJvdyB0aGlzLl9jcmVhdGVFcnJvcihfdW5rbm93bkVudGl0eUVycm9yTXNnKGVudGl0eSksIHRoaXMuX2dldFNwYW4oc3RhcnQpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIHN0YXJ0UG9zaXRpb24gPSB0aGlzLl9zYXZlUG9zaXRpb24oKTtcbiAgICAgICAgICAgICAgdGhpcy5fYXR0ZW1wdENoYXJDb2RlVW50aWxGbihpc05hbWVkRW50aXR5RW5kKTtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuX3BlZWsgIT0gJFNFTUlDT0xPTikge1xuICAgICAgICAgICAgICAgICAgdGhpcy5fcmVzdG9yZVBvc2l0aW9uKHN0YXJ0UG9zaXRpb24pO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuICcmJztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgICAgICAgIHZhciBuYW1lXzEgPSB0aGlzLl9pbnB1dC5zdWJzdHJpbmcoc3RhcnQub2Zmc2V0ICsgMSwgdGhpcy5faW5kZXggLSAxKTtcbiAgICAgICAgICAgICAgdmFyIGNoYXIgPSBOQU1FRF9FTlRJVElFU1tuYW1lXzFdO1xuICAgICAgICAgICAgICBpZiAoIWNoYXIpIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IHRoaXMuX2NyZWF0ZUVycm9yKF91bmtub3duRW50aXR5RXJyb3JNc2cobmFtZV8xKSwgdGhpcy5fZ2V0U3BhbihzdGFydCkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBjaGFyO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fY29uc3VtZVJhd1RleHQgPSBmdW5jdGlvbiAoZGVjb2RlRW50aXRpZXMsIGZpcnN0Q2hhck9mRW5kLCBhdHRlbXB0RW5kUmVzdCkge1xuICAgICAgICAgIHZhciB0YWdDbG9zZVN0YXJ0O1xuICAgICAgICAgIHZhciB0ZXh0U3RhcnQgPSB0aGlzLl9nZXRMb2NhdGlvbigpO1xuICAgICAgICAgIHRoaXMuX2JlZ2luVG9rZW4oZGVjb2RlRW50aXRpZXMgPyBUb2tlblR5cGUkMS5FU0NBUEFCTEVfUkFXX1RFWFQgOiBUb2tlblR5cGUkMS5SQVdfVEVYVCwgdGV4dFN0YXJ0KTtcbiAgICAgICAgICB2YXIgcGFydHMgPSBbXTtcbiAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICB0YWdDbG9zZVN0YXJ0ID0gdGhpcy5fZ2V0TG9jYXRpb24oKTtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuX2F0dGVtcHRDaGFyQ29kZShmaXJzdENoYXJPZkVuZCkgJiYgYXR0ZW1wdEVuZFJlc3QoKSkge1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHRoaXMuX2luZGV4ID4gdGFnQ2xvc2VTdGFydC5vZmZzZXQpIHtcbiAgICAgICAgICAgICAgICAgIC8vIGFkZCB0aGUgY2hhcmFjdGVycyBjb25zdW1lZCBieSB0aGUgcHJldmlvdXMgaWYgc3RhdGVtZW50IHRvIHRoZSBvdXRwdXRcbiAgICAgICAgICAgICAgICAgIHBhcnRzLnB1c2godGhpcy5faW5wdXQuc3Vic3RyaW5nKHRhZ0Nsb3NlU3RhcnQub2Zmc2V0LCB0aGlzLl9pbmRleCkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHdoaWxlICh0aGlzLl9wZWVrICE9PSBmaXJzdENoYXJPZkVuZCkge1xuICAgICAgICAgICAgICAgICAgcGFydHMucHVzaCh0aGlzLl9yZWFkQ2hhcihkZWNvZGVFbnRpdGllcykpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aGlzLl9lbmRUb2tlbihbdGhpcy5fcHJvY2Vzc0NhcnJpYWdlUmV0dXJucyhwYXJ0cy5qb2luKCcnKSldLCB0YWdDbG9zZVN0YXJ0KTtcbiAgICAgIH07XG4gICAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fY29uc3VtZUNvbW1lbnQgPSBmdW5jdGlvbiAoc3RhcnQpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHRoaXMuX2JlZ2luVG9rZW4oVG9rZW5UeXBlJDEuQ09NTUVOVF9TVEFSVCwgc3RhcnQpO1xuICAgICAgICAgIHRoaXMuX3JlcXVpcmVDaGFyQ29kZSgkTUlOVVMpO1xuICAgICAgICAgIHRoaXMuX2VuZFRva2VuKFtdKTtcbiAgICAgICAgICB2YXIgdGV4dFRva2VuID0gdGhpcy5fY29uc3VtZVJhd1RleHQoZmFsc2UsICRNSU5VUywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX2F0dGVtcHRTdHIoJy0+Jyk7IH0pO1xuICAgICAgICAgIHRoaXMuX2JlZ2luVG9rZW4oVG9rZW5UeXBlJDEuQ09NTUVOVF9FTkQsIHRleHRUb2tlbi5zb3VyY2VTcGFuLmVuZCk7XG4gICAgICAgICAgdGhpcy5fZW5kVG9rZW4oW10pO1xuICAgICAgfTtcbiAgICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9jb25zdW1lQ2RhdGEgPSBmdW5jdGlvbiAoc3RhcnQpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHRoaXMuX2JlZ2luVG9rZW4oVG9rZW5UeXBlJDEuQ0RBVEFfU1RBUlQsIHN0YXJ0KTtcbiAgICAgICAgICB0aGlzLl9yZXF1aXJlU3RyKCdDREFUQVsnKTtcbiAgICAgICAgICB0aGlzLl9lbmRUb2tlbihbXSk7XG4gICAgICAgICAgdmFyIHRleHRUb2tlbiA9IHRoaXMuX2NvbnN1bWVSYXdUZXh0KGZhbHNlLCAkUkJSQUNLRVQsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9hdHRlbXB0U3RyKCddPicpOyB9KTtcbiAgICAgICAgICB0aGlzLl9iZWdpblRva2VuKFRva2VuVHlwZSQxLkNEQVRBX0VORCwgdGV4dFRva2VuLnNvdXJjZVNwYW4uZW5kKTtcbiAgICAgICAgICB0aGlzLl9lbmRUb2tlbihbXSk7XG4gICAgICB9O1xuICAgICAgX1Rva2VuaXplci5wcm90b3R5cGUuX2NvbnN1bWVEb2NUeXBlID0gZnVuY3Rpb24gKHN0YXJ0KSB7XG4gICAgICAgICAgdGhpcy5fYmVnaW5Ub2tlbihUb2tlblR5cGUkMS5ET0NfVFlQRSwgc3RhcnQpO1xuICAgICAgICAgIHRoaXMuX2F0dGVtcHRVbnRpbENoYXIoJEdUKTtcbiAgICAgICAgICB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgICAgdGhpcy5fZW5kVG9rZW4oW3RoaXMuX2lucHV0LnN1YnN0cmluZyhzdGFydC5vZmZzZXQgKyAyLCB0aGlzLl9pbmRleCAtIDEpXSk7XG4gICAgICB9O1xuICAgICAgX1Rva2VuaXplci5wcm90b3R5cGUuX2NvbnN1bWVQcmVmaXhBbmROYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBuYW1lT3JQcmVmaXhTdGFydCA9IHRoaXMuX2luZGV4O1xuICAgICAgICAgIHZhciBwcmVmaXggPSBudWxsO1xuICAgICAgICAgIHdoaWxlICh0aGlzLl9wZWVrICE9PSAkQ09MT04gJiYgIWlzUHJlZml4RW5kKHRoaXMuX3BlZWspKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIG5hbWVTdGFydDtcbiAgICAgICAgICBpZiAodGhpcy5fcGVlayA9PT0gJENPTE9OKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgICAgICAgcHJlZml4ID0gdGhpcy5faW5wdXQuc3Vic3RyaW5nKG5hbWVPclByZWZpeFN0YXJ0LCB0aGlzLl9pbmRleCAtIDEpO1xuICAgICAgICAgICAgICBuYW1lU3RhcnQgPSB0aGlzLl9pbmRleDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIG5hbWVTdGFydCA9IG5hbWVPclByZWZpeFN0YXJ0O1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9yZXF1aXJlQ2hhckNvZGVVbnRpbEZuKGlzTmFtZUVuZCwgdGhpcy5faW5kZXggPT09IG5hbWVTdGFydCA/IDEgOiAwKTtcbiAgICAgICAgICB2YXIgbmFtZSA9IHRoaXMuX2lucHV0LnN1YnN0cmluZyhuYW1lU3RhcnQsIHRoaXMuX2luZGV4KTtcbiAgICAgICAgICByZXR1cm4gW3ByZWZpeCwgbmFtZV07XG4gICAgICB9O1xuICAgICAgX1Rva2VuaXplci5wcm90b3R5cGUuX2NvbnN1bWVUYWdPcGVuID0gZnVuY3Rpb24gKHN0YXJ0KSB7XG4gICAgICAgICAgdmFyIHNhdmVkUG9zID0gdGhpcy5fc2F2ZVBvc2l0aW9uKCk7XG4gICAgICAgICAgdmFyIHRhZ05hbWU7XG4gICAgICAgICAgdmFyIGxvd2VyY2FzZVRhZ05hbWU7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgaWYgKCFpc0FzY2lpTGV0dGVyKHRoaXMuX3BlZWspKSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyB0aGlzLl9jcmVhdGVFcnJvcihfdW5leHBlY3RlZENoYXJhY3RlckVycm9yTXNnKHRoaXMuX3BlZWspLCB0aGlzLl9nZXRTcGFuKCkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhciBuYW1lU3RhcnQgPSB0aGlzLl9pbmRleDtcbiAgICAgICAgICAgICAgdGhpcy5fY29uc3VtZVRhZ09wZW5TdGFydChzdGFydCk7XG4gICAgICAgICAgICAgIHRhZ05hbWUgPSB0aGlzLl9pbnB1dC5zdWJzdHJpbmcobmFtZVN0YXJ0LCB0aGlzLl9pbmRleCk7XG4gICAgICAgICAgICAgIGxvd2VyY2FzZVRhZ05hbWUgPSB0YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgIHRoaXMuX2F0dGVtcHRDaGFyQ29kZVVudGlsRm4oaXNOb3RXaGl0ZXNwYWNlKTtcbiAgICAgICAgICAgICAgd2hpbGUgKHRoaXMuX3BlZWsgIT09ICRTTEFTSCAmJiB0aGlzLl9wZWVrICE9PSAkR1QpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVBdHRyaWJ1dGVOYW1lKCk7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9hdHRlbXB0Q2hhckNvZGVVbnRpbEZuKGlzTm90V2hpdGVzcGFjZSk7XG4gICAgICAgICAgICAgICAgICBpZiAodGhpcy5fYXR0ZW1wdENoYXJDb2RlKCRFUSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hdHRlbXB0Q2hhckNvZGVVbnRpbEZuKGlzTm90V2hpdGVzcGFjZSk7XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29uc3VtZUF0dHJpYnV0ZVZhbHVlKCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB0aGlzLl9hdHRlbXB0Q2hhckNvZGVVbnRpbEZuKGlzTm90V2hpdGVzcGFjZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhpcy5fY29uc3VtZVRhZ09wZW5FbmQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBfQ29udHJvbEZsb3dFcnJvcikge1xuICAgICAgICAgICAgICAgICAgLy8gV2hlbiB0aGUgc3RhcnQgdGFnIGlzIGludmFsaWQsIGFzc3VtZSB3ZSB3YW50IGEgXCI8XCJcbiAgICAgICAgICAgICAgICAgIHRoaXMuX3Jlc3RvcmVQb3NpdGlvbihzYXZlZFBvcyk7XG4gICAgICAgICAgICAgICAgICAvLyBCYWNrIHRvIGJhY2sgdGV4dCB0b2tlbnMgYXJlIG1lcmdlZCBhdCB0aGUgZW5kXG4gICAgICAgICAgICAgICAgICB0aGlzLl9iZWdpblRva2VuKFRva2VuVHlwZSQxLlRFWFQsIHN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2VuZFRva2VuKFsnPCddKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgY29udGVudFRva2VuVHlwZSA9IHRoaXMuX2dldFRhZ0RlZmluaXRpb24odGFnTmFtZSkuY29udGVudFR5cGU7XG4gICAgICAgICAgaWYgKGNvbnRlbnRUb2tlblR5cGUgPT09IFRhZ0NvbnRlbnRUeXBlLlJBV19URVhUKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVSYXdUZXh0V2l0aFRhZ0Nsb3NlKGxvd2VyY2FzZVRhZ05hbWUsIGZhbHNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoY29udGVudFRva2VuVHlwZSA9PT0gVGFnQ29udGVudFR5cGUuRVNDQVBBQkxFX1JBV19URVhUKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVSYXdUZXh0V2l0aFRhZ0Nsb3NlKGxvd2VyY2FzZVRhZ05hbWUsIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fY29uc3VtZVJhd1RleHRXaXRoVGFnQ2xvc2UgPSBmdW5jdGlvbiAobG93ZXJjYXNlVGFnTmFtZSwgZGVjb2RlRW50aXRpZXMpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHZhciB0ZXh0VG9rZW4gPSB0aGlzLl9jb25zdW1lUmF3VGV4dChkZWNvZGVFbnRpdGllcywgJExULCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGlmICghX3RoaXMuX2F0dGVtcHRDaGFyQ29kZSgkU0xBU0gpKVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICBfdGhpcy5fYXR0ZW1wdENoYXJDb2RlVW50aWxGbihpc05vdFdoaXRlc3BhY2UpO1xuICAgICAgICAgICAgICBpZiAoIV90aGlzLl9hdHRlbXB0U3RyQ2FzZUluc2Vuc2l0aXZlKGxvd2VyY2FzZVRhZ05hbWUpKVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICBfdGhpcy5fYXR0ZW1wdENoYXJDb2RlVW50aWxGbihpc05vdFdoaXRlc3BhY2UpO1xuICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuX2F0dGVtcHRDaGFyQ29kZSgkR1QpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRoaXMuX2JlZ2luVG9rZW4oVG9rZW5UeXBlJDEuVEFHX0NMT1NFLCB0ZXh0VG9rZW4uc291cmNlU3Bhbi5lbmQpO1xuICAgICAgICAgIHRoaXMuX2VuZFRva2VuKFtudWxsLCBsb3dlcmNhc2VUYWdOYW1lXSk7XG4gICAgICB9O1xuICAgICAgX1Rva2VuaXplci5wcm90b3R5cGUuX2NvbnN1bWVUYWdPcGVuU3RhcnQgPSBmdW5jdGlvbiAoc3RhcnQpIHtcbiAgICAgICAgICB0aGlzLl9iZWdpblRva2VuKFRva2VuVHlwZSQxLlRBR19PUEVOX1NUQVJULCBzdGFydCk7XG4gICAgICAgICAgdmFyIHBhcnRzID0gdGhpcy5fY29uc3VtZVByZWZpeEFuZE5hbWUoKTtcbiAgICAgICAgICB0aGlzLl9lbmRUb2tlbihwYXJ0cyk7XG4gICAgICB9O1xuICAgICAgX1Rva2VuaXplci5wcm90b3R5cGUuX2NvbnN1bWVBdHRyaWJ1dGVOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoaXMuX2JlZ2luVG9rZW4oVG9rZW5UeXBlJDEuQVRUUl9OQU1FKTtcbiAgICAgICAgICB2YXIgcHJlZml4QW5kTmFtZSA9IHRoaXMuX2NvbnN1bWVQcmVmaXhBbmROYW1lKCk7XG4gICAgICAgICAgdGhpcy5fZW5kVG9rZW4ocHJlZml4QW5kTmFtZSk7XG4gICAgICB9O1xuICAgICAgX1Rva2VuaXplci5wcm90b3R5cGUuX2NvbnN1bWVBdHRyaWJ1dGVWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGlzLl9iZWdpblRva2VuKFRva2VuVHlwZSQxLkFUVFJfVkFMVUUpO1xuICAgICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgICBpZiAodGhpcy5fcGVlayA9PT0gJFNRIHx8IHRoaXMuX3BlZWsgPT09ICREUSkge1xuICAgICAgICAgICAgICB2YXIgcXVvdGVDaGFyID0gdGhpcy5fcGVlaztcbiAgICAgICAgICAgICAgdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICAgICAgICB2YXIgcGFydHMgPSBbXTtcbiAgICAgICAgICAgICAgd2hpbGUgKHRoaXMuX3BlZWsgIT09IHF1b3RlQ2hhcikge1xuICAgICAgICAgICAgICAgICAgcGFydHMucHVzaCh0aGlzLl9yZWFkQ2hhcih0cnVlKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFsdWUgPSBwYXJ0cy5qb2luKCcnKTtcbiAgICAgICAgICAgICAgdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIHZhbHVlU3RhcnQgPSB0aGlzLl9pbmRleDtcbiAgICAgICAgICAgICAgdGhpcy5fcmVxdWlyZUNoYXJDb2RlVW50aWxGbihpc05hbWVFbmQsIDEpO1xuICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMuX2lucHV0LnN1YnN0cmluZyh2YWx1ZVN0YXJ0LCB0aGlzLl9pbmRleCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX2VuZFRva2VuKFt0aGlzLl9wcm9jZXNzQ2FycmlhZ2VSZXR1cm5zKHZhbHVlKV0pO1xuICAgICAgfTtcbiAgICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9jb25zdW1lVGFnT3BlbkVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgdG9rZW5UeXBlID0gdGhpcy5fYXR0ZW1wdENoYXJDb2RlKCRTTEFTSCkgPyBUb2tlblR5cGUkMS5UQUdfT1BFTl9FTkRfVk9JRCA6IFRva2VuVHlwZSQxLlRBR19PUEVOX0VORDtcbiAgICAgICAgICB0aGlzLl9iZWdpblRva2VuKHRva2VuVHlwZSk7XG4gICAgICAgICAgdGhpcy5fcmVxdWlyZUNoYXJDb2RlKCRHVCk7XG4gICAgICAgICAgdGhpcy5fZW5kVG9rZW4oW10pO1xuICAgICAgfTtcbiAgICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9jb25zdW1lVGFnQ2xvc2UgPSBmdW5jdGlvbiAoc3RhcnQpIHtcbiAgICAgICAgICB0aGlzLl9iZWdpblRva2VuKFRva2VuVHlwZSQxLlRBR19DTE9TRSwgc3RhcnQpO1xuICAgICAgICAgIHRoaXMuX2F0dGVtcHRDaGFyQ29kZVVudGlsRm4oaXNOb3RXaGl0ZXNwYWNlKTtcbiAgICAgICAgICB2YXIgcHJlZml4QW5kTmFtZSA9IHRoaXMuX2NvbnN1bWVQcmVmaXhBbmROYW1lKCk7XG4gICAgICAgICAgdGhpcy5fYXR0ZW1wdENoYXJDb2RlVW50aWxGbihpc05vdFdoaXRlc3BhY2UpO1xuICAgICAgICAgIHRoaXMuX3JlcXVpcmVDaGFyQ29kZSgkR1QpO1xuICAgICAgICAgIHRoaXMuX2VuZFRva2VuKHByZWZpeEFuZE5hbWUpO1xuICAgICAgfTtcbiAgICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9jb25zdW1lRXhwYW5zaW9uRm9ybVN0YXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoaXMuX2JlZ2luVG9rZW4oVG9rZW5UeXBlJDEuRVhQQU5TSU9OX0ZPUk1fU1RBUlQsIHRoaXMuX2dldExvY2F0aW9uKCkpO1xuICAgICAgICAgIHRoaXMuX3JlcXVpcmVDaGFyQ29kZSgkTEJSQUNFKTtcbiAgICAgICAgICB0aGlzLl9lbmRUb2tlbihbXSk7XG4gICAgICAgICAgdGhpcy5fZXhwYW5zaW9uQ2FzZVN0YWNrLnB1c2goVG9rZW5UeXBlJDEuRVhQQU5TSU9OX0ZPUk1fU1RBUlQpO1xuICAgICAgICAgIHRoaXMuX2JlZ2luVG9rZW4oVG9rZW5UeXBlJDEuUkFXX1RFWFQsIHRoaXMuX2dldExvY2F0aW9uKCkpO1xuICAgICAgICAgIHZhciBjb25kaXRpb24gPSB0aGlzLl9yZWFkVW50aWwoJENPTU1BKTtcbiAgICAgICAgICB0aGlzLl9lbmRUb2tlbihbY29uZGl0aW9uXSwgdGhpcy5fZ2V0TG9jYXRpb24oKSk7XG4gICAgICAgICAgdGhpcy5fcmVxdWlyZUNoYXJDb2RlKCRDT01NQSk7XG4gICAgICAgICAgdGhpcy5fYXR0ZW1wdENoYXJDb2RlVW50aWxGbihpc05vdFdoaXRlc3BhY2UpO1xuICAgICAgICAgIHRoaXMuX2JlZ2luVG9rZW4oVG9rZW5UeXBlJDEuUkFXX1RFWFQsIHRoaXMuX2dldExvY2F0aW9uKCkpO1xuICAgICAgICAgIHZhciB0eXBlID0gdGhpcy5fcmVhZFVudGlsKCRDT01NQSk7XG4gICAgICAgICAgdGhpcy5fZW5kVG9rZW4oW3R5cGVdLCB0aGlzLl9nZXRMb2NhdGlvbigpKTtcbiAgICAgICAgICB0aGlzLl9yZXF1aXJlQ2hhckNvZGUoJENPTU1BKTtcbiAgICAgICAgICB0aGlzLl9hdHRlbXB0Q2hhckNvZGVVbnRpbEZuKGlzTm90V2hpdGVzcGFjZSk7XG4gICAgICB9O1xuICAgICAgX1Rva2VuaXplci5wcm90b3R5cGUuX2NvbnN1bWVFeHBhbnNpb25DYXNlU3RhcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhpcy5fYmVnaW5Ub2tlbihUb2tlblR5cGUkMS5FWFBBTlNJT05fQ0FTRV9WQUxVRSwgdGhpcy5fZ2V0TG9jYXRpb24oKSk7XG4gICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5fcmVhZFVudGlsKCRMQlJBQ0UpLnRyaW0oKTtcbiAgICAgICAgICB0aGlzLl9lbmRUb2tlbihbdmFsdWVdLCB0aGlzLl9nZXRMb2NhdGlvbigpKTtcbiAgICAgICAgICB0aGlzLl9hdHRlbXB0Q2hhckNvZGVVbnRpbEZuKGlzTm90V2hpdGVzcGFjZSk7XG4gICAgICAgICAgdGhpcy5fYmVnaW5Ub2tlbihUb2tlblR5cGUkMS5FWFBBTlNJT05fQ0FTRV9FWFBfU1RBUlQsIHRoaXMuX2dldExvY2F0aW9uKCkpO1xuICAgICAgICAgIHRoaXMuX3JlcXVpcmVDaGFyQ29kZSgkTEJSQUNFKTtcbiAgICAgICAgICB0aGlzLl9lbmRUb2tlbihbXSwgdGhpcy5fZ2V0TG9jYXRpb24oKSk7XG4gICAgICAgICAgdGhpcy5fYXR0ZW1wdENoYXJDb2RlVW50aWxGbihpc05vdFdoaXRlc3BhY2UpO1xuICAgICAgICAgIHRoaXMuX2V4cGFuc2lvbkNhc2VTdGFjay5wdXNoKFRva2VuVHlwZSQxLkVYUEFOU0lPTl9DQVNFX0VYUF9TVEFSVCk7XG4gICAgICB9O1xuICAgICAgX1Rva2VuaXplci5wcm90b3R5cGUuX2NvbnN1bWVFeHBhbnNpb25DYXNlRW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoaXMuX2JlZ2luVG9rZW4oVG9rZW5UeXBlJDEuRVhQQU5TSU9OX0NBU0VfRVhQX0VORCwgdGhpcy5fZ2V0TG9jYXRpb24oKSk7XG4gICAgICAgICAgdGhpcy5fcmVxdWlyZUNoYXJDb2RlKCRSQlJBQ0UpO1xuICAgICAgICAgIHRoaXMuX2VuZFRva2VuKFtdLCB0aGlzLl9nZXRMb2NhdGlvbigpKTtcbiAgICAgICAgICB0aGlzLl9hdHRlbXB0Q2hhckNvZGVVbnRpbEZuKGlzTm90V2hpdGVzcGFjZSk7XG4gICAgICAgICAgdGhpcy5fZXhwYW5zaW9uQ2FzZVN0YWNrLnBvcCgpO1xuICAgICAgfTtcbiAgICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9jb25zdW1lRXhwYW5zaW9uRm9ybUVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGlzLl9iZWdpblRva2VuKFRva2VuVHlwZSQxLkVYUEFOU0lPTl9GT1JNX0VORCwgdGhpcy5fZ2V0TG9jYXRpb24oKSk7XG4gICAgICAgICAgdGhpcy5fcmVxdWlyZUNoYXJDb2RlKCRSQlJBQ0UpO1xuICAgICAgICAgIHRoaXMuX2VuZFRva2VuKFtdKTtcbiAgICAgICAgICB0aGlzLl9leHBhbnNpb25DYXNlU3RhY2sucG9wKCk7XG4gICAgICB9O1xuICAgICAgX1Rva2VuaXplci5wcm90b3R5cGUuX2NvbnN1bWVUZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBzdGFydCA9IHRoaXMuX2dldExvY2F0aW9uKCk7XG4gICAgICAgICAgdGhpcy5fYmVnaW5Ub2tlbihUb2tlblR5cGUkMS5URVhULCBzdGFydCk7XG4gICAgICAgICAgdmFyIHBhcnRzID0gW107XG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICBpZiAodGhpcy5faW50ZXJwb2xhdGlvbkNvbmZpZyAmJiB0aGlzLl9hdHRlbXB0U3RyKHRoaXMuX2ludGVycG9sYXRpb25Db25maWcuc3RhcnQpKSB7XG4gICAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKHRoaXMuX2ludGVycG9sYXRpb25Db25maWcuc3RhcnQpO1xuICAgICAgICAgICAgICAgICAgdGhpcy5faW5JbnRlcnBvbGF0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9pbnRlcnBvbGF0aW9uQ29uZmlnICYmIHRoaXMuX2F0dGVtcHRTdHIodGhpcy5faW50ZXJwb2xhdGlvbkNvbmZpZy5lbmQpICYmXG4gICAgICAgICAgICAgICAgICB0aGlzLl9pbkludGVycG9sYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgIHBhcnRzLnB1c2godGhpcy5faW50ZXJwb2xhdGlvbkNvbmZpZy5lbmQpO1xuICAgICAgICAgICAgICAgICAgdGhpcy5faW5JbnRlcnBvbGF0aW9uID0gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKHRoaXMuX3JlYWRDaGFyKHRydWUpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0gd2hpbGUgKCF0aGlzLl9pc1RleHRFbmQoKSk7XG4gICAgICAgICAgdGhpcy5fZW5kVG9rZW4oW3RoaXMuX3Byb2Nlc3NDYXJyaWFnZVJldHVybnMocGFydHMuam9pbignJykpXSk7XG4gICAgICB9O1xuICAgICAgX1Rva2VuaXplci5wcm90b3R5cGUuX2lzVGV4dEVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAodGhpcy5fcGVlayA9PT0gJExUIHx8IHRoaXMuX3BlZWsgPT09ICRFT0YpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLl90b2tlbml6ZUljdSAmJiAhdGhpcy5faW5JbnRlcnBvbGF0aW9uKSB7XG4gICAgICAgICAgICAgIGlmIChpc0V4cGFuc2lvbkZvcm1TdGFydCh0aGlzLl9pbnB1dCwgdGhpcy5faW5kZXgsIHRoaXMuX2ludGVycG9sYXRpb25Db25maWcpKSB7XG4gICAgICAgICAgICAgICAgICAvLyBzdGFydCBvZiBhbiBleHBhbnNpb24gZm9ybVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHRoaXMuX3BlZWsgPT09ICRSQlJBQ0UgJiYgdGhpcy5faXNJbkV4cGFuc2lvbkNhc2UoKSkge1xuICAgICAgICAgICAgICAgICAgLy8gZW5kIG9mIGFuZCBleHBhbnNpb24gY2FzZVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfTtcbiAgICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9zYXZlUG9zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIFt0aGlzLl9wZWVrLCB0aGlzLl9pbmRleCwgdGhpcy5fY29sdW1uLCB0aGlzLl9saW5lLCB0aGlzLnRva2Vucy5sZW5ndGhdO1xuICAgICAgfTtcbiAgICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9yZWFkVW50aWwgPSBmdW5jdGlvbiAoY2hhcikge1xuICAgICAgICAgIHZhciBzdGFydCA9IHRoaXMuX2luZGV4O1xuICAgICAgICAgIHRoaXMuX2F0dGVtcHRVbnRpbENoYXIoY2hhcik7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2lucHV0LnN1YnN0cmluZyhzdGFydCwgdGhpcy5faW5kZXgpO1xuICAgICAgfTtcbiAgICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9yZXN0b3JlUG9zaXRpb24gPSBmdW5jdGlvbiAocG9zaXRpb24pIHtcbiAgICAgICAgICB0aGlzLl9wZWVrID0gcG9zaXRpb25bMF07XG4gICAgICAgICAgdGhpcy5faW5kZXggPSBwb3NpdGlvblsxXTtcbiAgICAgICAgICB0aGlzLl9jb2x1bW4gPSBwb3NpdGlvblsyXTtcbiAgICAgICAgICB0aGlzLl9saW5lID0gcG9zaXRpb25bM107XG4gICAgICAgICAgdmFyIG5iVG9rZW5zID0gcG9zaXRpb25bNF07XG4gICAgICAgICAgaWYgKG5iVG9rZW5zIDwgdGhpcy50b2tlbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIC8vIHJlbW92ZSBhbnkgZXh0cmEgdG9rZW5zXG4gICAgICAgICAgICAgIHRoaXMudG9rZW5zID0gdGhpcy50b2tlbnMuc2xpY2UoMCwgbmJUb2tlbnMpO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5faXNJbkV4cGFuc2lvbkNhc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2V4cGFuc2lvbkNhc2VTdGFjay5sZW5ndGggPiAwICYmXG4gICAgICAgICAgICAgIHRoaXMuX2V4cGFuc2lvbkNhc2VTdGFja1t0aGlzLl9leHBhbnNpb25DYXNlU3RhY2subGVuZ3RoIC0gMV0gPT09XG4gICAgICAgICAgICAgICAgICBUb2tlblR5cGUkMS5FWFBBTlNJT05fQ0FTRV9FWFBfU1RBUlQ7XG4gICAgICB9O1xuICAgICAgX1Rva2VuaXplci5wcm90b3R5cGUuX2lzSW5FeHBhbnNpb25Gb3JtID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9leHBhbnNpb25DYXNlU3RhY2subGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgICB0aGlzLl9leHBhbnNpb25DYXNlU3RhY2tbdGhpcy5fZXhwYW5zaW9uQ2FzZVN0YWNrLmxlbmd0aCAtIDFdID09PVxuICAgICAgICAgICAgICAgICAgVG9rZW5UeXBlJDEuRVhQQU5TSU9OX0ZPUk1fU1RBUlQ7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIF9Ub2tlbml6ZXI7XG4gIH0oKSk7XG4gIGZ1bmN0aW9uIGlzTm90V2hpdGVzcGFjZShjb2RlKSB7XG4gICAgICByZXR1cm4gIWlzV2hpdGVzcGFjZShjb2RlKSB8fCBjb2RlID09PSAkRU9GO1xuICB9XG4gIGZ1bmN0aW9uIGlzTmFtZUVuZChjb2RlKSB7XG4gICAgICByZXR1cm4gaXNXaGl0ZXNwYWNlKGNvZGUpIHx8IGNvZGUgPT09ICRHVCB8fCBjb2RlID09PSAkU0xBU0ggfHxcbiAgICAgICAgICBjb2RlID09PSAkU1EgfHwgY29kZSA9PT0gJERRIHx8IGNvZGUgPT09ICRFUTtcbiAgfVxuICBmdW5jdGlvbiBpc1ByZWZpeEVuZChjb2RlKSB7XG4gICAgICByZXR1cm4gKGNvZGUgPCAkYSB8fCAkeiA8IGNvZGUpICYmIChjb2RlIDwgJEEgfHwgJFogPCBjb2RlKSAmJlxuICAgICAgICAgIChjb2RlIDwgJDAgfHwgY29kZSA+ICQ5KTtcbiAgfVxuICBmdW5jdGlvbiBpc0RpZ2l0RW50aXR5RW5kKGNvZGUpIHtcbiAgICAgIHJldHVybiBjb2RlID09ICRTRU1JQ09MT04gfHwgY29kZSA9PSAkRU9GIHx8ICFpc0FzY2lpSGV4RGlnaXQoY29kZSk7XG4gIH1cbiAgZnVuY3Rpb24gaXNOYW1lZEVudGl0eUVuZChjb2RlKSB7XG4gICAgICByZXR1cm4gY29kZSA9PSAkU0VNSUNPTE9OIHx8IGNvZGUgPT0gJEVPRiB8fCAhaXNBc2NpaUxldHRlcihjb2RlKTtcbiAgfVxuICBmdW5jdGlvbiBpc0V4cGFuc2lvbkZvcm1TdGFydChpbnB1dCwgb2Zmc2V0LCBpbnRlcnBvbGF0aW9uQ29uZmlnKSB7XG4gICAgICB2YXIgaXNJbnRlcnBvbGF0aW9uU3RhcnQgPSBpbnRlcnBvbGF0aW9uQ29uZmlnID8gaW5wdXQuaW5kZXhPZihpbnRlcnBvbGF0aW9uQ29uZmlnLnN0YXJ0LCBvZmZzZXQpID09IG9mZnNldCA6IGZhbHNlO1xuICAgICAgcmV0dXJuIGlucHV0LmNoYXJDb2RlQXQob2Zmc2V0KSA9PSAkTEJSQUNFICYmICFpc0ludGVycG9sYXRpb25TdGFydDtcbiAgfVxuICBmdW5jdGlvbiBpc0V4cGFuc2lvbkNhc2VTdGFydChwZWVrKSB7XG4gICAgICByZXR1cm4gcGVlayA9PT0gJEVRIHx8IGlzQXNjaWlMZXR0ZXIocGVlayk7XG4gIH1cbiAgZnVuY3Rpb24gY29tcGFyZUNoYXJDb2RlQ2FzZUluc2Vuc2l0aXZlKGNvZGUxLCBjb2RlMikge1xuICAgICAgcmV0dXJuIHRvVXBwZXJDYXNlQ2hhckNvZGUoY29kZTEpID09IHRvVXBwZXJDYXNlQ2hhckNvZGUoY29kZTIpO1xuICB9XG4gIGZ1bmN0aW9uIHRvVXBwZXJDYXNlQ2hhckNvZGUoY29kZSkge1xuICAgICAgcmV0dXJuIGNvZGUgPj0gJGEgJiYgY29kZSA8PSAkeiA/IGNvZGUgLSAkYSArICRBIDogY29kZTtcbiAgfVxuICBmdW5jdGlvbiBtZXJnZVRleHRUb2tlbnMoc3JjVG9rZW5zKSB7XG4gICAgICB2YXIgZHN0VG9rZW5zID0gW107XG4gICAgICB2YXIgbGFzdERzdFRva2VuO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzcmNUb2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgdG9rZW4gPSBzcmNUb2tlbnNbaV07XG4gICAgICAgICAgaWYgKGxhc3REc3RUb2tlbiAmJiBsYXN0RHN0VG9rZW4udHlwZSA9PSBUb2tlblR5cGUkMS5URVhUICYmIHRva2VuLnR5cGUgPT0gVG9rZW5UeXBlJDEuVEVYVCkge1xuICAgICAgICAgICAgICBsYXN0RHN0VG9rZW4ucGFydHNbMF0gKz0gdG9rZW4ucGFydHNbMF07XG4gICAgICAgICAgICAgIGxhc3REc3RUb2tlbi5zb3VyY2VTcGFuLmVuZCA9IHRva2VuLnNvdXJjZVNwYW4uZW5kO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgbGFzdERzdFRva2VuID0gdG9rZW47XG4gICAgICAgICAgICAgIGRzdFRva2Vucy5wdXNoKGxhc3REc3RUb2tlbik7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGRzdFRva2VucztcbiAgfVxuXG4gIC8qKlxuICAgKiBAbGljZW5zZVxuICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICpcbiAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgKi9cbiAgdmFyIF9fZXh0ZW5kcyQzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICB9O1xuICB2YXIgVHJlZUVycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQzKFRyZWVFcnJvciwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIFRyZWVFcnJvcihlbGVtZW50TmFtZSwgc3BhbiwgbXNnKSB7XG4gICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgc3BhbiwgbXNnKTtcbiAgICAgICAgICB0aGlzLmVsZW1lbnROYW1lID0gZWxlbWVudE5hbWU7XG4gICAgICB9XG4gICAgICBUcmVlRXJyb3IuY3JlYXRlID0gZnVuY3Rpb24gKGVsZW1lbnROYW1lLCBzcGFuLCBtc2cpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFRyZWVFcnJvcihlbGVtZW50TmFtZSwgc3BhbiwgbXNnKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gVHJlZUVycm9yO1xuICB9KFBhcnNlRXJyb3IpKTtcbiAgdmFyIFBhcnNlVHJlZVJlc3VsdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBQYXJzZVRyZWVSZXN1bHQocm9vdE5vZGVzLCBlcnJvcnMpIHtcbiAgICAgICAgICB0aGlzLnJvb3ROb2RlcyA9IHJvb3ROb2RlcztcbiAgICAgICAgICB0aGlzLmVycm9ycyA9IGVycm9ycztcbiAgICAgIH1cbiAgICAgIHJldHVybiBQYXJzZVRyZWVSZXN1bHQ7XG4gIH0oKSk7XG4gIHZhciBQYXJzZXIkMSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBQYXJzZXIoZ2V0VGFnRGVmaW5pdGlvbikge1xuICAgICAgICAgIHRoaXMuZ2V0VGFnRGVmaW5pdGlvbiA9IGdldFRhZ0RlZmluaXRpb247XG4gICAgICB9XG4gICAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKHNvdXJjZSwgdXJsLCBwYXJzZUV4cGFuc2lvbkZvcm1zLCBpbnRlcnBvbGF0aW9uQ29uZmlnKSB7XG4gICAgICAgICAgaWYgKHBhcnNlRXhwYW5zaW9uRm9ybXMgPT09IHZvaWQgMCkgeyBwYXJzZUV4cGFuc2lvbkZvcm1zID0gZmFsc2U7IH1cbiAgICAgICAgICBpZiAoaW50ZXJwb2xhdGlvbkNvbmZpZyA9PT0gdm9pZCAwKSB7IGludGVycG9sYXRpb25Db25maWcgPSBERUZBVUxUX0lOVEVSUE9MQVRJT05fQ09ORklHOyB9XG4gICAgICAgICAgdmFyIHRva2Vuc0FuZEVycm9ycyA9IHRva2VuaXplKHNvdXJjZSwgdXJsLCB0aGlzLmdldFRhZ0RlZmluaXRpb24sIHBhcnNlRXhwYW5zaW9uRm9ybXMsIGludGVycG9sYXRpb25Db25maWcpO1xuICAgICAgICAgIHZhciB0cmVlQW5kRXJyb3JzID0gbmV3IF9UcmVlQnVpbGRlcih0b2tlbnNBbmRFcnJvcnMudG9rZW5zLCB0aGlzLmdldFRhZ0RlZmluaXRpb24pLmJ1aWxkKCk7XG4gICAgICAgICAgcmV0dXJuIG5ldyBQYXJzZVRyZWVSZXN1bHQodHJlZUFuZEVycm9ycy5yb290Tm9kZXMsIHRva2Vuc0FuZEVycm9ycy5lcnJvcnMuY29uY2F0KHRyZWVBbmRFcnJvcnMuZXJyb3JzKSk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIFBhcnNlcjtcbiAgfSgpKTtcbiAgdmFyIF9UcmVlQnVpbGRlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBfVHJlZUJ1aWxkZXIodG9rZW5zLCBnZXRUYWdEZWZpbml0aW9uKSB7XG4gICAgICAgICAgdGhpcy50b2tlbnMgPSB0b2tlbnM7XG4gICAgICAgICAgdGhpcy5nZXRUYWdEZWZpbml0aW9uID0gZ2V0VGFnRGVmaW5pdGlvbjtcbiAgICAgICAgICB0aGlzLl9pbmRleCA9IC0xO1xuICAgICAgICAgIHRoaXMuX3Jvb3ROb2RlcyA9IFtdO1xuICAgICAgICAgIHRoaXMuX2Vycm9ycyA9IFtdO1xuICAgICAgICAgIHRoaXMuX2VsZW1lbnRTdGFjayA9IFtdO1xuICAgICAgICAgIHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgIH1cbiAgICAgIF9UcmVlQnVpbGRlci5wcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgd2hpbGUgKHRoaXMuX3BlZWsudHlwZSAhPT0gVG9rZW5UeXBlJDEuRU9GKSB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLl9wZWVrLnR5cGUgPT09IFRva2VuVHlwZSQxLlRBR19PUEVOX1NUQVJUKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9jb25zdW1lU3RhcnRUYWcodGhpcy5fYWR2YW5jZSgpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9wZWVrLnR5cGUgPT09IFRva2VuVHlwZSQxLlRBR19DTE9TRSkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5fY29uc3VtZUVuZFRhZyh0aGlzLl9hZHZhbmNlKCkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX3BlZWsudHlwZSA9PT0gVG9rZW5UeXBlJDEuQ0RBVEFfU1RBUlQpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2Nsb3NlVm9pZEVsZW1lbnQoKTtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVDZGF0YSh0aGlzLl9hZHZhbmNlKCkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX3BlZWsudHlwZSA9PT0gVG9rZW5UeXBlJDEuQ09NTUVOVF9TVEFSVCkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5fY2xvc2VWb2lkRWxlbWVudCgpO1xuICAgICAgICAgICAgICAgICAgdGhpcy5fY29uc3VtZUNvbW1lbnQodGhpcy5fYWR2YW5jZSgpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9wZWVrLnR5cGUgPT09IFRva2VuVHlwZSQxLlRFWFQgfHwgdGhpcy5fcGVlay50eXBlID09PSBUb2tlblR5cGUkMS5SQVdfVEVYVCB8fFxuICAgICAgICAgICAgICAgICAgdGhpcy5fcGVlay50eXBlID09PSBUb2tlblR5cGUkMS5FU0NBUEFCTEVfUkFXX1RFWFQpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2Nsb3NlVm9pZEVsZW1lbnQoKTtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVUZXh0KHRoaXMuX2FkdmFuY2UoKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fcGVlay50eXBlID09PSBUb2tlblR5cGUkMS5FWFBBTlNJT05fRk9STV9TVEFSVCkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5fY29uc3VtZUV4cGFuc2lvbih0aGlzLl9hZHZhbmNlKCkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgLy8gU2tpcCBhbGwgb3RoZXIgdG9rZW5zLi4uXG4gICAgICAgICAgICAgICAgICB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5ldyBQYXJzZVRyZWVSZXN1bHQodGhpcy5fcm9vdE5vZGVzLCB0aGlzLl9lcnJvcnMpO1xuICAgICAgfTtcbiAgICAgIF9UcmVlQnVpbGRlci5wcm90b3R5cGUuX2FkdmFuY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHByZXYgPSB0aGlzLl9wZWVrO1xuICAgICAgICAgIGlmICh0aGlzLl9pbmRleCA8IHRoaXMudG9rZW5zLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgLy8gTm90ZTogdGhlcmUgaXMgYWx3YXlzIGFuIEVPRiB0b2tlbiBhdCB0aGUgZW5kXG4gICAgICAgICAgICAgIHRoaXMuX2luZGV4Kys7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX3BlZWsgPSB0aGlzLnRva2Vuc1t0aGlzLl9pbmRleF07XG4gICAgICAgICAgcmV0dXJuIHByZXY7XG4gICAgICB9O1xuICAgICAgX1RyZWVCdWlsZGVyLnByb3RvdHlwZS5fYWR2YW5jZUlmID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgICBpZiAodGhpcy5fcGVlay50eXBlID09PSB0eXBlKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcbiAgICAgIF9UcmVlQnVpbGRlci5wcm90b3R5cGUuX2NvbnN1bWVDZGF0YSA9IGZ1bmN0aW9uIChzdGFydFRva2VuKSB7XG4gICAgICAgICAgdGhpcy5fY29uc3VtZVRleHQodGhpcy5fYWR2YW5jZSgpKTtcbiAgICAgICAgICB0aGlzLl9hZHZhbmNlSWYoVG9rZW5UeXBlJDEuQ0RBVEFfRU5EKTtcbiAgICAgIH07XG4gICAgICBfVHJlZUJ1aWxkZXIucHJvdG90eXBlLl9jb25zdW1lQ29tbWVudCA9IGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgICAgIHZhciB0ZXh0ID0gdGhpcy5fYWR2YW5jZUlmKFRva2VuVHlwZSQxLlJBV19URVhUKTtcbiAgICAgICAgICB0aGlzLl9hZHZhbmNlSWYoVG9rZW5UeXBlJDEuQ09NTUVOVF9FTkQpO1xuICAgICAgICAgIHZhciB2YWx1ZSA9IGlzUHJlc2VudCh0ZXh0KSA/IHRleHQucGFydHNbMF0udHJpbSgpIDogbnVsbDtcbiAgICAgICAgICB0aGlzLl9hZGRUb1BhcmVudChuZXcgQ29tbWVudCh2YWx1ZSwgdG9rZW4uc291cmNlU3BhbikpO1xuICAgICAgfTtcbiAgICAgIF9UcmVlQnVpbGRlci5wcm90b3R5cGUuX2NvbnN1bWVFeHBhbnNpb24gPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgICAgICB2YXIgc3dpdGNoVmFsdWUgPSB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgICAgdmFyIHR5cGUgPSB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgICAgdmFyIGNhc2VzID0gW107XG4gICAgICAgICAgLy8gcmVhZCA9XG4gICAgICAgICAgd2hpbGUgKHRoaXMuX3BlZWsudHlwZSA9PT0gVG9rZW5UeXBlJDEuRVhQQU5TSU9OX0NBU0VfVkFMVUUpIHtcbiAgICAgICAgICAgICAgdmFyIGV4cENhc2UgPSB0aGlzLl9wYXJzZUV4cGFuc2lvbkNhc2UoKTtcbiAgICAgICAgICAgICAgaWYgKCFleHBDYXNlKVxuICAgICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBlcnJvclxuICAgICAgICAgICAgICBjYXNlcy5wdXNoKGV4cENhc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyByZWFkIHRoZSBmaW5hbCB9XG4gICAgICAgICAgaWYgKHRoaXMuX3BlZWsudHlwZSAhPT0gVG9rZW5UeXBlJDEuRVhQQU5TSU9OX0ZPUk1fRU5EKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2Vycm9ycy5wdXNoKFRyZWVFcnJvci5jcmVhdGUobnVsbCwgdGhpcy5fcGVlay5zb3VyY2VTcGFuLCBcIkludmFsaWQgSUNVIG1lc3NhZ2UuIE1pc3NpbmcgJ30nLlwiKSk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHNvdXJjZVNwYW4gPSBuZXcgUGFyc2VTb3VyY2VTcGFuKHRva2VuLnNvdXJjZVNwYW4uc3RhcnQsIHRoaXMuX3BlZWsuc291cmNlU3Bhbi5lbmQpO1xuICAgICAgICAgIHRoaXMuX2FkZFRvUGFyZW50KG5ldyBFeHBhbnNpb24oc3dpdGNoVmFsdWUucGFydHNbMF0sIHR5cGUucGFydHNbMF0sIGNhc2VzLCBzb3VyY2VTcGFuLCBzd2l0Y2hWYWx1ZS5zb3VyY2VTcGFuKSk7XG4gICAgICAgICAgdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgfTtcbiAgICAgIF9UcmVlQnVpbGRlci5wcm90b3R5cGUuX3BhcnNlRXhwYW5zaW9uQ2FzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgICAgLy8gcmVhZCB7XG4gICAgICAgICAgaWYgKHRoaXMuX3BlZWsudHlwZSAhPT0gVG9rZW5UeXBlJDEuRVhQQU5TSU9OX0NBU0VfRVhQX1NUQVJUKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2Vycm9ycy5wdXNoKFRyZWVFcnJvci5jcmVhdGUobnVsbCwgdGhpcy5fcGVlay5zb3VyY2VTcGFuLCBcIkludmFsaWQgSUNVIG1lc3NhZ2UuIE1pc3NpbmcgJ3snLlwiKSk7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyByZWFkIHVudGlsIH1cbiAgICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgICAgdmFyIGV4cCA9IHRoaXMuX2NvbGxlY3RFeHBhbnNpb25FeHBUb2tlbnMoc3RhcnQpO1xuICAgICAgICAgIGlmICghZXhwKVxuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB2YXIgZW5kID0gdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICAgIGV4cC5wdXNoKG5ldyBUb2tlbiQxKFRva2VuVHlwZSQxLkVPRiwgW10sIGVuZC5zb3VyY2VTcGFuKSk7XG4gICAgICAgICAgLy8gcGFyc2UgZXZlcnl0aGluZyBpbiBiZXR3ZWVuIHsgYW5kIH1cbiAgICAgICAgICB2YXIgcGFyc2VkRXhwID0gbmV3IF9UcmVlQnVpbGRlcihleHAsIHRoaXMuZ2V0VGFnRGVmaW5pdGlvbikuYnVpbGQoKTtcbiAgICAgICAgICBpZiAocGFyc2VkRXhwLmVycm9ycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2Vycm9ycyA9IHRoaXMuX2Vycm9ycy5jb25jYXQocGFyc2VkRXhwLmVycm9ycyk7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgc291cmNlU3BhbiA9IG5ldyBQYXJzZVNvdXJjZVNwYW4odmFsdWUuc291cmNlU3Bhbi5zdGFydCwgZW5kLnNvdXJjZVNwYW4uZW5kKTtcbiAgICAgICAgICB2YXIgZXhwU291cmNlU3BhbiA9IG5ldyBQYXJzZVNvdXJjZVNwYW4oc3RhcnQuc291cmNlU3Bhbi5zdGFydCwgZW5kLnNvdXJjZVNwYW4uZW5kKTtcbiAgICAgICAgICByZXR1cm4gbmV3IEV4cGFuc2lvbkNhc2UodmFsdWUucGFydHNbMF0sIHBhcnNlZEV4cC5yb290Tm9kZXMsIHNvdXJjZVNwYW4sIHZhbHVlLnNvdXJjZVNwYW4sIGV4cFNvdXJjZVNwYW4pO1xuICAgICAgfTtcbiAgICAgIF9UcmVlQnVpbGRlci5wcm90b3R5cGUuX2NvbGxlY3RFeHBhbnNpb25FeHBUb2tlbnMgPSBmdW5jdGlvbiAoc3RhcnQpIHtcbiAgICAgICAgICB2YXIgZXhwID0gW107XG4gICAgICAgICAgdmFyIGV4cGFuc2lvbkZvcm1TdGFjayA9IFtUb2tlblR5cGUkMS5FWFBBTlNJT05fQ0FTRV9FWFBfU1RBUlRdO1xuICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLl9wZWVrLnR5cGUgPT09IFRva2VuVHlwZSQxLkVYUEFOU0lPTl9GT1JNX1NUQVJUIHx8XG4gICAgICAgICAgICAgICAgICB0aGlzLl9wZWVrLnR5cGUgPT09IFRva2VuVHlwZSQxLkVYUEFOU0lPTl9DQVNFX0VYUF9TVEFSVCkge1xuICAgICAgICAgICAgICAgICAgZXhwYW5zaW9uRm9ybVN0YWNrLnB1c2godGhpcy5fcGVlay50eXBlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAodGhpcy5fcGVlay50eXBlID09PSBUb2tlblR5cGUkMS5FWFBBTlNJT05fQ0FTRV9FWFBfRU5EKSB7XG4gICAgICAgICAgICAgICAgICBpZiAobGFzdE9uU3RhY2soZXhwYW5zaW9uRm9ybVN0YWNrLCBUb2tlblR5cGUkMS5FWFBBTlNJT05fQ0FTRV9FWFBfU1RBUlQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgZXhwYW5zaW9uRm9ybVN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChleHBhbnNpb25Gb3JtU3RhY2subGVuZ3RoID09IDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBleHA7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9lcnJvcnMucHVzaChUcmVlRXJyb3IuY3JlYXRlKG51bGwsIHN0YXJ0LnNvdXJjZVNwYW4sIFwiSW52YWxpZCBJQ1UgbWVzc2FnZS4gTWlzc2luZyAnfScuXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAodGhpcy5fcGVlay50eXBlID09PSBUb2tlblR5cGUkMS5FWFBBTlNJT05fRk9STV9FTkQpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChsYXN0T25TdGFjayhleHBhbnNpb25Gb3JtU3RhY2ssIFRva2VuVHlwZSQxLkVYUEFOU0lPTl9GT1JNX1NUQVJUKSkge1xuICAgICAgICAgICAgICAgICAgICAgIGV4cGFuc2lvbkZvcm1TdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2Vycm9ycy5wdXNoKFRyZWVFcnJvci5jcmVhdGUobnVsbCwgc3RhcnQuc291cmNlU3BhbiwgXCJJbnZhbGlkIElDVSBtZXNzYWdlLiBNaXNzaW5nICd9Jy5cIikpO1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICh0aGlzLl9wZWVrLnR5cGUgPT09IFRva2VuVHlwZSQxLkVPRikge1xuICAgICAgICAgICAgICAgICAgdGhpcy5fZXJyb3JzLnB1c2goVHJlZUVycm9yLmNyZWF0ZShudWxsLCBzdGFydC5zb3VyY2VTcGFuLCBcIkludmFsaWQgSUNVIG1lc3NhZ2UuIE1pc3NpbmcgJ30nLlwiKSk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBleHAucHVzaCh0aGlzLl9hZHZhbmNlKCkpO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICBfVHJlZUJ1aWxkZXIucHJvdG90eXBlLl9jb25zdW1lVGV4dCA9IGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgICAgIHZhciB0ZXh0ID0gdG9rZW4ucGFydHNbMF07XG4gICAgICAgICAgaWYgKHRleHQubGVuZ3RoID4gMCAmJiB0ZXh0WzBdID09ICdcXG4nKSB7XG4gICAgICAgICAgICAgIHZhciBwYXJlbnRfMSA9IHRoaXMuX2dldFBhcmVudEVsZW1lbnQoKTtcbiAgICAgICAgICAgICAgaWYgKGlzUHJlc2VudChwYXJlbnRfMSkgJiYgcGFyZW50XzEuY2hpbGRyZW4ubGVuZ3RoID09IDAgJiZcbiAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0VGFnRGVmaW5pdGlvbihwYXJlbnRfMS5uYW1lKS5pZ25vcmVGaXJzdExmKSB7XG4gICAgICAgICAgICAgICAgICB0ZXh0ID0gdGV4dC5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRleHQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICB0aGlzLl9hZGRUb1BhcmVudChuZXcgVGV4dCh0ZXh0LCB0b2tlbi5zb3VyY2VTcGFuKSk7XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIF9UcmVlQnVpbGRlci5wcm90b3R5cGUuX2Nsb3NlVm9pZEVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX2VsZW1lbnRTdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIHZhciBlbCA9IHRoaXMuX2VsZW1lbnRTdGFja1t0aGlzLl9lbGVtZW50U3RhY2subGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgIGlmICh0aGlzLmdldFRhZ0RlZmluaXRpb24oZWwubmFtZSkuaXNWb2lkKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9lbGVtZW50U3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgX1RyZWVCdWlsZGVyLnByb3RvdHlwZS5fY29uc3VtZVN0YXJ0VGFnID0gZnVuY3Rpb24gKHN0YXJ0VGFnVG9rZW4pIHtcbiAgICAgICAgICB2YXIgcHJlZml4ID0gc3RhcnRUYWdUb2tlbi5wYXJ0c1swXTtcbiAgICAgICAgICB2YXIgbmFtZSA9IHN0YXJ0VGFnVG9rZW4ucGFydHNbMV07XG4gICAgICAgICAgdmFyIGF0dHJzID0gW107XG4gICAgICAgICAgd2hpbGUgKHRoaXMuX3BlZWsudHlwZSA9PT0gVG9rZW5UeXBlJDEuQVRUUl9OQU1FKSB7XG4gICAgICAgICAgICAgIGF0dHJzLnB1c2godGhpcy5fY29uc3VtZUF0dHIodGhpcy5fYWR2YW5jZSgpKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBmdWxsTmFtZSA9IHRoaXMuX2dldEVsZW1lbnRGdWxsTmFtZShwcmVmaXgsIG5hbWUsIHRoaXMuX2dldFBhcmVudEVsZW1lbnQoKSk7XG4gICAgICAgICAgdmFyIHNlbGZDbG9zaW5nID0gZmFsc2U7XG4gICAgICAgICAgLy8gTm90ZTogVGhlcmUgY291bGQgaGF2ZSBiZWVuIGEgdG9rZW5pemVyIGVycm9yXG4gICAgICAgICAgLy8gc28gdGhhdCB3ZSBkb24ndCBnZXQgYSB0b2tlbiBmb3IgdGhlIGVuZCB0YWcuLi5cbiAgICAgICAgICBpZiAodGhpcy5fcGVlay50eXBlID09PSBUb2tlblR5cGUkMS5UQUdfT1BFTl9FTkRfVk9JRCkge1xuICAgICAgICAgICAgICB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgICAgICAgIHNlbGZDbG9zaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgdmFyIHRhZ0RlZiA9IHRoaXMuZ2V0VGFnRGVmaW5pdGlvbihmdWxsTmFtZSk7XG4gICAgICAgICAgICAgIGlmICghKHRhZ0RlZi5jYW5TZWxmQ2xvc2UgfHwgZ2V0TnNQcmVmaXgoZnVsbE5hbWUpICE9PSBudWxsIHx8IHRhZ0RlZi5pc1ZvaWQpKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9lcnJvcnMucHVzaChUcmVlRXJyb3IuY3JlYXRlKGZ1bGxOYW1lLCBzdGFydFRhZ1Rva2VuLnNvdXJjZVNwYW4sIFwiT25seSB2b2lkIGFuZCBmb3JlaWduIGVsZW1lbnRzIGNhbiBiZSBzZWxmIGNsb3NlZCBcXFwiXCIgKyBzdGFydFRhZ1Rva2VuLnBhcnRzWzFdICsgXCJcXFwiXCIpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmICh0aGlzLl9wZWVrLnR5cGUgPT09IFRva2VuVHlwZSQxLlRBR19PUEVOX0VORCkge1xuICAgICAgICAgICAgICB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgICAgICAgIHNlbGZDbG9zaW5nID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBlbmQgPSB0aGlzLl9wZWVrLnNvdXJjZVNwYW4uc3RhcnQ7XG4gICAgICAgICAgdmFyIHNwYW4gPSBuZXcgUGFyc2VTb3VyY2VTcGFuKHN0YXJ0VGFnVG9rZW4uc291cmNlU3Bhbi5zdGFydCwgZW5kKTtcbiAgICAgICAgICB2YXIgZWwgPSBuZXcgRWxlbWVudChmdWxsTmFtZSwgYXR0cnMsIFtdLCBzcGFuLCBzcGFuLCBudWxsKTtcbiAgICAgICAgICB0aGlzLl9wdXNoRWxlbWVudChlbCk7XG4gICAgICAgICAgaWYgKHNlbGZDbG9zaW5nKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3BvcEVsZW1lbnQoZnVsbE5hbWUpO1xuICAgICAgICAgICAgICBlbC5lbmRTb3VyY2VTcGFuID0gc3BhbjtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgX1RyZWVCdWlsZGVyLnByb3RvdHlwZS5fcHVzaEVsZW1lbnQgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICBpZiAodGhpcy5fZWxlbWVudFN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgdmFyIHBhcmVudEVsID0gdGhpcy5fZWxlbWVudFN0YWNrW3RoaXMuX2VsZW1lbnRTdGFjay5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuZ2V0VGFnRGVmaW5pdGlvbihwYXJlbnRFbC5uYW1lKS5pc0Nsb3NlZEJ5Q2hpbGQoZWwubmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2VsZW1lbnRTdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgdGFnRGVmID0gdGhpcy5nZXRUYWdEZWZpbml0aW9uKGVsLm5hbWUpO1xuICAgICAgICAgIHZhciBfYSA9IHRoaXMuX2dldFBhcmVudEVsZW1lbnRTa2lwcGluZ0NvbnRhaW5lcnMoKSwgcGFyZW50ID0gX2EucGFyZW50LCBjb250YWluZXIgPSBfYS5jb250YWluZXI7XG4gICAgICAgICAgaWYgKGlzUHJlc2VudChwYXJlbnQpICYmIHRhZ0RlZi5yZXF1aXJlRXh0cmFQYXJlbnQocGFyZW50Lm5hbWUpKSB7XG4gICAgICAgICAgICAgIHZhciBuZXdQYXJlbnQgPSBuZXcgRWxlbWVudCh0YWdEZWYucGFyZW50VG9BZGQsIFtdLCBbXSwgZWwuc291cmNlU3BhbiwgZWwuc3RhcnRTb3VyY2VTcGFuLCBlbC5lbmRTb3VyY2VTcGFuKTtcbiAgICAgICAgICAgICAgdGhpcy5faW5zZXJ0QmVmb3JlQ29udGFpbmVyKHBhcmVudCwgY29udGFpbmVyLCBuZXdQYXJlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9hZGRUb1BhcmVudChlbCk7XG4gICAgICAgICAgdGhpcy5fZWxlbWVudFN0YWNrLnB1c2goZWwpO1xuICAgICAgfTtcbiAgICAgIF9UcmVlQnVpbGRlci5wcm90b3R5cGUuX2NvbnN1bWVFbmRUYWcgPSBmdW5jdGlvbiAoZW5kVGFnVG9rZW4pIHtcbiAgICAgICAgICB2YXIgZnVsbE5hbWUgPSB0aGlzLl9nZXRFbGVtZW50RnVsbE5hbWUoZW5kVGFnVG9rZW4ucGFydHNbMF0sIGVuZFRhZ1Rva2VuLnBhcnRzWzFdLCB0aGlzLl9nZXRQYXJlbnRFbGVtZW50KCkpO1xuICAgICAgICAgIGlmICh0aGlzLl9nZXRQYXJlbnRFbGVtZW50KCkpIHtcbiAgICAgICAgICAgICAgdGhpcy5fZ2V0UGFyZW50RWxlbWVudCgpLmVuZFNvdXJjZVNwYW4gPSBlbmRUYWdUb2tlbi5zb3VyY2VTcGFuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy5nZXRUYWdEZWZpbml0aW9uKGZ1bGxOYW1lKS5pc1ZvaWQpIHtcbiAgICAgICAgICAgICAgdGhpcy5fZXJyb3JzLnB1c2goVHJlZUVycm9yLmNyZWF0ZShmdWxsTmFtZSwgZW5kVGFnVG9rZW4uc291cmNlU3BhbiwgXCJWb2lkIGVsZW1lbnRzIGRvIG5vdCBoYXZlIGVuZCB0YWdzIFxcXCJcIiArIGVuZFRhZ1Rva2VuLnBhcnRzWzFdICsgXCJcXFwiXCIpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoIXRoaXMuX3BvcEVsZW1lbnQoZnVsbE5hbWUpKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2Vycm9ycy5wdXNoKFRyZWVFcnJvci5jcmVhdGUoZnVsbE5hbWUsIGVuZFRhZ1Rva2VuLnNvdXJjZVNwYW4sIFwiVW5leHBlY3RlZCBjbG9zaW5nIHRhZyBcXFwiXCIgKyBlbmRUYWdUb2tlbi5wYXJ0c1sxXSArIFwiXFxcIlwiKSk7XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIF9UcmVlQnVpbGRlci5wcm90b3R5cGUuX3BvcEVsZW1lbnQgPSBmdW5jdGlvbiAoZnVsbE5hbWUpIHtcbiAgICAgICAgICBmb3IgKHZhciBzdGFja0luZGV4ID0gdGhpcy5fZWxlbWVudFN0YWNrLmxlbmd0aCAtIDE7IHN0YWNrSW5kZXggPj0gMDsgc3RhY2tJbmRleC0tKSB7XG4gICAgICAgICAgICAgIHZhciBlbCA9IHRoaXMuX2VsZW1lbnRTdGFja1tzdGFja0luZGV4XTtcbiAgICAgICAgICAgICAgaWYgKGVsLm5hbWUgPT0gZnVsbE5hbWUpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2VsZW1lbnRTdGFjay5zcGxpY2Uoc3RhY2tJbmRleCwgdGhpcy5fZWxlbWVudFN0YWNrLmxlbmd0aCAtIHN0YWNrSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCF0aGlzLmdldFRhZ0RlZmluaXRpb24oZWwubmFtZSkuY2xvc2VkQnlQYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9O1xuICAgICAgX1RyZWVCdWlsZGVyLnByb3RvdHlwZS5fY29uc3VtZUF0dHIgPSBmdW5jdGlvbiAoYXR0ck5hbWUpIHtcbiAgICAgICAgICB2YXIgZnVsbE5hbWUgPSBtZXJnZU5zQW5kTmFtZShhdHRyTmFtZS5wYXJ0c1swXSwgYXR0ck5hbWUucGFydHNbMV0pO1xuICAgICAgICAgIHZhciBlbmQgPSBhdHRyTmFtZS5zb3VyY2VTcGFuLmVuZDtcbiAgICAgICAgICB2YXIgdmFsdWUgPSAnJztcbiAgICAgICAgICB2YXIgdmFsdWVTcGFuO1xuICAgICAgICAgIGlmICh0aGlzLl9wZWVrLnR5cGUgPT09IFRva2VuVHlwZSQxLkFUVFJfVkFMVUUpIHtcbiAgICAgICAgICAgICAgdmFyIHZhbHVlVG9rZW4gPSB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgICAgICAgIHZhbHVlID0gdmFsdWVUb2tlbi5wYXJ0c1swXTtcbiAgICAgICAgICAgICAgZW5kID0gdmFsdWVUb2tlbi5zb3VyY2VTcGFuLmVuZDtcbiAgICAgICAgICAgICAgdmFsdWVTcGFuID0gdmFsdWVUb2tlbi5zb3VyY2VTcGFuO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3IEF0dHJpYnV0ZSQxKGZ1bGxOYW1lLCB2YWx1ZSwgbmV3IFBhcnNlU291cmNlU3BhbihhdHRyTmFtZS5zb3VyY2VTcGFuLnN0YXJ0LCBlbmQpLCB2YWx1ZVNwYW4pO1xuICAgICAgfTtcbiAgICAgIF9UcmVlQnVpbGRlci5wcm90b3R5cGUuX2dldFBhcmVudEVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2VsZW1lbnRTdGFjay5sZW5ndGggPiAwID8gdGhpcy5fZWxlbWVudFN0YWNrW3RoaXMuX2VsZW1lbnRTdGFjay5sZW5ndGggLSAxXSA6IG51bGw7XG4gICAgICB9O1xuICAgICAgLyoqXG4gICAgICAgKiBSZXR1cm5zIHRoZSBwYXJlbnQgaW4gdGhlIERPTSBhbmQgdGhlIGNvbnRhaW5lci5cbiAgICAgICAqXG4gICAgICAgKiBgPG5nLWNvbnRhaW5lcj5gIGVsZW1lbnRzIGFyZSBza2lwcGVkIGFzIHRoZXkgYXJlIG5vdCByZW5kZXJlZCBhcyBET00gZWxlbWVudC5cbiAgICAgICAqL1xuICAgICAgX1RyZWVCdWlsZGVyLnByb3RvdHlwZS5fZ2V0UGFyZW50RWxlbWVudFNraXBwaW5nQ29udGFpbmVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgY29udGFpbmVyID0gbnVsbDtcbiAgICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5fZWxlbWVudFN0YWNrLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLl9lbGVtZW50U3RhY2tbaV0ubmFtZSAhPT0gJ25nLWNvbnRhaW5lcicpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB7IHBhcmVudDogdGhpcy5fZWxlbWVudFN0YWNrW2ldLCBjb250YWluZXI6IGNvbnRhaW5lciB9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnRhaW5lciA9IHRoaXMuX2VsZW1lbnRTdGFja1tpXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHsgcGFyZW50OiB0aGlzLl9lbGVtZW50U3RhY2tbdGhpcy5fZWxlbWVudFN0YWNrLmxlbmd0aCAtIDFdLCBjb250YWluZXI6IGNvbnRhaW5lciB9O1xuICAgICAgfTtcbiAgICAgIF9UcmVlQnVpbGRlci5wcm90b3R5cGUuX2FkZFRvUGFyZW50ID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICB2YXIgcGFyZW50ID0gdGhpcy5fZ2V0UGFyZW50RWxlbWVudCgpO1xuICAgICAgICAgIGlmIChpc1ByZXNlbnQocGFyZW50KSkge1xuICAgICAgICAgICAgICBwYXJlbnQuY2hpbGRyZW4ucHVzaChub2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuX3Jvb3ROb2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICAvKipcbiAgICAgICAqIEluc2VydCBhIG5vZGUgYmV0d2VlbiB0aGUgcGFyZW50IGFuZCB0aGUgY29udGFpbmVyLlxuICAgICAgICogV2hlbiBubyBjb250YWluZXIgaXMgZ2l2ZW4sIHRoZSBub2RlIGlzIGFwcGVuZGVkIGFzIGEgY2hpbGQgb2YgdGhlIHBhcmVudC5cbiAgICAgICAqIEFsc28gdXBkYXRlcyB0aGUgZWxlbWVudCBzdGFjayBhY2NvcmRpbmdseS5cbiAgICAgICAqXG4gICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAqL1xuICAgICAgX1RyZWVCdWlsZGVyLnByb3RvdHlwZS5faW5zZXJ0QmVmb3JlQ29udGFpbmVyID0gZnVuY3Rpb24gKHBhcmVudCwgY29udGFpbmVyLCBub2RlKSB7XG4gICAgICAgICAgaWYgKCFjb250YWluZXIpIHtcbiAgICAgICAgICAgICAgdGhpcy5fYWRkVG9QYXJlbnQobm9kZSk7XG4gICAgICAgICAgICAgIHRoaXMuX2VsZW1lbnRTdGFjay5wdXNoKG5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgICAgICAgICAgLy8gcmVwbGFjZSB0aGUgY29udGFpbmVyIHdpdGggdGhlIG5ldyBub2RlIGluIHRoZSBjaGlsZHJlblxuICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gcGFyZW50LmNoaWxkcmVuLmluZGV4T2YoY29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICAgIHBhcmVudC5jaGlsZHJlbltpbmRleF0gPSBub2RlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdGhpcy5fcm9vdE5vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbm9kZS5jaGlsZHJlbi5wdXNoKGNvbnRhaW5lcik7XG4gICAgICAgICAgICAgIHRoaXMuX2VsZW1lbnRTdGFjay5zcGxpY2UodGhpcy5fZWxlbWVudFN0YWNrLmluZGV4T2YoY29udGFpbmVyKSwgMCwgbm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIF9UcmVlQnVpbGRlci5wcm90b3R5cGUuX2dldEVsZW1lbnRGdWxsTmFtZSA9IGZ1bmN0aW9uIChwcmVmaXgsIGxvY2FsTmFtZSwgcGFyZW50RWxlbWVudCkge1xuICAgICAgICAgIGlmIChpc0JsYW5rKHByZWZpeCkpIHtcbiAgICAgICAgICAgICAgcHJlZml4ID0gdGhpcy5nZXRUYWdEZWZpbml0aW9uKGxvY2FsTmFtZSkuaW1wbGljaXROYW1lc3BhY2VQcmVmaXg7XG4gICAgICAgICAgICAgIGlmIChpc0JsYW5rKHByZWZpeCkgJiYgaXNQcmVzZW50KHBhcmVudEVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgICBwcmVmaXggPSBnZXROc1ByZWZpeChwYXJlbnRFbGVtZW50Lm5hbWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBtZXJnZU5zQW5kTmFtZShwcmVmaXgsIGxvY2FsTmFtZSk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIF9UcmVlQnVpbGRlcjtcbiAgfSgpKTtcbiAgZnVuY3Rpb24gbGFzdE9uU3RhY2soc3RhY2ssIGVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBzdGFjay5sZW5ndGggPiAwICYmIHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdID09PSBlbGVtZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIEBsaWNlbnNlXG4gICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgKlxuICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAqL1xuICBmdW5jdGlvbiBkaWdlc3RNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgIHJldHVybiBzaGExKHNlcmlhbGl6ZU5vZGVzKG1lc3NhZ2Uubm9kZXMpLmpvaW4oJycpICsgKFwiW1wiICsgbWVzc2FnZS5tZWFuaW5nICsgXCJdXCIpKTtcbiAgfVxuICAvKipcbiAgICogU2VyaWFsaXplIHRoZSBpMThuIGFzdCB0byBzb21ldGhpbmcgeG1sLWxpa2UgaW4gb3JkZXIgdG8gZ2VuZXJhdGUgYW4gVUlELlxuICAgKlxuICAgKiBUaGUgdmlzaXRvciBpcyBhbHNvIHVzZWQgaW4gdGhlIGkxOG4gcGFyc2VyIHRlc3RzXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgdmFyIF9TZXJpYWxpemVyVmlzaXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBfU2VyaWFsaXplclZpc2l0b3IoKSB7XG4gICAgICB9XG4gICAgICBfU2VyaWFsaXplclZpc2l0b3IucHJvdG90eXBlLnZpc2l0VGV4dCA9IGZ1bmN0aW9uICh0ZXh0LCBjb250ZXh0KSB7IHJldHVybiB0ZXh0LnZhbHVlOyB9O1xuICAgICAgX1NlcmlhbGl6ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdENvbnRhaW5lciA9IGZ1bmN0aW9uIChjb250YWluZXIsIGNvbnRleHQpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHJldHVybiBcIltcIiArIGNvbnRhaW5lci5jaGlsZHJlbi5tYXAoZnVuY3Rpb24gKGNoaWxkKSB7IHJldHVybiBjaGlsZC52aXNpdChfdGhpcyk7IH0pLmpvaW4oJywgJykgKyBcIl1cIjtcbiAgICAgIH07XG4gICAgICBfU2VyaWFsaXplclZpc2l0b3IucHJvdG90eXBlLnZpc2l0SWN1ID0gZnVuY3Rpb24gKGljdSwgY29udGV4dCkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgdmFyIHN0ckNhc2VzID0gT2JqZWN0LmtleXMoaWN1LmNhc2VzKS5tYXAoZnVuY3Rpb24gKGspIHsgcmV0dXJuIChrICsgXCIge1wiICsgaWN1LmNhc2VzW2tdLnZpc2l0KF90aGlzKSArIFwifVwiKTsgfSk7XG4gICAgICAgICAgcmV0dXJuIFwie1wiICsgaWN1LmV4cHJlc3Npb24gKyBcIiwgXCIgKyBpY3UudHlwZSArIFwiLCBcIiArIHN0ckNhc2VzLmpvaW4oJywgJykgKyBcIn1cIjtcbiAgICAgIH07XG4gICAgICBfU2VyaWFsaXplclZpc2l0b3IucHJvdG90eXBlLnZpc2l0VGFnUGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAocGgsIGNvbnRleHQpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHJldHVybiBwaC5pc1ZvaWQgP1xuICAgICAgICAgICAgICBcIjxwaCB0YWcgbmFtZT1cXFwiXCIgKyBwaC5zdGFydE5hbWUgKyBcIlxcXCIvPlwiIDpcbiAgICAgICAgICAgICAgXCI8cGggdGFnIG5hbWU9XFxcIlwiICsgcGguc3RhcnROYW1lICsgXCJcXFwiPlwiICsgcGguY2hpbGRyZW4ubWFwKGZ1bmN0aW9uIChjaGlsZCkgeyByZXR1cm4gY2hpbGQudmlzaXQoX3RoaXMpOyB9KS5qb2luKCcsICcpICsgXCI8L3BoIG5hbWU9XFxcIlwiICsgcGguY2xvc2VOYW1lICsgXCJcXFwiPlwiO1xuICAgICAgfTtcbiAgICAgIF9TZXJpYWxpemVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRQbGFjZWhvbGRlciA9IGZ1bmN0aW9uIChwaCwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiBcIjxwaCBuYW1lPVxcXCJcIiArIHBoLm5hbWUgKyBcIlxcXCI+XCIgKyBwaC52YWx1ZSArIFwiPC9waD5cIjtcbiAgICAgIH07XG4gICAgICBfU2VyaWFsaXplclZpc2l0b3IucHJvdG90eXBlLnZpc2l0SWN1UGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAocGgsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gXCI8cGggaWN1IG5hbWU9XFxcIlwiICsgcGgubmFtZSArIFwiXFxcIj5cIiArIHBoLnZhbHVlLnZpc2l0KHRoaXMpICsgXCI8L3BoPlwiO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBfU2VyaWFsaXplclZpc2l0b3I7XG4gIH0oKSk7XG4gIHZhciBzZXJpYWxpemVyVmlzaXRvciA9IG5ldyBfU2VyaWFsaXplclZpc2l0b3IoKTtcbiAgZnVuY3Rpb24gc2VyaWFsaXplTm9kZXMobm9kZXMpIHtcbiAgICAgIHJldHVybiBub2Rlcy5tYXAoZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGEudmlzaXQoc2VyaWFsaXplclZpc2l0b3IsIG51bGwpOyB9KTtcbiAgfVxuICAvKipcbiAgICogQ29tcHV0ZSB0aGUgU0hBMSBvZiB0aGUgZ2l2ZW4gc3RyaW5nXG4gICAqXG4gICAqIHNlZSBodHRwOi8vY3NyYy5uaXN0Lmdvdi9wdWJsaWNhdGlvbnMvZmlwcy9maXBzMTgwLTQvZmlwcy0xODAtNC5wZGZcbiAgICpcbiAgICogV0FSTklORzogdGhpcyBmdW5jdGlvbiBoYXMgbm90IGJlZW4gZGVzaWduZWQgbm90IHRlc3RlZCB3aXRoIHNlY3VyaXR5IGluIG1pbmQuXG4gICAqICAgICAgICAgIERPIE5PVCBVU0UgSVQgSU4gQSBTRUNVUklUWSBTRU5TSVRJVkUgQ09OVEVYVC5cbiAgICovXG4gIGZ1bmN0aW9uIHNoYTEoc3RyKSB7XG4gICAgICB2YXIgdXRmOCA9IHV0ZjhFbmNvZGUoc3RyKTtcbiAgICAgIHZhciB3b3JkczMyID0gc3RyaW5nVG9Xb3JkczMyKHV0ZjgpO1xuICAgICAgdmFyIGxlbiA9IHV0ZjgubGVuZ3RoICogODtcbiAgICAgIHZhciB3ID0gbmV3IEFycmF5KDgwKTtcbiAgICAgIHZhciBfYSA9IFsweDY3NDUyMzAxLCAweGVmY2RhYjg5LCAweDk4YmFkY2ZlLCAweDEwMzI1NDc2LCAweGMzZDJlMWYwXSwgYSA9IF9hWzBdLCBiID0gX2FbMV0sIGMgPSBfYVsyXSwgZCA9IF9hWzNdLCBlID0gX2FbNF07XG4gICAgICB3b3JkczMyW2xlbiA+PiA1XSB8PSAweDgwIDw8ICgyNCAtIGxlbiAlIDMyKTtcbiAgICAgIHdvcmRzMzJbKChsZW4gKyA2NCA+PiA5KSA8PCA0KSArIDE1XSA9IGxlbjtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgd29yZHMzMi5sZW5ndGg7IGkgKz0gMTYpIHtcbiAgICAgICAgICB2YXIgX2IgPSBbYSwgYiwgYywgZCwgZV0sIGgwID0gX2JbMF0sIGgxID0gX2JbMV0sIGgyID0gX2JbMl0sIGgzID0gX2JbM10sIGg0ID0gX2JbNF07XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCA4MDsgaisrKSB7XG4gICAgICAgICAgICAgIGlmIChqIDwgMTYpIHtcbiAgICAgICAgICAgICAgICAgIHdbal0gPSB3b3JkczMyW2kgKyBqXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHdbal0gPSByb2wzMih3W2ogLSAzXSBeIHdbaiAtIDhdIF4gd1tqIC0gMTRdIF4gd1tqIC0gMTZdLCAxKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2YXIgX2MgPSBmayhqLCBiLCBjLCBkKSwgZiA9IF9jWzBdLCBrID0gX2NbMV07XG4gICAgICAgICAgICAgIHZhciB0ZW1wID0gW3JvbDMyKGEsIDUpLCBmLCBlLCBrLCB3W2pdXS5yZWR1Y2UoYWRkMzIpO1xuICAgICAgICAgICAgICBfZCA9IFtkLCBjLCByb2wzMihiLCAzMCksIGEsIHRlbXBdLCBlID0gX2RbMF0sIGQgPSBfZFsxXSwgYyA9IF9kWzJdLCBiID0gX2RbM10sIGEgPSBfZFs0XTtcbiAgICAgICAgICB9XG4gICAgICAgICAgX2UgPSBbYWRkMzIoYSwgaDApLCBhZGQzMihiLCBoMSksIGFkZDMyKGMsIGgyKSwgYWRkMzIoZCwgaDMpLCBhZGQzMihlLCBoNCldLCBhID0gX2VbMF0sIGIgPSBfZVsxXSwgYyA9IF9lWzJdLCBkID0gX2VbM10sIGUgPSBfZVs0XTtcbiAgICAgIH1cbiAgICAgIHZhciBzaGExID0gd29yZHMzMlRvU3RyaW5nKFthLCBiLCBjLCBkLCBlXSk7XG4gICAgICB2YXIgaGV4ID0gJyc7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNoYTEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgYl8xID0gc2hhMS5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgIGhleCArPSAoYl8xID4+PiA0ICYgMHgwZikudG9TdHJpbmcoMTYpICsgKGJfMSAmIDB4MGYpLnRvU3RyaW5nKDE2KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBoZXgudG9Mb3dlckNhc2UoKTtcbiAgICAgIHZhciBfZCwgX2U7XG4gIH1cbiAgZnVuY3Rpb24gdXRmOEVuY29kZShzdHIpIHtcbiAgICAgIHZhciBlbmNvZGVkID0gJyc7XG4gICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgc3RyLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgIHZhciBjb2RlUG9pbnQgPSBkZWNvZGVTdXJyb2dhdGVQYWlycyhzdHIsIGluZGV4KTtcbiAgICAgICAgICBpZiAoY29kZVBvaW50IDw9IDB4N2YpIHtcbiAgICAgICAgICAgICAgZW5jb2RlZCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGVQb2ludCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKGNvZGVQb2ludCA8PSAweDdmZikge1xuICAgICAgICAgICAgICBlbmNvZGVkICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhjMCB8IGNvZGVQb2ludCA+Pj4gNiwgMHg4MCB8IGNvZGVQb2ludCAmIDB4M2YpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChjb2RlUG9pbnQgPD0gMHhmZmZmKSB7XG4gICAgICAgICAgICAgIGVuY29kZWQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgweGUwIHwgY29kZVBvaW50ID4+PiAxMiwgMHg4MCB8IGNvZGVQb2ludCA+Pj4gNiAmIDB4M2YsIDB4ODAgfCBjb2RlUG9pbnQgJiAweDNmKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoY29kZVBvaW50IDw9IDB4MWZmZmZmKSB7XG4gICAgICAgICAgICAgIGVuY29kZWQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgweGYwIHwgY29kZVBvaW50ID4+PiAxOCwgMHg4MCB8IGNvZGVQb2ludCA+Pj4gMTIgJiAweDNmLCAweDgwIHwgY29kZVBvaW50ID4+PiA2ICYgMHgzZiwgMHg4MCB8IGNvZGVQb2ludCAmIDB4M2YpO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBlbmNvZGVkO1xuICB9XG4gIC8vIHNlZSBodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZyNzdXJyb2dhdGUtZm9ybXVsYWVcbiAgZnVuY3Rpb24gZGVjb2RlU3Vycm9nYXRlUGFpcnMoc3RyLCBpbmRleCkge1xuICAgICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSBzdHIubGVuZ3RoKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW5kZXg9XCIgKyBpbmRleCArIFwiIGlzIG91dCBvZiByYW5nZSBpbiBcXFwiXCIgKyBzdHIgKyBcIlxcXCJcIik7XG4gICAgICB9XG4gICAgICB2YXIgaGlnaCA9IHN0ci5jaGFyQ29kZUF0KGluZGV4KTtcbiAgICAgIHZhciBsb3c7XG4gICAgICBpZiAoaGlnaCA+PSAweGQ4MDAgJiYgaGlnaCA8PSAweGRmZmYgJiYgc3RyLmxlbmd0aCA+IGluZGV4ICsgMSkge1xuICAgICAgICAgIGxvdyA9IHN0ci5jaGFyQ29kZUF0KGluZGV4ICsgMSk7XG4gICAgICAgICAgaWYgKGxvdyA+PSAweGRjMDAgJiYgbG93IDw9IDB4ZGZmZikge1xuICAgICAgICAgICAgICByZXR1cm4gKGhpZ2ggLSAweGQ4MDApICogMHg0MDAgKyBsb3cgLSAweGRjMDAgKyAweDEwMDAwO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBoaWdoO1xuICB9XG4gIGZ1bmN0aW9uIHN0cmluZ1RvV29yZHMzMihzdHIpIHtcbiAgICAgIHZhciB3b3JkczMyID0gQXJyYXkoc3RyLmxlbmd0aCA+Pj4gMik7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHdvcmRzMzIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB3b3JkczMyW2ldID0gMDtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgd29yZHMzMltpID4+PiAyXSB8PSAoc3RyLmNoYXJDb2RlQXQoaSkgJiAweGZmKSA8PCA4ICogKDMgLSBpICYgMHgzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3b3JkczMyO1xuICB9XG4gIGZ1bmN0aW9uIHdvcmRzMzJUb1N0cmluZyh3b3JkczMyKSB7XG4gICAgICB2YXIgc3RyID0gJyc7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHdvcmRzMzIubGVuZ3RoICogNDsgaSsrKSB7XG4gICAgICAgICAgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKHdvcmRzMzJbaSA+Pj4gMl0gPj4+IDggKiAoMyAtIGkgJiAweDMpKSAmIDB4ZmYpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0cjtcbiAgfVxuICBmdW5jdGlvbiBmayhpbmRleCwgYiwgYywgZCkge1xuICAgICAgaWYgKGluZGV4IDwgMjApIHtcbiAgICAgICAgICByZXR1cm4gWyhiICYgYykgfCAofmIgJiBkKSwgMHg1YTgyNzk5OV07XG4gICAgICB9XG4gICAgICBpZiAoaW5kZXggPCA0MCkge1xuICAgICAgICAgIHJldHVybiBbYiBeIGMgXiBkLCAweDZlZDllYmExXTtcbiAgICAgIH1cbiAgICAgIGlmIChpbmRleCA8IDYwKSB7XG4gICAgICAgICAgcmV0dXJuIFsoYiAmIGMpIHwgKGIgJiBkKSB8IChjICYgZCksIDB4OGYxYmJjZGNdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFtiIF4gYyBeIGQsIDB4Y2E2MmMxZDZdO1xuICB9XG4gIGZ1bmN0aW9uIGFkZDMyKGEsIGIpIHtcbiAgICAgIHZhciBsb3cgPSAoYSAmIDB4ZmZmZikgKyAoYiAmIDB4ZmZmZik7XG4gICAgICB2YXIgaGlnaCA9IChhID4+IDE2KSArIChiID4+IDE2KSArIChsb3cgPj4gMTYpO1xuICAgICAgcmV0dXJuIChoaWdoIDw8IDE2KSB8IChsb3cgJiAweGZmZmYpO1xuICB9XG4gIGZ1bmN0aW9uIHJvbDMyKGEsIGNvdW50KSB7XG4gICAgICByZXR1cm4gKGEgPDwgY291bnQpIHwgKGEgPj4+ICgzMiAtIGNvdW50KSk7XG4gIH1cblxuICAvKipcbiAgICogQGxpY2Vuc2VcbiAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAqXG4gICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICovXG4gIHZhciBNZXNzYWdlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIG5vZGVzIG1lc3NhZ2UgQVNUXG4gICAgICAgKiBAcGFyYW0gcGxhY2Vob2xkZXJzIG1hcHMgcGxhY2Vob2xkZXIgbmFtZXMgdG8gc3RhdGljIGNvbnRlbnRcbiAgICAgICAqIEBwYXJhbSBwbGFjZWhvbGRlclRvTXNnSWRzIG1hcHMgcGxhY2Vob2xkZXIgbmFtZXMgdG8gdHJhbnNsYXRhYmxlIG1lc3NhZ2UgSURzICh1c2VkIGZvciBJQ1VcbiAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VzKVxuICAgICAgICogQHBhcmFtIG1lYW5pbmdcbiAgICAgICAqIEBwYXJhbSBkZXNjcmlwdGlvblxuICAgICAgICovXG4gICAgICBmdW5jdGlvbiBNZXNzYWdlKG5vZGVzLCBwbGFjZWhvbGRlcnMsIHBsYWNlaG9sZGVyVG9Nc2dJZHMsIG1lYW5pbmcsIGRlc2NyaXB0aW9uKSB7XG4gICAgICAgICAgdGhpcy5ub2RlcyA9IG5vZGVzO1xuICAgICAgICAgIHRoaXMucGxhY2Vob2xkZXJzID0gcGxhY2Vob2xkZXJzO1xuICAgICAgICAgIHRoaXMucGxhY2Vob2xkZXJUb01zZ0lkcyA9IHBsYWNlaG9sZGVyVG9Nc2dJZHM7XG4gICAgICAgICAgdGhpcy5tZWFuaW5nID0gbWVhbmluZztcbiAgICAgICAgICB0aGlzLmRlc2NyaXB0aW9uID0gZGVzY3JpcHRpb247XG4gICAgICB9XG4gICAgICByZXR1cm4gTWVzc2FnZTtcbiAgfSgpKTtcbiAgdmFyIFRleHQkMSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBUZXh0KHZhbHVlLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgICB9XG4gICAgICBUZXh0LnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7IHJldHVybiB2aXNpdG9yLnZpc2l0VGV4dCh0aGlzLCBjb250ZXh0KTsgfTtcbiAgICAgIHJldHVybiBUZXh0O1xuICB9KCkpO1xuICB2YXIgQ29udGFpbmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIENvbnRhaW5lcihjaGlsZHJlbiwgc291cmNlU3Bhbikge1xuICAgICAgICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgICAgfVxuICAgICAgQ29udGFpbmVyLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7IHJldHVybiB2aXNpdG9yLnZpc2l0Q29udGFpbmVyKHRoaXMsIGNvbnRleHQpOyB9O1xuICAgICAgcmV0dXJuIENvbnRhaW5lcjtcbiAgfSgpKTtcbiAgdmFyIEljdSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBJY3UoZXhwcmVzc2lvbiwgdHlwZSwgY2FzZXMsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgICB0aGlzLmV4cHJlc3Npb24gPSBleHByZXNzaW9uO1xuICAgICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgICAgdGhpcy5jYXNlcyA9IGNhc2VzO1xuICAgICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgICB9XG4gICAgICBJY3UucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHsgcmV0dXJuIHZpc2l0b3IudmlzaXRJY3UodGhpcywgY29udGV4dCk7IH07XG4gICAgICByZXR1cm4gSWN1O1xuICB9KCkpO1xuICB2YXIgVGFnUGxhY2Vob2xkZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gVGFnUGxhY2Vob2xkZXIodGFnLCBhdHRycywgc3RhcnROYW1lLCBjbG9zZU5hbWUsIGNoaWxkcmVuLCBpc1ZvaWQsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgICB0aGlzLnRhZyA9IHRhZztcbiAgICAgICAgICB0aGlzLmF0dHJzID0gYXR0cnM7XG4gICAgICAgICAgdGhpcy5zdGFydE5hbWUgPSBzdGFydE5hbWU7XG4gICAgICAgICAgdGhpcy5jbG9zZU5hbWUgPSBjbG9zZU5hbWU7XG4gICAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgICAgIHRoaXMuaXNWb2lkID0gaXNWb2lkO1xuICAgICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgICB9XG4gICAgICBUYWdQbGFjZWhvbGRlci5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkgeyByZXR1cm4gdmlzaXRvci52aXNpdFRhZ1BsYWNlaG9sZGVyKHRoaXMsIGNvbnRleHQpOyB9O1xuICAgICAgcmV0dXJuIFRhZ1BsYWNlaG9sZGVyO1xuICB9KCkpO1xuICB2YXIgUGxhY2Vob2xkZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gUGxhY2Vob2xkZXIodmFsdWUsIG5hbWUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgICBpZiAobmFtZSA9PT0gdm9pZCAwKSB7IG5hbWUgPSAnJzsgfVxuICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgICB9XG4gICAgICBQbGFjZWhvbGRlci5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkgeyByZXR1cm4gdmlzaXRvci52aXNpdFBsYWNlaG9sZGVyKHRoaXMsIGNvbnRleHQpOyB9O1xuICAgICAgcmV0dXJuIFBsYWNlaG9sZGVyO1xuICB9KCkpO1xuICB2YXIgSWN1UGxhY2Vob2xkZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gSWN1UGxhY2Vob2xkZXIodmFsdWUsIG5hbWUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgICBpZiAobmFtZSA9PT0gdm9pZCAwKSB7IG5hbWUgPSAnJzsgfVxuICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgICB9XG4gICAgICBJY3VQbGFjZWhvbGRlci5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkgeyByZXR1cm4gdmlzaXRvci52aXNpdEljdVBsYWNlaG9sZGVyKHRoaXMsIGNvbnRleHQpOyB9O1xuICAgICAgcmV0dXJuIEljdVBsYWNlaG9sZGVyO1xuICB9KCkpO1xuXG4gIC8qKlxuICAgKiBAbGljZW5zZVxuICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICpcbiAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgKi9cbiAgdmFyIFRBR19UT19QTEFDRUhPTERFUl9OQU1FUyA9IHtcbiAgICAgICdBJzogJ0xJTksnLFxuICAgICAgJ0InOiAnQk9MRF9URVhUJyxcbiAgICAgICdCUic6ICdMSU5FX0JSRUFLJyxcbiAgICAgICdFTSc6ICdFTVBIQVNJU0VEX1RFWFQnLFxuICAgICAgJ0gxJzogJ0hFQURJTkdfTEVWRUwxJyxcbiAgICAgICdIMic6ICdIRUFESU5HX0xFVkVMMicsXG4gICAgICAnSDMnOiAnSEVBRElOR19MRVZFTDMnLFxuICAgICAgJ0g0JzogJ0hFQURJTkdfTEVWRUw0JyxcbiAgICAgICdINSc6ICdIRUFESU5HX0xFVkVMNScsXG4gICAgICAnSDYnOiAnSEVBRElOR19MRVZFTDYnLFxuICAgICAgJ0hSJzogJ0hPUklaT05UQUxfUlVMRScsXG4gICAgICAnSSc6ICdJVEFMSUNfVEVYVCcsXG4gICAgICAnTEknOiAnTElTVF9JVEVNJyxcbiAgICAgICdMSU5LJzogJ01FRElBX0xJTksnLFxuICAgICAgJ09MJzogJ09SREVSRURfTElTVCcsXG4gICAgICAnUCc6ICdQQVJBR1JBUEgnLFxuICAgICAgJ1EnOiAnUVVPVEFUSU9OJyxcbiAgICAgICdTJzogJ1NUUklLRVRIUk9VR0hfVEVYVCcsXG4gICAgICAnU01BTEwnOiAnU01BTExfVEVYVCcsXG4gICAgICAnU1VCJzogJ1NVQlNUUklQVCcsXG4gICAgICAnU1VQJzogJ1NVUEVSU0NSSVBUJyxcbiAgICAgICdUQk9EWSc6ICdUQUJMRV9CT0RZJyxcbiAgICAgICdURCc6ICdUQUJMRV9DRUxMJyxcbiAgICAgICdURk9PVCc6ICdUQUJMRV9GT09URVInLFxuICAgICAgJ1RIJzogJ1RBQkxFX0hFQURFUl9DRUxMJyxcbiAgICAgICdUSEVBRCc6ICdUQUJMRV9IRUFERVInLFxuICAgICAgJ1RSJzogJ1RBQkxFX1JPVycsXG4gICAgICAnVFQnOiAnTU9OT1NQQUNFRF9URVhUJyxcbiAgICAgICdVJzogJ1VOREVSTElORURfVEVYVCcsXG4gICAgICAnVUwnOiAnVU5PUkRFUkVEX0xJU1QnLFxuICB9O1xuICAvKipcbiAgICogQ3JlYXRlcyB1bmlxdWUgbmFtZXMgZm9yIHBsYWNlaG9sZGVyIHdpdGggZGlmZmVyZW50IGNvbnRlbnRcbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICB2YXIgUGxhY2Vob2xkZXJSZWdpc3RyeSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBQbGFjZWhvbGRlclJlZ2lzdHJ5KCkge1xuICAgICAgICAgIC8vIENvdW50IHRoZSBvY2N1cnJlbmNlIG9mIHRoZSBiYXNlIG5hbWUgdG9wIGdlbmVyYXRlIGEgdW5pcXVlIG5hbWVcbiAgICAgICAgICB0aGlzLl9wbGFjZUhvbGRlck5hbWVDb3VudHMgPSB7fTtcbiAgICAgICAgICAvLyBNYXBzIHNpZ25hdHVyZSB0byBwbGFjZWhvbGRlciBuYW1lc1xuICAgICAgICAgIHRoaXMuX3NpZ25hdHVyZVRvTmFtZSA9IHt9O1xuICAgICAgfVxuICAgICAgUGxhY2Vob2xkZXJSZWdpc3RyeS5wcm90b3R5cGUuZ2V0U3RhcnRUYWdQbGFjZWhvbGRlck5hbWUgPSBmdW5jdGlvbiAodGFnLCBhdHRycywgaXNWb2lkKSB7XG4gICAgICAgICAgdmFyIHNpZ25hdHVyZSA9IHRoaXMuX2hhc2hUYWcodGFnLCBhdHRycywgaXNWb2lkKTtcbiAgICAgICAgICBpZiAodGhpcy5fc2lnbmF0dXJlVG9OYW1lW3NpZ25hdHVyZV0pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NpZ25hdHVyZVRvTmFtZVtzaWduYXR1cmVdO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgdXBwZXJUYWcgPSB0YWcudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICB2YXIgYmFzZU5hbWUgPSBUQUdfVE9fUExBQ0VIT0xERVJfTkFNRVNbdXBwZXJUYWddIHx8IFwiVEFHX1wiICsgdXBwZXJUYWc7XG4gICAgICAgICAgdmFyIG5hbWUgPSB0aGlzLl9nZW5lcmF0ZVVuaXF1ZU5hbWUoaXNWb2lkID8gYmFzZU5hbWUgOiBcIlNUQVJUX1wiICsgYmFzZU5hbWUpO1xuICAgICAgICAgIHRoaXMuX3NpZ25hdHVyZVRvTmFtZVtzaWduYXR1cmVdID0gbmFtZTtcbiAgICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgIH07XG4gICAgICBQbGFjZWhvbGRlclJlZ2lzdHJ5LnByb3RvdHlwZS5nZXRDbG9zZVRhZ1BsYWNlaG9sZGVyTmFtZSA9IGZ1bmN0aW9uICh0YWcpIHtcbiAgICAgICAgICB2YXIgc2lnbmF0dXJlID0gdGhpcy5faGFzaENsb3NpbmdUYWcodGFnKTtcbiAgICAgICAgICBpZiAodGhpcy5fc2lnbmF0dXJlVG9OYW1lW3NpZ25hdHVyZV0pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NpZ25hdHVyZVRvTmFtZVtzaWduYXR1cmVdO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgdXBwZXJUYWcgPSB0YWcudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICB2YXIgYmFzZU5hbWUgPSBUQUdfVE9fUExBQ0VIT0xERVJfTkFNRVNbdXBwZXJUYWddIHx8IFwiVEFHX1wiICsgdXBwZXJUYWc7XG4gICAgICAgICAgdmFyIG5hbWUgPSB0aGlzLl9nZW5lcmF0ZVVuaXF1ZU5hbWUoXCJDTE9TRV9cIiArIGJhc2VOYW1lKTtcbiAgICAgICAgICB0aGlzLl9zaWduYXR1cmVUb05hbWVbc2lnbmF0dXJlXSA9IG5hbWU7XG4gICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICB9O1xuICAgICAgUGxhY2Vob2xkZXJSZWdpc3RyeS5wcm90b3R5cGUuZ2V0UGxhY2Vob2xkZXJOYW1lID0gZnVuY3Rpb24gKG5hbWUsIGNvbnRlbnQpIHtcbiAgICAgICAgICB2YXIgdXBwZXJOYW1lID0gbmFtZS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgIHZhciBzaWduYXR1cmUgPSBcIlBIOiBcIiArIHVwcGVyTmFtZSArIFwiPVwiICsgY29udGVudDtcbiAgICAgICAgICBpZiAodGhpcy5fc2lnbmF0dXJlVG9OYW1lW3NpZ25hdHVyZV0pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NpZ25hdHVyZVRvTmFtZVtzaWduYXR1cmVdO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgdW5pcXVlTmFtZSA9IHRoaXMuX2dlbmVyYXRlVW5pcXVlTmFtZSh1cHBlck5hbWUpO1xuICAgICAgICAgIHRoaXMuX3NpZ25hdHVyZVRvTmFtZVtzaWduYXR1cmVdID0gdW5pcXVlTmFtZTtcbiAgICAgICAgICByZXR1cm4gdW5pcXVlTmFtZTtcbiAgICAgIH07XG4gICAgICAvLyBHZW5lcmF0ZSBhIGhhc2ggZm9yIGEgdGFnIC0gZG9lcyBub3QgdGFrZSBhdHRyaWJ1dGUgb3JkZXIgaW50byBhY2NvdW50XG4gICAgICBQbGFjZWhvbGRlclJlZ2lzdHJ5LnByb3RvdHlwZS5faGFzaFRhZyA9IGZ1bmN0aW9uICh0YWcsIGF0dHJzLCBpc1ZvaWQpIHtcbiAgICAgICAgICB2YXIgc3RhcnQgPSBcIjxcIiArIHRhZztcbiAgICAgICAgICB2YXIgc3RyQXR0cnMgPSBPYmplY3Qua2V5cyhhdHRycykuc29ydCgpLm1hcChmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gKFwiIFwiICsgbmFtZSArIFwiPVwiICsgYXR0cnNbbmFtZV0pOyB9KS5qb2luKCcnKTtcbiAgICAgICAgICB2YXIgZW5kID0gaXNWb2lkID8gJy8+JyA6IFwiPjwvXCIgKyB0YWcgKyBcIj5cIjtcbiAgICAgICAgICByZXR1cm4gc3RhcnQgKyBzdHJBdHRycyArIGVuZDtcbiAgICAgIH07XG4gICAgICBQbGFjZWhvbGRlclJlZ2lzdHJ5LnByb3RvdHlwZS5faGFzaENsb3NpbmdUYWcgPSBmdW5jdGlvbiAodGFnKSB7IHJldHVybiB0aGlzLl9oYXNoVGFnKFwiL1wiICsgdGFnLCB7fSwgZmFsc2UpOyB9O1xuICAgICAgUGxhY2Vob2xkZXJSZWdpc3RyeS5wcm90b3R5cGUuX2dlbmVyYXRlVW5pcXVlTmFtZSA9IGZ1bmN0aW9uIChiYXNlKSB7XG4gICAgICAgICAgdmFyIG5hbWUgPSBiYXNlO1xuICAgICAgICAgIHZhciBuZXh0ID0gdGhpcy5fcGxhY2VIb2xkZXJOYW1lQ291bnRzW25hbWVdO1xuICAgICAgICAgIGlmICghbmV4dCkge1xuICAgICAgICAgICAgICBuZXh0ID0gMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIG5hbWUgKz0gXCJfXCIgKyBuZXh0O1xuICAgICAgICAgICAgICBuZXh0Kys7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX3BsYWNlSG9sZGVyTmFtZUNvdW50c1tiYXNlXSA9IG5leHQ7XG4gICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIFBsYWNlaG9sZGVyUmVnaXN0cnk7XG4gIH0oKSk7XG5cbiAgdmFyIF9leHBQYXJzZXIgPSBuZXcgUGFyc2VyKG5ldyBMZXhlcigpKTtcbiAgLyoqXG4gICAqIFJldHVybnMgYSBmdW5jdGlvbiBjb252ZXJ0aW5nIGh0bWwgbm9kZXMgdG8gYW4gaTE4biBNZXNzYWdlIGdpdmVuIGFuIGludGVycG9sYXRpb25Db25maWdcbiAgICovXG4gIGZ1bmN0aW9uIGNyZWF0ZUkxOG5NZXNzYWdlRmFjdG9yeShpbnRlcnBvbGF0aW9uQ29uZmlnKSB7XG4gICAgICB2YXIgdmlzaXRvciA9IG5ldyBfSTE4blZpc2l0b3IoX2V4cFBhcnNlciwgaW50ZXJwb2xhdGlvbkNvbmZpZyk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKG5vZGVzLCBtZWFuaW5nLCBkZXNjcmlwdGlvbikge1xuICAgICAgICAgIHJldHVybiB2aXNpdG9yLnRvSTE4bk1lc3NhZ2Uobm9kZXMsIG1lYW5pbmcsIGRlc2NyaXB0aW9uKTtcbiAgICAgIH07XG4gIH1cbiAgdmFyIF9JMThuVmlzaXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBfSTE4blZpc2l0b3IoX2V4cHJlc3Npb25QYXJzZXIsIF9pbnRlcnBvbGF0aW9uQ29uZmlnKSB7XG4gICAgICAgICAgdGhpcy5fZXhwcmVzc2lvblBhcnNlciA9IF9leHByZXNzaW9uUGFyc2VyO1xuICAgICAgICAgIHRoaXMuX2ludGVycG9sYXRpb25Db25maWcgPSBfaW50ZXJwb2xhdGlvbkNvbmZpZztcbiAgICAgIH1cbiAgICAgIF9JMThuVmlzaXRvci5wcm90b3R5cGUudG9JMThuTWVzc2FnZSA9IGZ1bmN0aW9uIChub2RlcywgbWVhbmluZywgZGVzY3JpcHRpb24pIHtcbiAgICAgICAgICB0aGlzLl9pc0ljdSA9IG5vZGVzLmxlbmd0aCA9PSAxICYmIG5vZGVzWzBdIGluc3RhbmNlb2YgRXhwYW5zaW9uO1xuICAgICAgICAgIHRoaXMuX2ljdURlcHRoID0gMDtcbiAgICAgICAgICB0aGlzLl9wbGFjZWhvbGRlclJlZ2lzdHJ5ID0gbmV3IFBsYWNlaG9sZGVyUmVnaXN0cnkoKTtcbiAgICAgICAgICB0aGlzLl9wbGFjZWhvbGRlclRvQ29udGVudCA9IHt9O1xuICAgICAgICAgIHRoaXMuX3BsYWNlaG9sZGVyVG9JZHMgPSB7fTtcbiAgICAgICAgICB2YXIgaTE4bm9kZXMgPSB2aXNpdEFsbCh0aGlzLCBub2Rlcywge30pO1xuICAgICAgICAgIHJldHVybiBuZXcgTWVzc2FnZShpMThub2RlcywgdGhpcy5fcGxhY2Vob2xkZXJUb0NvbnRlbnQsIHRoaXMuX3BsYWNlaG9sZGVyVG9JZHMsIG1lYW5pbmcsIGRlc2NyaXB0aW9uKTtcbiAgICAgIH07XG4gICAgICBfSTE4blZpc2l0b3IucHJvdG90eXBlLnZpc2l0RWxlbWVudCA9IGZ1bmN0aW9uIChlbCwgY29udGV4dCkge1xuICAgICAgICAgIHZhciBjaGlsZHJlbiA9IHZpc2l0QWxsKHRoaXMsIGVsLmNoaWxkcmVuKTtcbiAgICAgICAgICB2YXIgYXR0cnMgPSB7fTtcbiAgICAgICAgICBlbC5hdHRycy5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyKSB7XG4gICAgICAgICAgICAgIC8vIERvIG5vdCB2aXNpdCB0aGUgYXR0cmlidXRlcywgdHJhbnNsYXRhYmxlIG9uZXMgYXJlIHRvcC1sZXZlbCBBU1RzXG4gICAgICAgICAgICAgIGF0dHJzW2F0dHIubmFtZV0gPSBhdHRyLnZhbHVlO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHZhciBpc1ZvaWQgPSBnZXRIdG1sVGFnRGVmaW5pdGlvbihlbC5uYW1lKS5pc1ZvaWQ7XG4gICAgICAgICAgdmFyIHN0YXJ0UGhOYW1lID0gdGhpcy5fcGxhY2Vob2xkZXJSZWdpc3RyeS5nZXRTdGFydFRhZ1BsYWNlaG9sZGVyTmFtZShlbC5uYW1lLCBhdHRycywgaXNWb2lkKTtcbiAgICAgICAgICB0aGlzLl9wbGFjZWhvbGRlclRvQ29udGVudFtzdGFydFBoTmFtZV0gPSBlbC5zb3VyY2VTcGFuLnRvU3RyaW5nKCk7XG4gICAgICAgICAgdmFyIGNsb3NlUGhOYW1lID0gJyc7XG4gICAgICAgICAgaWYgKCFpc1ZvaWQpIHtcbiAgICAgICAgICAgICAgY2xvc2VQaE5hbWUgPSB0aGlzLl9wbGFjZWhvbGRlclJlZ2lzdHJ5LmdldENsb3NlVGFnUGxhY2Vob2xkZXJOYW1lKGVsLm5hbWUpO1xuICAgICAgICAgICAgICB0aGlzLl9wbGFjZWhvbGRlclRvQ29udGVudFtjbG9zZVBoTmFtZV0gPSBcIjwvXCIgKyBlbC5uYW1lICsgXCI+XCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuZXcgVGFnUGxhY2Vob2xkZXIoZWwubmFtZSwgYXR0cnMsIHN0YXJ0UGhOYW1lLCBjbG9zZVBoTmFtZSwgY2hpbGRyZW4sIGlzVm9pZCwgZWwuc291cmNlU3Bhbik7XG4gICAgICB9O1xuICAgICAgX0kxOG5WaXNpdG9yLnByb3RvdHlwZS52aXNpdEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChhdHRyaWJ1dGUsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fdmlzaXRUZXh0V2l0aEludGVycG9sYXRpb24oYXR0cmlidXRlLnZhbHVlLCBhdHRyaWJ1dGUuc291cmNlU3Bhbik7XG4gICAgICB9O1xuICAgICAgX0kxOG5WaXNpdG9yLnByb3RvdHlwZS52aXNpdFRleHQgPSBmdW5jdGlvbiAodGV4dCwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl92aXNpdFRleHRXaXRoSW50ZXJwb2xhdGlvbih0ZXh0LnZhbHVlLCB0ZXh0LnNvdXJjZVNwYW4pO1xuICAgICAgfTtcbiAgICAgIF9JMThuVmlzaXRvci5wcm90b3R5cGUudmlzaXRDb21tZW50ID0gZnVuY3Rpb24gKGNvbW1lbnQsIGNvbnRleHQpIHsgcmV0dXJuIG51bGw7IH07XG4gICAgICBfSTE4blZpc2l0b3IucHJvdG90eXBlLnZpc2l0RXhwYW5zaW9uID0gZnVuY3Rpb24gKGljdSwgY29udGV4dCkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgdGhpcy5faWN1RGVwdGgrKztcbiAgICAgICAgICB2YXIgaTE4bkljdUNhc2VzID0ge307XG4gICAgICAgICAgdmFyIGkxOG5JY3UgPSBuZXcgSWN1KGljdS5zd2l0Y2hWYWx1ZSwgaWN1LnR5cGUsIGkxOG5JY3VDYXNlcywgaWN1LnNvdXJjZVNwYW4pO1xuICAgICAgICAgIGljdS5jYXNlcy5mb3JFYWNoKGZ1bmN0aW9uIChjYXplKSB7XG4gICAgICAgICAgICAgIGkxOG5JY3VDYXNlc1tjYXplLnZhbHVlXSA9IG5ldyBDb250YWluZXIoY2F6ZS5leHByZXNzaW9uLm1hcChmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZS52aXNpdChfdGhpcywge30pOyB9KSwgY2F6ZS5leHBTb3VyY2VTcGFuKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLl9pY3VEZXB0aC0tO1xuICAgICAgICAgIGlmICh0aGlzLl9pc0ljdSB8fCB0aGlzLl9pY3VEZXB0aCA+IDApIHtcbiAgICAgICAgICAgICAgLy8gSWYgdGhlIG1lc3NhZ2UgKHZzIGEgcGFydCBvZiB0aGUgbWVzc2FnZSkgaXMgYW4gSUNVIG1lc3NhZ2UgcmV0dXJucyBpdFxuICAgICAgICAgICAgICByZXR1cm4gaTE4bkljdTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gRWxzZSByZXR1cm5zIGEgcGxhY2Vob2xkZXJcbiAgICAgICAgICAvLyBJQ1UgcGxhY2Vob2xkZXJzIHNob3VsZCBub3QgYmUgcmVwbGFjZWQgd2l0aCB0aGVpciBvcmlnaW5hbCBjb250ZW50IGJ1dCB3aXRoIHRoZSB0aGVpclxuICAgICAgICAgIC8vIHRyYW5zbGF0aW9ucy4gV2UgbmVlZCB0byBjcmVhdGUgYSBuZXcgdmlzaXRvciAodGhleSBhcmUgbm90IHJlLWVudHJhbnQpIHRvIGNvbXB1dGUgdGhlXG4gICAgICAgICAgLy8gbWVzc2FnZSBpZC5cbiAgICAgICAgICAvLyBUT0RPKHZpY2IpOiBhZGQgYSBodG1sLk5vZGUgLT4gaTE4bi5NZXNzYWdlIGNhY2hlIHRvIGF2b2lkIGhhdmluZyB0byByZS1jcmVhdGUgdGhlIG1zZ1xuICAgICAgICAgIHZhciBwaE5hbWUgPSB0aGlzLl9wbGFjZWhvbGRlclJlZ2lzdHJ5LmdldFBsYWNlaG9sZGVyTmFtZSgnSUNVJywgaWN1LnNvdXJjZVNwYW4udG9TdHJpbmcoKSk7XG4gICAgICAgICAgdmFyIHZpc2l0b3IgPSBuZXcgX0kxOG5WaXNpdG9yKHRoaXMuX2V4cHJlc3Npb25QYXJzZXIsIHRoaXMuX2ludGVycG9sYXRpb25Db25maWcpO1xuICAgICAgICAgIHRoaXMuX3BsYWNlaG9sZGVyVG9JZHNbcGhOYW1lXSA9IGRpZ2VzdE1lc3NhZ2UodmlzaXRvci50b0kxOG5NZXNzYWdlKFtpY3VdLCAnJywgJycpKTtcbiAgICAgICAgICByZXR1cm4gbmV3IEljdVBsYWNlaG9sZGVyKGkxOG5JY3UsIHBoTmFtZSwgaWN1LnNvdXJjZVNwYW4pO1xuICAgICAgfTtcbiAgICAgIF9JMThuVmlzaXRvci5wcm90b3R5cGUudmlzaXRFeHBhbnNpb25DYXNlID0gZnVuY3Rpb24gKGljdUNhc2UsIGNvbnRleHQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VucmVhY2hhYmxlIGNvZGUnKTtcbiAgICAgIH07XG4gICAgICBfSTE4blZpc2l0b3IucHJvdG90eXBlLl92aXNpdFRleHRXaXRoSW50ZXJwb2xhdGlvbiA9IGZ1bmN0aW9uICh0ZXh0LCBzb3VyY2VTcGFuKSB7XG4gICAgICAgICAgdmFyIHNwbGl0SW50ZXJwb2xhdGlvbiA9IHRoaXMuX2V4cHJlc3Npb25QYXJzZXIuc3BsaXRJbnRlcnBvbGF0aW9uKHRleHQsIHNvdXJjZVNwYW4uc3RhcnQudG9TdHJpbmcoKSwgdGhpcy5faW50ZXJwb2xhdGlvbkNvbmZpZyk7XG4gICAgICAgICAgaWYgKCFzcGxpdEludGVycG9sYXRpb24pIHtcbiAgICAgICAgICAgICAgLy8gTm8gZXhwcmVzc2lvbiwgcmV0dXJuIGEgc2luZ2xlIHRleHRcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBUZXh0JDEodGV4dCwgc291cmNlU3Bhbik7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFJldHVybiBhIGdyb3VwIG9mIHRleHQgKyBleHByZXNzaW9uc1xuICAgICAgICAgIHZhciBub2RlcyA9IFtdO1xuICAgICAgICAgIHZhciBjb250YWluZXIgPSBuZXcgQ29udGFpbmVyKG5vZGVzLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICB2YXIgX2EgPSB0aGlzLl9pbnRlcnBvbGF0aW9uQ29uZmlnLCBzRGVsaW1pdGVyID0gX2Euc3RhcnQsIGVEZWxpbWl0ZXIgPSBfYS5lbmQ7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzcGxpdEludGVycG9sYXRpb24uc3RyaW5ncy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFyIGV4cHJlc3Npb24gPSBzcGxpdEludGVycG9sYXRpb24uZXhwcmVzc2lvbnNbaV07XG4gICAgICAgICAgICAgIHZhciBiYXNlTmFtZSA9IF9leHRyYWN0UGxhY2Vob2xkZXJOYW1lKGV4cHJlc3Npb24pIHx8ICdJTlRFUlBPTEFUSU9OJztcbiAgICAgICAgICAgICAgdmFyIHBoTmFtZSA9IHRoaXMuX3BsYWNlaG9sZGVyUmVnaXN0cnkuZ2V0UGxhY2Vob2xkZXJOYW1lKGJhc2VOYW1lLCBleHByZXNzaW9uKTtcbiAgICAgICAgICAgICAgaWYgKHNwbGl0SW50ZXJwb2xhdGlvbi5zdHJpbmdzW2ldLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgLy8gTm8gbmVlZCB0byBhZGQgZW1wdHkgc3RyaW5nc1xuICAgICAgICAgICAgICAgICAgbm9kZXMucHVzaChuZXcgVGV4dCQxKHNwbGl0SW50ZXJwb2xhdGlvbi5zdHJpbmdzW2ldLCBzb3VyY2VTcGFuKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbm9kZXMucHVzaChuZXcgUGxhY2Vob2xkZXIoZXhwcmVzc2lvbiwgcGhOYW1lLCBzb3VyY2VTcGFuKSk7XG4gICAgICAgICAgICAgIHRoaXMuX3BsYWNlaG9sZGVyVG9Db250ZW50W3BoTmFtZV0gPSBzRGVsaW1pdGVyICsgZXhwcmVzc2lvbiArIGVEZWxpbWl0ZXI7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFRoZSBsYXN0IGluZGV4IGNvbnRhaW5zIG5vIGV4cHJlc3Npb25cbiAgICAgICAgICB2YXIgbGFzdFN0cmluZ0lkeCA9IHNwbGl0SW50ZXJwb2xhdGlvbi5zdHJpbmdzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgaWYgKHNwbGl0SW50ZXJwb2xhdGlvbi5zdHJpbmdzW2xhc3RTdHJpbmdJZHhdLmxlbmd0aCkge1xuICAgICAgICAgICAgICBub2Rlcy5wdXNoKG5ldyBUZXh0JDEoc3BsaXRJbnRlcnBvbGF0aW9uLnN0cmluZ3NbbGFzdFN0cmluZ0lkeF0sIHNvdXJjZVNwYW4pKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgICAgIH07XG4gICAgICByZXR1cm4gX0kxOG5WaXNpdG9yO1xuICB9KCkpO1xuICB2YXIgX0NVU1RPTV9QSF9FWFAgPSAvXFwvXFwvW1xcc1xcU10qaTE4bltcXHNcXFNdKlxcKFtcXHNcXFNdKnBoW1xcc1xcU10qPVtcXHNcXFNdKlwiKFtcXHNcXFNdKj8pXCJbXFxzXFxTXSpcXCkvZztcbiAgZnVuY3Rpb24gX2V4dHJhY3RQbGFjZWhvbGRlck5hbWUoaW5wdXQpIHtcbiAgICAgIHJldHVybiBpbnB1dC5zcGxpdChfQ1VTVE9NX1BIX0VYUClbMV07XG4gIH1cblxuICAvKipcbiAgICogQGxpY2Vuc2VcbiAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAqXG4gICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICovXG4gIHZhciBfX2V4dGVuZHMkNSA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgfTtcbiAgLyoqXG4gICAqIEFuIGkxOG4gZXJyb3IuXG4gICAqL1xuICB2YXIgSTE4bkVycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQ1KEkxOG5FcnJvciwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIEkxOG5FcnJvcihzcGFuLCBtc2cpIHtcbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBzcGFuLCBtc2cpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIEkxOG5FcnJvcjtcbiAgfShQYXJzZUVycm9yKSk7XG5cbiAgdmFyIF9JMThOX0FUVFIgPSAnaTE4bic7XG4gIHZhciBfSTE4Tl9BVFRSX1BSRUZJWCA9ICdpMThuLSc7XG4gIHZhciBfSTE4Tl9DT01NRU5UX1BSRUZJWF9SRUdFWFAgPSAvXmkxOG46Py87XG4gIC8qKlxuICAgKiBFeHRyYWN0IHRyYW5zbGF0YWJsZSBtZXNzYWdlcyBmcm9tIGFuIGh0bWwgQVNUXG4gICAqL1xuICBmdW5jdGlvbiBleHRyYWN0TWVzc2FnZXMobm9kZXMsIGludGVycG9sYXRpb25Db25maWcsIGltcGxpY2l0VGFncywgaW1wbGljaXRBdHRycykge1xuICAgICAgdmFyIHZpc2l0b3IgPSBuZXcgX1Zpc2l0b3IoaW1wbGljaXRUYWdzLCBpbXBsaWNpdEF0dHJzKTtcbiAgICAgIHJldHVybiB2aXNpdG9yLmV4dHJhY3Qobm9kZXMsIGludGVycG9sYXRpb25Db25maWcpO1xuICB9XG4gIGZ1bmN0aW9uIG1lcmdlVHJhbnNsYXRpb25zKG5vZGVzLCB0cmFuc2xhdGlvbnMsIGludGVycG9sYXRpb25Db25maWcsIGltcGxpY2l0VGFncywgaW1wbGljaXRBdHRycykge1xuICAgICAgdmFyIHZpc2l0b3IgPSBuZXcgX1Zpc2l0b3IoaW1wbGljaXRUYWdzLCBpbXBsaWNpdEF0dHJzKTtcbiAgICAgIHJldHVybiB2aXNpdG9yLm1lcmdlKG5vZGVzLCB0cmFuc2xhdGlvbnMsIGludGVycG9sYXRpb25Db25maWcpO1xuICB9XG4gIHZhciBFeHRyYWN0aW9uUmVzdWx0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIEV4dHJhY3Rpb25SZXN1bHQobWVzc2FnZXMsIGVycm9ycykge1xuICAgICAgICAgIHRoaXMubWVzc2FnZXMgPSBtZXNzYWdlcztcbiAgICAgICAgICB0aGlzLmVycm9ycyA9IGVycm9ycztcbiAgICAgIH1cbiAgICAgIHJldHVybiBFeHRyYWN0aW9uUmVzdWx0O1xuICB9KCkpO1xuICB2YXIgX1Zpc2l0b3JNb2RlO1xuICAoZnVuY3Rpb24gKF9WaXNpdG9yTW9kZSkge1xuICAgICAgX1Zpc2l0b3JNb2RlW19WaXNpdG9yTW9kZVtcIkV4dHJhY3RcIl0gPSAwXSA9IFwiRXh0cmFjdFwiO1xuICAgICAgX1Zpc2l0b3JNb2RlW19WaXNpdG9yTW9kZVtcIk1lcmdlXCJdID0gMV0gPSBcIk1lcmdlXCI7XG4gIH0pKF9WaXNpdG9yTW9kZSB8fCAoX1Zpc2l0b3JNb2RlID0ge30pKTtcbiAgLyoqXG4gICAqIFRoaXMgVmlzaXRvciBpcyB1c2VkOlxuICAgKiAxLiB0byBleHRyYWN0IGFsbCB0aGUgdHJhbnNsYXRhYmxlIHN0cmluZ3MgZnJvbSBhbiBodG1sIEFTVCAoc2VlIGBleHRyYWN0KClgKSxcbiAgICogMi4gdG8gcmVwbGFjZSB0aGUgdHJhbnNsYXRhYmxlIHN0cmluZ3Mgd2l0aCB0aGUgYWN0dWFsIHRyYW5zbGF0aW9ucyAoc2VlIGBtZXJnZSgpYClcbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICB2YXIgX1Zpc2l0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gX1Zpc2l0b3IoX2ltcGxpY2l0VGFncywgX2ltcGxpY2l0QXR0cnMpIHtcbiAgICAgICAgICB0aGlzLl9pbXBsaWNpdFRhZ3MgPSBfaW1wbGljaXRUYWdzO1xuICAgICAgICAgIHRoaXMuX2ltcGxpY2l0QXR0cnMgPSBfaW1wbGljaXRBdHRycztcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogRXh0cmFjdHMgdGhlIG1lc3NhZ2VzIGZyb20gdGhlIHRyZWVcbiAgICAgICAqL1xuICAgICAgX1Zpc2l0b3IucHJvdG90eXBlLmV4dHJhY3QgPSBmdW5jdGlvbiAobm9kZXMsIGludGVycG9sYXRpb25Db25maWcpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHRoaXMuX2luaXQoX1Zpc2l0b3JNb2RlLkV4dHJhY3QsIGludGVycG9sYXRpb25Db25maWcpO1xuICAgICAgICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGUudmlzaXQoX3RoaXMsIG51bGwpOyB9KTtcbiAgICAgICAgICBpZiAodGhpcy5faW5JMThuQmxvY2spIHtcbiAgICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3Iobm9kZXNbbm9kZXMubGVuZ3RoIC0gMV0sICdVbmNsb3NlZCBibG9jaycpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3IEV4dHJhY3Rpb25SZXN1bHQodGhpcy5fbWVzc2FnZXMsIHRoaXMuX2Vycm9ycyk7XG4gICAgICB9O1xuICAgICAgLyoqXG4gICAgICAgKiBSZXR1cm5zIGEgdHJlZSB3aGVyZSBhbGwgdHJhbnNsYXRhYmxlIG5vZGVzIGFyZSB0cmFuc2xhdGVkXG4gICAgICAgKi9cbiAgICAgIF9WaXNpdG9yLnByb3RvdHlwZS5tZXJnZSA9IGZ1bmN0aW9uIChub2RlcywgdHJhbnNsYXRpb25zLCBpbnRlcnBvbGF0aW9uQ29uZmlnKSB7XG4gICAgICAgICAgdGhpcy5faW5pdChfVmlzaXRvck1vZGUuTWVyZ2UsIGludGVycG9sYXRpb25Db25maWcpO1xuICAgICAgICAgIHRoaXMuX3RyYW5zbGF0aW9ucyA9IHRyYW5zbGF0aW9ucztcbiAgICAgICAgICAvLyBDb25zdHJ1Y3QgYSBzaW5nbGUgZmFrZSByb290IGVsZW1lbnRcbiAgICAgICAgICB2YXIgd3JhcHBlciA9IG5ldyBFbGVtZW50KCd3cmFwcGVyJywgW10sIG5vZGVzLCBudWxsLCBudWxsLCBudWxsKTtcbiAgICAgICAgICB2YXIgdHJhbnNsYXRlZE5vZGUgPSB3cmFwcGVyLnZpc2l0KHRoaXMsIG51bGwpO1xuICAgICAgICAgIGlmICh0aGlzLl9pbkkxOG5CbG9jaykge1xuICAgICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihub2Rlc1tub2Rlcy5sZW5ndGggLSAxXSwgJ1VuY2xvc2VkIGJsb2NrJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuZXcgUGFyc2VUcmVlUmVzdWx0KHRyYW5zbGF0ZWROb2RlLmNoaWxkcmVuLCB0aGlzLl9lcnJvcnMpO1xuICAgICAgfTtcbiAgICAgIF9WaXNpdG9yLnByb3RvdHlwZS52aXNpdEV4cGFuc2lvbkNhc2UgPSBmdW5jdGlvbiAoaWN1Q2FzZSwgY29udGV4dCkge1xuICAgICAgICAgIC8vIFBhcnNlIGNhc2VzIGZvciB0cmFuc2xhdGFibGUgaHRtbCBhdHRyaWJ1dGVzXG4gICAgICAgICAgdmFyIGV4cHJlc3Npb24gPSB2aXNpdEFsbCh0aGlzLCBpY3VDYXNlLmV4cHJlc3Npb24sIGNvbnRleHQpO1xuICAgICAgICAgIGlmICh0aGlzLl9tb2RlID09PSBfVmlzaXRvck1vZGUuTWVyZ2UpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBFeHBhbnNpb25DYXNlKGljdUNhc2UudmFsdWUsIGV4cHJlc3Npb24sIGljdUNhc2Uuc291cmNlU3BhbiwgaWN1Q2FzZS52YWx1ZVNvdXJjZVNwYW4sIGljdUNhc2UuZXhwU291cmNlU3Bhbik7XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIF9WaXNpdG9yLnByb3RvdHlwZS52aXNpdEV4cGFuc2lvbiA9IGZ1bmN0aW9uIChpY3UsIGNvbnRleHQpIHtcbiAgICAgICAgICB0aGlzLl9tYXlCZUFkZEJsb2NrQ2hpbGRyZW4oaWN1KTtcbiAgICAgICAgICB2YXIgd2FzSW5JY3UgPSB0aGlzLl9pbkljdTtcbiAgICAgICAgICBpZiAoIXRoaXMuX2luSWN1KSB7XG4gICAgICAgICAgICAgIC8vIG5lc3RlZCBJQ1UgbWVzc2FnZXMgc2hvdWxkIG5vdCBiZSBleHRyYWN0ZWQgYnV0IHRvcC1sZXZlbCB0cmFuc2xhdGVkIGFzIGEgd2hvbGVcbiAgICAgICAgICAgICAgaWYgKHRoaXMuX2lzSW5UcmFuc2xhdGFibGVTZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9hZGRNZXNzYWdlKFtpY3VdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aGlzLl9pbkljdSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBjYXNlcyA9IHZpc2l0QWxsKHRoaXMsIGljdS5jYXNlcywgY29udGV4dCk7XG4gICAgICAgICAgaWYgKHRoaXMuX21vZGUgPT09IF9WaXNpdG9yTW9kZS5NZXJnZSkge1xuICAgICAgICAgICAgICBpY3UgPSBuZXcgRXhwYW5zaW9uKGljdS5zd2l0Y2hWYWx1ZSwgaWN1LnR5cGUsIGNhc2VzLCBpY3Uuc291cmNlU3BhbiwgaWN1LnN3aXRjaFZhbHVlU291cmNlU3Bhbik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX2luSWN1ID0gd2FzSW5JY3U7XG4gICAgICAgICAgcmV0dXJuIGljdTtcbiAgICAgIH07XG4gICAgICBfVmlzaXRvci5wcm90b3R5cGUudmlzaXRDb21tZW50ID0gZnVuY3Rpb24gKGNvbW1lbnQsIGNvbnRleHQpIHtcbiAgICAgICAgICB2YXIgaXNPcGVuaW5nID0gX2lzT3BlbmluZ0NvbW1lbnQoY29tbWVudCk7XG4gICAgICAgICAgaWYgKGlzT3BlbmluZyAmJiB0aGlzLl9pc0luVHJhbnNsYXRhYmxlU2VjdGlvbikge1xuICAgICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihjb21tZW50LCAnQ291bGQgbm90IHN0YXJ0IGEgYmxvY2sgaW5zaWRlIGEgdHJhbnNsYXRhYmxlIHNlY3Rpb24nKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgaXNDbG9zaW5nID0gX2lzQ2xvc2luZ0NvbW1lbnQoY29tbWVudCk7XG4gICAgICAgICAgaWYgKGlzQ2xvc2luZyAmJiAhdGhpcy5faW5JMThuQmxvY2spIHtcbiAgICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoY29tbWVudCwgJ1RyeWluZyB0byBjbG9zZSBhbiB1bm9wZW5lZCBibG9jaycpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghdGhpcy5faW5JMThuTm9kZSAmJiAhdGhpcy5faW5JY3UpIHtcbiAgICAgICAgICAgICAgaWYgKCF0aGlzLl9pbkkxOG5CbG9jaykge1xuICAgICAgICAgICAgICAgICAgaWYgKGlzT3BlbmluZykge1xuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2luSTE4bkJsb2NrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9ibG9ja1N0YXJ0RGVwdGggPSB0aGlzLl9kZXB0aDtcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9ibG9ja0NoaWxkcmVuID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYmxvY2tNZWFuaW5nQW5kRGVzYyA9IGNvbW1lbnQudmFsdWUucmVwbGFjZShfSTE4Tl9DT01NRU5UX1BSRUZJWF9SRUdFWFAsICcnKS50cmltKCk7XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5fb3BlblRyYW5zbGF0YWJsZVNlY3Rpb24oY29tbWVudCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICBpZiAoaXNDbG9zaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2RlcHRoID09IHRoaXMuX2Jsb2NrU3RhcnREZXB0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jbG9zZVRyYW5zbGF0YWJsZVNlY3Rpb24oY29tbWVudCwgdGhpcy5fYmxvY2tDaGlsZHJlbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2luSTE4bkJsb2NrID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlID0gdGhpcy5fYWRkTWVzc2FnZSh0aGlzLl9ibG9ja0NoaWxkcmVuLCB0aGlzLl9ibG9ja01lYW5pbmdBbmREZXNjKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWVyZ2UgYXR0cmlidXRlcyBpbiBzZWN0aW9uc1xuICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZXMgPSB0aGlzLl90cmFuc2xhdGVNZXNzYWdlKGNvbW1lbnQsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmlzaXRBbGwodGhpcywgbm9kZXMpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoY29tbWVudCwgJ0kxOE4gYmxvY2tzIHNob3VsZCBub3QgY3Jvc3MgZWxlbWVudCBib3VuZGFyaWVzJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgX1Zpc2l0b3IucHJvdG90eXBlLnZpc2l0VGV4dCA9IGZ1bmN0aW9uICh0ZXh0LCBjb250ZXh0KSB7XG4gICAgICAgICAgaWYgKHRoaXMuX2lzSW5UcmFuc2xhdGFibGVTZWN0aW9uKSB7XG4gICAgICAgICAgICAgIHRoaXMuX21heUJlQWRkQmxvY2tDaGlsZHJlbih0ZXh0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgICB9O1xuICAgICAgX1Zpc2l0b3IucHJvdG90eXBlLnZpc2l0RWxlbWVudCA9IGZ1bmN0aW9uIChlbCwgY29udGV4dCkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgdGhpcy5fbWF5QmVBZGRCbG9ja0NoaWxkcmVuKGVsKTtcbiAgICAgICAgICB0aGlzLl9kZXB0aCsrO1xuICAgICAgICAgIHZhciB3YXNJbkkxOG5Ob2RlID0gdGhpcy5faW5JMThuTm9kZTtcbiAgICAgICAgICB2YXIgd2FzSW5JbXBsaWNpdE5vZGUgPSB0aGlzLl9pbkltcGxpY2l0Tm9kZTtcbiAgICAgICAgICB2YXIgY2hpbGROb2RlcztcbiAgICAgICAgICAvLyBFeHRyYWN0IG9ubHkgdG9wIGxldmVsIG5vZGVzIHdpdGggdGhlIChpbXBsaWNpdCkgXCJpMThuXCIgYXR0cmlidXRlIGlmIG5vdCBpbiBhIGJsb2NrIG9yIGFuIElDVVxuICAgICAgICAgIC8vIG1lc3NhZ2VcbiAgICAgICAgICB2YXIgaTE4bkF0dHIgPSBfZ2V0STE4bkF0dHIoZWwpO1xuICAgICAgICAgIHZhciBpc0ltcGxpY2l0ID0gdGhpcy5faW1wbGljaXRUYWdzLnNvbWUoZnVuY3Rpb24gKHRhZykgeyByZXR1cm4gZWwubmFtZSA9PT0gdGFnOyB9KSAmJlxuICAgICAgICAgICAgICAhdGhpcy5faW5JY3UgJiYgIXRoaXMuX2lzSW5UcmFuc2xhdGFibGVTZWN0aW9uO1xuICAgICAgICAgIHZhciBpc1RvcExldmVsSW1wbGljaXQgPSAhd2FzSW5JbXBsaWNpdE5vZGUgJiYgaXNJbXBsaWNpdDtcbiAgICAgICAgICB0aGlzLl9pbkltcGxpY2l0Tm9kZSA9IHRoaXMuX2luSW1wbGljaXROb2RlIHx8IGlzSW1wbGljaXQ7XG4gICAgICAgICAgaWYgKCF0aGlzLl9pc0luVHJhbnNsYXRhYmxlU2VjdGlvbiAmJiAhdGhpcy5faW5JY3UpIHtcbiAgICAgICAgICAgICAgaWYgKGkxOG5BdHRyKSB7XG4gICAgICAgICAgICAgICAgICAvLyBleHBsaWNpdCB0cmFuc2xhdGlvblxuICAgICAgICAgICAgICAgICAgdGhpcy5faW5JMThuTm9kZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICB2YXIgbWVzc2FnZSA9IHRoaXMuX2FkZE1lc3NhZ2UoZWwuY2hpbGRyZW4sIGkxOG5BdHRyLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgIGNoaWxkTm9kZXMgPSB0aGlzLl90cmFuc2xhdGVNZXNzYWdlKGVsLCBtZXNzYWdlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIGlmIChpc1RvcExldmVsSW1wbGljaXQpIHtcbiAgICAgICAgICAgICAgICAgIC8vIGltcGxpY2l0IHRyYW5zbGF0aW9uXG4gICAgICAgICAgICAgICAgICB0aGlzLl9pbkkxOG5Ob2RlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlID0gdGhpcy5fYWRkTWVzc2FnZShlbC5jaGlsZHJlbik7XG4gICAgICAgICAgICAgICAgICBjaGlsZE5vZGVzID0gdGhpcy5fdHJhbnNsYXRlTWVzc2FnZShlbCwgbWVzc2FnZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHRoaXMuX21vZGUgPT0gX1Zpc2l0b3JNb2RlLkV4dHJhY3QpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBpc1RyYW5zbGF0YWJsZSA9IGkxOG5BdHRyIHx8IGlzVG9wTGV2ZWxJbXBsaWNpdDtcbiAgICAgICAgICAgICAgICAgIGlmIChpc1RyYW5zbGF0YWJsZSkge1xuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX29wZW5UcmFuc2xhdGFibGVTZWN0aW9uKGVsKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHZpc2l0QWxsKHRoaXMsIGVsLmNoaWxkcmVuKTtcbiAgICAgICAgICAgICAgICAgIGlmIChpc1RyYW5zbGF0YWJsZSkge1xuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2Nsb3NlVHJhbnNsYXRhYmxlU2VjdGlvbihlbCwgZWwuY2hpbGRyZW4pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICh0aGlzLl9tb2RlID09PSBfVmlzaXRvck1vZGUuTWVyZ2UgJiYgIWkxOG5BdHRyICYmICFpc1RvcExldmVsSW1wbGljaXQpIHtcbiAgICAgICAgICAgICAgICAgIGNoaWxkTm9kZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgIGVsLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIHZpc2l0ZWQgPSBjaGlsZC52aXNpdChfdGhpcywgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHZpc2l0ZWQgJiYgIV90aGlzLl9pc0luVHJhbnNsYXRhYmxlU2VjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEbyBub3QgYWRkIHRoZSBjaGlsZHJlbiBmcm9tIHRyYW5zbGF0YWJsZSBzZWN0aW9ucyAoPSBpMThuIGJsb2NrcyBoZXJlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGV5IHdpbGwgYmUgYWRkZWQgd2hlbiB0aGUgc2VjdGlvbiBpcyBjbG9zZSAoaS5lLiBvbiBgPCEtLSAvaTE4biAtLT5gKVxuICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZE5vZGVzID0gY2hpbGROb2Rlcy5jb25jYXQodmlzaXRlZCk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChpMThuQXR0ciB8fCBpc1RvcExldmVsSW1wbGljaXQpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKGVsLCAnQ291bGQgbm90IG1hcmsgYW4gZWxlbWVudCBhcyB0cmFuc2xhdGFibGUgaW5zaWRlIGEgdHJhbnNsYXRhYmxlIHNlY3Rpb24nKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAodGhpcy5fbW9kZSA9PSBfVmlzaXRvck1vZGUuRXh0cmFjdCkge1xuICAgICAgICAgICAgICAgICAgLy8gRGVzY2VuZCBpbnRvIGNoaWxkIG5vZGVzIGZvciBleHRyYWN0aW9uXG4gICAgICAgICAgICAgICAgICB2aXNpdEFsbCh0aGlzLCBlbC5jaGlsZHJlbik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHRoaXMuX21vZGUgPT0gX1Zpc2l0b3JNb2RlLk1lcmdlKSB7XG4gICAgICAgICAgICAgICAgICAvLyBUcmFuc2xhdGUgYXR0cmlidXRlcyBpbiBJQ1UgbWVzc2FnZXNcbiAgICAgICAgICAgICAgICAgIGNoaWxkTm9kZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgIGVsLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIHZpc2l0ZWQgPSBjaGlsZC52aXNpdChfdGhpcywgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHZpc2l0ZWQgJiYgIV90aGlzLl9pc0luVHJhbnNsYXRhYmxlU2VjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEbyBub3QgYWRkIHRoZSBjaGlsZHJlbiBmcm9tIHRyYW5zbGF0YWJsZSBzZWN0aW9ucyAoPSBpMThuIGJsb2NrcyBoZXJlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGV5IHdpbGwgYmUgYWRkZWQgd2hlbiB0aGUgc2VjdGlvbiBpcyBjbG9zZSAoaS5lLiBvbiBgPCEtLSAvaTE4biAtLT5gKVxuICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZE5vZGVzID0gY2hpbGROb2Rlcy5jb25jYXQodmlzaXRlZCk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fdmlzaXRBdHRyaWJ1dGVzT2YoZWwpO1xuICAgICAgICAgIHRoaXMuX2RlcHRoLS07XG4gICAgICAgICAgdGhpcy5faW5JMThuTm9kZSA9IHdhc0luSTE4bk5vZGU7XG4gICAgICAgICAgdGhpcy5faW5JbXBsaWNpdE5vZGUgPSB3YXNJbkltcGxpY2l0Tm9kZTtcbiAgICAgICAgICBpZiAodGhpcy5fbW9kZSA9PT0gX1Zpc2l0b3JNb2RlLk1lcmdlKSB7XG4gICAgICAgICAgICAgIC8vIFRoZXJlIGFyZSBubyBjaGlsZE5vZGVzIGluIHRyYW5zbGF0YWJsZSBzZWN0aW9ucyAtIHRob3NlIG5vZGVzIHdpbGwgYmUgcmVwbGFjZSBhbnl3YXlcbiAgICAgICAgICAgICAgdmFyIHRyYW5zbGF0ZWRBdHRycyA9IHRoaXMuX3RyYW5zbGF0ZUF0dHJpYnV0ZXMoZWwpO1xuICAgICAgICAgICAgICByZXR1cm4gbmV3IEVsZW1lbnQoZWwubmFtZSwgdHJhbnNsYXRlZEF0dHJzLCBjaGlsZE5vZGVzLCBlbC5zb3VyY2VTcGFuLCBlbC5zdGFydFNvdXJjZVNwYW4sIGVsLmVuZFNvdXJjZVNwYW4pO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICBfVmlzaXRvci5wcm90b3R5cGUudmlzaXRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoYXR0cmlidXRlLCBjb250ZXh0KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bnJlYWNoYWJsZSBjb2RlJyk7XG4gICAgICB9O1xuICAgICAgX1Zpc2l0b3IucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gKG1vZGUsIGludGVycG9sYXRpb25Db25maWcpIHtcbiAgICAgICAgICB0aGlzLl9tb2RlID0gbW9kZTtcbiAgICAgICAgICB0aGlzLl9pbkkxOG5CbG9jayA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMuX2luSTE4bk5vZGUgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLl9kZXB0aCA9IDA7XG4gICAgICAgICAgdGhpcy5faW5JY3UgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLl9tc2dDb3VudEF0U2VjdGlvblN0YXJ0ID0gdm9pZCAwO1xuICAgICAgICAgIHRoaXMuX2Vycm9ycyA9IFtdO1xuICAgICAgICAgIHRoaXMuX21lc3NhZ2VzID0gW107XG4gICAgICAgICAgdGhpcy5faW5JbXBsaWNpdE5vZGUgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLl9jcmVhdGVJMThuTWVzc2FnZSA9IGNyZWF0ZUkxOG5NZXNzYWdlRmFjdG9yeShpbnRlcnBvbGF0aW9uQ29uZmlnKTtcbiAgICAgIH07XG4gICAgICAvLyBsb29rcyBmb3IgdHJhbnNsYXRhYmxlIGF0dHJpYnV0ZXNcbiAgICAgIF9WaXNpdG9yLnByb3RvdHlwZS5fdmlzaXRBdHRyaWJ1dGVzT2YgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHZhciBleHBsaWNpdEF0dHJOYW1lVG9WYWx1ZSA9IHt9O1xuICAgICAgICAgIHZhciBpbXBsaWNpdEF0dHJOYW1lcyA9IHRoaXMuX2ltcGxpY2l0QXR0cnNbZWwubmFtZV0gfHwgW107XG4gICAgICAgICAgZWwuYXR0cnMuZmlsdGVyKGZ1bmN0aW9uIChhdHRyKSB7IHJldHVybiBhdHRyLm5hbWUuc3RhcnRzV2l0aChfSTE4Tl9BVFRSX1BSRUZJWCk7IH0pXG4gICAgICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyKSB7IHJldHVybiBleHBsaWNpdEF0dHJOYW1lVG9WYWx1ZVthdHRyLm5hbWUuc2xpY2UoX0kxOE5fQVRUUl9QUkVGSVgubGVuZ3RoKV0gPVxuICAgICAgICAgICAgICBhdHRyLnZhbHVlOyB9KTtcbiAgICAgICAgICBlbC5hdHRycy5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyKSB7XG4gICAgICAgICAgICAgIGlmIChhdHRyLm5hbWUgaW4gZXhwbGljaXRBdHRyTmFtZVRvVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgIF90aGlzLl9hZGRNZXNzYWdlKFthdHRyXSwgZXhwbGljaXRBdHRyTmFtZVRvVmFsdWVbYXR0ci5uYW1lXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSBpZiAoaW1wbGljaXRBdHRyTmFtZXMuc29tZShmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gYXR0ci5uYW1lID09PSBuYW1lOyB9KSkge1xuICAgICAgICAgICAgICAgICAgX3RoaXMuX2FkZE1lc3NhZ2UoW2F0dHJdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIC8vIGFkZCBhIHRyYW5zbGF0YWJsZSBtZXNzYWdlXG4gICAgICBfVmlzaXRvci5wcm90b3R5cGUuX2FkZE1lc3NhZ2UgPSBmdW5jdGlvbiAoYXN0LCBtZWFuaW5nQW5kRGVzYykge1xuICAgICAgICAgIGlmIChhc3QubGVuZ3RoID09IDAgfHxcbiAgICAgICAgICAgICAgYXN0Lmxlbmd0aCA9PSAxICYmIGFzdFswXSBpbnN0YW5jZW9mIEF0dHJpYnV0ZSQxICYmICFhc3RbMF0udmFsdWUpIHtcbiAgICAgICAgICAgICAgLy8gRG8gbm90IGNyZWF0ZSBlbXB0eSBtZXNzYWdlc1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBfYSA9IF9zcGxpdE1lYW5pbmdBbmREZXNjKG1lYW5pbmdBbmREZXNjKSwgbWVhbmluZyA9IF9hWzBdLCBkZXNjcmlwdGlvbiA9IF9hWzFdO1xuICAgICAgICAgIHZhciBtZXNzYWdlID0gdGhpcy5fY3JlYXRlSTE4bk1lc3NhZ2UoYXN0LCBtZWFuaW5nLCBkZXNjcmlwdGlvbik7XG4gICAgICAgICAgdGhpcy5fbWVzc2FnZXMucHVzaChtZXNzYWdlKTtcbiAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgIH07XG4gICAgICAvLyBUcmFuc2xhdGVzIHRoZSBnaXZlbiBtZXNzYWdlIGdpdmVuIHRoZSBgVHJhbnNsYXRpb25CdW5kbGVgXG4gICAgICAvLyBuby1vcCB3aGVuIGNhbGxlZCBpbiBleHRyYWN0aW9uIG1vZGUgKHJldHVybnMgW10pXG4gICAgICBfVmlzaXRvci5wcm90b3R5cGUuX3RyYW5zbGF0ZU1lc3NhZ2UgPSBmdW5jdGlvbiAoZWwsIG1lc3NhZ2UpIHtcbiAgICAgICAgICBpZiAobWVzc2FnZSAmJiB0aGlzLl9tb2RlID09PSBfVmlzaXRvck1vZGUuTWVyZ2UpIHtcbiAgICAgICAgICAgICAgdmFyIGlkID0gZGlnZXN0TWVzc2FnZShtZXNzYWdlKTtcbiAgICAgICAgICAgICAgdmFyIG5vZGVzID0gdGhpcy5fdHJhbnNsYXRpb25zLmdldChpZCk7XG4gICAgICAgICAgICAgIGlmIChub2Rlcykge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGVzO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKGVsLCBcIlRyYW5zbGF0aW9uIHVuYXZhaWxhYmxlIGZvciBtZXNzYWdlIGlkPVxcXCJcIiArIGlkICsgXCJcXFwiXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICB9O1xuICAgICAgLy8gdHJhbnNsYXRlIHRoZSBhdHRyaWJ1dGVzIG9mIGFuIGVsZW1lbnQgYW5kIHJlbW92ZSBpMThuIHNwZWNpZmljIGF0dHJpYnV0ZXNcbiAgICAgIF9WaXNpdG9yLnByb3RvdHlwZS5fdHJhbnNsYXRlQXR0cmlidXRlcyA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBlbC5hdHRycztcbiAgICAgICAgICB2YXIgaTE4bkF0dHJpYnV0ZU1lYW5pbmdzID0ge307XG4gICAgICAgICAgYXR0cmlidXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyKSB7XG4gICAgICAgICAgICAgIGlmIChhdHRyLm5hbWUuc3RhcnRzV2l0aChfSTE4Tl9BVFRSX1BSRUZJWCkpIHtcbiAgICAgICAgICAgICAgICAgIGkxOG5BdHRyaWJ1dGVNZWFuaW5nc1thdHRyLm5hbWUuc2xpY2UoX0kxOE5fQVRUUl9QUkVGSVgubGVuZ3RoKV0gPVxuICAgICAgICAgICAgICAgICAgICAgIF9zcGxpdE1lYW5pbmdBbmREZXNjKGF0dHIudmFsdWUpWzBdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdmFyIHRyYW5zbGF0ZWRBdHRyaWJ1dGVzID0gW107XG4gICAgICAgICAgYXR0cmlidXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyKSB7XG4gICAgICAgICAgICAgIGlmIChhdHRyLm5hbWUgPT09IF9JMThOX0FUVFIgfHwgYXR0ci5uYW1lLnN0YXJ0c1dpdGgoX0kxOE5fQVRUUl9QUkVGSVgpKSB7XG4gICAgICAgICAgICAgICAgICAvLyBzdHJpcCBpMThuIHNwZWNpZmljIGF0dHJpYnV0ZXNcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoYXR0ci52YWx1ZSAmJiBhdHRyLnZhbHVlICE9ICcnICYmIGkxOG5BdHRyaWJ1dGVNZWFuaW5ncy5oYXNPd25Qcm9wZXJ0eShhdHRyLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgbWVhbmluZyA9IGkxOG5BdHRyaWJ1dGVNZWFuaW5nc1thdHRyLm5hbWVdO1xuICAgICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBfdGhpcy5fY3JlYXRlSTE4bk1lc3NhZ2UoW2F0dHJdLCBtZWFuaW5nLCAnJyk7XG4gICAgICAgICAgICAgICAgICB2YXIgaWQgPSBkaWdlc3RNZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgdmFyIG5vZGVzID0gX3RoaXMuX3RyYW5zbGF0aW9ucy5nZXQoaWQpO1xuICAgICAgICAgICAgICAgICAgaWYgKG5vZGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGVzWzBdIGluc3RhbmNlb2YgVGV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBub2Rlc1swXS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRlZEF0dHJpYnV0ZXMucHVzaChuZXcgQXR0cmlidXRlJDEoYXR0ci5uYW1lLCB2YWx1ZSwgYXR0ci5zb3VyY2VTcGFuKSk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcmVwb3J0RXJyb3IoZWwsIFwiVW5leHBlY3RlZCB0cmFuc2xhdGlvbiBmb3IgYXR0cmlidXRlIFxcXCJcIiArIGF0dHIubmFtZSArIFwiXFxcIiAoaWQ9XFxcIlwiICsgaWQgKyBcIlxcXCIpXCIpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9yZXBvcnRFcnJvcihlbCwgXCJUcmFuc2xhdGlvbiB1bmF2YWlsYWJsZSBmb3IgYXR0cmlidXRlIFxcXCJcIiArIGF0dHIubmFtZSArIFwiXFxcIiAoaWQ9XFxcIlwiICsgaWQgKyBcIlxcXCIpXCIpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdHJhbnNsYXRlZEF0dHJpYnV0ZXMucHVzaChhdHRyKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiB0cmFuc2xhdGVkQXR0cmlidXRlcztcbiAgICAgIH07XG4gICAgICAvKipcbiAgICAgICAqIEFkZCB0aGUgbm9kZSBhcyBhIGNoaWxkIG9mIHRoZSBibG9jayB3aGVuOlxuICAgICAgICogLSB3ZSBhcmUgaW4gYSBibG9jayxcbiAgICAgICAqIC0gd2UgYXJlIG5vdCBpbnNpZGUgYSBJQ1UgbWVzc2FnZSAodGhvc2UgYXJlIGhhbmRsZWQgc2VwYXJhdGVseSksXG4gICAgICAgKiAtIHRoZSBub2RlIGlzIGEgXCJkaXJlY3QgY2hpbGRcIiBvZiB0aGUgYmxvY2tcbiAgICAgICAqL1xuICAgICAgX1Zpc2l0b3IucHJvdG90eXBlLl9tYXlCZUFkZEJsb2NrQ2hpbGRyZW4gPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgIGlmICh0aGlzLl9pbkkxOG5CbG9jayAmJiAhdGhpcy5faW5JY3UgJiYgdGhpcy5fZGVwdGggPT0gdGhpcy5fYmxvY2tTdGFydERlcHRoKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2Jsb2NrQ2hpbGRyZW4ucHVzaChub2RlKTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgLyoqXG4gICAgICAgKiBNYXJrcyB0aGUgc3RhcnQgb2YgYSBzZWN0aW9uLCBzZWUgYF9lbmRTZWN0aW9uYFxuICAgICAgICovXG4gICAgICBfVmlzaXRvci5wcm90b3R5cGUuX29wZW5UcmFuc2xhdGFibGVTZWN0aW9uID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICBpZiAodGhpcy5faXNJblRyYW5zbGF0YWJsZVNlY3Rpb24pIHtcbiAgICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3Iobm9kZSwgJ1VuZXhwZWN0ZWQgc2VjdGlvbiBzdGFydCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5fbXNnQ291bnRBdFNlY3Rpb25TdGFydCA9IHRoaXMuX21lc3NhZ2VzLmxlbmd0aDtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9WaXNpdG9yLnByb3RvdHlwZSwgXCJfaXNJblRyYW5zbGF0YWJsZVNlY3Rpb25cIiwge1xuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIEEgdHJhbnNsYXRhYmxlIHNlY3Rpb24gY291bGQgYmU6XG4gICAgICAgICAgICogLSBhIHRyYW5zbGF0YWJsZSBlbGVtZW50LFxuICAgICAgICAgICAqIC0gbm9kZXMgYmV0d2VlbiBgPCEtLSBpMThuIC0tPmAgYW5kIGA8IS0tIC9pMThuIC0tPmAgY29tbWVudHNcbiAgICAgICAgICAgKi9cbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21zZ0NvdW50QXRTZWN0aW9uU3RhcnQgIT09IHZvaWQgMDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIC8qKlxuICAgICAgICogVGVybWluYXRlcyBhIHNlY3Rpb24uXG4gICAgICAgKlxuICAgICAgICogSWYgYSBzZWN0aW9uIGhhcyBvbmx5IG9uZSBzaWduaWZpY2FudCBjaGlsZHJlbiAoY29tbWVudHMgbm90IHNpZ25pZmljYW50KSB0aGVuIHdlIHNob3VsZCBub3RcbiAgICAgICAqIGtlZXAgdGhlIG1lc3NhZ2UgZnJvbSB0aGlzIGNoaWxkcmVuOlxuICAgICAgICpcbiAgICAgICAqIGA8cCBpMThuPVwibWVhbmluZ3xkZXNjcmlwdGlvblwiPntJQ1UgbWVzc2FnZX08L3A+YCB3b3VsZCBwcm9kdWNlIHR3byBtZXNzYWdlczpcbiAgICAgICAqIC0gb25lIGZvciB0aGUgPHA+IGNvbnRlbnQgd2l0aCBtZWFuaW5nIGFuZCBkZXNjcmlwdGlvbixcbiAgICAgICAqIC0gYW5vdGhlciBvbmUgZm9yIHRoZSBJQ1UgbWVzc2FnZS5cbiAgICAgICAqXG4gICAgICAgKiBJbiB0aGlzIGNhc2UgdGhlIGxhc3QgbWVzc2FnZSBpcyBkaXNjYXJkZWQgYXMgaXQgY29udGFpbnMgbGVzcyBpbmZvcm1hdGlvbiAodGhlIEFTVCBpc1xuICAgICAgICogb3RoZXJ3aXNlIGlkZW50aWNhbCkuXG4gICAgICAgKlxuICAgICAgICogTm90ZSB0aGF0IHdlIHNob3VsZCBzdGlsbCBrZWVwIG1lc3NhZ2VzIGV4dHJhY3RlZCBmcm9tIGF0dHJpYnV0ZXMgaW5zaWRlIHRoZSBzZWN0aW9uIChpZSBpbiB0aGVcbiAgICAgICAqIElDVSBtZXNzYWdlIGhlcmUpXG4gICAgICAgKi9cbiAgICAgIF9WaXNpdG9yLnByb3RvdHlwZS5fY2xvc2VUcmFuc2xhdGFibGVTZWN0aW9uID0gZnVuY3Rpb24gKG5vZGUsIGRpcmVjdENoaWxkcmVuKSB7XG4gICAgICAgICAgaWYgKCF0aGlzLl9pc0luVHJhbnNsYXRhYmxlU2VjdGlvbikge1xuICAgICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihub2RlLCAnVW5leHBlY3RlZCBzZWN0aW9uIGVuZCcpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBzdGFydEluZGV4ID0gdGhpcy5fbXNnQ291bnRBdFNlY3Rpb25TdGFydDtcbiAgICAgICAgICB2YXIgc2lnbmlmaWNhbnRDaGlsZHJlbiA9IGRpcmVjdENoaWxkcmVuLnJlZHVjZShmdW5jdGlvbiAoY291bnQsIG5vZGUpIHsgcmV0dXJuIGNvdW50ICsgKG5vZGUgaW5zdGFuY2VvZiBDb21tZW50ID8gMCA6IDEpOyB9LCAwKTtcbiAgICAgICAgICBpZiAoc2lnbmlmaWNhbnRDaGlsZHJlbiA9PSAxKSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSB0aGlzLl9tZXNzYWdlcy5sZW5ndGggLSAxOyBpID49IHN0YXJ0SW5kZXg7IGktLSkge1xuICAgICAgICAgICAgICAgICAgdmFyIGFzdCA9IHRoaXMuX21lc3NhZ2VzW2ldLm5vZGVzO1xuICAgICAgICAgICAgICAgICAgaWYgKCEoYXN0Lmxlbmd0aCA9PSAxICYmIGFzdFswXSBpbnN0YW5jZW9mIFRleHQkMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9tZXNzYWdlcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fbXNnQ291bnRBdFNlY3Rpb25TdGFydCA9IHZvaWQgMDtcbiAgICAgIH07XG4gICAgICBfVmlzaXRvci5wcm90b3R5cGUuX3JlcG9ydEVycm9yID0gZnVuY3Rpb24gKG5vZGUsIG1zZykge1xuICAgICAgICAgIHRoaXMuX2Vycm9ycy5wdXNoKG5ldyBJMThuRXJyb3Iobm9kZS5zb3VyY2VTcGFuLCBtc2cpKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gX1Zpc2l0b3I7XG4gIH0oKSk7XG4gIGZ1bmN0aW9uIF9pc09wZW5pbmdDb21tZW50KG4pIHtcbiAgICAgIHJldHVybiBuIGluc3RhbmNlb2YgQ29tbWVudCAmJiBuLnZhbHVlICYmIG4udmFsdWUuc3RhcnRzV2l0aCgnaTE4bicpO1xuICB9XG4gIGZ1bmN0aW9uIF9pc0Nsb3NpbmdDb21tZW50KG4pIHtcbiAgICAgIHJldHVybiBuIGluc3RhbmNlb2YgQ29tbWVudCAmJiBuLnZhbHVlICYmIG4udmFsdWUgPT09ICcvaTE4bic7XG4gIH1cbiAgZnVuY3Rpb24gX2dldEkxOG5BdHRyKHApIHtcbiAgICAgIHJldHVybiBwLmF0dHJzLmZpbmQoZnVuY3Rpb24gKGF0dHIpIHsgcmV0dXJuIGF0dHIubmFtZSA9PT0gX0kxOE5fQVRUUjsgfSkgfHwgbnVsbDtcbiAgfVxuICBmdW5jdGlvbiBfc3BsaXRNZWFuaW5nQW5kRGVzYyhpMThuKSB7XG4gICAgICBpZiAoIWkxOG4pXG4gICAgICAgICAgcmV0dXJuIFsnJywgJyddO1xuICAgICAgdmFyIHBpcGVJbmRleCA9IGkxOG4uaW5kZXhPZignfCcpO1xuICAgICAgcmV0dXJuIHBpcGVJbmRleCA9PSAtMSA/IFsnJywgaTE4bl0gOiBbaTE4bi5zbGljZSgwLCBwaXBlSW5kZXgpLCBpMThuLnNsaWNlKHBpcGVJbmRleCArIDEpXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIGNvbnRhaW5lciBmb3IgbWVzc2FnZSBleHRyYWN0ZWQgZnJvbSB0aGUgdGVtcGxhdGVzLlxuICAgKi9cbiAgdmFyIE1lc3NhZ2VCdW5kbGUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gTWVzc2FnZUJ1bmRsZShfaHRtbFBhcnNlciwgX2ltcGxpY2l0VGFncywgX2ltcGxpY2l0QXR0cnMpIHtcbiAgICAgICAgICB0aGlzLl9odG1sUGFyc2VyID0gX2h0bWxQYXJzZXI7XG4gICAgICAgICAgdGhpcy5faW1wbGljaXRUYWdzID0gX2ltcGxpY2l0VGFncztcbiAgICAgICAgICB0aGlzLl9pbXBsaWNpdEF0dHJzID0gX2ltcGxpY2l0QXR0cnM7XG4gICAgICAgICAgdGhpcy5fbWVzc2FnZU1hcCA9IHt9O1xuICAgICAgfVxuICAgICAgTWVzc2FnZUJ1bmRsZS5wcm90b3R5cGUudXBkYXRlRnJvbVRlbXBsYXRlID0gZnVuY3Rpb24gKGh0bWwsIHVybCwgaW50ZXJwb2xhdGlvbkNvbmZpZykge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgdmFyIGh0bWxQYXJzZXJSZXN1bHQgPSB0aGlzLl9odG1sUGFyc2VyLnBhcnNlKGh0bWwsIHVybCwgdHJ1ZSwgaW50ZXJwb2xhdGlvbkNvbmZpZyk7XG4gICAgICAgICAgaWYgKGh0bWxQYXJzZXJSZXN1bHQuZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgICByZXR1cm4gaHRtbFBhcnNlclJlc3VsdC5lcnJvcnM7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBpMThuUGFyc2VyUmVzdWx0ID0gZXh0cmFjdE1lc3NhZ2VzKGh0bWxQYXJzZXJSZXN1bHQucm9vdE5vZGVzLCBpbnRlcnBvbGF0aW9uQ29uZmlnLCB0aGlzLl9pbXBsaWNpdFRhZ3MsIHRoaXMuX2ltcGxpY2l0QXR0cnMpO1xuICAgICAgICAgIGlmIChpMThuUGFyc2VyUmVzdWx0LmVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGkxOG5QYXJzZXJSZXN1bHQuZXJyb3JzO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpMThuUGFyc2VyUmVzdWx0Lm1lc3NhZ2VzLmZvckVhY2goZnVuY3Rpb24gKG1lc3NhZ2UpIHsgX3RoaXMuX21lc3NhZ2VNYXBbZGlnZXN0TWVzc2FnZShtZXNzYWdlKV0gPSBtZXNzYWdlOyB9KTtcbiAgICAgIH07XG4gICAgICBNZXNzYWdlQnVuZGxlLnByb3RvdHlwZS5nZXRNZXNzYWdlTWFwID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fbWVzc2FnZU1hcDsgfTtcbiAgICAgIE1lc3NhZ2VCdW5kbGUucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKHNlcmlhbGl6ZXIpIHsgcmV0dXJuIHNlcmlhbGl6ZXIud3JpdGUodGhpcy5fbWVzc2FnZU1hcCk7IH07XG4gICAgICByZXR1cm4gTWVzc2FnZUJ1bmRsZTtcbiAgfSgpKTtcblxuICB2YXIgWG1sVGFnRGVmaW5pdGlvbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBYbWxUYWdEZWZpbml0aW9uKCkge1xuICAgICAgICAgIHRoaXMuY2xvc2VkQnlQYXJlbnQgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLmNvbnRlbnRUeXBlID0gVGFnQ29udGVudFR5cGUuUEFSU0FCTEVfREFUQTtcbiAgICAgICAgICB0aGlzLmlzVm9pZCA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMuaWdub3JlRmlyc3RMZiA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMuY2FuU2VsZkNsb3NlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIFhtbFRhZ0RlZmluaXRpb24ucHJvdG90eXBlLnJlcXVpcmVFeHRyYVBhcmVudCA9IGZ1bmN0aW9uIChjdXJyZW50UGFyZW50KSB7IHJldHVybiBmYWxzZTsgfTtcbiAgICAgIFhtbFRhZ0RlZmluaXRpb24ucHJvdG90eXBlLmlzQ2xvc2VkQnlDaGlsZCA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBmYWxzZTsgfTtcbiAgICAgIHJldHVybiBYbWxUYWdEZWZpbml0aW9uO1xuICB9KCkpO1xuICB2YXIgX1RBR19ERUZJTklUSU9OID0gbmV3IFhtbFRhZ0RlZmluaXRpb24oKTtcbiAgZnVuY3Rpb24gZ2V0WG1sVGFnRGVmaW5pdGlvbih0YWdOYW1lKSB7XG4gICAgICByZXR1cm4gX1RBR19ERUZJTklUSU9OO1xuICB9XG5cbiAgLyoqXG4gICAqIEBsaWNlbnNlXG4gICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgKlxuICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAqL1xuICB2YXIgX19leHRlbmRzJDYgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gIH07XG4gIHZhciBYbWxQYXJzZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDYoWG1sUGFyc2VyLCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gWG1sUGFyc2VyKCkge1xuICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGdldFhtbFRhZ0RlZmluaXRpb24pO1xuICAgICAgfVxuICAgICAgWG1sUGFyc2VyLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIChzb3VyY2UsIHVybCwgcGFyc2VFeHBhbnNpb25Gb3Jtcykge1xuICAgICAgICAgIGlmIChwYXJzZUV4cGFuc2lvbkZvcm1zID09PSB2b2lkIDApIHsgcGFyc2VFeHBhbnNpb25Gb3JtcyA9IGZhbHNlOyB9XG4gICAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUucGFyc2UuY2FsbCh0aGlzLCBzb3VyY2UsIHVybCwgcGFyc2VFeHBhbnNpb25Gb3JtcywgbnVsbCk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIFhtbFBhcnNlcjtcbiAgfShQYXJzZXIkMSkpO1xuXG4gIC8qKlxuICAgKiBAbGljZW5zZVxuICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICpcbiAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgKi9cbiAgLy8gR2VuZXJhdGUgYSBtYXAgb2YgcGxhY2Vob2xkZXIgdG8gY29udGVudCBpbmRleGVkIGJ5IG1lc3NhZ2UgaWRzXG4gIGZ1bmN0aW9uIGV4dHJhY3RQbGFjZWhvbGRlcnMobWVzc2FnZUJ1bmRsZSkge1xuICAgICAgdmFyIG1lc3NhZ2VNYXAgPSBtZXNzYWdlQnVuZGxlLmdldE1lc3NhZ2VNYXAoKTtcbiAgICAgIHZhciBwbGFjZWhvbGRlcnMgPSB7fTtcbiAgICAgIE9iamVjdC5rZXlzKG1lc3NhZ2VNYXApLmZvckVhY2goZnVuY3Rpb24gKG1zZ0lkKSB7XG4gICAgICAgICAgcGxhY2Vob2xkZXJzW21zZ0lkXSA9IG1lc3NhZ2VNYXBbbXNnSWRdLnBsYWNlaG9sZGVycztcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHBsYWNlaG9sZGVycztcbiAgfVxuICAvLyBHZW5lcmF0ZSBhIG1hcCBvZiBwbGFjZWhvbGRlciB0byBtZXNzYWdlIGlkcyBpbmRleGVkIGJ5IG1lc3NhZ2UgaWRzXG4gIGZ1bmN0aW9uIGV4dHJhY3RQbGFjZWhvbGRlclRvSWRzKG1lc3NhZ2VCdW5kbGUpIHtcbiAgICAgIHZhciBtZXNzYWdlTWFwID0gbWVzc2FnZUJ1bmRsZS5nZXRNZXNzYWdlTWFwKCk7XG4gICAgICB2YXIgcGxhY2Vob2xkZXJUb0lkcyA9IHt9O1xuICAgICAgT2JqZWN0LmtleXMobWVzc2FnZU1hcCkuZm9yRWFjaChmdW5jdGlvbiAobXNnSWQpIHtcbiAgICAgICAgICBwbGFjZWhvbGRlclRvSWRzW21zZ0lkXSA9IG1lc3NhZ2VNYXBbbXNnSWRdLnBsYWNlaG9sZGVyVG9Nc2dJZHM7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBwbGFjZWhvbGRlclRvSWRzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBsaWNlbnNlXG4gICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgKlxuICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAqL1xuICB2YXIgX19leHRlbmRzJDcgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gIH07XG4gIHZhciBfVmlzaXRvciQxID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIF9WaXNpdG9yKCkge1xuICAgICAgfVxuICAgICAgX1Zpc2l0b3IucHJvdG90eXBlLnZpc2l0VGFnID0gZnVuY3Rpb24gKHRhZykge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgdmFyIHN0ckF0dHJzID0gdGhpcy5fc2VyaWFsaXplQXR0cmlidXRlcyh0YWcuYXR0cnMpO1xuICAgICAgICAgIGlmICh0YWcuY2hpbGRyZW4ubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFwiPFwiICsgdGFnLm5hbWUgKyBzdHJBdHRycyArIFwiLz5cIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHN0ckNoaWxkcmVuID0gdGFnLmNoaWxkcmVuLm1hcChmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZS52aXNpdChfdGhpcyk7IH0pO1xuICAgICAgICAgIHJldHVybiBcIjxcIiArIHRhZy5uYW1lICsgc3RyQXR0cnMgKyBcIj5cIiArIHN0ckNoaWxkcmVuLmpvaW4oJycpICsgXCI8L1wiICsgdGFnLm5hbWUgKyBcIj5cIjtcbiAgICAgIH07XG4gICAgICBfVmlzaXRvci5wcm90b3R5cGUudmlzaXRUZXh0ID0gZnVuY3Rpb24gKHRleHQpIHsgcmV0dXJuIHRleHQudmFsdWU7IH07XG4gICAgICBfVmlzaXRvci5wcm90b3R5cGUudmlzaXREZWNsYXJhdGlvbiA9IGZ1bmN0aW9uIChkZWNsKSB7XG4gICAgICAgICAgcmV0dXJuIFwiPD94bWxcIiArIHRoaXMuX3NlcmlhbGl6ZUF0dHJpYnV0ZXMoZGVjbC5hdHRycykgKyBcIiA/PlwiO1xuICAgICAgfTtcbiAgICAgIF9WaXNpdG9yLnByb3RvdHlwZS5fc2VyaWFsaXplQXR0cmlidXRlcyA9IGZ1bmN0aW9uIChhdHRycykge1xuICAgICAgICAgIHZhciBzdHJBdHRycyA9IE9iamVjdC5rZXlzKGF0dHJzKS5tYXAoZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIChuYW1lICsgXCI9XFxcIlwiICsgYXR0cnNbbmFtZV0gKyBcIlxcXCJcIik7IH0pLmpvaW4oJyAnKTtcbiAgICAgICAgICByZXR1cm4gc3RyQXR0cnMubGVuZ3RoID4gMCA/ICcgJyArIHN0ckF0dHJzIDogJyc7XG4gICAgICB9O1xuICAgICAgX1Zpc2l0b3IucHJvdG90eXBlLnZpc2l0RG9jdHlwZSA9IGZ1bmN0aW9uIChkb2N0eXBlKSB7XG4gICAgICAgICAgcmV0dXJuIFwiPCFET0NUWVBFIFwiICsgZG9jdHlwZS5yb290VGFnICsgXCIgW1xcblwiICsgZG9jdHlwZS5kdGQgKyBcIlxcbl0+XCI7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIF9WaXNpdG9yO1xuICB9KCkpO1xuICB2YXIgX3Zpc2l0b3IgPSBuZXcgX1Zpc2l0b3IkMSgpO1xuICBmdW5jdGlvbiBzZXJpYWxpemUobm9kZXMpIHtcbiAgICAgIHJldHVybiBub2Rlcy5tYXAoZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGUudmlzaXQoX3Zpc2l0b3IpOyB9KS5qb2luKCcnKTtcbiAgfVxuICB2YXIgRGVjbGFyYXRpb24gPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gRGVjbGFyYXRpb24odW5lc2NhcGVkQXR0cnMpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHRoaXMuYXR0cnMgPSB7fTtcbiAgICAgICAgICBPYmplY3Qua2V5cyh1bmVzY2FwZWRBdHRycykuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgICBfdGhpcy5hdHRyc1trXSA9IF9lc2NhcGVYbWwodW5lc2NhcGVkQXR0cnNba10pO1xuICAgICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgRGVjbGFyYXRpb24ucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IpIHsgcmV0dXJuIHZpc2l0b3IudmlzaXREZWNsYXJhdGlvbih0aGlzKTsgfTtcbiAgICAgIHJldHVybiBEZWNsYXJhdGlvbjtcbiAgfSgpKTtcbiAgdmFyIERvY3R5cGUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gRG9jdHlwZShyb290VGFnLCBkdGQpIHtcbiAgICAgICAgICB0aGlzLnJvb3RUYWcgPSByb290VGFnO1xuICAgICAgICAgIHRoaXMuZHRkID0gZHRkO1xuICAgICAgfVxuICAgICAgO1xuICAgICAgRG9jdHlwZS5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvcikgeyByZXR1cm4gdmlzaXRvci52aXNpdERvY3R5cGUodGhpcyk7IH07XG4gICAgICByZXR1cm4gRG9jdHlwZTtcbiAgfSgpKTtcbiAgdmFyIFRhZyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBUYWcobmFtZSwgdW5lc2NhcGVkQXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICBpZiAodW5lc2NhcGVkQXR0cnMgPT09IHZvaWQgMCkgeyB1bmVzY2FwZWRBdHRycyA9IHt9OyB9XG4gICAgICAgICAgaWYgKGNoaWxkcmVuID09PSB2b2lkIDApIHsgY2hpbGRyZW4gPSBbXTsgfVxuICAgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgICAgIHRoaXMuYXR0cnMgPSB7fTtcbiAgICAgICAgICBPYmplY3Qua2V5cyh1bmVzY2FwZWRBdHRycykuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgICBfdGhpcy5hdHRyc1trXSA9IF9lc2NhcGVYbWwodW5lc2NhcGVkQXR0cnNba10pO1xuICAgICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgVGFnLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yKSB7IHJldHVybiB2aXNpdG9yLnZpc2l0VGFnKHRoaXMpOyB9O1xuICAgICAgcmV0dXJuIFRhZztcbiAgfSgpKTtcbiAgdmFyIFRleHQkMiA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBUZXh0KHVuZXNjYXBlZFZhbHVlKSB7XG4gICAgICAgICAgdGhpcy52YWx1ZSA9IF9lc2NhcGVYbWwodW5lc2NhcGVkVmFsdWUpO1xuICAgICAgfVxuICAgICAgO1xuICAgICAgVGV4dC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvcikgeyByZXR1cm4gdmlzaXRvci52aXNpdFRleHQodGhpcyk7IH07XG4gICAgICByZXR1cm4gVGV4dDtcbiAgfSgpKTtcbiAgdmFyIENSID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQ3KENSLCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gQ1Iod3MpIHtcbiAgICAgICAgICBpZiAod3MgPT09IHZvaWQgMCkgeyB3cyA9IDA7IH1cbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBcIlxcblwiICsgbmV3IEFycmF5KHdzICsgMSkuam9pbignICcpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBDUjtcbiAgfShUZXh0JDIpKTtcbiAgdmFyIF9FU0NBUEVEX0NIQVJTID0gW1xuICAgICAgWy8mL2csICcmYW1wOyddLFxuICAgICAgWy9cIi9nLCAnJnF1b3Q7J10sXG4gICAgICBbLycvZywgJyZhcG9zOyddLFxuICAgICAgWy88L2csICcmbHQ7J10sXG4gICAgICBbLz4vZywgJyZndDsnXSxcbiAgXTtcbiAgZnVuY3Rpb24gX2VzY2FwZVhtbCh0ZXh0KSB7XG4gICAgICByZXR1cm4gX0VTQ0FQRURfQ0hBUlMucmVkdWNlKGZ1bmN0aW9uICh0ZXh0LCBlbnRyeSkgeyByZXR1cm4gdGV4dC5yZXBsYWNlKGVudHJ5WzBdLCBlbnRyeVsxXSk7IH0sIHRleHQpO1xuICB9XG5cbiAgdmFyIF9WRVJTSU9OID0gJzEuMic7XG4gIHZhciBfWE1MTlMgPSAndXJuOm9hc2lzOm5hbWVzOnRjOnhsaWZmOmRvY3VtZW50OjEuMic7XG4gIC8vIFRPRE8odmljYik6IG1ha2UgdGhpcyBhIHBhcmFtIChzL18vLS8pXG4gIHZhciBfU09VUkNFX0xBTkcgPSAnZW4nO1xuICB2YXIgX1BMQUNFSE9MREVSX1RBRyA9ICd4JztcbiAgdmFyIF9TT1VSQ0VfVEFHID0gJ3NvdXJjZSc7XG4gIHZhciBfVEFSR0VUX1RBRyA9ICd0YXJnZXQnO1xuICB2YXIgX1VOSVRfVEFHID0gJ3RyYW5zLXVuaXQnO1xuICAvLyBodHRwOi8vZG9jcy5vYXNpcy1vcGVuLm9yZy94bGlmZi92MS4yL29zL3hsaWZmLWNvcmUuaHRtbFxuICAvLyBodHRwOi8vZG9jcy5vYXNpcy1vcGVuLm9yZy94bGlmZi92MS4yL3hsaWZmLXByb2ZpbGUtaHRtbC94bGlmZi1wcm9maWxlLWh0bWwtMS4yLmh0bWxcbiAgdmFyIFhsaWZmID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIFhsaWZmKF9odG1sUGFyc2VyLCBfaW50ZXJwb2xhdGlvbkNvbmZpZykge1xuICAgICAgICAgIHRoaXMuX2h0bWxQYXJzZXIgPSBfaHRtbFBhcnNlcjtcbiAgICAgICAgICB0aGlzLl9pbnRlcnBvbGF0aW9uQ29uZmlnID0gX2ludGVycG9sYXRpb25Db25maWc7XG4gICAgICB9XG4gICAgICBYbGlmZi5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAobWVzc2FnZU1hcCkge1xuICAgICAgICAgIHZhciB2aXNpdG9yID0gbmV3IF9Xcml0ZVZpc2l0b3IoKTtcbiAgICAgICAgICB2YXIgdHJhbnNVbml0cyA9IFtdO1xuICAgICAgICAgIE9iamVjdC5rZXlzKG1lc3NhZ2VNYXApLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgICAgICAgIHZhciBtZXNzYWdlID0gbWVzc2FnZU1hcFtpZF07XG4gICAgICAgICAgICAgIHZhciB0cmFuc1VuaXQgPSBuZXcgVGFnKF9VTklUX1RBRywgeyBpZDogaWQsIGRhdGF0eXBlOiAnaHRtbCcgfSk7XG4gICAgICAgICAgICAgIHRyYW5zVW5pdC5jaGlsZHJlbi5wdXNoKG5ldyBDUig4KSwgbmV3IFRhZyhfU09VUkNFX1RBRywge30sIHZpc2l0b3Iuc2VyaWFsaXplKG1lc3NhZ2Uubm9kZXMpKSwgbmV3IENSKDgpLCBuZXcgVGFnKF9UQVJHRVRfVEFHKSk7XG4gICAgICAgICAgICAgIGlmIChtZXNzYWdlLmRlc2NyaXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgICB0cmFuc1VuaXQuY2hpbGRyZW4ucHVzaChuZXcgQ1IoOCksIG5ldyBUYWcoJ25vdGUnLCB7IHByaW9yaXR5OiAnMScsIGZyb206ICdkZXNjcmlwdGlvbicgfSwgW25ldyBUZXh0JDIobWVzc2FnZS5kZXNjcmlwdGlvbildKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UubWVhbmluZykge1xuICAgICAgICAgICAgICAgICAgdHJhbnNVbml0LmNoaWxkcmVuLnB1c2gobmV3IENSKDgpLCBuZXcgVGFnKCdub3RlJywgeyBwcmlvcml0eTogJzEnLCBmcm9tOiAnbWVhbmluZycgfSwgW25ldyBUZXh0JDIobWVzc2FnZS5tZWFuaW5nKV0pKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0cmFuc1VuaXQuY2hpbGRyZW4ucHVzaChuZXcgQ1IoNikpO1xuICAgICAgICAgICAgICB0cmFuc1VuaXRzLnB1c2gobmV3IENSKDYpLCB0cmFuc1VuaXQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHZhciBib2R5ID0gbmV3IFRhZygnYm9keScsIHt9LCB0cmFuc1VuaXRzLmNvbmNhdChbbmV3IENSKDQpXSkpO1xuICAgICAgICAgIHZhciBmaWxlID0gbmV3IFRhZygnZmlsZScsIHsgJ3NvdXJjZS1sYW5ndWFnZSc6IF9TT1VSQ0VfTEFORywgZGF0YXR5cGU6ICdwbGFpbnRleHQnLCBvcmlnaW5hbDogJ25nMi50ZW1wbGF0ZScgfSwgW25ldyBDUig0KSwgYm9keSwgbmV3IENSKDIpXSk7XG4gICAgICAgICAgdmFyIHhsaWZmID0gbmV3IFRhZygneGxpZmYnLCB7IHZlcnNpb246IF9WRVJTSU9OLCB4bWxuczogX1hNTE5TIH0sIFtuZXcgQ1IoMiksIGZpbGUsIG5ldyBDUigpXSk7XG4gICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZShbXG4gICAgICAgICAgICAgIG5ldyBEZWNsYXJhdGlvbih7IHZlcnNpb246ICcxLjAnLCBlbmNvZGluZzogJ1VURi04JyB9KSwgbmV3IENSKCksIHhsaWZmLCBuZXcgQ1IoKVxuICAgICAgICAgIF0pO1xuICAgICAgfTtcbiAgICAgIFhsaWZmLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKGNvbnRlbnQsIHVybCwgbWVzc2FnZUJ1bmRsZSkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgLy8gUGFyc2UgdGhlIHh0YiBmaWxlIGludG8geG1sIG5vZGVzXG4gICAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBYbWxQYXJzZXIoKS5wYXJzZShjb250ZW50LCB1cmwpO1xuICAgICAgICAgIGlmIChyZXN1bHQuZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ4dGIgcGFyc2UgZXJyb3JzOlxcblwiICsgcmVzdWx0LmVycm9ycy5qb2luKCdcXG4nKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFJlcGxhY2UgdGhlIHBsYWNlaG9sZGVycywgbWVzc2FnZXMgYXJlIG5vdyBzdHJpbmdcbiAgICAgICAgICB2YXIgX2EgPSBuZXcgX0xvYWRWaXNpdG9yKCkucGFyc2UocmVzdWx0LnJvb3ROb2RlcywgbWVzc2FnZUJ1bmRsZSksIG1lc3NhZ2VzID0gX2EubWVzc2FnZXMsIGVycm9ycyA9IF9hLmVycm9ycztcbiAgICAgICAgICBpZiAoZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ4dGIgcGFyc2UgZXJyb3JzOlxcblwiICsgZXJyb3JzLmpvaW4oJ1xcbicpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gQ29udmVydCB0aGUgc3RyaW5nIG1lc3NhZ2VzIHRvIGh0bWwgYXN0XG4gICAgICAgICAgLy8gVE9ETyh2aWNiKTogbWFwIGVycm9yIG1lc3NhZ2UgYmFjayB0byB0aGUgb3JpZ2luYWwgbWVzc2FnZSBpbiB4dGJcbiAgICAgICAgICB2YXIgbWVzc2FnZU1hcCA9IHt9O1xuICAgICAgICAgIHZhciBwYXJzZUVycm9ycyA9IFtdO1xuICAgICAgICAgIE9iamVjdC5rZXlzKG1lc3NhZ2VzKS5mb3JFYWNoKGZ1bmN0aW9uIChpZCkge1xuICAgICAgICAgICAgICB2YXIgcmVzID0gX3RoaXMuX2h0bWxQYXJzZXIucGFyc2UobWVzc2FnZXNbaWRdLCB1cmwsIHRydWUsIF90aGlzLl9pbnRlcnBvbGF0aW9uQ29uZmlnKTtcbiAgICAgICAgICAgICAgcGFyc2VFcnJvcnMucHVzaC5hcHBseShwYXJzZUVycm9ycywgcmVzLmVycm9ycyk7XG4gICAgICAgICAgICAgIG1lc3NhZ2VNYXBbaWRdID0gcmVzLnJvb3ROb2RlcztcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAocGFyc2VFcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInh0YiBwYXJzZSBlcnJvcnM6XFxuXCIgKyBwYXJzZUVycm9ycy5qb2luKCdcXG4nKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBtZXNzYWdlTWFwO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBYbGlmZjtcbiAgfSgpKTtcbiAgdmFyIF9Xcml0ZVZpc2l0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gX1dyaXRlVmlzaXRvcigpIHtcbiAgICAgIH1cbiAgICAgIF9Xcml0ZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0VGV4dCA9IGZ1bmN0aW9uICh0ZXh0LCBjb250ZXh0KSB7IHJldHVybiBbbmV3IFRleHQkMih0ZXh0LnZhbHVlKV07IH07XG4gICAgICBfV3JpdGVWaXNpdG9yLnByb3RvdHlwZS52aXNpdENvbnRhaW5lciA9IGZ1bmN0aW9uIChjb250YWluZXIsIGNvbnRleHQpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHZhciBub2RlcyA9IFtdO1xuICAgICAgICAgIGNvbnRhaW5lci5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBub2Rlcy5wdXNoLmFwcGx5KG5vZGVzLCBub2RlLnZpc2l0KF90aGlzKSk7IH0pO1xuICAgICAgICAgIHJldHVybiBub2RlcztcbiAgICAgIH07XG4gICAgICBfV3JpdGVWaXNpdG9yLnByb3RvdHlwZS52aXNpdEljdSA9IGZ1bmN0aW9uIChpY3UsIGNvbnRleHQpIHtcbiAgICAgICAgICBpZiAodGhpcy5faXNJbkljdSkge1xuICAgICAgICAgICAgICAvLyBuZXN0ZWQgSUNVIGlzIG5vdCBzdXBwb3J0ZWRcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd4bGlmZiBkb2VzIG5vdCBzdXBwb3J0IG5lc3RlZCBJQ1UgbWVzc2FnZXMnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5faXNJbkljdSA9IHRydWU7XG4gICAgICAgICAgLy8gVE9ETyh2aWNiKTogc3VwcG9ydCBJQ1UgbWVzc2FnZXNcbiAgICAgICAgICAvLyBodHRwczovL2xpc3RzLm9hc2lzLW9wZW4ub3JnL2FyY2hpdmVzL3hsaWZmLzIwMTIwMS9tc2cwMDAyOC5odG1sXG4gICAgICAgICAgLy8gaHR0cDovL2RvY3Mub2FzaXMtb3Blbi5vcmcveGxpZmYvdjEuMi94bGlmZi1wcm9maWxlLXBvL3hsaWZmLXByb2ZpbGUtcG8tMS4yLWNkMDIuaHRtbFxuICAgICAgICAgIHZhciBub2RlcyA9IFtdO1xuICAgICAgICAgIHRoaXMuX2lzSW5JY3UgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gbm9kZXM7XG4gICAgICB9O1xuICAgICAgX1dyaXRlVmlzaXRvci5wcm90b3R5cGUudmlzaXRUYWdQbGFjZWhvbGRlciA9IGZ1bmN0aW9uIChwaCwgY29udGV4dCkge1xuICAgICAgICAgIHZhciBjdHlwZSA9IGdldEN0eXBlRm9yVGFnKHBoLnRhZyk7XG4gICAgICAgICAgdmFyIHN0YXJ0VGFnUGggPSBuZXcgVGFnKF9QTEFDRUhPTERFUl9UQUcsIHsgaWQ6IHBoLnN0YXJ0TmFtZSwgY3R5cGU6IGN0eXBlIH0pO1xuICAgICAgICAgIGlmIChwaC5pc1ZvaWQpIHtcbiAgICAgICAgICAgICAgLy8gdm9pZCB0YWdzIGhhdmUgbm8gY2hpbGRyZW4gbm9yIGNsb3NpbmcgdGFnc1xuICAgICAgICAgICAgICByZXR1cm4gW3N0YXJ0VGFnUGhdO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgY2xvc2VUYWdQaCA9IG5ldyBUYWcoX1BMQUNFSE9MREVSX1RBRywgeyBpZDogcGguY2xvc2VOYW1lLCBjdHlwZTogY3R5cGUgfSk7XG4gICAgICAgICAgcmV0dXJuIFtzdGFydFRhZ1BoXS5jb25jYXQodGhpcy5zZXJpYWxpemUocGguY2hpbGRyZW4pLCBbY2xvc2VUYWdQaF0pO1xuICAgICAgfTtcbiAgICAgIF9Xcml0ZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0UGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAocGgsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gW25ldyBUYWcoX1BMQUNFSE9MREVSX1RBRywgeyBpZDogcGgubmFtZSB9KV07XG4gICAgICB9O1xuICAgICAgX1dyaXRlVmlzaXRvci5wcm90b3R5cGUudmlzaXRJY3VQbGFjZWhvbGRlciA9IGZ1bmN0aW9uIChwaCwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiBbbmV3IFRhZyhfUExBQ0VIT0xERVJfVEFHLCB7IGlkOiBwaC5uYW1lIH0pXTtcbiAgICAgIH07XG4gICAgICBfV3JpdGVWaXNpdG9yLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiAobm9kZXMpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHRoaXMuX2lzSW5JY3UgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gTGlzdFdyYXBwZXIuZmxhdHRlbihub2Rlcy5tYXAoZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGUudmlzaXQoX3RoaXMpOyB9KSk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIF9Xcml0ZVZpc2l0b3I7XG4gIH0oKSk7XG4gIC8vIFRPRE8odmljYik6IGFkZCBlcnJvciBtYW5hZ2VtZW50IChzdHJ1Y3R1cmUpXG4gIC8vIFRPRE8odmljYik6IGZhY3Rvcml6ZSAoeHRiKSA/XG4gIHZhciBfTG9hZFZpc2l0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gX0xvYWRWaXNpdG9yKCkge1xuICAgICAgfVxuICAgICAgX0xvYWRWaXNpdG9yLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIChub2RlcywgbWVzc2FnZUJ1bmRsZSkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgdGhpcy5fbWVzc2FnZU5vZGVzID0gW107XG4gICAgICAgICAgdGhpcy5fdHJhbnNsYXRlZE1lc3NhZ2VzID0ge307XG4gICAgICAgICAgdGhpcy5fbXNnSWQgPSAnJztcbiAgICAgICAgICB0aGlzLl90YXJnZXQgPSBbXTtcbiAgICAgICAgICB0aGlzLl9lcnJvcnMgPSBbXTtcbiAgICAgICAgICAvLyBGaW5kIGFsbCBtZXNzYWdlc1xuICAgICAgICAgIHZpc2l0QWxsKHRoaXMsIG5vZGVzLCBudWxsKTtcbiAgICAgICAgICB2YXIgbWVzc2FnZU1hcCA9IG1lc3NhZ2VCdW5kbGUuZ2V0TWVzc2FnZU1hcCgpO1xuICAgICAgICAgIHZhciBwbGFjZWhvbGRlcnMgPSBleHRyYWN0UGxhY2Vob2xkZXJzKG1lc3NhZ2VCdW5kbGUpO1xuICAgICAgICAgIHZhciBwbGFjZWhvbGRlclRvSWRzID0gZXh0cmFjdFBsYWNlaG9sZGVyVG9JZHMobWVzc2FnZUJ1bmRsZSk7XG4gICAgICAgICAgdGhpcy5fbWVzc2FnZU5vZGVzXG4gICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgLy8gUmVtb3ZlIGFueSBtZXNzYWdlcyB0aGF0IGlzIG5vdCBwcmVzZW50IGluIHRoZSBzb3VyY2UgbWVzc2FnZSBidW5kbGUuXG4gICAgICAgICAgICAgIHJldHVybiBtZXNzYWdlTWFwLmhhc093blByb3BlcnR5KG1lc3NhZ2VbMF0pO1xuICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICAgIC8vIEJlY2F1c2UgdGhlcmUgY291bGQgYmUgbm8gSUNVIHBsYWNlaG9sZGVycyBpbnNpZGUgYW4gSUNVIG1lc3NhZ2UsXG4gICAgICAgICAgICAgIC8vIHdlIGRvIG5vdCBuZWVkIHRvIHRha2UgaW50byBhY2NvdW50IHRoZSBgcGxhY2Vob2xkZXJUb01zZ0lkc2Agb2YgdGhlIHJlZmVyZW5jZWRcbiAgICAgICAgICAgICAgLy8gbWVzc2FnZXMsIHRob3NlIHdvdWxkIGFsd2F5cyBiZSBlbXB0eVxuICAgICAgICAgICAgICAvLyBUT0RPKHZpY2IpOiBvdmVya2lsbCAtIGNyZWF0ZSAyIGJ1Y2tldHMgYW5kIFsuLi53b0RlcHMsIC4uLndEZXBzXS5wcm9jZXNzKClcbiAgICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKG1lc3NhZ2VNYXBbYVswXV0ucGxhY2Vob2xkZXJUb01zZ0lkcykubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMobWVzc2FnZU1hcFtiWzBdXS5wbGFjZWhvbGRlclRvTXNnSWRzKS5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgfSlcbiAgICAgICAgICAgICAgLmZvckVhY2goZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgdmFyIGlkID0gbWVzc2FnZVswXTtcbiAgICAgICAgICAgICAgX3RoaXMuX3BsYWNlaG9sZGVycyA9IHBsYWNlaG9sZGVyc1tpZF0gfHwge307XG4gICAgICAgICAgICAgIF90aGlzLl9wbGFjZWhvbGRlclRvSWRzID0gcGxhY2Vob2xkZXJUb0lkc1tpZF0gfHwge307XG4gICAgICAgICAgICAgIC8vIFRPRE8odmljYik6IG1ha2Ugc3VyZSB0aGVyZSBpcyBubyBgX1RSQU5TTEFUSU9OU19UQUdgIG5vciBgX1RSQU5TTEFUSU9OX1RBR2BcbiAgICAgICAgICAgICAgX3RoaXMuX3RyYW5zbGF0ZWRNZXNzYWdlc1tpZF0gPSB2aXNpdEFsbChfdGhpcywgbWVzc2FnZVsxXSkuam9pbignJyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIHsgbWVzc2FnZXM6IHRoaXMuX3RyYW5zbGF0ZWRNZXNzYWdlcywgZXJyb3JzOiB0aGlzLl9lcnJvcnMgfTtcbiAgICAgIH07XG4gICAgICBfTG9hZFZpc2l0b3IucHJvdG90eXBlLnZpc2l0RWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtZW50LCBjb250ZXh0KSB7XG4gICAgICAgICAgc3dpdGNoIChlbGVtZW50Lm5hbWUpIHtcbiAgICAgICAgICAgICAgY2FzZSBfVU5JVF9UQUc6XG4gICAgICAgICAgICAgICAgICB0aGlzLl90YXJnZXQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgdmFyIG1zZ0lkID0gZWxlbWVudC5hdHRycy5maW5kKGZ1bmN0aW9uIChhdHRyKSB7IHJldHVybiBhdHRyLm5hbWUgPT09ICdpZCc7IH0pO1xuICAgICAgICAgICAgICAgICAgaWYgKCFtc2dJZCkge1xuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZEVycm9yKGVsZW1lbnQsIFwiPFwiICsgX1VOSVRfVEFHICsgXCI+IG1pc3NlcyB0aGUgXFxcImlkXFxcIiBhdHRyaWJ1dGVcIik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9tc2dJZCA9IG1zZ0lkLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgdmlzaXRBbGwodGhpcywgZWxlbWVudC5jaGlsZHJlbiwgbnVsbCk7XG4gICAgICAgICAgICAgICAgICBpZiAodGhpcy5fbXNnSWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9tZXNzYWdlTm9kZXMucHVzaChbdGhpcy5fbXNnSWQsIHRoaXMuX3RhcmdldF0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgX1NPVVJDRV9UQUc6XG4gICAgICAgICAgICAgICAgICAvLyBpZ25vcmUgc291cmNlIG1lc3NhZ2VcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIF9UQVJHRVRfVEFHOlxuICAgICAgICAgICAgICAgICAgdGhpcy5fdGFyZ2V0ID0gZWxlbWVudC5jaGlsZHJlbjtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIF9QTEFDRUhPTERFUl9UQUc6XG4gICAgICAgICAgICAgICAgICB2YXIgaWRBdHRyID0gZWxlbWVudC5hdHRycy5maW5kKGZ1bmN0aW9uIChhdHRyKSB7IHJldHVybiBhdHRyLm5hbWUgPT09ICdpZCc7IH0pO1xuICAgICAgICAgICAgICAgICAgaWYgKCFpZEF0dHIpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRFcnJvcihlbGVtZW50LCBcIjxcIiArIF9QTEFDRUhPTERFUl9UQUcgKyBcIj4gbWlzc2VzIHRoZSBcXFwiaWRcXFwiIGF0dHJpYnV0ZVwiKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBpZCA9IGlkQXR0ci52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fcGxhY2Vob2xkZXJzLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcGxhY2Vob2xkZXJzW2lkXTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3BsYWNlaG9sZGVyVG9JZHMuaGFzT3duUHJvcGVydHkoaWQpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3RyYW5zbGF0ZWRNZXNzYWdlcy5oYXNPd25Qcm9wZXJ0eSh0aGlzLl9wbGFjZWhvbGRlclRvSWRzW2lkXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zbGF0ZWRNZXNzYWdlc1t0aGlzLl9wbGFjZWhvbGRlclRvSWRzW2lkXV07XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8odmljYik6IGJldHRlciBlcnJvciBtZXNzYWdlIGZvciB3aGVuXG4gICAgICAgICAgICAgICAgICAgICAgLy8gIXRoaXMuX3RyYW5zbGF0ZWRNZXNzYWdlcy5oYXNPd25Qcm9wZXJ0eSh0aGlzLl9wbGFjZWhvbGRlclRvSWRzW2lkXSlcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRFcnJvcihlbGVtZW50LCBcIlRoZSBwbGFjZWhvbGRlciBcXFwiXCIgKyBpZCArIFwiXFxcIiBkb2VzIG5vdCBleGlzdHMgaW4gdGhlIHNvdXJjZSBtZXNzYWdlXCIpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICB2aXNpdEFsbCh0aGlzLCBlbGVtZW50LmNoaWxkcmVuLCBudWxsKTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgX0xvYWRWaXNpdG9yLnByb3RvdHlwZS52aXNpdEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChhdHRyaWJ1dGUsIGNvbnRleHQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VucmVhY2hhYmxlIGNvZGUnKTtcbiAgICAgIH07XG4gICAgICBfTG9hZFZpc2l0b3IucHJvdG90eXBlLnZpc2l0VGV4dCA9IGZ1bmN0aW9uICh0ZXh0LCBjb250ZXh0KSB7IHJldHVybiB0ZXh0LnZhbHVlOyB9O1xuICAgICAgX0xvYWRWaXNpdG9yLnByb3RvdHlwZS52aXNpdENvbW1lbnQgPSBmdW5jdGlvbiAoY29tbWVudCwgY29udGV4dCkgeyByZXR1cm4gJyc7IH07XG4gICAgICBfTG9hZFZpc2l0b3IucHJvdG90eXBlLnZpc2l0RXhwYW5zaW9uID0gZnVuY3Rpb24gKGV4cGFuc2lvbiwgY29udGV4dCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndW5yZWFjaGFibGUgY29kZScpO1xuICAgICAgfTtcbiAgICAgIF9Mb2FkVmlzaXRvci5wcm90b3R5cGUudmlzaXRFeHBhbnNpb25DYXNlID0gZnVuY3Rpb24gKGV4cGFuc2lvbkNhc2UsIGNvbnRleHQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VucmVhY2hhYmxlIGNvZGUnKTtcbiAgICAgIH07XG4gICAgICBfTG9hZFZpc2l0b3IucHJvdG90eXBlLl9hZGRFcnJvciA9IGZ1bmN0aW9uIChub2RlLCBtZXNzYWdlKSB7XG4gICAgICAgICAgdGhpcy5fZXJyb3JzLnB1c2gobmV3IEkxOG5FcnJvcihub2RlLnNvdXJjZVNwYW4sIG1lc3NhZ2UpKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gX0xvYWRWaXNpdG9yO1xuICB9KCkpO1xuICBmdW5jdGlvbiBnZXRDdHlwZUZvclRhZyh0YWcpIHtcbiAgICAgIHN3aXRjaCAodGFnLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICBjYXNlICdicic6XG4gICAgICAgICAgICAgIHJldHVybiAnbGInO1xuICAgICAgICAgIGNhc2UgJ2ltZyc6XG4gICAgICAgICAgICAgIHJldHVybiAnaW1hZ2UnO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHJldHVybiBcIngtXCIgKyB0YWc7XG4gICAgICB9XG4gIH1cblxuICB2YXIgX01FU1NBR0VTX1RBRyA9ICdtZXNzYWdlYnVuZGxlJztcbiAgdmFyIF9NRVNTQUdFX1RBRyA9ICdtc2cnO1xuICB2YXIgX1BMQUNFSE9MREVSX1RBRyQxID0gJ3BoJztcbiAgdmFyIF9FWEVNUExFX1RBRyA9ICdleCc7XG4gIHZhciBfRE9DVFlQRSA9IFwiPCFFTEVNRU5UIG1lc3NhZ2VidW5kbGUgKG1zZykqPlxcbjwhQVRUTElTVCBtZXNzYWdlYnVuZGxlIGNsYXNzIENEQVRBICNJTVBMSUVEPlxcblxcbjwhRUxFTUVOVCBtc2cgKCNQQ0RBVEF8cGh8c291cmNlKSo+XFxuPCFBVFRMSVNUIG1zZyBpZCBDREFUQSAjSU1QTElFRD5cXG48IUFUVExJU1QgbXNnIHNlcSBDREFUQSAjSU1QTElFRD5cXG48IUFUVExJU1QgbXNnIG5hbWUgQ0RBVEEgI0lNUExJRUQ+XFxuPCFBVFRMSVNUIG1zZyBkZXNjIENEQVRBICNJTVBMSUVEPlxcbjwhQVRUTElTVCBtc2cgbWVhbmluZyBDREFUQSAjSU1QTElFRD5cXG48IUFUVExJU1QgbXNnIG9ic29sZXRlIChvYnNvbGV0ZSkgI0lNUExJRUQ+XFxuPCFBVFRMSVNUIG1zZyB4bWw6c3BhY2UgKGRlZmF1bHR8cHJlc2VydmUpIFxcXCJkZWZhdWx0XFxcIj5cXG48IUFUVExJU1QgbXNnIGlzX2hpZGRlbiBDREFUQSAjSU1QTElFRD5cXG5cXG48IUVMRU1FTlQgc291cmNlICgjUENEQVRBKT5cXG5cXG48IUVMRU1FTlQgcGggKCNQQ0RBVEF8ZXgpKj5cXG48IUFUVExJU1QgcGggbmFtZSBDREFUQSAjUkVRVUlSRUQ+XFxuXFxuPCFFTEVNRU5UIGV4ICgjUENEQVRBKT5cIjtcbiAgdmFyIFhtYiA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBYbWIoKSB7XG4gICAgICB9XG4gICAgICBYbWIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKG1lc3NhZ2VNYXApIHtcbiAgICAgICAgICB2YXIgdmlzaXRvciA9IG5ldyBfVmlzaXRvciQyKCk7XG4gICAgICAgICAgdmFyIHJvb3ROb2RlID0gbmV3IFRhZyhfTUVTU0FHRVNfVEFHKTtcbiAgICAgICAgICBPYmplY3Qua2V5cyhtZXNzYWdlTWFwKS5mb3JFYWNoKGZ1bmN0aW9uIChpZCkge1xuICAgICAgICAgICAgICB2YXIgbWVzc2FnZSA9IG1lc3NhZ2VNYXBbaWRdO1xuICAgICAgICAgICAgICB2YXIgYXR0cnMgPSB7IGlkOiBpZCB9O1xuICAgICAgICAgICAgICBpZiAobWVzc2FnZS5kZXNjcmlwdGlvbikge1xuICAgICAgICAgICAgICAgICAgYXR0cnNbJ2Rlc2MnXSA9IG1lc3NhZ2UuZGVzY3JpcHRpb247XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UubWVhbmluZykge1xuICAgICAgICAgICAgICAgICAgYXR0cnNbJ21lYW5pbmcnXSA9IG1lc3NhZ2UubWVhbmluZztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByb290Tm9kZS5jaGlsZHJlbi5wdXNoKG5ldyBDUigyKSwgbmV3IFRhZyhfTUVTU0FHRV9UQUcsIGF0dHJzLCB2aXNpdG9yLnNlcmlhbGl6ZShtZXNzYWdlLm5vZGVzKSkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJvb3ROb2RlLmNoaWxkcmVuLnB1c2gobmV3IENSKCkpO1xuICAgICAgICAgIHJldHVybiBzZXJpYWxpemUoW1xuICAgICAgICAgICAgICBuZXcgRGVjbGFyYXRpb24oeyB2ZXJzaW9uOiAnMS4wJywgZW5jb2Rpbmc6ICdVVEYtOCcgfSksXG4gICAgICAgICAgICAgIG5ldyBDUigpLFxuICAgICAgICAgICAgICBuZXcgRG9jdHlwZShfTUVTU0FHRVNfVEFHLCBfRE9DVFlQRSksXG4gICAgICAgICAgICAgIG5ldyBDUigpLFxuICAgICAgICAgICAgICByb290Tm9kZSxcbiAgICAgICAgICAgICAgbmV3IENSKCksXG4gICAgICAgICAgXSk7XG4gICAgICB9O1xuICAgICAgWG1iLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKGNvbnRlbnQsIHVybCwgbWVzc2FnZUJ1bmRsZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQnKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gWG1iO1xuICB9KCkpO1xuICB2YXIgX1Zpc2l0b3IkMiA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBfVmlzaXRvcigpIHtcbiAgICAgIH1cbiAgICAgIF9WaXNpdG9yLnByb3RvdHlwZS52aXNpdFRleHQgPSBmdW5jdGlvbiAodGV4dCwgY29udGV4dCkgeyByZXR1cm4gW25ldyBUZXh0JDIodGV4dC52YWx1ZSldOyB9O1xuICAgICAgX1Zpc2l0b3IucHJvdG90eXBlLnZpc2l0Q29udGFpbmVyID0gZnVuY3Rpb24gKGNvbnRhaW5lciwgY29udGV4dCkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgdmFyIG5vZGVzID0gW107XG4gICAgICAgICAgY29udGFpbmVyLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGVzLnB1c2guYXBwbHkobm9kZXMsIG5vZGUudmlzaXQoX3RoaXMpKTsgfSk7XG4gICAgICAgICAgcmV0dXJuIG5vZGVzO1xuICAgICAgfTtcbiAgICAgIF9WaXNpdG9yLnByb3RvdHlwZS52aXNpdEljdSA9IGZ1bmN0aW9uIChpY3UsIGNvbnRleHQpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHZhciBub2RlcyA9IFtuZXcgVGV4dCQyKFwie1wiICsgaWN1LmV4cHJlc3Npb24gKyBcIiwgXCIgKyBpY3UudHlwZSArIFwiLCBcIildO1xuICAgICAgICAgIE9iamVjdC5rZXlzKGljdS5jYXNlcykuZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgICBub2Rlcy5wdXNoLmFwcGx5KG5vZGVzLCBbbmV3IFRleHQkMihjICsgXCIge1wiKV0uY29uY2F0KGljdS5jYXNlc1tjXS52aXNpdChfdGhpcyksIFtuZXcgVGV4dCQyKFwifSBcIildKSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgbm9kZXMucHVzaChuZXcgVGV4dCQyKFwifVwiKSk7XG4gICAgICAgICAgcmV0dXJuIG5vZGVzO1xuICAgICAgfTtcbiAgICAgIF9WaXNpdG9yLnByb3RvdHlwZS52aXNpdFRhZ1BsYWNlaG9sZGVyID0gZnVuY3Rpb24gKHBoLCBjb250ZXh0KSB7XG4gICAgICAgICAgdmFyIHN0YXJ0RXggPSBuZXcgVGFnKF9FWEVNUExFX1RBRywge30sIFtuZXcgVGV4dCQyKFwiPFwiICsgcGgudGFnICsgXCI+XCIpXSk7XG4gICAgICAgICAgdmFyIHN0YXJ0VGFnUGggPSBuZXcgVGFnKF9QTEFDRUhPTERFUl9UQUckMSwgeyBuYW1lOiBwaC5zdGFydE5hbWUgfSwgW3N0YXJ0RXhdKTtcbiAgICAgICAgICBpZiAocGguaXNWb2lkKSB7XG4gICAgICAgICAgICAgIC8vIHZvaWQgdGFncyBoYXZlIG5vIGNoaWxkcmVuIG5vciBjbG9zaW5nIHRhZ3NcbiAgICAgICAgICAgICAgcmV0dXJuIFtzdGFydFRhZ1BoXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGNsb3NlRXggPSBuZXcgVGFnKF9FWEVNUExFX1RBRywge30sIFtuZXcgVGV4dCQyKFwiPC9cIiArIHBoLnRhZyArIFwiPlwiKV0pO1xuICAgICAgICAgIHZhciBjbG9zZVRhZ1BoID0gbmV3IFRhZyhfUExBQ0VIT0xERVJfVEFHJDEsIHsgbmFtZTogcGguY2xvc2VOYW1lIH0sIFtjbG9zZUV4XSk7XG4gICAgICAgICAgcmV0dXJuIFtzdGFydFRhZ1BoXS5jb25jYXQodGhpcy5zZXJpYWxpemUocGguY2hpbGRyZW4pLCBbY2xvc2VUYWdQaF0pO1xuICAgICAgfTtcbiAgICAgIF9WaXNpdG9yLnByb3RvdHlwZS52aXNpdFBsYWNlaG9sZGVyID0gZnVuY3Rpb24gKHBoLCBjb250ZXh0KSB7XG4gICAgICAgICAgcmV0dXJuIFtuZXcgVGFnKF9QTEFDRUhPTERFUl9UQUckMSwgeyBuYW1lOiBwaC5uYW1lIH0pXTtcbiAgICAgIH07XG4gICAgICBfVmlzaXRvci5wcm90b3R5cGUudmlzaXRJY3VQbGFjZWhvbGRlciA9IGZ1bmN0aW9uIChwaCwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiBbbmV3IFRhZyhfUExBQ0VIT0xERVJfVEFHJDEsIHsgbmFtZTogcGgubmFtZSB9KV07XG4gICAgICB9O1xuICAgICAgX1Zpc2l0b3IucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uIChub2Rlcykge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgcmV0dXJuIExpc3RXcmFwcGVyLmZsYXR0ZW4obm9kZXMubWFwKGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBub2RlLnZpc2l0KF90aGlzKTsgfSkpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBfVmlzaXRvcjtcbiAgfSgpKTtcblxuICB2YXIgX1RSQU5TTEFUSU9OU19UQUcgPSAndHJhbnNsYXRpb25idW5kbGUnO1xuICB2YXIgX1RSQU5TTEFUSU9OX1RBRyA9ICd0cmFuc2xhdGlvbic7XG4gIHZhciBfUExBQ0VIT0xERVJfVEFHJDIgPSAncGgnO1xuICB2YXIgWHRiID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIFh0YihfaHRtbFBhcnNlciwgX2ludGVycG9sYXRpb25Db25maWcpIHtcbiAgICAgICAgICB0aGlzLl9odG1sUGFyc2VyID0gX2h0bWxQYXJzZXI7XG4gICAgICAgICAgdGhpcy5faW50ZXJwb2xhdGlvbkNvbmZpZyA9IF9pbnRlcnBvbGF0aW9uQ29uZmlnO1xuICAgICAgfVxuICAgICAgWHRiLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChtZXNzYWdlTWFwKSB7IHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQnKTsgfTtcbiAgICAgIFh0Yi5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uIChjb250ZW50LCB1cmwsIG1lc3NhZ2VCdW5kbGUpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIC8vIFBhcnNlIHRoZSB4dGIgZmlsZSBpbnRvIHhtbCBub2Rlc1xuICAgICAgICAgIHZhciByZXN1bHQgPSBuZXcgWG1sUGFyc2VyKCkucGFyc2UoY29udGVudCwgdXJsKTtcbiAgICAgICAgICBpZiAocmVzdWx0LmVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwieHRiIHBhcnNlIGVycm9yczpcXG5cIiArIHJlc3VsdC5lcnJvcnMuam9pbignXFxuJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBSZXBsYWNlIHRoZSBwbGFjZWhvbGRlcnMsIG1lc3NhZ2VzIGFyZSBub3cgc3RyaW5nXG4gICAgICAgICAgdmFyIF9hID0gbmV3IF9WaXNpdG9yJDMoKS5wYXJzZShyZXN1bHQucm9vdE5vZGVzLCBtZXNzYWdlQnVuZGxlKSwgbWVzc2FnZXMgPSBfYS5tZXNzYWdlcywgZXJyb3JzID0gX2EuZXJyb3JzO1xuICAgICAgICAgIGlmIChlcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInh0YiBwYXJzZSBlcnJvcnM6XFxuXCIgKyBlcnJvcnMuam9pbignXFxuJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBDb252ZXJ0IHRoZSBzdHJpbmcgbWVzc2FnZXMgdG8gaHRtbCBhc3RcbiAgICAgICAgICAvLyBUT0RPKHZpY2IpOiBtYXAgZXJyb3IgbWVzc2FnZSBiYWNrIHRvIHRoZSBvcmlnaW5hbCBtZXNzYWdlIGluIHh0YlxuICAgICAgICAgIHZhciBtZXNzYWdlTWFwID0ge307XG4gICAgICAgICAgdmFyIHBhcnNlRXJyb3JzID0gW107XG4gICAgICAgICAgT2JqZWN0LmtleXMobWVzc2FnZXMpLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgICAgICAgIHZhciByZXMgPSBfdGhpcy5faHRtbFBhcnNlci5wYXJzZShtZXNzYWdlc1tpZF0sIHVybCwgdHJ1ZSwgX3RoaXMuX2ludGVycG9sYXRpb25Db25maWcpO1xuICAgICAgICAgICAgICBwYXJzZUVycm9ycy5wdXNoLmFwcGx5KHBhcnNlRXJyb3JzLCByZXMuZXJyb3JzKTtcbiAgICAgICAgICAgICAgbWVzc2FnZU1hcFtpZF0gPSByZXMucm9vdE5vZGVzO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmIChwYXJzZUVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwieHRiIHBhcnNlIGVycm9yczpcXG5cIiArIHBhcnNlRXJyb3JzLmpvaW4oJ1xcbicpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG1lc3NhZ2VNYXA7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIFh0YjtcbiAgfSgpKTtcbiAgdmFyIF9WaXNpdG9yJDMgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gX1Zpc2l0b3IoKSB7XG4gICAgICB9XG4gICAgICBfVmlzaXRvci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAobm9kZXMsIG1lc3NhZ2VCdW5kbGUpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHRoaXMuX21lc3NhZ2VOb2RlcyA9IFtdO1xuICAgICAgICAgIHRoaXMuX3RyYW5zbGF0ZWRNZXNzYWdlcyA9IHt9O1xuICAgICAgICAgIHRoaXMuX2J1bmRsZURlcHRoID0gMDtcbiAgICAgICAgICB0aGlzLl90cmFuc2xhdGlvbkRlcHRoID0gMDtcbiAgICAgICAgICB0aGlzLl9lcnJvcnMgPSBbXTtcbiAgICAgICAgICAvLyBGaW5kIGFsbCBtZXNzYWdlc1xuICAgICAgICAgIHZpc2l0QWxsKHRoaXMsIG5vZGVzLCBudWxsKTtcbiAgICAgICAgICB2YXIgbWVzc2FnZU1hcCA9IG1lc3NhZ2VCdW5kbGUuZ2V0TWVzc2FnZU1hcCgpO1xuICAgICAgICAgIHZhciBwbGFjZWhvbGRlcnMgPSBleHRyYWN0UGxhY2Vob2xkZXJzKG1lc3NhZ2VCdW5kbGUpO1xuICAgICAgICAgIHZhciBwbGFjZWhvbGRlclRvSWRzID0gZXh0cmFjdFBsYWNlaG9sZGVyVG9JZHMobWVzc2FnZUJ1bmRsZSk7XG4gICAgICAgICAgdGhpcy5fbWVzc2FnZU5vZGVzXG4gICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgLy8gUmVtb3ZlIGFueSBtZXNzYWdlcyB0aGF0IGlzIG5vdCBwcmVzZW50IGluIHRoZSBzb3VyY2UgbWVzc2FnZSBidW5kbGUuXG4gICAgICAgICAgICAgIHJldHVybiBtZXNzYWdlTWFwLmhhc093blByb3BlcnR5KG1lc3NhZ2VbMF0pO1xuICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICAgIC8vIEJlY2F1c2UgdGhlcmUgY291bGQgYmUgbm8gSUNVIHBsYWNlaG9sZGVycyBpbnNpZGUgYW4gSUNVIG1lc3NhZ2UsXG4gICAgICAgICAgICAgIC8vIHdlIGRvIG5vdCBuZWVkIHRvIHRha2UgaW50byBhY2NvdW50IHRoZSBgcGxhY2Vob2xkZXJUb01zZ0lkc2Agb2YgdGhlIHJlZmVyZW5jZWRcbiAgICAgICAgICAgICAgLy8gbWVzc2FnZXMsIHRob3NlIHdvdWxkIGFsd2F5cyBiZSBlbXB0eVxuICAgICAgICAgICAgICAvLyBUT0RPKHZpY2IpOiBvdmVya2lsbCAtIGNyZWF0ZSAyIGJ1Y2tldHMgYW5kIFsuLi53b0RlcHMsIC4uLndEZXBzXS5wcm9jZXNzKClcbiAgICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKG1lc3NhZ2VNYXBbYVswXV0ucGxhY2Vob2xkZXJUb01zZ0lkcykubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMobWVzc2FnZU1hcFtiWzBdXS5wbGFjZWhvbGRlclRvTXNnSWRzKS5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgfSlcbiAgICAgICAgICAgICAgLmZvckVhY2goZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgdmFyIGlkID0gbWVzc2FnZVswXTtcbiAgICAgICAgICAgICAgX3RoaXMuX3BsYWNlaG9sZGVycyA9IHBsYWNlaG9sZGVyc1tpZF0gfHwge307XG4gICAgICAgICAgICAgIF90aGlzLl9wbGFjZWhvbGRlclRvSWRzID0gcGxhY2Vob2xkZXJUb0lkc1tpZF0gfHwge307XG4gICAgICAgICAgICAgIC8vIFRPRE8odmljYik6IG1ha2Ugc3VyZSB0aGVyZSBpcyBubyBgX1RSQU5TTEFUSU9OU19UQUdgIG5vciBgX1RSQU5TTEFUSU9OX1RBR2BcbiAgICAgICAgICAgICAgX3RoaXMuX3RyYW5zbGF0ZWRNZXNzYWdlc1tpZF0gPSB2aXNpdEFsbChfdGhpcywgbWVzc2FnZVsxXSkuam9pbignJyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIHsgbWVzc2FnZXM6IHRoaXMuX3RyYW5zbGF0ZWRNZXNzYWdlcywgZXJyb3JzOiB0aGlzLl9lcnJvcnMgfTtcbiAgICAgIH07XG4gICAgICBfVmlzaXRvci5wcm90b3R5cGUudmlzaXRFbGVtZW50ID0gZnVuY3Rpb24gKGVsZW1lbnQsIGNvbnRleHQpIHtcbiAgICAgICAgICBzd2l0Y2ggKGVsZW1lbnQubmFtZSkge1xuICAgICAgICAgICAgICBjYXNlIF9UUkFOU0xBVElPTlNfVEFHOlxuICAgICAgICAgICAgICAgICAgdGhpcy5fYnVuZGxlRGVwdGgrKztcbiAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9idW5kbGVEZXB0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRFcnJvcihlbGVtZW50LCBcIjxcIiArIF9UUkFOU0xBVElPTlNfVEFHICsgXCI+IGVsZW1lbnRzIGNhbiBub3QgYmUgbmVzdGVkXCIpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgdmlzaXRBbGwodGhpcywgZWxlbWVudC5jaGlsZHJlbiwgbnVsbCk7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9idW5kbGVEZXB0aC0tO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgX1RSQU5TTEFUSU9OX1RBRzpcbiAgICAgICAgICAgICAgICAgIHRoaXMuX3RyYW5zbGF0aW9uRGVwdGgrKztcbiAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl90cmFuc2xhdGlvbkRlcHRoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZEVycm9yKGVsZW1lbnQsIFwiPFwiICsgX1RSQU5TTEFUSU9OX1RBRyArIFwiPiBlbGVtZW50cyBjYW4gbm90IGJlIG5lc3RlZFwiKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHZhciBpZEF0dHIgPSBlbGVtZW50LmF0dHJzLmZpbmQoZnVuY3Rpb24gKGF0dHIpIHsgcmV0dXJuIGF0dHIubmFtZSA9PT0gJ2lkJzsgfSk7XG4gICAgICAgICAgICAgICAgICBpZiAoIWlkQXR0cikge1xuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZEVycm9yKGVsZW1lbnQsIFwiPFwiICsgX1RSQU5TTEFUSU9OX1RBRyArIFwiPiBtaXNzZXMgdGhlIFxcXCJpZFxcXCIgYXR0cmlidXRlXCIpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gSUNVIHBsYWNlaG9sZGVycyBhcmUgcmVmZXJlbmNlIHRvIG90aGVyIG1lc3NhZ2VzLlxuICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSByZWZlcmVuY2VkIG1lc3NhZ2UgbWlnaHQgbm90IGhhdmUgYmVlbiBkZWNvZGVkIHlldC5cbiAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBuZWVkIHRvIGhhdmUgYWxsIG1lc3NhZ2VzIGF2YWlsYWJsZSB0byBtYWtlIHN1cmUgZGVwcyBhcmUgZGVjb2RlZCBmaXJzdC5cbiAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPKHZpY2IpOiByZXBvcnQgYW4gZXJyb3Igb24gZHVwbGljYXRlIGlkXG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWVzc2FnZU5vZGVzLnB1c2goW2lkQXR0ci52YWx1ZSwgZWxlbWVudC5jaGlsZHJlbl0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgdGhpcy5fdHJhbnNsYXRpb25EZXB0aC0tO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgX1BMQUNFSE9MREVSX1RBRyQyOlxuICAgICAgICAgICAgICAgICAgdmFyIG5hbWVBdHRyID0gZWxlbWVudC5hdHRycy5maW5kKGZ1bmN0aW9uIChhdHRyKSB7IHJldHVybiBhdHRyLm5hbWUgPT09ICduYW1lJzsgfSk7XG4gICAgICAgICAgICAgICAgICBpZiAoIW5hbWVBdHRyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkRXJyb3IoZWxlbWVudCwgXCI8XCIgKyBfUExBQ0VIT0xERVJfVEFHJDIgKyBcIj4gbWlzc2VzIHRoZSBcXFwibmFtZVxcXCIgYXR0cmlidXRlXCIpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWVfMSA9IG5hbWVBdHRyLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9wbGFjZWhvbGRlcnMuaGFzT3duUHJvcGVydHkobmFtZV8xKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcGxhY2Vob2xkZXJzW25hbWVfMV07XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9wbGFjZWhvbGRlclRvSWRzLmhhc093blByb3BlcnR5KG5hbWVfMSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdHJhbnNsYXRlZE1lc3NhZ2VzLmhhc093blByb3BlcnR5KHRoaXMuX3BsYWNlaG9sZGVyVG9JZHNbbmFtZV8xXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zbGF0ZWRNZXNzYWdlc1t0aGlzLl9wbGFjZWhvbGRlclRvSWRzW25hbWVfMV1dO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPKHZpY2IpOiBiZXR0ZXIgZXJyb3IgbWVzc2FnZSBmb3Igd2hlblxuICAgICAgICAgICAgICAgICAgICAgIC8vICF0aGlzLl90cmFuc2xhdGVkTWVzc2FnZXMuaGFzT3duUHJvcGVydHkodGhpcy5fcGxhY2Vob2xkZXJUb0lkc1tuYW1lXSlcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRFcnJvcihlbGVtZW50LCBcIlRoZSBwbGFjZWhvbGRlciBcXFwiXCIgKyBuYW1lXzEgKyBcIlxcXCIgZG9lcyBub3QgZXhpc3RzIGluIHRoZSBzb3VyY2UgbWVzc2FnZVwiKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkRXJyb3IoZWxlbWVudCwgJ1VuZXhwZWN0ZWQgdGFnJyk7XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIF9WaXNpdG9yLnByb3RvdHlwZS52aXNpdEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChhdHRyaWJ1dGUsIGNvbnRleHQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VucmVhY2hhYmxlIGNvZGUnKTtcbiAgICAgIH07XG4gICAgICBfVmlzaXRvci5wcm90b3R5cGUudmlzaXRUZXh0ID0gZnVuY3Rpb24gKHRleHQsIGNvbnRleHQpIHsgcmV0dXJuIHRleHQudmFsdWU7IH07XG4gICAgICBfVmlzaXRvci5wcm90b3R5cGUudmlzaXRDb21tZW50ID0gZnVuY3Rpb24gKGNvbW1lbnQsIGNvbnRleHQpIHsgcmV0dXJuICcnOyB9O1xuICAgICAgX1Zpc2l0b3IucHJvdG90eXBlLnZpc2l0RXhwYW5zaW9uID0gZnVuY3Rpb24gKGV4cGFuc2lvbiwgY29udGV4dCkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgdmFyIHN0ckNhc2VzID0gZXhwYW5zaW9uLmNhc2VzLm1hcChmdW5jdGlvbiAoYykgeyByZXR1cm4gYy52aXNpdChfdGhpcywgbnVsbCk7IH0pO1xuICAgICAgICAgIHJldHVybiBcIntcIiArIGV4cGFuc2lvbi5zd2l0Y2hWYWx1ZSArIFwiLCBcIiArIGV4cGFuc2lvbi50eXBlICsgXCIsIHN0ckNhc2VzLmpvaW4oJyAnKX1cIjtcbiAgICAgIH07XG4gICAgICBfVmlzaXRvci5wcm90b3R5cGUudmlzaXRFeHBhbnNpb25DYXNlID0gZnVuY3Rpb24gKGV4cGFuc2lvbkNhc2UsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gZXhwYW5zaW9uQ2FzZS52YWx1ZSArIFwiIHtcIiArIHZpc2l0QWxsKHRoaXMsIGV4cGFuc2lvbkNhc2UuZXhwcmVzc2lvbiwgbnVsbCkgKyBcIn1cIjtcbiAgICAgIH07XG4gICAgICBfVmlzaXRvci5wcm90b3R5cGUuX2FkZEVycm9yID0gZnVuY3Rpb24gKG5vZGUsIG1lc3NhZ2UpIHtcbiAgICAgICAgICB0aGlzLl9lcnJvcnMucHVzaChuZXcgSTE4bkVycm9yKG5vZGUuc291cmNlU3BhbiwgbWVzc2FnZSkpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBfVmlzaXRvcjtcbiAgfSgpKTtcblxuICAvKipcbiAgICogQGxpY2Vuc2VcbiAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAqXG4gICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICovXG4gIC8qKlxuICAgKiBBIGNvbnRhaW5lciBmb3IgdHJhbnNsYXRlZCBtZXNzYWdlc1xuICAgKi9cbiAgdmFyIFRyYW5zbGF0aW9uQnVuZGxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIFRyYW5zbGF0aW9uQnVuZGxlKF9tZXNzYWdlTWFwKSB7XG4gICAgICAgICAgaWYgKF9tZXNzYWdlTWFwID09PSB2b2lkIDApIHsgX21lc3NhZ2VNYXAgPSB7fTsgfVxuICAgICAgICAgIHRoaXMuX21lc3NhZ2VNYXAgPSBfbWVzc2FnZU1hcDtcbiAgICAgIH1cbiAgICAgIFRyYW5zbGF0aW9uQnVuZGxlLmxvYWQgPSBmdW5jdGlvbiAoY29udGVudCwgdXJsLCBtZXNzYWdlQnVuZGxlLCBzZXJpYWxpemVyKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBUcmFuc2xhdGlvbkJ1bmRsZShzZXJpYWxpemVyLmxvYWQoY29udGVudCwgdXJsLCBtZXNzYWdlQnVuZGxlKSk7XG4gICAgICB9O1xuICAgICAgVHJhbnNsYXRpb25CdW5kbGUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChpZCkgeyByZXR1cm4gdGhpcy5fbWVzc2FnZU1hcFtpZF07IH07XG4gICAgICBUcmFuc2xhdGlvbkJ1bmRsZS5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gKGlkKSB7IHJldHVybiBpZCBpbiB0aGlzLl9tZXNzYWdlTWFwOyB9O1xuICAgICAgcmV0dXJuIFRyYW5zbGF0aW9uQnVuZGxlO1xuICB9KCkpO1xuXG4gIHZhciBJMThOSHRtbFBhcnNlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBUT0RPKHZpY2IpOiB0cmFuc0IubG9hZCgpIHNob3VsZCBub3QgbmVlZCBhIG1zZ0IgJiBhZGQgdHJhbnNCLnJlc29sdmUobXNnQixcbiAgICAgIC8vIGludGVycG9sYXRpb25Db25maWcpXG4gICAgICAvLyBUT0RPKHZpY2IpOiByZW1vdmUgdGhlIGludGVycG9sYXRpb25Db25maWcgZnJvbSB0aGUgWHRiIHNlcmlhbGl6ZXJcbiAgICAgIGZ1bmN0aW9uIEkxOE5IdG1sUGFyc2VyKF9odG1sUGFyc2VyLCBfdHJhbnNsYXRpb25zLCBfdHJhbnNsYXRpb25zRm9ybWF0KSB7XG4gICAgICAgICAgdGhpcy5faHRtbFBhcnNlciA9IF9odG1sUGFyc2VyO1xuICAgICAgICAgIHRoaXMuX3RyYW5zbGF0aW9ucyA9IF90cmFuc2xhdGlvbnM7XG4gICAgICAgICAgdGhpcy5fdHJhbnNsYXRpb25zRm9ybWF0ID0gX3RyYW5zbGF0aW9uc0Zvcm1hdDtcbiAgICAgIH1cbiAgICAgIEkxOE5IdG1sUGFyc2VyLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIChzb3VyY2UsIHVybCwgcGFyc2VFeHBhbnNpb25Gb3JtcywgaW50ZXJwb2xhdGlvbkNvbmZpZykge1xuICAgICAgICAgIGlmIChwYXJzZUV4cGFuc2lvbkZvcm1zID09PSB2b2lkIDApIHsgcGFyc2VFeHBhbnNpb25Gb3JtcyA9IGZhbHNlOyB9XG4gICAgICAgICAgaWYgKGludGVycG9sYXRpb25Db25maWcgPT09IHZvaWQgMCkgeyBpbnRlcnBvbGF0aW9uQ29uZmlnID0gREVGQVVMVF9JTlRFUlBPTEFUSU9OX0NPTkZJRzsgfVxuICAgICAgICAgIHZhciBwYXJzZVJlc3VsdCA9IHRoaXMuX2h0bWxQYXJzZXIucGFyc2Uoc291cmNlLCB1cmwsIHBhcnNlRXhwYW5zaW9uRm9ybXMsIGludGVycG9sYXRpb25Db25maWcpO1xuICAgICAgICAgIGlmICghdGhpcy5fdHJhbnNsYXRpb25zIHx8IHRoaXMuX3RyYW5zbGF0aW9ucyA9PT0gJycpIHtcbiAgICAgICAgICAgICAgLy8gRG8gbm90IGVuYWJsZSBpMThuIHdoZW4gbm8gdHJhbnNsYXRpb24gYnVuZGxlIGlzIHByb3ZpZGVkXG4gICAgICAgICAgICAgIHJldHVybiBwYXJzZVJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gVE9ETyh2aWNiKTogYWRkIHN1cHBvcnQgZm9yIGltcGxpY2l0IHRhZ3MgLyBhdHRyaWJ1dGVzXG4gICAgICAgICAgdmFyIG1lc3NhZ2VCdW5kbGUgPSBuZXcgTWVzc2FnZUJ1bmRsZSh0aGlzLl9odG1sUGFyc2VyLCBbXSwge30pO1xuICAgICAgICAgIHZhciBlcnJvcnMgPSBtZXNzYWdlQnVuZGxlLnVwZGF0ZUZyb21UZW1wbGF0ZShzb3VyY2UsIHVybCwgaW50ZXJwb2xhdGlvbkNvbmZpZyk7XG4gICAgICAgICAgaWYgKGVycm9ycyAmJiBlcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgUGFyc2VUcmVlUmVzdWx0KHBhcnNlUmVzdWx0LnJvb3ROb2RlcywgcGFyc2VSZXN1bHQuZXJyb3JzLmNvbmNhdChlcnJvcnMpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHNlcmlhbGl6ZXIgPSB0aGlzLl9jcmVhdGVTZXJpYWxpemVyKGludGVycG9sYXRpb25Db25maWcpO1xuICAgICAgICAgIHZhciB0cmFuc2xhdGlvbkJ1bmRsZSA9IFRyYW5zbGF0aW9uQnVuZGxlLmxvYWQodGhpcy5fdHJhbnNsYXRpb25zLCB1cmwsIG1lc3NhZ2VCdW5kbGUsIHNlcmlhbGl6ZXIpO1xuICAgICAgICAgIHJldHVybiBtZXJnZVRyYW5zbGF0aW9ucyhwYXJzZVJlc3VsdC5yb290Tm9kZXMsIHRyYW5zbGF0aW9uQnVuZGxlLCBpbnRlcnBvbGF0aW9uQ29uZmlnLCBbXSwge30pO1xuICAgICAgfTtcbiAgICAgIEkxOE5IdG1sUGFyc2VyLnByb3RvdHlwZS5fY3JlYXRlU2VyaWFsaXplciA9IGZ1bmN0aW9uIChpbnRlcnBvbGF0aW9uQ29uZmlnKSB7XG4gICAgICAgICAgdmFyIGZvcm1hdCA9ICh0aGlzLl90cmFuc2xhdGlvbnNGb3JtYXQgfHwgJ3hsZicpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgc3dpdGNoIChmb3JtYXQpIHtcbiAgICAgICAgICAgICAgY2FzZSAneG1iJzpcbiAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgWG1iKCk7XG4gICAgICAgICAgICAgIGNhc2UgJ3h0Yic6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFh0Yih0aGlzLl9odG1sUGFyc2VyLCBpbnRlcnBvbGF0aW9uQ29uZmlnKTtcbiAgICAgICAgICAgICAgY2FzZSAneGxpZmYnOlxuICAgICAgICAgICAgICBjYXNlICd4bGYnOlxuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBYbGlmZih0aGlzLl9odG1sUGFyc2VyLCBpbnRlcnBvbGF0aW9uQ29uZmlnKTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgcmV0dXJuIEkxOE5IdG1sUGFyc2VyO1xuICB9KCkpO1xuXG4gIHZhciBpc0RlZmF1bHRDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSA9IF9hbmd1bGFyX2NvcmUuX19jb3JlX3ByaXZhdGVfXy5pc0RlZmF1bHRDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneTtcbiAgdmFyIENoYW5nZURldGVjdG9yU3RhdHVzID0gX2FuZ3VsYXJfY29yZS5fX2NvcmVfcHJpdmF0ZV9fLkNoYW5nZURldGVjdG9yU3RhdHVzO1xuICB2YXIgTGlmZWN5Y2xlSG9va3MgPSBfYW5ndWxhcl9jb3JlLl9fY29yZV9wcml2YXRlX18uTGlmZWN5Y2xlSG9va3M7XG4gIHZhciBMSUZFQ1lDTEVfSE9PS1NfVkFMVUVTID0gX2FuZ3VsYXJfY29yZS5fX2NvcmVfcHJpdmF0ZV9fLkxJRkVDWUNMRV9IT09LU19WQUxVRVM7XG4gIHZhciBSZWZsZWN0b3JSZWFkZXIgPSBfYW5ndWxhcl9jb3JlLl9fY29yZV9wcml2YXRlX18uUmVmbGVjdG9yUmVhZGVyO1xuICB2YXIgQXBwRWxlbWVudCA9IF9hbmd1bGFyX2NvcmUuX19jb3JlX3ByaXZhdGVfXy5BcHBFbGVtZW50O1xuICB2YXIgQ29kZWdlbkNvbXBvbmVudEZhY3RvcnlSZXNvbHZlciA9IF9hbmd1bGFyX2NvcmUuX19jb3JlX3ByaXZhdGVfXy5Db2RlZ2VuQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyO1xuICB2YXIgQXBwVmlldyA9IF9hbmd1bGFyX2NvcmUuX19jb3JlX3ByaXZhdGVfXy5BcHBWaWV3O1xuICB2YXIgRGVidWdBcHBWaWV3ID0gX2FuZ3VsYXJfY29yZS5fX2NvcmVfcHJpdmF0ZV9fLkRlYnVnQXBwVmlldztcbiAgdmFyIE5nTW9kdWxlSW5qZWN0b3IgPSBfYW5ndWxhcl9jb3JlLl9fY29yZV9wcml2YXRlX18uTmdNb2R1bGVJbmplY3RvcjtcbiAgdmFyIHJlZ2lzdGVyTW9kdWxlRmFjdG9yeSA9IF9hbmd1bGFyX2NvcmUuX19jb3JlX3ByaXZhdGVfXy5yZWdpc3Rlck1vZHVsZUZhY3Rvcnk7XG4gIHZhciBWaWV3VHlwZSA9IF9hbmd1bGFyX2NvcmUuX19jb3JlX3ByaXZhdGVfXy5WaWV3VHlwZTtcbiAgdmFyIHZpZXdfdXRpbHMgPSBfYW5ndWxhcl9jb3JlLl9fY29yZV9wcml2YXRlX18udmlld191dGlscztcbiAgdmFyIERlYnVnQ29udGV4dCA9IF9hbmd1bGFyX2NvcmUuX19jb3JlX3ByaXZhdGVfXy5EZWJ1Z0NvbnRleHQ7XG4gIHZhciBTdGF0aWNOb2RlRGVidWdJbmZvID0gX2FuZ3VsYXJfY29yZS5fX2NvcmVfcHJpdmF0ZV9fLlN0YXRpY05vZGVEZWJ1Z0luZm87XG4gIHZhciBkZXZNb2RlRXF1YWwgPSBfYW5ndWxhcl9jb3JlLl9fY29yZV9wcml2YXRlX18uZGV2TW9kZUVxdWFsO1xuICB2YXIgVU5JTklUSUFMSVpFRCA9IF9hbmd1bGFyX2NvcmUuX19jb3JlX3ByaXZhdGVfXy5VTklOSVRJQUxJWkVEO1xuICB2YXIgVmFsdWVVbndyYXBwZXIgPSBfYW5ndWxhcl9jb3JlLl9fY29yZV9wcml2YXRlX18uVmFsdWVVbndyYXBwZXI7XG4gIHZhciBUZW1wbGF0ZVJlZl8gPSBfYW5ndWxhcl9jb3JlLl9fY29yZV9wcml2YXRlX18uVGVtcGxhdGVSZWZfO1xuICB2YXIgQ29uc29sZSA9IF9hbmd1bGFyX2NvcmUuX19jb3JlX3ByaXZhdGVfXy5Db25zb2xlO1xuICB2YXIgcmVmbGVjdG9yID0gX2FuZ3VsYXJfY29yZS5fX2NvcmVfcHJpdmF0ZV9fLnJlZmxlY3RvcjtcbiAgdmFyIFJlZmxlY3RvciA9IF9hbmd1bGFyX2NvcmUuX19jb3JlX3ByaXZhdGVfXy5SZWZsZWN0b3I7XG4gIHZhciBSZWZsZWN0aW9uQ2FwYWJpbGl0aWVzID0gX2FuZ3VsYXJfY29yZS5fX2NvcmVfcHJpdmF0ZV9fLlJlZmxlY3Rpb25DYXBhYmlsaXRpZXM7XG4gIHZhciBOb09wQW5pbWF0aW9uUGxheWVyID0gX2FuZ3VsYXJfY29yZS5fX2NvcmVfcHJpdmF0ZV9fLk5vT3BBbmltYXRpb25QbGF5ZXI7XG4gIHZhciBBbmltYXRpb25TZXF1ZW5jZVBsYXllciA9IF9hbmd1bGFyX2NvcmUuX19jb3JlX3ByaXZhdGVfXy5BbmltYXRpb25TZXF1ZW5jZVBsYXllcjtcbiAgdmFyIEFuaW1hdGlvbkdyb3VwUGxheWVyID0gX2FuZ3VsYXJfY29yZS5fX2NvcmVfcHJpdmF0ZV9fLkFuaW1hdGlvbkdyb3VwUGxheWVyO1xuICB2YXIgQW5pbWF0aW9uS2V5ZnJhbWUgPSBfYW5ndWxhcl9jb3JlLl9fY29yZV9wcml2YXRlX18uQW5pbWF0aW9uS2V5ZnJhbWU7XG4gIHZhciBBbmltYXRpb25TdHlsZXMgPSBfYW5ndWxhcl9jb3JlLl9fY29yZV9wcml2YXRlX18uQW5pbWF0aW9uU3R5bGVzO1xuICB2YXIgQU5ZX1NUQVRFID0gX2FuZ3VsYXJfY29yZS5fX2NvcmVfcHJpdmF0ZV9fLkFOWV9TVEFURTtcbiAgdmFyIERFRkFVTFRfU1RBVEUgPSBfYW5ndWxhcl9jb3JlLl9fY29yZV9wcml2YXRlX18uREVGQVVMVF9TVEFURTtcbiAgdmFyIEVNUFRZX0FOSU1BVElPTl9TVEFURSA9IF9hbmd1bGFyX2NvcmUuX19jb3JlX3ByaXZhdGVfXy5FTVBUWV9TVEFURTtcbiAgdmFyIEZJTExfU1RZTEVfRkxBRyA9IF9hbmd1bGFyX2NvcmUuX19jb3JlX3ByaXZhdGVfXy5GSUxMX1NUWUxFX0ZMQUc7XG4gIHZhciBwcmVwYXJlRmluYWxBbmltYXRpb25TdHlsZXMgPSBfYW5ndWxhcl9jb3JlLl9fY29yZV9wcml2YXRlX18ucHJlcGFyZUZpbmFsQW5pbWF0aW9uU3R5bGVzO1xuICB2YXIgYmFsYW5jZUFuaW1hdGlvbktleWZyYW1lcyA9IF9hbmd1bGFyX2NvcmUuX19jb3JlX3ByaXZhdGVfXy5iYWxhbmNlQW5pbWF0aW9uS2V5ZnJhbWVzO1xuICB2YXIgY2xlYXJTdHlsZXMgPSBfYW5ndWxhcl9jb3JlLl9fY29yZV9wcml2YXRlX18uY2xlYXJTdHlsZXM7XG4gIHZhciBjb2xsZWN0QW5kUmVzb2x2ZVN0eWxlcyA9IF9hbmd1bGFyX2NvcmUuX19jb3JlX3ByaXZhdGVfXy5jb2xsZWN0QW5kUmVzb2x2ZVN0eWxlcztcbiAgdmFyIHJlbmRlclN0eWxlcyA9IF9hbmd1bGFyX2NvcmUuX19jb3JlX3ByaXZhdGVfXy5yZW5kZXJTdHlsZXM7XG4gIHZhciBDb21wb25lbnRTdGlsbExvYWRpbmdFcnJvciA9IF9hbmd1bGFyX2NvcmUuX19jb3JlX3ByaXZhdGVfXy5Db21wb25lbnRTdGlsbExvYWRpbmdFcnJvcjtcbiAgdmFyIEFuaW1hdGlvblRyYW5zaXRpb24gPSBfYW5ndWxhcl9jb3JlLl9fY29yZV9wcml2YXRlX18uQW5pbWF0aW9uVHJhbnNpdGlvbjtcblxuICB2YXIgQVBQX1ZJRVdfTU9EVUxFX1VSTCA9IGFzc2V0VXJsKCdjb3JlJywgJ2xpbmtlci92aWV3Jyk7XG4gIHZhciBWSUVXX1VUSUxTX01PRFVMRV9VUkwgPSBhc3NldFVybCgnY29yZScsICdsaW5rZXIvdmlld191dGlscycpO1xuICB2YXIgQ0RfTU9EVUxFX1VSTCA9IGFzc2V0VXJsKCdjb3JlJywgJ2NoYW5nZV9kZXRlY3Rpb24vY2hhbmdlX2RldGVjdGlvbicpO1xuICB2YXIgQU5JTUFUSU9OX1NUWUxFX1VUSUxfQVNTRVRfVVJMID0gYXNzZXRVcmwoJ2NvcmUnLCAnYW5pbWF0aW9uL2FuaW1hdGlvbl9zdHlsZV91dGlsJyk7XG4gIHZhciBJZGVudGlmaWVycyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBJZGVudGlmaWVycygpIHtcbiAgICAgIH1cbiAgICAgIElkZW50aWZpZXJzLkFOQUxZWkVfRk9SX0VOVFJZX0NPTVBPTkVOVFMgPSB7XG4gICAgICAgICAgbmFtZTogJ0FOQUxZWkVfRk9SX0VOVFJZX0NPTVBPTkVOVFMnLFxuICAgICAgICAgIG1vZHVsZVVybDogYXNzZXRVcmwoJ2NvcmUnLCAnbWV0YWRhdGEvZGknKSxcbiAgICAgICAgICBydW50aW1lOiBfYW5ndWxhcl9jb3JlLkFOQUxZWkVfRk9SX0VOVFJZX0NPTVBPTkVOVFNcbiAgICAgIH07XG4gICAgICBJZGVudGlmaWVycy5WaWV3VXRpbHMgPSB7XG4gICAgICAgICAgbmFtZTogJ1ZpZXdVdGlscycsXG4gICAgICAgICAgbW9kdWxlVXJsOiBhc3NldFVybCgnY29yZScsICdsaW5rZXIvdmlld191dGlscycpLFxuICAgICAgICAgIHJ1bnRpbWU6IHZpZXdfdXRpbHMuVmlld1V0aWxzXG4gICAgICB9O1xuICAgICAgSWRlbnRpZmllcnMuQXBwVmlldyA9IHsgbmFtZTogJ0FwcFZpZXcnLCBtb2R1bGVVcmw6IEFQUF9WSUVXX01PRFVMRV9VUkwsIHJ1bnRpbWU6IEFwcFZpZXcgfTtcbiAgICAgIElkZW50aWZpZXJzLkRlYnVnQXBwVmlldyA9IHtcbiAgICAgICAgICBuYW1lOiAnRGVidWdBcHBWaWV3JyxcbiAgICAgICAgICBtb2R1bGVVcmw6IEFQUF9WSUVXX01PRFVMRV9VUkwsXG4gICAgICAgICAgcnVudGltZTogRGVidWdBcHBWaWV3XG4gICAgICB9O1xuICAgICAgSWRlbnRpZmllcnMuQXBwRWxlbWVudCA9IHtcbiAgICAgICAgICBuYW1lOiAnQXBwRWxlbWVudCcsXG4gICAgICAgICAgbW9kdWxlVXJsOiBhc3NldFVybCgnY29yZScsICdsaW5rZXIvZWxlbWVudCcpLFxuICAgICAgICAgIHJ1bnRpbWU6IEFwcEVsZW1lbnRcbiAgICAgIH07XG4gICAgICBJZGVudGlmaWVycy5FbGVtZW50UmVmID0ge1xuICAgICAgICAgIG5hbWU6ICdFbGVtZW50UmVmJyxcbiAgICAgICAgICBtb2R1bGVVcmw6IGFzc2V0VXJsKCdjb3JlJywgJ2xpbmtlci9lbGVtZW50X3JlZicpLFxuICAgICAgICAgIHJ1bnRpbWU6IF9hbmd1bGFyX2NvcmUuRWxlbWVudFJlZlxuICAgICAgfTtcbiAgICAgIElkZW50aWZpZXJzLlZpZXdDb250YWluZXJSZWYgPSB7XG4gICAgICAgICAgbmFtZTogJ1ZpZXdDb250YWluZXJSZWYnLFxuICAgICAgICAgIG1vZHVsZVVybDogYXNzZXRVcmwoJ2NvcmUnLCAnbGlua2VyL3ZpZXdfY29udGFpbmVyX3JlZicpLFxuICAgICAgICAgIHJ1bnRpbWU6IF9hbmd1bGFyX2NvcmUuVmlld0NvbnRhaW5lclJlZlxuICAgICAgfTtcbiAgICAgIElkZW50aWZpZXJzLkNoYW5nZURldGVjdG9yUmVmID0ge1xuICAgICAgICAgIG5hbWU6ICdDaGFuZ2VEZXRlY3RvclJlZicsXG4gICAgICAgICAgbW9kdWxlVXJsOiBhc3NldFVybCgnY29yZScsICdjaGFuZ2VfZGV0ZWN0aW9uL2NoYW5nZV9kZXRlY3Rvcl9yZWYnKSxcbiAgICAgICAgICBydW50aW1lOiBfYW5ndWxhcl9jb3JlLkNoYW5nZURldGVjdG9yUmVmXG4gICAgICB9O1xuICAgICAgSWRlbnRpZmllcnMuUmVuZGVyQ29tcG9uZW50VHlwZSA9IHtcbiAgICAgICAgICBuYW1lOiAnUmVuZGVyQ29tcG9uZW50VHlwZScsXG4gICAgICAgICAgbW9kdWxlVXJsOiBhc3NldFVybCgnY29yZScsICdyZW5kZXIvYXBpJyksXG4gICAgICAgICAgcnVudGltZTogX2FuZ3VsYXJfY29yZS5SZW5kZXJDb21wb25lbnRUeXBlXG4gICAgICB9O1xuICAgICAgSWRlbnRpZmllcnMuUXVlcnlMaXN0ID0ge1xuICAgICAgICAgIG5hbWU6ICdRdWVyeUxpc3QnLFxuICAgICAgICAgIG1vZHVsZVVybDogYXNzZXRVcmwoJ2NvcmUnLCAnbGlua2VyL3F1ZXJ5X2xpc3QnKSxcbiAgICAgICAgICBydW50aW1lOiBfYW5ndWxhcl9jb3JlLlF1ZXJ5TGlzdFxuICAgICAgfTtcbiAgICAgIElkZW50aWZpZXJzLlRlbXBsYXRlUmVmID0ge1xuICAgICAgICAgIG5hbWU6ICdUZW1wbGF0ZVJlZicsXG4gICAgICAgICAgbW9kdWxlVXJsOiBhc3NldFVybCgnY29yZScsICdsaW5rZXIvdGVtcGxhdGVfcmVmJyksXG4gICAgICAgICAgcnVudGltZTogX2FuZ3VsYXJfY29yZS5UZW1wbGF0ZVJlZlxuICAgICAgfTtcbiAgICAgIElkZW50aWZpZXJzLlRlbXBsYXRlUmVmXyA9IHtcbiAgICAgICAgICBuYW1lOiAnVGVtcGxhdGVSZWZfJyxcbiAgICAgICAgICBtb2R1bGVVcmw6IGFzc2V0VXJsKCdjb3JlJywgJ2xpbmtlci90ZW1wbGF0ZV9yZWYnKSxcbiAgICAgICAgICBydW50aW1lOiBUZW1wbGF0ZVJlZl9cbiAgICAgIH07XG4gICAgICBJZGVudGlmaWVycy5Db2RlZ2VuQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyID0ge1xuICAgICAgICAgIG5hbWU6ICdDb2RlZ2VuQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyJyxcbiAgICAgICAgICBtb2R1bGVVcmw6IGFzc2V0VXJsKCdjb3JlJywgJ2xpbmtlci9jb21wb25lbnRfZmFjdG9yeV9yZXNvbHZlcicpLFxuICAgICAgICAgIHJ1bnRpbWU6IENvZGVnZW5Db21wb25lbnRGYWN0b3J5UmVzb2x2ZXJcbiAgICAgIH07XG4gICAgICBJZGVudGlmaWVycy5Db21wb25lbnRGYWN0b3J5UmVzb2x2ZXIgPSB7XG4gICAgICAgICAgbmFtZTogJ0NvbXBvbmVudEZhY3RvcnlSZXNvbHZlcicsXG4gICAgICAgICAgbW9kdWxlVXJsOiBhc3NldFVybCgnY29yZScsICdsaW5rZXIvY29tcG9uZW50X2ZhY3RvcnlfcmVzb2x2ZXInKSxcbiAgICAgICAgICBydW50aW1lOiBfYW5ndWxhcl9jb3JlLkNvbXBvbmVudEZhY3RvcnlSZXNvbHZlclxuICAgICAgfTtcbiAgICAgIElkZW50aWZpZXJzLkNvbXBvbmVudEZhY3RvcnkgPSB7XG4gICAgICAgICAgbmFtZTogJ0NvbXBvbmVudEZhY3RvcnknLFxuICAgICAgICAgIHJ1bnRpbWU6IF9hbmd1bGFyX2NvcmUuQ29tcG9uZW50RmFjdG9yeSxcbiAgICAgICAgICBtb2R1bGVVcmw6IGFzc2V0VXJsKCdjb3JlJywgJ2xpbmtlci9jb21wb25lbnRfZmFjdG9yeScpXG4gICAgICB9O1xuICAgICAgSWRlbnRpZmllcnMuTmdNb2R1bGVGYWN0b3J5ID0ge1xuICAgICAgICAgIG5hbWU6ICdOZ01vZHVsZUZhY3RvcnknLFxuICAgICAgICAgIHJ1bnRpbWU6IF9hbmd1bGFyX2NvcmUuTmdNb2R1bGVGYWN0b3J5LFxuICAgICAgICAgIG1vZHVsZVVybDogYXNzZXRVcmwoJ2NvcmUnLCAnbGlua2VyL25nX21vZHVsZV9mYWN0b3J5JylcbiAgICAgIH07XG4gICAgICBJZGVudGlmaWVycy5OZ01vZHVsZUluamVjdG9yID0ge1xuICAgICAgICAgIG5hbWU6ICdOZ01vZHVsZUluamVjdG9yJyxcbiAgICAgICAgICBydW50aW1lOiBOZ01vZHVsZUluamVjdG9yLFxuICAgICAgICAgIG1vZHVsZVVybDogYXNzZXRVcmwoJ2NvcmUnLCAnbGlua2VyL25nX21vZHVsZV9mYWN0b3J5JylcbiAgICAgIH07XG4gICAgICBJZGVudGlmaWVycy5SZWdpc3Rlck1vZHVsZUZhY3RvcnlGbiA9IHtcbiAgICAgICAgICBuYW1lOiAncmVnaXN0ZXJNb2R1bGVGYWN0b3J5JyxcbiAgICAgICAgICBydW50aW1lOiByZWdpc3Rlck1vZHVsZUZhY3RvcnksXG4gICAgICAgICAgbW9kdWxlVXJsOiBhc3NldFVybCgnY29yZScsICdsaW5rZXIvbmdfbW9kdWxlX2ZhY3RvcnlfbG9hZGVyJylcbiAgICAgIH07XG4gICAgICBJZGVudGlmaWVycy5WYWx1ZVVud3JhcHBlciA9IHsgbmFtZTogJ1ZhbHVlVW53cmFwcGVyJywgbW9kdWxlVXJsOiBDRF9NT0RVTEVfVVJMLCBydW50aW1lOiBWYWx1ZVVud3JhcHBlciB9O1xuICAgICAgSWRlbnRpZmllcnMuSW5qZWN0b3IgPSB7XG4gICAgICAgICAgbmFtZTogJ0luamVjdG9yJyxcbiAgICAgICAgICBtb2R1bGVVcmw6IGFzc2V0VXJsKCdjb3JlJywgJ2RpL2luamVjdG9yJyksXG4gICAgICAgICAgcnVudGltZTogX2FuZ3VsYXJfY29yZS5JbmplY3RvclxuICAgICAgfTtcbiAgICAgIElkZW50aWZpZXJzLlZpZXdFbmNhcHN1bGF0aW9uID0ge1xuICAgICAgICAgIG5hbWU6ICdWaWV3RW5jYXBzdWxhdGlvbicsXG4gICAgICAgICAgbW9kdWxlVXJsOiBhc3NldFVybCgnY29yZScsICdtZXRhZGF0YS92aWV3JyksXG4gICAgICAgICAgcnVudGltZTogX2FuZ3VsYXJfY29yZS5WaWV3RW5jYXBzdWxhdGlvblxuICAgICAgfTtcbiAgICAgIElkZW50aWZpZXJzLlZpZXdUeXBlID0ge1xuICAgICAgICAgIG5hbWU6ICdWaWV3VHlwZScsXG4gICAgICAgICAgbW9kdWxlVXJsOiBhc3NldFVybCgnY29yZScsICdsaW5rZXIvdmlld190eXBlJyksXG4gICAgICAgICAgcnVudGltZTogVmlld1R5cGVcbiAgICAgIH07XG4gICAgICBJZGVudGlmaWVycy5DaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSA9IHtcbiAgICAgICAgICBuYW1lOiAnQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3knLFxuICAgICAgICAgIG1vZHVsZVVybDogQ0RfTU9EVUxFX1VSTCxcbiAgICAgICAgICBydW50aW1lOiBfYW5ndWxhcl9jb3JlLkNoYW5nZURldGVjdGlvblN0cmF0ZWd5XG4gICAgICB9O1xuICAgICAgSWRlbnRpZmllcnMuU3RhdGljTm9kZURlYnVnSW5mbyA9IHtcbiAgICAgICAgICBuYW1lOiAnU3RhdGljTm9kZURlYnVnSW5mbycsXG4gICAgICAgICAgbW9kdWxlVXJsOiBhc3NldFVybCgnY29yZScsICdsaW5rZXIvZGVidWdfY29udGV4dCcpLFxuICAgICAgICAgIHJ1bnRpbWU6IFN0YXRpY05vZGVEZWJ1Z0luZm9cbiAgICAgIH07XG4gICAgICBJZGVudGlmaWVycy5EZWJ1Z0NvbnRleHQgPSB7XG4gICAgICAgICAgbmFtZTogJ0RlYnVnQ29udGV4dCcsXG4gICAgICAgICAgbW9kdWxlVXJsOiBhc3NldFVybCgnY29yZScsICdsaW5rZXIvZGVidWdfY29udGV4dCcpLFxuICAgICAgICAgIHJ1bnRpbWU6IERlYnVnQ29udGV4dFxuICAgICAgfTtcbiAgICAgIElkZW50aWZpZXJzLlJlbmRlcmVyID0ge1xuICAgICAgICAgIG5hbWU6ICdSZW5kZXJlcicsXG4gICAgICAgICAgbW9kdWxlVXJsOiBhc3NldFVybCgnY29yZScsICdyZW5kZXIvYXBpJyksXG4gICAgICAgICAgcnVudGltZTogX2FuZ3VsYXJfY29yZS5SZW5kZXJlclxuICAgICAgfTtcbiAgICAgIElkZW50aWZpZXJzLlNpbXBsZUNoYW5nZSA9IHsgbmFtZTogJ1NpbXBsZUNoYW5nZScsIG1vZHVsZVVybDogQ0RfTU9EVUxFX1VSTCwgcnVudGltZTogX2FuZ3VsYXJfY29yZS5TaW1wbGVDaGFuZ2UgfTtcbiAgICAgIElkZW50aWZpZXJzLlVOSU5JVElBTElaRUQgPSB7IG5hbWU6ICdVTklOSVRJQUxJWkVEJywgbW9kdWxlVXJsOiBDRF9NT0RVTEVfVVJMLCBydW50aW1lOiBVTklOSVRJQUxJWkVEIH07XG4gICAgICBJZGVudGlmaWVycy5DaGFuZ2VEZXRlY3RvclN0YXR1cyA9IHtcbiAgICAgICAgICBuYW1lOiAnQ2hhbmdlRGV0ZWN0b3JTdGF0dXMnLFxuICAgICAgICAgIG1vZHVsZVVybDogQ0RfTU9EVUxFX1VSTCxcbiAgICAgICAgICBydW50aW1lOiBDaGFuZ2VEZXRlY3RvclN0YXR1c1xuICAgICAgfTtcbiAgICAgIElkZW50aWZpZXJzLmNoZWNrQmluZGluZyA9IHtcbiAgICAgICAgICBuYW1lOiAnY2hlY2tCaW5kaW5nJyxcbiAgICAgICAgICBtb2R1bGVVcmw6IFZJRVdfVVRJTFNfTU9EVUxFX1VSTCxcbiAgICAgICAgICBydW50aW1lOiB2aWV3X3V0aWxzLmNoZWNrQmluZGluZ1xuICAgICAgfTtcbiAgICAgIElkZW50aWZpZXJzLmZsYXR0ZW5OZXN0ZWRWaWV3UmVuZGVyTm9kZXMgPSB7XG4gICAgICAgICAgbmFtZTogJ2ZsYXR0ZW5OZXN0ZWRWaWV3UmVuZGVyTm9kZXMnLFxuICAgICAgICAgIG1vZHVsZVVybDogVklFV19VVElMU19NT0RVTEVfVVJMLFxuICAgICAgICAgIHJ1bnRpbWU6IHZpZXdfdXRpbHMuZmxhdHRlbk5lc3RlZFZpZXdSZW5kZXJOb2Rlc1xuICAgICAgfTtcbiAgICAgIElkZW50aWZpZXJzLmRldk1vZGVFcXVhbCA9IHsgbmFtZTogJ2Rldk1vZGVFcXVhbCcsIG1vZHVsZVVybDogQ0RfTU9EVUxFX1VSTCwgcnVudGltZTogZGV2TW9kZUVxdWFsIH07XG4gICAgICBJZGVudGlmaWVycy5pbnRlcnBvbGF0ZSA9IHtcbiAgICAgICAgICBuYW1lOiAnaW50ZXJwb2xhdGUnLFxuICAgICAgICAgIG1vZHVsZVVybDogVklFV19VVElMU19NT0RVTEVfVVJMLFxuICAgICAgICAgIHJ1bnRpbWU6IHZpZXdfdXRpbHMuaW50ZXJwb2xhdGVcbiAgICAgIH07XG4gICAgICBJZGVudGlmaWVycy5jYXN0QnlWYWx1ZSA9IHtcbiAgICAgICAgICBuYW1lOiAnY2FzdEJ5VmFsdWUnLFxuICAgICAgICAgIG1vZHVsZVVybDogVklFV19VVElMU19NT0RVTEVfVVJMLFxuICAgICAgICAgIHJ1bnRpbWU6IHZpZXdfdXRpbHMuY2FzdEJ5VmFsdWVcbiAgICAgIH07XG4gICAgICBJZGVudGlmaWVycy5FTVBUWV9BUlJBWSA9IHtcbiAgICAgICAgICBuYW1lOiAnRU1QVFlfQVJSQVknLFxuICAgICAgICAgIG1vZHVsZVVybDogVklFV19VVElMU19NT0RVTEVfVVJMLFxuICAgICAgICAgIHJ1bnRpbWU6IHZpZXdfdXRpbHMuRU1QVFlfQVJSQVlcbiAgICAgIH07XG4gICAgICBJZGVudGlmaWVycy5FTVBUWV9NQVAgPSB7XG4gICAgICAgICAgbmFtZTogJ0VNUFRZX01BUCcsXG4gICAgICAgICAgbW9kdWxlVXJsOiBWSUVXX1VUSUxTX01PRFVMRV9VUkwsXG4gICAgICAgICAgcnVudGltZTogdmlld191dGlscy5FTVBUWV9NQVBcbiAgICAgIH07XG4gICAgICBJZGVudGlmaWVycy5jcmVhdGVSZW5kZXJFbGVtZW50ID0ge1xuICAgICAgICAgIG5hbWU6ICdjcmVhdGVSZW5kZXJFbGVtZW50JyxcbiAgICAgICAgICBtb2R1bGVVcmw6IFZJRVdfVVRJTFNfTU9EVUxFX1VSTCxcbiAgICAgICAgICBydW50aW1lOiB2aWV3X3V0aWxzLmNyZWF0ZVJlbmRlckVsZW1lbnRcbiAgICAgIH07XG4gICAgICBJZGVudGlmaWVycy5zZWxlY3RPckNyZWF0ZVJlbmRlckhvc3RFbGVtZW50ID0ge1xuICAgICAgICAgIG5hbWU6ICdzZWxlY3RPckNyZWF0ZVJlbmRlckhvc3RFbGVtZW50JyxcbiAgICAgICAgICBtb2R1bGVVcmw6IFZJRVdfVVRJTFNfTU9EVUxFX1VSTCxcbiAgICAgICAgICBydW50aW1lOiB2aWV3X3V0aWxzLnNlbGVjdE9yQ3JlYXRlUmVuZGVySG9zdEVsZW1lbnRcbiAgICAgIH07XG4gICAgICBJZGVudGlmaWVycy5wdXJlUHJveGllcyA9IFtcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIHsgbmFtZTogJ3B1cmVQcm94eTEnLCBtb2R1bGVVcmw6IFZJRVdfVVRJTFNfTU9EVUxFX1VSTCwgcnVudGltZTogdmlld191dGlscy5wdXJlUHJveHkxIH0sXG4gICAgICAgICAgeyBuYW1lOiAncHVyZVByb3h5MicsIG1vZHVsZVVybDogVklFV19VVElMU19NT0RVTEVfVVJMLCBydW50aW1lOiB2aWV3X3V0aWxzLnB1cmVQcm94eTIgfSxcbiAgICAgICAgICB7IG5hbWU6ICdwdXJlUHJveHkzJywgbW9kdWxlVXJsOiBWSUVXX1VUSUxTX01PRFVMRV9VUkwsIHJ1bnRpbWU6IHZpZXdfdXRpbHMucHVyZVByb3h5MyB9LFxuICAgICAgICAgIHsgbmFtZTogJ3B1cmVQcm94eTQnLCBtb2R1bGVVcmw6IFZJRVdfVVRJTFNfTU9EVUxFX1VSTCwgcnVudGltZTogdmlld191dGlscy5wdXJlUHJveHk0IH0sXG4gICAgICAgICAgeyBuYW1lOiAncHVyZVByb3h5NScsIG1vZHVsZVVybDogVklFV19VVElMU19NT0RVTEVfVVJMLCBydW50aW1lOiB2aWV3X3V0aWxzLnB1cmVQcm94eTUgfSxcbiAgICAgICAgICB7IG5hbWU6ICdwdXJlUHJveHk2JywgbW9kdWxlVXJsOiBWSUVXX1VUSUxTX01PRFVMRV9VUkwsIHJ1bnRpbWU6IHZpZXdfdXRpbHMucHVyZVByb3h5NiB9LFxuICAgICAgICAgIHsgbmFtZTogJ3B1cmVQcm94eTcnLCBtb2R1bGVVcmw6IFZJRVdfVVRJTFNfTU9EVUxFX1VSTCwgcnVudGltZTogdmlld191dGlscy5wdXJlUHJveHk3IH0sXG4gICAgICAgICAgeyBuYW1lOiAncHVyZVByb3h5OCcsIG1vZHVsZVVybDogVklFV19VVElMU19NT0RVTEVfVVJMLCBydW50aW1lOiB2aWV3X3V0aWxzLnB1cmVQcm94eTggfSxcbiAgICAgICAgICB7IG5hbWU6ICdwdXJlUHJveHk5JywgbW9kdWxlVXJsOiBWSUVXX1VUSUxTX01PRFVMRV9VUkwsIHJ1bnRpbWU6IHZpZXdfdXRpbHMucHVyZVByb3h5OSB9LFxuICAgICAgICAgIHsgbmFtZTogJ3B1cmVQcm94eTEwJywgbW9kdWxlVXJsOiBWSUVXX1VUSUxTX01PRFVMRV9VUkwsIHJ1bnRpbWU6IHZpZXdfdXRpbHMucHVyZVByb3h5MTAgfSxcbiAgICAgIF07XG4gICAgICBJZGVudGlmaWVycy5TZWN1cml0eUNvbnRleHQgPSB7XG4gICAgICAgICAgbmFtZTogJ1NlY3VyaXR5Q29udGV4dCcsXG4gICAgICAgICAgbW9kdWxlVXJsOiBhc3NldFVybCgnY29yZScsICdzZWN1cml0eScpLFxuICAgICAgICAgIHJ1bnRpbWU6IF9hbmd1bGFyX2NvcmUuU2VjdXJpdHlDb250ZXh0LFxuICAgICAgfTtcbiAgICAgIElkZW50aWZpZXJzLkFuaW1hdGlvbktleWZyYW1lID0ge1xuICAgICAgICAgIG5hbWU6ICdBbmltYXRpb25LZXlmcmFtZScsXG4gICAgICAgICAgbW9kdWxlVXJsOiBhc3NldFVybCgnY29yZScsICdhbmltYXRpb24vYW5pbWF0aW9uX2tleWZyYW1lJyksXG4gICAgICAgICAgcnVudGltZTogQW5pbWF0aW9uS2V5ZnJhbWVcbiAgICAgIH07XG4gICAgICBJZGVudGlmaWVycy5BbmltYXRpb25TdHlsZXMgPSB7XG4gICAgICAgICAgbmFtZTogJ0FuaW1hdGlvblN0eWxlcycsXG4gICAgICAgICAgbW9kdWxlVXJsOiBhc3NldFVybCgnY29yZScsICdhbmltYXRpb24vYW5pbWF0aW9uX3N0eWxlcycpLFxuICAgICAgICAgIHJ1bnRpbWU6IEFuaW1hdGlvblN0eWxlc1xuICAgICAgfTtcbiAgICAgIElkZW50aWZpZXJzLk5vT3BBbmltYXRpb25QbGF5ZXIgPSB7XG4gICAgICAgICAgbmFtZTogJ05vT3BBbmltYXRpb25QbGF5ZXInLFxuICAgICAgICAgIG1vZHVsZVVybDogYXNzZXRVcmwoJ2NvcmUnLCAnYW5pbWF0aW9uL2FuaW1hdGlvbl9wbGF5ZXInKSxcbiAgICAgICAgICBydW50aW1lOiBOb09wQW5pbWF0aW9uUGxheWVyXG4gICAgICB9O1xuICAgICAgSWRlbnRpZmllcnMuQW5pbWF0aW9uR3JvdXBQbGF5ZXIgPSB7XG4gICAgICAgICAgbmFtZTogJ0FuaW1hdGlvbkdyb3VwUGxheWVyJyxcbiAgICAgICAgICBtb2R1bGVVcmw6IGFzc2V0VXJsKCdjb3JlJywgJ2FuaW1hdGlvbi9hbmltYXRpb25fZ3JvdXBfcGxheWVyJyksXG4gICAgICAgICAgcnVudGltZTogQW5pbWF0aW9uR3JvdXBQbGF5ZXJcbiAgICAgIH07XG4gICAgICBJZGVudGlmaWVycy5BbmltYXRpb25TZXF1ZW5jZVBsYXllciA9IHtcbiAgICAgICAgICBuYW1lOiAnQW5pbWF0aW9uU2VxdWVuY2VQbGF5ZXInLFxuICAgICAgICAgIG1vZHVsZVVybDogYXNzZXRVcmwoJ2NvcmUnLCAnYW5pbWF0aW9uL2FuaW1hdGlvbl9zZXF1ZW5jZV9wbGF5ZXInKSxcbiAgICAgICAgICBydW50aW1lOiBBbmltYXRpb25TZXF1ZW5jZVBsYXllclxuICAgICAgfTtcbiAgICAgIElkZW50aWZpZXJzLnByZXBhcmVGaW5hbEFuaW1hdGlvblN0eWxlcyA9IHtcbiAgICAgICAgICBuYW1lOiAncHJlcGFyZUZpbmFsQW5pbWF0aW9uU3R5bGVzJyxcbiAgICAgICAgICBtb2R1bGVVcmw6IEFOSU1BVElPTl9TVFlMRV9VVElMX0FTU0VUX1VSTCxcbiAgICAgICAgICBydW50aW1lOiBwcmVwYXJlRmluYWxBbmltYXRpb25TdHlsZXNcbiAgICAgIH07XG4gICAgICBJZGVudGlmaWVycy5iYWxhbmNlQW5pbWF0aW9uS2V5ZnJhbWVzID0ge1xuICAgICAgICAgIG5hbWU6ICdiYWxhbmNlQW5pbWF0aW9uS2V5ZnJhbWVzJyxcbiAgICAgICAgICBtb2R1bGVVcmw6IEFOSU1BVElPTl9TVFlMRV9VVElMX0FTU0VUX1VSTCxcbiAgICAgICAgICBydW50aW1lOiBiYWxhbmNlQW5pbWF0aW9uS2V5ZnJhbWVzXG4gICAgICB9O1xuICAgICAgSWRlbnRpZmllcnMuY2xlYXJTdHlsZXMgPSB7XG4gICAgICAgICAgbmFtZTogJ2NsZWFyU3R5bGVzJyxcbiAgICAgICAgICBtb2R1bGVVcmw6IEFOSU1BVElPTl9TVFlMRV9VVElMX0FTU0VUX1VSTCxcbiAgICAgICAgICBydW50aW1lOiBjbGVhclN0eWxlc1xuICAgICAgfTtcbiAgICAgIElkZW50aWZpZXJzLnJlbmRlclN0eWxlcyA9IHtcbiAgICAgICAgICBuYW1lOiAncmVuZGVyU3R5bGVzJyxcbiAgICAgICAgICBtb2R1bGVVcmw6IEFOSU1BVElPTl9TVFlMRV9VVElMX0FTU0VUX1VSTCxcbiAgICAgICAgICBydW50aW1lOiByZW5kZXJTdHlsZXNcbiAgICAgIH07XG4gICAgICBJZGVudGlmaWVycy5jb2xsZWN0QW5kUmVzb2x2ZVN0eWxlcyA9IHtcbiAgICAgICAgICBuYW1lOiAnY29sbGVjdEFuZFJlc29sdmVTdHlsZXMnLFxuICAgICAgICAgIG1vZHVsZVVybDogQU5JTUFUSU9OX1NUWUxFX1VUSUxfQVNTRVRfVVJMLFxuICAgICAgICAgIHJ1bnRpbWU6IGNvbGxlY3RBbmRSZXNvbHZlU3R5bGVzXG4gICAgICB9O1xuICAgICAgSWRlbnRpZmllcnMuTE9DQUxFX0lEID0ge1xuICAgICAgICAgIG5hbWU6ICdMT0NBTEVfSUQnLFxuICAgICAgICAgIG1vZHVsZVVybDogYXNzZXRVcmwoJ2NvcmUnLCAnaTE4bi90b2tlbnMnKSxcbiAgICAgICAgICBydW50aW1lOiBfYW5ndWxhcl9jb3JlLkxPQ0FMRV9JRFxuICAgICAgfTtcbiAgICAgIElkZW50aWZpZXJzLlRSQU5TTEFUSU9OU19GT1JNQVQgPSB7XG4gICAgICAgICAgbmFtZTogJ1RSQU5TTEFUSU9OU19GT1JNQVQnLFxuICAgICAgICAgIG1vZHVsZVVybDogYXNzZXRVcmwoJ2NvcmUnLCAnaTE4bi90b2tlbnMnKSxcbiAgICAgICAgICBydW50aW1lOiBfYW5ndWxhcl9jb3JlLlRSQU5TTEFUSU9OU19GT1JNQVRcbiAgICAgIH07XG4gICAgICBJZGVudGlmaWVycy5zZXRCaW5kaW5nRGVidWdJbmZvID0ge1xuICAgICAgICAgIG5hbWU6ICdzZXRCaW5kaW5nRGVidWdJbmZvJyxcbiAgICAgICAgICBtb2R1bGVVcmw6IFZJRVdfVVRJTFNfTU9EVUxFX1VSTCxcbiAgICAgICAgICBydW50aW1lOiB2aWV3X3V0aWxzLnNldEJpbmRpbmdEZWJ1Z0luZm9cbiAgICAgIH07XG4gICAgICBJZGVudGlmaWVycy5zZXRCaW5kaW5nRGVidWdJbmZvRm9yQ2hhbmdlcyA9IHtcbiAgICAgICAgICBuYW1lOiAnc2V0QmluZGluZ0RlYnVnSW5mb0ZvckNoYW5nZXMnLFxuICAgICAgICAgIG1vZHVsZVVybDogVklFV19VVElMU19NT0RVTEVfVVJMLFxuICAgICAgICAgIHJ1bnRpbWU6IHZpZXdfdXRpbHMuc2V0QmluZGluZ0RlYnVnSW5mb0ZvckNoYW5nZXNcbiAgICAgIH07XG4gICAgICBJZGVudGlmaWVycy5BbmltYXRpb25UcmFuc2l0aW9uID0ge1xuICAgICAgICAgIG5hbWU6ICdBbmltYXRpb25UcmFuc2l0aW9uJyxcbiAgICAgICAgICBtb2R1bGVVcmw6IGFzc2V0VXJsKCdjb3JlJywgJ2FuaW1hdGlvbi9hbmltYXRpb25fdHJhbnNpdGlvbicpLFxuICAgICAgICAgIHJ1bnRpbWU6IEFuaW1hdGlvblRyYW5zaXRpb25cbiAgICAgIH07XG4gICAgICAvLyBUaGlzIGlzIGp1c3QgdGhlIGludGVyZmFjZSFcbiAgICAgIElkZW50aWZpZXJzLklubGluZUFycmF5ID0geyBuYW1lOiAnSW5saW5lQXJyYXknLCBtb2R1bGVVcmw6IFZJRVdfVVRJTFNfTU9EVUxFX1VSTCwgcnVudGltZTogbnVsbCB9O1xuICAgICAgSWRlbnRpZmllcnMuaW5saW5lQXJyYXlzID0gW1xuICAgICAgICAgIHsgbmFtZTogJ0lubGluZUFycmF5MicsIG1vZHVsZVVybDogVklFV19VVElMU19NT0RVTEVfVVJMLCBydW50aW1lOiB2aWV3X3V0aWxzLklubGluZUFycmF5MiB9LFxuICAgICAgICAgIHsgbmFtZTogJ0lubGluZUFycmF5MicsIG1vZHVsZVVybDogVklFV19VVElMU19NT0RVTEVfVVJMLCBydW50aW1lOiB2aWV3X3V0aWxzLklubGluZUFycmF5MiB9LFxuICAgICAgICAgIHsgbmFtZTogJ0lubGluZUFycmF5NCcsIG1vZHVsZVVybDogVklFV19VVElMU19NT0RVTEVfVVJMLCBydW50aW1lOiB2aWV3X3V0aWxzLklubGluZUFycmF5NCB9LFxuICAgICAgICAgIHsgbmFtZTogJ0lubGluZUFycmF5OCcsIG1vZHVsZVVybDogVklFV19VVElMU19NT0RVTEVfVVJMLCBydW50aW1lOiB2aWV3X3V0aWxzLklubGluZUFycmF5OCB9LFxuICAgICAgICAgIHsgbmFtZTogJ0lubGluZUFycmF5MTYnLCBtb2R1bGVVcmw6IFZJRVdfVVRJTFNfTU9EVUxFX1VSTCwgcnVudGltZTogdmlld191dGlscy5JbmxpbmVBcnJheTE2IH0sXG4gICAgICBdO1xuICAgICAgSWRlbnRpZmllcnMuRU1QVFlfSU5MSU5FX0FSUkFZID0ge1xuICAgICAgICAgIG5hbWU6ICdFTVBUWV9JTkxJTkVfQVJSQVknLFxuICAgICAgICAgIG1vZHVsZVVybDogVklFV19VVElMU19NT0RVTEVfVVJMLFxuICAgICAgICAgIHJ1bnRpbWU6IHZpZXdfdXRpbHMuRU1QVFlfSU5MSU5FX0FSUkFZXG4gICAgICB9O1xuICAgICAgSWRlbnRpZmllcnMuSW5saW5lQXJyYXlEeW5hbWljID0ge1xuICAgICAgICAgIG5hbWU6ICdJbmxpbmVBcnJheUR5bmFtaWMnLFxuICAgICAgICAgIG1vZHVsZVVybDogVklFV19VVElMU19NT0RVTEVfVVJMLFxuICAgICAgICAgIHJ1bnRpbWU6IHZpZXdfdXRpbHMuSW5saW5lQXJyYXlEeW5hbWljXG4gICAgICB9O1xuICAgICAgcmV0dXJuIElkZW50aWZpZXJzO1xuICB9KCkpO1xuICBmdW5jdGlvbiBhc3NldFVybChwa2csIHBhdGgsIHR5cGUpIHtcbiAgICAgIGlmIChwYXRoID09PSB2b2lkIDApIHsgcGF0aCA9IG51bGw7IH1cbiAgICAgIGlmICh0eXBlID09PSB2b2lkIDApIHsgdHlwZSA9ICdzcmMnOyB9XG4gICAgICBpZiAocGF0aCA9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIFwiYXNzZXQ6QGFuZ3VsYXIvbGliL1wiICsgcGtnICsgXCIvaW5kZXhcIjtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAgIHJldHVybiBcImFzc2V0OkBhbmd1bGFyL2xpYi9cIiArIHBrZyArIFwiL3NyYy9cIiArIHBhdGg7XG4gICAgICB9XG4gIH1cbiAgZnVuY3Rpb24gcmVzb2x2ZUlkZW50aWZpZXIoaWRlbnRpZmllcikge1xuICAgICAgcmV0dXJuIG5ldyBDb21waWxlSWRlbnRpZmllck1ldGFkYXRhKHtcbiAgICAgICAgICBuYW1lOiBpZGVudGlmaWVyLm5hbWUsXG4gICAgICAgICAgbW9kdWxlVXJsOiBpZGVudGlmaWVyLm1vZHVsZVVybCxcbiAgICAgICAgICByZWZlcmVuY2U6IHJlZmxlY3Rvci5yZXNvbHZlSWRlbnRpZmllcihpZGVudGlmaWVyLm5hbWUsIGlkZW50aWZpZXIubW9kdWxlVXJsLCBpZGVudGlmaWVyLnJ1bnRpbWUpXG4gICAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBpZGVudGlmaWVyVG9rZW4oaWRlbnRpZmllcikge1xuICAgICAgcmV0dXJuIG5ldyBDb21waWxlVG9rZW5NZXRhZGF0YSh7IGlkZW50aWZpZXI6IGlkZW50aWZpZXIgfSk7XG4gIH1cbiAgZnVuY3Rpb24gcmVzb2x2ZUlkZW50aWZpZXJUb2tlbihpZGVudGlmaWVyKSB7XG4gICAgICByZXR1cm4gaWRlbnRpZmllclRva2VuKHJlc29sdmVJZGVudGlmaWVyKGlkZW50aWZpZXIpKTtcbiAgfVxuICBmdW5jdGlvbiByZXNvbHZlRW51bUlkZW50aWZpZXIoZW51bVR5cGUsIG5hbWUpIHtcbiAgICAgIHZhciByZXNvbHZlZEVudW0gPSByZWZsZWN0b3IucmVzb2x2ZUVudW0oZW51bVR5cGUucmVmZXJlbmNlLCBuYW1lKTtcbiAgICAgIHJldHVybiBuZXcgQ29tcGlsZUlkZW50aWZpZXJNZXRhZGF0YSh7IG5hbWU6IGVudW1UeXBlLm5hbWUgKyBcIi5cIiArIG5hbWUsIG1vZHVsZVVybDogZW51bVR5cGUubW9kdWxlVXJsLCByZWZlcmVuY2U6IHJlc29sdmVkRW51bSB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbGljZW5zZVxuICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICpcbiAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgKi9cbiAgdmFyIF9fZXh0ZW5kcyQ4ID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICB9O1xuICB2YXIgSHRtbFBhcnNlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkOChIdG1sUGFyc2VyLCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gSHRtbFBhcnNlcigpIHtcbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBnZXRIdG1sVGFnRGVmaW5pdGlvbik7XG4gICAgICB9XG4gICAgICBIdG1sUGFyc2VyLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIChzb3VyY2UsIHVybCwgcGFyc2VFeHBhbnNpb25Gb3JtcywgaW50ZXJwb2xhdGlvbkNvbmZpZykge1xuICAgICAgICAgIGlmIChwYXJzZUV4cGFuc2lvbkZvcm1zID09PSB2b2lkIDApIHsgcGFyc2VFeHBhbnNpb25Gb3JtcyA9IGZhbHNlOyB9XG4gICAgICAgICAgaWYgKGludGVycG9sYXRpb25Db25maWcgPT09IHZvaWQgMCkgeyBpbnRlcnBvbGF0aW9uQ29uZmlnID0gREVGQVVMVF9JTlRFUlBPTEFUSU9OX0NPTkZJRzsgfVxuICAgICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLnBhcnNlLmNhbGwodGhpcywgc291cmNlLCB1cmwsIHBhcnNlRXhwYW5zaW9uRm9ybXMsIGludGVycG9sYXRpb25Db25maWcpO1xuICAgICAgfTtcbiAgICAgIEh0bWxQYXJzZXIuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0YWJsZSB9LFxuICAgICAgXTtcbiAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgSHRtbFBhcnNlci5jdG9yUGFyYW1ldGVycyA9IFtdO1xuICAgICAgcmV0dXJuIEh0bWxQYXJzZXI7XG4gIH0oUGFyc2VyJDEpKTtcblxuICAvKipcbiAgICogQGxpY2Vuc2VcbiAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAqXG4gICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICovXG4gIHZhciBfX2V4dGVuZHMkOSA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgfTtcbiAgLy8gaHR0cDovL2NsZHIudW5pY29kZS5vcmcvaW5kZXgvY2xkci1zcGVjL3BsdXJhbC1ydWxlc1xuICB2YXIgUExVUkFMX0NBU0VTID0gWyd6ZXJvJywgJ29uZScsICd0d28nLCAnZmV3JywgJ21hbnknLCAnb3RoZXInXTtcbiAgLyoqXG4gICAqIEV4cGFuZHMgc3BlY2lhbCBmb3JtcyBpbnRvIGVsZW1lbnRzLlxuICAgKlxuICAgKiBGb3IgZXhhbXBsZSxcbiAgICpcbiAgICogYGBgXG4gICAqIHsgbWVzc2FnZXMubGVuZ3RoLCBwbHVyYWwsXG4gICAqICAgPTAge3plcm99XG4gICAqICAgPTEge29uZX1cbiAgICogICBvdGhlciB7bW9yZSB0aGFuIG9uZX1cbiAgICogfVxuICAgKiBgYGBcbiAgICpcbiAgICogd2lsbCBiZSBleHBhbmRlZCBpbnRvXG4gICAqXG4gICAqIGBgYFxuICAgKiA8bmctY29udGFpbmVyIFtuZ1BsdXJhbF09XCJtZXNzYWdlcy5sZW5ndGhcIj5cbiAgICogICA8dGVtcGxhdGUgbmdQbHVyYWxDYXNlPVwiPTBcIj56ZXJvPC9uZy1jb250YWluZXI+XG4gICAqICAgPHRlbXBsYXRlIG5nUGx1cmFsQ2FzZT1cIj0xXCI+b25lPC9uZy1jb250YWluZXI+XG4gICAqICAgPHRlbXBsYXRlIG5nUGx1cmFsQ2FzZT1cIm90aGVyXCI+bW9yZSB0aGFuIG9uZTwvbmctY29udGFpbmVyPlxuICAgKiA8L25nLWNvbnRhaW5lcj5cbiAgICogYGBgXG4gICAqL1xuICBmdW5jdGlvbiBleHBhbmROb2Rlcyhub2Rlcykge1xuICAgICAgdmFyIGV4cGFuZGVyID0gbmV3IF9FeHBhbmRlcigpO1xuICAgICAgcmV0dXJuIG5ldyBFeHBhbnNpb25SZXN1bHQodmlzaXRBbGwoZXhwYW5kZXIsIG5vZGVzKSwgZXhwYW5kZXIuaXNFeHBhbmRlZCwgZXhwYW5kZXIuZXJyb3JzKTtcbiAgfVxuICB2YXIgRXhwYW5zaW9uUmVzdWx0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIEV4cGFuc2lvblJlc3VsdChub2RlcywgZXhwYW5kZWQsIGVycm9ycykge1xuICAgICAgICAgIHRoaXMubm9kZXMgPSBub2RlcztcbiAgICAgICAgICB0aGlzLmV4cGFuZGVkID0gZXhwYW5kZWQ7XG4gICAgICAgICAgdGhpcy5lcnJvcnMgPSBlcnJvcnM7XG4gICAgICB9XG4gICAgICByZXR1cm4gRXhwYW5zaW9uUmVzdWx0O1xuICB9KCkpO1xuICB2YXIgRXhwYW5zaW9uRXJyb3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDkoRXhwYW5zaW9uRXJyb3IsIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBFeHBhbnNpb25FcnJvcihzcGFuLCBlcnJvck1zZykge1xuICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIHNwYW4sIGVycm9yTXNnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBFeHBhbnNpb25FcnJvcjtcbiAgfShQYXJzZUVycm9yKSk7XG4gIC8qKlxuICAgKiBFeHBhbmQgZXhwYW5zaW9uIGZvcm1zIChwbHVyYWwsIHNlbGVjdCkgdG8gZGlyZWN0aXZlc1xuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHZhciBfRXhwYW5kZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gX0V4cGFuZGVyKCkge1xuICAgICAgICAgIHRoaXMuaXNFeHBhbmRlZCA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMuZXJyb3JzID0gW107XG4gICAgICB9XG4gICAgICBfRXhwYW5kZXIucHJvdG90eXBlLnZpc2l0RWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtZW50LCBjb250ZXh0KSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBFbGVtZW50KGVsZW1lbnQubmFtZSwgZWxlbWVudC5hdHRycywgdmlzaXRBbGwodGhpcywgZWxlbWVudC5jaGlsZHJlbiksIGVsZW1lbnQuc291cmNlU3BhbiwgZWxlbWVudC5zdGFydFNvdXJjZVNwYW4sIGVsZW1lbnQuZW5kU291cmNlU3Bhbik7XG4gICAgICB9O1xuICAgICAgX0V4cGFuZGVyLnByb3RvdHlwZS52aXNpdEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChhdHRyaWJ1dGUsIGNvbnRleHQpIHsgcmV0dXJuIGF0dHJpYnV0ZTsgfTtcbiAgICAgIF9FeHBhbmRlci5wcm90b3R5cGUudmlzaXRUZXh0ID0gZnVuY3Rpb24gKHRleHQsIGNvbnRleHQpIHsgcmV0dXJuIHRleHQ7IH07XG4gICAgICBfRXhwYW5kZXIucHJvdG90eXBlLnZpc2l0Q29tbWVudCA9IGZ1bmN0aW9uIChjb21tZW50LCBjb250ZXh0KSB7IHJldHVybiBjb21tZW50OyB9O1xuICAgICAgX0V4cGFuZGVyLnByb3RvdHlwZS52aXNpdEV4cGFuc2lvbiA9IGZ1bmN0aW9uIChpY3UsIGNvbnRleHQpIHtcbiAgICAgICAgICB0aGlzLmlzRXhwYW5kZWQgPSB0cnVlO1xuICAgICAgICAgIHJldHVybiBpY3UudHlwZSA9PSAncGx1cmFsJyA/IF9leHBhbmRQbHVyYWxGb3JtKGljdSwgdGhpcy5lcnJvcnMpIDpcbiAgICAgICAgICAgICAgX2V4cGFuZERlZmF1bHRGb3JtKGljdSwgdGhpcy5lcnJvcnMpO1xuICAgICAgfTtcbiAgICAgIF9FeHBhbmRlci5wcm90b3R5cGUudmlzaXRFeHBhbnNpb25DYXNlID0gZnVuY3Rpb24gKGljdUNhc2UsIGNvbnRleHQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Nob3VsZCBub3QgYmUgcmVhY2hlZCcpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBfRXhwYW5kZXI7XG4gIH0oKSk7XG4gIGZ1bmN0aW9uIF9leHBhbmRQbHVyYWxGb3JtKGFzdCwgZXJyb3JzKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBhc3QuY2FzZXMubWFwKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgaWYgKFBMVVJBTF9DQVNFUy5pbmRleE9mKGMudmFsdWUpID09IC0xICYmICFjLnZhbHVlLm1hdGNoKC9ePVxcZCskLykpIHtcbiAgICAgICAgICAgICAgZXJyb3JzLnB1c2gobmV3IEV4cGFuc2lvbkVycm9yKGMudmFsdWVTb3VyY2VTcGFuLCBcIlBsdXJhbCBjYXNlcyBzaG91bGQgYmUgXFxcIj08bnVtYmVyPlxcXCIgb3Igb25lIG9mIFwiICsgUExVUkFMX0NBU0VTLmpvaW4oXCIsIFwiKSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgZXhwYW5zaW9uUmVzdWx0ID0gZXhwYW5kTm9kZXMoYy5leHByZXNzaW9uKTtcbiAgICAgICAgICBlcnJvcnMucHVzaC5hcHBseShlcnJvcnMsIGV4cGFuc2lvblJlc3VsdC5lcnJvcnMpO1xuICAgICAgICAgIHJldHVybiBuZXcgRWxlbWVudChcInRlbXBsYXRlXCIsIFtuZXcgQXR0cmlidXRlJDEoJ25nUGx1cmFsQ2FzZScsIFwiXCIgKyBjLnZhbHVlLCBjLnZhbHVlU291cmNlU3BhbildLCBleHBhbnNpb25SZXN1bHQubm9kZXMsIGMuc291cmNlU3BhbiwgYy5zb3VyY2VTcGFuLCBjLnNvdXJjZVNwYW4pO1xuICAgICAgfSk7XG4gICAgICB2YXIgc3dpdGNoQXR0ciA9IG5ldyBBdHRyaWJ1dGUkMSgnW25nUGx1cmFsXScsIGFzdC5zd2l0Y2hWYWx1ZSwgYXN0LnN3aXRjaFZhbHVlU291cmNlU3Bhbik7XG4gICAgICByZXR1cm4gbmV3IEVsZW1lbnQoJ25nLWNvbnRhaW5lcicsIFtzd2l0Y2hBdHRyXSwgY2hpbGRyZW4sIGFzdC5zb3VyY2VTcGFuLCBhc3Quc291cmNlU3BhbiwgYXN0LnNvdXJjZVNwYW4pO1xuICB9XG4gIGZ1bmN0aW9uIF9leHBhbmREZWZhdWx0Rm9ybShhc3QsIGVycm9ycykge1xuICAgICAgdmFyIGNoaWxkcmVuID0gYXN0LmNhc2VzLm1hcChmdW5jdGlvbiAoYykge1xuICAgICAgICAgIHZhciBleHBhbnNpb25SZXN1bHQgPSBleHBhbmROb2RlcyhjLmV4cHJlc3Npb24pO1xuICAgICAgICAgIGVycm9ycy5wdXNoLmFwcGx5KGVycm9ycywgZXhwYW5zaW9uUmVzdWx0LmVycm9ycyk7XG4gICAgICAgICAgcmV0dXJuIG5ldyBFbGVtZW50KFwidGVtcGxhdGVcIiwgW25ldyBBdHRyaWJ1dGUkMSgnbmdTd2l0Y2hDYXNlJywgXCJcIiArIGMudmFsdWUsIGMudmFsdWVTb3VyY2VTcGFuKV0sIGV4cGFuc2lvblJlc3VsdC5ub2RlcywgYy5zb3VyY2VTcGFuLCBjLnNvdXJjZVNwYW4sIGMuc291cmNlU3Bhbik7XG4gICAgICB9KTtcbiAgICAgIHZhciBzd2l0Y2hBdHRyID0gbmV3IEF0dHJpYnV0ZSQxKCdbbmdTd2l0Y2hdJywgYXN0LnN3aXRjaFZhbHVlLCBhc3Quc3dpdGNoVmFsdWVTb3VyY2VTcGFuKTtcbiAgICAgIHJldHVybiBuZXcgRWxlbWVudCgnbmctY29udGFpbmVyJywgW3N3aXRjaEF0dHJdLCBjaGlsZHJlbiwgYXN0LnNvdXJjZVNwYW4sIGFzdC5zb3VyY2VTcGFuLCBhc3Quc291cmNlU3Bhbik7XG4gIH1cblxuICAvKipcbiAgICogQGxpY2Vuc2VcbiAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAqXG4gICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICovXG4gIHZhciBfX2V4dGVuZHMkMTAgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gIH07XG4gIHZhciBQcm92aWRlckVycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQxMChQcm92aWRlckVycm9yLCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gUHJvdmlkZXJFcnJvcihtZXNzYWdlLCBzcGFuKSB7XG4gICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgc3BhbiwgbWVzc2FnZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gUHJvdmlkZXJFcnJvcjtcbiAgfShQYXJzZUVycm9yKSk7XG4gIHZhciBQcm92aWRlclZpZXdDb250ZXh0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIFByb3ZpZGVyVmlld0NvbnRleHQoY29tcG9uZW50LCBzb3VyY2VTcGFuKSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICB0aGlzLmNvbXBvbmVudCA9IGNvbXBvbmVudDtcbiAgICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgICAgICAgIHRoaXMuZXJyb3JzID0gW107XG4gICAgICAgICAgdGhpcy52aWV3UXVlcmllcyA9IF9nZXRWaWV3UXVlcmllcyhjb21wb25lbnQpO1xuICAgICAgICAgIHRoaXMudmlld1Byb3ZpZGVycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICBfbm9ybWFsaXplUHJvdmlkZXJzKGNvbXBvbmVudC52aWV3UHJvdmlkZXJzLCBzb3VyY2VTcGFuLCB0aGlzLmVycm9ycykuZm9yRWFjaChmdW5jdGlvbiAocHJvdmlkZXIpIHtcbiAgICAgICAgICAgICAgaWYgKGlzQmxhbmsoX3RoaXMudmlld1Byb3ZpZGVycy5nZXQocHJvdmlkZXIudG9rZW4ucmVmZXJlbmNlKSkpIHtcbiAgICAgICAgICAgICAgICAgIF90aGlzLnZpZXdQcm92aWRlcnMuc2V0KHByb3ZpZGVyLnRva2VuLnJlZmVyZW5jZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBQcm92aWRlclZpZXdDb250ZXh0O1xuICB9KCkpO1xuICB2YXIgUHJvdmlkZXJFbGVtZW50Q29udGV4dCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBQcm92aWRlckVsZW1lbnRDb250ZXh0KHZpZXdDb250ZXh0LCBfcGFyZW50LCBfaXNWaWV3Um9vdCwgX2RpcmVjdGl2ZUFzdHMsIGF0dHJzLCByZWZzLCBfc291cmNlU3Bhbikge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgdGhpcy52aWV3Q29udGV4dCA9IHZpZXdDb250ZXh0O1xuICAgICAgICAgIHRoaXMuX3BhcmVudCA9IF9wYXJlbnQ7XG4gICAgICAgICAgdGhpcy5faXNWaWV3Um9vdCA9IF9pc1ZpZXdSb290O1xuICAgICAgICAgIHRoaXMuX2RpcmVjdGl2ZUFzdHMgPSBfZGlyZWN0aXZlQXN0cztcbiAgICAgICAgICB0aGlzLl9zb3VyY2VTcGFuID0gX3NvdXJjZVNwYW47XG4gICAgICAgICAgdGhpcy5fdHJhbnNmb3JtZWRQcm92aWRlcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgdGhpcy5fc2VlblByb3ZpZGVycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICB0aGlzLl9oYXNWaWV3Q29udGFpbmVyID0gZmFsc2U7XG4gICAgICAgICAgdGhpcy5fYXR0cnMgPSB7fTtcbiAgICAgICAgICBhdHRycy5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyQXN0KSB7IHJldHVybiBfdGhpcy5fYXR0cnNbYXR0ckFzdC5uYW1lXSA9IGF0dHJBc3QudmFsdWU7IH0pO1xuICAgICAgICAgIHZhciBkaXJlY3RpdmVzTWV0YSA9IF9kaXJlY3RpdmVBc3RzLm1hcChmdW5jdGlvbiAoZGlyZWN0aXZlQXN0KSB7IHJldHVybiBkaXJlY3RpdmVBc3QuZGlyZWN0aXZlOyB9KTtcbiAgICAgICAgICB0aGlzLl9hbGxQcm92aWRlcnMgPVxuICAgICAgICAgICAgICBfcmVzb2x2ZVByb3ZpZGVyc0Zyb21EaXJlY3RpdmVzKGRpcmVjdGl2ZXNNZXRhLCBfc291cmNlU3Bhbiwgdmlld0NvbnRleHQuZXJyb3JzKTtcbiAgICAgICAgICB0aGlzLl9jb250ZW50UXVlcmllcyA9IF9nZXRDb250ZW50UXVlcmllcyhkaXJlY3RpdmVzTWV0YSk7XG4gICAgICAgICAgdmFyIHF1ZXJpZWRUb2tlbnMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgTWFwV3JhcHBlci52YWx1ZXModGhpcy5fYWxsUHJvdmlkZXJzKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm92aWRlcikge1xuICAgICAgICAgICAgICBfdGhpcy5fYWRkUXVlcnlSZWFkc1RvKHByb3ZpZGVyLnRva2VuLCBxdWVyaWVkVG9rZW5zKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZWZzLmZvckVhY2goZnVuY3Rpb24gKHJlZkFzdCkge1xuICAgICAgICAgICAgICBfdGhpcy5fYWRkUXVlcnlSZWFkc1RvKG5ldyBDb21waWxlVG9rZW5NZXRhZGF0YSh7IHZhbHVlOiByZWZBc3QubmFtZSB9KSwgcXVlcmllZFRva2Vucyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKGlzUHJlc2VudChxdWVyaWVkVG9rZW5zLmdldChyZXNvbHZlSWRlbnRpZmllclRva2VuKElkZW50aWZpZXJzLlZpZXdDb250YWluZXJSZWYpLnJlZmVyZW5jZSkpKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2hhc1ZpZXdDb250YWluZXIgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBjcmVhdGUgdGhlIHByb3ZpZGVycyB0aGF0IHdlIGtub3cgYXJlIGVhZ2VyIGZpcnN0XG4gICAgICAgICAgTWFwV3JhcHBlci52YWx1ZXModGhpcy5fYWxsUHJvdmlkZXJzKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm92aWRlcikge1xuICAgICAgICAgICAgICB2YXIgZWFnZXIgPSBwcm92aWRlci5lYWdlciB8fCBpc1ByZXNlbnQocXVlcmllZFRva2Vucy5nZXQocHJvdmlkZXIudG9rZW4ucmVmZXJlbmNlKSk7XG4gICAgICAgICAgICAgIGlmIChlYWdlcikge1xuICAgICAgICAgICAgICAgICAgX3RoaXMuX2dldE9yQ3JlYXRlTG9jYWxQcm92aWRlcihwcm92aWRlci5wcm92aWRlclR5cGUsIHByb3ZpZGVyLnRva2VuLCB0cnVlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgUHJvdmlkZXJFbGVtZW50Q29udGV4dC5wcm90b3R5cGUuYWZ0ZXJFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgLy8gY29sbGVjdCBsYXp5IHByb3ZpZGVyc1xuICAgICAgICAgIE1hcFdyYXBwZXIudmFsdWVzKHRoaXMuX2FsbFByb3ZpZGVycykuZm9yRWFjaChmdW5jdGlvbiAocHJvdmlkZXIpIHtcbiAgICAgICAgICAgICAgX3RoaXMuX2dldE9yQ3JlYXRlTG9jYWxQcm92aWRlcihwcm92aWRlci5wcm92aWRlclR5cGUsIHByb3ZpZGVyLnRva2VuLCBmYWxzZSk7XG4gICAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFByb3ZpZGVyRWxlbWVudENvbnRleHQucHJvdG90eXBlLCBcInRyYW5zZm9ybVByb3ZpZGVyc1wiLCB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBNYXBXcmFwcGVyLnZhbHVlcyh0aGlzLl90cmFuc2Zvcm1lZFByb3ZpZGVycyk7IH0sXG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFByb3ZpZGVyRWxlbWVudENvbnRleHQucHJvdG90eXBlLCBcInRyYW5zZm9ybWVkRGlyZWN0aXZlQXN0c1wiLCB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHZhciBzb3J0ZWRQcm92aWRlclR5cGVzID0gdGhpcy50cmFuc2Zvcm1Qcm92aWRlcnMubWFwKGZ1bmN0aW9uIChwcm92aWRlcikgeyByZXR1cm4gcHJvdmlkZXIudG9rZW4uaWRlbnRpZmllcjsgfSk7XG4gICAgICAgICAgICAgIHZhciBzb3J0ZWREaXJlY3RpdmVzID0gdGhpcy5fZGlyZWN0aXZlQXN0cy5zbGljZSgpO1xuICAgICAgICAgICAgICBzb3J0ZWREaXJlY3RpdmVzLnNvcnQoZnVuY3Rpb24gKGRpcjEsIGRpcjIpIHsgcmV0dXJuIHNvcnRlZFByb3ZpZGVyVHlwZXMuaW5kZXhPZihkaXIxLmRpcmVjdGl2ZS50eXBlKSAtXG4gICAgICAgICAgICAgICAgICBzb3J0ZWRQcm92aWRlclR5cGVzLmluZGV4T2YoZGlyMi5kaXJlY3RpdmUudHlwZSk7IH0pO1xuICAgICAgICAgICAgICByZXR1cm4gc29ydGVkRGlyZWN0aXZlcztcbiAgICAgICAgICB9LFxuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQcm92aWRlckVsZW1lbnRDb250ZXh0LnByb3RvdHlwZSwgXCJ0cmFuc2Zvcm1lZEhhc1ZpZXdDb250YWluZXJcIiwge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5faGFzVmlld0NvbnRhaW5lcjsgfSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBQcm92aWRlckVsZW1lbnRDb250ZXh0LnByb3RvdHlwZS5fYWRkUXVlcnlSZWFkc1RvID0gZnVuY3Rpb24gKHRva2VuLCBxdWVyeVJlYWRUb2tlbnMpIHtcbiAgICAgICAgICB0aGlzLl9nZXRRdWVyaWVzRm9yKHRva2VuKS5mb3JFYWNoKGZ1bmN0aW9uIChxdWVyeSkge1xuICAgICAgICAgICAgICB2YXIgcXVlcnlSZWFkVG9rZW4gPSBxdWVyeS5yZWFkIHx8IHRva2VuO1xuICAgICAgICAgICAgICBpZiAoaXNCbGFuayhxdWVyeVJlYWRUb2tlbnMuZ2V0KHF1ZXJ5UmVhZFRva2VuLnJlZmVyZW5jZSkpKSB7XG4gICAgICAgICAgICAgICAgICBxdWVyeVJlYWRUb2tlbnMuc2V0KHF1ZXJ5UmVhZFRva2VuLnJlZmVyZW5jZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBQcm92aWRlckVsZW1lbnRDb250ZXh0LnByb3RvdHlwZS5fZ2V0UXVlcmllc0ZvciA9IGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgICB2YXIgY3VycmVudEVsID0gdGhpcztcbiAgICAgICAgICB2YXIgZGlzdGFuY2UgPSAwO1xuICAgICAgICAgIHZhciBxdWVyaWVzO1xuICAgICAgICAgIHdoaWxlIChjdXJyZW50RWwgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcXVlcmllcyA9IGN1cnJlbnRFbC5fY29udGVudFF1ZXJpZXMuZ2V0KHRva2VuLnJlZmVyZW5jZSk7XG4gICAgICAgICAgICAgIGlmIChpc1ByZXNlbnQocXVlcmllcykpIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoLmFwcGx5KHJlc3VsdCwgcXVlcmllcy5maWx0ZXIoZnVuY3Rpb24gKHF1ZXJ5KSB7IHJldHVybiBxdWVyeS5kZXNjZW5kYW50cyB8fCBkaXN0YW5jZSA8PSAxOyB9KSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGN1cnJlbnRFbC5fZGlyZWN0aXZlQXN0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICBkaXN0YW5jZSsrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGN1cnJlbnRFbCA9IGN1cnJlbnRFbC5fcGFyZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgICBxdWVyaWVzID0gdGhpcy52aWV3Q29udGV4dC52aWV3UXVlcmllcy5nZXQodG9rZW4ucmVmZXJlbmNlKTtcbiAgICAgICAgICBpZiAoaXNQcmVzZW50KHF1ZXJpZXMpKSB7XG4gICAgICAgICAgICAgIHJlc3VsdC5wdXNoLmFwcGx5KHJlc3VsdCwgcXVlcmllcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgICAgUHJvdmlkZXJFbGVtZW50Q29udGV4dC5wcm90b3R5cGUuX2dldE9yQ3JlYXRlTG9jYWxQcm92aWRlciA9IGZ1bmN0aW9uIChyZXF1ZXN0aW5nUHJvdmlkZXJUeXBlLCB0b2tlbiwgZWFnZXIpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHZhciByZXNvbHZlZFByb3ZpZGVyID0gdGhpcy5fYWxsUHJvdmlkZXJzLmdldCh0b2tlbi5yZWZlcmVuY2UpO1xuICAgICAgICAgIGlmICghcmVzb2x2ZWRQcm92aWRlciB8fCAoKHJlcXVlc3RpbmdQcm92aWRlclR5cGUgPT09IGV4cG9ydHMuUHJvdmlkZXJBc3RUeXBlLkRpcmVjdGl2ZSB8fFxuICAgICAgICAgICAgICByZXF1ZXN0aW5nUHJvdmlkZXJUeXBlID09PSBleHBvcnRzLlByb3ZpZGVyQXN0VHlwZS5QdWJsaWNTZXJ2aWNlKSAmJlxuICAgICAgICAgICAgICByZXNvbHZlZFByb3ZpZGVyLnByb3ZpZGVyVHlwZSA9PT0gZXhwb3J0cy5Qcm92aWRlckFzdFR5cGUuUHJpdmF0ZVNlcnZpY2UpIHx8XG4gICAgICAgICAgICAgICgocmVxdWVzdGluZ1Byb3ZpZGVyVHlwZSA9PT0gZXhwb3J0cy5Qcm92aWRlckFzdFR5cGUuUHJpdmF0ZVNlcnZpY2UgfHxcbiAgICAgICAgICAgICAgICAgIHJlcXVlc3RpbmdQcm92aWRlclR5cGUgPT09IGV4cG9ydHMuUHJvdmlkZXJBc3RUeXBlLlB1YmxpY1NlcnZpY2UpICYmXG4gICAgICAgICAgICAgICAgICByZXNvbHZlZFByb3ZpZGVyLnByb3ZpZGVyVHlwZSA9PT0gZXhwb3J0cy5Qcm92aWRlckFzdFR5cGUuQnVpbHRpbikpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciB0cmFuc2Zvcm1lZFByb3ZpZGVyQXN0ID0gdGhpcy5fdHJhbnNmb3JtZWRQcm92aWRlcnMuZ2V0KHRva2VuLnJlZmVyZW5jZSk7XG4gICAgICAgICAgaWYgKGlzUHJlc2VudCh0cmFuc2Zvcm1lZFByb3ZpZGVyQXN0KSkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJhbnNmb3JtZWRQcm92aWRlckFzdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLl9zZWVuUHJvdmlkZXJzLmdldCh0b2tlbi5yZWZlcmVuY2UpKSkge1xuICAgICAgICAgICAgICB0aGlzLnZpZXdDb250ZXh0LmVycm9ycy5wdXNoKG5ldyBQcm92aWRlckVycm9yKFwiQ2Fubm90IGluc3RhbnRpYXRlIGN5Y2xpYyBkZXBlbmRlbmN5ISBcIiArIHRva2VuLm5hbWUsIHRoaXMuX3NvdXJjZVNwYW4pKTtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX3NlZW5Qcm92aWRlcnMuc2V0KHRva2VuLnJlZmVyZW5jZSwgdHJ1ZSk7XG4gICAgICAgICAgdmFyIHRyYW5zZm9ybWVkUHJvdmlkZXJzID0gcmVzb2x2ZWRQcm92aWRlci5wcm92aWRlcnMubWFwKGZ1bmN0aW9uIChwcm92aWRlcikge1xuICAgICAgICAgICAgICB2YXIgdHJhbnNmb3JtZWRVc2VWYWx1ZSA9IHByb3ZpZGVyLnVzZVZhbHVlO1xuICAgICAgICAgICAgICB2YXIgdHJhbnNmb3JtZWRVc2VFeGlzdGluZyA9IHByb3ZpZGVyLnVzZUV4aXN0aW5nO1xuICAgICAgICAgICAgICB2YXIgdHJhbnNmb3JtZWREZXBzO1xuICAgICAgICAgICAgICBpZiAoaXNQcmVzZW50KHByb3ZpZGVyLnVzZUV4aXN0aW5nKSkge1xuICAgICAgICAgICAgICAgICAgdmFyIGV4aXN0aW5nRGlEZXAgPSBfdGhpcy5fZ2V0RGVwZW5kZW5jeShyZXNvbHZlZFByb3ZpZGVyLnByb3ZpZGVyVHlwZSwgbmV3IENvbXBpbGVEaURlcGVuZGVuY3lNZXRhZGF0YSh7IHRva2VuOiBwcm92aWRlci51c2VFeGlzdGluZyB9KSwgZWFnZXIpO1xuICAgICAgICAgICAgICAgICAgaWYgKGlzUHJlc2VudChleGlzdGluZ0RpRGVwLnRva2VuKSkge1xuICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybWVkVXNlRXhpc3RpbmcgPSBleGlzdGluZ0RpRGVwLnRva2VuO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtZWRVc2VFeGlzdGluZyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtZWRVc2VWYWx1ZSA9IGV4aXN0aW5nRGlEZXAudmFsdWU7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSBpZiAoaXNQcmVzZW50KHByb3ZpZGVyLnVzZUZhY3RvcnkpKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgZGVwcyA9IHByb3ZpZGVyLmRlcHMgfHwgcHJvdmlkZXIudXNlRmFjdG9yeS5kaURlcHM7XG4gICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1lZERlcHMgPVxuICAgICAgICAgICAgICAgICAgICAgIGRlcHMubWFwKGZ1bmN0aW9uIChkZXApIHsgcmV0dXJuIF90aGlzLl9nZXREZXBlbmRlbmN5KHJlc29sdmVkUHJvdmlkZXIucHJvdmlkZXJUeXBlLCBkZXAsIGVhZ2VyKTsgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSBpZiAoaXNQcmVzZW50KHByb3ZpZGVyLnVzZUNsYXNzKSkge1xuICAgICAgICAgICAgICAgICAgdmFyIGRlcHMgPSBwcm92aWRlci5kZXBzIHx8IHByb3ZpZGVyLnVzZUNsYXNzLmRpRGVwcztcbiAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybWVkRGVwcyA9XG4gICAgICAgICAgICAgICAgICAgICAgZGVwcy5tYXAoZnVuY3Rpb24gKGRlcCkgeyByZXR1cm4gX3RoaXMuX2dldERlcGVuZGVuY3kocmVzb2x2ZWRQcm92aWRlci5wcm92aWRlclR5cGUsIGRlcCwgZWFnZXIpOyB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gX3RyYW5zZm9ybVByb3ZpZGVyKHByb3ZpZGVyLCB7XG4gICAgICAgICAgICAgICAgICB1c2VFeGlzdGluZzogdHJhbnNmb3JtZWRVc2VFeGlzdGluZyxcbiAgICAgICAgICAgICAgICAgIHVzZVZhbHVlOiB0cmFuc2Zvcm1lZFVzZVZhbHVlLFxuICAgICAgICAgICAgICAgICAgZGVwczogdHJhbnNmb3JtZWREZXBzXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRyYW5zZm9ybWVkUHJvdmlkZXJBc3QgPVxuICAgICAgICAgICAgICBfdHJhbnNmb3JtUHJvdmlkZXJBc3QocmVzb2x2ZWRQcm92aWRlciwgeyBlYWdlcjogZWFnZXIsIHByb3ZpZGVyczogdHJhbnNmb3JtZWRQcm92aWRlcnMgfSk7XG4gICAgICAgICAgdGhpcy5fdHJhbnNmb3JtZWRQcm92aWRlcnMuc2V0KHRva2VuLnJlZmVyZW5jZSwgdHJhbnNmb3JtZWRQcm92aWRlckFzdCk7XG4gICAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWVkUHJvdmlkZXJBc3Q7XG4gICAgICB9O1xuICAgICAgUHJvdmlkZXJFbGVtZW50Q29udGV4dC5wcm90b3R5cGUuX2dldExvY2FsRGVwZW5kZW5jeSA9IGZ1bmN0aW9uIChyZXF1ZXN0aW5nUHJvdmlkZXJUeXBlLCBkZXAsIGVhZ2VyKSB7XG4gICAgICAgICAgaWYgKGVhZ2VyID09PSB2b2lkIDApIHsgZWFnZXIgPSBudWxsOyB9XG4gICAgICAgICAgaWYgKGRlcC5pc0F0dHJpYnV0ZSkge1xuICAgICAgICAgICAgICB2YXIgYXR0clZhbHVlID0gdGhpcy5fYXR0cnNbZGVwLnRva2VuLnZhbHVlXTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb21waWxlRGlEZXBlbmRlbmN5TWV0YWRhdGEoeyBpc1ZhbHVlOiB0cnVlLCB2YWx1ZTogYXR0clZhbHVlID09IG51bGwgPyBudWxsIDogYXR0clZhbHVlIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNQcmVzZW50KGRlcC5xdWVyeSkgfHwgaXNQcmVzZW50KGRlcC52aWV3UXVlcnkpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBkZXA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc1ByZXNlbnQoZGVwLnRva2VuKSkge1xuICAgICAgICAgICAgICAvLyBhY2Nlc3MgYnVpbHRpbnRzXG4gICAgICAgICAgICAgIGlmICgocmVxdWVzdGluZ1Byb3ZpZGVyVHlwZSA9PT0gZXhwb3J0cy5Qcm92aWRlckFzdFR5cGUuRGlyZWN0aXZlIHx8XG4gICAgICAgICAgICAgICAgICByZXF1ZXN0aW5nUHJvdmlkZXJUeXBlID09PSBleHBvcnRzLlByb3ZpZGVyQXN0VHlwZS5Db21wb25lbnQpKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoZGVwLnRva2VuLnJlZmVyZW5jZSA9PT0gcmVzb2x2ZUlkZW50aWZpZXJUb2tlbihJZGVudGlmaWVycy5SZW5kZXJlcikucmVmZXJlbmNlIHx8XG4gICAgICAgICAgICAgICAgICAgICAgZGVwLnRva2VuLnJlZmVyZW5jZSA9PT0gcmVzb2x2ZUlkZW50aWZpZXJUb2tlbihJZGVudGlmaWVycy5FbGVtZW50UmVmKS5yZWZlcmVuY2UgfHxcbiAgICAgICAgICAgICAgICAgICAgICBkZXAudG9rZW4ucmVmZXJlbmNlID09PVxuICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlSWRlbnRpZmllclRva2VuKElkZW50aWZpZXJzLkNoYW5nZURldGVjdG9yUmVmKS5yZWZlcmVuY2UgfHxcbiAgICAgICAgICAgICAgICAgICAgICBkZXAudG9rZW4ucmVmZXJlbmNlID09PSByZXNvbHZlSWRlbnRpZmllclRva2VuKElkZW50aWZpZXJzLlRlbXBsYXRlUmVmKS5yZWZlcmVuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVwO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKGRlcC50b2tlbi5yZWZlcmVuY2UgPT09XG4gICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZUlkZW50aWZpZXJUb2tlbihJZGVudGlmaWVycy5WaWV3Q29udGFpbmVyUmVmKS5yZWZlcmVuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9oYXNWaWV3Q29udGFpbmVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBhY2Nlc3MgdGhlIGluamVjdG9yXG4gICAgICAgICAgICAgIGlmIChkZXAudG9rZW4ucmVmZXJlbmNlID09PSByZXNvbHZlSWRlbnRpZmllclRva2VuKElkZW50aWZpZXJzLkluamVjdG9yKS5yZWZlcmVuY2UpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBkZXA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gYWNjZXNzIHByb3ZpZGVyc1xuICAgICAgICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuX2dldE9yQ3JlYXRlTG9jYWxQcm92aWRlcihyZXF1ZXN0aW5nUHJvdmlkZXJUeXBlLCBkZXAudG9rZW4sIGVhZ2VyKSkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBkZXA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgUHJvdmlkZXJFbGVtZW50Q29udGV4dC5wcm90b3R5cGUuX2dldERlcGVuZGVuY3kgPSBmdW5jdGlvbiAocmVxdWVzdGluZ1Byb3ZpZGVyVHlwZSwgZGVwLCBlYWdlcikge1xuICAgICAgICAgIGlmIChlYWdlciA9PT0gdm9pZCAwKSB7IGVhZ2VyID0gbnVsbDsgfVxuICAgICAgICAgIHZhciBjdXJyRWxlbWVudCA9IHRoaXM7XG4gICAgICAgICAgdmFyIGN1cnJFYWdlciA9IGVhZ2VyO1xuICAgICAgICAgIHZhciByZXN1bHQgPSBudWxsO1xuICAgICAgICAgIGlmICghZGVwLmlzU2tpcFNlbGYpIHtcbiAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5fZ2V0TG9jYWxEZXBlbmRlbmN5KHJlcXVlc3RpbmdQcm92aWRlclR5cGUsIGRlcCwgZWFnZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZGVwLmlzU2VsZikge1xuICAgICAgICAgICAgICBpZiAoIXJlc3VsdCAmJiBkZXAuaXNPcHRpb25hbCkge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IENvbXBpbGVEaURlcGVuZGVuY3lNZXRhZGF0YSh7IGlzVmFsdWU6IHRydWUsIHZhbHVlOiBudWxsIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAvLyBjaGVjayBwYXJlbnQgZWxlbWVudHNcbiAgICAgICAgICAgICAgd2hpbGUgKCFyZXN1bHQgJiYgaXNQcmVzZW50KGN1cnJFbGVtZW50Ll9wYXJlbnQpKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgcHJldkVsZW1lbnQgPSBjdXJyRWxlbWVudDtcbiAgICAgICAgICAgICAgICAgIGN1cnJFbGVtZW50ID0gY3VyckVsZW1lbnQuX3BhcmVudDtcbiAgICAgICAgICAgICAgICAgIGlmIChwcmV2RWxlbWVudC5faXNWaWV3Um9vdCkge1xuICAgICAgICAgICAgICAgICAgICAgIGN1cnJFYWdlciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gY3VyckVsZW1lbnQuX2dldExvY2FsRGVwZW5kZW5jeShleHBvcnRzLlByb3ZpZGVyQXN0VHlwZS5QdWJsaWNTZXJ2aWNlLCBkZXAsIGN1cnJFYWdlcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gY2hlY2sgQEhvc3QgcmVzdHJpY3Rpb25cbiAgICAgICAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgIGlmICghZGVwLmlzSG9zdCB8fCB0aGlzLnZpZXdDb250ZXh0LmNvbXBvbmVudC50eXBlLmlzSG9zdCB8fFxuICAgICAgICAgICAgICAgICAgICAgIHRoaXMudmlld0NvbnRleHQuY29tcG9uZW50LnR5cGUucmVmZXJlbmNlID09PSBkZXAudG9rZW4ucmVmZXJlbmNlIHx8XG4gICAgICAgICAgICAgICAgICAgICAgaXNQcmVzZW50KHRoaXMudmlld0NvbnRleHQudmlld1Byb3ZpZGVycy5nZXQoZGVwLnRva2VuLnJlZmVyZW5jZSkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gZGVwO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gZGVwLmlzT3B0aW9uYWwgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgQ29tcGlsZURpRGVwZW5kZW5jeU1ldGFkYXRhKHsgaXNWYWx1ZTogdHJ1ZSwgdmFsdWU6IG51bGwgfSkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICBudWxsO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICAgIHRoaXMudmlld0NvbnRleHQuZXJyb3JzLnB1c2gobmV3IFByb3ZpZGVyRXJyb3IoXCJObyBwcm92aWRlciBmb3IgXCIgKyBkZXAudG9rZW4ubmFtZSwgdGhpcy5fc291cmNlU3BhbikpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICAgIHJldHVybiBQcm92aWRlckVsZW1lbnRDb250ZXh0O1xuICB9KCkpO1xuICB2YXIgTmdNb2R1bGVQcm92aWRlckFuYWx5emVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIE5nTW9kdWxlUHJvdmlkZXJBbmFseXplcihuZ01vZHVsZSwgZXh0cmFQcm92aWRlcnMsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHRoaXMuX3RyYW5zZm9ybWVkUHJvdmlkZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICAgIHRoaXMuX3NlZW5Qcm92aWRlcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgdGhpcy5fZXJyb3JzID0gW107XG4gICAgICAgICAgdGhpcy5fYWxsUHJvdmlkZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICAgIHZhciBuZ01vZHVsZVR5cGVzID0gbmdNb2R1bGUudHJhbnNpdGl2ZU1vZHVsZS5tb2R1bGVzLm1hcChmdW5jdGlvbiAobW9kdWxlTWV0YSkgeyByZXR1cm4gbW9kdWxlTWV0YS50eXBlOyB9KTtcbiAgICAgICAgICBuZ01vZHVsZVR5cGVzLmZvckVhY2goZnVuY3Rpb24gKG5nTW9kdWxlVHlwZSkge1xuICAgICAgICAgICAgICB2YXIgbmdNb2R1bGVQcm92aWRlciA9IG5ldyBDb21waWxlUHJvdmlkZXJNZXRhZGF0YSh7IHRva2VuOiBuZXcgQ29tcGlsZVRva2VuTWV0YWRhdGEoeyBpZGVudGlmaWVyOiBuZ01vZHVsZVR5cGUgfSksIHVzZUNsYXNzOiBuZ01vZHVsZVR5cGUgfSk7XG4gICAgICAgICAgICAgIF9yZXNvbHZlUHJvdmlkZXJzKFtuZ01vZHVsZVByb3ZpZGVyXSwgZXhwb3J0cy5Qcm92aWRlckFzdFR5cGUuUHVibGljU2VydmljZSwgdHJ1ZSwgc291cmNlU3BhbiwgX3RoaXMuX2Vycm9ycywgX3RoaXMuX2FsbFByb3ZpZGVycyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgX3Jlc29sdmVQcm92aWRlcnMoX25vcm1hbGl6ZVByb3ZpZGVycyhuZ01vZHVsZS50cmFuc2l0aXZlTW9kdWxlLnByb3ZpZGVycy5jb25jYXQoZXh0cmFQcm92aWRlcnMpLCBzb3VyY2VTcGFuLCB0aGlzLl9lcnJvcnMpLCBleHBvcnRzLlByb3ZpZGVyQXN0VHlwZS5QdWJsaWNTZXJ2aWNlLCBmYWxzZSwgc291cmNlU3BhbiwgdGhpcy5fZXJyb3JzLCB0aGlzLl9hbGxQcm92aWRlcnMpO1xuICAgICAgfVxuICAgICAgTmdNb2R1bGVQcm92aWRlckFuYWx5emVyLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIE1hcFdyYXBwZXIudmFsdWVzKHRoaXMuX2FsbFByb3ZpZGVycykuZm9yRWFjaChmdW5jdGlvbiAocHJvdmlkZXIpIHtcbiAgICAgICAgICAgICAgX3RoaXMuX2dldE9yQ3JlYXRlTG9jYWxQcm92aWRlcihwcm92aWRlci50b2tlbiwgcHJvdmlkZXIuZWFnZXIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmICh0aGlzLl9lcnJvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICB2YXIgZXJyb3JTdHJpbmcgPSB0aGlzLl9lcnJvcnMuam9pbignXFxuJyk7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlByb3ZpZGVyIHBhcnNlIGVycm9yczpcXG5cIiArIGVycm9yU3RyaW5nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIE1hcFdyYXBwZXIudmFsdWVzKHRoaXMuX3RyYW5zZm9ybWVkUHJvdmlkZXJzKTtcbiAgICAgIH07XG4gICAgICBOZ01vZHVsZVByb3ZpZGVyQW5hbHl6ZXIucHJvdG90eXBlLl9nZXRPckNyZWF0ZUxvY2FsUHJvdmlkZXIgPSBmdW5jdGlvbiAodG9rZW4sIGVhZ2VyKSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICB2YXIgcmVzb2x2ZWRQcm92aWRlciA9IHRoaXMuX2FsbFByb3ZpZGVycy5nZXQodG9rZW4ucmVmZXJlbmNlKTtcbiAgICAgICAgICBpZiAoIXJlc29sdmVkUHJvdmlkZXIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciB0cmFuc2Zvcm1lZFByb3ZpZGVyQXN0ID0gdGhpcy5fdHJhbnNmb3JtZWRQcm92aWRlcnMuZ2V0KHRva2VuLnJlZmVyZW5jZSk7XG4gICAgICAgICAgaWYgKGlzUHJlc2VudCh0cmFuc2Zvcm1lZFByb3ZpZGVyQXN0KSkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJhbnNmb3JtZWRQcm92aWRlckFzdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLl9zZWVuUHJvdmlkZXJzLmdldCh0b2tlbi5yZWZlcmVuY2UpKSkge1xuICAgICAgICAgICAgICB0aGlzLl9lcnJvcnMucHVzaChuZXcgUHJvdmlkZXJFcnJvcihcIkNhbm5vdCBpbnN0YW50aWF0ZSBjeWNsaWMgZGVwZW5kZW5jeSEgXCIgKyB0b2tlbi5uYW1lLCByZXNvbHZlZFByb3ZpZGVyLnNvdXJjZVNwYW4pKTtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX3NlZW5Qcm92aWRlcnMuc2V0KHRva2VuLnJlZmVyZW5jZSwgdHJ1ZSk7XG4gICAgICAgICAgdmFyIHRyYW5zZm9ybWVkUHJvdmlkZXJzID0gcmVzb2x2ZWRQcm92aWRlci5wcm92aWRlcnMubWFwKGZ1bmN0aW9uIChwcm92aWRlcikge1xuICAgICAgICAgICAgICB2YXIgdHJhbnNmb3JtZWRVc2VWYWx1ZSA9IHByb3ZpZGVyLnVzZVZhbHVlO1xuICAgICAgICAgICAgICB2YXIgdHJhbnNmb3JtZWRVc2VFeGlzdGluZyA9IHByb3ZpZGVyLnVzZUV4aXN0aW5nO1xuICAgICAgICAgICAgICB2YXIgdHJhbnNmb3JtZWREZXBzO1xuICAgICAgICAgICAgICBpZiAoaXNQcmVzZW50KHByb3ZpZGVyLnVzZUV4aXN0aW5nKSkge1xuICAgICAgICAgICAgICAgICAgdmFyIGV4aXN0aW5nRGlEZXAgPSBfdGhpcy5fZ2V0RGVwZW5kZW5jeShuZXcgQ29tcGlsZURpRGVwZW5kZW5jeU1ldGFkYXRhKHsgdG9rZW46IHByb3ZpZGVyLnVzZUV4aXN0aW5nIH0pLCBlYWdlciwgcmVzb2x2ZWRQcm92aWRlci5zb3VyY2VTcGFuKTtcbiAgICAgICAgICAgICAgICAgIGlmIChpc1ByZXNlbnQoZXhpc3RpbmdEaURlcC50b2tlbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1lZFVzZUV4aXN0aW5nID0gZXhpc3RpbmdEaURlcC50b2tlbjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybWVkVXNlRXhpc3RpbmcgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybWVkVXNlVmFsdWUgPSBleGlzdGluZ0RpRGVwLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgaWYgKGlzUHJlc2VudChwcm92aWRlci51c2VGYWN0b3J5KSkge1xuICAgICAgICAgICAgICAgICAgdmFyIGRlcHMgPSBwcm92aWRlci5kZXBzIHx8IHByb3ZpZGVyLnVzZUZhY3RvcnkuZGlEZXBzO1xuICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtZWREZXBzID1cbiAgICAgICAgICAgICAgICAgICAgICBkZXBzLm1hcChmdW5jdGlvbiAoZGVwKSB7IHJldHVybiBfdGhpcy5fZ2V0RGVwZW5kZW5jeShkZXAsIGVhZ2VyLCByZXNvbHZlZFByb3ZpZGVyLnNvdXJjZVNwYW4pOyB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIGlmIChpc1ByZXNlbnQocHJvdmlkZXIudXNlQ2xhc3MpKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgZGVwcyA9IHByb3ZpZGVyLmRlcHMgfHwgcHJvdmlkZXIudXNlQ2xhc3MuZGlEZXBzO1xuICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtZWREZXBzID1cbiAgICAgICAgICAgICAgICAgICAgICBkZXBzLm1hcChmdW5jdGlvbiAoZGVwKSB7IHJldHVybiBfdGhpcy5fZ2V0RGVwZW5kZW5jeShkZXAsIGVhZ2VyLCByZXNvbHZlZFByb3ZpZGVyLnNvdXJjZVNwYW4pOyB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gX3RyYW5zZm9ybVByb3ZpZGVyKHByb3ZpZGVyLCB7XG4gICAgICAgICAgICAgICAgICB1c2VFeGlzdGluZzogdHJhbnNmb3JtZWRVc2VFeGlzdGluZyxcbiAgICAgICAgICAgICAgICAgIHVzZVZhbHVlOiB0cmFuc2Zvcm1lZFVzZVZhbHVlLFxuICAgICAgICAgICAgICAgICAgZGVwczogdHJhbnNmb3JtZWREZXBzXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRyYW5zZm9ybWVkUHJvdmlkZXJBc3QgPVxuICAgICAgICAgICAgICBfdHJhbnNmb3JtUHJvdmlkZXJBc3QocmVzb2x2ZWRQcm92aWRlciwgeyBlYWdlcjogZWFnZXIsIHByb3ZpZGVyczogdHJhbnNmb3JtZWRQcm92aWRlcnMgfSk7XG4gICAgICAgICAgdGhpcy5fdHJhbnNmb3JtZWRQcm92aWRlcnMuc2V0KHRva2VuLnJlZmVyZW5jZSwgdHJhbnNmb3JtZWRQcm92aWRlckFzdCk7XG4gICAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWVkUHJvdmlkZXJBc3Q7XG4gICAgICB9O1xuICAgICAgTmdNb2R1bGVQcm92aWRlckFuYWx5emVyLnByb3RvdHlwZS5fZ2V0RGVwZW5kZW5jeSA9IGZ1bmN0aW9uIChkZXAsIGVhZ2VyLCByZXF1ZXN0b3JTb3VyY2VTcGFuKSB7XG4gICAgICAgICAgaWYgKGVhZ2VyID09PSB2b2lkIDApIHsgZWFnZXIgPSBudWxsOyB9XG4gICAgICAgICAgdmFyIGZvdW5kTG9jYWwgPSBmYWxzZTtcbiAgICAgICAgICBpZiAoIWRlcC5pc1NraXBTZWxmICYmIGlzUHJlc2VudChkZXAudG9rZW4pKSB7XG4gICAgICAgICAgICAgIC8vIGFjY2VzcyB0aGUgaW5qZWN0b3JcbiAgICAgICAgICAgICAgaWYgKGRlcC50b2tlbi5yZWZlcmVuY2UgPT09IHJlc29sdmVJZGVudGlmaWVyVG9rZW4oSWRlbnRpZmllcnMuSW5qZWN0b3IpLnJlZmVyZW5jZSB8fFxuICAgICAgICAgICAgICAgICAgZGVwLnRva2VuLnJlZmVyZW5jZSA9PT1cbiAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlSWRlbnRpZmllclRva2VuKElkZW50aWZpZXJzLkNvbXBvbmVudEZhY3RvcnlSZXNvbHZlcikucmVmZXJlbmNlKSB7XG4gICAgICAgICAgICAgICAgICBmb3VuZExvY2FsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIGlmIChpc1ByZXNlbnQodGhpcy5fZ2V0T3JDcmVhdGVMb2NhbFByb3ZpZGVyKGRlcC50b2tlbiwgZWFnZXIpKSkge1xuICAgICAgICAgICAgICAgICAgZm91bmRMb2NhbCA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IGRlcDtcbiAgICAgICAgICBpZiAoZGVwLmlzU2VsZiAmJiAhZm91bmRMb2NhbCkge1xuICAgICAgICAgICAgICBpZiAoZGVwLmlzT3B0aW9uYWwpIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBDb21waWxlRGlEZXBlbmRlbmN5TWV0YWRhdGEoeyBpc1ZhbHVlOiB0cnVlLCB2YWx1ZTogbnVsbCB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2Vycm9ycy5wdXNoKG5ldyBQcm92aWRlckVycm9yKFwiTm8gcHJvdmlkZXIgZm9yIFwiICsgZGVwLnRva2VuLm5hbWUsIHJlcXVlc3RvclNvdXJjZVNwYW4pKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICAgIHJldHVybiBOZ01vZHVsZVByb3ZpZGVyQW5hbHl6ZXI7XG4gIH0oKSk7XG4gIGZ1bmN0aW9uIF90cmFuc2Zvcm1Qcm92aWRlcihwcm92aWRlciwgX2EpIHtcbiAgICAgIHZhciB1c2VFeGlzdGluZyA9IF9hLnVzZUV4aXN0aW5nLCB1c2VWYWx1ZSA9IF9hLnVzZVZhbHVlLCBkZXBzID0gX2EuZGVwcztcbiAgICAgIHJldHVybiBuZXcgQ29tcGlsZVByb3ZpZGVyTWV0YWRhdGEoe1xuICAgICAgICAgIHRva2VuOiBwcm92aWRlci50b2tlbixcbiAgICAgICAgICB1c2VDbGFzczogcHJvdmlkZXIudXNlQ2xhc3MsXG4gICAgICAgICAgdXNlRXhpc3Rpbmc6IHVzZUV4aXN0aW5nLFxuICAgICAgICAgIHVzZUZhY3Rvcnk6IHByb3ZpZGVyLnVzZUZhY3RvcnksXG4gICAgICAgICAgdXNlVmFsdWU6IHVzZVZhbHVlLFxuICAgICAgICAgIGRlcHM6IGRlcHMsXG4gICAgICAgICAgbXVsdGk6IHByb3ZpZGVyLm11bHRpXG4gICAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBfdHJhbnNmb3JtUHJvdmlkZXJBc3QocHJvdmlkZXIsIF9hKSB7XG4gICAgICB2YXIgZWFnZXIgPSBfYS5lYWdlciwgcHJvdmlkZXJzID0gX2EucHJvdmlkZXJzO1xuICAgICAgcmV0dXJuIG5ldyBQcm92aWRlckFzdChwcm92aWRlci50b2tlbiwgcHJvdmlkZXIubXVsdGlQcm92aWRlciwgcHJvdmlkZXIuZWFnZXIgfHwgZWFnZXIsIHByb3ZpZGVycywgcHJvdmlkZXIucHJvdmlkZXJUeXBlLCBwcm92aWRlci5saWZlY3ljbGVIb29rcywgcHJvdmlkZXIuc291cmNlU3Bhbik7XG4gIH1cbiAgZnVuY3Rpb24gX25vcm1hbGl6ZVByb3ZpZGVycyhwcm92aWRlcnMsIHNvdXJjZVNwYW4sIHRhcmdldEVycm9ycywgdGFyZ2V0UHJvdmlkZXJzKSB7XG4gICAgICBpZiAodGFyZ2V0UHJvdmlkZXJzID09PSB2b2lkIDApIHsgdGFyZ2V0UHJvdmlkZXJzID0gbnVsbDsgfVxuICAgICAgaWYgKCF0YXJnZXRQcm92aWRlcnMpIHtcbiAgICAgICAgICB0YXJnZXRQcm92aWRlcnMgPSBbXTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1ByZXNlbnQocHJvdmlkZXJzKSkge1xuICAgICAgICAgIHByb3ZpZGVycy5mb3JFYWNoKGZ1bmN0aW9uIChwcm92aWRlcikge1xuICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwcm92aWRlcikpIHtcbiAgICAgICAgICAgICAgICAgIF9ub3JtYWxpemVQcm92aWRlcnMocHJvdmlkZXIsIHNvdXJjZVNwYW4sIHRhcmdldEVycm9ycywgdGFyZ2V0UHJvdmlkZXJzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHZhciBub3JtYWxpemVQcm92aWRlciA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgIGlmIChwcm92aWRlciBpbnN0YW5jZW9mIENvbXBpbGVQcm92aWRlck1ldGFkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgbm9ybWFsaXplUHJvdmlkZXIgPSBwcm92aWRlcjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHByb3ZpZGVyIGluc3RhbmNlb2YgQ29tcGlsZVR5cGVNZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbGl6ZVByb3ZpZGVyID0gbmV3IENvbXBpbGVQcm92aWRlck1ldGFkYXRhKHsgdG9rZW46IG5ldyBDb21waWxlVG9rZW5NZXRhZGF0YSh7IGlkZW50aWZpZXI6IHByb3ZpZGVyIH0pLCB1c2VDbGFzczogcHJvdmlkZXIgfSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRFcnJvcnMucHVzaChuZXcgUHJvdmlkZXJFcnJvcihcIlVua25vd24gcHJvdmlkZXIgdHlwZSBcIiArIHByb3ZpZGVyLCBzb3VyY2VTcGFuKSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAoaXNQcmVzZW50KG5vcm1hbGl6ZVByb3ZpZGVyKSkge1xuICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFByb3ZpZGVycy5wdXNoKG5vcm1hbGl6ZVByb3ZpZGVyKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRhcmdldFByb3ZpZGVycztcbiAgfVxuICBmdW5jdGlvbiBfcmVzb2x2ZVByb3ZpZGVyc0Zyb21EaXJlY3RpdmVzKGRpcmVjdGl2ZXMsIHNvdXJjZVNwYW4sIHRhcmdldEVycm9ycykge1xuICAgICAgdmFyIHByb3ZpZGVyc0J5VG9rZW4gPSBuZXcgTWFwKCk7XG4gICAgICBkaXJlY3RpdmVzLmZvckVhY2goZnVuY3Rpb24gKGRpcmVjdGl2ZSkge1xuICAgICAgICAgIHZhciBkaXJQcm92aWRlciA9IG5ldyBDb21waWxlUHJvdmlkZXJNZXRhZGF0YSh7IHRva2VuOiBuZXcgQ29tcGlsZVRva2VuTWV0YWRhdGEoeyBpZGVudGlmaWVyOiBkaXJlY3RpdmUudHlwZSB9KSwgdXNlQ2xhc3M6IGRpcmVjdGl2ZS50eXBlIH0pO1xuICAgICAgICAgIF9yZXNvbHZlUHJvdmlkZXJzKFtkaXJQcm92aWRlcl0sIGRpcmVjdGl2ZS5pc0NvbXBvbmVudCA/IGV4cG9ydHMuUHJvdmlkZXJBc3RUeXBlLkNvbXBvbmVudCA6IGV4cG9ydHMuUHJvdmlkZXJBc3RUeXBlLkRpcmVjdGl2ZSwgdHJ1ZSwgc291cmNlU3BhbiwgdGFyZ2V0RXJyb3JzLCBwcm92aWRlcnNCeVRva2VuKTtcbiAgICAgIH0pO1xuICAgICAgLy8gTm90ZTogZGlyZWN0aXZlcyBuZWVkIHRvIGJlIGFibGUgdG8gb3ZlcndyaXRlIHByb3ZpZGVycyBvZiBhIGNvbXBvbmVudCFcbiAgICAgIHZhciBkaXJlY3RpdmVzV2l0aENvbXBvbmVudEZpcnN0ID0gZGlyZWN0aXZlcy5maWx0ZXIoZnVuY3Rpb24gKGRpcikgeyByZXR1cm4gZGlyLmlzQ29tcG9uZW50OyB9KS5jb25jYXQoZGlyZWN0aXZlcy5maWx0ZXIoZnVuY3Rpb24gKGRpcikgeyByZXR1cm4gIWRpci5pc0NvbXBvbmVudDsgfSkpO1xuICAgICAgZGlyZWN0aXZlc1dpdGhDb21wb25lbnRGaXJzdC5mb3JFYWNoKGZ1bmN0aW9uIChkaXJlY3RpdmUpIHtcbiAgICAgICAgICBfcmVzb2x2ZVByb3ZpZGVycyhfbm9ybWFsaXplUHJvdmlkZXJzKGRpcmVjdGl2ZS5wcm92aWRlcnMsIHNvdXJjZVNwYW4sIHRhcmdldEVycm9ycyksIGV4cG9ydHMuUHJvdmlkZXJBc3RUeXBlLlB1YmxpY1NlcnZpY2UsIGZhbHNlLCBzb3VyY2VTcGFuLCB0YXJnZXRFcnJvcnMsIHByb3ZpZGVyc0J5VG9rZW4pO1xuICAgICAgICAgIF9yZXNvbHZlUHJvdmlkZXJzKF9ub3JtYWxpemVQcm92aWRlcnMoZGlyZWN0aXZlLnZpZXdQcm92aWRlcnMsIHNvdXJjZVNwYW4sIHRhcmdldEVycm9ycyksIGV4cG9ydHMuUHJvdmlkZXJBc3RUeXBlLlByaXZhdGVTZXJ2aWNlLCBmYWxzZSwgc291cmNlU3BhbiwgdGFyZ2V0RXJyb3JzLCBwcm92aWRlcnNCeVRva2VuKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHByb3ZpZGVyc0J5VG9rZW47XG4gIH1cbiAgZnVuY3Rpb24gX3Jlc29sdmVQcm92aWRlcnMocHJvdmlkZXJzLCBwcm92aWRlclR5cGUsIGVhZ2VyLCBzb3VyY2VTcGFuLCB0YXJnZXRFcnJvcnMsIHRhcmdldFByb3ZpZGVyc0J5VG9rZW4pIHtcbiAgICAgIHByb3ZpZGVycy5mb3JFYWNoKGZ1bmN0aW9uIChwcm92aWRlcikge1xuICAgICAgICAgIHZhciByZXNvbHZlZFByb3ZpZGVyID0gdGFyZ2V0UHJvdmlkZXJzQnlUb2tlbi5nZXQocHJvdmlkZXIudG9rZW4ucmVmZXJlbmNlKTtcbiAgICAgICAgICBpZiAoaXNQcmVzZW50KHJlc29sdmVkUHJvdmlkZXIpICYmIHJlc29sdmVkUHJvdmlkZXIubXVsdGlQcm92aWRlciAhPT0gcHJvdmlkZXIubXVsdGkpIHtcbiAgICAgICAgICAgICAgdGFyZ2V0RXJyb3JzLnB1c2gobmV3IFByb3ZpZGVyRXJyb3IoXCJNaXhpbmcgbXVsdGkgYW5kIG5vbiBtdWx0aSBwcm92aWRlciBpcyBub3QgcG9zc2libGUgZm9yIHRva2VuIFwiICsgcmVzb2x2ZWRQcm92aWRlci50b2tlbi5uYW1lLCBzb3VyY2VTcGFuKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghcmVzb2x2ZWRQcm92aWRlcikge1xuICAgICAgICAgICAgICB2YXIgbGlmZWN5Y2xlSG9va3MgPSBwcm92aWRlci50b2tlbi5pZGVudGlmaWVyICYmIHByb3ZpZGVyLnRva2VuLmlkZW50aWZpZXIgaW5zdGFuY2VvZiBDb21waWxlVHlwZU1ldGFkYXRhID9cbiAgICAgICAgICAgICAgICAgIHByb3ZpZGVyLnRva2VuLmlkZW50aWZpZXIubGlmZWN5Y2xlSG9va3MgOlxuICAgICAgICAgICAgICAgICAgW107XG4gICAgICAgICAgICAgIHJlc29sdmVkUHJvdmlkZXIgPSBuZXcgUHJvdmlkZXJBc3QocHJvdmlkZXIudG9rZW4sIHByb3ZpZGVyLm11bHRpLCBlYWdlciB8fCBsaWZlY3ljbGVIb29rcy5sZW5ndGggPiAwLCBbcHJvdmlkZXJdLCBwcm92aWRlclR5cGUsIGxpZmVjeWNsZUhvb2tzLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICAgICAgdGFyZ2V0UHJvdmlkZXJzQnlUb2tlbi5zZXQocHJvdmlkZXIudG9rZW4ucmVmZXJlbmNlLCByZXNvbHZlZFByb3ZpZGVyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGlmICghcHJvdmlkZXIubXVsdGkpIHtcbiAgICAgICAgICAgICAgICAgIHJlc29sdmVkUHJvdmlkZXIucHJvdmlkZXJzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVzb2x2ZWRQcm92aWRlci5wcm92aWRlcnMucHVzaChwcm92aWRlcik7XG4gICAgICAgICAgfVxuICAgICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gX2dldFZpZXdRdWVyaWVzKGNvbXBvbmVudCkge1xuICAgICAgdmFyIHZpZXdRdWVyaWVzID0gbmV3IE1hcCgpO1xuICAgICAgaWYgKGlzUHJlc2VudChjb21wb25lbnQudmlld1F1ZXJpZXMpKSB7XG4gICAgICAgICAgY29tcG9uZW50LnZpZXdRdWVyaWVzLmZvckVhY2goZnVuY3Rpb24gKHF1ZXJ5KSB7IHJldHVybiBfYWRkUXVlcnlUb1Rva2VuTWFwKHZpZXdRdWVyaWVzLCBxdWVyeSk7IH0pO1xuICAgICAgfVxuICAgICAgY29tcG9uZW50LnR5cGUuZGlEZXBzLmZvckVhY2goZnVuY3Rpb24gKGRlcCkge1xuICAgICAgICAgIGlmIChpc1ByZXNlbnQoZGVwLnZpZXdRdWVyeSkpIHtcbiAgICAgICAgICAgICAgX2FkZFF1ZXJ5VG9Ub2tlbk1hcCh2aWV3UXVlcmllcywgZGVwLnZpZXdRdWVyeSk7XG4gICAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdmlld1F1ZXJpZXM7XG4gIH1cbiAgZnVuY3Rpb24gX2dldENvbnRlbnRRdWVyaWVzKGRpcmVjdGl2ZXMpIHtcbiAgICAgIHZhciBjb250ZW50UXVlcmllcyA9IG5ldyBNYXAoKTtcbiAgICAgIGRpcmVjdGl2ZXMuZm9yRWFjaChmdW5jdGlvbiAoZGlyZWN0aXZlKSB7XG4gICAgICAgICAgaWYgKGlzUHJlc2VudChkaXJlY3RpdmUucXVlcmllcykpIHtcbiAgICAgICAgICAgICAgZGlyZWN0aXZlLnF1ZXJpZXMuZm9yRWFjaChmdW5jdGlvbiAocXVlcnkpIHsgcmV0dXJuIF9hZGRRdWVyeVRvVG9rZW5NYXAoY29udGVudFF1ZXJpZXMsIHF1ZXJ5KTsgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRpcmVjdGl2ZS50eXBlLmRpRGVwcy5mb3JFYWNoKGZ1bmN0aW9uIChkZXApIHtcbiAgICAgICAgICAgICAgaWYgKGlzUHJlc2VudChkZXAucXVlcnkpKSB7XG4gICAgICAgICAgICAgICAgICBfYWRkUXVlcnlUb1Rva2VuTWFwKGNvbnRlbnRRdWVyaWVzLCBkZXAucXVlcnkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBjb250ZW50UXVlcmllcztcbiAgfVxuICBmdW5jdGlvbiBfYWRkUXVlcnlUb1Rva2VuTWFwKG1hcCwgcXVlcnkpIHtcbiAgICAgIHF1ZXJ5LnNlbGVjdG9ycy5mb3JFYWNoKGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgICAgIHZhciBlbnRyeSA9IG1hcC5nZXQodG9rZW4ucmVmZXJlbmNlKTtcbiAgICAgICAgICBpZiAoIWVudHJ5KSB7XG4gICAgICAgICAgICAgIGVudHJ5ID0gW107XG4gICAgICAgICAgICAgIG1hcC5zZXQodG9rZW4ucmVmZXJlbmNlLCBlbnRyeSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVudHJ5LnB1c2gocXVlcnkpO1xuICAgICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQGxpY2Vuc2VcbiAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAqXG4gICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICovXG4gIHZhciBFbGVtZW50U2NoZW1hUmVnaXN0cnkgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gRWxlbWVudFNjaGVtYVJlZ2lzdHJ5KCkge1xuICAgICAgfVxuICAgICAgcmV0dXJuIEVsZW1lbnRTY2hlbWFSZWdpc3RyeTtcbiAgfSgpKTtcblxuICB2YXIgU3R5bGVXaXRoSW1wb3J0cyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBTdHlsZVdpdGhJbXBvcnRzKHN0eWxlLCBzdHlsZVVybHMpIHtcbiAgICAgICAgICB0aGlzLnN0eWxlID0gc3R5bGU7XG4gICAgICAgICAgdGhpcy5zdHlsZVVybHMgPSBzdHlsZVVybHM7XG4gICAgICB9XG4gICAgICByZXR1cm4gU3R5bGVXaXRoSW1wb3J0cztcbiAgfSgpKTtcbiAgZnVuY3Rpb24gaXNTdHlsZVVybFJlc29sdmFibGUodXJsKSB7XG4gICAgICBpZiAoaXNCbGFuayh1cmwpIHx8IHVybC5sZW5ndGggPT09IDAgfHwgdXJsWzBdID09ICcvJylcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB2YXIgc2NoZW1lTWF0Y2ggPSB1cmwubWF0Y2goX3VybFdpdGhTY2hlbWFSZSk7XG4gICAgICByZXR1cm4gc2NoZW1lTWF0Y2ggPT09IG51bGwgfHwgc2NoZW1lTWF0Y2hbMV0gPT0gJ3BhY2thZ2UnIHx8IHNjaGVtZU1hdGNoWzFdID09ICdhc3NldCc7XG4gIH1cbiAgLyoqXG4gICAqIFJld3JpdGVzIHN0eWxlc2hlZXRzIGJ5IHJlc29sdmluZyBhbmQgcmVtb3ZpbmcgdGhlIEBpbXBvcnQgdXJscyB0aGF0XG4gICAqIGFyZSBlaXRoZXIgcmVsYXRpdmUgb3IgZG9uJ3QgaGF2ZSBhIGBwYWNrYWdlOmAgc2NoZW1lXG4gICAqL1xuICBmdW5jdGlvbiBleHRyYWN0U3R5bGVVcmxzKHJlc29sdmVyLCBiYXNlVXJsLCBjc3NUZXh0KSB7XG4gICAgICB2YXIgZm91bmRVcmxzID0gW107XG4gICAgICB2YXIgbW9kaWZpZWRDc3NUZXh0ID0gY3NzVGV4dC5yZXBsYWNlKF9jc3NJbXBvcnRSZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBtID0gW107XG4gICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgbVtfaSAtIDBdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHVybCA9IG1bMV0gfHwgbVsyXTtcbiAgICAgICAgICBpZiAoIWlzU3R5bGVVcmxSZXNvbHZhYmxlKHVybCkpIHtcbiAgICAgICAgICAgICAgLy8gRG8gbm90IGF0dGVtcHQgdG8gcmVzb2x2ZSBub24tcGFja2FnZSBhYnNvbHV0ZSBVUkxzIHdpdGggVVJJIHNjaGVtZVxuICAgICAgICAgICAgICByZXR1cm4gbVswXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm91bmRVcmxzLnB1c2gocmVzb2x2ZXIucmVzb2x2ZShiYXNlVXJsLCB1cmwpKTtcbiAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBuZXcgU3R5bGVXaXRoSW1wb3J0cyhtb2RpZmllZENzc1RleHQsIGZvdW5kVXJscyk7XG4gIH1cbiAgdmFyIF9jc3NJbXBvcnRSZSA9IC9AaW1wb3J0XFxzKyg/OnVybFxcKCk/XFxzKig/Oig/OlsnXCJdKFteJ1wiXSopKXwoW147XFwpXFxzXSopKVteO10qOz8vZztcbiAgdmFyIF91cmxXaXRoU2NoZW1hUmUgPSAvXihbXjovPyNdKyk6LztcblxuICAvKipcbiAgICogQGxpY2Vuc2VcbiAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAqXG4gICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICovXG4gIHZhciBfX2V4dGVuZHMkMTEgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gIH07XG4gIHZhciBQUk9QRVJUWV9QQVJUU19TRVBBUkFUT1IgPSAnLic7XG4gIHZhciBBVFRSSUJVVEVfUFJFRklYID0gJ2F0dHInO1xuICB2YXIgQ0xBU1NfUFJFRklYID0gJ2NsYXNzJztcbiAgdmFyIFNUWUxFX1BSRUZJWCA9ICdzdHlsZSc7XG4gIHZhciBBTklNQVRFX1BST1BfUFJFRklYID0gJ2FuaW1hdGUtJztcbiAgdmFyIEJvdW5kUHJvcGVydHlUeXBlO1xuICAoZnVuY3Rpb24gKEJvdW5kUHJvcGVydHlUeXBlKSB7XG4gICAgICBCb3VuZFByb3BlcnR5VHlwZVtCb3VuZFByb3BlcnR5VHlwZVtcIkRFRkFVTFRcIl0gPSAwXSA9IFwiREVGQVVMVFwiO1xuICAgICAgQm91bmRQcm9wZXJ0eVR5cGVbQm91bmRQcm9wZXJ0eVR5cGVbXCJMSVRFUkFMX0FUVFJcIl0gPSAxXSA9IFwiTElURVJBTF9BVFRSXCI7XG4gICAgICBCb3VuZFByb3BlcnR5VHlwZVtCb3VuZFByb3BlcnR5VHlwZVtcIkFOSU1BVElPTlwiXSA9IDJdID0gXCJBTklNQVRJT05cIjtcbiAgfSkoQm91bmRQcm9wZXJ0eVR5cGUgfHwgKEJvdW5kUHJvcGVydHlUeXBlID0ge30pKTtcbiAgLyoqXG4gICAqIFJlcHJlc2VudHMgYSBwYXJzZWQgcHJvcGVydHkuXG4gICAqL1xuICB2YXIgQm91bmRQcm9wZXJ0eSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBCb3VuZFByb3BlcnR5KG5hbWUsIGV4cHJlc3Npb24sIHR5cGUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICAgIHRoaXMuZXhwcmVzc2lvbiA9IGV4cHJlc3Npb247XG4gICAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgICAgfVxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJvdW5kUHJvcGVydHkucHJvdG90eXBlLCBcImlzTGl0ZXJhbFwiLCB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnR5cGUgPT09IEJvdW5kUHJvcGVydHlUeXBlLkxJVEVSQUxfQVRUUjsgfSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQm91bmRQcm9wZXJ0eS5wcm90b3R5cGUsIFwiaXNBbmltYXRpb25cIiwge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy50eXBlID09PSBCb3VuZFByb3BlcnR5VHlwZS5BTklNQVRJT047IH0sXG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIEJvdW5kUHJvcGVydHk7XG4gIH0oKSk7XG4gIC8qKlxuICAgKiBQYXJzZXMgYmluZGluZ3MgaW4gdGVtcGxhdGVzIGFuZCBpbiB0aGUgZGlyZWN0aXZlIGhvc3QgYXJlYS5cbiAgICovXG4gIHZhciBCaW5kaW5nUGFyc2VyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIEJpbmRpbmdQYXJzZXIoX2V4cHJQYXJzZXIsIF9pbnRlcnBvbGF0aW9uQ29uZmlnLCBfc2NoZW1hUmVnaXN0cnksIHBpcGVzLCBfdGFyZ2V0RXJyb3JzKSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICB0aGlzLl9leHByUGFyc2VyID0gX2V4cHJQYXJzZXI7XG4gICAgICAgICAgdGhpcy5faW50ZXJwb2xhdGlvbkNvbmZpZyA9IF9pbnRlcnBvbGF0aW9uQ29uZmlnO1xuICAgICAgICAgIHRoaXMuX3NjaGVtYVJlZ2lzdHJ5ID0gX3NjaGVtYVJlZ2lzdHJ5O1xuICAgICAgICAgIHRoaXMuX3RhcmdldEVycm9ycyA9IF90YXJnZXRFcnJvcnM7XG4gICAgICAgICAgdGhpcy5waXBlc0J5TmFtZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgICBwaXBlcy5mb3JFYWNoKGZ1bmN0aW9uIChwaXBlKSB7IHJldHVybiBfdGhpcy5waXBlc0J5TmFtZS5zZXQocGlwZS5uYW1lLCBwaXBlKTsgfSk7XG4gICAgICB9XG4gICAgICBCaW5kaW5nUGFyc2VyLnByb3RvdHlwZS5jcmVhdGVEaXJlY3RpdmVIb3N0UHJvcGVydHlBc3RzID0gZnVuY3Rpb24gKGRpck1ldGEsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIGlmIChkaXJNZXRhLmhvc3RQcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgIHZhciBib3VuZFByb3BzXzEgPSBbXTtcbiAgICAgICAgICAgICAgT2JqZWN0LmtleXMoZGlyTWV0YS5ob3N0UHJvcGVydGllcykuZm9yRWFjaChmdW5jdGlvbiAocHJvcE5hbWUpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBleHByZXNzaW9uID0gZGlyTWV0YS5ob3N0UHJvcGVydGllc1twcm9wTmFtZV07XG4gICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGV4cHJlc3Npb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgX3RoaXMucGFyc2VQcm9wZXJ0eUJpbmRpbmcocHJvcE5hbWUsIGV4cHJlc3Npb24sIHRydWUsIHNvdXJjZVNwYW4sIFtdLCBib3VuZFByb3BzXzEpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3JlcG9ydEVycm9yKFwiVmFsdWUgb2YgdGhlIGhvc3QgcHJvcGVydHkgYmluZGluZyBcXFwiXCIgKyBwcm9wTmFtZSArIFwiXFxcIiBuZWVkcyB0byBiZSBhIHN0cmluZyByZXByZXNlbnRpbmcgYW4gZXhwcmVzc2lvbiBidXQgZ290IFxcXCJcIiArIGV4cHJlc3Npb24gKyBcIlxcXCIgKFwiICsgdHlwZW9mIGV4cHJlc3Npb24gKyBcIilcIiwgc291cmNlU3Bhbik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICByZXR1cm4gYm91bmRQcm9wc18xLm1hcChmdW5jdGlvbiAocHJvcCkgeyByZXR1cm4gX3RoaXMuY3JlYXRlRWxlbWVudFByb3BlcnR5QXN0KGRpck1ldGEuc2VsZWN0b3IsIHByb3ApOyB9KTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgQmluZGluZ1BhcnNlci5wcm90b3R5cGUuY3JlYXRlRGlyZWN0aXZlSG9zdEV2ZW50QXN0cyA9IGZ1bmN0aW9uIChkaXJNZXRhLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICBpZiAoZGlyTWV0YS5ob3N0TGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgIHZhciB0YXJnZXRFdmVudEFzdHNfMSA9IFtdO1xuICAgICAgICAgICAgICBPYmplY3Qua2V5cyhkaXJNZXRhLmhvc3RMaXN0ZW5lcnMpLmZvckVhY2goZnVuY3Rpb24gKHByb3BOYW1lKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgZXhwcmVzc2lvbiA9IGRpck1ldGEuaG9zdExpc3RlbmVyc1twcm9wTmFtZV07XG4gICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGV4cHJlc3Npb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgX3RoaXMucGFyc2VFdmVudChwcm9wTmFtZSwgZXhwcmVzc2lvbiwgc291cmNlU3BhbiwgW10sIHRhcmdldEV2ZW50QXN0c18xKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9yZXBvcnRFcnJvcihcIlZhbHVlIG9mIHRoZSBob3N0IGxpc3RlbmVyIFxcXCJcIiArIHByb3BOYW1lICsgXCJcXFwiIG5lZWRzIHRvIGJlIGEgc3RyaW5nIHJlcHJlc2VudGluZyBhbiBleHByZXNzaW9uIGJ1dCBnb3QgXFxcIlwiICsgZXhwcmVzc2lvbiArIFwiXFxcIiAoXCIgKyB0eXBlb2YgZXhwcmVzc2lvbiArIFwiKVwiLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHJldHVybiB0YXJnZXRFdmVudEFzdHNfMTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgQmluZGluZ1BhcnNlci5wcm90b3R5cGUucGFyc2VJbnRlcnBvbGF0aW9uID0gZnVuY3Rpb24gKHZhbHVlLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgICAgdmFyIHNvdXJjZUluZm8gPSBzb3VyY2VTcGFuLnN0YXJ0LnRvU3RyaW5nKCk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgdmFyIGFzdCA9IHRoaXMuX2V4cHJQYXJzZXIucGFyc2VJbnRlcnBvbGF0aW9uKHZhbHVlLCBzb3VyY2VJbmZvLCB0aGlzLl9pbnRlcnBvbGF0aW9uQ29uZmlnKTtcbiAgICAgICAgICAgICAgaWYgKGFzdClcbiAgICAgICAgICAgICAgICAgIHRoaXMuX3JlcG9ydEV4cHJlc3Npb25QYXJzZXJFcnJvcnMoYXN0LmVycm9ycywgc291cmNlU3Bhbik7XG4gICAgICAgICAgICAgIHRoaXMuX2NoZWNrUGlwZXMoYXN0LCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICAgICAgaWYgKGFzdCAmJlxuICAgICAgICAgICAgICAgICAgYXN0LmFzdC5leHByZXNzaW9ucy5sZW5ndGggPiB2aWV3X3V0aWxzLk1BWF9JTlRFUlBPTEFUSU9OX1ZBTFVFUykge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiT25seSBzdXBwb3J0IGF0IG1vc3QgXCIgKyB2aWV3X3V0aWxzLk1BWF9JTlRFUlBPTEFUSU9OX1ZBTFVFUyArIFwiIGludGVycG9sYXRpb24gdmFsdWVzIVwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gYXN0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihcIlwiICsgZSwgc291cmNlU3Bhbik7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLl9leHByUGFyc2VyLndyYXBMaXRlcmFsUHJpbWl0aXZlKCdFUlJPUicsIHNvdXJjZUluZm8pO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICBCaW5kaW5nUGFyc2VyLnByb3RvdHlwZS5wYXJzZUlubGluZVRlbXBsYXRlQmluZGluZyA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSwgc291cmNlU3BhbiwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldFByb3BzLCB0YXJnZXRWYXJzKSB7XG4gICAgICAgICAgdmFyIGJpbmRpbmdzID0gdGhpcy5fcGFyc2VUZW1wbGF0ZUJpbmRpbmdzKHZhbHVlLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJpbmRpbmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIHZhciBiaW5kaW5nID0gYmluZGluZ3NbaV07XG4gICAgICAgICAgICAgIGlmIChiaW5kaW5nLmtleUlzVmFyKSB7XG4gICAgICAgICAgICAgICAgICB0YXJnZXRWYXJzLnB1c2gobmV3IFZhcmlhYmxlQXN0KGJpbmRpbmcua2V5LCBiaW5kaW5nLm5hbWUsIHNvdXJjZVNwYW4pKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIGlmIChpc1ByZXNlbnQoYmluZGluZy5leHByZXNzaW9uKSkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5fcGFyc2VQcm9wZXJ0eUFzdChiaW5kaW5nLmtleSwgYmluZGluZy5leHByZXNzaW9uLCBzb3VyY2VTcGFuLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0UHJvcHMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMucHVzaChbYmluZGluZy5rZXksICcnXSk7XG4gICAgICAgICAgICAgICAgICB0aGlzLnBhcnNlTGl0ZXJhbEF0dHIoYmluZGluZy5rZXksIG51bGwsIHNvdXJjZVNwYW4sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRQcm9wcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgQmluZGluZ1BhcnNlci5wcm90b3R5cGUuX3BhcnNlVGVtcGxhdGVCaW5kaW5ncyA9IGZ1bmN0aW9uICh2YWx1ZSwgc291cmNlU3Bhbikge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgdmFyIHNvdXJjZUluZm8gPSBzb3VyY2VTcGFuLnN0YXJ0LnRvU3RyaW5nKCk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgdmFyIGJpbmRpbmdzUmVzdWx0ID0gdGhpcy5fZXhwclBhcnNlci5wYXJzZVRlbXBsYXRlQmluZGluZ3ModmFsdWUsIHNvdXJjZUluZm8pO1xuICAgICAgICAgICAgICB0aGlzLl9yZXBvcnRFeHByZXNzaW9uUGFyc2VyRXJyb3JzKGJpbmRpbmdzUmVzdWx0LmVycm9ycywgc291cmNlU3Bhbik7XG4gICAgICAgICAgICAgIGJpbmRpbmdzUmVzdWx0LnRlbXBsYXRlQmluZGluZ3MuZm9yRWFjaChmdW5jdGlvbiAoYmluZGluZykge1xuICAgICAgICAgICAgICAgICAgaWYgKGlzUHJlc2VudChiaW5kaW5nLmV4cHJlc3Npb24pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2NoZWNrUGlwZXMoYmluZGluZy5leHByZXNzaW9uLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGJpbmRpbmdzUmVzdWx0Lndhcm5pbmdzLmZvckVhY2goZnVuY3Rpb24gKHdhcm5pbmcpIHsgX3RoaXMuX3JlcG9ydEVycm9yKHdhcm5pbmcsIHNvdXJjZVNwYW4sIGV4cG9ydHMuUGFyc2VFcnJvckxldmVsLldBUk5JTkcpOyB9KTtcbiAgICAgICAgICAgICAgcmV0dXJuIGJpbmRpbmdzUmVzdWx0LnRlbXBsYXRlQmluZGluZ3M7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKFwiXCIgKyBlLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICBCaW5kaW5nUGFyc2VyLnByb3RvdHlwZS5wYXJzZUxpdGVyYWxBdHRyID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlLCBzb3VyY2VTcGFuLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0UHJvcHMpIHtcbiAgICAgICAgICBpZiAoX2lzQW5pbWF0aW9uTGFiZWwobmFtZSkpIHtcbiAgICAgICAgICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKFwiQXNzaWduaW5nIGFuaW1hdGlvbiB0cmlnZ2VycyB2aWEgQHByb3A9XFxcImV4cFxcXCIgYXR0cmlidXRlcyB3aXRoIGFuIGV4cHJlc3Npb24gaXMgaW52YWxpZC5cIiArXG4gICAgICAgICAgICAgICAgICAgICAgXCIgVXNlIHByb3BlcnR5IGJpbmRpbmdzIChlLmcuIFtAcHJvcF09XFxcImV4cFxcXCIpIG9yIHVzZSBhbiBhdHRyaWJ1dGUgd2l0aG91dCBhIHZhbHVlIChlLmcuIEBwcm9wKSBpbnN0ZWFkLlwiLCBzb3VyY2VTcGFuLCBleHBvcnRzLlBhcnNlRXJyb3JMZXZlbC5GQVRBTCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhpcy5fcGFyc2VBbmltYXRpb24obmFtZSwgdmFsdWUsIHNvdXJjZVNwYW4sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRQcm9wcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICB0YXJnZXRQcm9wcy5wdXNoKG5ldyBCb3VuZFByb3BlcnR5KG5hbWUsIHRoaXMuX2V4cHJQYXJzZXIud3JhcExpdGVyYWxQcmltaXRpdmUodmFsdWUsICcnKSwgQm91bmRQcm9wZXJ0eVR5cGUuTElURVJBTF9BVFRSLCBzb3VyY2VTcGFuKSk7XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIEJpbmRpbmdQYXJzZXIucHJvdG90eXBlLnBhcnNlUHJvcGVydHlCaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUsIGV4cHJlc3Npb24sIGlzSG9zdCwgc291cmNlU3BhbiwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldFByb3BzKSB7XG4gICAgICAgICAgdmFyIGlzQW5pbWF0aW9uUHJvcCA9IGZhbHNlO1xuICAgICAgICAgIGlmIChuYW1lLnN0YXJ0c1dpdGgoQU5JTUFURV9QUk9QX1BSRUZJWCkpIHtcbiAgICAgICAgICAgICAgaXNBbmltYXRpb25Qcm9wID0gdHJ1ZTtcbiAgICAgICAgICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyaW5nKEFOSU1BVEVfUFJPUF9QUkVGSVgubGVuZ3RoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoX2lzQW5pbWF0aW9uTGFiZWwobmFtZSkpIHtcbiAgICAgICAgICAgICAgaXNBbmltYXRpb25Qcm9wID0gdHJ1ZTtcbiAgICAgICAgICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNBbmltYXRpb25Qcm9wKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3BhcnNlQW5pbWF0aW9uKG5hbWUsIGV4cHJlc3Npb24sIHNvdXJjZVNwYW4sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRQcm9wcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLl9wYXJzZVByb3BlcnR5QXN0KG5hbWUsIHRoaXMuX3BhcnNlQmluZGluZyhleHByZXNzaW9uLCBpc0hvc3QsIHNvdXJjZVNwYW4pLCBzb3VyY2VTcGFuLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0UHJvcHMpO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICBCaW5kaW5nUGFyc2VyLnByb3RvdHlwZS5wYXJzZVByb3BlcnR5SW50ZXJwb2xhdGlvbiA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSwgc291cmNlU3BhbiwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldFByb3BzKSB7XG4gICAgICAgICAgdmFyIGV4cHIgPSB0aGlzLnBhcnNlSW50ZXJwb2xhdGlvbih2YWx1ZSwgc291cmNlU3Bhbik7XG4gICAgICAgICAgaWYgKGlzUHJlc2VudChleHByKSkge1xuICAgICAgICAgICAgICB0aGlzLl9wYXJzZVByb3BlcnR5QXN0KG5hbWUsIGV4cHIsIHNvdXJjZVNwYW4sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRQcm9wcyk7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9O1xuICAgICAgQmluZGluZ1BhcnNlci5wcm90b3R5cGUuX3BhcnNlUHJvcGVydHlBc3QgPSBmdW5jdGlvbiAobmFtZSwgYXN0LCBzb3VyY2VTcGFuLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0UHJvcHMpIHtcbiAgICAgICAgICB0YXJnZXRNYXRjaGFibGVBdHRycy5wdXNoKFtuYW1lLCBhc3Quc291cmNlXSk7XG4gICAgICAgICAgdGFyZ2V0UHJvcHMucHVzaChuZXcgQm91bmRQcm9wZXJ0eShuYW1lLCBhc3QsIEJvdW5kUHJvcGVydHlUeXBlLkRFRkFVTFQsIHNvdXJjZVNwYW4pKTtcbiAgICAgIH07XG4gICAgICBCaW5kaW5nUGFyc2VyLnByb3RvdHlwZS5fcGFyc2VBbmltYXRpb24gPSBmdW5jdGlvbiAobmFtZSwgZXhwcmVzc2lvbiwgc291cmNlU3BhbiwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldFByb3BzKSB7XG4gICAgICAgICAgLy8gVGhpcyB3aWxsIG9jY3VyIHdoZW4gYSBAdHJpZ2dlciBpcyBub3QgcGFpcmVkIHdpdGggYW4gZXhwcmVzc2lvbi5cbiAgICAgICAgICAvLyBGb3IgYW5pbWF0aW9ucyBpdCBpcyB2YWxpZCB0byBub3QgaGF2ZSBhbiBleHByZXNzaW9uIHNpbmNlICovdm9pZFxuICAgICAgICAgIC8vIHN0YXRlcyB3aWxsIGJlIGFwcGxpZWQgYnkgYW5ndWxhciB3aGVuIHRoZSBlbGVtZW50IGlzIGF0dGFjaGVkL2RldGFjaGVkXG4gICAgICAgICAgdmFyIGFzdCA9IHRoaXMuX3BhcnNlQmluZGluZyhleHByZXNzaW9uIHx8ICdudWxsJywgZmFsc2UsIHNvdXJjZVNwYW4pO1xuICAgICAgICAgIHRhcmdldE1hdGNoYWJsZUF0dHJzLnB1c2goW25hbWUsIGFzdC5zb3VyY2VdKTtcbiAgICAgICAgICB0YXJnZXRQcm9wcy5wdXNoKG5ldyBCb3VuZFByb3BlcnR5KG5hbWUsIGFzdCwgQm91bmRQcm9wZXJ0eVR5cGUuQU5JTUFUSU9OLCBzb3VyY2VTcGFuKSk7XG4gICAgICB9O1xuICAgICAgQmluZGluZ1BhcnNlci5wcm90b3R5cGUuX3BhcnNlQmluZGluZyA9IGZ1bmN0aW9uICh2YWx1ZSwgaXNIb3N0QmluZGluZywgc291cmNlU3Bhbikge1xuICAgICAgICAgIHZhciBzb3VyY2VJbmZvID0gc291cmNlU3Bhbi5zdGFydC50b1N0cmluZygpO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHZhciBhc3QgPSBpc0hvc3RCaW5kaW5nID9cbiAgICAgICAgICAgICAgICAgIHRoaXMuX2V4cHJQYXJzZXIucGFyc2VTaW1wbGVCaW5kaW5nKHZhbHVlLCBzb3VyY2VJbmZvLCB0aGlzLl9pbnRlcnBvbGF0aW9uQ29uZmlnKSA6XG4gICAgICAgICAgICAgICAgICB0aGlzLl9leHByUGFyc2VyLnBhcnNlQmluZGluZyh2YWx1ZSwgc291cmNlSW5mbywgdGhpcy5faW50ZXJwb2xhdGlvbkNvbmZpZyk7XG4gICAgICAgICAgICAgIGlmIChhc3QpXG4gICAgICAgICAgICAgICAgICB0aGlzLl9yZXBvcnRFeHByZXNzaW9uUGFyc2VyRXJyb3JzKGFzdC5lcnJvcnMsIHNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgICB0aGlzLl9jaGVja1BpcGVzKGFzdCwgc291cmNlU3Bhbik7XG4gICAgICAgICAgICAgIHJldHVybiBhc3Q7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKFwiXCIgKyBlLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2V4cHJQYXJzZXIud3JhcExpdGVyYWxQcmltaXRpdmUoJ0VSUk9SJywgc291cmNlSW5mbyk7XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIEJpbmRpbmdQYXJzZXIucHJvdG90eXBlLmNyZWF0ZUVsZW1lbnRQcm9wZXJ0eUFzdCA9IGZ1bmN0aW9uIChlbGVtZW50U2VsZWN0b3IsIGJvdW5kUHJvcCkge1xuICAgICAgICAgIGlmIChib3VuZFByb3AuaXNBbmltYXRpb24pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCb3VuZEVsZW1lbnRQcm9wZXJ0eUFzdChib3VuZFByb3AubmFtZSwgZXhwb3J0cy5Qcm9wZXJ0eUJpbmRpbmdUeXBlLkFuaW1hdGlvbiwgX2FuZ3VsYXJfY29yZS5TZWN1cml0eUNvbnRleHQuTk9ORSwgZmFsc2UsIGJvdW5kUHJvcC5leHByZXNzaW9uLCBudWxsLCBib3VuZFByb3Auc291cmNlU3Bhbik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciB1bml0ID0gbnVsbDtcbiAgICAgICAgICB2YXIgYmluZGluZ1R5cGU7XG4gICAgICAgICAgdmFyIGJvdW5kUHJvcGVydHlOYW1lO1xuICAgICAgICAgIHZhciBwYXJ0cyA9IGJvdW5kUHJvcC5uYW1lLnNwbGl0KFBST1BFUlRZX1BBUlRTX1NFUEFSQVRPUik7XG4gICAgICAgICAgdmFyIHNlY3VyaXR5Q29udGV4dHM7XG4gICAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICB2YXIgcGFydFZhbHVlID0gcGFydHNbMF07XG4gICAgICAgICAgICAgIGJvdW5kUHJvcGVydHlOYW1lID0gdGhpcy5fc2NoZW1hUmVnaXN0cnkuZ2V0TWFwcGVkUHJvcE5hbWUocGFydFZhbHVlKTtcbiAgICAgICAgICAgICAgc2VjdXJpdHlDb250ZXh0cyA9IGNhbGNQb3NzaWJsZVNlY3VyaXR5Q29udGV4dHModGhpcy5fc2NoZW1hUmVnaXN0cnksIGVsZW1lbnRTZWxlY3RvciwgYm91bmRQcm9wZXJ0eU5hbWUsIGZhbHNlKTtcbiAgICAgICAgICAgICAgYmluZGluZ1R5cGUgPSBleHBvcnRzLlByb3BlcnR5QmluZGluZ1R5cGUuUHJvcGVydHk7XG4gICAgICAgICAgICAgIHRoaXMuX3ZhbGlkYXRlUHJvcGVydHlPckF0dHJpYnV0ZU5hbWUoYm91bmRQcm9wZXJ0eU5hbWUsIGJvdW5kUHJvcC5zb3VyY2VTcGFuLCBmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBpZiAocGFydHNbMF0gPT0gQVRUUklCVVRFX1BSRUZJWCkge1xuICAgICAgICAgICAgICAgICAgYm91bmRQcm9wZXJ0eU5hbWUgPSBwYXJ0c1sxXTtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX3ZhbGlkYXRlUHJvcGVydHlPckF0dHJpYnV0ZU5hbWUoYm91bmRQcm9wZXJ0eU5hbWUsIGJvdW5kUHJvcC5zb3VyY2VTcGFuLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgIHNlY3VyaXR5Q29udGV4dHMgPSBjYWxjUG9zc2libGVTZWN1cml0eUNvbnRleHRzKHRoaXMuX3NjaGVtYVJlZ2lzdHJ5LCBlbGVtZW50U2VsZWN0b3IsIGJvdW5kUHJvcGVydHlOYW1lLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgIHZhciBuc1NlcGFyYXRvcklkeCA9IGJvdW5kUHJvcGVydHlOYW1lLmluZGV4T2YoJzonKTtcbiAgICAgICAgICAgICAgICAgIGlmIChuc1NlcGFyYXRvcklkeCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIG5zID0gYm91bmRQcm9wZXJ0eU5hbWUuc3Vic3RyaW5nKDAsIG5zU2VwYXJhdG9ySWR4KTtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZV8xID0gYm91bmRQcm9wZXJ0eU5hbWUuc3Vic3RyaW5nKG5zU2VwYXJhdG9ySWR4ICsgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgYm91bmRQcm9wZXJ0eU5hbWUgPSBtZXJnZU5zQW5kTmFtZShucywgbmFtZV8xKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGJpbmRpbmdUeXBlID0gZXhwb3J0cy5Qcm9wZXJ0eUJpbmRpbmdUeXBlLkF0dHJpYnV0ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIGlmIChwYXJ0c1swXSA9PSBDTEFTU19QUkVGSVgpIHtcbiAgICAgICAgICAgICAgICAgIGJvdW5kUHJvcGVydHlOYW1lID0gcGFydHNbMV07XG4gICAgICAgICAgICAgICAgICBiaW5kaW5nVHlwZSA9IGV4cG9ydHMuUHJvcGVydHlCaW5kaW5nVHlwZS5DbGFzcztcbiAgICAgICAgICAgICAgICAgIHNlY3VyaXR5Q29udGV4dHMgPSBbX2FuZ3VsYXJfY29yZS5TZWN1cml0eUNvbnRleHQuTk9ORV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSBpZiAocGFydHNbMF0gPT0gU1RZTEVfUFJFRklYKSB7XG4gICAgICAgICAgICAgICAgICB1bml0ID0gcGFydHMubGVuZ3RoID4gMiA/IHBhcnRzWzJdIDogbnVsbDtcbiAgICAgICAgICAgICAgICAgIGJvdW5kUHJvcGVydHlOYW1lID0gcGFydHNbMV07XG4gICAgICAgICAgICAgICAgICBiaW5kaW5nVHlwZSA9IGV4cG9ydHMuUHJvcGVydHlCaW5kaW5nVHlwZS5TdHlsZTtcbiAgICAgICAgICAgICAgICAgIHNlY3VyaXR5Q29udGV4dHMgPSBbX2FuZ3VsYXJfY29yZS5TZWN1cml0eUNvbnRleHQuU1RZTEVdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoXCJJbnZhbGlkIHByb3BlcnR5IG5hbWUgJ1wiICsgYm91bmRQcm9wLm5hbWUgKyBcIidcIiwgYm91bmRQcm9wLnNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgICAgICAgYmluZGluZ1R5cGUgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgc2VjdXJpdHlDb250ZXh0cyA9IFtdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuZXcgQm91bmRFbGVtZW50UHJvcGVydHlBc3QoYm91bmRQcm9wZXJ0eU5hbWUsIGJpbmRpbmdUeXBlLCBzZWN1cml0eUNvbnRleHRzLmxlbmd0aCA9PT0gMSA/IHNlY3VyaXR5Q29udGV4dHNbMF0gOiBudWxsLCBzZWN1cml0eUNvbnRleHRzLmxlbmd0aCA+IDEsIGJvdW5kUHJvcC5leHByZXNzaW9uLCB1bml0LCBib3VuZFByb3Auc291cmNlU3Bhbik7XG4gICAgICB9O1xuICAgICAgQmluZGluZ1BhcnNlci5wcm90b3R5cGUucGFyc2VFdmVudCA9IGZ1bmN0aW9uIChuYW1lLCBleHByZXNzaW9uLCBzb3VyY2VTcGFuLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0RXZlbnRzKSB7XG4gICAgICAgICAgaWYgKF9pc0FuaW1hdGlvbkxhYmVsKG5hbWUpKSB7XG4gICAgICAgICAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cigxKTtcbiAgICAgICAgICAgICAgdGhpcy5fcGFyc2VBbmltYXRpb25FdmVudChuYW1lLCBleHByZXNzaW9uLCBzb3VyY2VTcGFuLCB0YXJnZXRFdmVudHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5fcGFyc2VFdmVudChuYW1lLCBleHByZXNzaW9uLCBzb3VyY2VTcGFuLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0RXZlbnRzKTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgQmluZGluZ1BhcnNlci5wcm90b3R5cGUuX3BhcnNlQW5pbWF0aW9uRXZlbnQgPSBmdW5jdGlvbiAobmFtZSwgZXhwcmVzc2lvbiwgc291cmNlU3BhbiwgdGFyZ2V0RXZlbnRzKSB7XG4gICAgICAgICAgdmFyIG1hdGNoZXMgPSBzcGxpdEF0UGVyaW9kKG5hbWUsIFtuYW1lLCAnJ10pO1xuICAgICAgICAgIHZhciBldmVudE5hbWUgPSBtYXRjaGVzWzBdO1xuICAgICAgICAgIHZhciBwaGFzZSA9IG1hdGNoZXNbMV0udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICBpZiAocGhhc2UpIHtcbiAgICAgICAgICAgICAgc3dpdGNoIChwaGFzZSkge1xuICAgICAgICAgICAgICAgICAgY2FzZSAnc3RhcnQnOlxuICAgICAgICAgICAgICAgICAgY2FzZSAnZG9uZSc6XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIGFzdCA9IHRoaXMuX3BhcnNlQWN0aW9uKGV4cHJlc3Npb24sIHNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgICAgICAgICAgIHRhcmdldEV2ZW50cy5wdXNoKG5ldyBCb3VuZEV2ZW50QXN0KGV2ZW50TmFtZSwgbnVsbCwgcGhhc2UsIGFzdCwgc291cmNlU3BhbikpO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihcIlRoZSBwcm92aWRlZCBhbmltYXRpb24gb3V0cHV0IHBoYXNlIHZhbHVlIFxcXCJcIiArIHBoYXNlICsgXCJcXFwiIGZvciBcXFwiQFwiICsgZXZlbnROYW1lICsgXCJcXFwiIGlzIG5vdCBzdXBwb3J0ZWQgKHVzZSBzdGFydCBvciBkb25lKVwiLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoXCJUaGUgYW5pbWF0aW9uIHRyaWdnZXIgb3V0cHV0IGV2ZW50IChAXCIgKyBldmVudE5hbWUgKyBcIikgaXMgbWlzc2luZyBpdHMgcGhhc2UgdmFsdWUgbmFtZSAoc3RhcnQgb3IgZG9uZSBhcmUgY3VycmVudGx5IHN1cHBvcnRlZClcIiwgc291cmNlU3Bhbik7XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIEJpbmRpbmdQYXJzZXIucHJvdG90eXBlLl9wYXJzZUV2ZW50ID0gZnVuY3Rpb24gKG5hbWUsIGV4cHJlc3Npb24sIHNvdXJjZVNwYW4sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRFdmVudHMpIHtcbiAgICAgICAgICAvLyBsb25nIGZvcm1hdDogJ3RhcmdldDogZXZlbnROYW1lJ1xuICAgICAgICAgIHZhciBfYSA9IHNwbGl0QXRDb2xvbihuYW1lLCBbbnVsbCwgbmFtZV0pLCB0YXJnZXQgPSBfYVswXSwgZXZlbnROYW1lID0gX2FbMV07XG4gICAgICAgICAgdmFyIGFzdCA9IHRoaXMuX3BhcnNlQWN0aW9uKGV4cHJlc3Npb24sIHNvdXJjZVNwYW4pO1xuICAgICAgICAgIHRhcmdldE1hdGNoYWJsZUF0dHJzLnB1c2goW25hbWUsIGFzdC5zb3VyY2VdKTtcbiAgICAgICAgICB0YXJnZXRFdmVudHMucHVzaChuZXcgQm91bmRFdmVudEFzdChldmVudE5hbWUsIHRhcmdldCwgbnVsbCwgYXN0LCBzb3VyY2VTcGFuKSk7XG4gICAgICAgICAgLy8gRG9uJ3QgZGV0ZWN0IGRpcmVjdGl2ZXMgZm9yIGV2ZW50IG5hbWVzIGZvciBub3csXG4gICAgICAgICAgLy8gc28gZG9uJ3QgYWRkIHRoZSBldmVudCBuYW1lIHRvIHRoZSBtYXRjaGFibGVBdHRyc1xuICAgICAgfTtcbiAgICAgIEJpbmRpbmdQYXJzZXIucHJvdG90eXBlLl9wYXJzZUFjdGlvbiA9IGZ1bmN0aW9uICh2YWx1ZSwgc291cmNlU3Bhbikge1xuICAgICAgICAgIHZhciBzb3VyY2VJbmZvID0gc291cmNlU3Bhbi5zdGFydC50b1N0cmluZygpO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHZhciBhc3QgPSB0aGlzLl9leHByUGFyc2VyLnBhcnNlQWN0aW9uKHZhbHVlLCBzb3VyY2VJbmZvLCB0aGlzLl9pbnRlcnBvbGF0aW9uQ29uZmlnKTtcbiAgICAgICAgICAgICAgaWYgKGFzdCkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXhwcmVzc2lvblBhcnNlckVycm9ycyhhc3QuZXJyb3JzLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoIWFzdCB8fCBhc3QuYXN0IGluc3RhbmNlb2YgRW1wdHlFeHByKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihcIkVtcHR5IGV4cHJlc3Npb25zIGFyZSBub3QgYWxsb3dlZFwiLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9leHByUGFyc2VyLndyYXBMaXRlcmFsUHJpbWl0aXZlKCdFUlJPUicsIHNvdXJjZUluZm8pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRoaXMuX2NoZWNrUGlwZXMoYXN0LCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGFzdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoXCJcIiArIGUsIHNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZXhwclBhcnNlci53cmFwTGl0ZXJhbFByaW1pdGl2ZSgnRVJST1InLCBzb3VyY2VJbmZvKTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgQmluZGluZ1BhcnNlci5wcm90b3R5cGUuX3JlcG9ydEVycm9yID0gZnVuY3Rpb24gKG1lc3NhZ2UsIHNvdXJjZVNwYW4sIGxldmVsKSB7XG4gICAgICAgICAgaWYgKGxldmVsID09PSB2b2lkIDApIHsgbGV2ZWwgPSBleHBvcnRzLlBhcnNlRXJyb3JMZXZlbC5GQVRBTDsgfVxuICAgICAgICAgIHRoaXMuX3RhcmdldEVycm9ycy5wdXNoKG5ldyBQYXJzZUVycm9yKHNvdXJjZVNwYW4sIG1lc3NhZ2UsIGxldmVsKSk7XG4gICAgICB9O1xuICAgICAgQmluZGluZ1BhcnNlci5wcm90b3R5cGUuX3JlcG9ydEV4cHJlc3Npb25QYXJzZXJFcnJvcnMgPSBmdW5jdGlvbiAoZXJyb3JzLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBlcnJvcnNfMSA9IGVycm9yczsgX2kgPCBlcnJvcnNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgdmFyIGVycm9yID0gZXJyb3JzXzFbX2ldO1xuICAgICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihlcnJvci5tZXNzYWdlLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgQmluZGluZ1BhcnNlci5wcm90b3R5cGUuX2NoZWNrUGlwZXMgPSBmdW5jdGlvbiAoYXN0LCBzb3VyY2VTcGFuKSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICBpZiAoaXNQcmVzZW50KGFzdCkpIHtcbiAgICAgICAgICAgICAgdmFyIGNvbGxlY3RvciA9IG5ldyBQaXBlQ29sbGVjdG9yKCk7XG4gICAgICAgICAgICAgIGFzdC52aXNpdChjb2xsZWN0b3IpO1xuICAgICAgICAgICAgICBjb2xsZWN0b3IucGlwZXMuZm9yRWFjaChmdW5jdGlvbiAocGlwZU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgIGlmICghX3RoaXMucGlwZXNCeU5hbWUuaGFzKHBpcGVOYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9yZXBvcnRFcnJvcihcIlRoZSBwaXBlICdcIiArIHBpcGVOYW1lICsgXCInIGNvdWxkIG5vdCBiZSBmb3VuZFwiLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHByb3BOYW1lIHRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSAvIGF0dHJpYnV0ZVxuICAgICAgICogQHBhcmFtIHNvdXJjZVNwYW5cbiAgICAgICAqIEBwYXJhbSBpc0F0dHIgdHJ1ZSB3aGVuIGJpbmRpbmcgdG8gYW4gYXR0cmlidXRlXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG4gICAgICBCaW5kaW5nUGFyc2VyLnByb3RvdHlwZS5fdmFsaWRhdGVQcm9wZXJ0eU9yQXR0cmlidXRlTmFtZSA9IGZ1bmN0aW9uIChwcm9wTmFtZSwgc291cmNlU3BhbiwgaXNBdHRyKSB7XG4gICAgICAgICAgdmFyIHJlcG9ydCA9IGlzQXR0ciA/IHRoaXMuX3NjaGVtYVJlZ2lzdHJ5LnZhbGlkYXRlQXR0cmlidXRlKHByb3BOYW1lKSA6XG4gICAgICAgICAgICAgIHRoaXMuX3NjaGVtYVJlZ2lzdHJ5LnZhbGlkYXRlUHJvcGVydHkocHJvcE5hbWUpO1xuICAgICAgICAgIGlmIChyZXBvcnQuZXJyb3IpIHtcbiAgICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IocmVwb3J0Lm1zZywgc291cmNlU3BhbiwgZXhwb3J0cy5QYXJzZUVycm9yTGV2ZWwuRkFUQUwpO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICByZXR1cm4gQmluZGluZ1BhcnNlcjtcbiAgfSgpKTtcbiAgdmFyIFBpcGVDb2xsZWN0b3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDExKFBpcGVDb2xsZWN0b3IsIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBQaXBlQ29sbGVjdG9yKCkge1xuICAgICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgIHRoaXMucGlwZXMgPSBuZXcgU2V0KCk7XG4gICAgICB9XG4gICAgICBQaXBlQ29sbGVjdG9yLnByb3RvdHlwZS52aXNpdFBpcGUgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgICAgdGhpcy5waXBlcy5hZGQoYXN0Lm5hbWUpO1xuICAgICAgICAgIGFzdC5leHAudmlzaXQodGhpcyk7XG4gICAgICAgICAgdGhpcy52aXNpdEFsbChhc3QuYXJncywgY29udGV4dCk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIFBpcGVDb2xsZWN0b3I7XG4gIH0oUmVjdXJzaXZlQXN0VmlzaXRvcikpO1xuICBmdW5jdGlvbiBfaXNBbmltYXRpb25MYWJlbChuYW1lKSB7XG4gICAgICByZXR1cm4gbmFtZVswXSA9PSAnQCc7XG4gIH1cbiAgZnVuY3Rpb24gY2FsY1Bvc3NpYmxlU2VjdXJpdHlDb250ZXh0cyhyZWdpc3RyeSwgc2VsZWN0b3IsIHByb3BOYW1lLCBpc0F0dHJpYnV0ZSkge1xuICAgICAgdmFyIGN0eHMgPSBbXTtcbiAgICAgIENzc1NlbGVjdG9yLnBhcnNlKHNlbGVjdG9yKS5mb3JFYWNoKGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgICAgICAgIHZhciBlbGVtZW50TmFtZXMgPSBzZWxlY3Rvci5lbGVtZW50ID8gW3NlbGVjdG9yLmVsZW1lbnRdIDogcmVnaXN0cnkuYWxsS25vd25FbGVtZW50TmFtZXMoKTtcbiAgICAgICAgICB2YXIgbm90RWxlbWVudE5hbWVzID0gbmV3IFNldChzZWxlY3Rvci5ub3RTZWxlY3RvcnMuZmlsdGVyKGZ1bmN0aW9uIChzZWxlY3RvcikgeyByZXR1cm4gc2VsZWN0b3IuaXNFbGVtZW50U2VsZWN0b3IoKTsgfSlcbiAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoc2VsZWN0b3IpIHsgcmV0dXJuIHNlbGVjdG9yLmVsZW1lbnQ7IH0pKTtcbiAgICAgICAgICB2YXIgcG9zc2libGVFbGVtZW50TmFtZXMgPSBlbGVtZW50TmFtZXMuZmlsdGVyKGZ1bmN0aW9uIChlbGVtZW50TmFtZSkgeyByZXR1cm4gIW5vdEVsZW1lbnROYW1lcy5oYXMoZWxlbWVudE5hbWUpOyB9KTtcbiAgICAgICAgICBjdHhzLnB1c2guYXBwbHkoY3R4cywgcG9zc2libGVFbGVtZW50TmFtZXMubWFwKGZ1bmN0aW9uIChlbGVtZW50TmFtZSkgeyByZXR1cm4gcmVnaXN0cnkuc2VjdXJpdHlDb250ZXh0KGVsZW1lbnROYW1lLCBwcm9wTmFtZSwgaXNBdHRyaWJ1dGUpOyB9KSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBjdHhzLmxlbmd0aCA9PT0gMCA/IFtfYW5ndWxhcl9jb3JlLlNlY3VyaXR5Q29udGV4dC5OT05FXSA6IEFycmF5LmZyb20obmV3IFNldChjdHhzKSkuc29ydCgpO1xuICB9XG5cbiAgdmFyIE5HX0NPTlRFTlRfU0VMRUNUX0FUVFIgPSAnc2VsZWN0JztcbiAgdmFyIE5HX0NPTlRFTlRfRUxFTUVOVCA9ICduZy1jb250ZW50JztcbiAgdmFyIExJTktfRUxFTUVOVCA9ICdsaW5rJztcbiAgdmFyIExJTktfU1RZTEVfUkVMX0FUVFIgPSAncmVsJztcbiAgdmFyIExJTktfU1RZTEVfSFJFRl9BVFRSID0gJ2hyZWYnO1xuICB2YXIgTElOS19TVFlMRV9SRUxfVkFMVUUgPSAnc3R5bGVzaGVldCc7XG4gIHZhciBTVFlMRV9FTEVNRU5UID0gJ3N0eWxlJztcbiAgdmFyIFNDUklQVF9FTEVNRU5UID0gJ3NjcmlwdCc7XG4gIHZhciBOR19OT05fQklOREFCTEVfQVRUUiA9ICduZ05vbkJpbmRhYmxlJztcbiAgdmFyIE5HX1BST0pFQ1RfQVMgPSAnbmdQcm9qZWN0QXMnO1xuICBmdW5jdGlvbiBwcmVwYXJzZUVsZW1lbnQoYXN0KSB7XG4gICAgICB2YXIgc2VsZWN0QXR0ciA9IG51bGw7XG4gICAgICB2YXIgaHJlZkF0dHIgPSBudWxsO1xuICAgICAgdmFyIHJlbEF0dHIgPSBudWxsO1xuICAgICAgdmFyIG5vbkJpbmRhYmxlID0gZmFsc2U7XG4gICAgICB2YXIgcHJvamVjdEFzID0gbnVsbDtcbiAgICAgIGFzdC5hdHRycy5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyKSB7XG4gICAgICAgICAgdmFyIGxjQXR0ck5hbWUgPSBhdHRyLm5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICBpZiAobGNBdHRyTmFtZSA9PSBOR19DT05URU5UX1NFTEVDVF9BVFRSKSB7XG4gICAgICAgICAgICAgIHNlbGVjdEF0dHIgPSBhdHRyLnZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChsY0F0dHJOYW1lID09IExJTktfU1RZTEVfSFJFRl9BVFRSKSB7XG4gICAgICAgICAgICAgIGhyZWZBdHRyID0gYXR0ci52YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAobGNBdHRyTmFtZSA9PSBMSU5LX1NUWUxFX1JFTF9BVFRSKSB7XG4gICAgICAgICAgICAgIHJlbEF0dHIgPSBhdHRyLnZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChhdHRyLm5hbWUgPT0gTkdfTk9OX0JJTkRBQkxFX0FUVFIpIHtcbiAgICAgICAgICAgICAgbm9uQmluZGFibGUgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChhdHRyLm5hbWUgPT0gTkdfUFJPSkVDVF9BUykge1xuICAgICAgICAgICAgICBpZiAoYXR0ci52YWx1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICBwcm9qZWN0QXMgPSBhdHRyLnZhbHVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBzZWxlY3RBdHRyID0gbm9ybWFsaXplTmdDb250ZW50U2VsZWN0KHNlbGVjdEF0dHIpO1xuICAgICAgdmFyIG5vZGVOYW1lID0gYXN0Lm5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIHZhciB0eXBlID0gUHJlcGFyc2VkRWxlbWVudFR5cGUuT1RIRVI7XG4gICAgICBpZiAoc3BsaXROc05hbWUobm9kZU5hbWUpWzFdID09IE5HX0NPTlRFTlRfRUxFTUVOVCkge1xuICAgICAgICAgIHR5cGUgPSBQcmVwYXJzZWRFbGVtZW50VHlwZS5OR19DT05URU5UO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAobm9kZU5hbWUgPT0gU1RZTEVfRUxFTUVOVCkge1xuICAgICAgICAgIHR5cGUgPSBQcmVwYXJzZWRFbGVtZW50VHlwZS5TVFlMRTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG5vZGVOYW1lID09IFNDUklQVF9FTEVNRU5UKSB7XG4gICAgICAgICAgdHlwZSA9IFByZXBhcnNlZEVsZW1lbnRUeXBlLlNDUklQVDtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG5vZGVOYW1lID09IExJTktfRUxFTUVOVCAmJiByZWxBdHRyID09IExJTktfU1RZTEVfUkVMX1ZBTFVFKSB7XG4gICAgICAgICAgdHlwZSA9IFByZXBhcnNlZEVsZW1lbnRUeXBlLlNUWUxFU0hFRVQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IFByZXBhcnNlZEVsZW1lbnQodHlwZSwgc2VsZWN0QXR0ciwgaHJlZkF0dHIsIG5vbkJpbmRhYmxlLCBwcm9qZWN0QXMpO1xuICB9XG4gIHZhciBQcmVwYXJzZWRFbGVtZW50VHlwZTtcbiAgKGZ1bmN0aW9uIChQcmVwYXJzZWRFbGVtZW50VHlwZSkge1xuICAgICAgUHJlcGFyc2VkRWxlbWVudFR5cGVbUHJlcGFyc2VkRWxlbWVudFR5cGVbXCJOR19DT05URU5UXCJdID0gMF0gPSBcIk5HX0NPTlRFTlRcIjtcbiAgICAgIFByZXBhcnNlZEVsZW1lbnRUeXBlW1ByZXBhcnNlZEVsZW1lbnRUeXBlW1wiU1RZTEVcIl0gPSAxXSA9IFwiU1RZTEVcIjtcbiAgICAgIFByZXBhcnNlZEVsZW1lbnRUeXBlW1ByZXBhcnNlZEVsZW1lbnRUeXBlW1wiU1RZTEVTSEVFVFwiXSA9IDJdID0gXCJTVFlMRVNIRUVUXCI7XG4gICAgICBQcmVwYXJzZWRFbGVtZW50VHlwZVtQcmVwYXJzZWRFbGVtZW50VHlwZVtcIlNDUklQVFwiXSA9IDNdID0gXCJTQ1JJUFRcIjtcbiAgICAgIFByZXBhcnNlZEVsZW1lbnRUeXBlW1ByZXBhcnNlZEVsZW1lbnRUeXBlW1wiT1RIRVJcIl0gPSA0XSA9IFwiT1RIRVJcIjtcbiAgfSkoUHJlcGFyc2VkRWxlbWVudFR5cGUgfHwgKFByZXBhcnNlZEVsZW1lbnRUeXBlID0ge30pKTtcbiAgdmFyIFByZXBhcnNlZEVsZW1lbnQgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gUHJlcGFyc2VkRWxlbWVudCh0eXBlLCBzZWxlY3RBdHRyLCBocmVmQXR0ciwgbm9uQmluZGFibGUsIHByb2plY3RBcykge1xuICAgICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgICAgdGhpcy5zZWxlY3RBdHRyID0gc2VsZWN0QXR0cjtcbiAgICAgICAgICB0aGlzLmhyZWZBdHRyID0gaHJlZkF0dHI7XG4gICAgICAgICAgdGhpcy5ub25CaW5kYWJsZSA9IG5vbkJpbmRhYmxlO1xuICAgICAgICAgIHRoaXMucHJvamVjdEFzID0gcHJvamVjdEFzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFByZXBhcnNlZEVsZW1lbnQ7XG4gIH0oKSk7XG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZU5nQ29udGVudFNlbGVjdChzZWxlY3RBdHRyKSB7XG4gICAgICBpZiAoc2VsZWN0QXR0ciA9PT0gbnVsbCB8fCBzZWxlY3RBdHRyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiAnKic7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZWN0QXR0cjtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbGljZW5zZVxuICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICpcbiAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgKi9cbiAgdmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgfTtcbiAgLy8gR3JvdXAgMSA9IFwiYmluZC1cIlxuICAvLyBHcm91cCAyID0gXCJsZXQtXCJcbiAgLy8gR3JvdXAgMyA9IFwicmVmLS8jXCJcbiAgLy8gR3JvdXAgNCA9IFwib24tXCJcbiAgLy8gR3JvdXAgNSA9IFwiYmluZG9uLVwiXG4gIC8vIEdyb3VwIDYgPSBcIkBcIlxuICAvLyBHcm91cCA3ID0gdGhlIGlkZW50aWZpZXIgYWZ0ZXIgXCJiaW5kLVwiLCBcImxldC1cIiwgXCJyZWYtLyNcIiwgXCJvbi1cIiwgXCJiaW5kb24tXCIgb3IgXCJAXCJcbiAgLy8gR3JvdXAgOCA9IGlkZW50aWZpZXIgaW5zaWRlIFsoKV1cbiAgLy8gR3JvdXAgOSA9IGlkZW50aWZpZXIgaW5zaWRlIFtdXG4gIC8vIEdyb3VwIDEwID0gaWRlbnRpZmllciBpbnNpZGUgKClcbiAgdmFyIEJJTkRfTkFNRV9SRUdFWFAgPSAvXig/Oig/Oig/OihiaW5kLSl8KGxldC0pfChyZWYtfCMpfChvbi0pfChiaW5kb24tKXwoQCkpKC4rKSl8XFxbXFwoKFteXFwpXSspXFwpXFxdfFxcWyhbXlxcXV0rKVxcXXxcXCgoW15cXCldKylcXCkpJC87XG4gIHZhciBLV19CSU5EX0lEWCA9IDE7XG4gIHZhciBLV19MRVRfSURYID0gMjtcbiAgdmFyIEtXX1JFRl9JRFggPSAzO1xuICB2YXIgS1dfT05fSURYID0gNDtcbiAgdmFyIEtXX0JJTkRPTl9JRFggPSA1O1xuICB2YXIgS1dfQVRfSURYID0gNjtcbiAgdmFyIElERU5UX0tXX0lEWCA9IDc7XG4gIHZhciBJREVOVF9CQU5BTkFfQk9YX0lEWCA9IDg7XG4gIHZhciBJREVOVF9QUk9QRVJUWV9JRFggPSA5O1xuICB2YXIgSURFTlRfRVZFTlRfSURYID0gMTA7XG4gIHZhciBURU1QTEFURV9FTEVNRU5UID0gJ3RlbXBsYXRlJztcbiAgdmFyIFRFTVBMQVRFX0FUVFIgPSAndGVtcGxhdGUnO1xuICB2YXIgVEVNUExBVEVfQVRUUl9QUkVGSVggPSAnKic7XG4gIHZhciBDTEFTU19BVFRSID0gJ2NsYXNzJztcbiAgdmFyIFRFWFRfQ1NTX1NFTEVDVE9SID0gQ3NzU2VsZWN0b3IucGFyc2UoJyonKVswXTtcbiAgLyoqXG4gICAqIFByb3ZpZGVzIGFuIGFycmF5IG9mIHtAbGluayBUZW1wbGF0ZUFzdFZpc2l0b3J9cyB3aGljaCB3aWxsIGJlIHVzZWQgdG8gdHJhbnNmb3JtXG4gICAqIHBhcnNlZCB0ZW1wbGF0ZXMgYmVmb3JlIGNvbXBpbGF0aW9uIGlzIGludm9rZWQsIGFsbG93aW5nIGN1c3RvbSBleHByZXNzaW9uIHN5bnRheFxuICAgKiBhbmQgb3RoZXIgYWR2YW5jZWQgdHJhbnNmb3JtYXRpb25zLlxuICAgKlxuICAgKiBUaGlzIGlzIGN1cnJlbnRseSBhbiBpbnRlcm5hbC1vbmx5IGZlYXR1cmUgYW5kIG5vdCBtZWFudCBmb3IgZ2VuZXJhbCB1c2UuXG4gICAqL1xuICB2YXIgVEVNUExBVEVfVFJBTlNGT1JNUyA9IG5ldyBfYW5ndWxhcl9jb3JlLk9wYXF1ZVRva2VuKCdUZW1wbGF0ZVRyYW5zZm9ybXMnKTtcbiAgdmFyIFRlbXBsYXRlUGFyc2VFcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMoVGVtcGxhdGVQYXJzZUVycm9yLCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gVGVtcGxhdGVQYXJzZUVycm9yKG1lc3NhZ2UsIHNwYW4sIGxldmVsKSB7XG4gICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgc3BhbiwgbWVzc2FnZSwgbGV2ZWwpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFRlbXBsYXRlUGFyc2VFcnJvcjtcbiAgfShQYXJzZUVycm9yKSk7XG4gIHZhciBUZW1wbGF0ZVBhcnNlUmVzdWx0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIFRlbXBsYXRlUGFyc2VSZXN1bHQodGVtcGxhdGVBc3QsIGVycm9ycykge1xuICAgICAgICAgIHRoaXMudGVtcGxhdGVBc3QgPSB0ZW1wbGF0ZUFzdDtcbiAgICAgICAgICB0aGlzLmVycm9ycyA9IGVycm9ycztcbiAgICAgIH1cbiAgICAgIHJldHVybiBUZW1wbGF0ZVBhcnNlUmVzdWx0O1xuICB9KCkpO1xuICB2YXIgVGVtcGxhdGVQYXJzZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gVGVtcGxhdGVQYXJzZXIoX2V4cHJQYXJzZXIsIF9zY2hlbWFSZWdpc3RyeSwgX2h0bWxQYXJzZXIsIF9jb25zb2xlLCB0cmFuc2Zvcm1zKSB7XG4gICAgICAgICAgdGhpcy5fZXhwclBhcnNlciA9IF9leHByUGFyc2VyO1xuICAgICAgICAgIHRoaXMuX3NjaGVtYVJlZ2lzdHJ5ID0gX3NjaGVtYVJlZ2lzdHJ5O1xuICAgICAgICAgIHRoaXMuX2h0bWxQYXJzZXIgPSBfaHRtbFBhcnNlcjtcbiAgICAgICAgICB0aGlzLl9jb25zb2xlID0gX2NvbnNvbGU7XG4gICAgICAgICAgdGhpcy50cmFuc2Zvcm1zID0gdHJhbnNmb3JtcztcbiAgICAgIH1cbiAgICAgIFRlbXBsYXRlUGFyc2VyLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIChjb21wb25lbnQsIHRlbXBsYXRlLCBkaXJlY3RpdmVzLCBwaXBlcywgc2NoZW1hcywgdGVtcGxhdGVVcmwpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy50cnlQYXJzZShjb21wb25lbnQsIHRlbXBsYXRlLCBkaXJlY3RpdmVzLCBwaXBlcywgc2NoZW1hcywgdGVtcGxhdGVVcmwpO1xuICAgICAgICAgIHZhciB3YXJuaW5ncyA9IHJlc3VsdC5lcnJvcnMuZmlsdGVyKGZ1bmN0aW9uIChlcnJvcikgeyByZXR1cm4gZXJyb3IubGV2ZWwgPT09IGV4cG9ydHMuUGFyc2VFcnJvckxldmVsLldBUk5JTkc7IH0pO1xuICAgICAgICAgIHZhciBlcnJvcnMgPSByZXN1bHQuZXJyb3JzLmZpbHRlcihmdW5jdGlvbiAoZXJyb3IpIHsgcmV0dXJuIGVycm9yLmxldmVsID09PSBleHBvcnRzLlBhcnNlRXJyb3JMZXZlbC5GQVRBTDsgfSk7XG4gICAgICAgICAgaWYgKHdhcm5pbmdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgdGhpcy5fY29uc29sZS53YXJuKFwiVGVtcGxhdGUgcGFyc2Ugd2FybmluZ3M6XFxuXCIgKyB3YXJuaW5ncy5qb2luKCdcXG4nKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChlcnJvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICB2YXIgZXJyb3JTdHJpbmcgPSBlcnJvcnMuam9pbignXFxuJyk7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRlbXBsYXRlIHBhcnNlIGVycm9yczpcXG5cIiArIGVycm9yU3RyaW5nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdC50ZW1wbGF0ZUFzdDtcbiAgICAgIH07XG4gICAgICBUZW1wbGF0ZVBhcnNlci5wcm90b3R5cGUudHJ5UGFyc2UgPSBmdW5jdGlvbiAoY29tcG9uZW50LCB0ZW1wbGF0ZSwgZGlyZWN0aXZlcywgcGlwZXMsIHNjaGVtYXMsIHRlbXBsYXRlVXJsKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudHJ5UGFyc2VIdG1sKHRoaXMuZXhwYW5kSHRtbCh0aGlzLl9odG1sUGFyc2VyLnBhcnNlKHRlbXBsYXRlLCB0ZW1wbGF0ZVVybCwgdHJ1ZSwgdGhpcy5nZXRJbnRlcnBvbGF0aW9uQ29uZmlnKGNvbXBvbmVudCkpKSwgY29tcG9uZW50LCB0ZW1wbGF0ZSwgZGlyZWN0aXZlcywgcGlwZXMsIHNjaGVtYXMsIHRlbXBsYXRlVXJsKTtcbiAgICAgIH07XG4gICAgICBUZW1wbGF0ZVBhcnNlci5wcm90b3R5cGUudHJ5UGFyc2VIdG1sID0gZnVuY3Rpb24gKGh0bWxBc3RXaXRoRXJyb3JzLCBjb21wb25lbnQsIHRlbXBsYXRlLCBkaXJlY3RpdmVzLCBwaXBlcywgc2NoZW1hcywgdGVtcGxhdGVVcmwpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICAgIHZhciBlcnJvcnMgPSBodG1sQXN0V2l0aEVycm9ycy5lcnJvcnM7XG4gICAgICAgICAgaWYgKGh0bWxBc3RXaXRoRXJyb3JzLnJvb3ROb2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIHZhciB1bmlxRGlyZWN0aXZlcyA9IHJlbW92ZUlkZW50aWZpZXJEdXBsaWNhdGVzKGRpcmVjdGl2ZXMpO1xuICAgICAgICAgICAgICB2YXIgdW5pcVBpcGVzID0gcmVtb3ZlSWRlbnRpZmllckR1cGxpY2F0ZXMocGlwZXMpO1xuICAgICAgICAgICAgICB2YXIgcHJvdmlkZXJWaWV3Q29udGV4dCA9IG5ldyBQcm92aWRlclZpZXdDb250ZXh0KGNvbXBvbmVudCwgaHRtbEFzdFdpdGhFcnJvcnMucm9vdE5vZGVzWzBdLnNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgICB2YXIgaW50ZXJwb2xhdGlvbkNvbmZpZyA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgaWYgKGNvbXBvbmVudC50ZW1wbGF0ZSAmJiBjb21wb25lbnQudGVtcGxhdGUuaW50ZXJwb2xhdGlvbikge1xuICAgICAgICAgICAgICAgICAgaW50ZXJwb2xhdGlvbkNvbmZpZyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICBzdGFydDogY29tcG9uZW50LnRlbXBsYXRlLmludGVycG9sYXRpb25bMF0sXG4gICAgICAgICAgICAgICAgICAgICAgZW5kOiBjb21wb25lbnQudGVtcGxhdGUuaW50ZXJwb2xhdGlvblsxXVxuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2YXIgYmluZGluZ1BhcnNlciA9IG5ldyBCaW5kaW5nUGFyc2VyKHRoaXMuX2V4cHJQYXJzZXIsIGludGVycG9sYXRpb25Db25maWcsIHRoaXMuX3NjaGVtYVJlZ2lzdHJ5LCB1bmlxUGlwZXMsIGVycm9ycyk7XG4gICAgICAgICAgICAgIHZhciBwYXJzZVZpc2l0b3IgPSBuZXcgVGVtcGxhdGVQYXJzZVZpc2l0b3IocHJvdmlkZXJWaWV3Q29udGV4dCwgdW5pcURpcmVjdGl2ZXMsIGJpbmRpbmdQYXJzZXIsIHRoaXMuX3NjaGVtYVJlZ2lzdHJ5LCBzY2hlbWFzLCBlcnJvcnMpO1xuICAgICAgICAgICAgICByZXN1bHQgPSB2aXNpdEFsbChwYXJzZVZpc2l0b3IsIGh0bWxBc3RXaXRoRXJyb3JzLnJvb3ROb2RlcywgRU1QVFlfRUxFTUVOVF9DT05URVhUKTtcbiAgICAgICAgICAgICAgZXJyb3JzLnB1c2guYXBwbHkoZXJyb3JzLCBwcm92aWRlclZpZXdDb250ZXh0LmVycm9ycyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICByZXN1bHQgPSBbXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fYXNzZXJ0Tm9SZWZlcmVuY2VEdXBsaWNhdGlvbk9uVGVtcGxhdGUocmVzdWx0LCBlcnJvcnMpO1xuICAgICAgICAgIGlmIChlcnJvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICByZXR1cm4gbmV3IFRlbXBsYXRlUGFyc2VSZXN1bHQocmVzdWx0LCBlcnJvcnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMudHJhbnNmb3JtcykpIHtcbiAgICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm1zLmZvckVhY2goZnVuY3Rpb24gKHRyYW5zZm9ybSkgeyByZXN1bHQgPSB0ZW1wbGF0ZVZpc2l0QWxsKHRyYW5zZm9ybSwgcmVzdWx0KTsgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuZXcgVGVtcGxhdGVQYXJzZVJlc3VsdChyZXN1bHQsIGVycm9ycyk7XG4gICAgICB9O1xuICAgICAgVGVtcGxhdGVQYXJzZXIucHJvdG90eXBlLmV4cGFuZEh0bWwgPSBmdW5jdGlvbiAoaHRtbEFzdFdpdGhFcnJvcnMsIGZvcmNlZCkge1xuICAgICAgICAgIGlmIChmb3JjZWQgPT09IHZvaWQgMCkgeyBmb3JjZWQgPSBmYWxzZTsgfVxuICAgICAgICAgIHZhciBlcnJvcnMgPSBodG1sQXN0V2l0aEVycm9ycy5lcnJvcnM7XG4gICAgICAgICAgaWYgKGVycm9ycy5sZW5ndGggPT0gMCB8fCBmb3JjZWQpIHtcbiAgICAgICAgICAgICAgLy8gVHJhbnNmb3JtIElDVSBtZXNzYWdlcyB0byBhbmd1bGFyIGRpcmVjdGl2ZXNcbiAgICAgICAgICAgICAgdmFyIGV4cGFuZGVkSHRtbEFzdCA9IGV4cGFuZE5vZGVzKGh0bWxBc3RXaXRoRXJyb3JzLnJvb3ROb2Rlcyk7XG4gICAgICAgICAgICAgIGVycm9ycy5wdXNoLmFwcGx5KGVycm9ycywgZXhwYW5kZWRIdG1sQXN0LmVycm9ycyk7XG4gICAgICAgICAgICAgIGh0bWxBc3RXaXRoRXJyb3JzID0gbmV3IFBhcnNlVHJlZVJlc3VsdChleHBhbmRlZEh0bWxBc3Qubm9kZXMsIGVycm9ycyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBodG1sQXN0V2l0aEVycm9ycztcbiAgICAgIH07XG4gICAgICBUZW1wbGF0ZVBhcnNlci5wcm90b3R5cGUuZ2V0SW50ZXJwb2xhdGlvbkNvbmZpZyA9IGZ1bmN0aW9uIChjb21wb25lbnQpIHtcbiAgICAgICAgICBpZiAoY29tcG9uZW50LnRlbXBsYXRlKSB7XG4gICAgICAgICAgICAgIHJldHVybiBJbnRlcnBvbGF0aW9uQ29uZmlnLmZyb21BcnJheShjb21wb25lbnQudGVtcGxhdGUuaW50ZXJwb2xhdGlvbik7XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgIFRlbXBsYXRlUGFyc2VyLnByb3RvdHlwZS5fYXNzZXJ0Tm9SZWZlcmVuY2VEdXBsaWNhdGlvbk9uVGVtcGxhdGUgPSBmdW5jdGlvbiAocmVzdWx0LCBlcnJvcnMpIHtcbiAgICAgICAgICB2YXIgZXhpc3RpbmdSZWZlcmVuY2VzID0gW107XG4gICAgICAgICAgcmVzdWx0LmZpbHRlcihmdW5jdGlvbiAoZWxlbWVudCkgeyByZXR1cm4gISFlbGVtZW50LnJlZmVyZW5jZXM7IH0pXG4gICAgICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50KSB7IHJldHVybiBlbGVtZW50LnJlZmVyZW5jZXMuZm9yRWFjaChmdW5jdGlvbiAocmVmZXJlbmNlKSB7XG4gICAgICAgICAgICAgIHZhciBuYW1lID0gcmVmZXJlbmNlLm5hbWU7XG4gICAgICAgICAgICAgIGlmIChleGlzdGluZ1JlZmVyZW5jZXMuaW5kZXhPZihuYW1lKSA8IDApIHtcbiAgICAgICAgICAgICAgICAgIGV4aXN0aW5nUmVmZXJlbmNlcy5wdXNoKG5hbWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdmFyIGVycm9yID0gbmV3IFRlbXBsYXRlUGFyc2VFcnJvcihcIlJlZmVyZW5jZSBcXFwiI1wiICsgbmFtZSArIFwiXFxcIiBpcyBkZWZpbmVkIHNldmVyYWwgdGltZXNcIiwgcmVmZXJlbmNlLnNvdXJjZVNwYW4sIGV4cG9ydHMuUGFyc2VFcnJvckxldmVsLkZBVEFMKTtcbiAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKGVycm9yKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0pOyB9KTtcbiAgICAgIH07XG4gICAgICBUZW1wbGF0ZVBhcnNlci5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3RhYmxlIH0sXG4gICAgICBdO1xuICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICBUZW1wbGF0ZVBhcnNlci5jdG9yUGFyYW1ldGVycyA9IFtcbiAgICAgICAgICB7IHR5cGU6IFBhcnNlciwgfSxcbiAgICAgICAgICB7IHR5cGU6IEVsZW1lbnRTY2hlbWFSZWdpc3RyeSwgfSxcbiAgICAgICAgICB7IHR5cGU6IEkxOE5IdG1sUGFyc2VyLCB9LFxuICAgICAgICAgIHsgdHlwZTogQ29uc29sZSwgfSxcbiAgICAgICAgICB7IHR5cGU6IEFycmF5LCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLk9wdGlvbmFsIH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3QsIGFyZ3M6IFtURU1QTEFURV9UUkFOU0ZPUk1TLF0gfSxdIH0sXG4gICAgICBdO1xuICAgICAgcmV0dXJuIFRlbXBsYXRlUGFyc2VyO1xuICB9KCkpO1xuICB2YXIgVGVtcGxhdGVQYXJzZVZpc2l0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gVGVtcGxhdGVQYXJzZVZpc2l0b3IocHJvdmlkZXJWaWV3Q29udGV4dCwgZGlyZWN0aXZlcywgX2JpbmRpbmdQYXJzZXIsIF9zY2hlbWFSZWdpc3RyeSwgX3NjaGVtYXMsIF90YXJnZXRFcnJvcnMpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHRoaXMucHJvdmlkZXJWaWV3Q29udGV4dCA9IHByb3ZpZGVyVmlld0NvbnRleHQ7XG4gICAgICAgICAgdGhpcy5fYmluZGluZ1BhcnNlciA9IF9iaW5kaW5nUGFyc2VyO1xuICAgICAgICAgIHRoaXMuX3NjaGVtYVJlZ2lzdHJ5ID0gX3NjaGVtYVJlZ2lzdHJ5O1xuICAgICAgICAgIHRoaXMuX3NjaGVtYXMgPSBfc2NoZW1hcztcbiAgICAgICAgICB0aGlzLl90YXJnZXRFcnJvcnMgPSBfdGFyZ2V0RXJyb3JzO1xuICAgICAgICAgIHRoaXMuc2VsZWN0b3JNYXRjaGVyID0gbmV3IFNlbGVjdG9yTWF0Y2hlcigpO1xuICAgICAgICAgIHRoaXMuZGlyZWN0aXZlc0luZGV4ID0gbmV3IE1hcCgpO1xuICAgICAgICAgIHRoaXMubmdDb250ZW50Q291bnQgPSAwO1xuICAgICAgICAgIGRpcmVjdGl2ZXMuZm9yRWFjaChmdW5jdGlvbiAoZGlyZWN0aXZlLCBpbmRleCkge1xuICAgICAgICAgICAgICB2YXIgc2VsZWN0b3IgPSBDc3NTZWxlY3Rvci5wYXJzZShkaXJlY3RpdmUuc2VsZWN0b3IpO1xuICAgICAgICAgICAgICBfdGhpcy5zZWxlY3Rvck1hdGNoZXIuYWRkU2VsZWN0YWJsZXMoc2VsZWN0b3IsIGRpcmVjdGl2ZSk7XG4gICAgICAgICAgICAgIF90aGlzLmRpcmVjdGl2ZXNJbmRleC5zZXQoZGlyZWN0aXZlLCBpbmRleCk7XG4gICAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUudmlzaXRFeHBhbnNpb24gPSBmdW5jdGlvbiAoZXhwYW5zaW9uLCBjb250ZXh0KSB7IHJldHVybiBudWxsOyB9O1xuICAgICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0RXhwYW5zaW9uQ2FzZSA9IGZ1bmN0aW9uIChleHBhbnNpb25DYXNlLCBjb250ZXh0KSB7IHJldHVybiBudWxsOyB9O1xuICAgICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0VGV4dCA9IGZ1bmN0aW9uICh0ZXh0LCBwYXJlbnQpIHtcbiAgICAgICAgICB2YXIgbmdDb250ZW50SW5kZXggPSBwYXJlbnQuZmluZE5nQ29udGVudEluZGV4KFRFWFRfQ1NTX1NFTEVDVE9SKTtcbiAgICAgICAgICB2YXIgZXhwciA9IHRoaXMuX2JpbmRpbmdQYXJzZXIucGFyc2VJbnRlcnBvbGF0aW9uKHRleHQudmFsdWUsIHRleHQuc291cmNlU3Bhbik7XG4gICAgICAgICAgaWYgKGlzUHJlc2VudChleHByKSkge1xuICAgICAgICAgICAgICByZXR1cm4gbmV3IEJvdW5kVGV4dEFzdChleHByLCBuZ0NvbnRlbnRJbmRleCwgdGV4dC5zb3VyY2VTcGFuKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgVGV4dEFzdCh0ZXh0LnZhbHVlLCBuZ0NvbnRlbnRJbmRleCwgdGV4dC5zb3VyY2VTcGFuKTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0QXR0cmlidXRlID0gZnVuY3Rpb24gKGF0dHJpYnV0ZSwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiBuZXcgQXR0ckFzdChhdHRyaWJ1dGUubmFtZSwgYXR0cmlidXRlLnZhbHVlLCBhdHRyaWJ1dGUuc291cmNlU3Bhbik7XG4gICAgICB9O1xuICAgICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0Q29tbWVudCA9IGZ1bmN0aW9uIChjb21tZW50LCBjb250ZXh0KSB7IHJldHVybiBudWxsOyB9O1xuICAgICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0RWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtZW50LCBwYXJlbnQpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHZhciBub2RlTmFtZSA9IGVsZW1lbnQubmFtZTtcbiAgICAgICAgICB2YXIgcHJlcGFyc2VkRWxlbWVudCA9IHByZXBhcnNlRWxlbWVudChlbGVtZW50KTtcbiAgICAgICAgICBpZiAocHJlcGFyc2VkRWxlbWVudC50eXBlID09PSBQcmVwYXJzZWRFbGVtZW50VHlwZS5TQ1JJUFQgfHxcbiAgICAgICAgICAgICAgcHJlcGFyc2VkRWxlbWVudC50eXBlID09PSBQcmVwYXJzZWRFbGVtZW50VHlwZS5TVFlMRSkge1xuICAgICAgICAgICAgICAvLyBTa2lwcGluZyA8c2NyaXB0PiBmb3Igc2VjdXJpdHkgcmVhc29uc1xuICAgICAgICAgICAgICAvLyBTa2lwcGluZyA8c3R5bGU+IGFzIHdlIGFscmVhZHkgcHJvY2Vzc2VkIHRoZW1cbiAgICAgICAgICAgICAgLy8gaW4gdGhlIFN0eWxlQ29tcGlsZXJcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwcmVwYXJzZWRFbGVtZW50LnR5cGUgPT09IFByZXBhcnNlZEVsZW1lbnRUeXBlLlNUWUxFU0hFRVQgJiZcbiAgICAgICAgICAgICAgaXNTdHlsZVVybFJlc29sdmFibGUocHJlcGFyc2VkRWxlbWVudC5ocmVmQXR0cikpIHtcbiAgICAgICAgICAgICAgLy8gU2tpcHBpbmcgc3R5bGVzaGVldHMgd2l0aCBlaXRoZXIgcmVsYXRpdmUgdXJscyBvciBwYWNrYWdlIHNjaGVtZSBhcyB3ZSBhbHJlYWR5IHByb2Nlc3NlZFxuICAgICAgICAgICAgICAvLyB0aGVtIGluIHRoZSBTdHlsZUNvbXBpbGVyXG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgbWF0Y2hhYmxlQXR0cnMgPSBbXTtcbiAgICAgICAgICB2YXIgZWxlbWVudE9yRGlyZWN0aXZlUHJvcHMgPSBbXTtcbiAgICAgICAgICB2YXIgZWxlbWVudE9yRGlyZWN0aXZlUmVmcyA9IFtdO1xuICAgICAgICAgIHZhciBlbGVtZW50VmFycyA9IFtdO1xuICAgICAgICAgIHZhciBldmVudHMgPSBbXTtcbiAgICAgICAgICB2YXIgdGVtcGxhdGVFbGVtZW50T3JEaXJlY3RpdmVQcm9wcyA9IFtdO1xuICAgICAgICAgIHZhciB0ZW1wbGF0ZU1hdGNoYWJsZUF0dHJzID0gW107XG4gICAgICAgICAgdmFyIHRlbXBsYXRlRWxlbWVudFZhcnMgPSBbXTtcbiAgICAgICAgICB2YXIgaGFzSW5saW5lVGVtcGxhdGVzID0gZmFsc2U7XG4gICAgICAgICAgdmFyIGF0dHJzID0gW107XG4gICAgICAgICAgdmFyIGxjRWxOYW1lID0gc3BsaXROc05hbWUobm9kZU5hbWUudG9Mb3dlckNhc2UoKSlbMV07XG4gICAgICAgICAgdmFyIGlzVGVtcGxhdGVFbGVtZW50ID0gbGNFbE5hbWUgPT0gVEVNUExBVEVfRUxFTUVOVDtcbiAgICAgICAgICBlbGVtZW50LmF0dHJzLmZvckVhY2goZnVuY3Rpb24gKGF0dHIpIHtcbiAgICAgICAgICAgICAgdmFyIGhhc0JpbmRpbmcgPSBfdGhpcy5fcGFyc2VBdHRyKGlzVGVtcGxhdGVFbGVtZW50LCBhdHRyLCBtYXRjaGFibGVBdHRycywgZWxlbWVudE9yRGlyZWN0aXZlUHJvcHMsIGV2ZW50cywgZWxlbWVudE9yRGlyZWN0aXZlUmVmcywgZWxlbWVudFZhcnMpO1xuICAgICAgICAgICAgICB2YXIgdGVtcGxhdGVCaW5kaW5nc1NvdXJjZTtcbiAgICAgICAgICAgICAgaWYgKF90aGlzLl9ub3JtYWxpemVBdHRyaWJ1dGVOYW1lKGF0dHIubmFtZSkgPT0gVEVNUExBVEVfQVRUUikge1xuICAgICAgICAgICAgICAgICAgdGVtcGxhdGVCaW5kaW5nc1NvdXJjZSA9IGF0dHIudmFsdWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSBpZiAoYXR0ci5uYW1lLnN0YXJ0c1dpdGgoVEVNUExBVEVfQVRUUl9QUkVGSVgpKSB7XG4gICAgICAgICAgICAgICAgICB2YXIga2V5ID0gYXR0ci5uYW1lLnN1YnN0cmluZyhURU1QTEFURV9BVFRSX1BSRUZJWC5sZW5ndGgpOyAvLyByZW1vdmUgdGhlIHN0YXJcbiAgICAgICAgICAgICAgICAgIHRlbXBsYXRlQmluZGluZ3NTb3VyY2UgPSAoYXR0ci52YWx1ZS5sZW5ndGggPT0gMCkgPyBrZXkgOiBrZXkgKyAnICcgKyBhdHRyLnZhbHVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhciBoYXNUZW1wbGF0ZUJpbmRpbmcgPSBpc1ByZXNlbnQodGVtcGxhdGVCaW5kaW5nc1NvdXJjZSk7XG4gICAgICAgICAgICAgIGlmIChoYXNUZW1wbGF0ZUJpbmRpbmcpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChoYXNJbmxpbmVUZW1wbGF0ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcmVwb3J0RXJyb3IoXCJDYW4ndCBoYXZlIG11bHRpcGxlIHRlbXBsYXRlIGJpbmRpbmdzIG9uIG9uZSBlbGVtZW50LiBVc2Ugb25seSBvbmUgYXR0cmlidXRlIG5hbWVkICd0ZW1wbGF0ZScgb3IgcHJlZml4ZWQgd2l0aCAqXCIsIGF0dHIuc291cmNlU3Bhbik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBoYXNJbmxpbmVUZW1wbGF0ZXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgX3RoaXMuX2JpbmRpbmdQYXJzZXIucGFyc2VJbmxpbmVUZW1wbGF0ZUJpbmRpbmcoYXR0ci5uYW1lLCB0ZW1wbGF0ZUJpbmRpbmdzU291cmNlLCBhdHRyLnNvdXJjZVNwYW4sIHRlbXBsYXRlTWF0Y2hhYmxlQXR0cnMsIHRlbXBsYXRlRWxlbWVudE9yRGlyZWN0aXZlUHJvcHMsIHRlbXBsYXRlRWxlbWVudFZhcnMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICghaGFzQmluZGluZyAmJiAhaGFzVGVtcGxhdGVCaW5kaW5nKSB7XG4gICAgICAgICAgICAgICAgICAvLyBkb24ndCBpbmNsdWRlIHRoZSBiaW5kaW5ncyBhcyBhdHRyaWJ1dGVzIGFzIHdlbGwgaW4gdGhlIEFTVFxuICAgICAgICAgICAgICAgICAgYXR0cnMucHVzaChfdGhpcy52aXNpdEF0dHJpYnV0ZShhdHRyLCBudWxsKSk7XG4gICAgICAgICAgICAgICAgICBtYXRjaGFibGVBdHRycy5wdXNoKFthdHRyLm5hbWUsIGF0dHIudmFsdWVdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHZhciBlbGVtZW50Q3NzU2VsZWN0b3IgPSBjcmVhdGVFbGVtZW50Q3NzU2VsZWN0b3Iobm9kZU5hbWUsIG1hdGNoYWJsZUF0dHJzKTtcbiAgICAgICAgICB2YXIgX2EgPSB0aGlzLl9wYXJzZURpcmVjdGl2ZXModGhpcy5zZWxlY3Rvck1hdGNoZXIsIGVsZW1lbnRDc3NTZWxlY3RvciksIGRpcmVjdGl2ZU1ldGFzID0gX2EuZGlyZWN0aXZlcywgbWF0Y2hFbGVtZW50ID0gX2EubWF0Y2hFbGVtZW50O1xuICAgICAgICAgIHZhciByZWZlcmVuY2VzID0gW107XG4gICAgICAgICAgdmFyIGRpcmVjdGl2ZUFzdHMgPSB0aGlzLl9jcmVhdGVEaXJlY3RpdmVBc3RzKGlzVGVtcGxhdGVFbGVtZW50LCBlbGVtZW50Lm5hbWUsIGRpcmVjdGl2ZU1ldGFzLCBlbGVtZW50T3JEaXJlY3RpdmVQcm9wcywgZWxlbWVudE9yRGlyZWN0aXZlUmVmcywgZWxlbWVudC5zb3VyY2VTcGFuLCByZWZlcmVuY2VzKTtcbiAgICAgICAgICB2YXIgZWxlbWVudFByb3BzID0gdGhpcy5fY3JlYXRlRWxlbWVudFByb3BlcnR5QXN0cyhlbGVtZW50Lm5hbWUsIGVsZW1lbnRPckRpcmVjdGl2ZVByb3BzLCBkaXJlY3RpdmVBc3RzKTtcbiAgICAgICAgICB2YXIgaXNWaWV3Um9vdCA9IHBhcmVudC5pc1RlbXBsYXRlRWxlbWVudCB8fCBoYXNJbmxpbmVUZW1wbGF0ZXM7XG4gICAgICAgICAgdmFyIHByb3ZpZGVyQ29udGV4dCA9IG5ldyBQcm92aWRlckVsZW1lbnRDb250ZXh0KHRoaXMucHJvdmlkZXJWaWV3Q29udGV4dCwgcGFyZW50LnByb3ZpZGVyQ29udGV4dCwgaXNWaWV3Um9vdCwgZGlyZWN0aXZlQXN0cywgYXR0cnMsIHJlZmVyZW5jZXMsIGVsZW1lbnQuc291cmNlU3Bhbik7XG4gICAgICAgICAgdmFyIGNoaWxkcmVuID0gdmlzaXRBbGwocHJlcGFyc2VkRWxlbWVudC5ub25CaW5kYWJsZSA/IE5PTl9CSU5EQUJMRV9WSVNJVE9SIDogdGhpcywgZWxlbWVudC5jaGlsZHJlbiwgRWxlbWVudENvbnRleHQuY3JlYXRlKGlzVGVtcGxhdGVFbGVtZW50LCBkaXJlY3RpdmVBc3RzLCBpc1RlbXBsYXRlRWxlbWVudCA/IHBhcmVudC5wcm92aWRlckNvbnRleHQgOiBwcm92aWRlckNvbnRleHQpKTtcbiAgICAgICAgICBwcm92aWRlckNvbnRleHQuYWZ0ZXJFbGVtZW50KCk7XG4gICAgICAgICAgLy8gT3ZlcnJpZGUgdGhlIGFjdHVhbCBzZWxlY3RvciB3aGVuIHRoZSBgbmdQcm9qZWN0QXNgIGF0dHJpYnV0ZSBpcyBwcm92aWRlZFxuICAgICAgICAgIHZhciBwcm9qZWN0aW9uU2VsZWN0b3IgPSBpc1ByZXNlbnQocHJlcGFyc2VkRWxlbWVudC5wcm9qZWN0QXMpID9cbiAgICAgICAgICAgICAgQ3NzU2VsZWN0b3IucGFyc2UocHJlcGFyc2VkRWxlbWVudC5wcm9qZWN0QXMpWzBdIDpcbiAgICAgICAgICAgICAgZWxlbWVudENzc1NlbGVjdG9yO1xuICAgICAgICAgIHZhciBuZ0NvbnRlbnRJbmRleCA9IHBhcmVudC5maW5kTmdDb250ZW50SW5kZXgocHJvamVjdGlvblNlbGVjdG9yKTtcbiAgICAgICAgICB2YXIgcGFyc2VkRWxlbWVudDtcbiAgICAgICAgICBpZiAocHJlcGFyc2VkRWxlbWVudC50eXBlID09PSBQcmVwYXJzZWRFbGVtZW50VHlwZS5OR19DT05URU5UKSB7XG4gICAgICAgICAgICAgIGlmIChlbGVtZW50LmNoaWxkcmVuICYmICFlbGVtZW50LmNoaWxkcmVuLmV2ZXJ5KF9pc0VtcHR5VGV4dE5vZGUpKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihcIjxuZy1jb250ZW50PiBlbGVtZW50IGNhbm5vdCBoYXZlIGNvbnRlbnQuXCIsIGVsZW1lbnQuc291cmNlU3Bhbik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcGFyc2VkRWxlbWVudCA9IG5ldyBOZ0NvbnRlbnRBc3QodGhpcy5uZ0NvbnRlbnRDb3VudCsrLCBoYXNJbmxpbmVUZW1wbGF0ZXMgPyBudWxsIDogbmdDb250ZW50SW5kZXgsIGVsZW1lbnQuc291cmNlU3Bhbik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKGlzVGVtcGxhdGVFbGVtZW50KSB7XG4gICAgICAgICAgICAgIHRoaXMuX2Fzc2VydEFsbEV2ZW50c1B1Ymxpc2hlZEJ5RGlyZWN0aXZlcyhkaXJlY3RpdmVBc3RzLCBldmVudHMpO1xuICAgICAgICAgICAgICB0aGlzLl9hc3NlcnROb0NvbXBvbmVudHNOb3JFbGVtZW50QmluZGluZ3NPblRlbXBsYXRlKGRpcmVjdGl2ZUFzdHMsIGVsZW1lbnRQcm9wcywgZWxlbWVudC5zb3VyY2VTcGFuKTtcbiAgICAgICAgICAgICAgcGFyc2VkRWxlbWVudCA9IG5ldyBFbWJlZGRlZFRlbXBsYXRlQXN0KGF0dHJzLCBldmVudHMsIHJlZmVyZW5jZXMsIGVsZW1lbnRWYXJzLCBwcm92aWRlckNvbnRleHQudHJhbnNmb3JtZWREaXJlY3RpdmVBc3RzLCBwcm92aWRlckNvbnRleHQudHJhbnNmb3JtUHJvdmlkZXJzLCBwcm92aWRlckNvbnRleHQudHJhbnNmb3JtZWRIYXNWaWV3Q29udGFpbmVyLCBjaGlsZHJlbiwgaGFzSW5saW5lVGVtcGxhdGVzID8gbnVsbCA6IG5nQ29udGVudEluZGV4LCBlbGVtZW50LnNvdXJjZVNwYW4pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5fYXNzZXJ0RWxlbWVudEV4aXN0cyhtYXRjaEVsZW1lbnQsIGVsZW1lbnQpO1xuICAgICAgICAgICAgICB0aGlzLl9hc3NlcnRPbmx5T25lQ29tcG9uZW50KGRpcmVjdGl2ZUFzdHMsIGVsZW1lbnQuc291cmNlU3Bhbik7XG4gICAgICAgICAgICAgIHZhciBuZ0NvbnRlbnRJbmRleF8xID0gaGFzSW5saW5lVGVtcGxhdGVzID8gbnVsbCA6IHBhcmVudC5maW5kTmdDb250ZW50SW5kZXgocHJvamVjdGlvblNlbGVjdG9yKTtcbiAgICAgICAgICAgICAgcGFyc2VkRWxlbWVudCA9IG5ldyBFbGVtZW50QXN0KG5vZGVOYW1lLCBhdHRycywgZWxlbWVudFByb3BzLCBldmVudHMsIHJlZmVyZW5jZXMsIHByb3ZpZGVyQ29udGV4dC50cmFuc2Zvcm1lZERpcmVjdGl2ZUFzdHMsIHByb3ZpZGVyQ29udGV4dC50cmFuc2Zvcm1Qcm92aWRlcnMsIHByb3ZpZGVyQ29udGV4dC50cmFuc2Zvcm1lZEhhc1ZpZXdDb250YWluZXIsIGNoaWxkcmVuLCBoYXNJbmxpbmVUZW1wbGF0ZXMgPyBudWxsIDogbmdDb250ZW50SW5kZXhfMSwgZWxlbWVudC5zb3VyY2VTcGFuLCBlbGVtZW50LmVuZFNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgICB0aGlzLl9maW5kQ29tcG9uZW50RGlyZWN0aXZlcyhkaXJlY3RpdmVBc3RzKVxuICAgICAgICAgICAgICAgICAgLmZvckVhY2goZnVuY3Rpb24gKGNvbXBvbmVudERpcmVjdGl2ZUFzdCkgeyByZXR1cm4gX3RoaXMuX3ZhbGlkYXRlRWxlbWVudEFuaW1hdGlvbklucHV0T3V0cHV0cyhjb21wb25lbnREaXJlY3RpdmVBc3QuaG9zdFByb3BlcnRpZXMsIGNvbXBvbmVudERpcmVjdGl2ZUFzdC5ob3N0RXZlbnRzLCBjb21wb25lbnREaXJlY3RpdmVBc3QuZGlyZWN0aXZlLnRlbXBsYXRlKTsgfSk7XG4gICAgICAgICAgICAgIHZhciBjb21wb25lbnRUZW1wbGF0ZSA9IHByb3ZpZGVyQ29udGV4dC52aWV3Q29udGV4dC5jb21wb25lbnQudGVtcGxhdGU7XG4gICAgICAgICAgICAgIHRoaXMuX3ZhbGlkYXRlRWxlbWVudEFuaW1hdGlvbklucHV0T3V0cHV0cyhlbGVtZW50UHJvcHMsIGV2ZW50cywgY29tcG9uZW50VGVtcGxhdGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaGFzSW5saW5lVGVtcGxhdGVzKSB7XG4gICAgICAgICAgICAgIHZhciB0ZW1wbGF0ZUNzc1NlbGVjdG9yID0gY3JlYXRlRWxlbWVudENzc1NlbGVjdG9yKFRFTVBMQVRFX0VMRU1FTlQsIHRlbXBsYXRlTWF0Y2hhYmxlQXR0cnMpO1xuICAgICAgICAgICAgICB2YXIgdGVtcGxhdGVEaXJlY3RpdmVNZXRhcyA9IHRoaXMuX3BhcnNlRGlyZWN0aXZlcyh0aGlzLnNlbGVjdG9yTWF0Y2hlciwgdGVtcGxhdGVDc3NTZWxlY3RvcikuZGlyZWN0aXZlcztcbiAgICAgICAgICAgICAgdmFyIHRlbXBsYXRlRGlyZWN0aXZlQXN0cyA9IHRoaXMuX2NyZWF0ZURpcmVjdGl2ZUFzdHModHJ1ZSwgZWxlbWVudC5uYW1lLCB0ZW1wbGF0ZURpcmVjdGl2ZU1ldGFzLCB0ZW1wbGF0ZUVsZW1lbnRPckRpcmVjdGl2ZVByb3BzLCBbXSwgZWxlbWVudC5zb3VyY2VTcGFuLCBbXSk7XG4gICAgICAgICAgICAgIHZhciB0ZW1wbGF0ZUVsZW1lbnRQcm9wcyA9IHRoaXMuX2NyZWF0ZUVsZW1lbnRQcm9wZXJ0eUFzdHMoZWxlbWVudC5uYW1lLCB0ZW1wbGF0ZUVsZW1lbnRPckRpcmVjdGl2ZVByb3BzLCB0ZW1wbGF0ZURpcmVjdGl2ZUFzdHMpO1xuICAgICAgICAgICAgICB0aGlzLl9hc3NlcnROb0NvbXBvbmVudHNOb3JFbGVtZW50QmluZGluZ3NPblRlbXBsYXRlKHRlbXBsYXRlRGlyZWN0aXZlQXN0cywgdGVtcGxhdGVFbGVtZW50UHJvcHMsIGVsZW1lbnQuc291cmNlU3Bhbik7XG4gICAgICAgICAgICAgIHZhciB0ZW1wbGF0ZVByb3ZpZGVyQ29udGV4dCA9IG5ldyBQcm92aWRlckVsZW1lbnRDb250ZXh0KHRoaXMucHJvdmlkZXJWaWV3Q29udGV4dCwgcGFyZW50LnByb3ZpZGVyQ29udGV4dCwgcGFyZW50LmlzVGVtcGxhdGVFbGVtZW50LCB0ZW1wbGF0ZURpcmVjdGl2ZUFzdHMsIFtdLCBbXSwgZWxlbWVudC5zb3VyY2VTcGFuKTtcbiAgICAgICAgICAgICAgdGVtcGxhdGVQcm92aWRlckNvbnRleHQuYWZ0ZXJFbGVtZW50KCk7XG4gICAgICAgICAgICAgIHBhcnNlZEVsZW1lbnQgPSBuZXcgRW1iZWRkZWRUZW1wbGF0ZUFzdChbXSwgW10sIFtdLCB0ZW1wbGF0ZUVsZW1lbnRWYXJzLCB0ZW1wbGF0ZVByb3ZpZGVyQ29udGV4dC50cmFuc2Zvcm1lZERpcmVjdGl2ZUFzdHMsIHRlbXBsYXRlUHJvdmlkZXJDb250ZXh0LnRyYW5zZm9ybVByb3ZpZGVycywgdGVtcGxhdGVQcm92aWRlckNvbnRleHQudHJhbnNmb3JtZWRIYXNWaWV3Q29udGFpbmVyLCBbcGFyc2VkRWxlbWVudF0sIG5nQ29udGVudEluZGV4LCBlbGVtZW50LnNvdXJjZVNwYW4pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcGFyc2VkRWxlbWVudDtcbiAgICAgIH07XG4gICAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUuX3ZhbGlkYXRlRWxlbWVudEFuaW1hdGlvbklucHV0T3V0cHV0cyA9IGZ1bmN0aW9uIChpbnB1dHMsIG91dHB1dHMsIHRlbXBsYXRlKSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICB2YXIgdHJpZ2dlckxvb2t1cCA9IG5ldyBTZXQoKTtcbiAgICAgICAgICB0ZW1wbGF0ZS5hbmltYXRpb25zLmZvckVhY2goZnVuY3Rpb24gKGVudHJ5KSB7IHRyaWdnZXJMb29rdXAuYWRkKGVudHJ5Lm5hbWUpOyB9KTtcbiAgICAgICAgICB2YXIgYW5pbWF0aW9uSW5wdXRzID0gaW5wdXRzLmZpbHRlcihmdW5jdGlvbiAoaW5wdXQpIHsgcmV0dXJuIGlucHV0LmlzQW5pbWF0aW9uOyB9KTtcbiAgICAgICAgICBhbmltYXRpb25JbnB1dHMuZm9yRWFjaChmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgICAgICAgdmFyIG5hbWUgPSBpbnB1dC5uYW1lO1xuICAgICAgICAgICAgICBpZiAoIXRyaWdnZXJMb29rdXAuaGFzKG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICBfdGhpcy5fcmVwb3J0RXJyb3IoXCJDb3VsZG4ndCBmaW5kIGFuIGFuaW1hdGlvbiBlbnRyeSBmb3IgXFxcIlwiICsgbmFtZSArIFwiXFxcIlwiLCBpbnB1dC5zb3VyY2VTcGFuKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIG91dHB1dHMuZm9yRWFjaChmdW5jdGlvbiAob3V0cHV0KSB7XG4gICAgICAgICAgICAgIGlmIChvdXRwdXQuaXNBbmltYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgIHZhciBmb3VuZCA9IGFuaW1hdGlvbklucHV0cy5maW5kKGZ1bmN0aW9uIChpbnB1dCkgeyByZXR1cm4gaW5wdXQubmFtZSA9PSBvdXRwdXQubmFtZTsgfSk7XG4gICAgICAgICAgICAgICAgICBpZiAoIWZvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3JlcG9ydEVycm9yKFwiVW5hYmxlIHRvIGxpc3RlbiBvbiAoQFwiICsgb3V0cHV0Lm5hbWUgKyBcIi5cIiArIG91dHB1dC5waGFzZSArIFwiKSBiZWNhdXNlIHRoZSBhbmltYXRpb24gdHJpZ2dlciBbQFwiICsgb3V0cHV0Lm5hbWUgKyBcIl0gaXNuJ3QgYmVpbmcgdXNlZCBvbiB0aGUgc2FtZSBlbGVtZW50XCIsIG91dHB1dC5zb3VyY2VTcGFuKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIFRlbXBsYXRlUGFyc2VWaXNpdG9yLnByb3RvdHlwZS5fcGFyc2VBdHRyID0gZnVuY3Rpb24gKGlzVGVtcGxhdGVFbGVtZW50LCBhdHRyLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0UHJvcHMsIHRhcmdldEV2ZW50cywgdGFyZ2V0UmVmcywgdGFyZ2V0VmFycykge1xuICAgICAgICAgIHZhciBuYW1lID0gdGhpcy5fbm9ybWFsaXplQXR0cmlidXRlTmFtZShhdHRyLm5hbWUpO1xuICAgICAgICAgIHZhciB2YWx1ZSA9IGF0dHIudmFsdWU7XG4gICAgICAgICAgdmFyIHNyY1NwYW4gPSBhdHRyLnNvdXJjZVNwYW47XG4gICAgICAgICAgdmFyIGJpbmRQYXJ0cyA9IG5hbWUubWF0Y2goQklORF9OQU1FX1JFR0VYUCk7XG4gICAgICAgICAgdmFyIGhhc0JpbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgICBpZiAoYmluZFBhcnRzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIGhhc0JpbmRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICBpZiAoaXNQcmVzZW50KGJpbmRQYXJ0c1tLV19CSU5EX0lEWF0pKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9iaW5kaW5nUGFyc2VyLnBhcnNlUHJvcGVydHlCaW5kaW5nKGJpbmRQYXJ0c1tJREVOVF9LV19JRFhdLCB2YWx1ZSwgZmFsc2UsIHNyY1NwYW4sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRQcm9wcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSBpZiAoYmluZFBhcnRzW0tXX0xFVF9JRFhdKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoaXNUZW1wbGF0ZUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgaWRlbnRpZmllciA9IGJpbmRQYXJ0c1tJREVOVF9LV19JRFhdO1xuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhcnNlVmFyaWFibGUoaWRlbnRpZmllciwgdmFsdWUsIHNyY1NwYW4sIHRhcmdldFZhcnMpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoXCJcXFwibGV0LVxcXCIgaXMgb25seSBzdXBwb3J0ZWQgb24gdGVtcGxhdGUgZWxlbWVudHMuXCIsIHNyY1NwYW4pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgaWYgKGJpbmRQYXJ0c1tLV19SRUZfSURYXSkge1xuICAgICAgICAgICAgICAgICAgdmFyIGlkZW50aWZpZXIgPSBiaW5kUGFydHNbSURFTlRfS1dfSURYXTtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX3BhcnNlUmVmZXJlbmNlKGlkZW50aWZpZXIsIHZhbHVlLCBzcmNTcGFuLCB0YXJnZXRSZWZzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIGlmIChiaW5kUGFydHNbS1dfT05fSURYXSkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5fYmluZGluZ1BhcnNlci5wYXJzZUV2ZW50KGJpbmRQYXJ0c1tJREVOVF9LV19JRFhdLCB2YWx1ZSwgc3JjU3BhbiwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldEV2ZW50cyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSBpZiAoYmluZFBhcnRzW0tXX0JJTkRPTl9JRFhdKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9iaW5kaW5nUGFyc2VyLnBhcnNlUHJvcGVydHlCaW5kaW5nKGJpbmRQYXJ0c1tJREVOVF9LV19JRFhdLCB2YWx1ZSwgZmFsc2UsIHNyY1NwYW4sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRQcm9wcyk7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9wYXJzZUFzc2lnbm1lbnRFdmVudChiaW5kUGFydHNbSURFTlRfS1dfSURYXSwgdmFsdWUsIHNyY1NwYW4sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRFdmVudHMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgaWYgKGJpbmRQYXJ0c1tLV19BVF9JRFhdKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9iaW5kaW5nUGFyc2VyLnBhcnNlTGl0ZXJhbEF0dHIobmFtZSwgdmFsdWUsIHNyY1NwYW4sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRQcm9wcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSBpZiAoYmluZFBhcnRzW0lERU5UX0JBTkFOQV9CT1hfSURYXSkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5fYmluZGluZ1BhcnNlci5wYXJzZVByb3BlcnR5QmluZGluZyhiaW5kUGFydHNbSURFTlRfQkFOQU5BX0JPWF9JRFhdLCB2YWx1ZSwgZmFsc2UsIHNyY1NwYW4sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRQcm9wcyk7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9wYXJzZUFzc2lnbm1lbnRFdmVudChiaW5kUGFydHNbSURFTlRfQkFOQU5BX0JPWF9JRFhdLCB2YWx1ZSwgc3JjU3BhbiwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldEV2ZW50cyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSBpZiAoYmluZFBhcnRzW0lERU5UX1BST1BFUlRZX0lEWF0pIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2JpbmRpbmdQYXJzZXIucGFyc2VQcm9wZXJ0eUJpbmRpbmcoYmluZFBhcnRzW0lERU5UX1BST1BFUlRZX0lEWF0sIHZhbHVlLCBmYWxzZSwgc3JjU3BhbiwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldFByb3BzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIGlmIChiaW5kUGFydHNbSURFTlRfRVZFTlRfSURYXSkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5fYmluZGluZ1BhcnNlci5wYXJzZUV2ZW50KGJpbmRQYXJ0c1tJREVOVF9FVkVOVF9JRFhdLCB2YWx1ZSwgc3JjU3BhbiwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldEV2ZW50cyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGhhc0JpbmRpbmcgPSB0aGlzLl9iaW5kaW5nUGFyc2VyLnBhcnNlUHJvcGVydHlJbnRlcnBvbGF0aW9uKG5hbWUsIHZhbHVlLCBzcmNTcGFuLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0UHJvcHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWhhc0JpbmRpbmcpIHtcbiAgICAgICAgICAgICAgdGhpcy5fYmluZGluZ1BhcnNlci5wYXJzZUxpdGVyYWxBdHRyKG5hbWUsIHZhbHVlLCBzcmNTcGFuLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0UHJvcHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gaGFzQmluZGluZztcbiAgICAgIH07XG4gICAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUuX25vcm1hbGl6ZUF0dHJpYnV0ZU5hbWUgPSBmdW5jdGlvbiAoYXR0ck5hbWUpIHtcbiAgICAgICAgICByZXR1cm4gL15kYXRhLS9pLnRlc3QoYXR0ck5hbWUpID8gYXR0ck5hbWUuc3Vic3RyaW5nKDUpIDogYXR0ck5hbWU7XG4gICAgICB9O1xuICAgICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLl9wYXJzZVZhcmlhYmxlID0gZnVuY3Rpb24gKGlkZW50aWZpZXIsIHZhbHVlLCBzb3VyY2VTcGFuLCB0YXJnZXRWYXJzKSB7XG4gICAgICAgICAgaWYgKGlkZW50aWZpZXIuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoXCJcXFwiLVxcXCIgaXMgbm90IGFsbG93ZWQgaW4gdmFyaWFibGUgbmFtZXNcIiwgc291cmNlU3Bhbik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRhcmdldFZhcnMucHVzaChuZXcgVmFyaWFibGVBc3QoaWRlbnRpZmllciwgdmFsdWUsIHNvdXJjZVNwYW4pKTtcbiAgICAgIH07XG4gICAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUuX3BhcnNlUmVmZXJlbmNlID0gZnVuY3Rpb24gKGlkZW50aWZpZXIsIHZhbHVlLCBzb3VyY2VTcGFuLCB0YXJnZXRSZWZzKSB7XG4gICAgICAgICAgaWYgKGlkZW50aWZpZXIuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoXCJcXFwiLVxcXCIgaXMgbm90IGFsbG93ZWQgaW4gcmVmZXJlbmNlIG5hbWVzXCIsIHNvdXJjZVNwYW4pO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0YXJnZXRSZWZzLnB1c2gobmV3IEVsZW1lbnRPckRpcmVjdGl2ZVJlZihpZGVudGlmaWVyLCB2YWx1ZSwgc291cmNlU3BhbikpO1xuICAgICAgfTtcbiAgICAgIFRlbXBsYXRlUGFyc2VWaXNpdG9yLnByb3RvdHlwZS5fcGFyc2VBc3NpZ25tZW50RXZlbnQgPSBmdW5jdGlvbiAobmFtZSwgZXhwcmVzc2lvbiwgc291cmNlU3BhbiwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldEV2ZW50cykge1xuICAgICAgICAgIHRoaXMuX2JpbmRpbmdQYXJzZXIucGFyc2VFdmVudChuYW1lICsgXCJDaGFuZ2VcIiwgZXhwcmVzc2lvbiArIFwiPSRldmVudFwiLCBzb3VyY2VTcGFuLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0RXZlbnRzKTtcbiAgICAgIH07XG4gICAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUuX3BhcnNlRGlyZWN0aXZlcyA9IGZ1bmN0aW9uIChzZWxlY3Rvck1hdGNoZXIsIGVsZW1lbnRDc3NTZWxlY3Rvcikge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgLy8gTmVlZCB0byBzb3J0IHRoZSBkaXJlY3RpdmVzIHNvIHRoYXQgd2UgZ2V0IGNvbnNpc3RlbnQgcmVzdWx0cyB0aHJvdWdob3V0LFxuICAgICAgICAgIC8vIGFzIHNlbGVjdG9yTWF0Y2hlciB1c2VzIE1hcHMgaW5zaWRlLlxuICAgICAgICAgIC8vIEFsc28gZGVkdXBsaWNhdGUgZGlyZWN0aXZlcyBhcyB0aGV5IG1pZ2h0IG1hdGNoIG1vcmUgdGhhbiBvbmUgdGltZSFcbiAgICAgICAgICB2YXIgZGlyZWN0aXZlcyA9IG5ldyBBcnJheSh0aGlzLmRpcmVjdGl2ZXNJbmRleC5zaXplKTtcbiAgICAgICAgICAvLyBXaGV0aGVyIGFueSBkaXJlY3RpdmUgc2VsZWN0b3IgbWF0Y2hlcyBvbiB0aGUgZWxlbWVudCBuYW1lXG4gICAgICAgICAgdmFyIG1hdGNoRWxlbWVudCA9IGZhbHNlO1xuICAgICAgICAgIHNlbGVjdG9yTWF0Y2hlci5tYXRjaChlbGVtZW50Q3NzU2VsZWN0b3IsIGZ1bmN0aW9uIChzZWxlY3RvciwgZGlyZWN0aXZlKSB7XG4gICAgICAgICAgICAgIGRpcmVjdGl2ZXNbX3RoaXMuZGlyZWN0aXZlc0luZGV4LmdldChkaXJlY3RpdmUpXSA9IGRpcmVjdGl2ZTtcbiAgICAgICAgICAgICAgbWF0Y2hFbGVtZW50ID0gbWF0Y2hFbGVtZW50IHx8IHNlbGVjdG9yLmhhc0VsZW1lbnRTZWxlY3RvcigpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGRpcmVjdGl2ZXM6IGRpcmVjdGl2ZXMuZmlsdGVyKGZ1bmN0aW9uIChkaXIpIHsgcmV0dXJuICEhZGlyOyB9KSxcbiAgICAgICAgICAgICAgbWF0Y2hFbGVtZW50OiBtYXRjaEVsZW1lbnQsXG4gICAgICAgICAgfTtcbiAgICAgIH07XG4gICAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUuX2NyZWF0ZURpcmVjdGl2ZUFzdHMgPSBmdW5jdGlvbiAoaXNUZW1wbGF0ZUVsZW1lbnQsIGVsZW1lbnROYW1lLCBkaXJlY3RpdmVzLCBwcm9wcywgZWxlbWVudE9yRGlyZWN0aXZlUmVmcywgZWxlbWVudFNvdXJjZVNwYW4sIHRhcmdldFJlZmVyZW5jZXMpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHZhciBtYXRjaGVkUmVmZXJlbmNlcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgICB2YXIgY29tcG9uZW50ID0gbnVsbDtcbiAgICAgICAgICB2YXIgZGlyZWN0aXZlQXN0cyA9IGRpcmVjdGl2ZXMubWFwKGZ1bmN0aW9uIChkaXJlY3RpdmUpIHtcbiAgICAgICAgICAgICAgdmFyIHNvdXJjZVNwYW4gPSBuZXcgUGFyc2VTb3VyY2VTcGFuKGVsZW1lbnRTb3VyY2VTcGFuLnN0YXJ0LCBlbGVtZW50U291cmNlU3Bhbi5lbmQsIFwiRGlyZWN0aXZlIFwiICsgZGlyZWN0aXZlLnR5cGUubmFtZSk7XG4gICAgICAgICAgICAgIGlmIChkaXJlY3RpdmUuaXNDb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICAgIGNvbXBvbmVudCA9IGRpcmVjdGl2ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2YXIgZGlyZWN0aXZlUHJvcGVydGllcyA9IFtdO1xuICAgICAgICAgICAgICB2YXIgaG9zdFByb3BlcnRpZXMgPSBfdGhpcy5fYmluZGluZ1BhcnNlci5jcmVhdGVEaXJlY3RpdmVIb3N0UHJvcGVydHlBc3RzKGRpcmVjdGl2ZSwgc291cmNlU3Bhbik7XG4gICAgICAgICAgICAgIC8vIE5vdGU6IFdlIG5lZWQgdG8gY2hlY2sgdGhlIGhvc3QgcHJvcGVydGllcyBoZXJlIGFzIHdlbGwsXG4gICAgICAgICAgICAgIC8vIGFzIHdlIGRvbid0IGtub3cgdGhlIGVsZW1lbnQgbmFtZSBpbiB0aGUgRGlyZWN0aXZlV3JhcHBlckNvbXBpbGVyIHlldC5cbiAgICAgICAgICAgICAgX3RoaXMuX2NoZWNrUHJvcGVydGllc0luU2NoZW1hKGVsZW1lbnROYW1lLCBob3N0UHJvcGVydGllcyk7XG4gICAgICAgICAgICAgIHZhciBob3N0RXZlbnRzID0gX3RoaXMuX2JpbmRpbmdQYXJzZXIuY3JlYXRlRGlyZWN0aXZlSG9zdEV2ZW50QXN0cyhkaXJlY3RpdmUsIHNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgICBfdGhpcy5fY3JlYXRlRGlyZWN0aXZlUHJvcGVydHlBc3RzKGRpcmVjdGl2ZS5pbnB1dHMsIHByb3BzLCBkaXJlY3RpdmVQcm9wZXJ0aWVzKTtcbiAgICAgICAgICAgICAgZWxlbWVudE9yRGlyZWN0aXZlUmVmcy5mb3JFYWNoKGZ1bmN0aW9uIChlbE9yRGlyUmVmKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoKGVsT3JEaXJSZWYudmFsdWUubGVuZ3RoID09PSAwICYmIGRpcmVjdGl2ZS5pc0NvbXBvbmVudCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAoZGlyZWN0aXZlLmV4cG9ydEFzID09IGVsT3JEaXJSZWYudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0UmVmZXJlbmNlcy5wdXNoKG5ldyBSZWZlcmVuY2VBc3QoZWxPckRpclJlZi5uYW1lLCBpZGVudGlmaWVyVG9rZW4oZGlyZWN0aXZlLnR5cGUpLCBlbE9yRGlyUmVmLnNvdXJjZVNwYW4pKTtcbiAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVkUmVmZXJlbmNlcy5hZGQoZWxPckRpclJlZi5uYW1lKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgRGlyZWN0aXZlQXN0KGRpcmVjdGl2ZSwgZGlyZWN0aXZlUHJvcGVydGllcywgaG9zdFByb3BlcnRpZXMsIGhvc3RFdmVudHMsIHNvdXJjZVNwYW4pO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGVsZW1lbnRPckRpcmVjdGl2ZVJlZnMuZm9yRWFjaChmdW5jdGlvbiAoZWxPckRpclJlZikge1xuICAgICAgICAgICAgICBpZiAoZWxPckRpclJlZi52YWx1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoIW1hdGNoZWRSZWZlcmVuY2VzLmhhcyhlbE9yRGlyUmVmLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3JlcG9ydEVycm9yKFwiVGhlcmUgaXMgbm8gZGlyZWN0aXZlIHdpdGggXFxcImV4cG9ydEFzXFxcIiBzZXQgdG8gXFxcIlwiICsgZWxPckRpclJlZi52YWx1ZSArIFwiXFxcIlwiLCBlbE9yRGlyUmVmLnNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgaWYgKCFjb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICAgIHZhciByZWZUb2tlbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgICBpZiAoaXNUZW1wbGF0ZUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZWZUb2tlbiA9IHJlc29sdmVJZGVudGlmaWVyVG9rZW4oSWRlbnRpZmllcnMuVGVtcGxhdGVSZWYpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgdGFyZ2V0UmVmZXJlbmNlcy5wdXNoKG5ldyBSZWZlcmVuY2VBc3QoZWxPckRpclJlZi5uYW1lLCByZWZUb2tlbiwgZWxPckRpclJlZi5zb3VyY2VTcGFuKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTsgLy8gZml4IHN5bnRheCBoaWdobGlnaHRpbmcgaXNzdWU6IGBcbiAgICAgICAgICByZXR1cm4gZGlyZWN0aXZlQXN0cztcbiAgICAgIH07XG4gICAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUuX2NyZWF0ZURpcmVjdGl2ZVByb3BlcnR5QXN0cyA9IGZ1bmN0aW9uIChkaXJlY3RpdmVQcm9wZXJ0aWVzLCBib3VuZFByb3BzLCB0YXJnZXRCb3VuZERpcmVjdGl2ZVByb3BzKSB7XG4gICAgICAgICAgaWYgKGRpcmVjdGl2ZVByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgdmFyIGJvdW5kUHJvcHNCeU5hbWVfMSA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgICAgYm91bmRQcm9wcy5mb3JFYWNoKGZ1bmN0aW9uIChib3VuZFByb3ApIHtcbiAgICAgICAgICAgICAgICAgIHZhciBwcmV2VmFsdWUgPSBib3VuZFByb3BzQnlOYW1lXzEuZ2V0KGJvdW5kUHJvcC5uYW1lKTtcbiAgICAgICAgICAgICAgICAgIGlmICghcHJldlZhbHVlIHx8IHByZXZWYWx1ZS5pc0xpdGVyYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBnaXZlIFthXT1cImJcIiBhIGhpZ2hlciBwcmVjZWRlbmNlIHRoYW4gYT1cImJcIiBvbiB0aGUgc2FtZSBlbGVtZW50XG4gICAgICAgICAgICAgICAgICAgICAgYm91bmRQcm9wc0J5TmFtZV8xLnNldChib3VuZFByb3AubmFtZSwgYm91bmRQcm9wKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIE9iamVjdC5rZXlzKGRpcmVjdGl2ZVByb3BlcnRpZXMpLmZvckVhY2goZnVuY3Rpb24gKGRpclByb3ApIHtcbiAgICAgICAgICAgICAgICAgIHZhciBlbFByb3AgPSBkaXJlY3RpdmVQcm9wZXJ0aWVzW2RpclByb3BdO1xuICAgICAgICAgICAgICAgICAgdmFyIGJvdW5kUHJvcCA9IGJvdW5kUHJvcHNCeU5hbWVfMS5nZXQoZWxQcm9wKTtcbiAgICAgICAgICAgICAgICAgIC8vIEJpbmRpbmdzIGFyZSBvcHRpb25hbCwgc28gdGhpcyBiaW5kaW5nIG9ubHkgbmVlZHMgdG8gYmUgc2V0IHVwIGlmIGFuIGV4cHJlc3Npb24gaXMgZ2l2ZW4uXG4gICAgICAgICAgICAgICAgICBpZiAoYm91bmRQcm9wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Qm91bmREaXJlY3RpdmVQcm9wcy5wdXNoKG5ldyBCb3VuZERpcmVjdGl2ZVByb3BlcnR5QXN0KGRpclByb3AsIGJvdW5kUHJvcC5uYW1lLCBib3VuZFByb3AuZXhwcmVzc2lvbiwgYm91bmRQcm9wLnNvdXJjZVNwYW4pKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIFRlbXBsYXRlUGFyc2VWaXNpdG9yLnByb3RvdHlwZS5fY3JlYXRlRWxlbWVudFByb3BlcnR5QXN0cyA9IGZ1bmN0aW9uIChlbGVtZW50TmFtZSwgcHJvcHMsIGRpcmVjdGl2ZXMpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHZhciBib3VuZEVsZW1lbnRQcm9wcyA9IFtdO1xuICAgICAgICAgIHZhciBib3VuZERpcmVjdGl2ZVByb3BzSW5kZXggPSBuZXcgTWFwKCk7XG4gICAgICAgICAgZGlyZWN0aXZlcy5mb3JFYWNoKGZ1bmN0aW9uIChkaXJlY3RpdmUpIHtcbiAgICAgICAgICAgICAgZGlyZWN0aXZlLmlucHV0cy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgICAgICAgICBib3VuZERpcmVjdGl2ZVByb3BzSW5kZXguc2V0KHByb3AudGVtcGxhdGVOYW1lLCBwcm9wKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcHJvcHMuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgICAgICBpZiAoIXByb3AuaXNMaXRlcmFsICYmICFib3VuZERpcmVjdGl2ZVByb3BzSW5kZXguZ2V0KHByb3AubmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgIGJvdW5kRWxlbWVudFByb3BzLnB1c2goX3RoaXMuX2JpbmRpbmdQYXJzZXIuY3JlYXRlRWxlbWVudFByb3BlcnR5QXN0KGVsZW1lbnROYW1lLCBwcm9wKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLl9jaGVja1Byb3BlcnRpZXNJblNjaGVtYShlbGVtZW50TmFtZSwgYm91bmRFbGVtZW50UHJvcHMpO1xuICAgICAgICAgIHJldHVybiBib3VuZEVsZW1lbnRQcm9wcztcbiAgICAgIH07XG4gICAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUuX2ZpbmRDb21wb25lbnREaXJlY3RpdmVzID0gZnVuY3Rpb24gKGRpcmVjdGl2ZXMpIHtcbiAgICAgICAgICByZXR1cm4gZGlyZWN0aXZlcy5maWx0ZXIoZnVuY3Rpb24gKGRpcmVjdGl2ZSkgeyByZXR1cm4gZGlyZWN0aXZlLmRpcmVjdGl2ZS5pc0NvbXBvbmVudDsgfSk7XG4gICAgICB9O1xuICAgICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLl9maW5kQ29tcG9uZW50RGlyZWN0aXZlTmFtZXMgPSBmdW5jdGlvbiAoZGlyZWN0aXZlcykge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9maW5kQ29tcG9uZW50RGlyZWN0aXZlcyhkaXJlY3RpdmVzKVxuICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChkaXJlY3RpdmUpIHsgcmV0dXJuIGRpcmVjdGl2ZS5kaXJlY3RpdmUudHlwZS5uYW1lOyB9KTtcbiAgICAgIH07XG4gICAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUuX2Fzc2VydE9ubHlPbmVDb21wb25lbnQgPSBmdW5jdGlvbiAoZGlyZWN0aXZlcywgc291cmNlU3Bhbikge1xuICAgICAgICAgIHZhciBjb21wb25lbnRUeXBlTmFtZXMgPSB0aGlzLl9maW5kQ29tcG9uZW50RGlyZWN0aXZlTmFtZXMoZGlyZWN0aXZlcyk7XG4gICAgICAgICAgaWYgKGNvbXBvbmVudFR5cGVOYW1lcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKFwiTW9yZSB0aGFuIG9uZSBjb21wb25lbnQ6IFwiICsgY29tcG9uZW50VHlwZU5hbWVzLmpvaW4oJywnKSwgc291cmNlU3Bhbik7XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIC8qKlxuICAgICAgICogTWFrZSBzdXJlIHRoYXQgbm9uLWFuZ3VsYXIgdGFncyBjb25mb3JtIHRvIHRoZSBzY2hlbWFzLlxuICAgICAgICpcbiAgICAgICAqIE5vdGU6IEFuIGVsZW1lbnQgaXMgY29uc2lkZXJlZCBhbiBhbmd1bGFyIHRhZyB3aGVuIGF0IGxlYXN0IG9uZSBkaXJlY3RpdmUgc2VsZWN0b3IgbWF0Y2hlcyB0aGVcbiAgICAgICAqIHRhZyBuYW1lLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSBtYXRjaEVsZW1lbnQgV2hldGhlciBhbnkgZGlyZWN0aXZlIGhhcyBtYXRjaGVkIG9uIHRoZSB0YWcgbmFtZVxuICAgICAgICogQHBhcmFtIGVsZW1lbnQgdGhlIGh0bWwgZWxlbWVudFxuICAgICAgICovXG4gICAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUuX2Fzc2VydEVsZW1lbnRFeGlzdHMgPSBmdW5jdGlvbiAobWF0Y2hFbGVtZW50LCBlbGVtZW50KSB7XG4gICAgICAgICAgdmFyIGVsTmFtZSA9IGVsZW1lbnQubmFtZS5yZXBsYWNlKC9eOnhodG1sOi8sICcnKTtcbiAgICAgICAgICBpZiAoIW1hdGNoRWxlbWVudCAmJiAhdGhpcy5fc2NoZW1hUmVnaXN0cnkuaGFzRWxlbWVudChlbE5hbWUsIHRoaXMuX3NjaGVtYXMpKSB7XG4gICAgICAgICAgICAgIHZhciBlcnJvck1zZyA9IChcIidcIiArIGVsTmFtZSArIFwiJyBpcyBub3QgYSBrbm93biBlbGVtZW50OlxcblwiKSArXG4gICAgICAgICAgICAgICAgICAoXCIxLiBJZiAnXCIgKyBlbE5hbWUgKyBcIicgaXMgYW4gQW5ndWxhciBjb21wb25lbnQsIHRoZW4gdmVyaWZ5IHRoYXQgaXQgaXMgcGFydCBvZiB0aGlzIG1vZHVsZS5cXG5cIikgK1xuICAgICAgICAgICAgICAgICAgKFwiMi4gSWYgJ1wiICsgZWxOYW1lICsgXCInIGlzIGEgV2ViIENvbXBvbmVudCB0aGVuIGFkZCBcXFwiQ1VTVE9NX0VMRU1FTlRTX1NDSEVNQVxcXCIgdG8gdGhlICdATmdNb2R1bGUuc2NoZW1hcycgb2YgdGhpcyBjb21wb25lbnQgdG8gc3VwcHJlc3MgdGhpcyBtZXNzYWdlLlwiKTtcbiAgICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoZXJyb3JNc2csIGVsZW1lbnQuc291cmNlU3Bhbik7XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIFRlbXBsYXRlUGFyc2VWaXNpdG9yLnByb3RvdHlwZS5fYXNzZXJ0Tm9Db21wb25lbnRzTm9yRWxlbWVudEJpbmRpbmdzT25UZW1wbGF0ZSA9IGZ1bmN0aW9uIChkaXJlY3RpdmVzLCBlbGVtZW50UHJvcHMsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHZhciBjb21wb25lbnRUeXBlTmFtZXMgPSB0aGlzLl9maW5kQ29tcG9uZW50RGlyZWN0aXZlTmFtZXMoZGlyZWN0aXZlcyk7XG4gICAgICAgICAgaWYgKGNvbXBvbmVudFR5cGVOYW1lcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKFwiQ29tcG9uZW50cyBvbiBhbiBlbWJlZGRlZCB0ZW1wbGF0ZTogXCIgKyBjb21wb25lbnRUeXBlTmFtZXMuam9pbignLCcpLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxlbWVudFByb3BzLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICAgICAgX3RoaXMuX3JlcG9ydEVycm9yKFwiUHJvcGVydHkgYmluZGluZyBcIiArIHByb3AubmFtZSArIFwiIG5vdCB1c2VkIGJ5IGFueSBkaXJlY3RpdmUgb24gYW4gZW1iZWRkZWQgdGVtcGxhdGUuIE1ha2Ugc3VyZSB0aGF0IHRoZSBwcm9wZXJ0eSBuYW1lIGlzIHNwZWxsZWQgY29ycmVjdGx5IGFuZCBhbGwgZGlyZWN0aXZlcyBhcmUgbGlzdGVkIGluIHRoZSBcXFwiZGlyZWN0aXZlc1xcXCIgc2VjdGlvbi5cIiwgc291cmNlU3Bhbik7XG4gICAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLl9hc3NlcnRBbGxFdmVudHNQdWJsaXNoZWRCeURpcmVjdGl2ZXMgPSBmdW5jdGlvbiAoZGlyZWN0aXZlcywgZXZlbnRzKSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICB2YXIgYWxsRGlyZWN0aXZlRXZlbnRzID0gbmV3IFNldCgpO1xuICAgICAgICAgIGRpcmVjdGl2ZXMuZm9yRWFjaChmdW5jdGlvbiAoZGlyZWN0aXZlKSB7XG4gICAgICAgICAgICAgIE9iamVjdC5rZXlzKGRpcmVjdGl2ZS5kaXJlY3RpdmUub3V0cHV0cykuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgICAgICAgdmFyIGV2ZW50TmFtZSA9IGRpcmVjdGl2ZS5kaXJlY3RpdmUub3V0cHV0c1trXTtcbiAgICAgICAgICAgICAgICAgIGFsbERpcmVjdGl2ZUV2ZW50cy5hZGQoZXZlbnROYW1lKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgIGlmIChpc1ByZXNlbnQoZXZlbnQudGFyZ2V0KSB8fCAhYWxsRGlyZWN0aXZlRXZlbnRzLmhhcyhldmVudC5uYW1lKSkge1xuICAgICAgICAgICAgICAgICAgX3RoaXMuX3JlcG9ydEVycm9yKFwiRXZlbnQgYmluZGluZyBcIiArIGV2ZW50LmZ1bGxOYW1lICsgXCIgbm90IGVtaXR0ZWQgYnkgYW55IGRpcmVjdGl2ZSBvbiBhbiBlbWJlZGRlZCB0ZW1wbGF0ZS4gTWFrZSBzdXJlIHRoYXQgdGhlIGV2ZW50IG5hbWUgaXMgc3BlbGxlZCBjb3JyZWN0bHkgYW5kIGFsbCBkaXJlY3RpdmVzIGFyZSBsaXN0ZWQgaW4gdGhlIFxcXCJkaXJlY3RpdmVzXFxcIiBzZWN0aW9uLlwiLCBldmVudC5zb3VyY2VTcGFuKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIFRlbXBsYXRlUGFyc2VWaXNpdG9yLnByb3RvdHlwZS5fY2hlY2tQcm9wZXJ0aWVzSW5TY2hlbWEgPSBmdW5jdGlvbiAoZWxlbWVudE5hbWUsIGJvdW5kUHJvcHMpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIGJvdW5kUHJvcHMuZm9yRWFjaChmdW5jdGlvbiAoYm91bmRQcm9wKSB7XG4gICAgICAgICAgICAgIGlmIChib3VuZFByb3AudHlwZSA9PT0gZXhwb3J0cy5Qcm9wZXJ0eUJpbmRpbmdUeXBlLlByb3BlcnR5ICYmXG4gICAgICAgICAgICAgICAgICAhX3RoaXMuX3NjaGVtYVJlZ2lzdHJ5Lmhhc1Byb3BlcnR5KGVsZW1lbnROYW1lLCBib3VuZFByb3AubmFtZSwgX3RoaXMuX3NjaGVtYXMpKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgZXJyb3JNc2cgPSBcIkNhbid0IGJpbmQgdG8gJ1wiICsgYm91bmRQcm9wLm5hbWUgKyBcIicgc2luY2UgaXQgaXNuJ3QgYSBrbm93biBwcm9wZXJ0eSBvZiAnXCIgKyBlbGVtZW50TmFtZSArIFwiJy5cIjtcbiAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50TmFtZS5pbmRleE9mKCctJykgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgIGVycm9yTXNnICs9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIChcIlxcbjEuIElmICdcIiArIGVsZW1lbnROYW1lICsgXCInIGlzIGFuIEFuZ3VsYXIgY29tcG9uZW50IGFuZCBpdCBoYXMgJ1wiICsgYm91bmRQcm9wLm5hbWUgKyBcIicgaW5wdXQsIHRoZW4gdmVyaWZ5IHRoYXQgaXQgaXMgcGFydCBvZiB0aGlzIG1vZHVsZS5cIikgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKFwiXFxuMi4gSWYgJ1wiICsgZWxlbWVudE5hbWUgKyBcIicgaXMgYSBXZWIgQ29tcG9uZW50IHRoZW4gYWRkIFxcXCJDVVNUT01fRUxFTUVOVFNfU0NIRU1BXFxcIiB0byB0aGUgJ0BOZ01vZHVsZS5zY2hlbWFzJyBvZiB0aGlzIGNvbXBvbmVudCB0byBzdXBwcmVzcyB0aGlzIG1lc3NhZ2UuXFxuXCIpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgX3RoaXMuX3JlcG9ydEVycm9yKGVycm9yTXNnLCBib3VuZFByb3Auc291cmNlU3Bhbik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUuX3JlcG9ydEVycm9yID0gZnVuY3Rpb24gKG1lc3NhZ2UsIHNvdXJjZVNwYW4sIGxldmVsKSB7XG4gICAgICAgICAgaWYgKGxldmVsID09PSB2b2lkIDApIHsgbGV2ZWwgPSBleHBvcnRzLlBhcnNlRXJyb3JMZXZlbC5GQVRBTDsgfVxuICAgICAgICAgIHRoaXMuX3RhcmdldEVycm9ycy5wdXNoKG5ldyBQYXJzZUVycm9yKHNvdXJjZVNwYW4sIG1lc3NhZ2UsIGxldmVsKSk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIFRlbXBsYXRlUGFyc2VWaXNpdG9yO1xuICB9KCkpO1xuICB2YXIgTm9uQmluZGFibGVWaXNpdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIE5vbkJpbmRhYmxlVmlzaXRvcigpIHtcbiAgICAgIH1cbiAgICAgIE5vbkJpbmRhYmxlVmlzaXRvci5wcm90b3R5cGUudmlzaXRFbGVtZW50ID0gZnVuY3Rpb24gKGFzdCwgcGFyZW50KSB7XG4gICAgICAgICAgdmFyIHByZXBhcnNlZEVsZW1lbnQgPSBwcmVwYXJzZUVsZW1lbnQoYXN0KTtcbiAgICAgICAgICBpZiAocHJlcGFyc2VkRWxlbWVudC50eXBlID09PSBQcmVwYXJzZWRFbGVtZW50VHlwZS5TQ1JJUFQgfHxcbiAgICAgICAgICAgICAgcHJlcGFyc2VkRWxlbWVudC50eXBlID09PSBQcmVwYXJzZWRFbGVtZW50VHlwZS5TVFlMRSB8fFxuICAgICAgICAgICAgICBwcmVwYXJzZWRFbGVtZW50LnR5cGUgPT09IFByZXBhcnNlZEVsZW1lbnRUeXBlLlNUWUxFU0hFRVQpIHtcbiAgICAgICAgICAgICAgLy8gU2tpcHBpbmcgPHNjcmlwdD4gZm9yIHNlY3VyaXR5IHJlYXNvbnNcbiAgICAgICAgICAgICAgLy8gU2tpcHBpbmcgPHN0eWxlPiBhbmQgc3R5bGVzaGVldHMgYXMgd2UgYWxyZWFkeSBwcm9jZXNzZWQgdGhlbVxuICAgICAgICAgICAgICAvLyBpbiB0aGUgU3R5bGVDb21waWxlclxuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGF0dHJOYW1lQW5kVmFsdWVzID0gYXN0LmF0dHJzLm1hcChmdW5jdGlvbiAoYXR0ckFzdCkgeyByZXR1cm4gW2F0dHJBc3QubmFtZSwgYXR0ckFzdC52YWx1ZV07IH0pO1xuICAgICAgICAgIHZhciBzZWxlY3RvciA9IGNyZWF0ZUVsZW1lbnRDc3NTZWxlY3Rvcihhc3QubmFtZSwgYXR0ck5hbWVBbmRWYWx1ZXMpO1xuICAgICAgICAgIHZhciBuZ0NvbnRlbnRJbmRleCA9IHBhcmVudC5maW5kTmdDb250ZW50SW5kZXgoc2VsZWN0b3IpO1xuICAgICAgICAgIHZhciBjaGlsZHJlbiA9IHZpc2l0QWxsKHRoaXMsIGFzdC5jaGlsZHJlbiwgRU1QVFlfRUxFTUVOVF9DT05URVhUKTtcbiAgICAgICAgICByZXR1cm4gbmV3IEVsZW1lbnRBc3QoYXN0Lm5hbWUsIHZpc2l0QWxsKHRoaXMsIGFzdC5hdHRycyksIFtdLCBbXSwgW10sIFtdLCBbXSwgZmFsc2UsIGNoaWxkcmVuLCBuZ0NvbnRlbnRJbmRleCwgYXN0LnNvdXJjZVNwYW4sIGFzdC5lbmRTb3VyY2VTcGFuKTtcbiAgICAgIH07XG4gICAgICBOb25CaW5kYWJsZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0Q29tbWVudCA9IGZ1bmN0aW9uIChjb21tZW50LCBjb250ZXh0KSB7IHJldHVybiBudWxsOyB9O1xuICAgICAgTm9uQmluZGFibGVWaXNpdG9yLnByb3RvdHlwZS52aXNpdEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChhdHRyaWJ1dGUsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IEF0dHJBc3QoYXR0cmlidXRlLm5hbWUsIGF0dHJpYnV0ZS52YWx1ZSwgYXR0cmlidXRlLnNvdXJjZVNwYW4pO1xuICAgICAgfTtcbiAgICAgIE5vbkJpbmRhYmxlVmlzaXRvci5wcm90b3R5cGUudmlzaXRUZXh0ID0gZnVuY3Rpb24gKHRleHQsIHBhcmVudCkge1xuICAgICAgICAgIHZhciBuZ0NvbnRlbnRJbmRleCA9IHBhcmVudC5maW5kTmdDb250ZW50SW5kZXgoVEVYVF9DU1NfU0VMRUNUT1IpO1xuICAgICAgICAgIHJldHVybiBuZXcgVGV4dEFzdCh0ZXh0LnZhbHVlLCBuZ0NvbnRlbnRJbmRleCwgdGV4dC5zb3VyY2VTcGFuKTtcbiAgICAgIH07XG4gICAgICBOb25CaW5kYWJsZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0RXhwYW5zaW9uID0gZnVuY3Rpb24gKGV4cGFuc2lvbiwgY29udGV4dCkgeyByZXR1cm4gZXhwYW5zaW9uOyB9O1xuICAgICAgTm9uQmluZGFibGVWaXNpdG9yLnByb3RvdHlwZS52aXNpdEV4cGFuc2lvbkNhc2UgPSBmdW5jdGlvbiAoZXhwYW5zaW9uQ2FzZSwgY29udGV4dCkgeyByZXR1cm4gZXhwYW5zaW9uQ2FzZTsgfTtcbiAgICAgIHJldHVybiBOb25CaW5kYWJsZVZpc2l0b3I7XG4gIH0oKSk7XG4gIHZhciBFbGVtZW50T3JEaXJlY3RpdmVSZWYgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gRWxlbWVudE9yRGlyZWN0aXZlUmVmKG5hbWUsIHZhbHVlLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBFbGVtZW50T3JEaXJlY3RpdmVSZWY7XG4gIH0oKSk7XG4gIGZ1bmN0aW9uIHNwbGl0Q2xhc3NlcyhjbGFzc0F0dHJWYWx1ZSkge1xuICAgICAgcmV0dXJuIGNsYXNzQXR0clZhbHVlLnRyaW0oKS5zcGxpdCgvXFxzKy9nKTtcbiAgfVxuICB2YXIgRWxlbWVudENvbnRleHQgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gRWxlbWVudENvbnRleHQoaXNUZW1wbGF0ZUVsZW1lbnQsIF9uZ0NvbnRlbnRJbmRleE1hdGNoZXIsIF93aWxkY2FyZE5nQ29udGVudEluZGV4LCBwcm92aWRlckNvbnRleHQpIHtcbiAgICAgICAgICB0aGlzLmlzVGVtcGxhdGVFbGVtZW50ID0gaXNUZW1wbGF0ZUVsZW1lbnQ7XG4gICAgICAgICAgdGhpcy5fbmdDb250ZW50SW5kZXhNYXRjaGVyID0gX25nQ29udGVudEluZGV4TWF0Y2hlcjtcbiAgICAgICAgICB0aGlzLl93aWxkY2FyZE5nQ29udGVudEluZGV4ID0gX3dpbGRjYXJkTmdDb250ZW50SW5kZXg7XG4gICAgICAgICAgdGhpcy5wcm92aWRlckNvbnRleHQgPSBwcm92aWRlckNvbnRleHQ7XG4gICAgICB9XG4gICAgICBFbGVtZW50Q29udGV4dC5jcmVhdGUgPSBmdW5jdGlvbiAoaXNUZW1wbGF0ZUVsZW1lbnQsIGRpcmVjdGl2ZXMsIHByb3ZpZGVyQ29udGV4dCkge1xuICAgICAgICAgIHZhciBtYXRjaGVyID0gbmV3IFNlbGVjdG9yTWF0Y2hlcigpO1xuICAgICAgICAgIHZhciB3aWxkY2FyZE5nQ29udGVudEluZGV4ID0gbnVsbDtcbiAgICAgICAgICB2YXIgY29tcG9uZW50ID0gZGlyZWN0aXZlcy5maW5kKGZ1bmN0aW9uIChkaXJlY3RpdmUpIHsgcmV0dXJuIGRpcmVjdGl2ZS5kaXJlY3RpdmUuaXNDb21wb25lbnQ7IH0pO1xuICAgICAgICAgIGlmIChjb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgdmFyIG5nQ29udGVudFNlbGVjdG9ycyA9IGNvbXBvbmVudC5kaXJlY3RpdmUudGVtcGxhdGUubmdDb250ZW50U2VsZWN0b3JzO1xuICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5nQ29udGVudFNlbGVjdG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgdmFyIHNlbGVjdG9yID0gbmdDb250ZW50U2VsZWN0b3JzW2ldO1xuICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdG9yID09PSAnKicpIHtcbiAgICAgICAgICAgICAgICAgICAgICB3aWxkY2FyZE5nQ29udGVudEluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZXIuYWRkU2VsZWN0YWJsZXMoQ3NzU2VsZWN0b3IucGFyc2UobmdDb250ZW50U2VsZWN0b3JzW2ldKSwgaSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5ldyBFbGVtZW50Q29udGV4dChpc1RlbXBsYXRlRWxlbWVudCwgbWF0Y2hlciwgd2lsZGNhcmROZ0NvbnRlbnRJbmRleCwgcHJvdmlkZXJDb250ZXh0KTtcbiAgICAgIH07XG4gICAgICBFbGVtZW50Q29udGV4dC5wcm90b3R5cGUuZmluZE5nQ29udGVudEluZGV4ID0gZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgICAgICAgdmFyIG5nQ29udGVudEluZGljZXMgPSBbXTtcbiAgICAgICAgICB0aGlzLl9uZ0NvbnRlbnRJbmRleE1hdGNoZXIubWF0Y2goc2VsZWN0b3IsIGZ1bmN0aW9uIChzZWxlY3RvciwgbmdDb250ZW50SW5kZXgpIHsgbmdDb250ZW50SW5kaWNlcy5wdXNoKG5nQ29udGVudEluZGV4KTsgfSk7XG4gICAgICAgICAgbmdDb250ZW50SW5kaWNlcy5zb3J0KCk7XG4gICAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLl93aWxkY2FyZE5nQ29udGVudEluZGV4KSkge1xuICAgICAgICAgICAgICBuZ0NvbnRlbnRJbmRpY2VzLnB1c2godGhpcy5fd2lsZGNhcmROZ0NvbnRlbnRJbmRleCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuZ0NvbnRlbnRJbmRpY2VzLmxlbmd0aCA+IDAgPyBuZ0NvbnRlbnRJbmRpY2VzWzBdIDogbnVsbDtcbiAgICAgIH07XG4gICAgICByZXR1cm4gRWxlbWVudENvbnRleHQ7XG4gIH0oKSk7XG4gIGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRDc3NTZWxlY3RvcihlbGVtZW50TmFtZSwgbWF0Y2hhYmxlQXR0cnMpIHtcbiAgICAgIHZhciBjc3NTZWxlY3RvciA9IG5ldyBDc3NTZWxlY3RvcigpO1xuICAgICAgdmFyIGVsTmFtZU5vTnMgPSBzcGxpdE5zTmFtZShlbGVtZW50TmFtZSlbMV07XG4gICAgICBjc3NTZWxlY3Rvci5zZXRFbGVtZW50KGVsTmFtZU5vTnMpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXRjaGFibGVBdHRycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBhdHRyTmFtZSA9IG1hdGNoYWJsZUF0dHJzW2ldWzBdO1xuICAgICAgICAgIHZhciBhdHRyTmFtZU5vTnMgPSBzcGxpdE5zTmFtZShhdHRyTmFtZSlbMV07XG4gICAgICAgICAgdmFyIGF0dHJWYWx1ZSA9IG1hdGNoYWJsZUF0dHJzW2ldWzFdO1xuICAgICAgICAgIGNzc1NlbGVjdG9yLmFkZEF0dHJpYnV0ZShhdHRyTmFtZU5vTnMsIGF0dHJWYWx1ZSk7XG4gICAgICAgICAgaWYgKGF0dHJOYW1lLnRvTG93ZXJDYXNlKCkgPT0gQ0xBU1NfQVRUUikge1xuICAgICAgICAgICAgICB2YXIgY2xhc3NlcyA9IHNwbGl0Q2xhc3NlcyhhdHRyVmFsdWUpO1xuICAgICAgICAgICAgICBjbGFzc2VzLmZvckVhY2goZnVuY3Rpb24gKGNsYXNzTmFtZSkgeyByZXR1cm4gY3NzU2VsZWN0b3IuYWRkQ2xhc3NOYW1lKGNsYXNzTmFtZSk7IH0pO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBjc3NTZWxlY3RvcjtcbiAgfVxuICB2YXIgRU1QVFlfRUxFTUVOVF9DT05URVhUID0gbmV3IEVsZW1lbnRDb250ZXh0KHRydWUsIG5ldyBTZWxlY3Rvck1hdGNoZXIoKSwgbnVsbCwgbnVsbCk7XG4gIHZhciBOT05fQklOREFCTEVfVklTSVRPUiA9IG5ldyBOb25CaW5kYWJsZVZpc2l0b3IoKTtcbiAgZnVuY3Rpb24gX2lzRW1wdHlUZXh0Tm9kZShub2RlKSB7XG4gICAgICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIFRleHQgJiYgbm9kZS52YWx1ZS50cmltKCkubGVuZ3RoID09IDA7XG4gIH1cblxuICBmdW5jdGlvbiB1bmltcGxlbWVudGVkJDEoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VuaW1wbGVtZW50ZWQnKTtcbiAgfVxuICB2YXIgQ29tcGlsZXJDb25maWcgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gQ29tcGlsZXJDb25maWcoX2EpIHtcbiAgICAgICAgICB2YXIgX2IgPSBfYSA9PT0gdm9pZCAwID8ge30gOiBfYSwgX2MgPSBfYi5yZW5kZXJUeXBlcywgcmVuZGVyVHlwZXMgPSBfYyA9PT0gdm9pZCAwID8gbmV3IERlZmF1bHRSZW5kZXJUeXBlcygpIDogX2MsIF9kID0gX2IuZGVmYXVsdEVuY2Fwc3VsYXRpb24sIGRlZmF1bHRFbmNhcHN1bGF0aW9uID0gX2QgPT09IHZvaWQgMCA/IF9hbmd1bGFyX2NvcmUuVmlld0VuY2Fwc3VsYXRpb24uRW11bGF0ZWQgOiBfZCwgZ2VuRGVidWdJbmZvID0gX2IuZ2VuRGVidWdJbmZvLCBsb2dCaW5kaW5nVXBkYXRlID0gX2IubG9nQmluZGluZ1VwZGF0ZSwgX2UgPSBfYi51c2VKaXQsIHVzZUppdCA9IF9lID09PSB2b2lkIDAgPyB0cnVlIDogX2U7XG4gICAgICAgICAgdGhpcy5yZW5kZXJUeXBlcyA9IHJlbmRlclR5cGVzO1xuICAgICAgICAgIHRoaXMuZGVmYXVsdEVuY2Fwc3VsYXRpb24gPSBkZWZhdWx0RW5jYXBzdWxhdGlvbjtcbiAgICAgICAgICB0aGlzLl9nZW5EZWJ1Z0luZm8gPSBnZW5EZWJ1Z0luZm87XG4gICAgICAgICAgdGhpcy5fbG9nQmluZGluZ1VwZGF0ZSA9IGxvZ0JpbmRpbmdVcGRhdGU7XG4gICAgICAgICAgdGhpcy51c2VKaXQgPSB1c2VKaXQ7XG4gICAgICB9XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tcGlsZXJDb25maWcucHJvdG90eXBlLCBcImdlbkRlYnVnSW5mb1wiLCB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZW5EZWJ1Z0luZm8gPT09IHZvaWQgMCA/IF9hbmd1bGFyX2NvcmUuaXNEZXZNb2RlKCkgOiB0aGlzLl9nZW5EZWJ1Z0luZm87XG4gICAgICAgICAgfSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tcGlsZXJDb25maWcucHJvdG90eXBlLCBcImxvZ0JpbmRpbmdVcGRhdGVcIiwge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbG9nQmluZGluZ1VwZGF0ZSA9PT0gdm9pZCAwID8gX2FuZ3VsYXJfY29yZS5pc0Rldk1vZGUoKSA6IHRoaXMuX2xvZ0JpbmRpbmdVcGRhdGU7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gQ29tcGlsZXJDb25maWc7XG4gIH0oKSk7XG4gIC8qKlxuICAgKiBUeXBlcyB1c2VkIGZvciB0aGUgcmVuZGVyZXIuXG4gICAqIENhbiBiZSByZXBsYWNlZCB0byBzcGVjaWFsaXplIHRoZSBnZW5lcmF0ZWQgb3V0cHV0IHRvIGEgc3BlY2lmaWMgcmVuZGVyZXJcbiAgICogdG8gaGVscCB0cmVlIHNoYWtpbmcuXG4gICAqL1xuICB2YXIgUmVuZGVyVHlwZXMgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gUmVuZGVyVHlwZXMoKSB7XG4gICAgICB9XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVuZGVyVHlwZXMucHJvdG90eXBlLCBcInJlbmRlcmVyXCIsIHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVuaW1wbGVtZW50ZWQkMSgpOyB9LFxuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZW5kZXJUeXBlcy5wcm90b3R5cGUsIFwicmVuZGVyVGV4dFwiLCB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1bmltcGxlbWVudGVkJDEoKTsgfSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVuZGVyVHlwZXMucHJvdG90eXBlLCBcInJlbmRlckVsZW1lbnRcIiwge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdW5pbXBsZW1lbnRlZCQxKCk7IH0sXG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlbmRlclR5cGVzLnByb3RvdHlwZSwgXCJyZW5kZXJDb21tZW50XCIsIHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVuaW1wbGVtZW50ZWQkMSgpOyB9LFxuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZW5kZXJUeXBlcy5wcm90b3R5cGUsIFwicmVuZGVyTm9kZVwiLCB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1bmltcGxlbWVudGVkJDEoKTsgfSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVuZGVyVHlwZXMucHJvdG90eXBlLCBcInJlbmRlckV2ZW50XCIsIHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVuaW1wbGVtZW50ZWQkMSgpOyB9LFxuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBSZW5kZXJUeXBlcztcbiAgfSgpKTtcbiAgdmFyIERlZmF1bHRSZW5kZXJUeXBlcyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBEZWZhdWx0UmVuZGVyVHlwZXMoKSB7XG4gICAgICAgICAgdGhpcy5yZW5kZXJUZXh0ID0gbnVsbDtcbiAgICAgICAgICB0aGlzLnJlbmRlckVsZW1lbnQgPSBudWxsO1xuICAgICAgICAgIHRoaXMucmVuZGVyQ29tbWVudCA9IG51bGw7XG4gICAgICAgICAgdGhpcy5yZW5kZXJOb2RlID0gbnVsbDtcbiAgICAgICAgICB0aGlzLnJlbmRlckV2ZW50ID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEZWZhdWx0UmVuZGVyVHlwZXMucHJvdG90eXBlLCBcInJlbmRlcmVyXCIsIHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlc29sdmVJZGVudGlmaWVyKElkZW50aWZpZXJzLlJlbmRlcmVyKTsgfSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICA7XG4gICAgICByZXR1cm4gRGVmYXVsdFJlbmRlclR5cGVzO1xuICB9KCkpO1xuXG4gIC8qKlxuICAgKiBAbGljZW5zZVxuICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICpcbiAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgKi9cbiAgdmFyIF9fZXh0ZW5kcyQxMiA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgfTtcbiAgLy8vLyBUeXBlc1xuICB2YXIgVHlwZU1vZGlmaWVyO1xuICAoZnVuY3Rpb24gKFR5cGVNb2RpZmllcikge1xuICAgICAgVHlwZU1vZGlmaWVyW1R5cGVNb2RpZmllcltcIkNvbnN0XCJdID0gMF0gPSBcIkNvbnN0XCI7XG4gIH0pKFR5cGVNb2RpZmllciB8fCAoVHlwZU1vZGlmaWVyID0ge30pKTtcbiAgdmFyIFR5cGUkMSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBUeXBlKG1vZGlmaWVycykge1xuICAgICAgICAgIGlmIChtb2RpZmllcnMgPT09IHZvaWQgMCkgeyBtb2RpZmllcnMgPSBudWxsOyB9XG4gICAgICAgICAgdGhpcy5tb2RpZmllcnMgPSBtb2RpZmllcnM7XG4gICAgICAgICAgaWYgKCFtb2RpZmllcnMpIHtcbiAgICAgICAgICAgICAgdGhpcy5tb2RpZmllcnMgPSBbXTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICBUeXBlLnByb3RvdHlwZS5oYXNNb2RpZmllciA9IGZ1bmN0aW9uIChtb2RpZmllcikgeyByZXR1cm4gdGhpcy5tb2RpZmllcnMuaW5kZXhPZihtb2RpZmllcikgIT09IC0xOyB9O1xuICAgICAgcmV0dXJuIFR5cGU7XG4gIH0oKSk7XG4gIHZhciBCdWlsdGluVHlwZU5hbWU7XG4gIChmdW5jdGlvbiAoQnVpbHRpblR5cGVOYW1lKSB7XG4gICAgICBCdWlsdGluVHlwZU5hbWVbQnVpbHRpblR5cGVOYW1lW1wiRHluYW1pY1wiXSA9IDBdID0gXCJEeW5hbWljXCI7XG4gICAgICBCdWlsdGluVHlwZU5hbWVbQnVpbHRpblR5cGVOYW1lW1wiQm9vbFwiXSA9IDFdID0gXCJCb29sXCI7XG4gICAgICBCdWlsdGluVHlwZU5hbWVbQnVpbHRpblR5cGVOYW1lW1wiU3RyaW5nXCJdID0gMl0gPSBcIlN0cmluZ1wiO1xuICAgICAgQnVpbHRpblR5cGVOYW1lW0J1aWx0aW5UeXBlTmFtZVtcIkludFwiXSA9IDNdID0gXCJJbnRcIjtcbiAgICAgIEJ1aWx0aW5UeXBlTmFtZVtCdWlsdGluVHlwZU5hbWVbXCJOdW1iZXJcIl0gPSA0XSA9IFwiTnVtYmVyXCI7XG4gICAgICBCdWlsdGluVHlwZU5hbWVbQnVpbHRpblR5cGVOYW1lW1wiRnVuY3Rpb25cIl0gPSA1XSA9IFwiRnVuY3Rpb25cIjtcbiAgfSkoQnVpbHRpblR5cGVOYW1lIHx8IChCdWlsdGluVHlwZU5hbWUgPSB7fSkpO1xuICB2YXIgQnVpbHRpblR5cGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDEyKEJ1aWx0aW5UeXBlLCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gQnVpbHRpblR5cGUobmFtZSwgbW9kaWZpZXJzKSB7XG4gICAgICAgICAgaWYgKG1vZGlmaWVycyA9PT0gdm9pZCAwKSB7IG1vZGlmaWVycyA9IG51bGw7IH1cbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBtb2RpZmllcnMpO1xuICAgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICB9XG4gICAgICBCdWlsdGluVHlwZS5wcm90b3R5cGUudmlzaXRUeXBlID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEJ1aWx0aW50VHlwZSh0aGlzLCBjb250ZXh0KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gQnVpbHRpblR5cGU7XG4gIH0oVHlwZSQxKSk7XG4gIHZhciBFeHRlcm5hbFR5cGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDEyKEV4dGVybmFsVHlwZSwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIEV4dGVybmFsVHlwZSh2YWx1ZSwgdHlwZVBhcmFtcywgbW9kaWZpZXJzKSB7XG4gICAgICAgICAgaWYgKHR5cGVQYXJhbXMgPT09IHZvaWQgMCkgeyB0eXBlUGFyYW1zID0gbnVsbDsgfVxuICAgICAgICAgIGlmIChtb2RpZmllcnMgPT09IHZvaWQgMCkgeyBtb2RpZmllcnMgPSBudWxsOyB9XG4gICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgbW9kaWZpZXJzKTtcbiAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgdGhpcy50eXBlUGFyYW1zID0gdHlwZVBhcmFtcztcbiAgICAgIH1cbiAgICAgIEV4dGVybmFsVHlwZS5wcm90b3R5cGUudmlzaXRUeXBlID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEV4dGVybmFsVHlwZSh0aGlzLCBjb250ZXh0KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gRXh0ZXJuYWxUeXBlO1xuICB9KFR5cGUkMSkpO1xuICB2YXIgQXJyYXlUeXBlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQxMihBcnJheVR5cGUsIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBBcnJheVR5cGUob2YsIG1vZGlmaWVycykge1xuICAgICAgICAgIGlmIChtb2RpZmllcnMgPT09IHZvaWQgMCkgeyBtb2RpZmllcnMgPSBudWxsOyB9XG4gICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgbW9kaWZpZXJzKTtcbiAgICAgICAgICB0aGlzLm9mID0gb2Y7XG4gICAgICB9XG4gICAgICBBcnJheVR5cGUucHJvdG90eXBlLnZpc2l0VHlwZSA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRBcnJheVR5cGUodGhpcywgY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIEFycmF5VHlwZTtcbiAgfShUeXBlJDEpKTtcbiAgdmFyIE1hcFR5cGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDEyKE1hcFR5cGUsIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBNYXBUeXBlKHZhbHVlVHlwZSwgbW9kaWZpZXJzKSB7XG4gICAgICAgICAgaWYgKG1vZGlmaWVycyA9PT0gdm9pZCAwKSB7IG1vZGlmaWVycyA9IG51bGw7IH1cbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBtb2RpZmllcnMpO1xuICAgICAgICAgIHRoaXMudmFsdWVUeXBlID0gdmFsdWVUeXBlO1xuICAgICAgfVxuICAgICAgTWFwVHlwZS5wcm90b3R5cGUudmlzaXRUeXBlID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHsgcmV0dXJuIHZpc2l0b3IudmlzaXRNYXBUeXBlKHRoaXMsIGNvbnRleHQpOyB9O1xuICAgICAgcmV0dXJuIE1hcFR5cGU7XG4gIH0oVHlwZSQxKSk7XG4gIHZhciBEWU5BTUlDX1RZUEUgPSBuZXcgQnVpbHRpblR5cGUoQnVpbHRpblR5cGVOYW1lLkR5bmFtaWMpO1xuICB2YXIgQk9PTF9UWVBFID0gbmV3IEJ1aWx0aW5UeXBlKEJ1aWx0aW5UeXBlTmFtZS5Cb29sKTtcbiAgdmFyIElOVF9UWVBFID0gbmV3IEJ1aWx0aW5UeXBlKEJ1aWx0aW5UeXBlTmFtZS5JbnQpO1xuICB2YXIgTlVNQkVSX1RZUEUgPSBuZXcgQnVpbHRpblR5cGUoQnVpbHRpblR5cGVOYW1lLk51bWJlcik7XG4gIHZhciBTVFJJTkdfVFlQRSA9IG5ldyBCdWlsdGluVHlwZShCdWlsdGluVHlwZU5hbWUuU3RyaW5nKTtcbiAgdmFyIEZVTkNUSU9OX1RZUEUgPSBuZXcgQnVpbHRpblR5cGUoQnVpbHRpblR5cGVOYW1lLkZ1bmN0aW9uKTtcbiAgLy8vLy8gRXhwcmVzc2lvbnNcbiAgdmFyIEJpbmFyeU9wZXJhdG9yO1xuICAoZnVuY3Rpb24gKEJpbmFyeU9wZXJhdG9yKSB7XG4gICAgICBCaW5hcnlPcGVyYXRvcltCaW5hcnlPcGVyYXRvcltcIkVxdWFsc1wiXSA9IDBdID0gXCJFcXVhbHNcIjtcbiAgICAgIEJpbmFyeU9wZXJhdG9yW0JpbmFyeU9wZXJhdG9yW1wiTm90RXF1YWxzXCJdID0gMV0gPSBcIk5vdEVxdWFsc1wiO1xuICAgICAgQmluYXJ5T3BlcmF0b3JbQmluYXJ5T3BlcmF0b3JbXCJJZGVudGljYWxcIl0gPSAyXSA9IFwiSWRlbnRpY2FsXCI7XG4gICAgICBCaW5hcnlPcGVyYXRvcltCaW5hcnlPcGVyYXRvcltcIk5vdElkZW50aWNhbFwiXSA9IDNdID0gXCJOb3RJZGVudGljYWxcIjtcbiAgICAgIEJpbmFyeU9wZXJhdG9yW0JpbmFyeU9wZXJhdG9yW1wiTWludXNcIl0gPSA0XSA9IFwiTWludXNcIjtcbiAgICAgIEJpbmFyeU9wZXJhdG9yW0JpbmFyeU9wZXJhdG9yW1wiUGx1c1wiXSA9IDVdID0gXCJQbHVzXCI7XG4gICAgICBCaW5hcnlPcGVyYXRvcltCaW5hcnlPcGVyYXRvcltcIkRpdmlkZVwiXSA9IDZdID0gXCJEaXZpZGVcIjtcbiAgICAgIEJpbmFyeU9wZXJhdG9yW0JpbmFyeU9wZXJhdG9yW1wiTXVsdGlwbHlcIl0gPSA3XSA9IFwiTXVsdGlwbHlcIjtcbiAgICAgIEJpbmFyeU9wZXJhdG9yW0JpbmFyeU9wZXJhdG9yW1wiTW9kdWxvXCJdID0gOF0gPSBcIk1vZHVsb1wiO1xuICAgICAgQmluYXJ5T3BlcmF0b3JbQmluYXJ5T3BlcmF0b3JbXCJBbmRcIl0gPSA5XSA9IFwiQW5kXCI7XG4gICAgICBCaW5hcnlPcGVyYXRvcltCaW5hcnlPcGVyYXRvcltcIk9yXCJdID0gMTBdID0gXCJPclwiO1xuICAgICAgQmluYXJ5T3BlcmF0b3JbQmluYXJ5T3BlcmF0b3JbXCJMb3dlclwiXSA9IDExXSA9IFwiTG93ZXJcIjtcbiAgICAgIEJpbmFyeU9wZXJhdG9yW0JpbmFyeU9wZXJhdG9yW1wiTG93ZXJFcXVhbHNcIl0gPSAxMl0gPSBcIkxvd2VyRXF1YWxzXCI7XG4gICAgICBCaW5hcnlPcGVyYXRvcltCaW5hcnlPcGVyYXRvcltcIkJpZ2dlclwiXSA9IDEzXSA9IFwiQmlnZ2VyXCI7XG4gICAgICBCaW5hcnlPcGVyYXRvcltCaW5hcnlPcGVyYXRvcltcIkJpZ2dlckVxdWFsc1wiXSA9IDE0XSA9IFwiQmlnZ2VyRXF1YWxzXCI7XG4gIH0pKEJpbmFyeU9wZXJhdG9yIHx8IChCaW5hcnlPcGVyYXRvciA9IHt9KSk7XG4gIHZhciBFeHByZXNzaW9uID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIEV4cHJlc3Npb24odHlwZSkge1xuICAgICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICB9XG4gICAgICBFeHByZXNzaW9uLnByb3RvdHlwZS5wcm9wID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIG5ldyBSZWFkUHJvcEV4cHIodGhpcywgbmFtZSk7IH07XG4gICAgICBFeHByZXNzaW9uLnByb3RvdHlwZS5rZXkgPSBmdW5jdGlvbiAoaW5kZXgsIHR5cGUpIHtcbiAgICAgICAgICBpZiAodHlwZSA9PT0gdm9pZCAwKSB7IHR5cGUgPSBudWxsOyB9XG4gICAgICAgICAgcmV0dXJuIG5ldyBSZWFkS2V5RXhwcih0aGlzLCBpbmRleCwgdHlwZSk7XG4gICAgICB9O1xuICAgICAgRXhwcmVzc2lvbi5wcm90b3R5cGUuY2FsbE1ldGhvZCA9IGZ1bmN0aW9uIChuYW1lLCBwYXJhbXMpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IEludm9rZU1ldGhvZEV4cHIodGhpcywgbmFtZSwgcGFyYW1zKTtcbiAgICAgIH07XG4gICAgICBFeHByZXNzaW9uLnByb3RvdHlwZS5jYWxsRm4gPSBmdW5jdGlvbiAocGFyYW1zKSB7IHJldHVybiBuZXcgSW52b2tlRnVuY3Rpb25FeHByKHRoaXMsIHBhcmFtcyk7IH07XG4gICAgICBFeHByZXNzaW9uLnByb3RvdHlwZS5pbnN0YW50aWF0ZSA9IGZ1bmN0aW9uIChwYXJhbXMsIHR5cGUpIHtcbiAgICAgICAgICBpZiAodHlwZSA9PT0gdm9pZCAwKSB7IHR5cGUgPSBudWxsOyB9XG4gICAgICAgICAgcmV0dXJuIG5ldyBJbnN0YW50aWF0ZUV4cHIodGhpcywgcGFyYW1zLCB0eXBlKTtcbiAgICAgIH07XG4gICAgICBFeHByZXNzaW9uLnByb3RvdHlwZS5jb25kaXRpb25hbCA9IGZ1bmN0aW9uICh0cnVlQ2FzZSwgZmFsc2VDYXNlKSB7XG4gICAgICAgICAgaWYgKGZhbHNlQ2FzZSA9PT0gdm9pZCAwKSB7IGZhbHNlQ2FzZSA9IG51bGw7IH1cbiAgICAgICAgICByZXR1cm4gbmV3IENvbmRpdGlvbmFsRXhwcih0aGlzLCB0cnVlQ2FzZSwgZmFsc2VDYXNlKTtcbiAgICAgIH07XG4gICAgICBFeHByZXNzaW9uLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiAocmhzKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBCaW5hcnlPcGVyYXRvckV4cHIoQmluYXJ5T3BlcmF0b3IuRXF1YWxzLCB0aGlzLCByaHMpO1xuICAgICAgfTtcbiAgICAgIEV4cHJlc3Npb24ucHJvdG90eXBlLm5vdEVxdWFscyA9IGZ1bmN0aW9uIChyaHMpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IEJpbmFyeU9wZXJhdG9yRXhwcihCaW5hcnlPcGVyYXRvci5Ob3RFcXVhbHMsIHRoaXMsIHJocyk7XG4gICAgICB9O1xuICAgICAgRXhwcmVzc2lvbi5wcm90b3R5cGUuaWRlbnRpY2FsID0gZnVuY3Rpb24gKHJocykge1xuICAgICAgICAgIHJldHVybiBuZXcgQmluYXJ5T3BlcmF0b3JFeHByKEJpbmFyeU9wZXJhdG9yLklkZW50aWNhbCwgdGhpcywgcmhzKTtcbiAgICAgIH07XG4gICAgICBFeHByZXNzaW9uLnByb3RvdHlwZS5ub3RJZGVudGljYWwgPSBmdW5jdGlvbiAocmhzKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBCaW5hcnlPcGVyYXRvckV4cHIoQmluYXJ5T3BlcmF0b3IuTm90SWRlbnRpY2FsLCB0aGlzLCByaHMpO1xuICAgICAgfTtcbiAgICAgIEV4cHJlc3Npb24ucHJvdG90eXBlLm1pbnVzID0gZnVuY3Rpb24gKHJocykge1xuICAgICAgICAgIHJldHVybiBuZXcgQmluYXJ5T3BlcmF0b3JFeHByKEJpbmFyeU9wZXJhdG9yLk1pbnVzLCB0aGlzLCByaHMpO1xuICAgICAgfTtcbiAgICAgIEV4cHJlc3Npb24ucHJvdG90eXBlLnBsdXMgPSBmdW5jdGlvbiAocmhzKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBCaW5hcnlPcGVyYXRvckV4cHIoQmluYXJ5T3BlcmF0b3IuUGx1cywgdGhpcywgcmhzKTtcbiAgICAgIH07XG4gICAgICBFeHByZXNzaW9uLnByb3RvdHlwZS5kaXZpZGUgPSBmdW5jdGlvbiAocmhzKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBCaW5hcnlPcGVyYXRvckV4cHIoQmluYXJ5T3BlcmF0b3IuRGl2aWRlLCB0aGlzLCByaHMpO1xuICAgICAgfTtcbiAgICAgIEV4cHJlc3Npb24ucHJvdG90eXBlLm11bHRpcGx5ID0gZnVuY3Rpb24gKHJocykge1xuICAgICAgICAgIHJldHVybiBuZXcgQmluYXJ5T3BlcmF0b3JFeHByKEJpbmFyeU9wZXJhdG9yLk11bHRpcGx5LCB0aGlzLCByaHMpO1xuICAgICAgfTtcbiAgICAgIEV4cHJlc3Npb24ucHJvdG90eXBlLm1vZHVsbyA9IGZ1bmN0aW9uIChyaHMpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IEJpbmFyeU9wZXJhdG9yRXhwcihCaW5hcnlPcGVyYXRvci5Nb2R1bG8sIHRoaXMsIHJocyk7XG4gICAgICB9O1xuICAgICAgRXhwcmVzc2lvbi5wcm90b3R5cGUuYW5kID0gZnVuY3Rpb24gKHJocykge1xuICAgICAgICAgIHJldHVybiBuZXcgQmluYXJ5T3BlcmF0b3JFeHByKEJpbmFyeU9wZXJhdG9yLkFuZCwgdGhpcywgcmhzKTtcbiAgICAgIH07XG4gICAgICBFeHByZXNzaW9uLnByb3RvdHlwZS5vciA9IGZ1bmN0aW9uIChyaHMpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IEJpbmFyeU9wZXJhdG9yRXhwcihCaW5hcnlPcGVyYXRvci5PciwgdGhpcywgcmhzKTtcbiAgICAgIH07XG4gICAgICBFeHByZXNzaW9uLnByb3RvdHlwZS5sb3dlciA9IGZ1bmN0aW9uIChyaHMpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IEJpbmFyeU9wZXJhdG9yRXhwcihCaW5hcnlPcGVyYXRvci5Mb3dlciwgdGhpcywgcmhzKTtcbiAgICAgIH07XG4gICAgICBFeHByZXNzaW9uLnByb3RvdHlwZS5sb3dlckVxdWFscyA9IGZ1bmN0aW9uIChyaHMpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IEJpbmFyeU9wZXJhdG9yRXhwcihCaW5hcnlPcGVyYXRvci5Mb3dlckVxdWFscywgdGhpcywgcmhzKTtcbiAgICAgIH07XG4gICAgICBFeHByZXNzaW9uLnByb3RvdHlwZS5iaWdnZXIgPSBmdW5jdGlvbiAocmhzKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBCaW5hcnlPcGVyYXRvckV4cHIoQmluYXJ5T3BlcmF0b3IuQmlnZ2VyLCB0aGlzLCByaHMpO1xuICAgICAgfTtcbiAgICAgIEV4cHJlc3Npb24ucHJvdG90eXBlLmJpZ2dlckVxdWFscyA9IGZ1bmN0aW9uIChyaHMpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IEJpbmFyeU9wZXJhdG9yRXhwcihCaW5hcnlPcGVyYXRvci5CaWdnZXJFcXVhbHMsIHRoaXMsIHJocyk7XG4gICAgICB9O1xuICAgICAgRXhwcmVzc2lvbi5wcm90b3R5cGUuaXNCbGFuayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvLyBOb3RlOiBXZSB1c2UgZXF1YWxzIGJ5IHB1cnBvc2UgaGVyZSB0byBjb21wYXJlIHRvIG51bGwgYW5kIHVuZGVmaW5lZCBpbiBKUy5cbiAgICAgICAgICByZXR1cm4gdGhpcy5lcXVhbHMoTlVMTF9FWFBSKTtcbiAgICAgIH07XG4gICAgICBFeHByZXNzaW9uLnByb3RvdHlwZS5jYXN0ID0gZnVuY3Rpb24gKHR5cGUpIHsgcmV0dXJuIG5ldyBDYXN0RXhwcih0aGlzLCB0eXBlKTsgfTtcbiAgICAgIEV4cHJlc3Npb24ucHJvdG90eXBlLnRvU3RtdCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBFeHByZXNzaW9uU3RhdGVtZW50KHRoaXMpOyB9O1xuICAgICAgcmV0dXJuIEV4cHJlc3Npb247XG4gIH0oKSk7XG4gIHZhciBCdWlsdGluVmFyO1xuICAoZnVuY3Rpb24gKEJ1aWx0aW5WYXIpIHtcbiAgICAgIEJ1aWx0aW5WYXJbQnVpbHRpblZhcltcIlRoaXNcIl0gPSAwXSA9IFwiVGhpc1wiO1xuICAgICAgQnVpbHRpblZhcltCdWlsdGluVmFyW1wiU3VwZXJcIl0gPSAxXSA9IFwiU3VwZXJcIjtcbiAgICAgIEJ1aWx0aW5WYXJbQnVpbHRpblZhcltcIkNhdGNoRXJyb3JcIl0gPSAyXSA9IFwiQ2F0Y2hFcnJvclwiO1xuICAgICAgQnVpbHRpblZhcltCdWlsdGluVmFyW1wiQ2F0Y2hTdGFja1wiXSA9IDNdID0gXCJDYXRjaFN0YWNrXCI7XG4gIH0pKEJ1aWx0aW5WYXIgfHwgKEJ1aWx0aW5WYXIgPSB7fSkpO1xuICB2YXIgUmVhZFZhckV4cHIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDEyKFJlYWRWYXJFeHByLCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gUmVhZFZhckV4cHIobmFtZSwgdHlwZSkge1xuICAgICAgICAgIGlmICh0eXBlID09PSB2b2lkIDApIHsgdHlwZSA9IG51bGw7IH1cbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCB0eXBlKTtcbiAgICAgICAgICBpZiAodHlwZW9mIG5hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgICAgICAgIHRoaXMuYnVpbHRpbiA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLm5hbWUgPSBudWxsO1xuICAgICAgICAgICAgICB0aGlzLmJ1aWx0aW4gPSBuYW1lO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFJlYWRWYXJFeHByLnByb3RvdHlwZS52aXNpdEV4cHJlc3Npb24gPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0UmVhZFZhckV4cHIodGhpcywgY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgUmVhZFZhckV4cHIucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gbmV3IFdyaXRlVmFyRXhwcih0aGlzLm5hbWUsIHZhbHVlKTsgfTtcbiAgICAgIHJldHVybiBSZWFkVmFyRXhwcjtcbiAgfShFeHByZXNzaW9uKSk7XG4gIHZhciBXcml0ZVZhckV4cHIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDEyKFdyaXRlVmFyRXhwciwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIFdyaXRlVmFyRXhwcihuYW1lLCB2YWx1ZSwgdHlwZSkge1xuICAgICAgICAgIGlmICh0eXBlID09PSB2b2lkIDApIHsgdHlwZSA9IG51bGw7IH1cbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCB0eXBlIHx8IHZhbHVlLnR5cGUpO1xuICAgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgV3JpdGVWYXJFeHByLnByb3RvdHlwZS52aXNpdEV4cHJlc3Npb24gPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0V3JpdGVWYXJFeHByKHRoaXMsIGNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIFdyaXRlVmFyRXhwci5wcm90b3R5cGUudG9EZWNsU3RtdCA9IGZ1bmN0aW9uICh0eXBlLCBtb2RpZmllcnMpIHtcbiAgICAgICAgICBpZiAodHlwZSA9PT0gdm9pZCAwKSB7IHR5cGUgPSBudWxsOyB9XG4gICAgICAgICAgaWYgKG1vZGlmaWVycyA9PT0gdm9pZCAwKSB7IG1vZGlmaWVycyA9IG51bGw7IH1cbiAgICAgICAgICByZXR1cm4gbmV3IERlY2xhcmVWYXJTdG10KHRoaXMubmFtZSwgdGhpcy52YWx1ZSwgdHlwZSwgbW9kaWZpZXJzKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gV3JpdGVWYXJFeHByO1xuICB9KEV4cHJlc3Npb24pKTtcbiAgdmFyIFdyaXRlS2V5RXhwciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkMTIoV3JpdGVLZXlFeHByLCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gV3JpdGVLZXlFeHByKHJlY2VpdmVyLCBpbmRleCwgdmFsdWUsIHR5cGUpIHtcbiAgICAgICAgICBpZiAodHlwZSA9PT0gdm9pZCAwKSB7IHR5cGUgPSBudWxsOyB9XG4gICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgdHlwZSB8fCB2YWx1ZS50eXBlKTtcbiAgICAgICAgICB0aGlzLnJlY2VpdmVyID0gcmVjZWl2ZXI7XG4gICAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIFdyaXRlS2V5RXhwci5wcm90b3R5cGUudmlzaXRFeHByZXNzaW9uID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFdyaXRlS2V5RXhwcih0aGlzLCBjb250ZXh0KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gV3JpdGVLZXlFeHByO1xuICB9KEV4cHJlc3Npb24pKTtcbiAgdmFyIFdyaXRlUHJvcEV4cHIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDEyKFdyaXRlUHJvcEV4cHIsIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBXcml0ZVByb3BFeHByKHJlY2VpdmVyLCBuYW1lLCB2YWx1ZSwgdHlwZSkge1xuICAgICAgICAgIGlmICh0eXBlID09PSB2b2lkIDApIHsgdHlwZSA9IG51bGw7IH1cbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCB0eXBlIHx8IHZhbHVlLnR5cGUpO1xuICAgICAgICAgIHRoaXMucmVjZWl2ZXIgPSByZWNlaXZlcjtcbiAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIFdyaXRlUHJvcEV4cHIucHJvdG90eXBlLnZpc2l0RXhwcmVzc2lvbiA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRXcml0ZVByb3BFeHByKHRoaXMsIGNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBXcml0ZVByb3BFeHByO1xuICB9KEV4cHJlc3Npb24pKTtcbiAgdmFyIEJ1aWx0aW5NZXRob2Q7XG4gIChmdW5jdGlvbiAoQnVpbHRpbk1ldGhvZCkge1xuICAgICAgQnVpbHRpbk1ldGhvZFtCdWlsdGluTWV0aG9kW1wiQ29uY2F0QXJyYXlcIl0gPSAwXSA9IFwiQ29uY2F0QXJyYXlcIjtcbiAgICAgIEJ1aWx0aW5NZXRob2RbQnVpbHRpbk1ldGhvZFtcIlN1YnNjcmliZU9ic2VydmFibGVcIl0gPSAxXSA9IFwiU3Vic2NyaWJlT2JzZXJ2YWJsZVwiO1xuICAgICAgQnVpbHRpbk1ldGhvZFtCdWlsdGluTWV0aG9kW1wiQmluZFwiXSA9IDJdID0gXCJCaW5kXCI7XG4gIH0pKEJ1aWx0aW5NZXRob2QgfHwgKEJ1aWx0aW5NZXRob2QgPSB7fSkpO1xuICB2YXIgSW52b2tlTWV0aG9kRXhwciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkMTIoSW52b2tlTWV0aG9kRXhwciwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIEludm9rZU1ldGhvZEV4cHIocmVjZWl2ZXIsIG1ldGhvZCwgYXJncywgdHlwZSkge1xuICAgICAgICAgIGlmICh0eXBlID09PSB2b2lkIDApIHsgdHlwZSA9IG51bGw7IH1cbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCB0eXBlKTtcbiAgICAgICAgICB0aGlzLnJlY2VpdmVyID0gcmVjZWl2ZXI7XG4gICAgICAgICAgdGhpcy5hcmdzID0gYXJncztcbiAgICAgICAgICBpZiAodHlwZW9mIG1ldGhvZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgdGhpcy5uYW1lID0gbWV0aG9kO1xuICAgICAgICAgICAgICB0aGlzLmJ1aWx0aW4gPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5uYW1lID0gbnVsbDtcbiAgICAgICAgICAgICAgdGhpcy5idWlsdGluID0gbWV0aG9kO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIEludm9rZU1ldGhvZEV4cHIucHJvdG90eXBlLnZpc2l0RXhwcmVzc2lvbiA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRJbnZva2VNZXRob2RFeHByKHRoaXMsIGNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBJbnZva2VNZXRob2RFeHByO1xuICB9KEV4cHJlc3Npb24pKTtcbiAgdmFyIEludm9rZUZ1bmN0aW9uRXhwciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkMTIoSW52b2tlRnVuY3Rpb25FeHByLCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gSW52b2tlRnVuY3Rpb25FeHByKGZuLCBhcmdzLCB0eXBlKSB7XG4gICAgICAgICAgaWYgKHR5cGUgPT09IHZvaWQgMCkgeyB0eXBlID0gbnVsbDsgfVxuICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIHR5cGUpO1xuICAgICAgICAgIHRoaXMuZm4gPSBmbjtcbiAgICAgICAgICB0aGlzLmFyZ3MgPSBhcmdzO1xuICAgICAgfVxuICAgICAgSW52b2tlRnVuY3Rpb25FeHByLnByb3RvdHlwZS52aXNpdEV4cHJlc3Npb24gPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0SW52b2tlRnVuY3Rpb25FeHByKHRoaXMsIGNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBJbnZva2VGdW5jdGlvbkV4cHI7XG4gIH0oRXhwcmVzc2lvbikpO1xuICB2YXIgSW5zdGFudGlhdGVFeHByID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQxMihJbnN0YW50aWF0ZUV4cHIsIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBJbnN0YW50aWF0ZUV4cHIoY2xhc3NFeHByLCBhcmdzLCB0eXBlKSB7XG4gICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgdHlwZSk7XG4gICAgICAgICAgdGhpcy5jbGFzc0V4cHIgPSBjbGFzc0V4cHI7XG4gICAgICAgICAgdGhpcy5hcmdzID0gYXJncztcbiAgICAgIH1cbiAgICAgIEluc3RhbnRpYXRlRXhwci5wcm90b3R5cGUudmlzaXRFeHByZXNzaW9uID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEluc3RhbnRpYXRlRXhwcih0aGlzLCBjb250ZXh0KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gSW5zdGFudGlhdGVFeHByO1xuICB9KEV4cHJlc3Npb24pKTtcbiAgdmFyIExpdGVyYWxFeHByID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQxMihMaXRlcmFsRXhwciwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIExpdGVyYWxFeHByKHZhbHVlLCB0eXBlKSB7XG4gICAgICAgICAgaWYgKHR5cGUgPT09IHZvaWQgMCkgeyB0eXBlID0gbnVsbDsgfVxuICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIHR5cGUpO1xuICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIExpdGVyYWxFeHByLnByb3RvdHlwZS52aXNpdEV4cHJlc3Npb24gPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0TGl0ZXJhbEV4cHIodGhpcywgY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIExpdGVyYWxFeHByO1xuICB9KEV4cHJlc3Npb24pKTtcbiAgdmFyIEV4dGVybmFsRXhwciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkMTIoRXh0ZXJuYWxFeHByLCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gRXh0ZXJuYWxFeHByKHZhbHVlLCB0eXBlLCB0eXBlUGFyYW1zKSB7XG4gICAgICAgICAgaWYgKHR5cGUgPT09IHZvaWQgMCkgeyB0eXBlID0gbnVsbDsgfVxuICAgICAgICAgIGlmICh0eXBlUGFyYW1zID09PSB2b2lkIDApIHsgdHlwZVBhcmFtcyA9IG51bGw7IH1cbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCB0eXBlKTtcbiAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgdGhpcy50eXBlUGFyYW1zID0gdHlwZVBhcmFtcztcbiAgICAgIH1cbiAgICAgIEV4dGVybmFsRXhwci5wcm90b3R5cGUudmlzaXRFeHByZXNzaW9uID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEV4dGVybmFsRXhwcih0aGlzLCBjb250ZXh0KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gRXh0ZXJuYWxFeHByO1xuICB9KEV4cHJlc3Npb24pKTtcbiAgdmFyIENvbmRpdGlvbmFsRXhwciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkMTIoQ29uZGl0aW9uYWxFeHByLCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gQ29uZGl0aW9uYWxFeHByKGNvbmRpdGlvbiwgdHJ1ZUNhc2UsIGZhbHNlQ2FzZSwgdHlwZSkge1xuICAgICAgICAgIGlmIChmYWxzZUNhc2UgPT09IHZvaWQgMCkgeyBmYWxzZUNhc2UgPSBudWxsOyB9XG4gICAgICAgICAgaWYgKHR5cGUgPT09IHZvaWQgMCkgeyB0eXBlID0gbnVsbDsgfVxuICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIHR5cGUgfHwgdHJ1ZUNhc2UudHlwZSk7XG4gICAgICAgICAgdGhpcy5jb25kaXRpb24gPSBjb25kaXRpb247XG4gICAgICAgICAgdGhpcy5mYWxzZUNhc2UgPSBmYWxzZUNhc2U7XG4gICAgICAgICAgdGhpcy50cnVlQ2FzZSA9IHRydWVDYXNlO1xuICAgICAgfVxuICAgICAgQ29uZGl0aW9uYWxFeHByLnByb3RvdHlwZS52aXNpdEV4cHJlc3Npb24gPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Q29uZGl0aW9uYWxFeHByKHRoaXMsIGNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBDb25kaXRpb25hbEV4cHI7XG4gIH0oRXhwcmVzc2lvbikpO1xuICB2YXIgTm90RXhwciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkMTIoTm90RXhwciwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIE5vdEV4cHIoY29uZGl0aW9uKSB7XG4gICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgQk9PTF9UWVBFKTtcbiAgICAgICAgICB0aGlzLmNvbmRpdGlvbiA9IGNvbmRpdGlvbjtcbiAgICAgIH1cbiAgICAgIE5vdEV4cHIucHJvdG90eXBlLnZpc2l0RXhwcmVzc2lvbiA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXROb3RFeHByKHRoaXMsIGNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBOb3RFeHByO1xuICB9KEV4cHJlc3Npb24pKTtcbiAgdmFyIENhc3RFeHByID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQxMihDYXN0RXhwciwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIENhc3RFeHByKHZhbHVlLCB0eXBlKSB7XG4gICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgdHlwZSk7XG4gICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgQ2FzdEV4cHIucHJvdG90eXBlLnZpc2l0RXhwcmVzc2lvbiA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRDYXN0RXhwcih0aGlzLCBjb250ZXh0KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gQ2FzdEV4cHI7XG4gIH0oRXhwcmVzc2lvbikpO1xuICB2YXIgRm5QYXJhbSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBGblBhcmFtKG5hbWUsIHR5cGUpIHtcbiAgICAgICAgICBpZiAodHlwZSA9PT0gdm9pZCAwKSB7IHR5cGUgPSBudWxsOyB9XG4gICAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIEZuUGFyYW07XG4gIH0oKSk7XG4gIHZhciBGdW5jdGlvbkV4cHIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDEyKEZ1bmN0aW9uRXhwciwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIEZ1bmN0aW9uRXhwcihwYXJhbXMsIHN0YXRlbWVudHMsIHR5cGUpIHtcbiAgICAgICAgICBpZiAodHlwZSA9PT0gdm9pZCAwKSB7IHR5cGUgPSBudWxsOyB9XG4gICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgdHlwZSk7XG4gICAgICAgICAgdGhpcy5wYXJhbXMgPSBwYXJhbXM7XG4gICAgICAgICAgdGhpcy5zdGF0ZW1lbnRzID0gc3RhdGVtZW50cztcbiAgICAgIH1cbiAgICAgIEZ1bmN0aW9uRXhwci5wcm90b3R5cGUudmlzaXRFeHByZXNzaW9uID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEZ1bmN0aW9uRXhwcih0aGlzLCBjb250ZXh0KTtcbiAgICAgIH07XG4gICAgICBGdW5jdGlvbkV4cHIucHJvdG90eXBlLnRvRGVjbFN0bXQgPSBmdW5jdGlvbiAobmFtZSwgbW9kaWZpZXJzKSB7XG4gICAgICAgICAgaWYgKG1vZGlmaWVycyA9PT0gdm9pZCAwKSB7IG1vZGlmaWVycyA9IG51bGw7IH1cbiAgICAgICAgICByZXR1cm4gbmV3IERlY2xhcmVGdW5jdGlvblN0bXQobmFtZSwgdGhpcy5wYXJhbXMsIHRoaXMuc3RhdGVtZW50cywgdGhpcy50eXBlLCBtb2RpZmllcnMpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBGdW5jdGlvbkV4cHI7XG4gIH0oRXhwcmVzc2lvbikpO1xuICB2YXIgQmluYXJ5T3BlcmF0b3JFeHByID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQxMihCaW5hcnlPcGVyYXRvckV4cHIsIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBCaW5hcnlPcGVyYXRvckV4cHIob3BlcmF0b3IsIGxocywgcmhzLCB0eXBlKSB7XG4gICAgICAgICAgaWYgKHR5cGUgPT09IHZvaWQgMCkgeyB0eXBlID0gbnVsbDsgfVxuICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIHR5cGUgfHwgbGhzLnR5cGUpO1xuICAgICAgICAgIHRoaXMub3BlcmF0b3IgPSBvcGVyYXRvcjtcbiAgICAgICAgICB0aGlzLnJocyA9IHJocztcbiAgICAgICAgICB0aGlzLmxocyA9IGxocztcbiAgICAgIH1cbiAgICAgIEJpbmFyeU9wZXJhdG9yRXhwci5wcm90b3R5cGUudmlzaXRFeHByZXNzaW9uID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEJpbmFyeU9wZXJhdG9yRXhwcih0aGlzLCBjb250ZXh0KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gQmluYXJ5T3BlcmF0b3JFeHByO1xuICB9KEV4cHJlc3Npb24pKTtcbiAgdmFyIFJlYWRQcm9wRXhwciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkMTIoUmVhZFByb3BFeHByLCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gUmVhZFByb3BFeHByKHJlY2VpdmVyLCBuYW1lLCB0eXBlKSB7XG4gICAgICAgICAgaWYgKHR5cGUgPT09IHZvaWQgMCkgeyB0eXBlID0gbnVsbDsgfVxuICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIHR5cGUpO1xuICAgICAgICAgIHRoaXMucmVjZWl2ZXIgPSByZWNlaXZlcjtcbiAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgfVxuICAgICAgUmVhZFByb3BFeHByLnByb3RvdHlwZS52aXNpdEV4cHJlc3Npb24gPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0UmVhZFByb3BFeHByKHRoaXMsIGNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIFJlYWRQcm9wRXhwci5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBXcml0ZVByb3BFeHByKHRoaXMucmVjZWl2ZXIsIHRoaXMubmFtZSwgdmFsdWUpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBSZWFkUHJvcEV4cHI7XG4gIH0oRXhwcmVzc2lvbikpO1xuICB2YXIgUmVhZEtleUV4cHIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDEyKFJlYWRLZXlFeHByLCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gUmVhZEtleUV4cHIocmVjZWl2ZXIsIGluZGV4LCB0eXBlKSB7XG4gICAgICAgICAgaWYgKHR5cGUgPT09IHZvaWQgMCkgeyB0eXBlID0gbnVsbDsgfVxuICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIHR5cGUpO1xuICAgICAgICAgIHRoaXMucmVjZWl2ZXIgPSByZWNlaXZlcjtcbiAgICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICB9XG4gICAgICBSZWFkS2V5RXhwci5wcm90b3R5cGUudmlzaXRFeHByZXNzaW9uID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFJlYWRLZXlFeHByKHRoaXMsIGNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIFJlYWRLZXlFeHByLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFdyaXRlS2V5RXhwcih0aGlzLnJlY2VpdmVyLCB0aGlzLmluZGV4LCB2YWx1ZSk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIFJlYWRLZXlFeHByO1xuICB9KEV4cHJlc3Npb24pKTtcbiAgdmFyIExpdGVyYWxBcnJheUV4cHIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDEyKExpdGVyYWxBcnJheUV4cHIsIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBMaXRlcmFsQXJyYXlFeHByKGVudHJpZXMsIHR5cGUpIHtcbiAgICAgICAgICBpZiAodHlwZSA9PT0gdm9pZCAwKSB7IHR5cGUgPSBudWxsOyB9XG4gICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgdHlwZSk7XG4gICAgICAgICAgdGhpcy5lbnRyaWVzID0gZW50cmllcztcbiAgICAgIH1cbiAgICAgIExpdGVyYWxBcnJheUV4cHIucHJvdG90eXBlLnZpc2l0RXhwcmVzc2lvbiA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRMaXRlcmFsQXJyYXlFeHByKHRoaXMsIGNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBMaXRlcmFsQXJyYXlFeHByO1xuICB9KEV4cHJlc3Npb24pKTtcbiAgdmFyIExpdGVyYWxNYXBFeHByID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQxMihMaXRlcmFsTWFwRXhwciwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIExpdGVyYWxNYXBFeHByKGVudHJpZXMsIHR5cGUpIHtcbiAgICAgICAgICBpZiAodHlwZSA9PT0gdm9pZCAwKSB7IHR5cGUgPSBudWxsOyB9XG4gICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgdHlwZSk7XG4gICAgICAgICAgdGhpcy5lbnRyaWVzID0gZW50cmllcztcbiAgICAgICAgICB0aGlzLnZhbHVlVHlwZSA9IG51bGw7XG4gICAgICAgICAgaWYgKGlzUHJlc2VudCh0eXBlKSkge1xuICAgICAgICAgICAgICB0aGlzLnZhbHVlVHlwZSA9IHR5cGUudmFsdWVUeXBlO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIExpdGVyYWxNYXBFeHByLnByb3RvdHlwZS52aXNpdEV4cHJlc3Npb24gPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0TGl0ZXJhbE1hcEV4cHIodGhpcywgY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIExpdGVyYWxNYXBFeHByO1xuICB9KEV4cHJlc3Npb24pKTtcbiAgdmFyIFRISVNfRVhQUiA9IG5ldyBSZWFkVmFyRXhwcihCdWlsdGluVmFyLlRoaXMpO1xuICB2YXIgU1VQRVJfRVhQUiA9IG5ldyBSZWFkVmFyRXhwcihCdWlsdGluVmFyLlN1cGVyKTtcbiAgdmFyIENBVENIX0VSUk9SX1ZBUiA9IG5ldyBSZWFkVmFyRXhwcihCdWlsdGluVmFyLkNhdGNoRXJyb3IpO1xuICB2YXIgQ0FUQ0hfU1RBQ0tfVkFSID0gbmV3IFJlYWRWYXJFeHByKEJ1aWx0aW5WYXIuQ2F0Y2hTdGFjayk7XG4gIHZhciBOVUxMX0VYUFIgPSBuZXcgTGl0ZXJhbEV4cHIobnVsbCwgbnVsbCk7XG4gIC8vLy8gU3RhdGVtZW50c1xuICB2YXIgU3RtdE1vZGlmaWVyO1xuICAoZnVuY3Rpb24gKFN0bXRNb2RpZmllcikge1xuICAgICAgU3RtdE1vZGlmaWVyW1N0bXRNb2RpZmllcltcIkZpbmFsXCJdID0gMF0gPSBcIkZpbmFsXCI7XG4gICAgICBTdG10TW9kaWZpZXJbU3RtdE1vZGlmaWVyW1wiUHJpdmF0ZVwiXSA9IDFdID0gXCJQcml2YXRlXCI7XG4gIH0pKFN0bXRNb2RpZmllciB8fCAoU3RtdE1vZGlmaWVyID0ge30pKTtcbiAgdmFyIFN0YXRlbWVudCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBTdGF0ZW1lbnQobW9kaWZpZXJzKSB7XG4gICAgICAgICAgaWYgKG1vZGlmaWVycyA9PT0gdm9pZCAwKSB7IG1vZGlmaWVycyA9IG51bGw7IH1cbiAgICAgICAgICB0aGlzLm1vZGlmaWVycyA9IG1vZGlmaWVycztcbiAgICAgICAgICBpZiAoIW1vZGlmaWVycykge1xuICAgICAgICAgICAgICB0aGlzLm1vZGlmaWVycyA9IFtdO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFN0YXRlbWVudC5wcm90b3R5cGUuaGFzTW9kaWZpZXIgPSBmdW5jdGlvbiAobW9kaWZpZXIpIHsgcmV0dXJuIHRoaXMubW9kaWZpZXJzLmluZGV4T2YobW9kaWZpZXIpICE9PSAtMTsgfTtcbiAgICAgIHJldHVybiBTdGF0ZW1lbnQ7XG4gIH0oKSk7XG4gIHZhciBEZWNsYXJlVmFyU3RtdCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkMTIoRGVjbGFyZVZhclN0bXQsIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBEZWNsYXJlVmFyU3RtdChuYW1lLCB2YWx1ZSwgdHlwZSwgbW9kaWZpZXJzKSB7XG4gICAgICAgICAgaWYgKHR5cGUgPT09IHZvaWQgMCkgeyB0eXBlID0gbnVsbDsgfVxuICAgICAgICAgIGlmIChtb2RpZmllcnMgPT09IHZvaWQgMCkgeyBtb2RpZmllcnMgPSBudWxsOyB9XG4gICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgbW9kaWZpZXJzKTtcbiAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICB0aGlzLnR5cGUgPSB0eXBlIHx8IHZhbHVlLnR5cGU7XG4gICAgICB9XG4gICAgICBEZWNsYXJlVmFyU3RtdC5wcm90b3R5cGUudmlzaXRTdGF0ZW1lbnQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0RGVjbGFyZVZhclN0bXQodGhpcywgY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIERlY2xhcmVWYXJTdG10O1xuICB9KFN0YXRlbWVudCkpO1xuICB2YXIgRGVjbGFyZUZ1bmN0aW9uU3RtdCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkMTIoRGVjbGFyZUZ1bmN0aW9uU3RtdCwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIERlY2xhcmVGdW5jdGlvblN0bXQobmFtZSwgcGFyYW1zLCBzdGF0ZW1lbnRzLCB0eXBlLCBtb2RpZmllcnMpIHtcbiAgICAgICAgICBpZiAodHlwZSA9PT0gdm9pZCAwKSB7IHR5cGUgPSBudWxsOyB9XG4gICAgICAgICAgaWYgKG1vZGlmaWVycyA9PT0gdm9pZCAwKSB7IG1vZGlmaWVycyA9IG51bGw7IH1cbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBtb2RpZmllcnMpO1xuICAgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgICAgdGhpcy5wYXJhbXMgPSBwYXJhbXM7XG4gICAgICAgICAgdGhpcy5zdGF0ZW1lbnRzID0gc3RhdGVtZW50cztcbiAgICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgfVxuICAgICAgRGVjbGFyZUZ1bmN0aW9uU3RtdC5wcm90b3R5cGUudmlzaXRTdGF0ZW1lbnQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0RGVjbGFyZUZ1bmN0aW9uU3RtdCh0aGlzLCBjb250ZXh0KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gRGVjbGFyZUZ1bmN0aW9uU3RtdDtcbiAgfShTdGF0ZW1lbnQpKTtcbiAgdmFyIEV4cHJlc3Npb25TdGF0ZW1lbnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDEyKEV4cHJlc3Npb25TdGF0ZW1lbnQsIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBFeHByZXNzaW9uU3RhdGVtZW50KGV4cHIpIHtcbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICB0aGlzLmV4cHIgPSBleHByO1xuICAgICAgfVxuICAgICAgRXhwcmVzc2lvblN0YXRlbWVudC5wcm90b3R5cGUudmlzaXRTdGF0ZW1lbnQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0RXhwcmVzc2lvblN0bXQodGhpcywgY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIEV4cHJlc3Npb25TdGF0ZW1lbnQ7XG4gIH0oU3RhdGVtZW50KSk7XG4gIHZhciBSZXR1cm5TdGF0ZW1lbnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDEyKFJldHVyblN0YXRlbWVudCwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIFJldHVyblN0YXRlbWVudCh2YWx1ZSkge1xuICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIFJldHVyblN0YXRlbWVudC5wcm90b3R5cGUudmlzaXRTdGF0ZW1lbnQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0UmV0dXJuU3RtdCh0aGlzLCBjb250ZXh0KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gUmV0dXJuU3RhdGVtZW50O1xuICB9KFN0YXRlbWVudCkpO1xuICB2YXIgQWJzdHJhY3RDbGFzc1BhcnQgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gQWJzdHJhY3RDbGFzc1BhcnQodHlwZSwgbW9kaWZpZXJzKSB7XG4gICAgICAgICAgaWYgKHR5cGUgPT09IHZvaWQgMCkgeyB0eXBlID0gbnVsbDsgfVxuICAgICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgICAgdGhpcy5tb2RpZmllcnMgPSBtb2RpZmllcnM7XG4gICAgICAgICAgaWYgKCFtb2RpZmllcnMpIHtcbiAgICAgICAgICAgICAgdGhpcy5tb2RpZmllcnMgPSBbXTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICBBYnN0cmFjdENsYXNzUGFydC5wcm90b3R5cGUuaGFzTW9kaWZpZXIgPSBmdW5jdGlvbiAobW9kaWZpZXIpIHsgcmV0dXJuIHRoaXMubW9kaWZpZXJzLmluZGV4T2YobW9kaWZpZXIpICE9PSAtMTsgfTtcbiAgICAgIHJldHVybiBBYnN0cmFjdENsYXNzUGFydDtcbiAgfSgpKTtcbiAgdmFyIENsYXNzRmllbGQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDEyKENsYXNzRmllbGQsIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBDbGFzc0ZpZWxkKG5hbWUsIHR5cGUsIG1vZGlmaWVycykge1xuICAgICAgICAgIGlmICh0eXBlID09PSB2b2lkIDApIHsgdHlwZSA9IG51bGw7IH1cbiAgICAgICAgICBpZiAobW9kaWZpZXJzID09PSB2b2lkIDApIHsgbW9kaWZpZXJzID0gbnVsbDsgfVxuICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIHR5cGUsIG1vZGlmaWVycyk7XG4gICAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBDbGFzc0ZpZWxkO1xuICB9KEFic3RyYWN0Q2xhc3NQYXJ0KSk7XG4gIHZhciBDbGFzc01ldGhvZCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkMTIoQ2xhc3NNZXRob2QsIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBDbGFzc01ldGhvZChuYW1lLCBwYXJhbXMsIGJvZHksIHR5cGUsIG1vZGlmaWVycykge1xuICAgICAgICAgIGlmICh0eXBlID09PSB2b2lkIDApIHsgdHlwZSA9IG51bGw7IH1cbiAgICAgICAgICBpZiAobW9kaWZpZXJzID09PSB2b2lkIDApIHsgbW9kaWZpZXJzID0gbnVsbDsgfVxuICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIHR5cGUsIG1vZGlmaWVycyk7XG4gICAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgICB0aGlzLnBhcmFtcyA9IHBhcmFtcztcbiAgICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgICAgfVxuICAgICAgcmV0dXJuIENsYXNzTWV0aG9kO1xuICB9KEFic3RyYWN0Q2xhc3NQYXJ0KSk7XG4gIHZhciBDbGFzc0dldHRlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkMTIoQ2xhc3NHZXR0ZXIsIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBDbGFzc0dldHRlcihuYW1lLCBib2R5LCB0eXBlLCBtb2RpZmllcnMpIHtcbiAgICAgICAgICBpZiAodHlwZSA9PT0gdm9pZCAwKSB7IHR5cGUgPSBudWxsOyB9XG4gICAgICAgICAgaWYgKG1vZGlmaWVycyA9PT0gdm9pZCAwKSB7IG1vZGlmaWVycyA9IG51bGw7IH1cbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCB0eXBlLCBtb2RpZmllcnMpO1xuICAgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBDbGFzc0dldHRlcjtcbiAgfShBYnN0cmFjdENsYXNzUGFydCkpO1xuICB2YXIgQ2xhc3NTdG10ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQxMihDbGFzc1N0bXQsIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBDbGFzc1N0bXQobmFtZSwgcGFyZW50LCBmaWVsZHMsIGdldHRlcnMsIGNvbnN0cnVjdG9yTWV0aG9kLCBtZXRob2RzLCBtb2RpZmllcnMpIHtcbiAgICAgICAgICBpZiAobW9kaWZpZXJzID09PSB2b2lkIDApIHsgbW9kaWZpZXJzID0gbnVsbDsgfVxuICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIG1vZGlmaWVycyk7XG4gICAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgICB0aGlzLmZpZWxkcyA9IGZpZWxkcztcbiAgICAgICAgICB0aGlzLmdldHRlcnMgPSBnZXR0ZXJzO1xuICAgICAgICAgIHRoaXMuY29uc3RydWN0b3JNZXRob2QgPSBjb25zdHJ1Y3Rvck1ldGhvZDtcbiAgICAgICAgICB0aGlzLm1ldGhvZHMgPSBtZXRob2RzO1xuICAgICAgfVxuICAgICAgQ2xhc3NTdG10LnByb3RvdHlwZS52aXNpdFN0YXRlbWVudCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXREZWNsYXJlQ2xhc3NTdG10KHRoaXMsIGNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBDbGFzc1N0bXQ7XG4gIH0oU3RhdGVtZW50KSk7XG4gIHZhciBJZlN0bXQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDEyKElmU3RtdCwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIElmU3RtdChjb25kaXRpb24sIHRydWVDYXNlLCBmYWxzZUNhc2UpIHtcbiAgICAgICAgICBpZiAoZmFsc2VDYXNlID09PSB2b2lkIDApIHsgZmFsc2VDYXNlID0gW107IH1cbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICB0aGlzLmNvbmRpdGlvbiA9IGNvbmRpdGlvbjtcbiAgICAgICAgICB0aGlzLnRydWVDYXNlID0gdHJ1ZUNhc2U7XG4gICAgICAgICAgdGhpcy5mYWxzZUNhc2UgPSBmYWxzZUNhc2U7XG4gICAgICB9XG4gICAgICBJZlN0bXQucHJvdG90eXBlLnZpc2l0U3RhdGVtZW50ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdElmU3RtdCh0aGlzLCBjb250ZXh0KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gSWZTdG10O1xuICB9KFN0YXRlbWVudCkpO1xuICB2YXIgQ29tbWVudFN0bXQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDEyKENvbW1lbnRTdG10LCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gQ29tbWVudFN0bXQoY29tbWVudCkge1xuICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgIHRoaXMuY29tbWVudCA9IGNvbW1lbnQ7XG4gICAgICB9XG4gICAgICBDb21tZW50U3RtdC5wcm90b3R5cGUudmlzaXRTdGF0ZW1lbnQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Q29tbWVudFN0bXQodGhpcywgY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIENvbW1lbnRTdG10O1xuICB9KFN0YXRlbWVudCkpO1xuICB2YXIgVHJ5Q2F0Y2hTdG10ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQxMihUcnlDYXRjaFN0bXQsIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBUcnlDYXRjaFN0bXQoYm9keVN0bXRzLCBjYXRjaFN0bXRzKSB7XG4gICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgdGhpcy5ib2R5U3RtdHMgPSBib2R5U3RtdHM7XG4gICAgICAgICAgdGhpcy5jYXRjaFN0bXRzID0gY2F0Y2hTdG10cztcbiAgICAgIH1cbiAgICAgIFRyeUNhdGNoU3RtdC5wcm90b3R5cGUudmlzaXRTdGF0ZW1lbnQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0VHJ5Q2F0Y2hTdG10KHRoaXMsIGNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBUcnlDYXRjaFN0bXQ7XG4gIH0oU3RhdGVtZW50KSk7XG4gIHZhciBUaHJvd1N0bXQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDEyKFRocm93U3RtdCwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIFRocm93U3RtdChlcnJvcikge1xuICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgIHRoaXMuZXJyb3IgPSBlcnJvcjtcbiAgICAgIH1cbiAgICAgIFRocm93U3RtdC5wcm90b3R5cGUudmlzaXRTdGF0ZW1lbnQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0VGhyb3dTdG10KHRoaXMsIGNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBUaHJvd1N0bXQ7XG4gIH0oU3RhdGVtZW50KSk7XG4gIHZhciBFeHByZXNzaW9uVHJhbnNmb3JtZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gRXhwcmVzc2lvblRyYW5zZm9ybWVyKCkge1xuICAgICAgfVxuICAgICAgRXhwcmVzc2lvblRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdFJlYWRWYXJFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyByZXR1cm4gYXN0OyB9O1xuICAgICAgRXhwcmVzc2lvblRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdFdyaXRlVmFyRXhwciA9IGZ1bmN0aW9uIChleHByLCBjb250ZXh0KSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBXcml0ZVZhckV4cHIoZXhwci5uYW1lLCBleHByLnZhbHVlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KSk7XG4gICAgICB9O1xuICAgICAgRXhwcmVzc2lvblRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdFdyaXRlS2V5RXhwciA9IGZ1bmN0aW9uIChleHByLCBjb250ZXh0KSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBXcml0ZUtleUV4cHIoZXhwci5yZWNlaXZlci52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCksIGV4cHIuaW5kZXgudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpLCBleHByLnZhbHVlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KSk7XG4gICAgICB9O1xuICAgICAgRXhwcmVzc2lvblRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdFdyaXRlUHJvcEV4cHIgPSBmdW5jdGlvbiAoZXhwciwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiBuZXcgV3JpdGVQcm9wRXhwcihleHByLnJlY2VpdmVyLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KSwgZXhwci5uYW1lLCBleHByLnZhbHVlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KSk7XG4gICAgICB9O1xuICAgICAgRXhwcmVzc2lvblRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdEludm9rZU1ldGhvZEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgICAgdmFyIG1ldGhvZCA9IGFzdC5idWlsdGluIHx8IGFzdC5uYW1lO1xuICAgICAgICAgIHJldHVybiBuZXcgSW52b2tlTWV0aG9kRXhwcihhc3QucmVjZWl2ZXIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpLCBtZXRob2QsIHRoaXMudmlzaXRBbGxFeHByZXNzaW9ucyhhc3QuYXJncywgY29udGV4dCksIGFzdC50eXBlKTtcbiAgICAgIH07XG4gICAgICBFeHByZXNzaW9uVHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0SW52b2tlRnVuY3Rpb25FeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiBuZXcgSW52b2tlRnVuY3Rpb25FeHByKGFzdC5mbi52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCksIHRoaXMudmlzaXRBbGxFeHByZXNzaW9ucyhhc3QuYXJncywgY29udGV4dCksIGFzdC50eXBlKTtcbiAgICAgIH07XG4gICAgICBFeHByZXNzaW9uVHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0SW5zdGFudGlhdGVFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiBuZXcgSW5zdGFudGlhdGVFeHByKGFzdC5jbGFzc0V4cHIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpLCB0aGlzLnZpc2l0QWxsRXhwcmVzc2lvbnMoYXN0LmFyZ3MsIGNvbnRleHQpLCBhc3QudHlwZSk7XG4gICAgICB9O1xuICAgICAgRXhwcmVzc2lvblRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdExpdGVyYWxFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyByZXR1cm4gYXN0OyB9O1xuICAgICAgRXhwcmVzc2lvblRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdEV4dGVybmFsRXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgcmV0dXJuIGFzdDsgfTtcbiAgICAgIEV4cHJlc3Npb25UcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRDb25kaXRpb25hbEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBDb25kaXRpb25hbEV4cHIoYXN0LmNvbmRpdGlvbi52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCksIGFzdC50cnVlQ2FzZS52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCksIGFzdC5mYWxzZUNhc2UudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpKTtcbiAgICAgIH07XG4gICAgICBFeHByZXNzaW9uVHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0Tm90RXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IE5vdEV4cHIoYXN0LmNvbmRpdGlvbi52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCkpO1xuICAgICAgfTtcbiAgICAgIEV4cHJlc3Npb25UcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRDYXN0RXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IENhc3RFeHByKGFzdC52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCksIGNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIEV4cHJlc3Npb25UcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRGdW5jdGlvbkV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgICAgLy8gRG9uJ3QgZGVzY2VuZCBpbnRvIG5lc3RlZCBmdW5jdGlvbnNcbiAgICAgICAgICByZXR1cm4gYXN0O1xuICAgICAgfTtcbiAgICAgIEV4cHJlc3Npb25UcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRCaW5hcnlPcGVyYXRvckV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBCaW5hcnlPcGVyYXRvckV4cHIoYXN0Lm9wZXJhdG9yLCBhc3QubGhzLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KSwgYXN0LnJocy52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCksIGFzdC50eXBlKTtcbiAgICAgIH07XG4gICAgICBFeHByZXNzaW9uVHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0UmVhZFByb3BFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiBuZXcgUmVhZFByb3BFeHByKGFzdC5yZWNlaXZlci52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCksIGFzdC5uYW1lLCBhc3QudHlwZSk7XG4gICAgICB9O1xuICAgICAgRXhwcmVzc2lvblRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdFJlYWRLZXlFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiBuZXcgUmVhZEtleUV4cHIoYXN0LnJlY2VpdmVyLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KSwgYXN0LmluZGV4LnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KSwgYXN0LnR5cGUpO1xuICAgICAgfTtcbiAgICAgIEV4cHJlc3Npb25UcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRMaXRlcmFsQXJyYXlFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiBuZXcgTGl0ZXJhbEFycmF5RXhwcih0aGlzLnZpc2l0QWxsRXhwcmVzc2lvbnMoYXN0LmVudHJpZXMsIGNvbnRleHQpKTtcbiAgICAgIH07XG4gICAgICBFeHByZXNzaW9uVHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0TGl0ZXJhbE1hcEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICB2YXIgZW50cmllcyA9IGFzdC5lbnRyaWVzLm1hcChmdW5jdGlvbiAoZW50cnkpIHsgcmV0dXJuIFtlbnRyeVswXSwgZW50cnlbMV0udmlzaXRFeHByZXNzaW9uKF90aGlzLCBjb250ZXh0KSxdOyB9KTtcbiAgICAgICAgICByZXR1cm4gbmV3IExpdGVyYWxNYXBFeHByKGVudHJpZXMpO1xuICAgICAgfTtcbiAgICAgIEV4cHJlc3Npb25UcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRBbGxFeHByZXNzaW9ucyA9IGZ1bmN0aW9uIChleHBycywgY29udGV4dCkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgcmV0dXJuIGV4cHJzLm1hcChmdW5jdGlvbiAoZXhwcikgeyByZXR1cm4gZXhwci52aXNpdEV4cHJlc3Npb24oX3RoaXMsIGNvbnRleHQpOyB9KTtcbiAgICAgIH07XG4gICAgICBFeHByZXNzaW9uVHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0RGVjbGFyZVZhclN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiBuZXcgRGVjbGFyZVZhclN0bXQoc3RtdC5uYW1lLCBzdG10LnZhbHVlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KSwgc3RtdC50eXBlLCBzdG10Lm1vZGlmaWVycyk7XG4gICAgICB9O1xuICAgICAgRXhwcmVzc2lvblRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdERlY2xhcmVGdW5jdGlvblN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY29udGV4dCkge1xuICAgICAgICAgIC8vIERvbid0IGRlc2NlbmQgaW50byBuZXN0ZWQgZnVuY3Rpb25zXG4gICAgICAgICAgcmV0dXJuIHN0bXQ7XG4gICAgICB9O1xuICAgICAgRXhwcmVzc2lvblRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdEV4cHJlc3Npb25TdG10ID0gZnVuY3Rpb24gKHN0bXQsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IEV4cHJlc3Npb25TdGF0ZW1lbnQoc3RtdC5leHByLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KSk7XG4gICAgICB9O1xuICAgICAgRXhwcmVzc2lvblRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdFJldHVyblN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiBuZXcgUmV0dXJuU3RhdGVtZW50KHN0bXQudmFsdWUudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpKTtcbiAgICAgIH07XG4gICAgICBFeHByZXNzaW9uVHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0RGVjbGFyZUNsYXNzU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjb250ZXh0KSB7XG4gICAgICAgICAgLy8gRG9uJ3QgZGVzY2VuZCBpbnRvIG5lc3RlZCBmdW5jdGlvbnNcbiAgICAgICAgICByZXR1cm4gc3RtdDtcbiAgICAgIH07XG4gICAgICBFeHByZXNzaW9uVHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0SWZTdG10ID0gZnVuY3Rpb24gKHN0bXQsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IElmU3RtdChzdG10LmNvbmRpdGlvbi52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCksIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKHN0bXQudHJ1ZUNhc2UsIGNvbnRleHQpLCB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhzdG10LmZhbHNlQ2FzZSwgY29udGV4dCkpO1xuICAgICAgfTtcbiAgICAgIEV4cHJlc3Npb25UcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRUcnlDYXRjaFN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiBuZXcgVHJ5Q2F0Y2hTdG10KHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKHN0bXQuYm9keVN0bXRzLCBjb250ZXh0KSwgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoc3RtdC5jYXRjaFN0bXRzLCBjb250ZXh0KSk7XG4gICAgICB9O1xuICAgICAgRXhwcmVzc2lvblRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdFRocm93U3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjb250ZXh0KSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBUaHJvd1N0bXQoc3RtdC5lcnJvci52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCkpO1xuICAgICAgfTtcbiAgICAgIEV4cHJlc3Npb25UcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRDb21tZW50U3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjb250ZXh0KSB7IHJldHVybiBzdG10OyB9O1xuICAgICAgRXhwcmVzc2lvblRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdEFsbFN0YXRlbWVudHMgPSBmdW5jdGlvbiAoc3RtdHMsIGNvbnRleHQpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHJldHVybiBzdG10cy5tYXAoZnVuY3Rpb24gKHN0bXQpIHsgcmV0dXJuIHN0bXQudmlzaXRTdGF0ZW1lbnQoX3RoaXMsIGNvbnRleHQpOyB9KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gRXhwcmVzc2lvblRyYW5zZm9ybWVyO1xuICB9KCkpO1xuICB2YXIgUmVjdXJzaXZlRXhwcmVzc2lvblZpc2l0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gUmVjdXJzaXZlRXhwcmVzc2lvblZpc2l0b3IoKSB7XG4gICAgICB9XG4gICAgICBSZWN1cnNpdmVFeHByZXNzaW9uVmlzaXRvci5wcm90b3R5cGUudmlzaXRSZWFkVmFyRXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgcmV0dXJuIGFzdDsgfTtcbiAgICAgIFJlY3Vyc2l2ZUV4cHJlc3Npb25WaXNpdG9yLnByb3RvdHlwZS52aXNpdFdyaXRlVmFyRXhwciA9IGZ1bmN0aW9uIChleHByLCBjb250ZXh0KSB7XG4gICAgICAgICAgZXhwci52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgICB9O1xuICAgICAgUmVjdXJzaXZlRXhwcmVzc2lvblZpc2l0b3IucHJvdG90eXBlLnZpc2l0V3JpdGVLZXlFeHByID0gZnVuY3Rpb24gKGV4cHIsIGNvbnRleHQpIHtcbiAgICAgICAgICBleHByLnJlY2VpdmVyLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgICBleHByLmluZGV4LnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgICBleHByLnZhbHVlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgICByZXR1cm4gZXhwcjtcbiAgICAgIH07XG4gICAgICBSZWN1cnNpdmVFeHByZXNzaW9uVmlzaXRvci5wcm90b3R5cGUudmlzaXRXcml0ZVByb3BFeHByID0gZnVuY3Rpb24gKGV4cHIsIGNvbnRleHQpIHtcbiAgICAgICAgICBleHByLnJlY2VpdmVyLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgICBleHByLnZhbHVlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgICByZXR1cm4gZXhwcjtcbiAgICAgIH07XG4gICAgICBSZWN1cnNpdmVFeHByZXNzaW9uVmlzaXRvci5wcm90b3R5cGUudmlzaXRJbnZva2VNZXRob2RFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICAgIGFzdC5yZWNlaXZlci52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgICAgdGhpcy52aXNpdEFsbEV4cHJlc3Npb25zKGFzdC5hcmdzLCBjb250ZXh0KTtcbiAgICAgICAgICByZXR1cm4gYXN0O1xuICAgICAgfTtcbiAgICAgIFJlY3Vyc2l2ZUV4cHJlc3Npb25WaXNpdG9yLnByb3RvdHlwZS52aXNpdEludm9rZUZ1bmN0aW9uRXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgICBhc3QuZm4udmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICAgIHRoaXMudmlzaXRBbGxFeHByZXNzaW9ucyhhc3QuYXJncywgY29udGV4dCk7XG4gICAgICAgICAgcmV0dXJuIGFzdDtcbiAgICAgIH07XG4gICAgICBSZWN1cnNpdmVFeHByZXNzaW9uVmlzaXRvci5wcm90b3R5cGUudmlzaXRJbnN0YW50aWF0ZUV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgICAgYXN0LmNsYXNzRXhwci52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgICAgdGhpcy52aXNpdEFsbEV4cHJlc3Npb25zKGFzdC5hcmdzLCBjb250ZXh0KTtcbiAgICAgICAgICByZXR1cm4gYXN0O1xuICAgICAgfTtcbiAgICAgIFJlY3Vyc2l2ZUV4cHJlc3Npb25WaXNpdG9yLnByb3RvdHlwZS52aXNpdExpdGVyYWxFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyByZXR1cm4gYXN0OyB9O1xuICAgICAgUmVjdXJzaXZlRXhwcmVzc2lvblZpc2l0b3IucHJvdG90eXBlLnZpc2l0RXh0ZXJuYWxFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyByZXR1cm4gYXN0OyB9O1xuICAgICAgUmVjdXJzaXZlRXhwcmVzc2lvblZpc2l0b3IucHJvdG90eXBlLnZpc2l0Q29uZGl0aW9uYWxFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICAgIGFzdC5jb25kaXRpb24udmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICAgIGFzdC50cnVlQ2FzZS52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgICAgYXN0LmZhbHNlQ2FzZS52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgICAgcmV0dXJuIGFzdDtcbiAgICAgIH07XG4gICAgICBSZWN1cnNpdmVFeHByZXNzaW9uVmlzaXRvci5wcm90b3R5cGUudmlzaXROb3RFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICAgIGFzdC5jb25kaXRpb24udmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICAgIHJldHVybiBhc3Q7XG4gICAgICB9O1xuICAgICAgUmVjdXJzaXZlRXhwcmVzc2lvblZpc2l0b3IucHJvdG90eXBlLnZpc2l0Q2FzdEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgICAgYXN0LnZhbHVlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgICByZXR1cm4gYXN0O1xuICAgICAgfTtcbiAgICAgIFJlY3Vyc2l2ZUV4cHJlc3Npb25WaXNpdG9yLnByb3RvdHlwZS52aXNpdEZ1bmN0aW9uRXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgcmV0dXJuIGFzdDsgfTtcbiAgICAgIFJlY3Vyc2l2ZUV4cHJlc3Npb25WaXNpdG9yLnByb3RvdHlwZS52aXNpdEJpbmFyeU9wZXJhdG9yRXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgICBhc3QubGhzLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgICBhc3QucmhzLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgICByZXR1cm4gYXN0O1xuICAgICAgfTtcbiAgICAgIFJlY3Vyc2l2ZUV4cHJlc3Npb25WaXNpdG9yLnByb3RvdHlwZS52aXNpdFJlYWRQcm9wRXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgICBhc3QucmVjZWl2ZXIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICAgIHJldHVybiBhc3Q7XG4gICAgICB9O1xuICAgICAgUmVjdXJzaXZlRXhwcmVzc2lvblZpc2l0b3IucHJvdG90eXBlLnZpc2l0UmVhZEtleUV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgICAgYXN0LnJlY2VpdmVyLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgICBhc3QuaW5kZXgudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICAgIHJldHVybiBhc3Q7XG4gICAgICB9O1xuICAgICAgUmVjdXJzaXZlRXhwcmVzc2lvblZpc2l0b3IucHJvdG90eXBlLnZpc2l0TGl0ZXJhbEFycmF5RXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgICB0aGlzLnZpc2l0QWxsRXhwcmVzc2lvbnMoYXN0LmVudHJpZXMsIGNvbnRleHQpO1xuICAgICAgICAgIHJldHVybiBhc3Q7XG4gICAgICB9O1xuICAgICAgUmVjdXJzaXZlRXhwcmVzc2lvblZpc2l0b3IucHJvdG90eXBlLnZpc2l0TGl0ZXJhbE1hcEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICBhc3QuZW50cmllcy5mb3JFYWNoKGZ1bmN0aW9uIChlbnRyeSkgeyByZXR1cm4gZW50cnlbMV0udmlzaXRFeHByZXNzaW9uKF90aGlzLCBjb250ZXh0KTsgfSk7XG4gICAgICAgICAgcmV0dXJuIGFzdDtcbiAgICAgIH07XG4gICAgICBSZWN1cnNpdmVFeHByZXNzaW9uVmlzaXRvci5wcm90b3R5cGUudmlzaXRBbGxFeHByZXNzaW9ucyA9IGZ1bmN0aW9uIChleHBycywgY29udGV4dCkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgZXhwcnMuZm9yRWFjaChmdW5jdGlvbiAoZXhwcikgeyByZXR1cm4gZXhwci52aXNpdEV4cHJlc3Npb24oX3RoaXMsIGNvbnRleHQpOyB9KTtcbiAgICAgIH07XG4gICAgICBSZWN1cnNpdmVFeHByZXNzaW9uVmlzaXRvci5wcm90b3R5cGUudmlzaXREZWNsYXJlVmFyU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjb250ZXh0KSB7XG4gICAgICAgICAgc3RtdC52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgICAgcmV0dXJuIHN0bXQ7XG4gICAgICB9O1xuICAgICAgUmVjdXJzaXZlRXhwcmVzc2lvblZpc2l0b3IucHJvdG90eXBlLnZpc2l0RGVjbGFyZUZ1bmN0aW9uU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjb250ZXh0KSB7XG4gICAgICAgICAgLy8gRG9uJ3QgZGVzY2VuZCBpbnRvIG5lc3RlZCBmdW5jdGlvbnNcbiAgICAgICAgICByZXR1cm4gc3RtdDtcbiAgICAgIH07XG4gICAgICBSZWN1cnNpdmVFeHByZXNzaW9uVmlzaXRvci5wcm90b3R5cGUudmlzaXRFeHByZXNzaW9uU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjb250ZXh0KSB7XG4gICAgICAgICAgc3RtdC5leHByLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgICByZXR1cm4gc3RtdDtcbiAgICAgIH07XG4gICAgICBSZWN1cnNpdmVFeHByZXNzaW9uVmlzaXRvci5wcm90b3R5cGUudmlzaXRSZXR1cm5TdG10ID0gZnVuY3Rpb24gKHN0bXQsIGNvbnRleHQpIHtcbiAgICAgICAgICBzdG10LnZhbHVlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgICByZXR1cm4gc3RtdDtcbiAgICAgIH07XG4gICAgICBSZWN1cnNpdmVFeHByZXNzaW9uVmlzaXRvci5wcm90b3R5cGUudmlzaXREZWNsYXJlQ2xhc3NTdG10ID0gZnVuY3Rpb24gKHN0bXQsIGNvbnRleHQpIHtcbiAgICAgICAgICAvLyBEb24ndCBkZXNjZW5kIGludG8gbmVzdGVkIGZ1bmN0aW9uc1xuICAgICAgICAgIHJldHVybiBzdG10O1xuICAgICAgfTtcbiAgICAgIFJlY3Vyc2l2ZUV4cHJlc3Npb25WaXNpdG9yLnByb3RvdHlwZS52aXNpdElmU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjb250ZXh0KSB7XG4gICAgICAgICAgc3RtdC5jb25kaXRpb24udmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICAgIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKHN0bXQudHJ1ZUNhc2UsIGNvbnRleHQpO1xuICAgICAgICAgIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKHN0bXQuZmFsc2VDYXNlLCBjb250ZXh0KTtcbiAgICAgICAgICByZXR1cm4gc3RtdDtcbiAgICAgIH07XG4gICAgICBSZWN1cnNpdmVFeHByZXNzaW9uVmlzaXRvci5wcm90b3R5cGUudmlzaXRUcnlDYXRjaFN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY29udGV4dCkge1xuICAgICAgICAgIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKHN0bXQuYm9keVN0bXRzLCBjb250ZXh0KTtcbiAgICAgICAgICB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhzdG10LmNhdGNoU3RtdHMsIGNvbnRleHQpO1xuICAgICAgICAgIHJldHVybiBzdG10O1xuICAgICAgfTtcbiAgICAgIFJlY3Vyc2l2ZUV4cHJlc3Npb25WaXNpdG9yLnByb3RvdHlwZS52aXNpdFRocm93U3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjb250ZXh0KSB7XG4gICAgICAgICAgc3RtdC5lcnJvci52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgICAgcmV0dXJuIHN0bXQ7XG4gICAgICB9O1xuICAgICAgUmVjdXJzaXZlRXhwcmVzc2lvblZpc2l0b3IucHJvdG90eXBlLnZpc2l0Q29tbWVudFN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY29udGV4dCkgeyByZXR1cm4gc3RtdDsgfTtcbiAgICAgIFJlY3Vyc2l2ZUV4cHJlc3Npb25WaXNpdG9yLnByb3RvdHlwZS52aXNpdEFsbFN0YXRlbWVudHMgPSBmdW5jdGlvbiAoc3RtdHMsIGNvbnRleHQpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHN0bXRzLmZvckVhY2goZnVuY3Rpb24gKHN0bXQpIHsgcmV0dXJuIHN0bXQudmlzaXRTdGF0ZW1lbnQoX3RoaXMsIGNvbnRleHQpOyB9KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gUmVjdXJzaXZlRXhwcmVzc2lvblZpc2l0b3I7XG4gIH0oKSk7XG4gIGZ1bmN0aW9uIHJlcGxhY2VWYXJJbkV4cHJlc3Npb24odmFyTmFtZSwgbmV3VmFsdWUsIGV4cHJlc3Npb24pIHtcbiAgICAgIHZhciB0cmFuc2Zvcm1lciA9IG5ldyBfUmVwbGFjZVZhcmlhYmxlVHJhbnNmb3JtZXIodmFyTmFtZSwgbmV3VmFsdWUpO1xuICAgICAgcmV0dXJuIGV4cHJlc3Npb24udmlzaXRFeHByZXNzaW9uKHRyYW5zZm9ybWVyLCBudWxsKTtcbiAgfVxuICB2YXIgX1JlcGxhY2VWYXJpYWJsZVRyYW5zZm9ybWVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQxMihfUmVwbGFjZVZhcmlhYmxlVHJhbnNmb3JtZXIsIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBfUmVwbGFjZVZhcmlhYmxlVHJhbnNmb3JtZXIoX3Zhck5hbWUsIF9uZXdWYWx1ZSkge1xuICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgIHRoaXMuX3Zhck5hbWUgPSBfdmFyTmFtZTtcbiAgICAgICAgICB0aGlzLl9uZXdWYWx1ZSA9IF9uZXdWYWx1ZTtcbiAgICAgIH1cbiAgICAgIF9SZXBsYWNlVmFyaWFibGVUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRSZWFkVmFyRXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gYXN0Lm5hbWUgPT0gdGhpcy5fdmFyTmFtZSA/IHRoaXMuX25ld1ZhbHVlIDogYXN0O1xuICAgICAgfTtcbiAgICAgIHJldHVybiBfUmVwbGFjZVZhcmlhYmxlVHJhbnNmb3JtZXI7XG4gIH0oRXhwcmVzc2lvblRyYW5zZm9ybWVyKSk7XG4gIGZ1bmN0aW9uIGZpbmRSZWFkVmFyTmFtZXMoc3RtdHMpIHtcbiAgICAgIHZhciBmaW5kZXIgPSBuZXcgX1ZhcmlhYmxlRmluZGVyKCk7XG4gICAgICBmaW5kZXIudmlzaXRBbGxTdGF0ZW1lbnRzKHN0bXRzLCBudWxsKTtcbiAgICAgIHJldHVybiBmaW5kZXIudmFyTmFtZXM7XG4gIH1cbiAgdmFyIF9WYXJpYWJsZUZpbmRlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkMTIoX1ZhcmlhYmxlRmluZGVyLCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gX1ZhcmlhYmxlRmluZGVyKCkge1xuICAgICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgIHRoaXMudmFyTmFtZXMgPSBuZXcgU2V0KCk7XG4gICAgICB9XG4gICAgICBfVmFyaWFibGVGaW5kZXIucHJvdG90eXBlLnZpc2l0UmVhZFZhckV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgICAgdGhpcy52YXJOYW1lcy5hZGQoYXN0Lm5hbWUpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBfVmFyaWFibGVGaW5kZXI7XG4gIH0oUmVjdXJzaXZlRXhwcmVzc2lvblZpc2l0b3IpKTtcbiAgZnVuY3Rpb24gdmFyaWFibGUobmFtZSwgdHlwZSkge1xuICAgICAgaWYgKHR5cGUgPT09IHZvaWQgMCkgeyB0eXBlID0gbnVsbDsgfVxuICAgICAgcmV0dXJuIG5ldyBSZWFkVmFyRXhwcihuYW1lLCB0eXBlKTtcbiAgfVxuICBmdW5jdGlvbiBpbXBvcnRFeHByKGlkLCB0eXBlUGFyYW1zKSB7XG4gICAgICBpZiAodHlwZVBhcmFtcyA9PT0gdm9pZCAwKSB7IHR5cGVQYXJhbXMgPSBudWxsOyB9XG4gICAgICByZXR1cm4gbmV3IEV4dGVybmFsRXhwcihpZCwgbnVsbCwgdHlwZVBhcmFtcyk7XG4gIH1cbiAgZnVuY3Rpb24gaW1wb3J0VHlwZShpZCwgdHlwZVBhcmFtcywgdHlwZU1vZGlmaWVycykge1xuICAgICAgaWYgKHR5cGVQYXJhbXMgPT09IHZvaWQgMCkgeyB0eXBlUGFyYW1zID0gbnVsbDsgfVxuICAgICAgaWYgKHR5cGVNb2RpZmllcnMgPT09IHZvaWQgMCkgeyB0eXBlTW9kaWZpZXJzID0gbnVsbDsgfVxuICAgICAgcmV0dXJuIGlzUHJlc2VudChpZCkgPyBuZXcgRXh0ZXJuYWxUeXBlKGlkLCB0eXBlUGFyYW1zLCB0eXBlTW9kaWZpZXJzKSA6IG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gbGl0ZXJhbEFycih2YWx1ZXMsIHR5cGUpIHtcbiAgICAgIGlmICh0eXBlID09PSB2b2lkIDApIHsgdHlwZSA9IG51bGw7IH1cbiAgICAgIHJldHVybiBuZXcgTGl0ZXJhbEFycmF5RXhwcih2YWx1ZXMsIHR5cGUpO1xuICB9XG4gIGZ1bmN0aW9uIGxpdGVyYWxNYXAodmFsdWVzLCB0eXBlKSB7XG4gICAgICBpZiAodHlwZSA9PT0gdm9pZCAwKSB7IHR5cGUgPSBudWxsOyB9XG4gICAgICByZXR1cm4gbmV3IExpdGVyYWxNYXBFeHByKHZhbHVlcywgdHlwZSk7XG4gIH1cbiAgZnVuY3Rpb24gbm90KGV4cHIpIHtcbiAgICAgIHJldHVybiBuZXcgTm90RXhwcihleHByKTtcbiAgfVxuICBmdW5jdGlvbiBmbihwYXJhbXMsIGJvZHksIHR5cGUpIHtcbiAgICAgIGlmICh0eXBlID09PSB2b2lkIDApIHsgdHlwZSA9IG51bGw7IH1cbiAgICAgIHJldHVybiBuZXcgRnVuY3Rpb25FeHByKHBhcmFtcywgYm9keSwgdHlwZSk7XG4gIH1cbiAgZnVuY3Rpb24gbGl0ZXJhbCh2YWx1ZSwgdHlwZSkge1xuICAgICAgaWYgKHR5cGUgPT09IHZvaWQgMCkgeyB0eXBlID0gbnVsbDsgfVxuICAgICAgcmV0dXJuIG5ldyBMaXRlcmFsRXhwcih2YWx1ZSwgdHlwZSk7XG4gIH1cblxuICAvKipcbiAgICogQGxpY2Vuc2VcbiAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAqXG4gICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICovXG4gIHZhciBfX2V4dGVuZHMkMTMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gIH07XG4gIHZhciBBbmltYXRpb25Bc3QgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gQW5pbWF0aW9uQXN0KCkge1xuICAgICAgICAgIHRoaXMuc3RhcnRUaW1lID0gMDtcbiAgICAgICAgICB0aGlzLnBsYXlUaW1lID0gMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBBbmltYXRpb25Bc3Q7XG4gIH0oKSk7XG4gIHZhciBBbmltYXRpb25TdGF0ZUFzdCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkMTMoQW5pbWF0aW9uU3RhdGVBc3QsIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBBbmltYXRpb25TdGF0ZUFzdCgpIHtcbiAgICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBBbmltYXRpb25TdGF0ZUFzdDtcbiAgfShBbmltYXRpb25Bc3QpKTtcbiAgdmFyIEFuaW1hdGlvbkVudHJ5QXN0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQxMyhBbmltYXRpb25FbnRyeUFzdCwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIEFuaW1hdGlvbkVudHJ5QXN0KG5hbWUsIHN0YXRlRGVjbGFyYXRpb25zLCBzdGF0ZVRyYW5zaXRpb25zKSB7XG4gICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgICB0aGlzLnN0YXRlRGVjbGFyYXRpb25zID0gc3RhdGVEZWNsYXJhdGlvbnM7XG4gICAgICAgICAgdGhpcy5zdGF0ZVRyYW5zaXRpb25zID0gc3RhdGVUcmFuc2l0aW9ucztcbiAgICAgIH1cbiAgICAgIEFuaW1hdGlvbkVudHJ5QXN0LnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRBbmltYXRpb25FbnRyeSh0aGlzLCBjb250ZXh0KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gQW5pbWF0aW9uRW50cnlBc3Q7XG4gIH0oQW5pbWF0aW9uQXN0KSk7XG4gIHZhciBBbmltYXRpb25TdGF0ZURlY2xhcmF0aW9uQXN0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQxMyhBbmltYXRpb25TdGF0ZURlY2xhcmF0aW9uQXN0LCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gQW5pbWF0aW9uU3RhdGVEZWNsYXJhdGlvbkFzdChzdGF0ZU5hbWUsIHN0eWxlcykge1xuICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgIHRoaXMuc3RhdGVOYW1lID0gc3RhdGVOYW1lO1xuICAgICAgICAgIHRoaXMuc3R5bGVzID0gc3R5bGVzO1xuICAgICAgfVxuICAgICAgQW5pbWF0aW9uU3RhdGVEZWNsYXJhdGlvbkFzdC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0QW5pbWF0aW9uU3RhdGVEZWNsYXJhdGlvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gQW5pbWF0aW9uU3RhdGVEZWNsYXJhdGlvbkFzdDtcbiAgfShBbmltYXRpb25TdGF0ZUFzdCkpO1xuICB2YXIgQW5pbWF0aW9uU3RhdGVUcmFuc2l0aW9uRXhwcmVzc2lvbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBBbmltYXRpb25TdGF0ZVRyYW5zaXRpb25FeHByZXNzaW9uKGZyb21TdGF0ZSwgdG9TdGF0ZSkge1xuICAgICAgICAgIHRoaXMuZnJvbVN0YXRlID0gZnJvbVN0YXRlO1xuICAgICAgICAgIHRoaXMudG9TdGF0ZSA9IHRvU3RhdGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gQW5pbWF0aW9uU3RhdGVUcmFuc2l0aW9uRXhwcmVzc2lvbjtcbiAgfSgpKTtcbiAgdmFyIEFuaW1hdGlvblN0YXRlVHJhbnNpdGlvbkFzdCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkMTMoQW5pbWF0aW9uU3RhdGVUcmFuc2l0aW9uQXN0LCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gQW5pbWF0aW9uU3RhdGVUcmFuc2l0aW9uQXN0KHN0YXRlQ2hhbmdlcywgYW5pbWF0aW9uKSB7XG4gICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgdGhpcy5zdGF0ZUNoYW5nZXMgPSBzdGF0ZUNoYW5nZXM7XG4gICAgICAgICAgdGhpcy5hbmltYXRpb24gPSBhbmltYXRpb247XG4gICAgICB9XG4gICAgICBBbmltYXRpb25TdGF0ZVRyYW5zaXRpb25Bc3QucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEFuaW1hdGlvblN0YXRlVHJhbnNpdGlvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gQW5pbWF0aW9uU3RhdGVUcmFuc2l0aW9uQXN0O1xuICB9KEFuaW1hdGlvblN0YXRlQXN0KSk7XG4gIHZhciBBbmltYXRpb25TdGVwQXN0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQxMyhBbmltYXRpb25TdGVwQXN0LCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gQW5pbWF0aW9uU3RlcEFzdChzdGFydGluZ1N0eWxlcywga2V5ZnJhbWVzLCBkdXJhdGlvbiwgZGVsYXksIGVhc2luZykge1xuICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgIHRoaXMuc3RhcnRpbmdTdHlsZXMgPSBzdGFydGluZ1N0eWxlcztcbiAgICAgICAgICB0aGlzLmtleWZyYW1lcyA9IGtleWZyYW1lcztcbiAgICAgICAgICB0aGlzLmR1cmF0aW9uID0gZHVyYXRpb247XG4gICAgICAgICAgdGhpcy5kZWxheSA9IGRlbGF5O1xuICAgICAgICAgIHRoaXMuZWFzaW5nID0gZWFzaW5nO1xuICAgICAgfVxuICAgICAgQW5pbWF0aW9uU3RlcEFzdC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0QW5pbWF0aW9uU3RlcCh0aGlzLCBjb250ZXh0KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gQW5pbWF0aW9uU3RlcEFzdDtcbiAgfShBbmltYXRpb25Bc3QpKTtcbiAgdmFyIEFuaW1hdGlvblN0eWxlc0FzdCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkMTMoQW5pbWF0aW9uU3R5bGVzQXN0LCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gQW5pbWF0aW9uU3R5bGVzQXN0KHN0eWxlcykge1xuICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgIHRoaXMuc3R5bGVzID0gc3R5bGVzO1xuICAgICAgfVxuICAgICAgQW5pbWF0aW9uU3R5bGVzQXN0LnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRBbmltYXRpb25TdHlsZXModGhpcywgY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIEFuaW1hdGlvblN0eWxlc0FzdDtcbiAgfShBbmltYXRpb25Bc3QpKTtcbiAgdmFyIEFuaW1hdGlvbktleWZyYW1lQXN0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQxMyhBbmltYXRpb25LZXlmcmFtZUFzdCwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIEFuaW1hdGlvbktleWZyYW1lQXN0KG9mZnNldCwgc3R5bGVzKSB7XG4gICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgICAgdGhpcy5zdHlsZXMgPSBzdHlsZXM7XG4gICAgICB9XG4gICAgICBBbmltYXRpb25LZXlmcmFtZUFzdC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0QW5pbWF0aW9uS2V5ZnJhbWUodGhpcywgY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIEFuaW1hdGlvbktleWZyYW1lQXN0O1xuICB9KEFuaW1hdGlvbkFzdCkpO1xuICB2YXIgQW5pbWF0aW9uV2l0aFN0ZXBzQXN0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQxMyhBbmltYXRpb25XaXRoU3RlcHNBc3QsIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBBbmltYXRpb25XaXRoU3RlcHNBc3Qoc3RlcHMpIHtcbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICB0aGlzLnN0ZXBzID0gc3RlcHM7XG4gICAgICB9XG4gICAgICByZXR1cm4gQW5pbWF0aW9uV2l0aFN0ZXBzQXN0O1xuICB9KEFuaW1hdGlvbkFzdCkpO1xuICB2YXIgQW5pbWF0aW9uR3JvdXBBc3QgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDEzKEFuaW1hdGlvbkdyb3VwQXN0LCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gQW5pbWF0aW9uR3JvdXBBc3Qoc3RlcHMpIHtcbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBzdGVwcyk7XG4gICAgICB9XG4gICAgICBBbmltYXRpb25Hcm91cEFzdC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0QW5pbWF0aW9uR3JvdXAodGhpcywgY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIEFuaW1hdGlvbkdyb3VwQXN0O1xuICB9KEFuaW1hdGlvbldpdGhTdGVwc0FzdCkpO1xuICB2YXIgQW5pbWF0aW9uU2VxdWVuY2VBc3QgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDEzKEFuaW1hdGlvblNlcXVlbmNlQXN0LCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gQW5pbWF0aW9uU2VxdWVuY2VBc3Qoc3RlcHMpIHtcbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBzdGVwcyk7XG4gICAgICB9XG4gICAgICBBbmltYXRpb25TZXF1ZW5jZUFzdC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0QW5pbWF0aW9uU2VxdWVuY2UodGhpcywgY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIEFuaW1hdGlvblNlcXVlbmNlQXN0O1xuICB9KEFuaW1hdGlvbldpdGhTdGVwc0FzdCkpO1xuXG4gIHZhciBBbmltYXRpb25FbnRyeUNvbXBpbGVSZXN1bHQgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gQW5pbWF0aW9uRW50cnlDb21waWxlUmVzdWx0KG5hbWUsIHN0YXRlbWVudHMsIGZuRXhwKSB7XG4gICAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgICB0aGlzLnN0YXRlbWVudHMgPSBzdGF0ZW1lbnRzO1xuICAgICAgICAgIHRoaXMuZm5FeHAgPSBmbkV4cDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBBbmltYXRpb25FbnRyeUNvbXBpbGVSZXN1bHQ7XG4gIH0oKSk7XG4gIHZhciBBbmltYXRpb25Db21waWxlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBBbmltYXRpb25Db21waWxlcigpIHtcbiAgICAgIH1cbiAgICAgIEFuaW1hdGlvbkNvbXBpbGVyLnByb3RvdHlwZS5jb21waWxlID0gZnVuY3Rpb24gKGZhY3RvcnlOYW1lUHJlZml4LCBwYXJzZWRBbmltYXRpb25zKSB7XG4gICAgICAgICAgcmV0dXJuIHBhcnNlZEFuaW1hdGlvbnMubWFwKGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICAgICAgICB2YXIgZmFjdG9yeU5hbWUgPSBmYWN0b3J5TmFtZVByZWZpeCArIFwiX1wiICsgZW50cnkubmFtZTtcbiAgICAgICAgICAgICAgdmFyIHZpc2l0b3IgPSBuZXcgX0FuaW1hdGlvbkJ1aWxkZXIoZW50cnkubmFtZSwgZmFjdG9yeU5hbWUpO1xuICAgICAgICAgICAgICByZXR1cm4gdmlzaXRvci5idWlsZChlbnRyeSk7XG4gICAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIEFuaW1hdGlvbkNvbXBpbGVyO1xuICB9KCkpO1xuICB2YXIgX0FOSU1BVElPTl9GQUNUT1JZX0VMRU1FTlRfVkFSID0gdmFyaWFibGUoJ2VsZW1lbnQnKTtcbiAgdmFyIF9BTklNQVRJT05fREVGQVVMVF9TVEFURV9WQVIgPSB2YXJpYWJsZSgnZGVmYXVsdFN0YXRlU3R5bGVzJyk7XG4gIHZhciBfQU5JTUFUSU9OX0ZBQ1RPUllfVklFV19WQVIgPSB2YXJpYWJsZSgndmlldycpO1xuICB2YXIgX0FOSU1BVElPTl9GQUNUT1JZX1ZJRVdfQ09OVEVYVCA9IF9BTklNQVRJT05fRkFDVE9SWV9WSUVXX1ZBUi5wcm9wKCdhbmltYXRpb25Db250ZXh0Jyk7XG4gIHZhciBfQU5JTUFUSU9OX0ZBQ1RPUllfUkVOREVSRVJfVkFSID0gX0FOSU1BVElPTl9GQUNUT1JZX1ZJRVdfVkFSLnByb3AoJ3JlbmRlcmVyJyk7XG4gIHZhciBfQU5JTUFUSU9OX0NVUlJFTlRfU1RBVEVfVkFSID0gdmFyaWFibGUoJ2N1cnJlbnRTdGF0ZScpO1xuICB2YXIgX0FOSU1BVElPTl9ORVhUX1NUQVRFX1ZBUiA9IHZhcmlhYmxlKCduZXh0U3RhdGUnKTtcbiAgdmFyIF9BTklNQVRJT05fUExBWUVSX1ZBUiA9IHZhcmlhYmxlKCdwbGF5ZXInKTtcbiAgdmFyIF9BTklNQVRJT05fVElNRV9WQVIgPSB2YXJpYWJsZSgndG90YWxUaW1lJyk7XG4gIHZhciBfQU5JTUFUSU9OX1NUQVJUX1NUQVRFX1NUWUxFU19WQVIgPSB2YXJpYWJsZSgnc3RhcnRTdGF0ZVN0eWxlcycpO1xuICB2YXIgX0FOSU1BVElPTl9FTkRfU1RBVEVfU1RZTEVTX1ZBUiA9IHZhcmlhYmxlKCdlbmRTdGF0ZVN0eWxlcycpO1xuICB2YXIgX0FOSU1BVElPTl9DT0xMRUNURURfU1RZTEVTID0gdmFyaWFibGUoJ2NvbGxlY3RlZFN0eWxlcycpO1xuICB2YXIgRU1QVFlfTUFQID0gbGl0ZXJhbE1hcChbXSk7XG4gIHZhciBfQW5pbWF0aW9uQnVpbGRlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBfQW5pbWF0aW9uQnVpbGRlcihhbmltYXRpb25OYW1lLCBmYWN0b3J5TmFtZSkge1xuICAgICAgICAgIHRoaXMuYW5pbWF0aW9uTmFtZSA9IGFuaW1hdGlvbk5hbWU7XG4gICAgICAgICAgdGhpcy5fZm5WYXJOYW1lID0gZmFjdG9yeU5hbWUgKyAnX2ZhY3RvcnknO1xuICAgICAgICAgIHRoaXMuX3N0YXRlc01hcFZhck5hbWUgPSBmYWN0b3J5TmFtZSArICdfc3RhdGVzJztcbiAgICAgICAgICB0aGlzLl9zdGF0ZXNNYXBWYXIgPSB2YXJpYWJsZSh0aGlzLl9zdGF0ZXNNYXBWYXJOYW1lKTtcbiAgICAgIH1cbiAgICAgIF9BbmltYXRpb25CdWlsZGVyLnByb3RvdHlwZS52aXNpdEFuaW1hdGlvblN0eWxlcyA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgICB2YXIgc3R5bGVzQXJyID0gW107XG4gICAgICAgICAgaWYgKGNvbnRleHQuaXNFeHBlY3RpbmdGaXJzdFN0eWxlU3RlcCkge1xuICAgICAgICAgICAgICBzdHlsZXNBcnIucHVzaChfQU5JTUFUSU9OX1NUQVJUX1NUQVRFX1NUWUxFU19WQVIpO1xuICAgICAgICAgICAgICBjb250ZXh0LmlzRXhwZWN0aW5nRmlyc3RTdHlsZVN0ZXAgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYXN0LnN0eWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICAgICAgICB2YXIgZW50cmllcyA9IE9iamVjdC5rZXlzKGVudHJ5KS5tYXAoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gW2tleSwgbGl0ZXJhbChlbnRyeVtrZXldKV07IH0pO1xuICAgICAgICAgICAgICBzdHlsZXNBcnIucHVzaChsaXRlcmFsTWFwKGVudHJpZXMpKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gaW1wb3J0RXhwcihyZXNvbHZlSWRlbnRpZmllcihJZGVudGlmaWVycy5BbmltYXRpb25TdHlsZXMpKS5pbnN0YW50aWF0ZShbXG4gICAgICAgICAgICAgIGltcG9ydEV4cHIocmVzb2x2ZUlkZW50aWZpZXIoSWRlbnRpZmllcnMuY29sbGVjdEFuZFJlc29sdmVTdHlsZXMpKS5jYWxsRm4oW1xuICAgICAgICAgICAgICAgICAgX0FOSU1BVElPTl9DT0xMRUNURURfU1RZTEVTLCBsaXRlcmFsQXJyKHN0eWxlc0FycilcbiAgICAgICAgICAgICAgXSlcbiAgICAgICAgICBdKTtcbiAgICAgIH07XG4gICAgICBfQW5pbWF0aW9uQnVpbGRlci5wcm90b3R5cGUudmlzaXRBbmltYXRpb25LZXlmcmFtZSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gaW1wb3J0RXhwcihyZXNvbHZlSWRlbnRpZmllcihJZGVudGlmaWVycy5BbmltYXRpb25LZXlmcmFtZSkpLmluc3RhbnRpYXRlKFtcbiAgICAgICAgICAgICAgbGl0ZXJhbChhc3Qub2Zmc2V0KSwgYXN0LnN0eWxlcy52aXNpdCh0aGlzLCBjb250ZXh0KVxuICAgICAgICAgIF0pO1xuICAgICAgfTtcbiAgICAgIF9BbmltYXRpb25CdWlsZGVyLnByb3RvdHlwZS52aXNpdEFuaW1hdGlvblN0ZXAgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICBpZiAoY29udGV4dC5lbmRTdGF0ZUFuaW1hdGVTdGVwID09PSBhc3QpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Zpc2l0RW5kU3RhdGVBbmltYXRpb24oYXN0LCBjb250ZXh0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHN0YXJ0aW5nU3R5bGVzRXhwciA9IGFzdC5zdGFydGluZ1N0eWxlcy52aXNpdCh0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgICB2YXIga2V5ZnJhbWVFeHByZXNzaW9ucyA9IGFzdC5rZXlmcmFtZXMubWFwKGZ1bmN0aW9uIChrZXlmcmFtZUVudHJ5KSB7IHJldHVybiBrZXlmcmFtZUVudHJ5LnZpc2l0KF90aGlzLCBjb250ZXh0KTsgfSk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2NhbGxBbmltYXRlTWV0aG9kKGFzdCwgc3RhcnRpbmdTdHlsZXNFeHByLCBsaXRlcmFsQXJyKGtleWZyYW1lRXhwcmVzc2lvbnMpLCBjb250ZXh0KTtcbiAgICAgIH07XG4gICAgICAvKiogQGludGVybmFsICovXG4gICAgICBfQW5pbWF0aW9uQnVpbGRlci5wcm90b3R5cGUuX3Zpc2l0RW5kU3RhdGVBbmltYXRpb24gPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICB2YXIgc3RhcnRpbmdTdHlsZXNFeHByID0gYXN0LnN0YXJ0aW5nU3R5bGVzLnZpc2l0KHRoaXMsIGNvbnRleHQpO1xuICAgICAgICAgIHZhciBrZXlmcmFtZUV4cHJlc3Npb25zID0gYXN0LmtleWZyYW1lcy5tYXAoZnVuY3Rpb24gKGtleWZyYW1lKSB7IHJldHVybiBrZXlmcmFtZS52aXNpdChfdGhpcywgY29udGV4dCk7IH0pO1xuICAgICAgICAgIHZhciBrZXlmcmFtZXNFeHByID0gaW1wb3J0RXhwcihyZXNvbHZlSWRlbnRpZmllcihJZGVudGlmaWVycy5iYWxhbmNlQW5pbWF0aW9uS2V5ZnJhbWVzKSkuY2FsbEZuKFtcbiAgICAgICAgICAgICAgX0FOSU1BVElPTl9DT0xMRUNURURfU1RZTEVTLCBfQU5JTUFUSU9OX0VORF9TVEFURV9TVFlMRVNfVkFSLFxuICAgICAgICAgICAgICBsaXRlcmFsQXJyKGtleWZyYW1lRXhwcmVzc2lvbnMpXG4gICAgICAgICAgXSk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2NhbGxBbmltYXRlTWV0aG9kKGFzdCwgc3RhcnRpbmdTdHlsZXNFeHByLCBrZXlmcmFtZXNFeHByLCBjb250ZXh0KTtcbiAgICAgIH07XG4gICAgICAvKiogQGludGVybmFsICovXG4gICAgICBfQW5pbWF0aW9uQnVpbGRlci5wcm90b3R5cGUuX2NhbGxBbmltYXRlTWV0aG9kID0gZnVuY3Rpb24gKGFzdCwgc3RhcnRpbmdTdHlsZXNFeHByLCBrZXlmcmFtZXNFeHByLCBjb250ZXh0KSB7XG4gICAgICAgICAgY29udGV4dC50b3RhbFRyYW5zaXRpb25UaW1lICs9IGFzdC5kdXJhdGlvbiArIGFzdC5kZWxheTtcbiAgICAgICAgICByZXR1cm4gX0FOSU1BVElPTl9GQUNUT1JZX1JFTkRFUkVSX1ZBUi5jYWxsTWV0aG9kKCdhbmltYXRlJywgW1xuICAgICAgICAgICAgICBfQU5JTUFUSU9OX0ZBQ1RPUllfRUxFTUVOVF9WQVIsIHN0YXJ0aW5nU3R5bGVzRXhwciwga2V5ZnJhbWVzRXhwciwgbGl0ZXJhbChhc3QuZHVyYXRpb24pLFxuICAgICAgICAgICAgICBsaXRlcmFsKGFzdC5kZWxheSksIGxpdGVyYWwoYXN0LmVhc2luZylcbiAgICAgICAgICBdKTtcbiAgICAgIH07XG4gICAgICBfQW5pbWF0aW9uQnVpbGRlci5wcm90b3R5cGUudmlzaXRBbmltYXRpb25TZXF1ZW5jZSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHZhciBwbGF5ZXJFeHBycyA9IGFzdC5zdGVwcy5tYXAoZnVuY3Rpb24gKHN0ZXApIHsgcmV0dXJuIHN0ZXAudmlzaXQoX3RoaXMsIGNvbnRleHQpOyB9KTtcbiAgICAgICAgICByZXR1cm4gaW1wb3J0RXhwcihyZXNvbHZlSWRlbnRpZmllcihJZGVudGlmaWVycy5BbmltYXRpb25TZXF1ZW5jZVBsYXllcikpLmluc3RhbnRpYXRlKFtcbiAgICAgICAgICAgICAgbGl0ZXJhbEFycihwbGF5ZXJFeHBycylcbiAgICAgICAgICBdKTtcbiAgICAgIH07XG4gICAgICBfQW5pbWF0aW9uQnVpbGRlci5wcm90b3R5cGUudmlzaXRBbmltYXRpb25Hcm91cCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHZhciBwbGF5ZXJFeHBycyA9IGFzdC5zdGVwcy5tYXAoZnVuY3Rpb24gKHN0ZXApIHsgcmV0dXJuIHN0ZXAudmlzaXQoX3RoaXMsIGNvbnRleHQpOyB9KTtcbiAgICAgICAgICByZXR1cm4gaW1wb3J0RXhwcihyZXNvbHZlSWRlbnRpZmllcihJZGVudGlmaWVycy5BbmltYXRpb25Hcm91cFBsYXllcikpLmluc3RhbnRpYXRlKFtcbiAgICAgICAgICAgICAgbGl0ZXJhbEFycihwbGF5ZXJFeHBycylcbiAgICAgICAgICBdKTtcbiAgICAgIH07XG4gICAgICBfQW5pbWF0aW9uQnVpbGRlci5wcm90b3R5cGUudmlzaXRBbmltYXRpb25TdGF0ZURlY2xhcmF0aW9uID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICAgIHZhciBmbGF0U3R5bGVzID0ge307XG4gICAgICAgICAgX2dldFN0eWxlc0FycmF5KGFzdCkuZm9yRWFjaChmdW5jdGlvbiAoZW50cnkpIHsgT2JqZWN0LmtleXMoZW50cnkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBmbGF0U3R5bGVzW2tleV0gPSBlbnRyeVtrZXldOyB9KTsgfSk7XG4gICAgICAgICAgY29udGV4dC5zdGF0ZU1hcC5yZWdpc3RlclN0YXRlKGFzdC5zdGF0ZU5hbWUsIGZsYXRTdHlsZXMpO1xuICAgICAgfTtcbiAgICAgIF9BbmltYXRpb25CdWlsZGVyLnByb3RvdHlwZS52aXNpdEFuaW1hdGlvblN0YXRlVHJhbnNpdGlvbiA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgICB2YXIgc3RlcHMgPSBhc3QuYW5pbWF0aW9uLnN0ZXBzO1xuICAgICAgICAgIHZhciBsYXN0U3RlcCA9IHN0ZXBzW3N0ZXBzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgIGlmIChfaXNFbmRTdGF0ZUFuaW1hdGVTdGVwKGxhc3RTdGVwKSkge1xuICAgICAgICAgICAgICBjb250ZXh0LmVuZFN0YXRlQW5pbWF0ZVN0ZXAgPSBsYXN0U3RlcDtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGV4dC50b3RhbFRyYW5zaXRpb25UaW1lID0gMDtcbiAgICAgICAgICBjb250ZXh0LmlzRXhwZWN0aW5nRmlyc3RTdHlsZVN0ZXAgPSB0cnVlO1xuICAgICAgICAgIHZhciBzdGF0ZUNoYW5nZVByZWNvbmRpdGlvbnMgPSBbXTtcbiAgICAgICAgICBhc3Quc3RhdGVDaGFuZ2VzLmZvckVhY2goZnVuY3Rpb24gKHN0YXRlQ2hhbmdlKSB7XG4gICAgICAgICAgICAgIHN0YXRlQ2hhbmdlUHJlY29uZGl0aW9ucy5wdXNoKF9jb21wYXJlVG9BbmltYXRpb25TdGF0ZUV4cHIoX0FOSU1BVElPTl9DVVJSRU5UX1NUQVRFX1ZBUiwgc3RhdGVDaGFuZ2UuZnJvbVN0YXRlKVxuICAgICAgICAgICAgICAgICAgLmFuZChfY29tcGFyZVRvQW5pbWF0aW9uU3RhdGVFeHByKF9BTklNQVRJT05fTkVYVF9TVEFURV9WQVIsIHN0YXRlQ2hhbmdlLnRvU3RhdGUpKSk7XG4gICAgICAgICAgICAgIGlmIChzdGF0ZUNoYW5nZS5mcm9tU3RhdGUgIT0gQU5ZX1NUQVRFKSB7XG4gICAgICAgICAgICAgICAgICBjb250ZXh0LnN0YXRlTWFwLnJlZ2lzdGVyU3RhdGUoc3RhdGVDaGFuZ2UuZnJvbVN0YXRlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoc3RhdGVDaGFuZ2UudG9TdGF0ZSAhPSBBTllfU1RBVEUpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnRleHQuc3RhdGVNYXAucmVnaXN0ZXJTdGF0ZShzdGF0ZUNoYW5nZS50b1N0YXRlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHZhciBhbmltYXRpb25QbGF5ZXJFeHByID0gYXN0LmFuaW1hdGlvbi52aXNpdCh0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgICB2YXIgcmVkdWNlZFN0YXRlQ2hhbmdlc1ByZWNvbmRpdGlvbiA9IHN0YXRlQ2hhbmdlUHJlY29uZGl0aW9ucy5yZWR1Y2UoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEub3IoYik7IH0pO1xuICAgICAgICAgIHZhciBwcmVjb25kaXRpb24gPSBfQU5JTUFUSU9OX1BMQVlFUl9WQVIuZXF1YWxzKE5VTExfRVhQUikuYW5kKHJlZHVjZWRTdGF0ZUNoYW5nZXNQcmVjb25kaXRpb24pO1xuICAgICAgICAgIHZhciBhbmltYXRpb25TdG10ID0gX0FOSU1BVElPTl9QTEFZRVJfVkFSLnNldChhbmltYXRpb25QbGF5ZXJFeHByKS50b1N0bXQoKTtcbiAgICAgICAgICB2YXIgdG90YWxUaW1lU3RtdCA9IF9BTklNQVRJT05fVElNRV9WQVIuc2V0KGxpdGVyYWwoY29udGV4dC50b3RhbFRyYW5zaXRpb25UaW1lKSkudG9TdG10KCk7XG4gICAgICAgICAgcmV0dXJuIG5ldyBJZlN0bXQocHJlY29uZGl0aW9uLCBbYW5pbWF0aW9uU3RtdCwgdG90YWxUaW1lU3RtdF0pO1xuICAgICAgfTtcbiAgICAgIF9BbmltYXRpb25CdWlsZGVyLnByb3RvdHlwZS52aXNpdEFuaW1hdGlvbkVudHJ5ID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgLy8gdmlzaXQgZWFjaCBvZiB0aGUgZGVjbGFyYXRpb25zIGZpcnN0IHRvIGJ1aWxkIHRoZSBjb250ZXh0IHN0YXRlIG1hcFxuICAgICAgICAgIGFzdC5zdGF0ZURlY2xhcmF0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChkZWYpIHsgcmV0dXJuIGRlZi52aXNpdChfdGhpcywgY29udGV4dCk7IH0pO1xuICAgICAgICAgIC8vIHRoaXMgc2hvdWxkIGFsd2F5cyBiZSBkZWZpbmVkIGV2ZW4gaWYgdGhlIHVzZXIgb3ZlcnJpZGVzIGl0XG4gICAgICAgICAgY29udGV4dC5zdGF0ZU1hcC5yZWdpc3RlclN0YXRlKERFRkFVTFRfU1RBVEUsIHt9KTtcbiAgICAgICAgICB2YXIgc3RhdGVtZW50cyA9IFtdO1xuICAgICAgICAgIHN0YXRlbWVudHMucHVzaChfQU5JTUFUSU9OX0ZBQ1RPUllfVklFV19DT05URVhUXG4gICAgICAgICAgICAgIC5jYWxsTWV0aG9kKCdjYW5jZWxBY3RpdmVBbmltYXRpb24nLCBbXG4gICAgICAgICAgICAgIF9BTklNQVRJT05fRkFDVE9SWV9FTEVNRU5UX1ZBUiwgbGl0ZXJhbCh0aGlzLmFuaW1hdGlvbk5hbWUpLFxuICAgICAgICAgICAgICBfQU5JTUFUSU9OX05FWFRfU1RBVEVfVkFSLmVxdWFscyhsaXRlcmFsKEVNUFRZX0FOSU1BVElPTl9TVEFURSkpXG4gICAgICAgICAgXSlcbiAgICAgICAgICAgICAgLnRvU3RtdCgpKTtcbiAgICAgICAgICBzdGF0ZW1lbnRzLnB1c2goX0FOSU1BVElPTl9DT0xMRUNURURfU1RZTEVTLnNldChFTVBUWV9NQVApLnRvRGVjbFN0bXQoKSk7XG4gICAgICAgICAgc3RhdGVtZW50cy5wdXNoKF9BTklNQVRJT05fUExBWUVSX1ZBUi5zZXQoTlVMTF9FWFBSKS50b0RlY2xTdG10KCkpO1xuICAgICAgICAgIHN0YXRlbWVudHMucHVzaChfQU5JTUFUSU9OX1RJTUVfVkFSLnNldChsaXRlcmFsKDApKS50b0RlY2xTdG10KCkpO1xuICAgICAgICAgIHN0YXRlbWVudHMucHVzaChfQU5JTUFUSU9OX0RFRkFVTFRfU1RBVEVfVkFSLnNldCh0aGlzLl9zdGF0ZXNNYXBWYXIua2V5KGxpdGVyYWwoREVGQVVMVF9TVEFURSkpKVxuICAgICAgICAgICAgICAudG9EZWNsU3RtdCgpKTtcbiAgICAgICAgICBzdGF0ZW1lbnRzLnB1c2goX0FOSU1BVElPTl9TVEFSVF9TVEFURV9TVFlMRVNfVkFSLnNldCh0aGlzLl9zdGF0ZXNNYXBWYXIua2V5KF9BTklNQVRJT05fQ1VSUkVOVF9TVEFURV9WQVIpKVxuICAgICAgICAgICAgICAudG9EZWNsU3RtdCgpKTtcbiAgICAgICAgICBzdGF0ZW1lbnRzLnB1c2gobmV3IElmU3RtdChfQU5JTUFUSU9OX1NUQVJUX1NUQVRFX1NUWUxFU19WQVIuZXF1YWxzKE5VTExfRVhQUiksIFtfQU5JTUFUSU9OX1NUQVJUX1NUQVRFX1NUWUxFU19WQVIuc2V0KF9BTklNQVRJT05fREVGQVVMVF9TVEFURV9WQVIpLnRvU3RtdCgpXSkpO1xuICAgICAgICAgIHN0YXRlbWVudHMucHVzaChfQU5JTUFUSU9OX0VORF9TVEFURV9TVFlMRVNfVkFSLnNldCh0aGlzLl9zdGF0ZXNNYXBWYXIua2V5KF9BTklNQVRJT05fTkVYVF9TVEFURV9WQVIpKVxuICAgICAgICAgICAgICAudG9EZWNsU3RtdCgpKTtcbiAgICAgICAgICBzdGF0ZW1lbnRzLnB1c2gobmV3IElmU3RtdChfQU5JTUFUSU9OX0VORF9TVEFURV9TVFlMRVNfVkFSLmVxdWFscyhOVUxMX0VYUFIpLCBbX0FOSU1BVElPTl9FTkRfU1RBVEVfU1RZTEVTX1ZBUi5zZXQoX0FOSU1BVElPTl9ERUZBVUxUX1NUQVRFX1ZBUikudG9TdG10KCldKSk7XG4gICAgICAgICAgdmFyIFJFTkRFUl9TVFlMRVNfRk4gPSBpbXBvcnRFeHByKHJlc29sdmVJZGVudGlmaWVyKElkZW50aWZpZXJzLnJlbmRlclN0eWxlcykpO1xuICAgICAgICAgIC8vIGJlZm9yZSB3ZSBzdGFydCBhbnkgYW5pbWF0aW9uIHdlIHdhbnQgdG8gY2xlYXIgb3V0IHRoZSBzdGFydGluZ1xuICAgICAgICAgIC8vIHN0eWxlcyBmcm9tIHRoZSBlbGVtZW50J3Mgc3R5bGUgcHJvcGVydHkgKHNpbmNlIHRoZXkgd2VyZSBwbGFjZWRcbiAgICAgICAgICAvLyB0aGVyZSBhdCB0aGUgZW5kIG9mIHRoZSBsYXN0IGFuaW1hdGlvblxuICAgICAgICAgIHN0YXRlbWVudHMucHVzaChSRU5ERVJfU1RZTEVTX0ZOXG4gICAgICAgICAgICAgIC5jYWxsRm4oW1xuICAgICAgICAgICAgICBfQU5JTUFUSU9OX0ZBQ1RPUllfRUxFTUVOVF9WQVIsIF9BTklNQVRJT05fRkFDVE9SWV9SRU5ERVJFUl9WQVIsXG4gICAgICAgICAgICAgIGltcG9ydEV4cHIocmVzb2x2ZUlkZW50aWZpZXIoSWRlbnRpZmllcnMuY2xlYXJTdHlsZXMpKVxuICAgICAgICAgICAgICAgICAgLmNhbGxGbihbX0FOSU1BVElPTl9TVEFSVF9TVEFURV9TVFlMRVNfVkFSXSlcbiAgICAgICAgICBdKVxuICAgICAgICAgICAgICAudG9TdG10KCkpO1xuICAgICAgICAgIGFzdC5zdGF0ZVRyYW5zaXRpb25zLmZvckVhY2goZnVuY3Rpb24gKHRyYW5zQXN0KSB7IHJldHVybiBzdGF0ZW1lbnRzLnB1c2godHJhbnNBc3QudmlzaXQoX3RoaXMsIGNvbnRleHQpKTsgfSk7XG4gICAgICAgICAgLy8gdGhpcyBjaGVjayBlbnN1cmVzIHRoYXQgdGhlIGFuaW1hdGlvbiBmYWN0b3J5IGFsd2F5cyByZXR1cm5zIGEgcGxheWVyXG4gICAgICAgICAgLy8gc28gdGhhdCB0aGUgb25Eb25lIGNhbGxiYWNrIGNhbiBiZSB1c2VkIGZvciB0cmFja2luZ1xuICAgICAgICAgIHN0YXRlbWVudHMucHVzaChuZXcgSWZTdG10KF9BTklNQVRJT05fUExBWUVSX1ZBUi5lcXVhbHMoTlVMTF9FWFBSKSwgW19BTklNQVRJT05fUExBWUVSX1ZBUlxuICAgICAgICAgICAgICAgICAgLnNldChpbXBvcnRFeHByKHJlc29sdmVJZGVudGlmaWVyKElkZW50aWZpZXJzLk5vT3BBbmltYXRpb25QbGF5ZXIpKS5pbnN0YW50aWF0ZShbXSkpXG4gICAgICAgICAgICAgICAgICAudG9TdG10KCldKSk7XG4gICAgICAgICAgLy8gb25jZSBjb21wbGV0ZSB3ZSB3YW50IHRvIGFwcGx5IHRoZSBzdHlsZXMgb24gdGhlIGVsZW1lbnRcbiAgICAgICAgICAvLyBzaW5jZSB0aGUgZGVzdGluYXRpb24gc3RhdGUncyB2YWx1ZXMgc2hvdWxkIHBlcnNpc3Qgb25jZVxuICAgICAgICAgIC8vIHRoZSBhbmltYXRpb24gc2VxdWVuY2UgaGFzIGNvbXBsZXRlZC5cbiAgICAgICAgICBzdGF0ZW1lbnRzLnB1c2goX0FOSU1BVElPTl9QTEFZRVJfVkFSXG4gICAgICAgICAgICAgIC5jYWxsTWV0aG9kKCdvbkRvbmUnLCBbZm4oW10sIFtSRU5ERVJfU1RZTEVTX0ZOXG4gICAgICAgICAgICAgICAgICAgICAgLmNhbGxGbihbXG4gICAgICAgICAgICAgICAgICAgICAgX0FOSU1BVElPTl9GQUNUT1JZX0VMRU1FTlRfVkFSLCBfQU5JTUFUSU9OX0ZBQ1RPUllfUkVOREVSRVJfVkFSLFxuICAgICAgICAgICAgICAgICAgICAgIGltcG9ydEV4cHIocmVzb2x2ZUlkZW50aWZpZXIoSWRlbnRpZmllcnMucHJlcGFyZUZpbmFsQW5pbWF0aW9uU3R5bGVzKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLmNhbGxGbihbXG4gICAgICAgICAgICAgICAgICAgICAgICAgIF9BTklNQVRJT05fU1RBUlRfU1RBVEVfU1RZTEVTX1ZBUiwgX0FOSU1BVElPTl9FTkRfU1RBVEVfU1RZTEVTX1ZBUlxuICAgICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgICAgICAgIC50b1N0bXQoKV0pXSlcbiAgICAgICAgICAgICAgLnRvU3RtdCgpKTtcbiAgICAgICAgICBzdGF0ZW1lbnRzLnB1c2goX0FOSU1BVElPTl9GQUNUT1JZX1ZJRVdfQ09OVEVYVFxuICAgICAgICAgICAgICAuY2FsbE1ldGhvZCgncXVldWVBbmltYXRpb24nLCBbXG4gICAgICAgICAgICAgIF9BTklNQVRJT05fRkFDVE9SWV9FTEVNRU5UX1ZBUiwgbGl0ZXJhbCh0aGlzLmFuaW1hdGlvbk5hbWUpLFxuICAgICAgICAgICAgICBfQU5JTUFUSU9OX1BMQVlFUl9WQVJcbiAgICAgICAgICBdKVxuICAgICAgICAgICAgICAudG9TdG10KCkpO1xuICAgICAgICAgIHN0YXRlbWVudHMucHVzaChuZXcgUmV0dXJuU3RhdGVtZW50KGltcG9ydEV4cHIocmVzb2x2ZUlkZW50aWZpZXIoSWRlbnRpZmllcnMuQW5pbWF0aW9uVHJhbnNpdGlvbikpLmluc3RhbnRpYXRlKFtcbiAgICAgICAgICAgICAgX0FOSU1BVElPTl9QTEFZRVJfVkFSLCBfQU5JTUFUSU9OX0NVUlJFTlRfU1RBVEVfVkFSLCBfQU5JTUFUSU9OX05FWFRfU1RBVEVfVkFSLFxuICAgICAgICAgICAgICBfQU5JTUFUSU9OX1RJTUVfVkFSXG4gICAgICAgICAgXSkpKTtcbiAgICAgICAgICByZXR1cm4gZm4oW1xuICAgICAgICAgICAgICBuZXcgRm5QYXJhbShfQU5JTUFUSU9OX0ZBQ1RPUllfVklFV19WQVIubmFtZSwgaW1wb3J0VHlwZShyZXNvbHZlSWRlbnRpZmllcihJZGVudGlmaWVycy5BcHBWaWV3KSwgW0RZTkFNSUNfVFlQRV0pKSxcbiAgICAgICAgICAgICAgbmV3IEZuUGFyYW0oX0FOSU1BVElPTl9GQUNUT1JZX0VMRU1FTlRfVkFSLm5hbWUsIERZTkFNSUNfVFlQRSksXG4gICAgICAgICAgICAgIG5ldyBGblBhcmFtKF9BTklNQVRJT05fQ1VSUkVOVF9TVEFURV9WQVIubmFtZSwgRFlOQU1JQ19UWVBFKSxcbiAgICAgICAgICAgICAgbmV3IEZuUGFyYW0oX0FOSU1BVElPTl9ORVhUX1NUQVRFX1ZBUi5uYW1lLCBEWU5BTUlDX1RZUEUpXG4gICAgICAgICAgXSwgc3RhdGVtZW50cywgaW1wb3J0VHlwZShyZXNvbHZlSWRlbnRpZmllcihJZGVudGlmaWVycy5BbmltYXRpb25UcmFuc2l0aW9uKSkpO1xuICAgICAgfTtcbiAgICAgIF9BbmltYXRpb25CdWlsZGVyLnByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uIChhc3QpIHtcbiAgICAgICAgICB2YXIgY29udGV4dCA9IG5ldyBfQW5pbWF0aW9uQnVpbGRlckNvbnRleHQoKTtcbiAgICAgICAgICB2YXIgZm5TdGF0ZW1lbnQgPSBhc3QudmlzaXQodGhpcywgY29udGV4dCkudG9EZWNsU3RtdCh0aGlzLl9mblZhck5hbWUpO1xuICAgICAgICAgIHZhciBmblZhcmlhYmxlID0gdmFyaWFibGUodGhpcy5fZm5WYXJOYW1lKTtcbiAgICAgICAgICB2YXIgbG9va3VwTWFwID0gW107XG4gICAgICAgICAgT2JqZWN0LmtleXMoY29udGV4dC5zdGF0ZU1hcC5zdGF0ZXMpLmZvckVhY2goZnVuY3Rpb24gKHN0YXRlTmFtZSkge1xuICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBjb250ZXh0LnN0YXRlTWFwLnN0YXRlc1tzdGF0ZU5hbWVdO1xuICAgICAgICAgICAgICB2YXIgdmFyaWFibGVWYWx1ZSA9IEVNUFRZX01BUDtcbiAgICAgICAgICAgICAgaWYgKGlzUHJlc2VudCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBzdHlsZU1hcF8xID0gW107XG4gICAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyh2YWx1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IHN0eWxlTWFwXzEucHVzaChba2V5LCBsaXRlcmFsKHZhbHVlW2tleV0pXSk7IH0pO1xuICAgICAgICAgICAgICAgICAgdmFyaWFibGVWYWx1ZSA9IGxpdGVyYWxNYXAoc3R5bGVNYXBfMSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbG9va3VwTWFwLnB1c2goW3N0YXRlTmFtZSwgdmFyaWFibGVWYWx1ZV0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHZhciBjb21waWxlZFN0YXRlc01hcFN0bXQgPSB0aGlzLl9zdGF0ZXNNYXBWYXIuc2V0KGxpdGVyYWxNYXAobG9va3VwTWFwKSkudG9EZWNsU3RtdCgpO1xuICAgICAgICAgIHZhciBzdGF0ZW1lbnRzID0gW2NvbXBpbGVkU3RhdGVzTWFwU3RtdCwgZm5TdGF0ZW1lbnRdO1xuICAgICAgICAgIHJldHVybiBuZXcgQW5pbWF0aW9uRW50cnlDb21waWxlUmVzdWx0KHRoaXMuYW5pbWF0aW9uTmFtZSwgc3RhdGVtZW50cywgZm5WYXJpYWJsZSk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIF9BbmltYXRpb25CdWlsZGVyO1xuICB9KCkpO1xuICB2YXIgX0FuaW1hdGlvbkJ1aWxkZXJDb250ZXh0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIF9BbmltYXRpb25CdWlsZGVyQ29udGV4dCgpIHtcbiAgICAgICAgICB0aGlzLnN0YXRlTWFwID0gbmV3IF9BbmltYXRpb25CdWlsZGVyU3RhdGVNYXAoKTtcbiAgICAgICAgICB0aGlzLmVuZFN0YXRlQW5pbWF0ZVN0ZXAgPSBudWxsO1xuICAgICAgICAgIHRoaXMuaXNFeHBlY3RpbmdGaXJzdFN0eWxlU3RlcCA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMudG90YWxUcmFuc2l0aW9uVGltZSA9IDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gX0FuaW1hdGlvbkJ1aWxkZXJDb250ZXh0O1xuICB9KCkpO1xuICB2YXIgX0FuaW1hdGlvbkJ1aWxkZXJTdGF0ZU1hcCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBfQW5pbWF0aW9uQnVpbGRlclN0YXRlTWFwKCkge1xuICAgICAgICAgIHRoaXMuX3N0YXRlcyA9IHt9O1xuICAgICAgfVxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9BbmltYXRpb25CdWlsZGVyU3RhdGVNYXAucHJvdG90eXBlLCBcInN0YXRlc1wiLCB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9zdGF0ZXM7IH0sXG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgICAgX0FuaW1hdGlvbkJ1aWxkZXJTdGF0ZU1hcC5wcm90b3R5cGUucmVnaXN0ZXJTdGF0ZSA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSB7IHZhbHVlID0gbnVsbDsgfVxuICAgICAgICAgIHZhciBleGlzdGluZ0VudHJ5ID0gdGhpcy5fc3RhdGVzW25hbWVdO1xuICAgICAgICAgIGlmICghZXhpc3RpbmdFbnRyeSkge1xuICAgICAgICAgICAgICB0aGlzLl9zdGF0ZXNbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgcmV0dXJuIF9BbmltYXRpb25CdWlsZGVyU3RhdGVNYXA7XG4gIH0oKSk7XG4gIGZ1bmN0aW9uIF9jb21wYXJlVG9BbmltYXRpb25TdGF0ZUV4cHIodmFsdWUsIGFuaW1hdGlvblN0YXRlKSB7XG4gICAgICB2YXIgZW1wdHlTdGF0ZUxpdGVyYWwgPSBsaXRlcmFsKEVNUFRZX0FOSU1BVElPTl9TVEFURSk7XG4gICAgICBzd2l0Y2ggKGFuaW1hdGlvblN0YXRlKSB7XG4gICAgICAgICAgY2FzZSBFTVBUWV9BTklNQVRJT05fU1RBVEU6XG4gICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5lcXVhbHMoZW1wdHlTdGF0ZUxpdGVyYWwpO1xuICAgICAgICAgIGNhc2UgQU5ZX1NUQVRFOlxuICAgICAgICAgICAgICByZXR1cm4gbGl0ZXJhbCh0cnVlKTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICByZXR1cm4gdmFsdWUuZXF1YWxzKGxpdGVyYWwoYW5pbWF0aW9uU3RhdGUpKTtcbiAgICAgIH1cbiAgfVxuICBmdW5jdGlvbiBfaXNFbmRTdGF0ZUFuaW1hdGVTdGVwKHN0ZXApIHtcbiAgICAgIC8vIHRoZSBmaW5hbCBhbmltYXRpb24gc3RlcCBpcyBjaGFyYWN0ZXJpemVkIGJ5IGhhdmluZyBvbmx5IFRXT1xuICAgICAgLy8ga2V5ZnJhbWUgdmFsdWVzIGFuZCBpdCBtdXN0IGhhdmUgemVybyBzdHlsZXMgZm9yIGJvdGgga2V5ZnJhbWVzXG4gICAgICBpZiAoc3RlcCBpbnN0YW5jZW9mIEFuaW1hdGlvblN0ZXBBc3QgJiYgc3RlcC5kdXJhdGlvbiA+IDAgJiYgc3RlcC5rZXlmcmFtZXMubGVuZ3RoID09IDIpIHtcbiAgICAgICAgICB2YXIgc3R5bGVzMSA9IF9nZXRTdHlsZXNBcnJheShzdGVwLmtleWZyYW1lc1swXSlbMF07XG4gICAgICAgICAgdmFyIHN0eWxlczIgPSBfZ2V0U3R5bGVzQXJyYXkoc3RlcC5rZXlmcmFtZXNbMV0pWzBdO1xuICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhzdHlsZXMxKS5sZW5ndGggPT09IDAgJiYgT2JqZWN0LmtleXMoc3R5bGVzMikubGVuZ3RoID09PSAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZ1bmN0aW9uIF9nZXRTdHlsZXNBcnJheShvYmopIHtcbiAgICAgIHJldHVybiBvYmouc3R5bGVzLnN0eWxlcztcbiAgfVxuXG4gIHZhciBTdHlsZXNDb2xsZWN0aW9uRW50cnkgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gU3R5bGVzQ29sbGVjdGlvbkVudHJ5KHRpbWUsIHZhbHVlKSB7XG4gICAgICAgICAgdGhpcy50aW1lID0gdGltZTtcbiAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICB9XG4gICAgICBTdHlsZXNDb2xsZWN0aW9uRW50cnkucHJvdG90eXBlLm1hdGNoZXMgPSBmdW5jdGlvbiAodGltZSwgdmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gdGltZSA9PSB0aGlzLnRpbWUgJiYgdmFsdWUgPT0gdGhpcy52YWx1ZTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gU3R5bGVzQ29sbGVjdGlvbkVudHJ5O1xuICB9KCkpO1xuICB2YXIgU3R5bGVzQ29sbGVjdGlvbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBTdHlsZXNDb2xsZWN0aW9uKCkge1xuICAgICAgICAgIHRoaXMuc3R5bGVzID0ge307XG4gICAgICB9XG4gICAgICBTdHlsZXNDb2xsZWN0aW9uLnByb3RvdHlwZS5pbnNlcnRBdFRpbWUgPSBmdW5jdGlvbiAocHJvcGVydHksIHRpbWUsIHZhbHVlKSB7XG4gICAgICAgICAgdmFyIHR1cGxlID0gbmV3IFN0eWxlc0NvbGxlY3Rpb25FbnRyeSh0aW1lLCB2YWx1ZSk7XG4gICAgICAgICAgdmFyIGVudHJpZXMgPSB0aGlzLnN0eWxlc1twcm9wZXJ0eV07XG4gICAgICAgICAgaWYgKCFpc1ByZXNlbnQoZW50cmllcykpIHtcbiAgICAgICAgICAgICAgZW50cmllcyA9IHRoaXMuc3R5bGVzW3Byb3BlcnR5XSA9IFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBpbnNlcnQgdGhpcyBhdCB0aGUgcmlnaHQgc3RvcCBpbiB0aGUgYXJyYXlcbiAgICAgICAgICAvLyB0aGlzIHdheSB3ZSBjYW4ga2VlcCBpdCBzb3J0ZWRcbiAgICAgICAgICB2YXIgaW5zZXJ0aW9uSW5kZXggPSAwO1xuICAgICAgICAgIGZvciAodmFyIGkgPSBlbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgIGlmIChlbnRyaWVzW2ldLnRpbWUgPD0gdGltZSkge1xuICAgICAgICAgICAgICAgICAgaW5zZXJ0aW9uSW5kZXggPSBpICsgMTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGVudHJpZXMuc3BsaWNlKGluc2VydGlvbkluZGV4LCAwLCB0dXBsZSk7XG4gICAgICB9O1xuICAgICAgU3R5bGVzQ29sbGVjdGlvbi5wcm90b3R5cGUuZ2V0QnlJbmRleCA9IGZ1bmN0aW9uIChwcm9wZXJ0eSwgaW5kZXgpIHtcbiAgICAgICAgICB2YXIgaXRlbXMgPSB0aGlzLnN0eWxlc1twcm9wZXJ0eV07XG4gICAgICAgICAgaWYgKGlzUHJlc2VudChpdGVtcykpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGluZGV4ID49IGl0ZW1zLmxlbmd0aCA/IG51bGwgOiBpdGVtc1tpbmRleF07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcbiAgICAgIFN0eWxlc0NvbGxlY3Rpb24ucHJvdG90eXBlLmluZGV4T2ZBdE9yQmVmb3JlVGltZSA9IGZ1bmN0aW9uIChwcm9wZXJ0eSwgdGltZSkge1xuICAgICAgICAgIHZhciBlbnRyaWVzID0gdGhpcy5zdHlsZXNbcHJvcGVydHldO1xuICAgICAgICAgIGlmIChpc1ByZXNlbnQoZW50cmllcykpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IGVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgIGlmIChlbnRyaWVzW2ldLnRpbWUgPD0gdGltZSlcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICByZXR1cm4gU3R5bGVzQ29sbGVjdGlvbjtcbiAgfSgpKTtcblxuICAvKipcbiAgICogQGxpY2Vuc2VcbiAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAqXG4gICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICovXG4gIHZhciBfX2V4dGVuZHMkMTQgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gIH07XG4gIHZhciBfSU5JVElBTF9LRVlGUkFNRSA9IDA7XG4gIHZhciBfVEVSTUlOQUxfS0VZRlJBTUUgPSAxO1xuICB2YXIgX09ORV9TRUNPTkQgPSAxMDAwO1xuICB2YXIgQW5pbWF0aW9uUGFyc2VFcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkMTQoQW5pbWF0aW9uUGFyc2VFcnJvciwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIEFuaW1hdGlvblBhcnNlRXJyb3IobWVzc2FnZSkge1xuICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIG51bGwsIG1lc3NhZ2UpO1xuICAgICAgfVxuICAgICAgQW5pbWF0aW9uUGFyc2VFcnJvci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBcIlwiICsgdGhpcy5tc2c7IH07XG4gICAgICByZXR1cm4gQW5pbWF0aW9uUGFyc2VFcnJvcjtcbiAgfShQYXJzZUVycm9yKSk7XG4gIHZhciBBbmltYXRpb25FbnRyeVBhcnNlUmVzdWx0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIEFuaW1hdGlvbkVudHJ5UGFyc2VSZXN1bHQoYXN0LCBlcnJvcnMpIHtcbiAgICAgICAgICB0aGlzLmFzdCA9IGFzdDtcbiAgICAgICAgICB0aGlzLmVycm9ycyA9IGVycm9ycztcbiAgICAgIH1cbiAgICAgIHJldHVybiBBbmltYXRpb25FbnRyeVBhcnNlUmVzdWx0O1xuICB9KCkpO1xuICB2YXIgQW5pbWF0aW9uUGFyc2VyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIEFuaW1hdGlvblBhcnNlcigpIHtcbiAgICAgIH1cbiAgICAgIEFuaW1hdGlvblBhcnNlci5wcm90b3R5cGUucGFyc2VDb21wb25lbnQgPSBmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICB2YXIgZXJyb3JzID0gW107XG4gICAgICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBjb21wb25lbnQudHlwZS5uYW1lO1xuICAgICAgICAgIHZhciBhbmltYXRpb25UcmlnZ2VyTmFtZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgdmFyIGFzdHMgPSBjb21wb25lbnQudGVtcGxhdGUuYW5pbWF0aW9ucy5tYXAoZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgICAgICAgIHZhciByZXN1bHQgPSBfdGhpcy5wYXJzZUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICAgICAgdmFyIGFzdCA9IHJlc3VsdC5hc3Q7XG4gICAgICAgICAgICAgIHZhciB0cmlnZ2VyTmFtZSA9IGFzdC5uYW1lO1xuICAgICAgICAgICAgICBpZiAoYW5pbWF0aW9uVHJpZ2dlck5hbWVzLmhhcyh0cmlnZ2VyTmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdC5lcnJvcnMucHVzaChuZXcgQW5pbWF0aW9uUGFyc2VFcnJvcihcIlRoZSBhbmltYXRpb24gdHJpZ2dlciBcXFwiXCIgKyB0cmlnZ2VyTmFtZSArIFwiXFxcIiBoYXMgYWxyZWFkeSBiZWVuIHJlZ2lzdGVyZWQgZm9yIHRoZSBcIiArIGNvbXBvbmVudE5hbWUgKyBcIiBjb21wb25lbnRcIikpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uVHJpZ2dlck5hbWVzLmFkZCh0cmlnZ2VyTmFtZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHJlc3VsdC5lcnJvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgdmFyIGVycm9yTWVzc2FnZV8xID0gXCItIFVuYWJsZSB0byBwYXJzZSB0aGUgYW5pbWF0aW9uIHNlcXVlbmNlIGZvciBcXFwiXCIgKyB0cmlnZ2VyTmFtZSArIFwiXFxcIiBvbiB0aGUgXCIgKyBjb21wb25lbnROYW1lICsgXCIgY29tcG9uZW50IGR1ZSB0byB0aGUgZm9sbG93aW5nIGVycm9yczpcIjtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdC5lcnJvcnMuZm9yRWFjaChmdW5jdGlvbiAoZXJyb3IpIHsgZXJyb3JNZXNzYWdlXzEgKz0gJ1xcbi0tICcgKyBlcnJvci5tc2c7IH0pO1xuICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goZXJyb3JNZXNzYWdlXzEpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBhc3Q7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKGVycm9ycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIHZhciBlcnJvclN0cmluZyA9IGVycm9ycy5qb2luKCdcXG4nKTtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQW5pbWF0aW9uIHBhcnNlIGVycm9yczpcXG5cIiArIGVycm9yU3RyaW5nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGFzdHM7XG4gICAgICB9O1xuICAgICAgQW5pbWF0aW9uUGFyc2VyLnByb3RvdHlwZS5wYXJzZUVudHJ5ID0gZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgICAgdmFyIGVycm9ycyA9IFtdO1xuICAgICAgICAgIHZhciBzdGF0ZVN0eWxlcyA9IHt9O1xuICAgICAgICAgIHZhciB0cmFuc2l0aW9ucyA9IFtdO1xuICAgICAgICAgIHZhciBzdGF0ZURlY2xhcmF0aW9uQXN0cyA9IFtdO1xuICAgICAgICAgIGVudHJ5LmRlZmluaXRpb25zLmZvckVhY2goZnVuY3Rpb24gKGRlZikge1xuICAgICAgICAgICAgICBpZiAoZGVmIGluc3RhbmNlb2YgQ29tcGlsZUFuaW1hdGlvblN0YXRlRGVjbGFyYXRpb25NZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgICAgX3BhcnNlQW5pbWF0aW9uRGVjbGFyYXRpb25TdGF0ZXMoZGVmLCBlcnJvcnMpLmZvckVhY2goZnVuY3Rpb24gKGFzdCkge1xuICAgICAgICAgICAgICAgICAgICAgIHN0YXRlRGVjbGFyYXRpb25Bc3RzLnB1c2goYXN0KTtcbiAgICAgICAgICAgICAgICAgICAgICBzdGF0ZVN0eWxlc1thc3Quc3RhdGVOYW1lXSA9IGFzdC5zdHlsZXM7XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb25zLnB1c2goZGVmKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHZhciBzdGF0ZVRyYW5zaXRpb25Bc3RzID0gdHJhbnNpdGlvbnMubWFwKGZ1bmN0aW9uICh0cmFuc0RlZikgeyByZXR1cm4gX3BhcnNlQW5pbWF0aW9uU3RhdGVUcmFuc2l0aW9uKHRyYW5zRGVmLCBzdGF0ZVN0eWxlcywgZXJyb3JzKTsgfSk7XG4gICAgICAgICAgdmFyIGFzdCA9IG5ldyBBbmltYXRpb25FbnRyeUFzdChlbnRyeS5uYW1lLCBzdGF0ZURlY2xhcmF0aW9uQXN0cywgc3RhdGVUcmFuc2l0aW9uQXN0cyk7XG4gICAgICAgICAgcmV0dXJuIG5ldyBBbmltYXRpb25FbnRyeVBhcnNlUmVzdWx0KGFzdCwgZXJyb3JzKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gQW5pbWF0aW9uUGFyc2VyO1xuICB9KCkpO1xuICBmdW5jdGlvbiBfcGFyc2VBbmltYXRpb25EZWNsYXJhdGlvblN0YXRlcyhzdGF0ZU1ldGFkYXRhLCBlcnJvcnMpIHtcbiAgICAgIHZhciBzdHlsZVZhbHVlcyA9IFtdO1xuICAgICAgc3RhdGVNZXRhZGF0YS5zdHlsZXMuc3R5bGVzLmZvckVhY2goZnVuY3Rpb24gKHN0eWxlc0VudHJ5KSB7XG4gICAgICAgICAgLy8gVE9ETyAobWF0c2tvKTogY2hhbmdlIHRoaXMgd2hlbiB3ZSBnZXQgQ1NTIGNsYXNzIGludGVncmF0aW9uIHN1cHBvcnRcbiAgICAgICAgICBpZiAodHlwZW9mIHN0eWxlc0VudHJ5ID09PSAnb2JqZWN0JyAmJiBzdHlsZXNFbnRyeSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICBzdHlsZVZhbHVlcy5wdXNoKHN0eWxlc0VudHJ5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBBbmltYXRpb25QYXJzZUVycm9yKFwiU3RhdGUgYmFzZWQgYW5pbWF0aW9ucyBjYW5ub3QgY29udGFpbiByZWZlcmVuY2VzIHRvIG90aGVyIHN0YXRlc1wiKSk7XG4gICAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB2YXIgZGVmU3R5bGVzID0gbmV3IEFuaW1hdGlvblN0eWxlc0FzdChzdHlsZVZhbHVlcyk7XG4gICAgICB2YXIgc3RhdGVzID0gc3RhdGVNZXRhZGF0YS5zdGF0ZU5hbWVFeHByLnNwbGl0KC9cXHMqLFxccyovKTtcbiAgICAgIHJldHVybiBzdGF0ZXMubWFwKGZ1bmN0aW9uIChzdGF0ZSkgeyByZXR1cm4gbmV3IEFuaW1hdGlvblN0YXRlRGVjbGFyYXRpb25Bc3Qoc3RhdGUsIGRlZlN0eWxlcyk7IH0pO1xuICB9XG4gIGZ1bmN0aW9uIF9wYXJzZUFuaW1hdGlvblN0YXRlVHJhbnNpdGlvbih0cmFuc2l0aW9uU3RhdGVNZXRhZGF0YSwgc3RhdGVTdHlsZXMsIGVycm9ycykge1xuICAgICAgdmFyIHN0eWxlcyA9IG5ldyBTdHlsZXNDb2xsZWN0aW9uKCk7XG4gICAgICB2YXIgdHJhbnNpdGlvbkV4cHJzID0gW107XG4gICAgICB2YXIgdHJhbnNpdGlvblN0YXRlcyA9IHRyYW5zaXRpb25TdGF0ZU1ldGFkYXRhLnN0YXRlQ2hhbmdlRXhwci5zcGxpdCgvXFxzKixcXHMqLyk7XG4gICAgICB0cmFuc2l0aW9uU3RhdGVzLmZvckVhY2goZnVuY3Rpb24gKGV4cHIpIHsgdHJhbnNpdGlvbkV4cHJzLnB1c2guYXBwbHkodHJhbnNpdGlvbkV4cHJzLCBfcGFyc2VBbmltYXRpb25UcmFuc2l0aW9uRXhwcihleHByLCBlcnJvcnMpKTsgfSk7XG4gICAgICB2YXIgZW50cnkgPSBfbm9ybWFsaXplQW5pbWF0aW9uRW50cnkodHJhbnNpdGlvblN0YXRlTWV0YWRhdGEuc3RlcHMpO1xuICAgICAgdmFyIGFuaW1hdGlvbiA9IF9ub3JtYWxpemVTdHlsZVN0ZXBzKGVudHJ5LCBzdGF0ZVN0eWxlcywgZXJyb3JzKTtcbiAgICAgIHZhciBhbmltYXRpb25Bc3QgPSBfcGFyc2VUcmFuc2l0aW9uQW5pbWF0aW9uKGFuaW1hdGlvbiwgMCwgc3R5bGVzLCBzdGF0ZVN0eWxlcywgZXJyb3JzKTtcbiAgICAgIGlmIChlcnJvcnMubGVuZ3RoID09IDApIHtcbiAgICAgICAgICBfZmlsbEFuaW1hdGlvbkFzdFN0YXJ0aW5nS2V5ZnJhbWVzKGFuaW1hdGlvbkFzdCwgc3R5bGVzLCBlcnJvcnMpO1xuICAgICAgfVxuICAgICAgdmFyIHN0ZXBzQXN0ID0gKGFuaW1hdGlvbkFzdCBpbnN0YW5jZW9mIEFuaW1hdGlvbldpdGhTdGVwc0FzdCkgP1xuICAgICAgICAgIGFuaW1hdGlvbkFzdCA6XG4gICAgICAgICAgbmV3IEFuaW1hdGlvblNlcXVlbmNlQXN0KFthbmltYXRpb25Bc3RdKTtcbiAgICAgIHJldHVybiBuZXcgQW5pbWF0aW9uU3RhdGVUcmFuc2l0aW9uQXN0KHRyYW5zaXRpb25FeHBycywgc3RlcHNBc3QpO1xuICB9XG4gIGZ1bmN0aW9uIF9wYXJzZUFuaW1hdGlvbkFsaWFzKGFsaWFzLCBlcnJvcnMpIHtcbiAgICAgIHN3aXRjaCAoYWxpYXMpIHtcbiAgICAgICAgICBjYXNlICc6ZW50ZXInOlxuICAgICAgICAgICAgICByZXR1cm4gJ3ZvaWQgPT4gKic7XG4gICAgICAgICAgY2FzZSAnOmxlYXZlJzpcbiAgICAgICAgICAgICAgcmV0dXJuICcqID0+IHZvaWQnO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBBbmltYXRpb25QYXJzZUVycm9yKFwidGhlIHRyYW5zaXRpb24gYWxpYXMgdmFsdWUgXFxcIlwiICsgYWxpYXMgKyBcIlxcXCIgaXMgbm90IHN1cHBvcnRlZFwiKSk7XG4gICAgICAgICAgICAgIHJldHVybiAnKiA9PiAqJztcbiAgICAgIH1cbiAgfVxuICBmdW5jdGlvbiBfcGFyc2VBbmltYXRpb25UcmFuc2l0aW9uRXhwcihldmVudFN0ciwgZXJyb3JzKSB7XG4gICAgICB2YXIgZXhwcmVzc2lvbnMgPSBbXTtcbiAgICAgIGlmIChldmVudFN0clswXSA9PSAnOicpIHtcbiAgICAgICAgICBldmVudFN0ciA9IF9wYXJzZUFuaW1hdGlvbkFsaWFzKGV2ZW50U3RyLCBlcnJvcnMpO1xuICAgICAgfVxuICAgICAgdmFyIG1hdGNoID0gZXZlbnRTdHIubWF0Y2goL14oXFwqfFstXFx3XSspXFxzKig8P1s9LV0+KVxccyooXFwqfFstXFx3XSspJC8pO1xuICAgICAgaWYgKCFpc1ByZXNlbnQobWF0Y2gpIHx8IG1hdGNoLmxlbmd0aCA8IDQpIHtcbiAgICAgICAgICBlcnJvcnMucHVzaChuZXcgQW5pbWF0aW9uUGFyc2VFcnJvcihcInRoZSBwcm92aWRlZCBcIiArIGV2ZW50U3RyICsgXCIgaXMgbm90IG9mIGEgc3VwcG9ydGVkIGZvcm1hdFwiKSk7XG4gICAgICAgICAgcmV0dXJuIGV4cHJlc3Npb25zO1xuICAgICAgfVxuICAgICAgdmFyIGZyb21TdGF0ZSA9IG1hdGNoWzFdO1xuICAgICAgdmFyIHNlcGFyYXRvciA9IG1hdGNoWzJdO1xuICAgICAgdmFyIHRvU3RhdGUgPSBtYXRjaFszXTtcbiAgICAgIGV4cHJlc3Npb25zLnB1c2gobmV3IEFuaW1hdGlvblN0YXRlVHJhbnNpdGlvbkV4cHJlc3Npb24oZnJvbVN0YXRlLCB0b1N0YXRlKSk7XG4gICAgICB2YXIgaXNGdWxsQW55U3RhdGVFeHByID0gZnJvbVN0YXRlID09IEFOWV9TVEFURSAmJiB0b1N0YXRlID09IEFOWV9TVEFURTtcbiAgICAgIGlmIChzZXBhcmF0b3JbMF0gPT0gJzwnICYmICFpc0Z1bGxBbnlTdGF0ZUV4cHIpIHtcbiAgICAgICAgICBleHByZXNzaW9ucy5wdXNoKG5ldyBBbmltYXRpb25TdGF0ZVRyYW5zaXRpb25FeHByZXNzaW9uKHRvU3RhdGUsIGZyb21TdGF0ZSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGV4cHJlc3Npb25zO1xuICB9XG4gIGZ1bmN0aW9uIF9ub3JtYWxpemVBbmltYXRpb25FbnRyeShlbnRyeSkge1xuICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoZW50cnkpID8gbmV3IENvbXBpbGVBbmltYXRpb25TZXF1ZW5jZU1ldGFkYXRhKGVudHJ5KSA6IGVudHJ5O1xuICB9XG4gIGZ1bmN0aW9uIF9ub3JtYWxpemVTdHlsZU1ldGFkYXRhKGVudHJ5LCBzdGF0ZVN0eWxlcywgZXJyb3JzKSB7XG4gICAgICB2YXIgbm9ybWFsaXplZFN0eWxlcyA9IFtdO1xuICAgICAgZW50cnkuc3R5bGVzLmZvckVhY2goZnVuY3Rpb24gKHN0eWxlRW50cnkpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHN0eWxlRW50cnkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIG5vcm1hbGl6ZWRTdHlsZXMucHVzaC5hcHBseShub3JtYWxpemVkU3R5bGVzLCBfcmVzb2x2ZVN0eWxlc0Zyb21TdGF0ZShzdHlsZUVudHJ5LCBzdGF0ZVN0eWxlcywgZXJyb3JzKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBub3JtYWxpemVkU3R5bGVzLnB1c2goc3R5bGVFbnRyeSk7XG4gICAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gbm9ybWFsaXplZFN0eWxlcztcbiAgfVxuICBmdW5jdGlvbiBfbm9ybWFsaXplU3R5bGVTdGVwcyhlbnRyeSwgc3RhdGVTdHlsZXMsIGVycm9ycykge1xuICAgICAgdmFyIHN0ZXBzID0gX25vcm1hbGl6ZVN0eWxlU3RlcEVudHJ5KGVudHJ5LCBzdGF0ZVN0eWxlcywgZXJyb3JzKTtcbiAgICAgIHJldHVybiAoZW50cnkgaW5zdGFuY2VvZiBDb21waWxlQW5pbWF0aW9uR3JvdXBNZXRhZGF0YSkgP1xuICAgICAgICAgIG5ldyBDb21waWxlQW5pbWF0aW9uR3JvdXBNZXRhZGF0YShzdGVwcykgOlxuICAgICAgICAgIG5ldyBDb21waWxlQW5pbWF0aW9uU2VxdWVuY2VNZXRhZGF0YShzdGVwcyk7XG4gIH1cbiAgZnVuY3Rpb24gX21lcmdlQW5pbWF0aW9uU3R5bGVzKHN0eWxlc0xpc3QsIG5ld0l0ZW0pIHtcbiAgICAgIGlmICh0eXBlb2YgbmV3SXRlbSA9PT0gJ29iamVjdCcgJiYgbmV3SXRlbSAhPT0gbnVsbCAmJiBzdHlsZXNMaXN0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB2YXIgbGFzdEluZGV4ID0gc3R5bGVzTGlzdC5sZW5ndGggLSAxO1xuICAgICAgICAgIHZhciBsYXN0SXRlbSA9IHN0eWxlc0xpc3RbbGFzdEluZGV4XTtcbiAgICAgICAgICBpZiAodHlwZW9mIGxhc3RJdGVtID09PSAnb2JqZWN0JyAmJiBsYXN0SXRlbSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICBzdHlsZXNMaXN0W2xhc3RJbmRleF0gPSBTdHJpbmdNYXBXcmFwcGVyLm1lcmdlKGxhc3RJdGVtLCBuZXdJdGVtKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHN0eWxlc0xpc3QucHVzaChuZXdJdGVtKTtcbiAgfVxuICBmdW5jdGlvbiBfbm9ybWFsaXplU3R5bGVTdGVwRW50cnkoZW50cnksIHN0YXRlU3R5bGVzLCBlcnJvcnMpIHtcbiAgICAgIHZhciBzdGVwcztcbiAgICAgIGlmIChlbnRyeSBpbnN0YW5jZW9mIENvbXBpbGVBbmltYXRpb25XaXRoU3RlcHNNZXRhZGF0YSkge1xuICAgICAgICAgIHN0ZXBzID0gZW50cnkuc3RlcHM7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gW2VudHJ5XTtcbiAgICAgIH1cbiAgICAgIHZhciBuZXdTdGVwcyA9IFtdO1xuICAgICAgdmFyIGNvbWJpbmVkU3R5bGVzO1xuICAgICAgc3RlcHMuZm9yRWFjaChmdW5jdGlvbiAoc3RlcCkge1xuICAgICAgICAgIGlmIChzdGVwIGluc3RhbmNlb2YgQ29tcGlsZUFuaW1hdGlvblN0eWxlTWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgLy8gdGhpcyBvY2N1cnMgd2hlbiBhIHN0eWxlIHN0ZXAgaXMgZm9sbG93ZWQgYnkgYSBwcmV2aW91cyBzdHlsZSBzdGVwXG4gICAgICAgICAgICAgIC8vIG9yIHdoZW4gdGhlIGZpcnN0IHN0eWxlIHN0ZXAgaXMgcnVuLiBXZSB3YW50IHRvIGNvbmNhdGVuYXRlIGFsbCBzdWJzZXF1ZW50XG4gICAgICAgICAgICAgIC8vIHN0eWxlIHN0ZXBzIHRvZ2V0aGVyIGludG8gYSBzaW5nbGUgc3R5bGUgc3RlcCBzdWNoIHRoYXQgd2UgaGF2ZSB0aGUgY29ycmVjdFxuICAgICAgICAgICAgICAvLyBzdGFydGluZyBrZXlmcmFtZSBkYXRhIHRvIHBhc3MgaW50byB0aGUgYW5pbWF0aW9uIHBsYXllci5cbiAgICAgICAgICAgICAgaWYgKCFpc1ByZXNlbnQoY29tYmluZWRTdHlsZXMpKSB7XG4gICAgICAgICAgICAgICAgICBjb21iaW5lZFN0eWxlcyA9IFtdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIF9ub3JtYWxpemVTdHlsZU1ldGFkYXRhKHN0ZXAsIHN0YXRlU3R5bGVzLCBlcnJvcnMpXG4gICAgICAgICAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbiAoZW50cnkpIHsgX21lcmdlQW5pbWF0aW9uU3R5bGVzKGNvbWJpbmVkU3R5bGVzLCBlbnRyeSk7IH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gaXQgaXMgaW1wb3J0YW50IHRoYXQgd2UgY3JlYXRlIGEgbWV0YWRhdGEgZW50cnkgb2YgdGhlIGNvbWJpbmVkIHN0eWxlc1xuICAgICAgICAgICAgICAvLyBiZWZvcmUgd2UgZ28gb24gYW4gcHJvY2VzcyB0aGUgYW5pbWF0ZSwgc2VxdWVuY2Ugb3IgZ3JvdXAgbWV0YWRhdGEgc3RlcHMuXG4gICAgICAgICAgICAgIC8vIFRoaXMgd2lsbCBlbnN1cmUgdGhhdCB0aGUgQVNUIHdpbGwgaGF2ZSB0aGUgcHJldmlvdXMgc3R5bGVzIHBhaW50ZWQgb25cbiAgICAgICAgICAgICAgLy8gc2NyZWVuIGJlZm9yZSBhbnkgZnVydGhlciBhbmltYXRpb25zIHRoYXQgdXNlIHRoZSBzdHlsZXMgdGFrZSBwbGFjZS5cbiAgICAgICAgICAgICAgaWYgKGlzUHJlc2VudChjb21iaW5lZFN0eWxlcykpIHtcbiAgICAgICAgICAgICAgICAgIG5ld1N0ZXBzLnB1c2gobmV3IENvbXBpbGVBbmltYXRpb25TdHlsZU1ldGFkYXRhKDAsIGNvbWJpbmVkU3R5bGVzKSk7XG4gICAgICAgICAgICAgICAgICBjb21iaW5lZFN0eWxlcyA9IG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHN0ZXAgaW5zdGFuY2VvZiBDb21waWxlQW5pbWF0aW9uQW5pbWF0ZU1ldGFkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAvLyB3ZSBkbyBub3QgcmVjdXJzZSBpbnRvIENvbXBpbGVBbmltYXRpb25BbmltYXRlTWV0YWRhdGEgc2luY2VcbiAgICAgICAgICAgICAgICAgIC8vIHRob3NlIHN0eWxlIHN0ZXBzIGFyZSBub3QgZ29pbmcgdG8gYmUgc3F1YXNoZWRcbiAgICAgICAgICAgICAgICAgIHZhciBhbmltYXRlU3R5bGVWYWx1ZSA9IHN0ZXAuc3R5bGVzO1xuICAgICAgICAgICAgICAgICAgaWYgKGFuaW1hdGVTdHlsZVZhbHVlIGluc3RhbmNlb2YgQ29tcGlsZUFuaW1hdGlvblN0eWxlTWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICBhbmltYXRlU3R5bGVWYWx1ZS5zdHlsZXMgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICBfbm9ybWFsaXplU3R5bGVNZXRhZGF0YShhbmltYXRlU3R5bGVWYWx1ZSwgc3RhdGVTdHlsZXMsIGVycm9ycyk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBlbHNlIGlmIChhbmltYXRlU3R5bGVWYWx1ZSBpbnN0YW5jZW9mIENvbXBpbGVBbmltYXRpb25LZXlmcmFtZXNTZXF1ZW5jZU1ldGFkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgYW5pbWF0ZVN0eWxlVmFsdWUuc3RlcHMuZm9yRWFjaChmdW5jdGlvbiAoc3RlcCkgeyBzdGVwLnN0eWxlcyA9IF9ub3JtYWxpemVTdHlsZU1ldGFkYXRhKHN0ZXAsIHN0YXRlU3R5bGVzLCBlcnJvcnMpOyB9KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIGlmIChzdGVwIGluc3RhbmNlb2YgQ29tcGlsZUFuaW1hdGlvbldpdGhTdGVwc01ldGFkYXRhKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgaW5uZXJTdGVwcyA9IF9ub3JtYWxpemVTdHlsZVN0ZXBFbnRyeShzdGVwLCBzdGF0ZVN0eWxlcywgZXJyb3JzKTtcbiAgICAgICAgICAgICAgICAgIHN0ZXAgPSBzdGVwIGluc3RhbmNlb2YgQ29tcGlsZUFuaW1hdGlvbkdyb3VwTWV0YWRhdGEgP1xuICAgICAgICAgICAgICAgICAgICAgIG5ldyBDb21waWxlQW5pbWF0aW9uR3JvdXBNZXRhZGF0YShpbm5lclN0ZXBzKSA6XG4gICAgICAgICAgICAgICAgICAgICAgbmV3IENvbXBpbGVBbmltYXRpb25TZXF1ZW5jZU1ldGFkYXRhKGlubmVyU3RlcHMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG5ld1N0ZXBzLnB1c2goc3RlcCk7XG4gICAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICAvLyB0aGlzIGhhcHBlbnMgd2hlbiBvbmx5IHN0eWxlcyB3ZXJlIGFuaW1hdGVkIHdpdGhpbiB0aGUgc2VxdWVuY2VcbiAgICAgIGlmIChpc1ByZXNlbnQoY29tYmluZWRTdHlsZXMpKSB7XG4gICAgICAgICAgbmV3U3RlcHMucHVzaChuZXcgQ29tcGlsZUFuaW1hdGlvblN0eWxlTWV0YWRhdGEoMCwgY29tYmluZWRTdHlsZXMpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXdTdGVwcztcbiAgfVxuICBmdW5jdGlvbiBfcmVzb2x2ZVN0eWxlc0Zyb21TdGF0ZShzdGF0ZU5hbWUsIHN0YXRlU3R5bGVzLCBlcnJvcnMpIHtcbiAgICAgIHZhciBzdHlsZXMgPSBbXTtcbiAgICAgIGlmIChzdGF0ZU5hbWVbMF0gIT0gJzonKSB7XG4gICAgICAgICAgZXJyb3JzLnB1c2gobmV3IEFuaW1hdGlvblBhcnNlRXJyb3IoXCJBbmltYXRpb24gc3RhdGVzIHZpYSBzdHlsZXMgbXVzdCBiZSBwcmVmaXhlZCB3aXRoIGEgXFxcIjpcXFwiXCIpKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAgIHZhciBub3JtYWxpemVkU3RhdGVOYW1lID0gc3RhdGVOYW1lLnN1YnN0cmluZygxKTtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBzdGF0ZVN0eWxlc1tub3JtYWxpemVkU3RhdGVOYW1lXTtcbiAgICAgICAgICBpZiAoIWlzUHJlc2VudCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgZXJyb3JzLnB1c2gobmV3IEFuaW1hdGlvblBhcnNlRXJyb3IoXCJVbmFibGUgdG8gYXBwbHkgc3R5bGVzIGR1ZSB0byBtaXNzaW5nIGEgc3RhdGU6IFxcXCJcIiArIG5vcm1hbGl6ZWRTdGF0ZU5hbWUgKyBcIlxcXCJcIikpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgdmFsdWUuc3R5bGVzLmZvckVhY2goZnVuY3Rpb24gKHN0eWxlc0VudHJ5KSB7XG4gICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHN0eWxlc0VudHJ5ID09PSAnb2JqZWN0JyAmJiBzdHlsZXNFbnRyeSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgIHN0eWxlcy5wdXNoKHN0eWxlc0VudHJ5KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHN0eWxlcztcbiAgfVxuICB2YXIgX0FuaW1hdGlvblRpbWluZ3MgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gX0FuaW1hdGlvblRpbWluZ3MoZHVyYXRpb24sIGRlbGF5LCBlYXNpbmcpIHtcbiAgICAgICAgICB0aGlzLmR1cmF0aW9uID0gZHVyYXRpb247XG4gICAgICAgICAgdGhpcy5kZWxheSA9IGRlbGF5O1xuICAgICAgICAgIHRoaXMuZWFzaW5nID0gZWFzaW5nO1xuICAgICAgfVxuICAgICAgcmV0dXJuIF9BbmltYXRpb25UaW1pbmdzO1xuICB9KCkpO1xuICBmdW5jdGlvbiBfcGFyc2VBbmltYXRpb25LZXlmcmFtZXMoa2V5ZnJhbWVTZXF1ZW5jZSwgY3VycmVudFRpbWUsIGNvbGxlY3RlZFN0eWxlcywgc3RhdGVTdHlsZXMsIGVycm9ycykge1xuICAgICAgdmFyIHRvdGFsRW50cmllcyA9IGtleWZyYW1lU2VxdWVuY2Uuc3RlcHMubGVuZ3RoO1xuICAgICAgdmFyIHRvdGFsT2Zmc2V0cyA9IDA7XG4gICAgICBrZXlmcmFtZVNlcXVlbmNlLnN0ZXBzLmZvckVhY2goZnVuY3Rpb24gKHN0ZXApIHsgcmV0dXJuIHRvdGFsT2Zmc2V0cyArPSAoaXNQcmVzZW50KHN0ZXAub2Zmc2V0KSA/IDEgOiAwKTsgfSk7XG4gICAgICBpZiAodG90YWxPZmZzZXRzID4gMCAmJiB0b3RhbE9mZnNldHMgPCB0b3RhbEVudHJpZXMpIHtcbiAgICAgICAgICBlcnJvcnMucHVzaChuZXcgQW5pbWF0aW9uUGFyc2VFcnJvcihcIk5vdCBhbGwgc3R5bGUoKSBlbnRyaWVzIGNvbnRhaW4gYW4gb2Zmc2V0IGZvciB0aGUgcHJvdmlkZWQga2V5ZnJhbWUoKVwiKSk7XG4gICAgICAgICAgdG90YWxPZmZzZXRzID0gdG90YWxFbnRyaWVzO1xuICAgICAgfVxuICAgICAgdmFyIGxpbWl0ID0gdG90YWxFbnRyaWVzIC0gMTtcbiAgICAgIHZhciBtYXJnaW4gPSB0b3RhbE9mZnNldHMgPT0gMCA/ICgxIC8gbGltaXQpIDogMDtcbiAgICAgIHZhciByYXdLZXlmcmFtZXMgPSBbXTtcbiAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICB2YXIgZG9Tb3J0S2V5ZnJhbWVzID0gZmFsc2U7XG4gICAgICB2YXIgbGFzdE9mZnNldCA9IDA7XG4gICAgICBrZXlmcmFtZVNlcXVlbmNlLnN0ZXBzLmZvckVhY2goZnVuY3Rpb24gKHN0eWxlTWV0YWRhdGEpIHtcbiAgICAgICAgICB2YXIgb2Zmc2V0ID0gc3R5bGVNZXRhZGF0YS5vZmZzZXQ7XG4gICAgICAgICAgdmFyIGtleWZyYW1lU3R5bGVzID0ge307XG4gICAgICAgICAgc3R5bGVNZXRhZGF0YS5zdHlsZXMuZm9yRWFjaChmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgICAgICAgT2JqZWN0LmtleXMoZW50cnkpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICAgICAgICAgIGlmIChwcm9wICE9ICdvZmZzZXQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAga2V5ZnJhbWVTdHlsZXNbcHJvcF0gPSBlbnRyeVtwcm9wXTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKGlzUHJlc2VudChvZmZzZXQpKSB7XG4gICAgICAgICAgICAgIGRvU29ydEtleWZyYW1lcyA9IGRvU29ydEtleWZyYW1lcyB8fCAob2Zmc2V0IDwgbGFzdE9mZnNldCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBvZmZzZXQgPSBpbmRleCA9PSBsaW1pdCA/IF9URVJNSU5BTF9LRVlGUkFNRSA6IChtYXJnaW4gKiBpbmRleCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJhd0tleWZyYW1lcy5wdXNoKFtvZmZzZXQsIGtleWZyYW1lU3R5bGVzXSk7XG4gICAgICAgICAgbGFzdE9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgICBpbmRleCsrO1xuICAgICAgfSk7XG4gICAgICBpZiAoZG9Tb3J0S2V5ZnJhbWVzKSB7XG4gICAgICAgICAgcmF3S2V5ZnJhbWVzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGFbMF0gPD0gYlswXSA/IC0xIDogMTsgfSk7XG4gICAgICB9XG4gICAgICB2YXIgZmlyc3RLZXlmcmFtZSA9IHJhd0tleWZyYW1lc1swXTtcbiAgICAgIGlmIChmaXJzdEtleWZyYW1lWzBdICE9IF9JTklUSUFMX0tFWUZSQU1FKSB7XG4gICAgICAgICAgcmF3S2V5ZnJhbWVzLnNwbGljZSgwLCAwLCBmaXJzdEtleWZyYW1lID0gW19JTklUSUFMX0tFWUZSQU1FLCB7fV0pO1xuICAgICAgfVxuICAgICAgdmFyIGZpcnN0S2V5ZnJhbWVTdHlsZXMgPSBmaXJzdEtleWZyYW1lWzFdO1xuICAgICAgbGltaXQgPSByYXdLZXlmcmFtZXMubGVuZ3RoIC0gMTtcbiAgICAgIHZhciBsYXN0S2V5ZnJhbWUgPSByYXdLZXlmcmFtZXNbbGltaXRdO1xuICAgICAgaWYgKGxhc3RLZXlmcmFtZVswXSAhPSBfVEVSTUlOQUxfS0VZRlJBTUUpIHtcbiAgICAgICAgICByYXdLZXlmcmFtZXMucHVzaChsYXN0S2V5ZnJhbWUgPSBbX1RFUk1JTkFMX0tFWUZSQU1FLCB7fV0pO1xuICAgICAgICAgIGxpbWl0Kys7XG4gICAgICB9XG4gICAgICB2YXIgbGFzdEtleWZyYW1lU3R5bGVzID0gbGFzdEtleWZyYW1lWzFdO1xuICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPD0gbGltaXQ7IGkrKykge1xuICAgICAgICAgIHZhciBlbnRyeSA9IHJhd0tleWZyYW1lc1tpXTtcbiAgICAgICAgICB2YXIgc3R5bGVzID0gZW50cnlbMV07XG4gICAgICAgICAgT2JqZWN0LmtleXMoc3R5bGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgICAgIGlmICghaXNQcmVzZW50KGZpcnN0S2V5ZnJhbWVTdHlsZXNbcHJvcF0pKSB7XG4gICAgICAgICAgICAgICAgICBmaXJzdEtleWZyYW1lU3R5bGVzW3Byb3BdID0gRklMTF9TVFlMRV9GTEFHO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgICB2YXIgZW50cnkgPSByYXdLZXlmcmFtZXNbaV07XG4gICAgICAgICAgdmFyIHN0eWxlcyA9IGVudHJ5WzFdO1xuICAgICAgICAgIE9iamVjdC5rZXlzKHN0eWxlcykuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgICAgICBpZiAoIWlzUHJlc2VudChsYXN0S2V5ZnJhbWVTdHlsZXNbcHJvcF0pKSB7XG4gICAgICAgICAgICAgICAgICBsYXN0S2V5ZnJhbWVTdHlsZXNbcHJvcF0gPSBzdHlsZXNbcHJvcF07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBmb3IgKHZhciBpID0gbGltaXQgLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIF9sb29wXzEoaSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmF3S2V5ZnJhbWVzLm1hcChmdW5jdGlvbiAoZW50cnkpIHsgcmV0dXJuIG5ldyBBbmltYXRpb25LZXlmcmFtZUFzdChlbnRyeVswXSwgbmV3IEFuaW1hdGlvblN0eWxlc0FzdChbZW50cnlbMV1dKSk7IH0pO1xuICB9XG4gIGZ1bmN0aW9uIF9wYXJzZVRyYW5zaXRpb25BbmltYXRpb24oZW50cnksIGN1cnJlbnRUaW1lLCBjb2xsZWN0ZWRTdHlsZXMsIHN0YXRlU3R5bGVzLCBlcnJvcnMpIHtcbiAgICAgIHZhciBhc3Q7XG4gICAgICB2YXIgcGxheVRpbWUgPSAwO1xuICAgICAgdmFyIHN0YXJ0aW5nVGltZSA9IGN1cnJlbnRUaW1lO1xuICAgICAgaWYgKGVudHJ5IGluc3RhbmNlb2YgQ29tcGlsZUFuaW1hdGlvbldpdGhTdGVwc01ldGFkYXRhKSB7XG4gICAgICAgICAgdmFyIG1heER1cmF0aW9uID0gMDtcbiAgICAgICAgICB2YXIgc3RlcHMgPSBbXTtcbiAgICAgICAgICB2YXIgaXNHcm91cCA9IGVudHJ5IGluc3RhbmNlb2YgQ29tcGlsZUFuaW1hdGlvbkdyb3VwTWV0YWRhdGE7XG4gICAgICAgICAgdmFyIHByZXZpb3VzU3R5bGVzO1xuICAgICAgICAgIGVudHJ5LnN0ZXBzLmZvckVhY2goZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgICAgICAgIC8vIHRoZXNlIHdpbGwgZ2V0IHBpY2tlZCB1cCBieSB0aGUgbmV4dCBzdGVwLi4uXG4gICAgICAgICAgICAgIHZhciB0aW1lID0gaXNHcm91cCA/IHN0YXJ0aW5nVGltZSA6IGN1cnJlbnRUaW1lO1xuICAgICAgICAgICAgICBpZiAoZW50cnkgaW5zdGFuY2VvZiBDb21waWxlQW5pbWF0aW9uU3R5bGVNZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgICAgZW50cnkuc3R5bGVzLmZvckVhY2goZnVuY3Rpb24gKHN0eWxlc0VudHJ5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gYnkgdGhpcyBwb2ludCB3ZSBrbm93IHRoYXQgd2Ugb25seSBoYXZlIHN0cmluZ21hcCB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgbWFwID0gc3R5bGVzRW50cnk7XG4gICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXMobWFwKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7IGNvbGxlY3RlZFN0eWxlcy5pbnNlcnRBdFRpbWUocHJvcCwgdGltZSwgbWFwW3Byb3BdKTsgfSk7XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIHByZXZpb3VzU3R5bGVzID0gZW50cnkuc3R5bGVzO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhciBpbm5lckFzdCA9IF9wYXJzZVRyYW5zaXRpb25BbmltYXRpb24oZW50cnksIHRpbWUsIGNvbGxlY3RlZFN0eWxlcywgc3RhdGVTdHlsZXMsIGVycm9ycyk7XG4gICAgICAgICAgICAgIGlmIChpc1ByZXNlbnQocHJldmlvdXNTdHlsZXMpKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoZW50cnkgaW5zdGFuY2VvZiBDb21waWxlQW5pbWF0aW9uV2l0aFN0ZXBzTWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RhcnRpbmdTdHlsZXMgPSBuZXcgQW5pbWF0aW9uU3R5bGVzQXN0KHByZXZpb3VzU3R5bGVzKTtcbiAgICAgICAgICAgICAgICAgICAgICBzdGVwcy5wdXNoKG5ldyBBbmltYXRpb25TdGVwQXN0KHN0YXJ0aW5nU3R5bGVzLCBbXSwgMCwgMCwgJycpKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBpbm5lclN0ZXAgPSBpbm5lckFzdDtcbiAgICAgICAgICAgICAgICAgICAgICAoX2EgPSBpbm5lclN0ZXAuc3RhcnRpbmdTdHlsZXMuc3R5bGVzKS5wdXNoLmFwcGx5KF9hLCBwcmV2aW91c1N0eWxlcyk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBwcmV2aW91c1N0eWxlcyA9IG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFyIGFzdER1cmF0aW9uID0gaW5uZXJBc3QucGxheVRpbWU7XG4gICAgICAgICAgICAgIGN1cnJlbnRUaW1lICs9IGFzdER1cmF0aW9uO1xuICAgICAgICAgICAgICBwbGF5VGltZSArPSBhc3REdXJhdGlvbjtcbiAgICAgICAgICAgICAgbWF4RHVyYXRpb24gPSBNYXRoLm1heChhc3REdXJhdGlvbiwgbWF4RHVyYXRpb24pO1xuICAgICAgICAgICAgICBzdGVwcy5wdXNoKGlubmVyQXN0KTtcbiAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmIChpc1ByZXNlbnQocHJldmlvdXNTdHlsZXMpKSB7XG4gICAgICAgICAgICAgIHZhciBzdGFydGluZ1N0eWxlcyA9IG5ldyBBbmltYXRpb25TdHlsZXNBc3QocHJldmlvdXNTdHlsZXMpO1xuICAgICAgICAgICAgICBzdGVwcy5wdXNoKG5ldyBBbmltYXRpb25TdGVwQXN0KHN0YXJ0aW5nU3R5bGVzLCBbXSwgMCwgMCwgJycpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzR3JvdXApIHtcbiAgICAgICAgICAgICAgYXN0ID0gbmV3IEFuaW1hdGlvbkdyb3VwQXN0KHN0ZXBzKTtcbiAgICAgICAgICAgICAgcGxheVRpbWUgPSBtYXhEdXJhdGlvbjtcbiAgICAgICAgICAgICAgY3VycmVudFRpbWUgPSBzdGFydGluZ1RpbWUgKyBwbGF5VGltZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGFzdCA9IG5ldyBBbmltYXRpb25TZXF1ZW5jZUFzdChzdGVwcyk7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAoZW50cnkgaW5zdGFuY2VvZiBDb21waWxlQW5pbWF0aW9uQW5pbWF0ZU1ldGFkYXRhKSB7XG4gICAgICAgICAgdmFyIHRpbWluZ3MgPSBfcGFyc2VUaW1lRXhwcmVzc2lvbihlbnRyeS50aW1pbmdzLCBlcnJvcnMpO1xuICAgICAgICAgIHZhciBzdHlsZXMgPSBlbnRyeS5zdHlsZXM7XG4gICAgICAgICAgdmFyIGtleWZyYW1lcztcbiAgICAgICAgICBpZiAoc3R5bGVzIGluc3RhbmNlb2YgQ29tcGlsZUFuaW1hdGlvbktleWZyYW1lc1NlcXVlbmNlTWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAga2V5ZnJhbWVzID1cbiAgICAgICAgICAgICAgICAgIF9wYXJzZUFuaW1hdGlvbktleWZyYW1lcyhzdHlsZXMsIGN1cnJlbnRUaW1lLCBjb2xsZWN0ZWRTdHlsZXMsIHN0YXRlU3R5bGVzLCBlcnJvcnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIHN0eWxlRGF0YSA9IHN0eWxlcztcbiAgICAgICAgICAgICAgdmFyIG9mZnNldCA9IF9URVJNSU5BTF9LRVlGUkFNRTtcbiAgICAgICAgICAgICAgdmFyIHN0eWxlQXN0ID0gbmV3IEFuaW1hdGlvblN0eWxlc0FzdChzdHlsZURhdGEuc3R5bGVzKTtcbiAgICAgICAgICAgICAgdmFyIGtleWZyYW1lID0gbmV3IEFuaW1hdGlvbktleWZyYW1lQXN0KG9mZnNldCwgc3R5bGVBc3QpO1xuICAgICAgICAgICAgICBrZXlmcmFtZXMgPSBba2V5ZnJhbWVdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhc3QgPSBuZXcgQW5pbWF0aW9uU3RlcEFzdChuZXcgQW5pbWF0aW9uU3R5bGVzQXN0KFtdKSwga2V5ZnJhbWVzLCB0aW1pbmdzLmR1cmF0aW9uLCB0aW1pbmdzLmRlbGF5LCB0aW1pbmdzLmVhc2luZyk7XG4gICAgICAgICAgcGxheVRpbWUgPSB0aW1pbmdzLmR1cmF0aW9uICsgdGltaW5ncy5kZWxheTtcbiAgICAgICAgICBjdXJyZW50VGltZSArPSBwbGF5VGltZTtcbiAgICAgICAgICBrZXlmcmFtZXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5ZnJhbWUgLyoqIFRPRE8gIzkxMDAgKi8pIHsgcmV0dXJuIGtleWZyYW1lLnN0eWxlcy5zdHlsZXMuZm9yRWFjaChmdW5jdGlvbiAoZW50cnkgLyoqIFRPRE8gIzkxMDAgKi8pIHsgcmV0dXJuIE9iamVjdC5rZXlzKGVudHJ5KS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7IGNvbGxlY3RlZFN0eWxlcy5pbnNlcnRBdFRpbWUocHJvcCwgY3VycmVudFRpbWUsIGVudHJ5W3Byb3BdKTsgfSk7IH0pOyB9KTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAgIC8vIGlmIHRoZSBjb2RlIHJlYWNoZXMgdGhpcyBzdGFnZSB0aGVuIGFuIGVycm9yXG4gICAgICAgICAgLy8gaGFzIGFscmVhZHkgYmVlbiBwb3B1bGF0ZWQgd2l0aGluIHRoZSBfbm9ybWFsaXplU3R5bGVTdGVwcygpXG4gICAgICAgICAgLy8gb3BlcmF0aW9uLi4uXG4gICAgICAgICAgYXN0ID0gbmV3IEFuaW1hdGlvblN0ZXBBc3QobnVsbCwgW10sIDAsIDAsICcnKTtcbiAgICAgIH1cbiAgICAgIGFzdC5wbGF5VGltZSA9IHBsYXlUaW1lO1xuICAgICAgYXN0LnN0YXJ0VGltZSA9IHN0YXJ0aW5nVGltZTtcbiAgICAgIHJldHVybiBhc3Q7XG4gIH1cbiAgZnVuY3Rpb24gX2ZpbGxBbmltYXRpb25Bc3RTdGFydGluZ0tleWZyYW1lcyhhc3QsIGNvbGxlY3RlZFN0eWxlcywgZXJyb3JzKSB7XG4gICAgICAvLyBzdGVwcyB0aGF0IG9ubHkgY29udGFpbiBzdHlsZSB3aWxsIG5vdCBiZSBmaWxsZWRcbiAgICAgIGlmICgoYXN0IGluc3RhbmNlb2YgQW5pbWF0aW9uU3RlcEFzdCkgJiYgYXN0LmtleWZyYW1lcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdmFyIGtleWZyYW1lcyA9IGFzdC5rZXlmcmFtZXM7XG4gICAgICAgICAgaWYgKGtleWZyYW1lcy5sZW5ndGggPT0gMSkge1xuICAgICAgICAgICAgICB2YXIgZW5kS2V5ZnJhbWUgPSBrZXlmcmFtZXNbMF07XG4gICAgICAgICAgICAgIHZhciBzdGFydEtleWZyYW1lID0gX2NyZWF0ZVN0YXJ0S2V5ZnJhbWVGcm9tRW5kS2V5ZnJhbWUoZW5kS2V5ZnJhbWUsIGFzdC5zdGFydFRpbWUsIGFzdC5wbGF5VGltZSwgY29sbGVjdGVkU3R5bGVzLCBlcnJvcnMpO1xuICAgICAgICAgICAgICBhc3Qua2V5ZnJhbWVzID0gW3N0YXJ0S2V5ZnJhbWUsIGVuZEtleWZyYW1lXTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChhc3QgaW5zdGFuY2VvZiBBbmltYXRpb25XaXRoU3RlcHNBc3QpIHtcbiAgICAgICAgICBhc3Quc3RlcHMuZm9yRWFjaChmdW5jdGlvbiAoZW50cnkpIHsgcmV0dXJuIF9maWxsQW5pbWF0aW9uQXN0U3RhcnRpbmdLZXlmcmFtZXMoZW50cnksIGNvbGxlY3RlZFN0eWxlcywgZXJyb3JzKTsgfSk7XG4gICAgICB9XG4gIH1cbiAgZnVuY3Rpb24gX3BhcnNlVGltZUV4cHJlc3Npb24oZXhwLCBlcnJvcnMpIHtcbiAgICAgIHZhciByZWdleCA9IC9eKFtcXC5cXGRdKykobT9zKSg/OlxccysoW1xcLlxcZF0rKShtP3MpKT8oPzpcXHMrKFstYS16XSsoPzpcXCguKz9cXCkpPykpPy9pO1xuICAgICAgdmFyIGR1cmF0aW9uO1xuICAgICAgdmFyIGRlbGF5ID0gMDtcbiAgICAgIHZhciBlYXNpbmcgPSBudWxsO1xuICAgICAgaWYgKHR5cGVvZiBleHAgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgdmFyIG1hdGNoZXMgPSBleHAubWF0Y2gocmVnZXgpO1xuICAgICAgICAgIGlmIChtYXRjaGVzID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBBbmltYXRpb25QYXJzZUVycm9yKFwiVGhlIHByb3ZpZGVkIHRpbWluZyB2YWx1ZSBcXFwiXCIgKyBleHAgKyBcIlxcXCIgaXMgaW52YWxpZC5cIikpO1xuICAgICAgICAgICAgICByZXR1cm4gbmV3IF9BbmltYXRpb25UaW1pbmdzKDAsIDAsIG51bGwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgZHVyYXRpb25NYXRjaCA9IHBhcnNlRmxvYXQobWF0Y2hlc1sxXSk7XG4gICAgICAgICAgdmFyIGR1cmF0aW9uVW5pdCA9IG1hdGNoZXNbMl07XG4gICAgICAgICAgaWYgKGR1cmF0aW9uVW5pdCA9PSAncycpIHtcbiAgICAgICAgICAgICAgZHVyYXRpb25NYXRjaCAqPSBfT05FX1NFQ09ORDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZHVyYXRpb24gPSBNYXRoLmZsb29yKGR1cmF0aW9uTWF0Y2gpO1xuICAgICAgICAgIHZhciBkZWxheU1hdGNoID0gbWF0Y2hlc1szXTtcbiAgICAgICAgICB2YXIgZGVsYXlVbml0ID0gbWF0Y2hlc1s0XTtcbiAgICAgICAgICBpZiAoaXNQcmVzZW50KGRlbGF5TWF0Y2gpKSB7XG4gICAgICAgICAgICAgIHZhciBkZWxheVZhbCA9IHBhcnNlRmxvYXQoZGVsYXlNYXRjaCk7XG4gICAgICAgICAgICAgIGlmIChpc1ByZXNlbnQoZGVsYXlVbml0KSAmJiBkZWxheVVuaXQgPT0gJ3MnKSB7XG4gICAgICAgICAgICAgICAgICBkZWxheVZhbCAqPSBfT05FX1NFQ09ORDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBkZWxheSA9IE1hdGguZmxvb3IoZGVsYXlWYWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgZWFzaW5nVmFsID0gbWF0Y2hlc1s1XTtcbiAgICAgICAgICBpZiAoIWlzQmxhbmsoZWFzaW5nVmFsKSkge1xuICAgICAgICAgICAgICBlYXNpbmcgPSBlYXNpbmdWYWw7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICAgZHVyYXRpb24gPSBleHA7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IF9BbmltYXRpb25UaW1pbmdzKGR1cmF0aW9uLCBkZWxheSwgZWFzaW5nKTtcbiAgfVxuICBmdW5jdGlvbiBfY3JlYXRlU3RhcnRLZXlmcmFtZUZyb21FbmRLZXlmcmFtZShlbmRLZXlmcmFtZSwgc3RhcnRUaW1lLCBkdXJhdGlvbiwgY29sbGVjdGVkU3R5bGVzLCBlcnJvcnMpIHtcbiAgICAgIHZhciB2YWx1ZXMgPSB7fTtcbiAgICAgIHZhciBlbmRUaW1lID0gc3RhcnRUaW1lICsgZHVyYXRpb247XG4gICAgICBlbmRLZXlmcmFtZS5zdHlsZXMuc3R5bGVzLmZvckVhY2goZnVuY3Rpb24gKHN0eWxlRGF0YSkge1xuICAgICAgICAgIE9iamVjdC5rZXlzKHN0eWxlRGF0YSkuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgICAgICB2YXIgdmFsID0gc3R5bGVEYXRhW3Byb3BdO1xuICAgICAgICAgICAgICBpZiAocHJvcCA9PSAnb2Zmc2V0JylcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgdmFyIHJlc3VsdEluZGV4ID0gY29sbGVjdGVkU3R5bGVzLmluZGV4T2ZBdE9yQmVmb3JlVGltZShwcm9wLCBzdGFydFRpbWUpO1xuICAgICAgICAgICAgICB2YXIgcmVzdWx0RW50cnkgLyoqIFRPRE8gIzkxMDAgKi8sIG5leHRFbnRyeSAvKiogVE9ETyAjOTEwMCAqLywgdmFsdWU7XG4gICAgICAgICAgICAgIGlmIChpc1ByZXNlbnQocmVzdWx0SW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHRFbnRyeSA9IGNvbGxlY3RlZFN0eWxlcy5nZXRCeUluZGV4KHByb3AsIHJlc3VsdEluZGV4KTtcbiAgICAgICAgICAgICAgICAgIHZhbHVlID0gcmVzdWx0RW50cnkudmFsdWU7XG4gICAgICAgICAgICAgICAgICBuZXh0RW50cnkgPSBjb2xsZWN0ZWRTdHlsZXMuZ2V0QnlJbmRleChwcm9wLCByZXN1bHRJbmRleCArIDEpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgLy8gdGhpcyBpcyBhIGZsYWcgdGhhdCB0aGUgcnVudGltZSBjb2RlIHVzZXMgdG8gcGFzc1xuICAgICAgICAgICAgICAgICAgLy8gaW4gYSB2YWx1ZSBlaXRoZXIgZnJvbSB0aGUgc3RhdGUgZGVjbGFyYXRpb24gc3R5bGVzXG4gICAgICAgICAgICAgICAgICAvLyBvciB1c2luZyB0aGUgQVVUT19TVFlMRSB2YWx1ZSAoZS5nLiBnZXRDb21wdXRlZFN0eWxlKVxuICAgICAgICAgICAgICAgICAgdmFsdWUgPSBGSUxMX1NUWUxFX0ZMQUc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGlzUHJlc2VudChuZXh0RW50cnkpICYmICFuZXh0RW50cnkubWF0Y2hlcyhlbmRUaW1lLCB2YWwpKSB7XG4gICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChuZXcgQW5pbWF0aW9uUGFyc2VFcnJvcihcIlRoZSBhbmltYXRlZCBDU1MgcHJvcGVydHkgXFxcIlwiICsgcHJvcCArIFwiXFxcIiB1bmV4cGVjdGVkbHkgY2hhbmdlcyBiZXR3ZWVuIHN0ZXBzIFxcXCJcIiArIHJlc3VsdEVudHJ5LnRpbWUgKyBcIm1zXFxcIiBhbmQgXFxcIlwiICsgZW5kVGltZSArIFwibXNcXFwiIGF0IFxcXCJcIiArIG5leHRFbnRyeS50aW1lICsgXCJtc1xcXCJcIikpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhbHVlc1twcm9wXSA9IHZhbHVlO1xuICAgICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gbmV3IEFuaW1hdGlvbktleWZyYW1lQXN0KF9JTklUSUFMX0tFWUZSQU1FLCBuZXcgQW5pbWF0aW9uU3R5bGVzQXN0KFt2YWx1ZXNdKSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVEaVRva2VuRXhwcmVzc2lvbih0b2tlbikge1xuICAgICAgaWYgKGlzUHJlc2VudCh0b2tlbi52YWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gbGl0ZXJhbCh0b2tlbi52YWx1ZSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh0b2tlbi5pZGVudGlmaWVySXNJbnN0YW5jZSkge1xuICAgICAgICAgIHJldHVybiBpbXBvcnRFeHByKHRva2VuLmlkZW50aWZpZXIpXG4gICAgICAgICAgICAgIC5pbnN0YW50aWF0ZShbXSwgaW1wb3J0VHlwZSh0b2tlbi5pZGVudGlmaWVyLCBbXSwgW1R5cGVNb2RpZmllci5Db25zdF0pKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAgIHJldHVybiBpbXBvcnRFeHByKHRva2VuLmlkZW50aWZpZXIpO1xuICAgICAgfVxuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZUlubGluZUFycmF5KHZhbHVlcykge1xuICAgICAgaWYgKHZhbHVlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gaW1wb3J0RXhwcihyZXNvbHZlSWRlbnRpZmllcihJZGVudGlmaWVycy5FTVBUWV9JTkxJTkVfQVJSQVkpKTtcbiAgICAgIH1cbiAgICAgIHZhciBsb2cyID0gTWF0aC5sb2codmFsdWVzLmxlbmd0aCkgLyBNYXRoLmxvZygyKTtcbiAgICAgIHZhciBpbmRleCA9IE1hdGguY2VpbChsb2cyKTtcbiAgICAgIHZhciBpZGVudGlmaWVyU3BlYyA9IGluZGV4IDwgSWRlbnRpZmllcnMuaW5saW5lQXJyYXlzLmxlbmd0aCA/IElkZW50aWZpZXJzLmlubGluZUFycmF5c1tpbmRleF0gOlxuICAgICAgICAgIElkZW50aWZpZXJzLklubGluZUFycmF5RHluYW1pYztcbiAgICAgIHZhciBpZGVudGlmaWVyID0gcmVzb2x2ZUlkZW50aWZpZXIoaWRlbnRpZmllclNwZWMpO1xuICAgICAgcmV0dXJuIGltcG9ydEV4cHIoaWRlbnRpZmllcikuaW5zdGFudGlhdGUoW1xuICAgICAgICAgIGxpdGVyYWwodmFsdWVzLmxlbmd0aClcbiAgICAgIF0uY29uY2F0KHZhbHVlcykpO1xuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZVB1cmVQcm94eShmbiwgYXJnQ291bnQsIHB1cmVQcm94eVByb3AsIGJ1aWxkZXIpIHtcbiAgICAgIGJ1aWxkZXIuZmllbGRzLnB1c2gobmV3IENsYXNzRmllbGQocHVyZVByb3h5UHJvcC5uYW1lLCBudWxsKSk7XG4gICAgICB2YXIgcHVyZVByb3h5SWQgPSBhcmdDb3VudCA8IElkZW50aWZpZXJzLnB1cmVQcm94aWVzLmxlbmd0aCA/IElkZW50aWZpZXJzLnB1cmVQcm94aWVzW2FyZ0NvdW50XSA6IG51bGw7XG4gICAgICBpZiAoIXB1cmVQcm94eUlkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgbnVtYmVyIG9mIGFyZ3VtZW50IGZvciBwdXJlIGZ1bmN0aW9uczogXCIgKyBhcmdDb3VudCk7XG4gICAgICB9XG4gICAgICBidWlsZGVyLmN0b3JTdG10cy5wdXNoKFRISVNfRVhQUi5wcm9wKHB1cmVQcm94eVByb3AubmFtZSlcbiAgICAgICAgICAuc2V0KGltcG9ydEV4cHIocmVzb2x2ZUlkZW50aWZpZXIocHVyZVByb3h5SWQpKS5jYWxsRm4oW2ZuXSkpXG4gICAgICAgICAgLnRvU3RtdCgpKTtcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVFbnVtRXhwcmVzc2lvbihlbnVtVHlwZSwgZW51bVZhbHVlKSB7XG4gICAgICB2YXIgZW51bU5hbWUgPSBPYmplY3Qua2V5cyhlbnVtVHlwZS5ydW50aW1lKS5maW5kKGZ1bmN0aW9uIChwcm9wTmFtZSkgeyByZXR1cm4gZW51bVR5cGUucnVudGltZVtwcm9wTmFtZV0gPT09IGVudW1WYWx1ZTsgfSk7XG4gICAgICBpZiAoIWVudW1OYW1lKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBlbnVtIHZhbHVlIFwiICsgZW51bVZhbHVlICsgXCIgaW4gXCIgKyBlbnVtVHlwZS5uYW1lKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpbXBvcnRFeHByKHJlc29sdmVFbnVtSWRlbnRpZmllcihyZXNvbHZlSWRlbnRpZmllcihlbnVtVHlwZSksIGVudW1OYW1lKSk7XG4gIH1cblxuICB2YXIgQ2hlY2tCaW5kaW5nRmllbGQgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gQ2hlY2tCaW5kaW5nRmllbGQoZXhwcmVzc2lvbiwgYmluZGluZ0lkKSB7XG4gICAgICAgICAgdGhpcy5leHByZXNzaW9uID0gZXhwcmVzc2lvbjtcbiAgICAgICAgICB0aGlzLmJpbmRpbmdJZCA9IGJpbmRpbmdJZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBDaGVja0JpbmRpbmdGaWVsZDtcbiAgfSgpKTtcbiAgZnVuY3Rpb24gY3JlYXRlQ2hlY2tCaW5kaW5nRmllbGQoYnVpbGRlcikge1xuICAgICAgdmFyIGJpbmRpbmdJZCA9IFwiXCIgKyBidWlsZGVyLmZpZWxkcy5sZW5ndGg7XG4gICAgICB2YXIgZmllbGRFeHByID0gY3JlYXRlQmluZEZpZWxkRXhwcihiaW5kaW5nSWQpO1xuICAgICAgLy8gcHJpdmF0ZSBpcyBmaW5lIGhlcmUgYXMgbm8gY2hpbGQgdmlldyB3aWxsIHJlZmVyZW5jZSB0aGUgY2FjaGVkIHZhbHVlLi4uXG4gICAgICBidWlsZGVyLmZpZWxkcy5wdXNoKG5ldyBDbGFzc0ZpZWxkKGZpZWxkRXhwci5uYW1lLCBudWxsLCBbU3RtdE1vZGlmaWVyLlByaXZhdGVdKSk7XG4gICAgICBidWlsZGVyLmN0b3JTdG10cy5wdXNoKFRISVNfRVhQUi5wcm9wKGZpZWxkRXhwci5uYW1lKVxuICAgICAgICAgIC5zZXQoaW1wb3J0RXhwcihyZXNvbHZlSWRlbnRpZmllcihJZGVudGlmaWVycy5VTklOSVRJQUxJWkVEKSkpXG4gICAgICAgICAgLnRvU3RtdCgpKTtcbiAgICAgIHJldHVybiBuZXcgQ2hlY2tCaW5kaW5nRmllbGQoZmllbGRFeHByLCBiaW5kaW5nSWQpO1xuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZUNoZWNrQmluZGluZ1N0bXQoZXZhbFJlc3VsdCwgZmllbGRFeHByLCB0aHJvd09uQ2hhbmdlVmFyLCBhY3Rpb25zKSB7XG4gICAgICB2YXIgY29uZGl0aW9uID0gaW1wb3J0RXhwcihyZXNvbHZlSWRlbnRpZmllcihJZGVudGlmaWVycy5jaGVja0JpbmRpbmcpKS5jYWxsRm4oW1xuICAgICAgICAgIHRocm93T25DaGFuZ2VWYXIsIGZpZWxkRXhwciwgZXZhbFJlc3VsdC5jdXJyVmFsRXhwclxuICAgICAgXSk7XG4gICAgICBpZiAoZXZhbFJlc3VsdC5mb3JjZVVwZGF0ZSkge1xuICAgICAgICAgIGNvbmRpdGlvbiA9IGV2YWxSZXN1bHQuZm9yY2VVcGRhdGUub3IoY29uZGl0aW9uKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBldmFsUmVzdWx0LnN0bXRzLmNvbmNhdChbXG4gICAgICAgICAgbmV3IElmU3RtdChjb25kaXRpb24sIGFjdGlvbnMuY29uY2F0KFtcbiAgICAgICAgICAgICAgVEhJU19FWFBSLnByb3AoZmllbGRFeHByLm5hbWUpLnNldChldmFsUmVzdWx0LmN1cnJWYWxFeHByKS50b1N0bXQoKVxuICAgICAgICAgIF0pKVxuICAgICAgXSk7XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlQmluZEZpZWxkRXhwcihiaW5kaW5nSWQpIHtcbiAgICAgIHJldHVybiBUSElTX0VYUFIucHJvcChcIl9leHByX1wiICsgYmluZGluZ0lkKTtcbiAgfVxuXG4gIHZhciBWQUxfVU5XUkFQUEVSX1ZBUiA9IHZhcmlhYmxlKFwidmFsVW53cmFwcGVyXCIpO1xuICB2YXIgRXZlbnRIYW5kbGVyVmFycyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBFdmVudEhhbmRsZXJWYXJzKCkge1xuICAgICAgfVxuICAgICAgRXZlbnRIYW5kbGVyVmFycy5ldmVudCA9IHZhcmlhYmxlKCckZXZlbnQnKTtcbiAgICAgIHJldHVybiBFdmVudEhhbmRsZXJWYXJzO1xuICB9KCkpO1xuICB2YXIgQ29udmVydFByb3BlcnR5QmluZGluZ1Jlc3VsdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBDb252ZXJ0UHJvcGVydHlCaW5kaW5nUmVzdWx0KHN0bXRzLCBjdXJyVmFsRXhwciwgZm9yY2VVcGRhdGUpIHtcbiAgICAgICAgICB0aGlzLnN0bXRzID0gc3RtdHM7XG4gICAgICAgICAgdGhpcy5jdXJyVmFsRXhwciA9IGN1cnJWYWxFeHByO1xuICAgICAgICAgIHRoaXMuZm9yY2VVcGRhdGUgPSBmb3JjZVVwZGF0ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBDb252ZXJ0UHJvcGVydHlCaW5kaW5nUmVzdWx0O1xuICB9KCkpO1xuICAvKipcbiAgICogQ29udmVydHMgdGhlIGdpdmVuIGV4cHJlc3Npb24gQVNUIGludG8gYW4gZXhlY3V0YWJsZSBvdXRwdXQgQVNULCBhc3N1bWluZyB0aGUgZXhwcmVzc2lvbiBpc1xuICAgKiB1c2VkIGluIGEgcHJvcGVydHkgYmluZGluZy5cbiAgICovXG4gIGZ1bmN0aW9uIGNvbnZlcnRQcm9wZXJ0eUJpbmRpbmcoYnVpbGRlciwgbmFtZVJlc29sdmVyLCBpbXBsaWNpdFJlY2VpdmVyLCBleHByZXNzaW9uLCBiaW5kaW5nSWQpIHtcbiAgICAgIHZhciBjdXJyVmFsRXhwciA9IGNyZWF0ZUN1cnJWYWx1ZUV4cHIoYmluZGluZ0lkKTtcbiAgICAgIHZhciBzdG10cyA9IFtdO1xuICAgICAgaWYgKCFuYW1lUmVzb2x2ZXIpIHtcbiAgICAgICAgICBuYW1lUmVzb2x2ZXIgPSBuZXcgRGVmYXVsdE5hbWVSZXNvbHZlcigpO1xuICAgICAgfVxuICAgICAgdmFyIHZpc2l0b3IgPSBuZXcgX0FzdFRvSXJWaXNpdG9yKGJ1aWxkZXIsIG5hbWVSZXNvbHZlciwgaW1wbGljaXRSZWNlaXZlciwgVkFMX1VOV1JBUFBFUl9WQVIsIGJpbmRpbmdJZCwgZmFsc2UpO1xuICAgICAgdmFyIG91dHB1dEV4cHIgPSBleHByZXNzaW9uLnZpc2l0KHZpc2l0b3IsIF9Nb2RlLkV4cHJlc3Npb24pO1xuICAgICAgaWYgKCFvdXRwdXRFeHByKSB7XG4gICAgICAgICAgLy8gZS5nLiBhbiBlbXB0eSBleHByZXNzaW9uIHdhcyBnaXZlblxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKHZpc2l0b3IudGVtcG9yYXJ5Q291bnQpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZpc2l0b3IudGVtcG9yYXJ5Q291bnQ7IGkrKykge1xuICAgICAgICAgICAgICBzdG10cy5wdXNoKHRlbXBvcmFyeURlY2xhcmF0aW9uKGJpbmRpbmdJZCwgaSkpO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh2aXNpdG9yLm5lZWRzVmFsdWVVbndyYXBwZXIpIHtcbiAgICAgICAgICB2YXIgaW5pdFZhbHVlVW53cmFwcGVyU3RtdCA9IFZBTF9VTldSQVBQRVJfVkFSLmNhbGxNZXRob2QoJ3Jlc2V0JywgW10pLnRvU3RtdCgpO1xuICAgICAgICAgIHN0bXRzLnB1c2goaW5pdFZhbHVlVW53cmFwcGVyU3RtdCk7XG4gICAgICB9XG4gICAgICBzdG10cy5wdXNoKGN1cnJWYWxFeHByLnNldChvdXRwdXRFeHByKS50b0RlY2xTdG10KG51bGwsIFtTdG10TW9kaWZpZXIuRmluYWxdKSk7XG4gICAgICBpZiAodmlzaXRvci5uZWVkc1ZhbHVlVW53cmFwcGVyKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBDb252ZXJ0UHJvcGVydHlCaW5kaW5nUmVzdWx0KHN0bXRzLCBjdXJyVmFsRXhwciwgVkFMX1VOV1JBUFBFUl9WQVIucHJvcCgnaGFzV3JhcHBlZFZhbHVlJykpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBDb252ZXJ0UHJvcGVydHlCaW5kaW5nUmVzdWx0KHN0bXRzLCBjdXJyVmFsRXhwciwgbnVsbCk7XG4gICAgICB9XG4gIH1cbiAgdmFyIENvbnZlcnRBY3Rpb25CaW5kaW5nUmVzdWx0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIENvbnZlcnRBY3Rpb25CaW5kaW5nUmVzdWx0KHN0bXRzLCBwcmV2ZW50RGVmYXVsdCkge1xuICAgICAgICAgIHRoaXMuc3RtdHMgPSBzdG10cztcbiAgICAgICAgICB0aGlzLnByZXZlbnREZWZhdWx0ID0gcHJldmVudERlZmF1bHQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gQ29udmVydEFjdGlvbkJpbmRpbmdSZXN1bHQ7XG4gIH0oKSk7XG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGUgZ2l2ZW4gZXhwcmVzc2lvbiBBU1QgaW50byBhbiBleGVjdXRhYmxlIG91dHB1dCBBU1QsIGFzc3VtaW5nIHRoZSBleHByZXNzaW9uIGlzXG4gICAqIHVzZWQgaW4gYW4gYWN0aW9uIGJpbmRpbmcgKGUuZy4gYW4gZXZlbnQgaGFuZGxlcikuXG4gICAqL1xuICBmdW5jdGlvbiBjb252ZXJ0QWN0aW9uQmluZGluZyhidWlsZGVyLCBuYW1lUmVzb2x2ZXIsIGltcGxpY2l0UmVjZWl2ZXIsIGFjdGlvbiwgYmluZGluZ0lkKSB7XG4gICAgICBpZiAoIW5hbWVSZXNvbHZlcikge1xuICAgICAgICAgIG5hbWVSZXNvbHZlciA9IG5ldyBEZWZhdWx0TmFtZVJlc29sdmVyKCk7XG4gICAgICB9XG4gICAgICB2YXIgdmlzaXRvciA9IG5ldyBfQXN0VG9JclZpc2l0b3IoYnVpbGRlciwgbmFtZVJlc29sdmVyLCBpbXBsaWNpdFJlY2VpdmVyLCBudWxsLCBiaW5kaW5nSWQsIHRydWUpO1xuICAgICAgdmFyIGFjdGlvblN0bXRzID0gW107XG4gICAgICBmbGF0dGVuU3RhdGVtZW50cyhhY3Rpb24udmlzaXQodmlzaXRvciwgX01vZGUuU3RhdGVtZW50KSwgYWN0aW9uU3RtdHMpO1xuICAgICAgcHJlcGVuZFRlbXBvcmFyeURlY2xzKHZpc2l0b3IudGVtcG9yYXJ5Q291bnQsIGJpbmRpbmdJZCwgYWN0aW9uU3RtdHMpO1xuICAgICAgdmFyIGxhc3RJbmRleCA9IGFjdGlvblN0bXRzLmxlbmd0aCAtIDE7XG4gICAgICB2YXIgcHJldmVudERlZmF1bHRWYXIgPSBudWxsO1xuICAgICAgaWYgKGxhc3RJbmRleCA+PSAwKSB7XG4gICAgICAgICAgdmFyIGxhc3RTdGF0ZW1lbnQgPSBhY3Rpb25TdG10c1tsYXN0SW5kZXhdO1xuICAgICAgICAgIHZhciByZXR1cm5FeHByID0gY29udmVydFN0bXRJbnRvRXhwcmVzc2lvbihsYXN0U3RhdGVtZW50KTtcbiAgICAgICAgICBpZiAocmV0dXJuRXhwcikge1xuICAgICAgICAgICAgICAvLyBOb3RlOiBXZSBuZWVkIHRvIGNhc3QgdGhlIHJlc3VsdCBvZiB0aGUgbWV0aG9kIGNhbGwgdG8gZHluYW1pYyxcbiAgICAgICAgICAgICAgLy8gYXMgaXQgbWlnaHQgYmUgYSB2b2lkIG1ldGhvZCFcbiAgICAgICAgICAgICAgcHJldmVudERlZmF1bHRWYXIgPSBjcmVhdGVQcmV2ZW50RGVmYXVsdFZhcihiaW5kaW5nSWQpO1xuICAgICAgICAgICAgICBhY3Rpb25TdG10c1tsYXN0SW5kZXhdID1cbiAgICAgICAgICAgICAgICAgIHByZXZlbnREZWZhdWx0VmFyLnNldChyZXR1cm5FeHByLmNhc3QoRFlOQU1JQ19UWVBFKS5ub3RJZGVudGljYWwobGl0ZXJhbChmYWxzZSkpKVxuICAgICAgICAgICAgICAgICAgICAgIC50b0RlY2xTdG10KG51bGwsIFtTdG10TW9kaWZpZXIuRmluYWxdKTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IENvbnZlcnRBY3Rpb25CaW5kaW5nUmVzdWx0KGFjdGlvblN0bXRzLCBwcmV2ZW50RGVmYXVsdFZhcik7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgdmFyaWFibGVzIHRoYXQgYXJlIHNoYXJlZCBieSBtdWx0aXBsZSBjYWxscyB0byBgY29udmVydEFjdGlvbkJpbmRpbmdgIC9cbiAgICogYGNvbnZlcnRQcm9wZXJ0eUJpbmRpbmdgXG4gICAqL1xuICBmdW5jdGlvbiBjcmVhdGVTaGFyZWRCaW5kaW5nVmFyaWFibGVzSWZOZWVkZWQoc3RtdHMpIHtcbiAgICAgIHZhciB1bndyYXBwZXJTdG10cyA9IFtdO1xuICAgICAgdmFyIHJlYWRWYXJzID0gZmluZFJlYWRWYXJOYW1lcyhzdG10cyk7XG4gICAgICBpZiAocmVhZFZhcnMuaGFzKFZBTF9VTldSQVBQRVJfVkFSLm5hbWUpKSB7XG4gICAgICAgICAgdW53cmFwcGVyU3RtdHMucHVzaChWQUxfVU5XUkFQUEVSX1ZBUlxuICAgICAgICAgICAgICAuc2V0KGltcG9ydEV4cHIocmVzb2x2ZUlkZW50aWZpZXIoSWRlbnRpZmllcnMuVmFsdWVVbndyYXBwZXIpKS5pbnN0YW50aWF0ZShbXSkpXG4gICAgICAgICAgICAgIC50b0RlY2xTdG10KG51bGwsIFtTdG10TW9kaWZpZXIuRmluYWxdKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdW53cmFwcGVyU3RtdHM7XG4gIH1cbiAgZnVuY3Rpb24gdGVtcG9yYXJ5TmFtZShiaW5kaW5nSWQsIHRlbXBvcmFyeU51bWJlcikge1xuICAgICAgcmV0dXJuIFwidG1wX1wiICsgYmluZGluZ0lkICsgXCJfXCIgKyB0ZW1wb3JhcnlOdW1iZXI7XG4gIH1cbiAgZnVuY3Rpb24gdGVtcG9yYXJ5RGVjbGFyYXRpb24oYmluZGluZ0lkLCB0ZW1wb3JhcnlOdW1iZXIpIHtcbiAgICAgIHJldHVybiBuZXcgRGVjbGFyZVZhclN0bXQodGVtcG9yYXJ5TmFtZShiaW5kaW5nSWQsIHRlbXBvcmFyeU51bWJlciksIE5VTExfRVhQUik7XG4gIH1cbiAgZnVuY3Rpb24gcHJlcGVuZFRlbXBvcmFyeURlY2xzKHRlbXBvcmFyeUNvdW50LCBiaW5kaW5nSWQsIHN0YXRlbWVudHMpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0ZW1wb3JhcnlDb3VudCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgc3RhdGVtZW50cy51bnNoaWZ0KHRlbXBvcmFyeURlY2xhcmF0aW9uKGJpbmRpbmdJZCwgaSkpO1xuICAgICAgfVxuICB9XG4gIHZhciBfTW9kZTtcbiAgKGZ1bmN0aW9uIChfTW9kZSkge1xuICAgICAgX01vZGVbX01vZGVbXCJTdGF0ZW1lbnRcIl0gPSAwXSA9IFwiU3RhdGVtZW50XCI7XG4gICAgICBfTW9kZVtfTW9kZVtcIkV4cHJlc3Npb25cIl0gPSAxXSA9IFwiRXhwcmVzc2lvblwiO1xuICB9KShfTW9kZSB8fCAoX01vZGUgPSB7fSkpO1xuICBmdW5jdGlvbiBlbnN1cmVTdGF0ZW1lbnRNb2RlKG1vZGUsIGFzdCkge1xuICAgICAgaWYgKG1vZGUgIT09IF9Nb2RlLlN0YXRlbWVudCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIGEgc3RhdGVtZW50LCBidXQgc2F3IFwiICsgYXN0KTtcbiAgICAgIH1cbiAgfVxuICBmdW5jdGlvbiBlbnN1cmVFeHByZXNzaW9uTW9kZShtb2RlLCBhc3QpIHtcbiAgICAgIGlmIChtb2RlICE9PSBfTW9kZS5FeHByZXNzaW9uKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgYW4gZXhwcmVzc2lvbiwgYnV0IHNhdyBcIiArIGFzdCk7XG4gICAgICB9XG4gIH1cbiAgZnVuY3Rpb24gY29udmVydFRvU3RhdGVtZW50SWZOZWVkZWQobW9kZSwgZXhwcikge1xuICAgICAgaWYgKG1vZGUgPT09IF9Nb2RlLlN0YXRlbWVudCkge1xuICAgICAgICAgIHJldHVybiBleHByLnRvU3RtdCgpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgICB9XG4gIH1cbiAgdmFyIF9Bc3RUb0lyVmlzaXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBfQXN0VG9JclZpc2l0b3IoX2J1aWxkZXIsIF9uYW1lUmVzb2x2ZXIsIF9pbXBsaWNpdFJlY2VpdmVyLCBfdmFsdWVVbndyYXBwZXIsIGJpbmRpbmdJZCwgaXNBY3Rpb24pIHtcbiAgICAgICAgICB0aGlzLl9idWlsZGVyID0gX2J1aWxkZXI7XG4gICAgICAgICAgdGhpcy5fbmFtZVJlc29sdmVyID0gX25hbWVSZXNvbHZlcjtcbiAgICAgICAgICB0aGlzLl9pbXBsaWNpdFJlY2VpdmVyID0gX2ltcGxpY2l0UmVjZWl2ZXI7XG4gICAgICAgICAgdGhpcy5fdmFsdWVVbndyYXBwZXIgPSBfdmFsdWVVbndyYXBwZXI7XG4gICAgICAgICAgdGhpcy5iaW5kaW5nSWQgPSBiaW5kaW5nSWQ7XG4gICAgICAgICAgdGhpcy5pc0FjdGlvbiA9IGlzQWN0aW9uO1xuICAgICAgICAgIHRoaXMuX25vZGVNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgdGhpcy5fcmVzdWx0TWFwID0gbmV3IE1hcCgpO1xuICAgICAgICAgIHRoaXMuX2N1cnJlbnRUZW1wb3JhcnkgPSAwO1xuICAgICAgICAgIHRoaXMubmVlZHNWYWx1ZVVud3JhcHBlciA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMudGVtcG9yYXJ5Q291bnQgPSAwO1xuICAgICAgfVxuICAgICAgX0FzdFRvSXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEJpbmFyeSA9IGZ1bmN0aW9uIChhc3QsIG1vZGUpIHtcbiAgICAgICAgICB2YXIgb3A7XG4gICAgICAgICAgc3dpdGNoIChhc3Qub3BlcmF0aW9uKSB7XG4gICAgICAgICAgICAgIGNhc2UgJysnOlxuICAgICAgICAgICAgICAgICAgb3AgPSBCaW5hcnlPcGVyYXRvci5QbHVzO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgJy0nOlxuICAgICAgICAgICAgICAgICAgb3AgPSBCaW5hcnlPcGVyYXRvci5NaW51cztcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlICcqJzpcbiAgICAgICAgICAgICAgICAgIG9wID0gQmluYXJ5T3BlcmF0b3IuTXVsdGlwbHk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAnLyc6XG4gICAgICAgICAgICAgICAgICBvcCA9IEJpbmFyeU9wZXJhdG9yLkRpdmlkZTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlICclJzpcbiAgICAgICAgICAgICAgICAgIG9wID0gQmluYXJ5T3BlcmF0b3IuTW9kdWxvO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgJyYmJzpcbiAgICAgICAgICAgICAgICAgIG9wID0gQmluYXJ5T3BlcmF0b3IuQW5kO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgJ3x8JzpcbiAgICAgICAgICAgICAgICAgIG9wID0gQmluYXJ5T3BlcmF0b3IuT3I7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAnPT0nOlxuICAgICAgICAgICAgICAgICAgb3AgPSBCaW5hcnlPcGVyYXRvci5FcXVhbHM7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAnIT0nOlxuICAgICAgICAgICAgICAgICAgb3AgPSBCaW5hcnlPcGVyYXRvci5Ob3RFcXVhbHM7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAnPT09JzpcbiAgICAgICAgICAgICAgICAgIG9wID0gQmluYXJ5T3BlcmF0b3IuSWRlbnRpY2FsO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgJyE9PSc6XG4gICAgICAgICAgICAgICAgICBvcCA9IEJpbmFyeU9wZXJhdG9yLk5vdElkZW50aWNhbDtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlICc8JzpcbiAgICAgICAgICAgICAgICAgIG9wID0gQmluYXJ5T3BlcmF0b3IuTG93ZXI7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAnPic6XG4gICAgICAgICAgICAgICAgICBvcCA9IEJpbmFyeU9wZXJhdG9yLkJpZ2dlcjtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlICc8PSc6XG4gICAgICAgICAgICAgICAgICBvcCA9IEJpbmFyeU9wZXJhdG9yLkxvd2VyRXF1YWxzO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgJz49JzpcbiAgICAgICAgICAgICAgICAgIG9wID0gQmluYXJ5T3BlcmF0b3IuQmlnZ2VyRXF1YWxzO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBvcGVyYXRpb24gXCIgKyBhc3Qub3BlcmF0aW9uKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGNvbnZlcnRUb1N0YXRlbWVudElmTmVlZGVkKG1vZGUsIG5ldyBCaW5hcnlPcGVyYXRvckV4cHIob3AsIHRoaXMudmlzaXQoYXN0LmxlZnQsIF9Nb2RlLkV4cHJlc3Npb24pLCB0aGlzLnZpc2l0KGFzdC5yaWdodCwgX01vZGUuRXhwcmVzc2lvbikpKTtcbiAgICAgIH07XG4gICAgICBfQXN0VG9JclZpc2l0b3IucHJvdG90eXBlLnZpc2l0Q2hhaW4gPSBmdW5jdGlvbiAoYXN0LCBtb2RlKSB7XG4gICAgICAgICAgZW5zdXJlU3RhdGVtZW50TW9kZShtb2RlLCBhc3QpO1xuICAgICAgICAgIHJldHVybiB0aGlzLnZpc2l0QWxsKGFzdC5leHByZXNzaW9ucywgbW9kZSk7XG4gICAgICB9O1xuICAgICAgX0FzdFRvSXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdENvbmRpdGlvbmFsID0gZnVuY3Rpb24gKGFzdCwgbW9kZSkge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMudmlzaXQoYXN0LmNvbmRpdGlvbiwgX01vZGUuRXhwcmVzc2lvbik7XG4gICAgICAgICAgcmV0dXJuIGNvbnZlcnRUb1N0YXRlbWVudElmTmVlZGVkKG1vZGUsIHZhbHVlLmNvbmRpdGlvbmFsKHRoaXMudmlzaXQoYXN0LnRydWVFeHAsIF9Nb2RlLkV4cHJlc3Npb24pLCB0aGlzLnZpc2l0KGFzdC5mYWxzZUV4cCwgX01vZGUuRXhwcmVzc2lvbikpKTtcbiAgICAgIH07XG4gICAgICBfQXN0VG9JclZpc2l0b3IucHJvdG90eXBlLnZpc2l0UGlwZSA9IGZ1bmN0aW9uIChhc3QsIG1vZGUpIHtcbiAgICAgICAgICB2YXIgaW5wdXQgPSB0aGlzLnZpc2l0KGFzdC5leHAsIF9Nb2RlLkV4cHJlc3Npb24pO1xuICAgICAgICAgIHZhciBhcmdzID0gdGhpcy52aXNpdEFsbChhc3QuYXJncywgX01vZGUuRXhwcmVzc2lvbik7XG4gICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5fbmFtZVJlc29sdmVyLmNhbGxQaXBlKGFzdC5uYW1lLCBpbnB1dCwgYXJncyk7XG4gICAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbGxlZ2FsIHN0YXRlOiBQaXBlIFwiICsgYXN0Lm5hbWUgKyBcIiBpcyBub3QgYWxsb3dlZCBoZXJlIVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5uZWVkc1ZhbHVlVW53cmFwcGVyID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm4gY29udmVydFRvU3RhdGVtZW50SWZOZWVkZWQobW9kZSwgdGhpcy5fdmFsdWVVbndyYXBwZXIuY2FsbE1ldGhvZCgndW53cmFwJywgW3ZhbHVlXSkpO1xuICAgICAgfTtcbiAgICAgIF9Bc3RUb0lyVmlzaXRvci5wcm90b3R5cGUudmlzaXRGdW5jdGlvbkNhbGwgPSBmdW5jdGlvbiAoYXN0LCBtb2RlKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnZlcnRUb1N0YXRlbWVudElmTmVlZGVkKG1vZGUsIHRoaXMudmlzaXQoYXN0LnRhcmdldCwgX01vZGUuRXhwcmVzc2lvbikuY2FsbEZuKHRoaXMudmlzaXRBbGwoYXN0LmFyZ3MsIF9Nb2RlLkV4cHJlc3Npb24pKSk7XG4gICAgICB9O1xuICAgICAgX0FzdFRvSXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEltcGxpY2l0UmVjZWl2ZXIgPSBmdW5jdGlvbiAoYXN0LCBtb2RlKSB7XG4gICAgICAgICAgZW5zdXJlRXhwcmVzc2lvbk1vZGUobW9kZSwgYXN0KTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5faW1wbGljaXRSZWNlaXZlcjtcbiAgICAgIH07XG4gICAgICBfQXN0VG9JclZpc2l0b3IucHJvdG90eXBlLnZpc2l0SW50ZXJwb2xhdGlvbiA9IGZ1bmN0aW9uIChhc3QsIG1vZGUpIHtcbiAgICAgICAgICBlbnN1cmVFeHByZXNzaW9uTW9kZShtb2RlLCBhc3QpO1xuICAgICAgICAgIHZhciBhcmdzID0gW2xpdGVyYWwoYXN0LmV4cHJlc3Npb25zLmxlbmd0aCldO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXN0LnN0cmluZ3MubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICAgIGFyZ3MucHVzaChsaXRlcmFsKGFzdC5zdHJpbmdzW2ldKSk7XG4gICAgICAgICAgICAgIGFyZ3MucHVzaCh0aGlzLnZpc2l0KGFzdC5leHByZXNzaW9uc1tpXSwgX01vZGUuRXhwcmVzc2lvbikpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhcmdzLnB1c2gobGl0ZXJhbChhc3Quc3RyaW5nc1thc3Quc3RyaW5ncy5sZW5ndGggLSAxXSkpO1xuICAgICAgICAgIHJldHVybiBpbXBvcnRFeHByKHJlc29sdmVJZGVudGlmaWVyKElkZW50aWZpZXJzLmludGVycG9sYXRlKSkuY2FsbEZuKGFyZ3MpO1xuICAgICAgfTtcbiAgICAgIF9Bc3RUb0lyVmlzaXRvci5wcm90b3R5cGUudmlzaXRLZXllZFJlYWQgPSBmdW5jdGlvbiAoYXN0LCBtb2RlKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnZlcnRUb1N0YXRlbWVudElmTmVlZGVkKG1vZGUsIHRoaXMudmlzaXQoYXN0Lm9iaiwgX01vZGUuRXhwcmVzc2lvbikua2V5KHRoaXMudmlzaXQoYXN0LmtleSwgX01vZGUuRXhwcmVzc2lvbikpKTtcbiAgICAgIH07XG4gICAgICBfQXN0VG9JclZpc2l0b3IucHJvdG90eXBlLnZpc2l0S2V5ZWRXcml0ZSA9IGZ1bmN0aW9uIChhc3QsIG1vZGUpIHtcbiAgICAgICAgICB2YXIgb2JqID0gdGhpcy52aXNpdChhc3Qub2JqLCBfTW9kZS5FeHByZXNzaW9uKTtcbiAgICAgICAgICB2YXIga2V5ID0gdGhpcy52aXNpdChhc3Qua2V5LCBfTW9kZS5FeHByZXNzaW9uKTtcbiAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLnZpc2l0KGFzdC52YWx1ZSwgX01vZGUuRXhwcmVzc2lvbik7XG4gICAgICAgICAgcmV0dXJuIGNvbnZlcnRUb1N0YXRlbWVudElmTmVlZGVkKG1vZGUsIG9iai5rZXkoa2V5KS5zZXQodmFsdWUpKTtcbiAgICAgIH07XG4gICAgICBfQXN0VG9JclZpc2l0b3IucHJvdG90eXBlLnZpc2l0TGl0ZXJhbEFycmF5ID0gZnVuY3Rpb24gKGFzdCwgbW9kZSkge1xuICAgICAgICAgIHZhciBwYXJ0cyA9IHRoaXMudmlzaXRBbGwoYXN0LmV4cHJlc3Npb25zLCBtb2RlKTtcbiAgICAgICAgICB2YXIgbGl0ZXJhbEFyciQkID0gdGhpcy5pc0FjdGlvbiA/IGxpdGVyYWxBcnIocGFydHMpIDogY3JlYXRlQ2FjaGVkTGl0ZXJhbEFycmF5KHRoaXMuX2J1aWxkZXIsIHBhcnRzKTtcbiAgICAgICAgICByZXR1cm4gY29udmVydFRvU3RhdGVtZW50SWZOZWVkZWQobW9kZSwgbGl0ZXJhbEFyciQkKTtcbiAgICAgIH07XG4gICAgICBfQXN0VG9JclZpc2l0b3IucHJvdG90eXBlLnZpc2l0TGl0ZXJhbE1hcCA9IGZ1bmN0aW9uIChhc3QsIG1vZGUpIHtcbiAgICAgICAgICB2YXIgcGFydHMgPSBbXTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFzdC5rZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIHBhcnRzLnB1c2goW2FzdC5rZXlzW2ldLCB0aGlzLnZpc2l0KGFzdC52YWx1ZXNbaV0sIF9Nb2RlLkV4cHJlc3Npb24pXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBsaXRlcmFsTWFwJCQgPSB0aGlzLmlzQWN0aW9uID8gbGl0ZXJhbE1hcChwYXJ0cykgOiBjcmVhdGVDYWNoZWRMaXRlcmFsTWFwKHRoaXMuX2J1aWxkZXIsIHBhcnRzKTtcbiAgICAgICAgICByZXR1cm4gY29udmVydFRvU3RhdGVtZW50SWZOZWVkZWQobW9kZSwgbGl0ZXJhbE1hcCQkKTtcbiAgICAgIH07XG4gICAgICBfQXN0VG9JclZpc2l0b3IucHJvdG90eXBlLnZpc2l0TGl0ZXJhbFByaW1pdGl2ZSA9IGZ1bmN0aW9uIChhc3QsIG1vZGUpIHtcbiAgICAgICAgICByZXR1cm4gY29udmVydFRvU3RhdGVtZW50SWZOZWVkZWQobW9kZSwgbGl0ZXJhbChhc3QudmFsdWUpKTtcbiAgICAgIH07XG4gICAgICBfQXN0VG9JclZpc2l0b3IucHJvdG90eXBlLl9nZXRMb2NhbCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgaWYgKHRoaXMuaXNBY3Rpb24gJiYgbmFtZSA9PSBFdmVudEhhbmRsZXJWYXJzLmV2ZW50Lm5hbWUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIEV2ZW50SGFuZGxlclZhcnMuZXZlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aGlzLl9uYW1lUmVzb2x2ZXIuZ2V0TG9jYWwobmFtZSk7XG4gICAgICB9O1xuICAgICAgX0FzdFRvSXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdE1ldGhvZENhbGwgPSBmdW5jdGlvbiAoYXN0LCBtb2RlKSB7XG4gICAgICAgICAgdmFyIGxlZnRNb3N0U2FmZSA9IHRoaXMubGVmdE1vc3RTYWZlTm9kZShhc3QpO1xuICAgICAgICAgIGlmIChsZWZ0TW9zdFNhZmUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udmVydFNhZmVBY2Nlc3MoYXN0LCBsZWZ0TW9zdFNhZmUsIG1vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIGFyZ3MgPSB0aGlzLnZpc2l0QWxsKGFzdC5hcmdzLCBfTW9kZS5FeHByZXNzaW9uKTtcbiAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG51bGw7XG4gICAgICAgICAgICAgIHZhciByZWNlaXZlciA9IHRoaXMudmlzaXQoYXN0LnJlY2VpdmVyLCBfTW9kZS5FeHByZXNzaW9uKTtcbiAgICAgICAgICAgICAgaWYgKHJlY2VpdmVyID09PSB0aGlzLl9pbXBsaWNpdFJlY2VpdmVyKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgdmFyRXhwciA9IHRoaXMuX2dldExvY2FsKGFzdC5uYW1lKTtcbiAgICAgICAgICAgICAgICAgIGlmIChpc1ByZXNlbnQodmFyRXhwcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB2YXJFeHByLmNhbGxGbihhcmdzKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoaXNCbGFuayhyZXN1bHQpKSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHQgPSByZWNlaXZlci5jYWxsTWV0aG9kKGFzdC5uYW1lLCBhcmdzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gY29udmVydFRvU3RhdGVtZW50SWZOZWVkZWQobW9kZSwgcmVzdWx0KTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgX0FzdFRvSXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFByZWZpeE5vdCA9IGZ1bmN0aW9uIChhc3QsIG1vZGUpIHtcbiAgICAgICAgICByZXR1cm4gY29udmVydFRvU3RhdGVtZW50SWZOZWVkZWQobW9kZSwgbm90KHRoaXMudmlzaXQoYXN0LmV4cHJlc3Npb24sIF9Nb2RlLkV4cHJlc3Npb24pKSk7XG4gICAgICB9O1xuICAgICAgX0FzdFRvSXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFByb3BlcnR5UmVhZCA9IGZ1bmN0aW9uIChhc3QsIG1vZGUpIHtcbiAgICAgICAgICB2YXIgbGVmdE1vc3RTYWZlID0gdGhpcy5sZWZ0TW9zdFNhZmVOb2RlKGFzdCk7XG4gICAgICAgICAgaWYgKGxlZnRNb3N0U2FmZSkge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb252ZXJ0U2FmZUFjY2Vzcyhhc3QsIGxlZnRNb3N0U2FmZSwgbW9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgICAgICAgdmFyIHJlY2VpdmVyID0gdGhpcy52aXNpdChhc3QucmVjZWl2ZXIsIF9Nb2RlLkV4cHJlc3Npb24pO1xuICAgICAgICAgICAgICBpZiAocmVjZWl2ZXIgPT09IHRoaXMuX2ltcGxpY2l0UmVjZWl2ZXIpIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuX2dldExvY2FsKGFzdC5uYW1lKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoaXNCbGFuayhyZXN1bHQpKSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHQgPSByZWNlaXZlci5wcm9wKGFzdC5uYW1lKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gY29udmVydFRvU3RhdGVtZW50SWZOZWVkZWQobW9kZSwgcmVzdWx0KTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgX0FzdFRvSXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFByb3BlcnR5V3JpdGUgPSBmdW5jdGlvbiAoYXN0LCBtb2RlKSB7XG4gICAgICAgICAgdmFyIHJlY2VpdmVyID0gdGhpcy52aXNpdChhc3QucmVjZWl2ZXIsIF9Nb2RlLkV4cHJlc3Npb24pO1xuICAgICAgICAgIGlmIChyZWNlaXZlciA9PT0gdGhpcy5faW1wbGljaXRSZWNlaXZlcikge1xuICAgICAgICAgICAgICB2YXIgdmFyRXhwciA9IHRoaXMuX2dldExvY2FsKGFzdC5uYW1lKTtcbiAgICAgICAgICAgICAgaWYgKGlzUHJlc2VudCh2YXJFeHByKSkge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgYXNzaWduIHRvIGEgcmVmZXJlbmNlIG9yIHZhcmlhYmxlIScpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBjb252ZXJ0VG9TdGF0ZW1lbnRJZk5lZWRlZChtb2RlLCByZWNlaXZlci5wcm9wKGFzdC5uYW1lKS5zZXQodGhpcy52aXNpdChhc3QudmFsdWUsIF9Nb2RlLkV4cHJlc3Npb24pKSk7XG4gICAgICB9O1xuICAgICAgX0FzdFRvSXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFNhZmVQcm9wZXJ0eVJlYWQgPSBmdW5jdGlvbiAoYXN0LCBtb2RlKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY29udmVydFNhZmVBY2Nlc3MoYXN0LCB0aGlzLmxlZnRNb3N0U2FmZU5vZGUoYXN0KSwgbW9kZSk7XG4gICAgICB9O1xuICAgICAgX0FzdFRvSXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFNhZmVNZXRob2RDYWxsID0gZnVuY3Rpb24gKGFzdCwgbW9kZSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmNvbnZlcnRTYWZlQWNjZXNzKGFzdCwgdGhpcy5sZWZ0TW9zdFNhZmVOb2RlKGFzdCksIG1vZGUpO1xuICAgICAgfTtcbiAgICAgIF9Bc3RUb0lyVmlzaXRvci5wcm90b3R5cGUudmlzaXRBbGwgPSBmdW5jdGlvbiAoYXN0cywgbW9kZSkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgcmV0dXJuIGFzdHMubWFwKGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIF90aGlzLnZpc2l0KGFzdCwgbW9kZSk7IH0pO1xuICAgICAgfTtcbiAgICAgIF9Bc3RUb0lyVmlzaXRvci5wcm90b3R5cGUudmlzaXRRdW90ZSA9IGZ1bmN0aW9uIChhc3QsIG1vZGUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1F1b3RlcyBhcmUgbm90IHN1cHBvcnRlZCBmb3IgZXZhbHVhdGlvbiEnKTtcbiAgICAgIH07XG4gICAgICBfQXN0VG9JclZpc2l0b3IucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKGFzdCwgbW9kZSkge1xuICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLl9yZXN1bHRNYXAuZ2V0KGFzdCk7XG4gICAgICAgICAgaWYgKHJlc3VsdClcbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICByZXR1cm4gKHRoaXMuX25vZGVNYXAuZ2V0KGFzdCkgfHwgYXN0KS52aXNpdCh0aGlzLCBtb2RlKTtcbiAgICAgIH07XG4gICAgICBfQXN0VG9JclZpc2l0b3IucHJvdG90eXBlLmNvbnZlcnRTYWZlQWNjZXNzID0gZnVuY3Rpb24gKGFzdCwgbGVmdE1vc3RTYWZlLCBtb2RlKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGV4cHJlc3Npb24gY29udGFpbnMgYSBzYWZlIGFjY2VzcyBub2RlIG9uIHRoZSBsZWZ0IGl0IG5lZWRzIHRvIGJlIGNvbnZlcnRlZCB0b1xuICAgICAgICAgIC8vIGFuIGV4cHJlc3Npb24gdGhhdCBndWFyZHMgdGhlIGFjY2VzcyB0byB0aGUgbWVtYmVyIGJ5IGNoZWNraW5nIHRoZSByZWNlaXZlciBmb3IgYmxhbmsuIEFzXG4gICAgICAgICAgLy8gZXhlY3V0aW9uIHByb2NlZWRzIGZyb20gbGVmdCB0byByaWdodCwgdGhlIGxlZnQgbW9zdCBwYXJ0IG9mIHRoZSBleHByZXNzaW9uIG11c3QgYmUgZ3VhcmRlZFxuICAgICAgICAgIC8vIGZpcnN0IGJ1dCwgYmVjYXVzZSBtZW1iZXIgYWNjZXNzIGlzIGxlZnQgYXNzb2NpYXRpdmUsIHRoZSByaWdodCBzaWRlIG9mIHRoZSBleHByZXNzaW9uIGlzIGF0XG4gICAgICAgICAgLy8gdGhlIHRvcCBvZiB0aGUgQVNULiBUaGUgZGVzaXJlZCByZXN1bHQgcmVxdWlyZXMgbGlmdGluZyBhIGNvcHkgb2YgdGhlIHRoZSBsZWZ0IHBhcnQgb2YgdGhlXG4gICAgICAgICAgLy8gZXhwcmVzc2lvbiB1cCB0byB0ZXN0IGl0IGZvciBibGFuayBiZWZvcmUgZ2VuZXJhdGluZyB0aGUgdW5ndWFyZGVkIHZlcnNpb24uXG4gICAgICAgICAgLy8gQ29uc2lkZXIsIGZvciBleGFtcGxlIHRoZSBmb2xsb3dpbmcgZXhwcmVzc2lvbjogYT8uYi5jPy5kLmVcbiAgICAgICAgICAvLyBUaGlzIHJlc3VsdHMgaW4gdGhlIGFzdDpcbiAgICAgICAgICAvLyAgICAgICAgIC5cbiAgICAgICAgICAvLyAgICAgICAgLyBcXFxuICAgICAgICAgIC8vICAgICAgID8uICAgZVxuICAgICAgICAgIC8vICAgICAgLyAgXFxcbiAgICAgICAgICAvLyAgICAgLiAgICBkXG4gICAgICAgICAgLy8gICAgLyBcXFxuICAgICAgICAgIC8vICAgPy4gIGNcbiAgICAgICAgICAvLyAgLyAgXFxcbiAgICAgICAgICAvLyBhICAgIGJcbiAgICAgICAgICAvLyBUaGUgZm9sbG93aW5nIHRyZWUgc2hvdWxkIGJlIGdlbmVyYXRlZDpcbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vICAgICAgICAvLS0tLSA/IC0tLS1cXFxuICAgICAgICAgIC8vICAgICAgIC8gICAgICB8ICAgICAgXFxcbiAgICAgICAgICAvLyAgICAgYSAgIC8tLS0gPyAtLS1cXCAgbnVsbFxuICAgICAgICAgIC8vICAgICAgICAvICAgICB8ICAgICBcXFxuICAgICAgICAgIC8vICAgICAgIC4gICAgICAuICAgICBudWxsXG4gICAgICAgICAgLy8gICAgICAvIFxcICAgIC8gXFxcbiAgICAgICAgICAvLyAgICAgLiAgYyAgIC4gICBlXG4gICAgICAgICAgLy8gICAgLyBcXCAgICAvIFxcXG4gICAgICAgICAgLy8gICBhICAgYiAgLCAgIGRcbiAgICAgICAgICAvLyAgICAgICAgIC8gXFxcbiAgICAgICAgICAvLyAgICAgICAgLiAgIGNcbiAgICAgICAgICAvLyAgICAgICAvIFxcXG4gICAgICAgICAgLy8gICAgICBhICAgYlxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gTm90aWNlIHRoYXQgdGhlIGZpcnN0IGd1YXJkIGNvbmRpdGlvbiBpcyB0aGUgbGVmdCBoYW5kIG9mIHRoZSBsZWZ0IG1vc3Qgc2FmZSBhY2Nlc3Mgbm9kZVxuICAgICAgICAgIC8vIHdoaWNoIGNvbWVzIGluIGFzIGxlZnRNb3N0U2FmZSB0byB0aGlzIHJvdXRpbmUuXG4gICAgICAgICAgdmFyIGd1YXJkZWRFeHByZXNzaW9uID0gdGhpcy52aXNpdChsZWZ0TW9zdFNhZmUucmVjZWl2ZXIsIF9Nb2RlLkV4cHJlc3Npb24pO1xuICAgICAgICAgIHZhciB0ZW1wb3Jhcnk7XG4gICAgICAgICAgaWYgKHRoaXMubmVlZHNUZW1wb3JhcnkobGVmdE1vc3RTYWZlLnJlY2VpdmVyKSkge1xuICAgICAgICAgICAgICAvLyBJZiB0aGUgZXhwcmVzc2lvbiBoYXMgbWV0aG9kIGNhbGxzIG9yIHBpcGVzIHRoZW4gd2UgbmVlZCB0byBzYXZlIHRoZSByZXN1bHQgaW50byBhXG4gICAgICAgICAgICAgIC8vIHRlbXBvcmFyeSB2YXJpYWJsZSB0byBhdm9pZCBjYWxsaW5nIHN0YXRlZnVsIG9yIGltcHVyZSBjb2RlIG1vcmUgdGhhbiBvbmNlLlxuICAgICAgICAgICAgICB0ZW1wb3JhcnkgPSB0aGlzLmFsbG9jYXRlVGVtcG9yYXJ5KCk7XG4gICAgICAgICAgICAgIC8vIFByZXNlcnZlIHRoZSByZXN1bHQgaW4gdGhlIHRlbXBvcmFyeSB2YXJpYWJsZVxuICAgICAgICAgICAgICBndWFyZGVkRXhwcmVzc2lvbiA9IHRlbXBvcmFyeS5zZXQoZ3VhcmRlZEV4cHJlc3Npb24pO1xuICAgICAgICAgICAgICAvLyBFbnN1cmUgYWxsIGZ1cnRoZXIgcmVmZXJlbmNlcyB0byB0aGUgZ3VhcmRlZCBleHByZXNzaW9uIHJlZmVyIHRvIHRoZSB0ZW1wb3JhcnkgaW5zdGVhZC5cbiAgICAgICAgICAgICAgdGhpcy5fcmVzdWx0TWFwLnNldChsZWZ0TW9zdFNhZmUucmVjZWl2ZXIsIHRlbXBvcmFyeSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBjb25kaXRpb24gPSBndWFyZGVkRXhwcmVzc2lvbi5pc0JsYW5rKCk7XG4gICAgICAgICAgLy8gQ29udmVydCB0aGUgYXN0IHRvIGFuIHVuZ3VhcmRlZCBhY2Nlc3MgdG8gdGhlIHJlY2VpdmVyJ3MgbWVtYmVyLiBUaGUgbWFwIHdpbGwgc3Vic3RpdHV0ZVxuICAgICAgICAgIC8vIGxlZnRNb3N0Tm9kZSB3aXRoIGl0cyB1bmd1YXJkZWQgdmVyc2lvbiBpbiB0aGUgY2FsbCB0byBgdGhpcy52aXNpdCgpYC5cbiAgICAgICAgICBpZiAobGVmdE1vc3RTYWZlIGluc3RhbmNlb2YgU2FmZU1ldGhvZENhbGwpIHtcbiAgICAgICAgICAgICAgdGhpcy5fbm9kZU1hcC5zZXQobGVmdE1vc3RTYWZlLCBuZXcgTWV0aG9kQ2FsbChsZWZ0TW9zdFNhZmUuc3BhbiwgbGVmdE1vc3RTYWZlLnJlY2VpdmVyLCBsZWZ0TW9zdFNhZmUubmFtZSwgbGVmdE1vc3RTYWZlLmFyZ3MpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuX25vZGVNYXAuc2V0KGxlZnRNb3N0U2FmZSwgbmV3IFByb3BlcnR5UmVhZChsZWZ0TW9zdFNhZmUuc3BhbiwgbGVmdE1vc3RTYWZlLnJlY2VpdmVyLCBsZWZ0TW9zdFNhZmUubmFtZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBSZWN1cnNpdmVseSBjb252ZXJ0IHRoZSBub2RlIG5vdyB3aXRob3V0IHRoZSBndWFyZGVkIG1lbWJlciBhY2Nlc3MuXG4gICAgICAgICAgdmFyIGFjY2VzcyA9IHRoaXMudmlzaXQoYXN0LCBfTW9kZS5FeHByZXNzaW9uKTtcbiAgICAgICAgICAvLyBSZW1vdmUgdGhlIG1hcHBpbmcuIFRoaXMgaXMgbm90IHN0cmljdGx5IHJlcXVpcmVkIGFzIHRoZSBjb252ZXJ0ZXIgb25seSB0cmF2ZXJzZXMgZWFjaCBub2RlXG4gICAgICAgICAgLy8gb25jZSBidXQgaXMgc2FmZXIgaWYgdGhlIGNvbnZlcnNpb24gaXMgY2hhbmdlZCB0byB0cmF2ZXJzZSB0aGUgbm9kZXMgbW9yZSB0aGFuIG9uY2UuXG4gICAgICAgICAgdGhpcy5fbm9kZU1hcC5kZWxldGUobGVmdE1vc3RTYWZlKTtcbiAgICAgICAgICAvLyBJZiB3ZSBhbGxjb2F0ZWQgYSB0ZW1wb3JhcnksIHJlbGVhc2UgaXQuXG4gICAgICAgICAgaWYgKHRlbXBvcmFyeSkge1xuICAgICAgICAgICAgICB0aGlzLnJlbGVhc2VUZW1wb3JhcnkodGVtcG9yYXJ5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gUHJvZHVjZSB0aGUgY29uZGl0aW9uYWxcbiAgICAgICAgICByZXR1cm4gY29udmVydFRvU3RhdGVtZW50SWZOZWVkZWQobW9kZSwgY29uZGl0aW9uLmNvbmRpdGlvbmFsKGxpdGVyYWwobnVsbCksIGFjY2VzcykpO1xuICAgICAgfTtcbiAgICAgIC8vIEdpdmVuIGEgZXhwcmVzc2lvbiBvZiB0aGUgZm9ybSBhPy5iLmM/LmQuZSB0aGUgdGhlIGxlZnQgbW9zdCBzYWZlIG5vZGUgaXNcbiAgICAgIC8vIHRoZSAoYT8uYikuIFRoZSAuIGFuZCA/LiBhcmUgbGVmdCBhc3NvY2lhdGl2ZSB0aHVzIGNhbiBiZSByZXdyaXR0ZW4gYXM6XG4gICAgICAvLyAoKCgoYT8uYykuYikuYyk/LmQpLmUuIFRoaXMgcmV0dXJucyB0aGUgbW9zdCBkZWVwbHkgbmVzdGVkIHNhZmUgcmVhZCBvclxuICAgICAgLy8gc2FmZSBtZXRob2QgY2FsbCBhcyB0aGlzIG5lZWRzIGJlIHRyYW5zZm9ybSBpbml0aWFsbHkgdG86XG4gICAgICAvLyAgIGEgPT0gbnVsbCA/IG51bGwgOiBhLmMuYi5jPy5kLmVcbiAgICAgIC8vIHRoZW4gdG86XG4gICAgICAvLyAgIGEgPT0gbnVsbCA/IG51bGwgOiBhLmIuYyA9PSBudWxsID8gbnVsbCA6IGEuYi5jLmQuZVxuICAgICAgX0FzdFRvSXJWaXNpdG9yLnByb3RvdHlwZS5sZWZ0TW9zdFNhZmVOb2RlID0gZnVuY3Rpb24gKGFzdCkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgdmFyIHZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGFzdCkge1xuICAgICAgICAgICAgICByZXR1cm4gKF90aGlzLl9ub2RlTWFwLmdldChhc3QpIHx8IGFzdCkudmlzaXQodmlzaXRvcik7XG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm4gYXN0LnZpc2l0KHtcbiAgICAgICAgICAgICAgdmlzaXRCaW5hcnk6IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgICAgICAgICAgIHZpc2l0Q2hhaW46IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgICAgICAgICAgIHZpc2l0Q29uZGl0aW9uYWw6IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgICAgICAgICAgIHZpc2l0RnVuY3Rpb25DYWxsOiBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiBudWxsOyB9LFxuICAgICAgICAgICAgICB2aXNpdEltcGxpY2l0UmVjZWl2ZXI6IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgICAgICAgICAgIHZpc2l0SW50ZXJwb2xhdGlvbjogZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gbnVsbDsgfSxcbiAgICAgICAgICAgICAgdmlzaXRLZXllZFJlYWQ6IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIHZpc2l0KHRoaXMsIGFzdC5vYmopOyB9LFxuICAgICAgICAgICAgICB2aXNpdEtleWVkV3JpdGU6IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgICAgICAgICAgIHZpc2l0TGl0ZXJhbEFycmF5OiBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiBudWxsOyB9LFxuICAgICAgICAgICAgICB2aXNpdExpdGVyYWxNYXA6IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgICAgICAgICAgIHZpc2l0TGl0ZXJhbFByaW1pdGl2ZTogZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gbnVsbDsgfSxcbiAgICAgICAgICAgICAgdmlzaXRNZXRob2RDYWxsOiBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiB2aXNpdCh0aGlzLCBhc3QucmVjZWl2ZXIpOyB9LFxuICAgICAgICAgICAgICB2aXNpdFBpcGU6IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgICAgICAgICAgIHZpc2l0UHJlZml4Tm90OiBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiBudWxsOyB9LFxuICAgICAgICAgICAgICB2aXNpdFByb3BlcnR5UmVhZDogZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gdmlzaXQodGhpcywgYXN0LnJlY2VpdmVyKTsgfSxcbiAgICAgICAgICAgICAgdmlzaXRQcm9wZXJ0eVdyaXRlOiBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiBudWxsOyB9LFxuICAgICAgICAgICAgICB2aXNpdFF1b3RlOiBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiBudWxsOyB9LFxuICAgICAgICAgICAgICB2aXNpdFNhZmVNZXRob2RDYWxsOiBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiB2aXNpdCh0aGlzLCBhc3QucmVjZWl2ZXIpIHx8IGFzdDsgfSxcbiAgICAgICAgICAgICAgdmlzaXRTYWZlUHJvcGVydHlSZWFkOiBmdW5jdGlvbiAoYXN0KSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdmlzaXQodGhpcywgYXN0LnJlY2VpdmVyKSB8fCBhc3Q7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICAvLyBSZXR1cm5zIHRydWUgb2YgdGhlIEFTVCBpbmNsdWRlcyBhIG1ldGhvZCBvciBhIHBpcGUgaW5kaWNhdGluZyB0aGF0LCBpZiB0aGVcbiAgICAgIC8vIGV4cHJlc3Npb24gaXMgdXNlZCBhcyB0aGUgdGFyZ2V0IG9mIGEgc2FmZSBwcm9wZXJ0eSBvciBtZXRob2QgYWNjZXNzIHRoZW5cbiAgICAgIC8vIHRoZSBleHByZXNzaW9uIHNob3VsZCBiZSBzdG9yZWQgaW50byBhIHRlbXBvcmFyeSB2YXJpYWJsZS5cbiAgICAgIF9Bc3RUb0lyVmlzaXRvci5wcm90b3R5cGUubmVlZHNUZW1wb3JhcnkgPSBmdW5jdGlvbiAoYXN0KSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICB2YXIgdmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgYXN0KSB7XG4gICAgICAgICAgICAgIHJldHVybiBhc3QgJiYgKF90aGlzLl9ub2RlTWFwLmdldChhc3QpIHx8IGFzdCkudmlzaXQodmlzaXRvcik7XG4gICAgICAgICAgfTtcbiAgICAgICAgICB2YXIgdmlzaXRTb21lID0gZnVuY3Rpb24gKHZpc2l0b3IsIGFzdCkge1xuICAgICAgICAgICAgICByZXR1cm4gYXN0LnNvbWUoZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gdmlzaXQodmlzaXRvciwgYXN0KTsgfSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm4gYXN0LnZpc2l0KHtcbiAgICAgICAgICAgICAgdmlzaXRCaW5hcnk6IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIHZpc2l0KHRoaXMsIGFzdC5sZWZ0KSB8fCB2aXNpdCh0aGlzLCBhc3QucmlnaHQpOyB9LFxuICAgICAgICAgICAgICB2aXNpdENoYWluOiBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiBmYWxzZTsgfSxcbiAgICAgICAgICAgICAgdmlzaXRDb25kaXRpb25hbDogZnVuY3Rpb24gKGFzdCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHZpc2l0KHRoaXMsIGFzdC5jb25kaXRpb24pIHx8IHZpc2l0KHRoaXMsIGFzdC50cnVlRXhwKSB8fFxuICAgICAgICAgICAgICAgICAgICAgIHZpc2l0KHRoaXMsIGFzdC5mYWxzZUV4cCk7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHZpc2l0RnVuY3Rpb25DYWxsOiBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiB0cnVlOyB9LFxuICAgICAgICAgICAgICB2aXNpdEltcGxpY2l0UmVjZWl2ZXI6IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIGZhbHNlOyB9LFxuICAgICAgICAgICAgICB2aXNpdEludGVycG9sYXRpb246IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIHZpc2l0U29tZSh0aGlzLCBhc3QuZXhwcmVzc2lvbnMpOyB9LFxuICAgICAgICAgICAgICB2aXNpdEtleWVkUmVhZDogZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gZmFsc2U7IH0sXG4gICAgICAgICAgICAgIHZpc2l0S2V5ZWRXcml0ZTogZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gZmFsc2U7IH0sXG4gICAgICAgICAgICAgIHZpc2l0TGl0ZXJhbEFycmF5OiBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiB0cnVlOyB9LFxuICAgICAgICAgICAgICB2aXNpdExpdGVyYWxNYXA6IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIHRydWU7IH0sXG4gICAgICAgICAgICAgIHZpc2l0TGl0ZXJhbFByaW1pdGl2ZTogZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gZmFsc2U7IH0sXG4gICAgICAgICAgICAgIHZpc2l0TWV0aG9kQ2FsbDogZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gdHJ1ZTsgfSxcbiAgICAgICAgICAgICAgdmlzaXRQaXBlOiBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiB0cnVlOyB9LFxuICAgICAgICAgICAgICB2aXNpdFByZWZpeE5vdDogZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gdmlzaXQodGhpcywgYXN0LmV4cHJlc3Npb24pOyB9LFxuICAgICAgICAgICAgICB2aXNpdFByb3BlcnR5UmVhZDogZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gZmFsc2U7IH0sXG4gICAgICAgICAgICAgIHZpc2l0UHJvcGVydHlXcml0ZTogZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gZmFsc2U7IH0sXG4gICAgICAgICAgICAgIHZpc2l0UXVvdGU6IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIGZhbHNlOyB9LFxuICAgICAgICAgICAgICB2aXNpdFNhZmVNZXRob2RDYWxsOiBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiB0cnVlOyB9LFxuICAgICAgICAgICAgICB2aXNpdFNhZmVQcm9wZXJ0eVJlYWQ6IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgX0FzdFRvSXJWaXNpdG9yLnByb3RvdHlwZS5hbGxvY2F0ZVRlbXBvcmFyeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgdGVtcE51bWJlciA9IHRoaXMuX2N1cnJlbnRUZW1wb3JhcnkrKztcbiAgICAgICAgICB0aGlzLnRlbXBvcmFyeUNvdW50ID0gTWF0aC5tYXgodGhpcy5fY3VycmVudFRlbXBvcmFyeSwgdGhpcy50ZW1wb3JhcnlDb3VudCk7XG4gICAgICAgICAgcmV0dXJuIG5ldyBSZWFkVmFyRXhwcih0ZW1wb3JhcnlOYW1lKHRoaXMuYmluZGluZ0lkLCB0ZW1wTnVtYmVyKSk7XG4gICAgICB9O1xuICAgICAgX0FzdFRvSXJWaXNpdG9yLnByb3RvdHlwZS5yZWxlYXNlVGVtcG9yYXJ5ID0gZnVuY3Rpb24gKHRlbXBvcmFyeSkge1xuICAgICAgICAgIHRoaXMuX2N1cnJlbnRUZW1wb3JhcnktLTtcbiAgICAgICAgICBpZiAodGVtcG9yYXJ5Lm5hbWUgIT0gdGVtcG9yYXJ5TmFtZSh0aGlzLmJpbmRpbmdJZCwgdGhpcy5fY3VycmVudFRlbXBvcmFyeSkpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGVtcG9yYXJ5IFwiICsgdGVtcG9yYXJ5Lm5hbWUgKyBcIiByZWxlYXNlZCBvdXQgb2Ygb3JkZXJcIik7XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHJldHVybiBfQXN0VG9JclZpc2l0b3I7XG4gIH0oKSk7XG4gIGZ1bmN0aW9uIGZsYXR0ZW5TdGF0ZW1lbnRzKGFyZywgb3V0cHV0KSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShhcmcpKSB7XG4gICAgICAgICAgYXJnLmZvckVhY2goZnVuY3Rpb24gKGVudHJ5KSB7IHJldHVybiBmbGF0dGVuU3RhdGVtZW50cyhlbnRyeSwgb3V0cHV0KTsgfSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgICBvdXRwdXQucHVzaChhcmcpO1xuICAgICAgfVxuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZUNhY2hlZExpdGVyYWxBcnJheShidWlsZGVyLCB2YWx1ZXMpIHtcbiAgICAgIGlmICh2YWx1ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIGltcG9ydEV4cHIocmVzb2x2ZUlkZW50aWZpZXIoSWRlbnRpZmllcnMuRU1QVFlfQVJSQVkpKTtcbiAgICAgIH1cbiAgICAgIHZhciBwcm94eUV4cHIgPSBUSElTX0VYUFIucHJvcChcIl9hcnJfXCIgKyBidWlsZGVyLmZpZWxkcy5sZW5ndGgpO1xuICAgICAgdmFyIHByb3h5UGFyYW1zID0gW107XG4gICAgICB2YXIgcHJveHlSZXR1cm5FbnRyaWVzID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBwYXJhbU5hbWUgPSBcInBcIiArIGk7XG4gICAgICAgICAgcHJveHlQYXJhbXMucHVzaChuZXcgRm5QYXJhbShwYXJhbU5hbWUpKTtcbiAgICAgICAgICBwcm94eVJldHVybkVudHJpZXMucHVzaCh2YXJpYWJsZShwYXJhbU5hbWUpKTtcbiAgICAgIH1cbiAgICAgIGNyZWF0ZVB1cmVQcm94eShmbihwcm94eVBhcmFtcywgW25ldyBSZXR1cm5TdGF0ZW1lbnQobGl0ZXJhbEFycihwcm94eVJldHVybkVudHJpZXMpKV0sIG5ldyBBcnJheVR5cGUoRFlOQU1JQ19UWVBFKSksIHZhbHVlcy5sZW5ndGgsIHByb3h5RXhwciwgYnVpbGRlcik7XG4gICAgICByZXR1cm4gcHJveHlFeHByLmNhbGxGbih2YWx1ZXMpO1xuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZUNhY2hlZExpdGVyYWxNYXAoYnVpbGRlciwgZW50cmllcykge1xuICAgICAgaWYgKGVudHJpZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIGltcG9ydEV4cHIocmVzb2x2ZUlkZW50aWZpZXIoSWRlbnRpZmllcnMuRU1QVFlfTUFQKSk7XG4gICAgICB9XG4gICAgICB2YXIgcHJveHlFeHByID0gVEhJU19FWFBSLnByb3AoXCJfbWFwX1wiICsgYnVpbGRlci5maWVsZHMubGVuZ3RoKTtcbiAgICAgIHZhciBwcm94eVBhcmFtcyA9IFtdO1xuICAgICAgdmFyIHByb3h5UmV0dXJuRW50cmllcyA9IFtdO1xuICAgICAgdmFyIHZhbHVlcyA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbnRyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHBhcmFtTmFtZSA9IFwicFwiICsgaTtcbiAgICAgICAgICBwcm94eVBhcmFtcy5wdXNoKG5ldyBGblBhcmFtKHBhcmFtTmFtZSkpO1xuICAgICAgICAgIHByb3h5UmV0dXJuRW50cmllcy5wdXNoKFtlbnRyaWVzW2ldWzBdLCB2YXJpYWJsZShwYXJhbU5hbWUpXSk7XG4gICAgICAgICAgdmFsdWVzLnB1c2goZW50cmllc1tpXVsxXSk7XG4gICAgICB9XG4gICAgICBjcmVhdGVQdXJlUHJveHkoZm4ocHJveHlQYXJhbXMsIFtuZXcgUmV0dXJuU3RhdGVtZW50KGxpdGVyYWxNYXAocHJveHlSZXR1cm5FbnRyaWVzKSldLCBuZXcgTWFwVHlwZShEWU5BTUlDX1RZUEUpKSwgZW50cmllcy5sZW5ndGgsIHByb3h5RXhwciwgYnVpbGRlcik7XG4gICAgICByZXR1cm4gcHJveHlFeHByLmNhbGxGbih2YWx1ZXMpO1xuICB9XG4gIHZhciBEZWZhdWx0TmFtZVJlc29sdmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIERlZmF1bHROYW1lUmVzb2x2ZXIoKSB7XG4gICAgICB9XG4gICAgICBEZWZhdWx0TmFtZVJlc29sdmVyLnByb3RvdHlwZS5jYWxsUGlwZSA9IGZ1bmN0aW9uIChuYW1lLCBpbnB1dCwgYXJncykgeyByZXR1cm4gbnVsbDsgfTtcbiAgICAgIERlZmF1bHROYW1lUmVzb2x2ZXIucHJvdG90eXBlLmdldExvY2FsID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIG51bGw7IH07XG4gICAgICByZXR1cm4gRGVmYXVsdE5hbWVSZXNvbHZlcjtcbiAgfSgpKTtcbiAgZnVuY3Rpb24gY3JlYXRlQ3VyclZhbHVlRXhwcihiaW5kaW5nSWQpIHtcbiAgICAgIHJldHVybiB2YXJpYWJsZShcImN1cnJWYWxfXCIgKyBiaW5kaW5nSWQpOyAvLyBmaXggc3ludGF4IGhpZ2hsaWdodGluZzogYFxuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZVByZXZlbnREZWZhdWx0VmFyKGJpbmRpbmdJZCkge1xuICAgICAgcmV0dXJuIHZhcmlhYmxlKFwicGRfXCIgKyBiaW5kaW5nSWQpO1xuICB9XG4gIGZ1bmN0aW9uIGNvbnZlcnRTdG10SW50b0V4cHJlc3Npb24oc3RtdCkge1xuICAgICAgaWYgKHN0bXQgaW5zdGFuY2VvZiBFeHByZXNzaW9uU3RhdGVtZW50KSB7XG4gICAgICAgICAgcmV0dXJuIHN0bXQuZXhwcjtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHN0bXQgaW5zdGFuY2VvZiBSZXR1cm5TdGF0ZW1lbnQpIHtcbiAgICAgICAgICByZXR1cm4gc3RtdC52YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gd3JpdGVUb1JlbmRlcmVyKHZpZXcsIGJvdW5kUHJvcCwgcmVuZGVyRWxlbWVudCwgcmVuZGVyVmFsdWUsIGxvZ0JpbmRpbmdVcGRhdGUsIHNlY3VyaXR5Q29udGV4dEV4cHJlc3Npb24pIHtcbiAgICAgIHZhciB1cGRhdGVTdG10cyA9IFtdO1xuICAgICAgdmFyIHJlbmRlcmVyID0gdmlldy5wcm9wKCdyZW5kZXJlcicpO1xuICAgICAgcmVuZGVyVmFsdWUgPSBzYW5pdGl6ZWRWYWx1ZSh2aWV3LCBib3VuZFByb3AsIHJlbmRlclZhbHVlLCBzZWN1cml0eUNvbnRleHRFeHByZXNzaW9uKTtcbiAgICAgIHN3aXRjaCAoYm91bmRQcm9wLnR5cGUpIHtcbiAgICAgICAgICBjYXNlIGV4cG9ydHMuUHJvcGVydHlCaW5kaW5nVHlwZS5Qcm9wZXJ0eTpcbiAgICAgICAgICAgICAgaWYgKGxvZ0JpbmRpbmdVcGRhdGUpIHtcbiAgICAgICAgICAgICAgICAgIHVwZGF0ZVN0bXRzLnB1c2goaW1wb3J0RXhwcihyZXNvbHZlSWRlbnRpZmllcihJZGVudGlmaWVycy5zZXRCaW5kaW5nRGVidWdJbmZvKSlcbiAgICAgICAgICAgICAgICAgICAgICAuY2FsbEZuKFtyZW5kZXJlciwgcmVuZGVyRWxlbWVudCwgbGl0ZXJhbChib3VuZFByb3AubmFtZSksIHJlbmRlclZhbHVlXSlcbiAgICAgICAgICAgICAgICAgICAgICAudG9TdG10KCkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHVwZGF0ZVN0bXRzLnB1c2gocmVuZGVyZXJcbiAgICAgICAgICAgICAgICAgIC5jYWxsTWV0aG9kKCdzZXRFbGVtZW50UHJvcGVydHknLCBbcmVuZGVyRWxlbWVudCwgbGl0ZXJhbChib3VuZFByb3AubmFtZSksIHJlbmRlclZhbHVlXSlcbiAgICAgICAgICAgICAgICAgIC50b1N0bXQoKSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgZXhwb3J0cy5Qcm9wZXJ0eUJpbmRpbmdUeXBlLkF0dHJpYnV0ZTpcbiAgICAgICAgICAgICAgcmVuZGVyVmFsdWUgPVxuICAgICAgICAgICAgICAgICAgcmVuZGVyVmFsdWUuaXNCbGFuaygpLmNvbmRpdGlvbmFsKE5VTExfRVhQUiwgcmVuZGVyVmFsdWUuY2FsbE1ldGhvZCgndG9TdHJpbmcnLCBbXSkpO1xuICAgICAgICAgICAgICB1cGRhdGVTdG10cy5wdXNoKHJlbmRlcmVyXG4gICAgICAgICAgICAgICAgICAuY2FsbE1ldGhvZCgnc2V0RWxlbWVudEF0dHJpYnV0ZScsIFtyZW5kZXJFbGVtZW50LCBsaXRlcmFsKGJvdW5kUHJvcC5uYW1lKSwgcmVuZGVyVmFsdWVdKVxuICAgICAgICAgICAgICAgICAgLnRvU3RtdCgpKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBleHBvcnRzLlByb3BlcnR5QmluZGluZ1R5cGUuQ2xhc3M6XG4gICAgICAgICAgICAgIHVwZGF0ZVN0bXRzLnB1c2gocmVuZGVyZXJcbiAgICAgICAgICAgICAgICAgIC5jYWxsTWV0aG9kKCdzZXRFbGVtZW50Q2xhc3MnLCBbcmVuZGVyRWxlbWVudCwgbGl0ZXJhbChib3VuZFByb3AubmFtZSksIHJlbmRlclZhbHVlXSlcbiAgICAgICAgICAgICAgICAgIC50b1N0bXQoKSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgZXhwb3J0cy5Qcm9wZXJ0eUJpbmRpbmdUeXBlLlN0eWxlOlxuICAgICAgICAgICAgICB2YXIgc3RyVmFsdWUgPSByZW5kZXJWYWx1ZS5jYWxsTWV0aG9kKCd0b1N0cmluZycsIFtdKTtcbiAgICAgICAgICAgICAgaWYgKGlzUHJlc2VudChib3VuZFByb3AudW5pdCkpIHtcbiAgICAgICAgICAgICAgICAgIHN0clZhbHVlID0gc3RyVmFsdWUucGx1cyhsaXRlcmFsKGJvdW5kUHJvcC51bml0KSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVuZGVyVmFsdWUgPSByZW5kZXJWYWx1ZS5pc0JsYW5rKCkuY29uZGl0aW9uYWwoTlVMTF9FWFBSLCBzdHJWYWx1ZSk7XG4gICAgICAgICAgICAgIHVwZGF0ZVN0bXRzLnB1c2gocmVuZGVyZXJcbiAgICAgICAgICAgICAgICAgIC5jYWxsTWV0aG9kKCdzZXRFbGVtZW50U3R5bGUnLCBbcmVuZGVyRWxlbWVudCwgbGl0ZXJhbChib3VuZFByb3AubmFtZSksIHJlbmRlclZhbHVlXSlcbiAgICAgICAgICAgICAgICAgIC50b1N0bXQoKSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgZXhwb3J0cy5Qcm9wZXJ0eUJpbmRpbmdUeXBlLkFuaW1hdGlvbjpcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbGxlZ2FsIHN0YXRlOiBTaG91bGQgbm90IGNvbWUgaGVyZSEnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB1cGRhdGVTdG10cztcbiAgfVxuICBmdW5jdGlvbiBzYW5pdGl6ZWRWYWx1ZSh2aWV3LCBib3VuZFByb3AsIHJlbmRlclZhbHVlLCBzZWN1cml0eUNvbnRleHRFeHByZXNzaW9uKSB7XG4gICAgICBpZiAoYm91bmRQcm9wLnNlY3VyaXR5Q29udGV4dCA9PT0gX2FuZ3VsYXJfY29yZS5TZWN1cml0eUNvbnRleHQuTk9ORSkge1xuICAgICAgICAgIHJldHVybiByZW5kZXJWYWx1ZTsgLy8gTm8gc2FuaXRpemF0aW9uIG5lZWRlZC5cbiAgICAgIH1cbiAgICAgIGlmICghYm91bmRQcm9wLm5lZWRzUnVudGltZVNlY3VyaXR5Q29udGV4dCkge1xuICAgICAgICAgIHNlY3VyaXR5Q29udGV4dEV4cHJlc3Npb24gPVxuICAgICAgICAgICAgICBjcmVhdGVFbnVtRXhwcmVzc2lvbihJZGVudGlmaWVycy5TZWN1cml0eUNvbnRleHQsIGJvdW5kUHJvcC5zZWN1cml0eUNvbnRleHQpO1xuICAgICAgfVxuICAgICAgaWYgKCFzZWN1cml0eUNvbnRleHRFeHByZXNzaW9uKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW50ZXJuYWwgZXJyb3IsIG5vIFNlY3VyaXR5Q29udGV4dCBnaXZlbiBcIiArIGJvdW5kUHJvcC5uYW1lKTtcbiAgICAgIH1cbiAgICAgIHZhciBjdHggPSB2aWV3LnByb3AoJ3ZpZXdVdGlscycpLnByb3AoJ3Nhbml0aXplcicpO1xuICAgICAgdmFyIGFyZ3MgPSBbc2VjdXJpdHlDb250ZXh0RXhwcmVzc2lvbiwgcmVuZGVyVmFsdWVdO1xuICAgICAgcmV0dXJuIGN0eC5jYWxsTWV0aG9kKCdzYW5pdGl6ZScsIGFyZ3MpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBjbGFzcyBzdG10cyBiYXNlZCBvbiB0aGUgZ2l2ZW4gZGF0YS5cbiAgICovXG4gIGZ1bmN0aW9uIGNyZWF0ZUNsYXNzU3RtdChjb25maWcpIHtcbiAgICAgIHZhciBwYXJlbnRBcmdzID0gY29uZmlnLnBhcmVudEFyZ3MgfHwgW107XG4gICAgICB2YXIgc3VwZXJDdG9yU3RtdHMgPSBjb25maWcucGFyZW50ID8gW1NVUEVSX0VYUFIuY2FsbEZuKHBhcmVudEFyZ3MpLnRvU3RtdCgpXSA6IFtdO1xuICAgICAgdmFyIGJ1aWxkZXIgPSBjb25jYXRDbGFzc0J1aWxkZXJQYXJ0cyhBcnJheS5pc0FycmF5KGNvbmZpZy5idWlsZGVycykgPyBjb25maWcuYnVpbGRlcnMgOiBbY29uZmlnLmJ1aWxkZXJzXSk7XG4gICAgICB2YXIgY3RvciA9IG5ldyBDbGFzc01ldGhvZChudWxsLCBjb25maWcuY3RvclBhcmFtcyB8fCBbXSwgc3VwZXJDdG9yU3RtdHMuY29uY2F0KGJ1aWxkZXIuY3RvclN0bXRzKSk7XG4gICAgICByZXR1cm4gbmV3IENsYXNzU3RtdChjb25maWcubmFtZSwgY29uZmlnLnBhcmVudCwgYnVpbGRlci5maWVsZHMsIGJ1aWxkZXIuZ2V0dGVycywgY3RvciwgYnVpbGRlci5tZXRob2RzLCBjb25maWcubW9kaWZpZXJzIHx8IFtdKTtcbiAgfVxuICBmdW5jdGlvbiBjb25jYXRDbGFzc0J1aWxkZXJQYXJ0cyhidWlsZGVycykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBmaWVsZHM6IChfYSA9IFtdKS5jb25jYXQuYXBwbHkoX2EsIGJ1aWxkZXJzLm1hcChmdW5jdGlvbiAoYnVpbGRlcikgeyByZXR1cm4gYnVpbGRlci5maWVsZHMgfHwgW107IH0pKSxcbiAgICAgICAgICBtZXRob2RzOiAoX2IgPSBbXSkuY29uY2F0LmFwcGx5KF9iLCBidWlsZGVycy5tYXAoZnVuY3Rpb24gKGJ1aWxkZXIpIHsgcmV0dXJuIGJ1aWxkZXIubWV0aG9kcyB8fCBbXTsgfSkpLFxuICAgICAgICAgIGdldHRlcnM6IChfYyA9IFtdKS5jb25jYXQuYXBwbHkoX2MsIGJ1aWxkZXJzLm1hcChmdW5jdGlvbiAoYnVpbGRlcikgeyByZXR1cm4gYnVpbGRlci5nZXR0ZXJzIHx8IFtdOyB9KSksXG4gICAgICAgICAgY3RvclN0bXRzOiAoX2QgPSBbXSkuY29uY2F0LmFwcGx5KF9kLCBidWlsZGVycy5tYXAoZnVuY3Rpb24gKGJ1aWxkZXIpIHsgcmV0dXJuIGJ1aWxkZXIuY3RvclN0bXRzIHx8IFtdOyB9KSksXG4gICAgICB9O1xuICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICB9XG5cbiAgdmFyIERpcmVjdGl2ZVdyYXBwZXJDb21waWxlUmVzdWx0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIERpcmVjdGl2ZVdyYXBwZXJDb21waWxlUmVzdWx0KHN0YXRlbWVudHMsIGRpcldyYXBwZXJDbGFzc1Zhcikge1xuICAgICAgICAgIHRoaXMuc3RhdGVtZW50cyA9IHN0YXRlbWVudHM7XG4gICAgICAgICAgdGhpcy5kaXJXcmFwcGVyQ2xhc3NWYXIgPSBkaXJXcmFwcGVyQ2xhc3NWYXI7XG4gICAgICB9XG4gICAgICByZXR1cm4gRGlyZWN0aXZlV3JhcHBlckNvbXBpbGVSZXN1bHQ7XG4gIH0oKSk7XG4gIHZhciBDT05URVhUX0ZJRUxEX05BTUUgPSAnY29udGV4dCc7XG4gIHZhciBDSEFOR0VTX0ZJRUxEX05BTUUgPSAnY2hhbmdlcyc7XG4gIHZhciBDSEFOR0VEX0ZJRUxEX05BTUUgPSAnY2hhbmdlZCc7XG4gIHZhciBDVVJSX1ZBTFVFX1ZBUiA9IHZhcmlhYmxlKCdjdXJyVmFsdWUnKTtcbiAgdmFyIFRIUk9XX09OX0NIQU5HRV9WQVIgPSB2YXJpYWJsZSgndGhyb3dPbkNoYW5nZScpO1xuICB2YXIgRk9SQ0VfVVBEQVRFX1ZBUiA9IHZhcmlhYmxlKCdmb3JjZVVwZGF0ZScpO1xuICB2YXIgVklFV19WQVIgPSB2YXJpYWJsZSgndmlldycpO1xuICB2YXIgUkVOREVSX0VMX1ZBUiA9IHZhcmlhYmxlKCdlbCcpO1xuICB2YXIgUkVTRVRfQ0hBTkdFU19TVE1UID0gVEhJU19FWFBSLnByb3AoQ0hBTkdFU19GSUVMRF9OQU1FKS5zZXQobGl0ZXJhbE1hcChbXSkpLnRvU3RtdCgpO1xuICAvKipcbiAgICogV2UgZ2VuZXJhdGUgZGlyZWN0aXZlIHdyYXBwZXJzIHRvIHByZXZlbnQgY29kZSBibG9hdCB3aGVuIGEgZGlyZWN0aXZlIGlzIHVzZWQuXG4gICAqIEEgZGlyZWN0aXZlIHdyYXBwZXIgZW5jYXBzdWxhdGVzXG4gICAqIHRoZSBkaXJ0eSBjaGVja2luZyBmb3IgYEBJbnB1dGAsIHRoZSBoYW5kbGluZyBvZiBgQEhvc3RMaXN0ZW5lcmAgLyBgQEhvc3RCaW5kaW5nYFxuICAgKiBhbmQgY2FsbGluZyB0aGUgbGlmZWN5Y2xlaG9va3MgYG5nT25Jbml0YCwgYG5nT25DaGFuZ2VzYCwgYG5nRG9DaGVja2AuXG4gICAqXG4gICAqIFNvIGZhciwgb25seSBgQElucHV0YCBhbmQgdGhlIGxpZmVjeWNsZSBob29rcyBoYXZlIGJlZW4gaW1wbGVtZW50ZWQuXG4gICAqL1xuICB2YXIgRGlyZWN0aXZlV3JhcHBlckNvbXBpbGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIERpcmVjdGl2ZVdyYXBwZXJDb21waWxlcihjb21waWxlckNvbmZpZywgX2V4cHJQYXJzZXIsIF9zY2hlbWFSZWdpc3RyeSwgX2NvbnNvbGUpIHtcbiAgICAgICAgICB0aGlzLmNvbXBpbGVyQ29uZmlnID0gY29tcGlsZXJDb25maWc7XG4gICAgICAgICAgdGhpcy5fZXhwclBhcnNlciA9IF9leHByUGFyc2VyO1xuICAgICAgICAgIHRoaXMuX3NjaGVtYVJlZ2lzdHJ5ID0gX3NjaGVtYVJlZ2lzdHJ5O1xuICAgICAgICAgIHRoaXMuX2NvbnNvbGUgPSBfY29uc29sZTtcbiAgICAgIH1cbiAgICAgIERpcmVjdGl2ZVdyYXBwZXJDb21waWxlci5kaXJXcmFwcGVyQ2xhc3NOYW1lID0gZnVuY3Rpb24gKGlkKSB7IHJldHVybiBcIldyYXBwZXJfXCIgKyBpZC5uYW1lOyB9O1xuICAgICAgRGlyZWN0aXZlV3JhcHBlckNvbXBpbGVyLnByb3RvdHlwZS5jb21waWxlID0gZnVuY3Rpb24gKGRpck1ldGEpIHtcbiAgICAgICAgICB2YXIgYnVpbGRlciA9IG5ldyBEaXJlY3RpdmVXcmFwcGVyQnVpbGRlcih0aGlzLmNvbXBpbGVyQ29uZmlnLCBkaXJNZXRhKTtcbiAgICAgICAgICBPYmplY3Qua2V5cyhkaXJNZXRhLmlucHV0cykuZm9yRWFjaChmdW5jdGlvbiAoaW5wdXRGaWVsZE5hbWUpIHtcbiAgICAgICAgICAgICAgYWRkQ2hlY2tJbnB1dE1ldGhvZChpbnB1dEZpZWxkTmFtZSwgYnVpbGRlcik7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYWRkRGV0ZWN0Q2hhbmdlc0luSW5wdXRQcm9wc01ldGhvZChidWlsZGVyKTtcbiAgICAgICAgICB2YXIgaG9zdFBhcnNlUmVzdWx0ID0gcGFyc2VIb3N0QmluZGluZ3MoZGlyTWV0YSwgdGhpcy5fZXhwclBhcnNlciwgdGhpcy5fc2NoZW1hUmVnaXN0cnkpO1xuICAgICAgICAgIHJlcG9ydFBhcnNlRXJyb3JzKGhvc3RQYXJzZVJlc3VsdC5lcnJvcnMsIHRoaXMuX2NvbnNvbGUpO1xuICAgICAgICAgIC8vIGhvc3QgcHJvcGVydGllcyBhcmUgY2hhbmdlIGRldGVjdGVkIGJ5IHRoZSBEaXJlY3RpdmVXcmFwcGVycyxcbiAgICAgICAgICAvLyBleGNlcHQgZm9yIHRoZSBhbmltYXRpb24gcHJvcGVydGllcyBhcyB0aGV5IG5lZWQgY2xvc2UgaW50ZWdyYXRpb24gd2l0aCBhbmltYXRpb24gZXZlbnRzXG4gICAgICAgICAgLy8gYW5kIERpcmVjdGl2ZVdyYXBwZXJzIGRvbid0IHN1cHBvcnRcbiAgICAgICAgICAvLyBldmVudCBsaXN0ZW5lcnMgcmlnaHQgbm93LlxuICAgICAgICAgIGFkZERldGVjdENoYW5nZXNJbkhvc3RQcm9wc01ldGhvZChob3N0UGFyc2VSZXN1bHQuaG9zdFByb3BzLmZpbHRlcihmdW5jdGlvbiAoaG9zdFByb3ApIHsgcmV0dXJuICFob3N0UHJvcC5pc0FuaW1hdGlvbjsgfSksIGJ1aWxkZXIpO1xuICAgICAgICAgIC8vIFRPRE8odGJvc2NoKTogaW1wbGVtZW50IGhvc3RMaXN0ZW5lcnMgdmlhIERpcmVjdGl2ZVdyYXBwZXIgYXMgd2VsbCFcbiAgICAgICAgICB2YXIgY2xhc3NTdG10ID0gYnVpbGRlci5idWlsZCgpO1xuICAgICAgICAgIHJldHVybiBuZXcgRGlyZWN0aXZlV3JhcHBlckNvbXBpbGVSZXN1bHQoW2NsYXNzU3RtdF0sIGNsYXNzU3RtdC5uYW1lKTtcbiAgICAgIH07XG4gICAgICBEaXJlY3RpdmVXcmFwcGVyQ29tcGlsZXIuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0YWJsZSB9LFxuICAgICAgXTtcbiAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgRGlyZWN0aXZlV3JhcHBlckNvbXBpbGVyLmN0b3JQYXJhbWV0ZXJzID0gW1xuICAgICAgICAgIHsgdHlwZTogQ29tcGlsZXJDb25maWcsIH0sXG4gICAgICAgICAgeyB0eXBlOiBQYXJzZXIsIH0sXG4gICAgICAgICAgeyB0eXBlOiBFbGVtZW50U2NoZW1hUmVnaXN0cnksIH0sXG4gICAgICAgICAgeyB0eXBlOiBDb25zb2xlLCB9LFxuICAgICAgXTtcbiAgICAgIHJldHVybiBEaXJlY3RpdmVXcmFwcGVyQ29tcGlsZXI7XG4gIH0oKSk7XG4gIHZhciBEaXJlY3RpdmVXcmFwcGVyQnVpbGRlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBEaXJlY3RpdmVXcmFwcGVyQnVpbGRlcihjb21waWxlckNvbmZpZywgZGlyTWV0YSkge1xuICAgICAgICAgIHRoaXMuY29tcGlsZXJDb25maWcgPSBjb21waWxlckNvbmZpZztcbiAgICAgICAgICB0aGlzLmRpck1ldGEgPSBkaXJNZXRhO1xuICAgICAgICAgIHRoaXMuZmllbGRzID0gW107XG4gICAgICAgICAgdGhpcy5nZXR0ZXJzID0gW107XG4gICAgICAgICAgdGhpcy5tZXRob2RzID0gW107XG4gICAgICAgICAgdGhpcy5jdG9yU3RtdHMgPSBbXTtcbiAgICAgICAgICB2YXIgZGlyTGlmZWN5Y2xlSG9va3MgPSBkaXJNZXRhLnR5cGUubGlmZWN5Y2xlSG9va3M7XG4gICAgICAgICAgdGhpcy5nZW5DaGFuZ2VzID0gZGlyTGlmZWN5Y2xlSG9va3MuaW5kZXhPZihMaWZlY3ljbGVIb29rcy5PbkNoYW5nZXMpICE9PSAtMSB8fFxuICAgICAgICAgICAgICB0aGlzLmNvbXBpbGVyQ29uZmlnLmxvZ0JpbmRpbmdVcGRhdGU7XG4gICAgICAgICAgdGhpcy5uZ09uQ2hhbmdlcyA9IGRpckxpZmVjeWNsZUhvb2tzLmluZGV4T2YoTGlmZWN5Y2xlSG9va3MuT25DaGFuZ2VzKSAhPT0gLTE7XG4gICAgICAgICAgdGhpcy5uZ09uSW5pdCA9IGRpckxpZmVjeWNsZUhvb2tzLmluZGV4T2YoTGlmZWN5Y2xlSG9va3MuT25Jbml0KSAhPT0gLTE7XG4gICAgICAgICAgdGhpcy5uZ0RvQ2hlY2sgPSBkaXJMaWZlY3ljbGVIb29rcy5pbmRleE9mKExpZmVjeWNsZUhvb2tzLkRvQ2hlY2spICE9PSAtMTtcbiAgICAgIH1cbiAgICAgIERpcmVjdGl2ZVdyYXBwZXJCdWlsZGVyLnByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgZGlyRGVwUGFyYW1OYW1lcyA9IFtdO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5kaXJNZXRhLnR5cGUuZGlEZXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIGRpckRlcFBhcmFtTmFtZXMucHVzaChcInBcIiArIGkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgZmllbGRzID0gW1xuICAgICAgICAgICAgICBuZXcgQ2xhc3NGaWVsZChDT05URVhUX0ZJRUxEX05BTUUsIGltcG9ydFR5cGUodGhpcy5kaXJNZXRhLnR5cGUpKSxcbiAgICAgICAgICAgICAgbmV3IENsYXNzRmllbGQoQ0hBTkdFRF9GSUVMRF9OQU1FLCBCT09MX1RZUEUpLFxuICAgICAgICAgIF07XG4gICAgICAgICAgdmFyIGN0b3JTdG10cyA9IFtUSElTX0VYUFIucHJvcChDSEFOR0VEX0ZJRUxEX05BTUUpLnNldChsaXRlcmFsKGZhbHNlKSkudG9TdG10KCldO1xuICAgICAgICAgIGlmICh0aGlzLmdlbkNoYW5nZXMpIHtcbiAgICAgICAgICAgICAgZmllbGRzLnB1c2gobmV3IENsYXNzRmllbGQoQ0hBTkdFU19GSUVMRF9OQU1FLCBuZXcgTWFwVHlwZShEWU5BTUlDX1RZUEUpKSk7XG4gICAgICAgICAgICAgIGN0b3JTdG10cy5wdXNoKFJFU0VUX0NIQU5HRVNfU1RNVCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGN0b3JTdG10cy5wdXNoKFRISVNfRVhQUi5wcm9wKENPTlRFWFRfRklFTERfTkFNRSlcbiAgICAgICAgICAgICAgLnNldChpbXBvcnRFeHByKHRoaXMuZGlyTWV0YS50eXBlKVxuICAgICAgICAgICAgICAuaW5zdGFudGlhdGUoZGlyRGVwUGFyYW1OYW1lcy5tYXAoZnVuY3Rpb24gKHBhcmFtTmFtZSkgeyByZXR1cm4gdmFyaWFibGUocGFyYW1OYW1lKTsgfSkpKVxuICAgICAgICAgICAgICAudG9TdG10KCkpO1xuICAgICAgICAgIHJldHVybiBjcmVhdGVDbGFzc1N0bXQoe1xuICAgICAgICAgICAgICBuYW1lOiBEaXJlY3RpdmVXcmFwcGVyQ29tcGlsZXIuZGlyV3JhcHBlckNsYXNzTmFtZSh0aGlzLmRpck1ldGEudHlwZSksXG4gICAgICAgICAgICAgIGN0b3JQYXJhbXM6IGRpckRlcFBhcmFtTmFtZXMubWFwKGZ1bmN0aW9uIChwYXJhbU5hbWUpIHsgcmV0dXJuIG5ldyBGblBhcmFtKHBhcmFtTmFtZSwgRFlOQU1JQ19UWVBFKTsgfSksXG4gICAgICAgICAgICAgIGJ1aWxkZXJzOiBbeyBmaWVsZHM6IGZpZWxkcywgY3RvclN0bXRzOiBjdG9yU3RtdHMgfSwgdGhpc11cbiAgICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gRGlyZWN0aXZlV3JhcHBlckJ1aWxkZXI7XG4gIH0oKSk7XG4gIGZ1bmN0aW9uIGFkZERldGVjdENoYW5nZXNJbklucHV0UHJvcHNNZXRob2QoYnVpbGRlcikge1xuICAgICAgdmFyIGNoYW5nZWRWYXIgPSB2YXJpYWJsZSgnY2hhbmdlZCcpO1xuICAgICAgdmFyIHN0bXRzID0gW1xuICAgICAgICAgIGNoYW5nZWRWYXIuc2V0KFRISVNfRVhQUi5wcm9wKENIQU5HRURfRklFTERfTkFNRSkpLnRvRGVjbFN0bXQoKSxcbiAgICAgICAgICBUSElTX0VYUFIucHJvcChDSEFOR0VEX0ZJRUxEX05BTUUpLnNldChsaXRlcmFsKGZhbHNlKSkudG9TdG10KCksXG4gICAgICBdO1xuICAgICAgdmFyIGxpZmVjeWNsZVN0bXRzID0gW107XG4gICAgICBpZiAoYnVpbGRlci5nZW5DaGFuZ2VzKSB7XG4gICAgICAgICAgdmFyIG9uQ2hhbmdlc1N0bXRzID0gW107XG4gICAgICAgICAgaWYgKGJ1aWxkZXIubmdPbkNoYW5nZXMpIHtcbiAgICAgICAgICAgICAgb25DaGFuZ2VzU3RtdHMucHVzaChUSElTX0VYUFIucHJvcChDT05URVhUX0ZJRUxEX05BTUUpXG4gICAgICAgICAgICAgICAgICAuY2FsbE1ldGhvZCgnbmdPbkNoYW5nZXMnLCBbVEhJU19FWFBSLnByb3AoQ0hBTkdFU19GSUVMRF9OQU1FKV0pXG4gICAgICAgICAgICAgICAgICAudG9TdG10KCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYnVpbGRlci5jb21waWxlckNvbmZpZy5sb2dCaW5kaW5nVXBkYXRlKSB7XG4gICAgICAgICAgICAgIG9uQ2hhbmdlc1N0bXRzLnB1c2goaW1wb3J0RXhwcihyZXNvbHZlSWRlbnRpZmllcihJZGVudGlmaWVycy5zZXRCaW5kaW5nRGVidWdJbmZvRm9yQ2hhbmdlcykpXG4gICAgICAgICAgICAgICAgICAuY2FsbEZuKFtWSUVXX1ZBUi5wcm9wKCdyZW5kZXJlcicpLCBSRU5ERVJfRUxfVkFSLCBUSElTX0VYUFIucHJvcChDSEFOR0VTX0ZJRUxEX05BTUUpXSlcbiAgICAgICAgICAgICAgICAgIC50b1N0bXQoKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG9uQ2hhbmdlc1N0bXRzLnB1c2goUkVTRVRfQ0hBTkdFU19TVE1UKTtcbiAgICAgICAgICBsaWZlY3ljbGVTdG10cy5wdXNoKG5ldyBJZlN0bXQoY2hhbmdlZFZhciwgb25DaGFuZ2VzU3RtdHMpKTtcbiAgICAgIH1cbiAgICAgIGlmIChidWlsZGVyLm5nT25Jbml0KSB7XG4gICAgICAgICAgbGlmZWN5Y2xlU3RtdHMucHVzaChuZXcgSWZTdG10KFZJRVdfVkFSLnByb3AoJ251bWJlck9mQ2hlY2tzJykuaWRlbnRpY2FsKG5ldyBMaXRlcmFsRXhwcigwKSksIFtUSElTX0VYUFIucHJvcChDT05URVhUX0ZJRUxEX05BTUUpLmNhbGxNZXRob2QoJ25nT25Jbml0JywgW10pLnRvU3RtdCgpXSkpO1xuICAgICAgfVxuICAgICAgaWYgKGJ1aWxkZXIubmdEb0NoZWNrKSB7XG4gICAgICAgICAgbGlmZWN5Y2xlU3RtdHMucHVzaChUSElTX0VYUFIucHJvcChDT05URVhUX0ZJRUxEX05BTUUpLmNhbGxNZXRob2QoJ25nRG9DaGVjaycsIFtdKS50b1N0bXQoKSk7XG4gICAgICB9XG4gICAgICBpZiAobGlmZWN5Y2xlU3RtdHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHN0bXRzLnB1c2gobmV3IElmU3RtdChub3QoVEhST1dfT05fQ0hBTkdFX1ZBUiksIGxpZmVjeWNsZVN0bXRzKSk7XG4gICAgICB9XG4gICAgICBzdG10cy5wdXNoKG5ldyBSZXR1cm5TdGF0ZW1lbnQoY2hhbmdlZFZhcikpO1xuICAgICAgYnVpbGRlci5tZXRob2RzLnB1c2gobmV3IENsYXNzTWV0aG9kKCdkZXRlY3RDaGFuZ2VzSW5JbnB1dFByb3BzJywgW1xuICAgICAgICAgIG5ldyBGblBhcmFtKFZJRVdfVkFSLm5hbWUsIGltcG9ydFR5cGUocmVzb2x2ZUlkZW50aWZpZXIoSWRlbnRpZmllcnMuQXBwVmlldyksIFtEWU5BTUlDX1RZUEVdKSksXG4gICAgICAgICAgbmV3IEZuUGFyYW0oUkVOREVSX0VMX1ZBUi5uYW1lLCBEWU5BTUlDX1RZUEUpLFxuICAgICAgICAgIG5ldyBGblBhcmFtKFRIUk9XX09OX0NIQU5HRV9WQVIubmFtZSwgQk9PTF9UWVBFKSxcbiAgICAgIF0sIHN0bXRzLCBCT09MX1RZUEUpKTtcbiAgfVxuICBmdW5jdGlvbiBhZGRDaGVja0lucHV0TWV0aG9kKGlucHV0LCBidWlsZGVyKSB7XG4gICAgICB2YXIgZmllbGQgPSBjcmVhdGVDaGVja0JpbmRpbmdGaWVsZChidWlsZGVyKTtcbiAgICAgIHZhciBvbkNoYW5nZVN0YXRlbWVudHMgPSBbXG4gICAgICAgICAgVEhJU19FWFBSLnByb3AoQ0hBTkdFRF9GSUVMRF9OQU1FKS5zZXQobGl0ZXJhbCh0cnVlKSkudG9TdG10KCksXG4gICAgICAgICAgVEhJU19FWFBSLnByb3AoQ09OVEVYVF9GSUVMRF9OQU1FKS5wcm9wKGlucHV0KS5zZXQoQ1VSUl9WQUxVRV9WQVIpLnRvU3RtdCgpLFxuICAgICAgXTtcbiAgICAgIGlmIChidWlsZGVyLmdlbkNoYW5nZXMpIHtcbiAgICAgICAgICBvbkNoYW5nZVN0YXRlbWVudHMucHVzaChUSElTX0VYUFIucHJvcChDSEFOR0VTX0ZJRUxEX05BTUUpXG4gICAgICAgICAgICAgIC5rZXkobGl0ZXJhbChpbnB1dCkpXG4gICAgICAgICAgICAgIC5zZXQoaW1wb3J0RXhwcihyZXNvbHZlSWRlbnRpZmllcihJZGVudGlmaWVycy5TaW1wbGVDaGFuZ2UpKVxuICAgICAgICAgICAgICAuaW5zdGFudGlhdGUoW2ZpZWxkLmV4cHJlc3Npb24sIENVUlJfVkFMVUVfVkFSXSkpXG4gICAgICAgICAgICAgIC50b1N0bXQoKSk7XG4gICAgICB9XG4gICAgICB2YXIgbWV0aG9kQm9keSA9IGNyZWF0ZUNoZWNrQmluZGluZ1N0bXQoeyBjdXJyVmFsRXhwcjogQ1VSUl9WQUxVRV9WQVIsIGZvcmNlVXBkYXRlOiBGT1JDRV9VUERBVEVfVkFSLCBzdG10czogW10gfSwgZmllbGQuZXhwcmVzc2lvbiwgVEhST1dfT05fQ0hBTkdFX1ZBUiwgb25DaGFuZ2VTdGF0ZW1lbnRzKTtcbiAgICAgIGJ1aWxkZXIubWV0aG9kcy5wdXNoKG5ldyBDbGFzc01ldGhvZChcImNoZWNrX1wiICsgaW5wdXQsIFtcbiAgICAgICAgICBuZXcgRm5QYXJhbShDVVJSX1ZBTFVFX1ZBUi5uYW1lLCBEWU5BTUlDX1RZUEUpLFxuICAgICAgICAgIG5ldyBGblBhcmFtKFRIUk9XX09OX0NIQU5HRV9WQVIubmFtZSwgQk9PTF9UWVBFKSxcbiAgICAgICAgICBuZXcgRm5QYXJhbShGT1JDRV9VUERBVEVfVkFSLm5hbWUsIEJPT0xfVFlQRSksXG4gICAgICBdLCBtZXRob2RCb2R5KSk7XG4gIH1cbiAgZnVuY3Rpb24gYWRkRGV0ZWN0Q2hhbmdlc0luSG9zdFByb3BzTWV0aG9kKGhvc3RQcm9wcywgYnVpbGRlcikge1xuICAgICAgdmFyIHN0bXRzID0gW107XG4gICAgICB2YXIgbWV0aG9kUGFyYW1zID0gW1xuICAgICAgICAgIG5ldyBGblBhcmFtKFZJRVdfVkFSLm5hbWUsIGltcG9ydFR5cGUocmVzb2x2ZUlkZW50aWZpZXIoSWRlbnRpZmllcnMuQXBwVmlldyksIFtEWU5BTUlDX1RZUEVdKSksXG4gICAgICAgICAgbmV3IEZuUGFyYW0oUkVOREVSX0VMX1ZBUi5uYW1lLCBEWU5BTUlDX1RZUEUpLFxuICAgICAgICAgIG5ldyBGblBhcmFtKFRIUk9XX09OX0NIQU5HRV9WQVIubmFtZSwgQk9PTF9UWVBFKSxcbiAgICAgIF07XG4gICAgICBob3N0UHJvcHMuZm9yRWFjaChmdW5jdGlvbiAoaG9zdFByb3ApIHtcbiAgICAgICAgICB2YXIgZmllbGQgPSBjcmVhdGVDaGVja0JpbmRpbmdGaWVsZChidWlsZGVyKTtcbiAgICAgICAgICB2YXIgZXZhbFJlc3VsdCA9IGNvbnZlcnRQcm9wZXJ0eUJpbmRpbmcoYnVpbGRlciwgbnVsbCwgVEhJU19FWFBSLnByb3AoQ09OVEVYVF9GSUVMRF9OQU1FKSwgaG9zdFByb3AudmFsdWUsIGZpZWxkLmJpbmRpbmdJZCk7XG4gICAgICAgICAgaWYgKCFldmFsUmVzdWx0KSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHNlY3VyaXR5Q29udGV4dEV4cHI7XG4gICAgICAgICAgaWYgKGhvc3RQcm9wLm5lZWRzUnVudGltZVNlY3VyaXR5Q29udGV4dCkge1xuICAgICAgICAgICAgICBzZWN1cml0eUNvbnRleHRFeHByID0gdmFyaWFibGUoXCJzZWNDdHhfXCIgKyBtZXRob2RQYXJhbXMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgbWV0aG9kUGFyYW1zLnB1c2gobmV3IEZuUGFyYW0oc2VjdXJpdHlDb250ZXh0RXhwci5uYW1lLCBpbXBvcnRUeXBlKHJlc29sdmVJZGVudGlmaWVyKElkZW50aWZpZXJzLlNlY3VyaXR5Q29udGV4dCkpKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0bXRzLnB1c2guYXBwbHkoc3RtdHMsIGNyZWF0ZUNoZWNrQmluZGluZ1N0bXQoZXZhbFJlc3VsdCwgZmllbGQuZXhwcmVzc2lvbiwgVEhST1dfT05fQ0hBTkdFX1ZBUiwgd3JpdGVUb1JlbmRlcmVyKFZJRVdfVkFSLCBob3N0UHJvcCwgUkVOREVSX0VMX1ZBUiwgZXZhbFJlc3VsdC5jdXJyVmFsRXhwciwgYnVpbGRlci5jb21waWxlckNvbmZpZy5sb2dCaW5kaW5nVXBkYXRlLCBzZWN1cml0eUNvbnRleHRFeHByKSkpO1xuICAgICAgfSk7XG4gICAgICBidWlsZGVyLm1ldGhvZHMucHVzaChuZXcgQ2xhc3NNZXRob2QoJ2RldGVjdENoYW5nZXNJbkhvc3RQcm9wcycsIG1ldGhvZFBhcmFtcywgc3RtdHMpKTtcbiAgfVxuICB2YXIgUGFyc2VSZXN1bHQgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gUGFyc2VSZXN1bHQoaG9zdFByb3BzLCBob3N0TGlzdGVuZXJzLCBlcnJvcnMpIHtcbiAgICAgICAgICB0aGlzLmhvc3RQcm9wcyA9IGhvc3RQcm9wcztcbiAgICAgICAgICB0aGlzLmhvc3RMaXN0ZW5lcnMgPSBob3N0TGlzdGVuZXJzO1xuICAgICAgICAgIHRoaXMuZXJyb3JzID0gZXJyb3JzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFBhcnNlUmVzdWx0O1xuICB9KCkpO1xuICBmdW5jdGlvbiBwYXJzZUhvc3RCaW5kaW5ncyhkaXJNZXRhLCBleHByUGFyc2VyLCBzY2hlbWFSZWdpc3RyeSkge1xuICAgICAgdmFyIGVycm9ycyA9IFtdO1xuICAgICAgdmFyIHBhcnNlciA9IG5ldyBCaW5kaW5nUGFyc2VyKGV4cHJQYXJzZXIsIERFRkFVTFRfSU5URVJQT0xBVElPTl9DT05GSUcsIHNjaGVtYVJlZ2lzdHJ5LCBbXSwgZXJyb3JzKTtcbiAgICAgIHZhciBzb3VyY2VGaWxlTmFtZSA9IGRpck1ldGEudHlwZS5tb2R1bGVVcmwgP1xuICAgICAgICAgIFwiaW4gRGlyZWN0aXZlIFwiICsgZGlyTWV0YS50eXBlLm5hbWUgKyBcIiBpbiBcIiArIGRpck1ldGEudHlwZS5tb2R1bGVVcmwgOlxuICAgICAgICAgIFwiaW4gRGlyZWN0aXZlIFwiICsgZGlyTWV0YS50eXBlLm5hbWU7XG4gICAgICB2YXIgc291cmNlRmlsZSA9IG5ldyBQYXJzZVNvdXJjZUZpbGUoJycsIHNvdXJjZUZpbGVOYW1lKTtcbiAgICAgIHZhciBzb3VyY2VTcGFuID0gbmV3IFBhcnNlU291cmNlU3BhbihuZXcgUGFyc2VMb2NhdGlvbihzb3VyY2VGaWxlLCBudWxsLCBudWxsLCBudWxsKSwgbmV3IFBhcnNlTG9jYXRpb24oc291cmNlRmlsZSwgbnVsbCwgbnVsbCwgbnVsbCkpO1xuICAgICAgdmFyIHBhcnNlZEhvc3RQcm9wcyA9IHBhcnNlci5jcmVhdGVEaXJlY3RpdmVIb3N0UHJvcGVydHlBc3RzKGRpck1ldGEsIHNvdXJjZVNwYW4pO1xuICAgICAgdmFyIHBhcnNlZEhvc3RMaXN0ZW5lcnMgPSBwYXJzZXIuY3JlYXRlRGlyZWN0aXZlSG9zdEV2ZW50QXN0cyhkaXJNZXRhLCBzb3VyY2VTcGFuKTtcbiAgICAgIHJldHVybiBuZXcgUGFyc2VSZXN1bHQocGFyc2VkSG9zdFByb3BzLCBwYXJzZWRIb3N0TGlzdGVuZXJzLCBlcnJvcnMpO1xuICB9XG4gIGZ1bmN0aW9uIHJlcG9ydFBhcnNlRXJyb3JzKHBhcnNlRXJyb3JzLCBjb25zb2xlKSB7XG4gICAgICB2YXIgd2FybmluZ3MgPSBwYXJzZUVycm9ycy5maWx0ZXIoZnVuY3Rpb24gKGVycm9yKSB7IHJldHVybiBlcnJvci5sZXZlbCA9PT0gZXhwb3J0cy5QYXJzZUVycm9yTGV2ZWwuV0FSTklORzsgfSk7XG4gICAgICB2YXIgZXJyb3JzID0gcGFyc2VFcnJvcnMuZmlsdGVyKGZ1bmN0aW9uIChlcnJvcikgeyByZXR1cm4gZXJyb3IubGV2ZWwgPT09IGV4cG9ydHMuUGFyc2VFcnJvckxldmVsLkZBVEFMOyB9KTtcbiAgICAgIGlmICh3YXJuaW5ncy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdGhpcy5fY29uc29sZS53YXJuKFwiRGlyZWN0aXZlIHBhcnNlIHdhcm5pbmdzOlxcblwiICsgd2FybmluZ3Muam9pbignXFxuJykpO1xuICAgICAgfVxuICAgICAgaWYgKGVycm9ycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGlyZWN0aXZlIHBhcnNlIGVycm9yczpcXG5cIiArIGVycm9ycy5qb2luKCdcXG4nKSk7XG4gICAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb252ZXJ0VmFsdWVUb091dHB1dEFzdCh2YWx1ZSwgdHlwZSkge1xuICAgICAgaWYgKHR5cGUgPT09IHZvaWQgMCkgeyB0eXBlID0gbnVsbDsgfVxuICAgICAgcmV0dXJuIHZpc2l0VmFsdWUodmFsdWUsIG5ldyBfVmFsdWVPdXRwdXRBc3RUcmFuc2Zvcm1lcigpLCB0eXBlKTtcbiAgfVxuICB2YXIgX1ZhbHVlT3V0cHV0QXN0VHJhbnNmb3JtZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gX1ZhbHVlT3V0cHV0QXN0VHJhbnNmb3JtZXIoKSB7XG4gICAgICB9XG4gICAgICBfVmFsdWVPdXRwdXRBc3RUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRBcnJheSA9IGZ1bmN0aW9uIChhcnIsIHR5cGUpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHJldHVybiBsaXRlcmFsQXJyKGFyci5tYXAoZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiB2aXNpdFZhbHVlKHZhbHVlLCBfdGhpcywgbnVsbCk7IH0pLCB0eXBlKTtcbiAgICAgIH07XG4gICAgICBfVmFsdWVPdXRwdXRBc3RUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRTdHJpbmdNYXAgPSBmdW5jdGlvbiAobWFwLCB0eXBlKSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICB2YXIgZW50cmllcyA9IFtdO1xuICAgICAgICAgIE9iamVjdC5rZXlzKG1hcCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IGVudHJpZXMucHVzaChba2V5LCB2aXNpdFZhbHVlKG1hcFtrZXldLCBfdGhpcywgbnVsbCldKTsgfSk7XG4gICAgICAgICAgcmV0dXJuIGxpdGVyYWxNYXAoZW50cmllcywgdHlwZSk7XG4gICAgICB9O1xuICAgICAgX1ZhbHVlT3V0cHV0QXN0VHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0UHJpbWl0aXZlID0gZnVuY3Rpb24gKHZhbHVlLCB0eXBlKSB7IHJldHVybiBsaXRlcmFsKHZhbHVlLCB0eXBlKTsgfTtcbiAgICAgIF9WYWx1ZU91dHB1dEFzdFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdE90aGVyID0gZnVuY3Rpb24gKHZhbHVlLCB0eXBlKSB7XG4gICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQ29tcGlsZUlkZW50aWZpZXJNZXRhZGF0YSkge1xuICAgICAgICAgICAgICByZXR1cm4gaW1wb3J0RXhwcih2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgRXhwcmVzc2lvbikge1xuICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbGxlZ2FsIHN0YXRlOiBEb24ndCBub3cgaG93IHRvIGNvbXBpbGUgdmFsdWUgXCIgKyB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHJldHVybiBfVmFsdWVPdXRwdXRBc3RUcmFuc2Zvcm1lcjtcbiAgfSgpKTtcblxuICB2YXIgX0RlYnVnU3RhdGUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gX0RlYnVnU3RhdGUobm9kZUluZGV4LCBzb3VyY2VBc3QpIHtcbiAgICAgICAgICB0aGlzLm5vZGVJbmRleCA9IG5vZGVJbmRleDtcbiAgICAgICAgICB0aGlzLnNvdXJjZUFzdCA9IHNvdXJjZUFzdDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfRGVidWdTdGF0ZTtcbiAgfSgpKTtcbiAgdmFyIE5VTExfREVCVUdfU1RBVEUgPSBuZXcgX0RlYnVnU3RhdGUobnVsbCwgbnVsbCk7XG4gIHZhciBDb21waWxlTWV0aG9kID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIENvbXBpbGVNZXRob2QoX3ZpZXcpIHtcbiAgICAgICAgICB0aGlzLl92aWV3ID0gX3ZpZXc7XG4gICAgICAgICAgdGhpcy5fbmV3U3RhdGUgPSBOVUxMX0RFQlVHX1NUQVRFO1xuICAgICAgICAgIHRoaXMuX2N1cnJTdGF0ZSA9IE5VTExfREVCVUdfU1RBVEU7XG4gICAgICAgICAgdGhpcy5fYm9keVN0YXRlbWVudHMgPSBbXTtcbiAgICAgICAgICB0aGlzLl9kZWJ1Z0VuYWJsZWQgPSB0aGlzLl92aWV3LmdlbkNvbmZpZy5nZW5EZWJ1Z0luZm87XG4gICAgICB9XG4gICAgICBDb21waWxlTWV0aG9kLnByb3RvdHlwZS5fdXBkYXRlRGVidWdDb250ZXh0SWZOZWVkZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX25ld1N0YXRlLm5vZGVJbmRleCAhPT0gdGhpcy5fY3VyclN0YXRlLm5vZGVJbmRleCB8fFxuICAgICAgICAgICAgICB0aGlzLl9uZXdTdGF0ZS5zb3VyY2VBc3QgIT09IHRoaXMuX2N1cnJTdGF0ZS5zb3VyY2VBc3QpIHtcbiAgICAgICAgICAgICAgdmFyIGV4cHIgPSB0aGlzLl91cGRhdGVEZWJ1Z0NvbnRleHQodGhpcy5fbmV3U3RhdGUpO1xuICAgICAgICAgICAgICBpZiAoaXNQcmVzZW50KGV4cHIpKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9ib2R5U3RhdGVtZW50cy5wdXNoKGV4cHIudG9TdG10KCkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIENvbXBpbGVNZXRob2QucHJvdG90eXBlLl91cGRhdGVEZWJ1Z0NvbnRleHQgPSBmdW5jdGlvbiAobmV3U3RhdGUpIHtcbiAgICAgICAgICB0aGlzLl9jdXJyU3RhdGUgPSB0aGlzLl9uZXdTdGF0ZSA9IG5ld1N0YXRlO1xuICAgICAgICAgIGlmICh0aGlzLl9kZWJ1Z0VuYWJsZWQpIHtcbiAgICAgICAgICAgICAgdmFyIHNvdXJjZUxvY2F0aW9uID0gaXNQcmVzZW50KG5ld1N0YXRlLnNvdXJjZUFzdCkgPyBuZXdTdGF0ZS5zb3VyY2VBc3Quc291cmNlU3Bhbi5zdGFydCA6IG51bGw7XG4gICAgICAgICAgICAgIHJldHVybiBUSElTX0VYUFIuY2FsbE1ldGhvZCgnZGVidWcnLCBbXG4gICAgICAgICAgICAgICAgICBsaXRlcmFsKG5ld1N0YXRlLm5vZGVJbmRleCksXG4gICAgICAgICAgICAgICAgICBpc1ByZXNlbnQoc291cmNlTG9jYXRpb24pID8gbGl0ZXJhbChzb3VyY2VMb2NhdGlvbi5saW5lKSA6IE5VTExfRVhQUixcbiAgICAgICAgICAgICAgICAgIGlzUHJlc2VudChzb3VyY2VMb2NhdGlvbikgPyBsaXRlcmFsKHNvdXJjZUxvY2F0aW9uLmNvbCkgOiBOVUxMX0VYUFJcbiAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgQ29tcGlsZU1ldGhvZC5wcm90b3R5cGUucmVzZXREZWJ1Z0luZm9FeHByID0gZnVuY3Rpb24gKG5vZGVJbmRleCwgdGVtcGxhdGVBc3QpIHtcbiAgICAgICAgICB2YXIgcmVzID0gdGhpcy5fdXBkYXRlRGVidWdDb250ZXh0KG5ldyBfRGVidWdTdGF0ZShub2RlSW5kZXgsIHRlbXBsYXRlQXN0KSk7XG4gICAgICAgICAgcmV0dXJuIHJlcyB8fCBOVUxMX0VYUFI7XG4gICAgICB9O1xuICAgICAgQ29tcGlsZU1ldGhvZC5wcm90b3R5cGUucmVzZXREZWJ1Z0luZm8gPSBmdW5jdGlvbiAobm9kZUluZGV4LCB0ZW1wbGF0ZUFzdCkge1xuICAgICAgICAgIHRoaXMuX25ld1N0YXRlID0gbmV3IF9EZWJ1Z1N0YXRlKG5vZGVJbmRleCwgdGVtcGxhdGVBc3QpO1xuICAgICAgfTtcbiAgICAgIENvbXBpbGVNZXRob2QucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHN0bXRzID0gW107XG4gICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgc3RtdHNbX2kgLSAwXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuYWRkU3RtdHMoc3RtdHMpO1xuICAgICAgfTtcbiAgICAgIENvbXBpbGVNZXRob2QucHJvdG90eXBlLmFkZFN0bXQgPSBmdW5jdGlvbiAoc3RtdCkge1xuICAgICAgICAgIHRoaXMuX3VwZGF0ZURlYnVnQ29udGV4dElmTmVlZGVkKCk7XG4gICAgICAgICAgdGhpcy5fYm9keVN0YXRlbWVudHMucHVzaChzdG10KTtcbiAgICAgIH07XG4gICAgICBDb21waWxlTWV0aG9kLnByb3RvdHlwZS5hZGRTdG10cyA9IGZ1bmN0aW9uIChzdG10cykge1xuICAgICAgICAgIHRoaXMuX3VwZGF0ZURlYnVnQ29udGV4dElmTmVlZGVkKCk7XG4gICAgICAgICAgKF9hID0gdGhpcy5fYm9keVN0YXRlbWVudHMpLnB1c2guYXBwbHkoX2EsIHN0bXRzKTtcbiAgICAgICAgICB2YXIgX2E7XG4gICAgICB9O1xuICAgICAgQ29tcGlsZU1ldGhvZC5wcm90b3R5cGUuZmluaXNoID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fYm9keVN0YXRlbWVudHM7IH07XG4gICAgICBDb21waWxlTWV0aG9kLnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fYm9keVN0YXRlbWVudHMubGVuZ3RoID09PSAwOyB9O1xuICAgICAgcmV0dXJuIENvbXBpbGVNZXRob2Q7XG4gIH0oKSk7XG5cbiAgLyoqXG4gICAqIEBsaWNlbnNlXG4gICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgKlxuICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAqL1xuICB2YXIgX19leHRlbmRzJDE2ID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICB9O1xuICBmdW5jdGlvbiBnZXRQcm9wZXJ0eUluVmlldyhwcm9wZXJ0eSwgY2FsbGluZ1ZpZXcsIGRlZmluZWRWaWV3KSB7XG4gICAgICBpZiAoY2FsbGluZ1ZpZXcgPT09IGRlZmluZWRWaWV3KSB7XG4gICAgICAgICAgcmV0dXJuIHByb3BlcnR5O1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICAgdmFyIHZpZXdQcm9wID0gVEhJU19FWFBSO1xuICAgICAgICAgIHZhciBjdXJyVmlldyA9IGNhbGxpbmdWaWV3O1xuICAgICAgICAgIHdoaWxlIChjdXJyVmlldyAhPT0gZGVmaW5lZFZpZXcgJiYgaXNQcmVzZW50KGN1cnJWaWV3LmRlY2xhcmF0aW9uRWxlbWVudC52aWV3KSkge1xuICAgICAgICAgICAgICBjdXJyVmlldyA9IGN1cnJWaWV3LmRlY2xhcmF0aW9uRWxlbWVudC52aWV3O1xuICAgICAgICAgICAgICB2aWV3UHJvcCA9IHZpZXdQcm9wLnByb3AoJ3BhcmVudCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY3VyclZpZXcgIT09IGRlZmluZWRWaWV3KSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludGVybmFsIGVycm9yOiBDb3VsZCBub3QgY2FsY3VsYXRlIGEgcHJvcGVydHkgaW4gYSBwYXJlbnQgdmlldzogXCIgKyBwcm9wZXJ0eSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBwcm9wZXJ0eS52aXNpdEV4cHJlc3Npb24obmV3IF9SZXBsYWNlVmlld1RyYW5zZm9ybWVyKHZpZXdQcm9wLCBkZWZpbmVkVmlldyksIG51bGwpO1xuICAgICAgfVxuICB9XG4gIHZhciBfUmVwbGFjZVZpZXdUcmFuc2Zvcm1lciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkMTYoX1JlcGxhY2VWaWV3VHJhbnNmb3JtZXIsIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBfUmVwbGFjZVZpZXdUcmFuc2Zvcm1lcihfdmlld0V4cHIsIF92aWV3KSB7XG4gICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgdGhpcy5fdmlld0V4cHIgPSBfdmlld0V4cHI7XG4gICAgICAgICAgdGhpcy5fdmlldyA9IF92aWV3O1xuICAgICAgfVxuICAgICAgX1JlcGxhY2VWaWV3VHJhbnNmb3JtZXIucHJvdG90eXBlLl9pc1RoaXMgPSBmdW5jdGlvbiAoZXhwcikge1xuICAgICAgICAgIHJldHVybiBleHByIGluc3RhbmNlb2YgUmVhZFZhckV4cHIgJiYgZXhwci5idWlsdGluID09PSBCdWlsdGluVmFyLlRoaXM7XG4gICAgICB9O1xuICAgICAgX1JlcGxhY2VWaWV3VHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0UmVhZFZhckV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2lzVGhpcyhhc3QpID8gdGhpcy5fdmlld0V4cHIgOiBhc3Q7XG4gICAgICB9O1xuICAgICAgX1JlcGxhY2VWaWV3VHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0UmVhZFByb3BFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICAgIGlmICh0aGlzLl9pc1RoaXMoYXN0LnJlY2VpdmVyKSkge1xuICAgICAgICAgICAgICAvLyBOb3RlOiBEb24ndCBjYXN0IGZvciBtZW1iZXJzIG9mIHRoZSBBcHBWaWV3IGJhc2UgY2xhc3MuLi5cbiAgICAgICAgICAgICAgaWYgKHRoaXMuX3ZpZXcuZmllbGRzLnNvbWUoZnVuY3Rpb24gKGZpZWxkKSB7IHJldHVybiBmaWVsZC5uYW1lID09IGFzdC5uYW1lOyB9KSB8fFxuICAgICAgICAgICAgICAgICAgdGhpcy5fdmlldy5nZXR0ZXJzLnNvbWUoZnVuY3Rpb24gKGZpZWxkKSB7IHJldHVybiBmaWVsZC5uYW1lID09IGFzdC5uYW1lOyB9KSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ZpZXdFeHByLmNhc3QodGhpcy5fdmlldy5jbGFzc1R5cGUpLnByb3AoYXN0Lm5hbWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLnZpc2l0UmVhZFByb3BFeHByLmNhbGwodGhpcywgYXN0LCBjb250ZXh0KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gX1JlcGxhY2VWaWV3VHJhbnNmb3JtZXI7XG4gIH0oRXhwcmVzc2lvblRyYW5zZm9ybWVyKSk7XG4gIGZ1bmN0aW9uIGluamVjdEZyb21WaWV3UGFyZW50SW5qZWN0b3IodG9rZW4sIG9wdGlvbmFsKSB7XG4gICAgICB2YXIgYXJncyA9IFtjcmVhdGVEaVRva2VuRXhwcmVzc2lvbih0b2tlbildO1xuICAgICAgaWYgKG9wdGlvbmFsKSB7XG4gICAgICAgICAgYXJncy5wdXNoKE5VTExfRVhQUik7XG4gICAgICB9XG4gICAgICByZXR1cm4gVEhJU19FWFBSLnByb3AoJ3BhcmVudEluamVjdG9yJykuY2FsbE1ldGhvZCgnZ2V0JywgYXJncyk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0Vmlld0ZhY3RvcnlOYW1lKGNvbXBvbmVudCwgZW1iZWRkZWRUZW1wbGF0ZUluZGV4KSB7XG4gICAgICByZXR1cm4gXCJ2aWV3RmFjdG9yeV9cIiArIGNvbXBvbmVudC50eXBlLm5hbWUgKyBlbWJlZGRlZFRlbXBsYXRlSW5kZXg7XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlRmxhdEFycmF5KGV4cHJlc3Npb25zKSB7XG4gICAgICB2YXIgbGFzdE5vbkFycmF5RXhwcmVzc2lvbnMgPSBbXTtcbiAgICAgIHZhciByZXN1bHQgPSBsaXRlcmFsQXJyKFtdKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhwcmVzc2lvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgZXhwciA9IGV4cHJlc3Npb25zW2ldO1xuICAgICAgICAgIGlmIChleHByLnR5cGUgaW5zdGFuY2VvZiBBcnJheVR5cGUpIHtcbiAgICAgICAgICAgICAgaWYgKGxhc3ROb25BcnJheUV4cHJlc3Npb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdCA9XG4gICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmNhbGxNZXRob2QoQnVpbHRpbk1ldGhvZC5Db25jYXRBcnJheSwgW2xpdGVyYWxBcnIobGFzdE5vbkFycmF5RXhwcmVzc2lvbnMpXSk7XG4gICAgICAgICAgICAgICAgICBsYXN0Tm9uQXJyYXlFeHByZXNzaW9ucyA9IFtdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5jYWxsTWV0aG9kKEJ1aWx0aW5NZXRob2QuQ29uY2F0QXJyYXksIFtleHByXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBsYXN0Tm9uQXJyYXlFeHByZXNzaW9ucy5wdXNoKGV4cHIpO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChsYXN0Tm9uQXJyYXlFeHByZXNzaW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgcmVzdWx0ID1cbiAgICAgICAgICAgICAgcmVzdWx0LmNhbGxNZXRob2QoQnVpbHRpbk1ldGhvZC5Db25jYXRBcnJheSwgW2xpdGVyYWxBcnIobGFzdE5vbkFycmF5RXhwcmVzc2lvbnMpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgdmFyIFZpZXdRdWVyeVZhbHVlcyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBWaWV3UXVlcnlWYWx1ZXModmlldywgdmFsdWVzKSB7XG4gICAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgICB0aGlzLnZhbHVlcyA9IHZhbHVlcztcbiAgICAgIH1cbiAgICAgIHJldHVybiBWaWV3UXVlcnlWYWx1ZXM7XG4gIH0oKSk7XG4gIHZhciBDb21waWxlUXVlcnkgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gQ29tcGlsZVF1ZXJ5KG1ldGEsIHF1ZXJ5TGlzdCwgb3duZXJEaXJlY3RpdmVFeHByZXNzaW9uLCB2aWV3KSB7XG4gICAgICAgICAgdGhpcy5tZXRhID0gbWV0YTtcbiAgICAgICAgICB0aGlzLnF1ZXJ5TGlzdCA9IHF1ZXJ5TGlzdDtcbiAgICAgICAgICB0aGlzLm93bmVyRGlyZWN0aXZlRXhwcmVzc2lvbiA9IG93bmVyRGlyZWN0aXZlRXhwcmVzc2lvbjtcbiAgICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICAgIHRoaXMuX3ZhbHVlcyA9IG5ldyBWaWV3UXVlcnlWYWx1ZXModmlldywgW10pO1xuICAgICAgfVxuICAgICAgQ29tcGlsZVF1ZXJ5LnByb3RvdHlwZS5hZGRWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgdmlldykge1xuICAgICAgICAgIHZhciBjdXJyZW50VmlldyA9IHZpZXc7XG4gICAgICAgICAgdmFyIGVsUGF0aCA9IFtdO1xuICAgICAgICAgIHdoaWxlIChpc1ByZXNlbnQoY3VycmVudFZpZXcpICYmIGN1cnJlbnRWaWV3ICE9PSB0aGlzLnZpZXcpIHtcbiAgICAgICAgICAgICAgdmFyIHBhcmVudEVsID0gY3VycmVudFZpZXcuZGVjbGFyYXRpb25FbGVtZW50O1xuICAgICAgICAgICAgICBlbFBhdGgudW5zaGlmdChwYXJlbnRFbCk7XG4gICAgICAgICAgICAgIGN1cnJlbnRWaWV3ID0gcGFyZW50RWwudmlldztcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHF1ZXJ5TGlzdEZvckRpcnR5RXhwciA9IGdldFByb3BlcnR5SW5WaWV3KHRoaXMucXVlcnlMaXN0LCB2aWV3LCB0aGlzLnZpZXcpO1xuICAgICAgICAgIHZhciB2aWV3VmFsdWVzID0gdGhpcy5fdmFsdWVzO1xuICAgICAgICAgIGVsUGF0aC5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgICB2YXIgbGFzdCA9IHZpZXdWYWx1ZXMudmFsdWVzLmxlbmd0aCA+IDAgPyB2aWV3VmFsdWVzLnZhbHVlc1t2aWV3VmFsdWVzLnZhbHVlcy5sZW5ndGggLSAxXSA6IG51bGw7XG4gICAgICAgICAgICAgIGlmIChsYXN0IGluc3RhbmNlb2YgVmlld1F1ZXJ5VmFsdWVzICYmIGxhc3QudmlldyA9PT0gZWwuZW1iZWRkZWRWaWV3KSB7XG4gICAgICAgICAgICAgICAgICB2aWV3VmFsdWVzID0gbGFzdDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHZhciBuZXdWaWV3VmFsdWVzID0gbmV3IFZpZXdRdWVyeVZhbHVlcyhlbC5lbWJlZGRlZFZpZXcsIFtdKTtcbiAgICAgICAgICAgICAgICAgIHZpZXdWYWx1ZXMudmFsdWVzLnB1c2gobmV3Vmlld1ZhbHVlcyk7XG4gICAgICAgICAgICAgICAgICB2aWV3VmFsdWVzID0gbmV3Vmlld1ZhbHVlcztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHZpZXdWYWx1ZXMudmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgICAgIGlmIChlbFBhdGgubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICB2aWV3LmRpcnR5UGFyZW50UXVlcmllc01ldGhvZC5hZGRTdG10KHF1ZXJ5TGlzdEZvckRpcnR5RXhwci5jYWxsTWV0aG9kKCdzZXREaXJ0eScsIFtdKS50b1N0bXQoKSk7XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIENvbXBpbGVRdWVyeS5wcm90b3R5cGUuX2lzU3RhdGljID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiAhdGhpcy5fdmFsdWVzLnZhbHVlcy5zb21lKGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBWaWV3UXVlcnlWYWx1ZXM7IH0pO1xuICAgICAgfTtcbiAgICAgIENvbXBpbGVRdWVyeS5wcm90b3R5cGUuYWZ0ZXJDaGlsZHJlbiA9IGZ1bmN0aW9uICh0YXJnZXRTdGF0aWNNZXRob2QsIHRhcmdldER5bmFtaWNNZXRob2QpIHtcbiAgICAgICAgICB2YXIgdmFsdWVzID0gY3JlYXRlUXVlcnlWYWx1ZXModGhpcy5fdmFsdWVzKTtcbiAgICAgICAgICB2YXIgdXBkYXRlU3RtdHMgPSBbdGhpcy5xdWVyeUxpc3QuY2FsbE1ldGhvZCgncmVzZXQnLCBbbGl0ZXJhbEFycih2YWx1ZXMpXSkudG9TdG10KCldO1xuICAgICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5vd25lckRpcmVjdGl2ZUV4cHJlc3Npb24pKSB7XG4gICAgICAgICAgICAgIHZhciB2YWx1ZUV4cHIgPSB0aGlzLm1ldGEuZmlyc3QgPyB0aGlzLnF1ZXJ5TGlzdC5wcm9wKCdmaXJzdCcpIDogdGhpcy5xdWVyeUxpc3Q7XG4gICAgICAgICAgICAgIHVwZGF0ZVN0bXRzLnB1c2godGhpcy5vd25lckRpcmVjdGl2ZUV4cHJlc3Npb24ucHJvcCh0aGlzLm1ldGEucHJvcGVydHlOYW1lKS5zZXQodmFsdWVFeHByKS50b1N0bXQoKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghdGhpcy5tZXRhLmZpcnN0KSB7XG4gICAgICAgICAgICAgIHVwZGF0ZVN0bXRzLnB1c2godGhpcy5xdWVyeUxpc3QuY2FsbE1ldGhvZCgnbm90aWZ5T25DaGFuZ2VzJywgW10pLnRvU3RtdCgpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRoaXMubWV0YS5maXJzdCAmJiB0aGlzLl9pc1N0YXRpYygpKSB7XG4gICAgICAgICAgICAgIC8vIGZvciBxdWVyaWVzIHRoYXQgZG9uJ3QgY2hhbmdlIGFuZCB0aGUgdXNlciBhc2tlZCBmb3IgYSBzaW5nbGUgZWxlbWVudCxcbiAgICAgICAgICAgICAgLy8gc2V0IGl0IGltbWVkaWF0ZWx5LiBUaGF0IGlzIGUuZy4gbmVlZGVkIGZvciBxdWVyeWluZyBmb3IgVmlld0NvbnRhaW5lclJlZnMsIC4uLlxuICAgICAgICAgICAgICAvLyB3ZSBkb24ndCBkbyB0aGlzIGZvciBRdWVyeUxpc3RzIGZvciBub3cgYXMgdGhpcyB3b3VsZCBicmVhayB0aGUgdGltaW5nIHdoZW5cbiAgICAgICAgICAgICAgLy8gd2UgY2FsbCBRdWVyeUxpc3QgbGlzdGVuZXJzLi4uXG4gICAgICAgICAgICAgIHRhcmdldFN0YXRpY01ldGhvZC5hZGRTdG10cyh1cGRhdGVTdG10cyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICB0YXJnZXREeW5hbWljTWV0aG9kLmFkZFN0bXQobmV3IElmU3RtdCh0aGlzLnF1ZXJ5TGlzdC5wcm9wKCdkaXJ0eScpLCB1cGRhdGVTdG10cykpO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICByZXR1cm4gQ29tcGlsZVF1ZXJ5O1xuICB9KCkpO1xuICBmdW5jdGlvbiBjcmVhdGVRdWVyeVZhbHVlcyh2aWV3VmFsdWVzKSB7XG4gICAgICByZXR1cm4gTGlzdFdyYXBwZXIuZmxhdHRlbih2aWV3VmFsdWVzLnZhbHVlcy5tYXAoZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgICAgaWYgKGVudHJ5IGluc3RhbmNlb2YgVmlld1F1ZXJ5VmFsdWVzKSB7XG4gICAgICAgICAgICAgIHJldHVybiBtYXBOZXN0ZWRWaWV3cyhlbnRyeS52aWV3LmRlY2xhcmF0aW9uRWxlbWVudC5hcHBFbGVtZW50LCBlbnRyeS52aWV3LCBjcmVhdGVRdWVyeVZhbHVlcyhlbnRyeSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGVudHJ5O1xuICAgICAgICAgIH1cbiAgICAgIH0pKTtcbiAgfVxuICBmdW5jdGlvbiBtYXBOZXN0ZWRWaWV3cyhkZWNsYXJhdGlvbkFwcEVsZW1lbnQsIHZpZXcsIGV4cHJlc3Npb25zKSB7XG4gICAgICB2YXIgYWRqdXN0ZWRFeHByZXNzaW9ucyA9IGV4cHJlc3Npb25zLm1hcChmdW5jdGlvbiAoZXhwcikgeyByZXR1cm4gcmVwbGFjZVZhckluRXhwcmVzc2lvbihUSElTX0VYUFIubmFtZSwgdmFyaWFibGUoJ25lc3RlZFZpZXcnKSwgZXhwcik7IH0pO1xuICAgICAgcmV0dXJuIGRlY2xhcmF0aW9uQXBwRWxlbWVudC5jYWxsTWV0aG9kKCdtYXBOZXN0ZWRWaWV3cycsIFtcbiAgICAgICAgICB2YXJpYWJsZSh2aWV3LmNsYXNzTmFtZSksXG4gICAgICAgICAgZm4oW25ldyBGblBhcmFtKCduZXN0ZWRWaWV3Jywgdmlldy5jbGFzc1R5cGUpXSwgW25ldyBSZXR1cm5TdGF0ZW1lbnQobGl0ZXJhbEFycihhZGp1c3RlZEV4cHJlc3Npb25zKSldLCBEWU5BTUlDX1RZUEUpXG4gICAgICBdKTtcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVRdWVyeUxpc3QocXVlcnksIGRpcmVjdGl2ZUluc3RhbmNlLCBwcm9wZXJ0eU5hbWUsIGNvbXBpbGVWaWV3KSB7XG4gICAgICBjb21waWxlVmlldy5maWVsZHMucHVzaChuZXcgQ2xhc3NGaWVsZChwcm9wZXJ0eU5hbWUsIGltcG9ydFR5cGUocmVzb2x2ZUlkZW50aWZpZXIoSWRlbnRpZmllcnMuUXVlcnlMaXN0KSwgW0RZTkFNSUNfVFlQRV0pKSk7XG4gICAgICB2YXIgZXhwciA9IFRISVNfRVhQUi5wcm9wKHByb3BlcnR5TmFtZSk7XG4gICAgICBjb21waWxlVmlldy5jcmVhdGVNZXRob2QuYWRkU3RtdChUSElTX0VYUFIucHJvcChwcm9wZXJ0eU5hbWUpXG4gICAgICAgICAgLnNldChpbXBvcnRFeHByKHJlc29sdmVJZGVudGlmaWVyKElkZW50aWZpZXJzLlF1ZXJ5TGlzdCksIFtEWU5BTUlDX1RZUEVdKVxuICAgICAgICAgIC5pbnN0YW50aWF0ZShbXSkpXG4gICAgICAgICAgLnRvU3RtdCgpKTtcbiAgICAgIHJldHVybiBleHByO1xuICB9XG4gIGZ1bmN0aW9uIGFkZFF1ZXJ5VG9Ub2tlbk1hcChtYXAsIHF1ZXJ5KSB7XG4gICAgICBxdWVyeS5tZXRhLnNlbGVjdG9ycy5mb3JFYWNoKGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgICAgICAgIHZhciBlbnRyeSA9IG1hcC5nZXQoc2VsZWN0b3IucmVmZXJlbmNlKTtcbiAgICAgICAgICBpZiAoIWVudHJ5KSB7XG4gICAgICAgICAgICAgIGVudHJ5ID0gW107XG4gICAgICAgICAgICAgIG1hcC5zZXQoc2VsZWN0b3IucmVmZXJlbmNlLCBlbnRyeSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVudHJ5LnB1c2gocXVlcnkpO1xuICAgICAgfSk7XG4gIH1cblxuICB2YXIgVmlld1R5cGVFbnVtID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIFZpZXdUeXBlRW51bSgpIHtcbiAgICAgIH1cbiAgICAgIFZpZXdUeXBlRW51bS5mcm9tVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlRW51bUV4cHJlc3Npb24oSWRlbnRpZmllcnMuVmlld1R5cGUsIHZhbHVlKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gVmlld1R5cGVFbnVtO1xuICB9KCkpO1xuICB2YXIgVmlld0VuY2Fwc3VsYXRpb25FbnVtID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIFZpZXdFbmNhcHN1bGF0aW9uRW51bSgpIHtcbiAgICAgIH1cbiAgICAgIFZpZXdFbmNhcHN1bGF0aW9uRW51bS5mcm9tVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlRW51bUV4cHJlc3Npb24oSWRlbnRpZmllcnMuVmlld0VuY2Fwc3VsYXRpb24sIHZhbHVlKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gVmlld0VuY2Fwc3VsYXRpb25FbnVtO1xuICB9KCkpO1xuICB2YXIgQ2hhbmdlRGV0ZWN0b3JTdGF0dXNFbnVtID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIENoYW5nZURldGVjdG9yU3RhdHVzRW51bSgpIHtcbiAgICAgIH1cbiAgICAgIENoYW5nZURldGVjdG9yU3RhdHVzRW51bS5mcm9tVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlRW51bUV4cHJlc3Npb24oSWRlbnRpZmllcnMuQ2hhbmdlRGV0ZWN0b3JTdGF0dXMsIHZhbHVlKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gQ2hhbmdlRGV0ZWN0b3JTdGF0dXNFbnVtO1xuICB9KCkpO1xuICB2YXIgVmlld0NvbnN0cnVjdG9yVmFycyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBWaWV3Q29uc3RydWN0b3JWYXJzKCkge1xuICAgICAgfVxuICAgICAgVmlld0NvbnN0cnVjdG9yVmFycy52aWV3VXRpbHMgPSB2YXJpYWJsZSgndmlld1V0aWxzJyk7XG4gICAgICBWaWV3Q29uc3RydWN0b3JWYXJzLnBhcmVudEluamVjdG9yID0gdmFyaWFibGUoJ3BhcmVudEluamVjdG9yJyk7XG4gICAgICBWaWV3Q29uc3RydWN0b3JWYXJzLmRlY2xhcmF0aW9uRWwgPSB2YXJpYWJsZSgnZGVjbGFyYXRpb25FbCcpO1xuICAgICAgcmV0dXJuIFZpZXdDb25zdHJ1Y3RvclZhcnM7XG4gIH0oKSk7XG4gIHZhciBWaWV3UHJvcGVydGllcyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBWaWV3UHJvcGVydGllcygpIHtcbiAgICAgIH1cbiAgICAgIFZpZXdQcm9wZXJ0aWVzLnJlbmRlcmVyID0gVEhJU19FWFBSLnByb3AoJ3JlbmRlcmVyJyk7XG4gICAgICBWaWV3UHJvcGVydGllcy5wcm9qZWN0YWJsZU5vZGVzID0gVEhJU19FWFBSLnByb3AoJ3Byb2plY3RhYmxlTm9kZXMnKTtcbiAgICAgIFZpZXdQcm9wZXJ0aWVzLnZpZXdVdGlscyA9IFRISVNfRVhQUi5wcm9wKCd2aWV3VXRpbHMnKTtcbiAgICAgIHJldHVybiBWaWV3UHJvcGVydGllcztcbiAgfSgpKTtcbiAgdmFyIEluamVjdE1ldGhvZFZhcnMgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gSW5qZWN0TWV0aG9kVmFycygpIHtcbiAgICAgIH1cbiAgICAgIEluamVjdE1ldGhvZFZhcnMudG9rZW4gPSB2YXJpYWJsZSgndG9rZW4nKTtcbiAgICAgIEluamVjdE1ldGhvZFZhcnMucmVxdWVzdE5vZGVJbmRleCA9IHZhcmlhYmxlKCdyZXF1ZXN0Tm9kZUluZGV4Jyk7XG4gICAgICBJbmplY3RNZXRob2RWYXJzLm5vdEZvdW5kUmVzdWx0ID0gdmFyaWFibGUoJ25vdEZvdW5kUmVzdWx0Jyk7XG4gICAgICByZXR1cm4gSW5qZWN0TWV0aG9kVmFycztcbiAgfSgpKTtcbiAgdmFyIERldGVjdENoYW5nZXNWYXJzID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIERldGVjdENoYW5nZXNWYXJzKCkge1xuICAgICAgfVxuICAgICAgRGV0ZWN0Q2hhbmdlc1ZhcnMudGhyb3dPbkNoYW5nZSA9IHZhcmlhYmxlKFwidGhyb3dPbkNoYW5nZVwiKTtcbiAgICAgIERldGVjdENoYW5nZXNWYXJzLmNoYW5nZXMgPSB2YXJpYWJsZShcImNoYW5nZXNcIik7XG4gICAgICBEZXRlY3RDaGFuZ2VzVmFycy5jaGFuZ2VkID0gdmFyaWFibGUoXCJjaGFuZ2VkXCIpO1xuICAgICAgcmV0dXJuIERldGVjdENoYW5nZXNWYXJzO1xuICB9KCkpO1xuXG4gIC8qKlxuICAgKiBAbGljZW5zZVxuICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICpcbiAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgKi9cbiAgdmFyIFZpZXdGYWN0b3J5RGVwZW5kZW5jeSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBWaWV3RmFjdG9yeURlcGVuZGVuY3koY29tcCwgcGxhY2Vob2xkZXIpIHtcbiAgICAgICAgICB0aGlzLmNvbXAgPSBjb21wO1xuICAgICAgICAgIHRoaXMucGxhY2Vob2xkZXIgPSBwbGFjZWhvbGRlcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBWaWV3RmFjdG9yeURlcGVuZGVuY3k7XG4gIH0oKSk7XG4gIHZhciBDb21wb25lbnRGYWN0b3J5RGVwZW5kZW5jeSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBDb21wb25lbnRGYWN0b3J5RGVwZW5kZW5jeShjb21wLCBwbGFjZWhvbGRlcikge1xuICAgICAgICAgIHRoaXMuY29tcCA9IGNvbXA7XG4gICAgICAgICAgdGhpcy5wbGFjZWhvbGRlciA9IHBsYWNlaG9sZGVyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIENvbXBvbmVudEZhY3RvcnlEZXBlbmRlbmN5O1xuICB9KCkpO1xuICB2YXIgRGlyZWN0aXZlV3JhcHBlckRlcGVuZGVuY3kgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gRGlyZWN0aXZlV3JhcHBlckRlcGVuZGVuY3koZGlyLCBwbGFjZWhvbGRlcikge1xuICAgICAgICAgIHRoaXMuZGlyID0gZGlyO1xuICAgICAgICAgIHRoaXMucGxhY2Vob2xkZXIgPSBwbGFjZWhvbGRlcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBEaXJlY3RpdmVXcmFwcGVyRGVwZW5kZW5jeTtcbiAgfSgpKTtcblxuICAvKipcbiAgICogQGxpY2Vuc2VcbiAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAqXG4gICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICovXG4gIHZhciBfX2V4dGVuZHMkMTUgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gIH07XG4gIHZhciBDb21waWxlTm9kZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBDb21waWxlTm9kZShwYXJlbnQsIHZpZXcsIG5vZGVJbmRleCwgcmVuZGVyTm9kZSwgc291cmNlQXN0KSB7XG4gICAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgICB0aGlzLm5vZGVJbmRleCA9IG5vZGVJbmRleDtcbiAgICAgICAgICB0aGlzLnJlbmRlck5vZGUgPSByZW5kZXJOb2RlO1xuICAgICAgICAgIHRoaXMuc291cmNlQXN0ID0gc291cmNlQXN0O1xuICAgICAgfVxuICAgICAgQ29tcGlsZU5vZGUucHJvdG90eXBlLmlzTnVsbCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICF0aGlzLnJlbmRlck5vZGU7IH07XG4gICAgICBDb21waWxlTm9kZS5wcm90b3R5cGUuaXNSb290RWxlbWVudCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMudmlldyAhPSB0aGlzLnBhcmVudC52aWV3OyB9O1xuICAgICAgcmV0dXJuIENvbXBpbGVOb2RlO1xuICB9KCkpO1xuICB2YXIgQ29tcGlsZUVsZW1lbnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDE1KENvbXBpbGVFbGVtZW50LCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gQ29tcGlsZUVsZW1lbnQocGFyZW50LCB2aWV3LCBub2RlSW5kZXgsIHJlbmRlck5vZGUsIHNvdXJjZUFzdCwgY29tcG9uZW50LCBfZGlyZWN0aXZlcywgX3Jlc29sdmVkUHJvdmlkZXJzQXJyYXksIGhhc1ZpZXdDb250YWluZXIsIGhhc0VtYmVkZGVkVmlldywgcmVmZXJlbmNlcywgX3RhcmdldERlcGVuZGVuY2llcykge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgcGFyZW50LCB2aWV3LCBub2RlSW5kZXgsIHJlbmRlck5vZGUsIHNvdXJjZUFzdCk7XG4gICAgICAgICAgdGhpcy5jb21wb25lbnQgPSBjb21wb25lbnQ7XG4gICAgICAgICAgdGhpcy5fZGlyZWN0aXZlcyA9IF9kaXJlY3RpdmVzO1xuICAgICAgICAgIHRoaXMuX3Jlc29sdmVkUHJvdmlkZXJzQXJyYXkgPSBfcmVzb2x2ZWRQcm92aWRlcnNBcnJheTtcbiAgICAgICAgICB0aGlzLmhhc1ZpZXdDb250YWluZXIgPSBoYXNWaWV3Q29udGFpbmVyO1xuICAgICAgICAgIHRoaXMuaGFzRW1iZWRkZWRWaWV3ID0gaGFzRW1iZWRkZWRWaWV3O1xuICAgICAgICAgIHRoaXMuX3RhcmdldERlcGVuZGVuY2llcyA9IF90YXJnZXREZXBlbmRlbmNpZXM7XG4gICAgICAgICAgdGhpcy5fY29tcFZpZXdFeHByID0gbnVsbDtcbiAgICAgICAgICB0aGlzLmluc3RhbmNlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICB0aGlzLmRpcmVjdGl2ZVdyYXBwZXJJbnN0YW5jZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgICB0aGlzLl9xdWVyeUNvdW50ID0gMDtcbiAgICAgICAgICB0aGlzLl9xdWVyaWVzID0gbmV3IE1hcCgpO1xuICAgICAgICAgIHRoaXMuX2NvbXBvbmVudENvbnN0cnVjdG9yVmlld1F1ZXJ5TGlzdHMgPSBbXTtcbiAgICAgICAgICB0aGlzLmNvbnRlbnROb2Rlc0J5TmdDb250ZW50SW5kZXggPSBudWxsO1xuICAgICAgICAgIHRoaXMucmVmZXJlbmNlVG9rZW5zID0ge307XG4gICAgICAgICAgcmVmZXJlbmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChyZWYpIHsgcmV0dXJuIF90aGlzLnJlZmVyZW5jZVRva2Vuc1tyZWYubmFtZV0gPSByZWYudmFsdWU7IH0pO1xuICAgICAgICAgIHRoaXMuZWxlbWVudFJlZiA9XG4gICAgICAgICAgICAgIGltcG9ydEV4cHIocmVzb2x2ZUlkZW50aWZpZXIoSWRlbnRpZmllcnMuRWxlbWVudFJlZikpLmluc3RhbnRpYXRlKFt0aGlzLnJlbmRlck5vZGVdKTtcbiAgICAgICAgICB0aGlzLmluc3RhbmNlcy5zZXQocmVzb2x2ZUlkZW50aWZpZXJUb2tlbihJZGVudGlmaWVycy5FbGVtZW50UmVmKS5yZWZlcmVuY2UsIHRoaXMuZWxlbWVudFJlZik7XG4gICAgICAgICAgdGhpcy5pbmplY3RvciA9IFRISVNfRVhQUi5jYWxsTWV0aG9kKCdpbmplY3RvcicsIFtsaXRlcmFsKHRoaXMubm9kZUluZGV4KV0pO1xuICAgICAgICAgIHRoaXMuaW5zdGFuY2VzLnNldChyZXNvbHZlSWRlbnRpZmllclRva2VuKElkZW50aWZpZXJzLkluamVjdG9yKS5yZWZlcmVuY2UsIHRoaXMuaW5qZWN0b3IpO1xuICAgICAgICAgIHRoaXMuaW5zdGFuY2VzLnNldChyZXNvbHZlSWRlbnRpZmllclRva2VuKElkZW50aWZpZXJzLlJlbmRlcmVyKS5yZWZlcmVuY2UsIFRISVNfRVhQUi5wcm9wKCdyZW5kZXJlcicpKTtcbiAgICAgICAgICBpZiAodGhpcy5oYXNWaWV3Q29udGFpbmVyIHx8IHRoaXMuaGFzRW1iZWRkZWRWaWV3IHx8IGlzUHJlc2VudCh0aGlzLmNvbXBvbmVudCkpIHtcbiAgICAgICAgICAgICAgdGhpcy5fY3JlYXRlQXBwRWxlbWVudCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy5jb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgdGhpcy5fY3JlYXRlQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyKCk7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgQ29tcGlsZUVsZW1lbnQuY3JlYXRlTnVsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IENvbXBpbGVFbGVtZW50KG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIFtdLCBbXSwgZmFsc2UsIGZhbHNlLCBbXSwgW10pO1xuICAgICAgfTtcbiAgICAgIENvbXBpbGVFbGVtZW50LnByb3RvdHlwZS5fY3JlYXRlQXBwRWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgZmllbGROYW1lID0gXCJfYXBwRWxfXCIgKyB0aGlzLm5vZGVJbmRleDtcbiAgICAgICAgICB2YXIgcGFyZW50Tm9kZUluZGV4ID0gdGhpcy5pc1Jvb3RFbGVtZW50KCkgPyBudWxsIDogdGhpcy5wYXJlbnQubm9kZUluZGV4O1xuICAgICAgICAgIC8vIHByaXZhdGUgaXMgZmluZSBoZXJlIGFzIG5vIGNoaWxkIHZpZXcgd2lsbCByZWZlcmVuY2UgYW4gQXBwRWxlbWVudFxuICAgICAgICAgIHRoaXMudmlldy5maWVsZHMucHVzaChuZXcgQ2xhc3NGaWVsZChmaWVsZE5hbWUsIGltcG9ydFR5cGUocmVzb2x2ZUlkZW50aWZpZXIoSWRlbnRpZmllcnMuQXBwRWxlbWVudCkpLCBbU3RtdE1vZGlmaWVyLlByaXZhdGVdKSk7XG4gICAgICAgICAgdmFyIHN0YXRlbWVudCA9IFRISVNfRVhQUi5wcm9wKGZpZWxkTmFtZSlcbiAgICAgICAgICAgICAgLnNldChpbXBvcnRFeHByKHJlc29sdmVJZGVudGlmaWVyKElkZW50aWZpZXJzLkFwcEVsZW1lbnQpKS5pbnN0YW50aWF0ZShbXG4gICAgICAgICAgICAgIGxpdGVyYWwodGhpcy5ub2RlSW5kZXgpLCBsaXRlcmFsKHBhcmVudE5vZGVJbmRleCksIFRISVNfRVhQUiwgdGhpcy5yZW5kZXJOb2RlXG4gICAgICAgICAgXSkpXG4gICAgICAgICAgICAgIC50b1N0bXQoKTtcbiAgICAgICAgICB0aGlzLnZpZXcuY3JlYXRlTWV0aG9kLmFkZFN0bXQoc3RhdGVtZW50KTtcbiAgICAgICAgICB0aGlzLmFwcEVsZW1lbnQgPSBUSElTX0VYUFIucHJvcChmaWVsZE5hbWUpO1xuICAgICAgICAgIHRoaXMuaW5zdGFuY2VzLnNldChyZXNvbHZlSWRlbnRpZmllclRva2VuKElkZW50aWZpZXJzLkFwcEVsZW1lbnQpLnJlZmVyZW5jZSwgdGhpcy5hcHBFbGVtZW50KTtcbiAgICAgIH07XG4gICAgICBDb21waWxlRWxlbWVudC5wcm90b3R5cGUuX2NyZWF0ZUNvbXBvbmVudEZhY3RvcnlSZXNvbHZlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHZhciBlbnRyeUNvbXBvbmVudHMgPSB0aGlzLmNvbXBvbmVudC5lbnRyeUNvbXBvbmVudHMubWFwKGZ1bmN0aW9uIChlbnRyeUNvbXBvbmVudCkge1xuICAgICAgICAgICAgICB2YXIgaWQgPSBuZXcgQ29tcGlsZUlkZW50aWZpZXJNZXRhZGF0YSh7IG5hbWU6IGVudHJ5Q29tcG9uZW50Lm5hbWUgfSk7XG4gICAgICAgICAgICAgIF90aGlzLl90YXJnZXREZXBlbmRlbmNpZXMucHVzaChuZXcgQ29tcG9uZW50RmFjdG9yeURlcGVuZGVuY3koZW50cnlDb21wb25lbnQsIGlkKSk7XG4gICAgICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAoIWVudHJ5Q29tcG9uZW50cyB8fCBlbnRyeUNvbXBvbmVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGNyZWF0ZUNvbXBvbmVudEZhY3RvcnlSZXNvbHZlckV4cHIgPSBpbXBvcnRFeHByKHJlc29sdmVJZGVudGlmaWVyKElkZW50aWZpZXJzLkNvZGVnZW5Db21wb25lbnRGYWN0b3J5UmVzb2x2ZXIpKS5pbnN0YW50aWF0ZShbXG4gICAgICAgICAgICAgIGxpdGVyYWxBcnIoZW50cnlDb21wb25lbnRzLm1hcChmdW5jdGlvbiAoZW50cnlDb21wb25lbnQpIHsgcmV0dXJuIGltcG9ydEV4cHIoZW50cnlDb21wb25lbnQpOyB9KSksXG4gICAgICAgICAgICAgIGluamVjdEZyb21WaWV3UGFyZW50SW5qZWN0b3IocmVzb2x2ZUlkZW50aWZpZXJUb2tlbihJZGVudGlmaWVycy5Db21wb25lbnRGYWN0b3J5UmVzb2x2ZXIpLCBmYWxzZSlcbiAgICAgICAgICBdKTtcbiAgICAgICAgICB2YXIgcHJvdmlkZXIgPSBuZXcgQ29tcGlsZVByb3ZpZGVyTWV0YWRhdGEoe1xuICAgICAgICAgICAgICB0b2tlbjogcmVzb2x2ZUlkZW50aWZpZXJUb2tlbihJZGVudGlmaWVycy5Db21wb25lbnRGYWN0b3J5UmVzb2x2ZXIpLFxuICAgICAgICAgICAgICB1c2VWYWx1ZTogY3JlYXRlQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyRXhwclxuICAgICAgICAgIH0pO1xuICAgICAgICAgIC8vIEFkZCBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIgYXMgZmlyc3QgcHJvdmlkZXIgYXMgaXQgZG9lcyBub3QgaGF2ZSBkZXBzIG9uIG90aGVyIHByb3ZpZGVyc1xuICAgICAgICAgIC8vIFByb3ZpZGVyQXN0VHlwZS5Qcml2YXRlU2VydmljZSBhcyBvbmx5IHRoZSBjb21wb25lbnQgYW5kIGl0cyB2aWV3IGNhbiBzZWUgaXQsXG4gICAgICAgICAgLy8gYnV0IG5vYm9keSBlbHNlXG4gICAgICAgICAgdGhpcy5fcmVzb2x2ZWRQcm92aWRlcnNBcnJheS51bnNoaWZ0KG5ldyBQcm92aWRlckFzdChwcm92aWRlci50b2tlbiwgZmFsc2UsIHRydWUsIFtwcm92aWRlcl0sIGV4cG9ydHMuUHJvdmlkZXJBc3RUeXBlLlByaXZhdGVTZXJ2aWNlLCBbXSwgdGhpcy5zb3VyY2VBc3Quc291cmNlU3BhbikpO1xuICAgICAgfTtcbiAgICAgIENvbXBpbGVFbGVtZW50LnByb3RvdHlwZS5zZXRDb21wb25lbnRWaWV3ID0gZnVuY3Rpb24gKGNvbXBWaWV3RXhwcikge1xuICAgICAgICAgIHRoaXMuX2NvbXBWaWV3RXhwciA9IGNvbXBWaWV3RXhwcjtcbiAgICAgICAgICB0aGlzLmNvbnRlbnROb2Rlc0J5TmdDb250ZW50SW5kZXggPVxuICAgICAgICAgICAgICBuZXcgQXJyYXkodGhpcy5jb21wb25lbnQudGVtcGxhdGUubmdDb250ZW50U2VsZWN0b3JzLmxlbmd0aCk7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNvbnRlbnROb2Rlc0J5TmdDb250ZW50SW5kZXgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdGhpcy5jb250ZW50Tm9kZXNCeU5nQ29udGVudEluZGV4W2ldID0gW107XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIENvbXBpbGVFbGVtZW50LnByb3RvdHlwZS5zZXRFbWJlZGRlZFZpZXcgPSBmdW5jdGlvbiAoZW1iZWRkZWRWaWV3KSB7XG4gICAgICAgICAgdGhpcy5lbWJlZGRlZFZpZXcgPSBlbWJlZGRlZFZpZXc7XG4gICAgICAgICAgaWYgKGlzUHJlc2VudChlbWJlZGRlZFZpZXcpKSB7XG4gICAgICAgICAgICAgIHZhciBjcmVhdGVUZW1wbGF0ZVJlZkV4cHIgPSBpbXBvcnRFeHByKHJlc29sdmVJZGVudGlmaWVyKElkZW50aWZpZXJzLlRlbXBsYXRlUmVmXykpLmluc3RhbnRpYXRlKFtcbiAgICAgICAgICAgICAgICAgIHRoaXMuYXBwRWxlbWVudCwgdGhpcy5lbWJlZGRlZFZpZXcudmlld0ZhY3RvcnlcbiAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgIHZhciBwcm92aWRlciA9IG5ldyBDb21waWxlUHJvdmlkZXJNZXRhZGF0YSh7XG4gICAgICAgICAgICAgICAgICB0b2tlbjogcmVzb2x2ZUlkZW50aWZpZXJUb2tlbihJZGVudGlmaWVycy5UZW1wbGF0ZVJlZiksXG4gICAgICAgICAgICAgICAgICB1c2VWYWx1ZTogY3JlYXRlVGVtcGxhdGVSZWZFeHByXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAvLyBBZGQgVGVtcGxhdGVSZWYgYXMgZmlyc3QgcHJvdmlkZXIgYXMgaXQgZG9lcyBub3QgaGF2ZSBkZXBzIG9uIG90aGVyIHByb3ZpZGVyc1xuICAgICAgICAgICAgICB0aGlzLl9yZXNvbHZlZFByb3ZpZGVyc0FycmF5LnVuc2hpZnQobmV3IFByb3ZpZGVyQXN0KHByb3ZpZGVyLnRva2VuLCBmYWxzZSwgdHJ1ZSwgW3Byb3ZpZGVyXSwgZXhwb3J0cy5Qcm92aWRlckFzdFR5cGUuQnVpbHRpbiwgW10sIHRoaXMuc291cmNlQXN0LnNvdXJjZVNwYW4pKTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgQ29tcGlsZUVsZW1lbnQucHJvdG90eXBlLmJlZm9yZUNoaWxkcmVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgaWYgKHRoaXMuaGFzVmlld0NvbnRhaW5lcikge1xuICAgICAgICAgICAgICB0aGlzLmluc3RhbmNlcy5zZXQocmVzb2x2ZUlkZW50aWZpZXJUb2tlbihJZGVudGlmaWVycy5WaWV3Q29udGFpbmVyUmVmKS5yZWZlcmVuY2UsIHRoaXMuYXBwRWxlbWVudC5wcm9wKCd2Y1JlZicpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fcmVzb2x2ZWRQcm92aWRlcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgdGhpcy5fcmVzb2x2ZWRQcm92aWRlcnNBcnJheS5mb3JFYWNoKGZ1bmN0aW9uIChwcm92aWRlcikgeyByZXR1cm4gX3RoaXMuX3Jlc29sdmVkUHJvdmlkZXJzLnNldChwcm92aWRlci50b2tlbi5yZWZlcmVuY2UsIHByb3ZpZGVyKTsgfSk7XG4gICAgICAgICAgLy8gY3JlYXRlIGFsbCB0aGUgcHJvdmlkZXIgaW5zdGFuY2VzLCBzb21lIGluIHRoZSB2aWV3IGNvbnN0cnVjdG9yLFxuICAgICAgICAgIC8vIHNvbWUgYXMgZ2V0dGVycy4gV2UgcmVseSBvbiB0aGUgZmFjdCB0aGF0IHRoZXkgYXJlIGFscmVhZHkgc29ydGVkIHRvcG9sb2dpY2FsbHkuXG4gICAgICAgICAgTWFwV3JhcHBlci52YWx1ZXModGhpcy5fcmVzb2x2ZWRQcm92aWRlcnMpLmZvckVhY2goZnVuY3Rpb24gKHJlc29sdmVkUHJvdmlkZXIpIHtcbiAgICAgICAgICAgICAgdmFyIGlzRGlyZWN0aXZlV3JhcHBlciA9IHJlc29sdmVkUHJvdmlkZXIucHJvdmlkZXJUeXBlID09PSBleHBvcnRzLlByb3ZpZGVyQXN0VHlwZS5Db21wb25lbnQgfHxcbiAgICAgICAgICAgICAgICAgIHJlc29sdmVkUHJvdmlkZXIucHJvdmlkZXJUeXBlID09PSBleHBvcnRzLlByb3ZpZGVyQXN0VHlwZS5EaXJlY3RpdmU7XG4gICAgICAgICAgICAgIHZhciBwcm92aWRlclZhbHVlRXhwcmVzc2lvbnMgPSByZXNvbHZlZFByb3ZpZGVyLnByb3ZpZGVycy5tYXAoZnVuY3Rpb24gKHByb3ZpZGVyKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoaXNQcmVzZW50KHByb3ZpZGVyLnVzZUV4aXN0aW5nKSkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fZ2V0RGVwZW5kZW5jeShyZXNvbHZlZFByb3ZpZGVyLnByb3ZpZGVyVHlwZSwgbmV3IENvbXBpbGVEaURlcGVuZGVuY3lNZXRhZGF0YSh7IHRva2VuOiBwcm92aWRlci51c2VFeGlzdGluZyB9KSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBlbHNlIGlmIChpc1ByZXNlbnQocHJvdmlkZXIudXNlRmFjdG9yeSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVwcyA9IHByb3ZpZGVyLmRlcHMgfHwgcHJvdmlkZXIudXNlRmFjdG9yeS5kaURlcHM7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIGRlcHNFeHByID0gZGVwcy5tYXAoZnVuY3Rpb24gKGRlcCkgeyByZXR1cm4gX3RoaXMuX2dldERlcGVuZGVuY3kocmVzb2x2ZWRQcm92aWRlci5wcm92aWRlclR5cGUsIGRlcCk7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpbXBvcnRFeHByKHByb3ZpZGVyLnVzZUZhY3RvcnkpLmNhbGxGbihkZXBzRXhwcik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBlbHNlIGlmIChpc1ByZXNlbnQocHJvdmlkZXIudXNlQ2xhc3MpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIGRlcHMgPSBwcm92aWRlci5kZXBzIHx8IHByb3ZpZGVyLnVzZUNsYXNzLmRpRGVwcztcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVwc0V4cHIgPSBkZXBzLm1hcChmdW5jdGlvbiAoZGVwKSB7IHJldHVybiBfdGhpcy5fZ2V0RGVwZW5kZW5jeShyZXNvbHZlZFByb3ZpZGVyLnByb3ZpZGVyVHlwZSwgZGVwKTsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGlzRGlyZWN0aXZlV3JhcHBlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGlyZWN0aXZlV3JhcHBlcklkZW50aWZpZXIgPSBuZXcgQ29tcGlsZUlkZW50aWZpZXJNZXRhZGF0YSh7IG5hbWU6IERpcmVjdGl2ZVdyYXBwZXJDb21waWxlci5kaXJXcmFwcGVyQ2xhc3NOYW1lKHByb3ZpZGVyLnVzZUNsYXNzKSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3RhcmdldERlcGVuZGVuY2llcy5wdXNoKG5ldyBEaXJlY3RpdmVXcmFwcGVyRGVwZW5kZW5jeShwcm92aWRlci51c2VDbGFzcywgZGlyZWN0aXZlV3JhcHBlcklkZW50aWZpZXIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGltcG9ydEV4cHIoZGlyZWN0aXZlV3JhcHBlcklkZW50aWZpZXIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuaW5zdGFudGlhdGUoZGVwc0V4cHIsIGltcG9ydFR5cGUoZGlyZWN0aXZlV3JhcHBlcklkZW50aWZpZXIpKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpbXBvcnRFeHByKHByb3ZpZGVyLnVzZUNsYXNzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmluc3RhbnRpYXRlKGRlcHNFeHByLCBpbXBvcnRUeXBlKHByb3ZpZGVyLnVzZUNsYXNzKSk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnZlcnRWYWx1ZVRvT3V0cHV0QXN0KHByb3ZpZGVyLnVzZVZhbHVlKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHZhciBwcm9wTmFtZSA9IFwiX1wiICsgcmVzb2x2ZWRQcm92aWRlci50b2tlbi5uYW1lICsgXCJfXCIgKyBfdGhpcy5ub2RlSW5kZXggKyBcIl9cIiArIF90aGlzLmluc3RhbmNlcy5zaXplO1xuICAgICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBjcmVhdGVQcm92aWRlclByb3BlcnR5KHByb3BOYW1lLCByZXNvbHZlZFByb3ZpZGVyLCBwcm92aWRlclZhbHVlRXhwcmVzc2lvbnMsIHJlc29sdmVkUHJvdmlkZXIubXVsdGlQcm92aWRlciwgcmVzb2x2ZWRQcm92aWRlci5lYWdlciwgX3RoaXMpO1xuICAgICAgICAgICAgICBpZiAoaXNEaXJlY3RpdmVXcmFwcGVyKSB7XG4gICAgICAgICAgICAgICAgICBfdGhpcy5kaXJlY3RpdmVXcmFwcGVySW5zdGFuY2Uuc2V0KHJlc29sdmVkUHJvdmlkZXIudG9rZW4ucmVmZXJlbmNlLCBpbnN0YW5jZSk7XG4gICAgICAgICAgICAgICAgICBfdGhpcy5pbnN0YW5jZXMuc2V0KHJlc29sdmVkUHJvdmlkZXIudG9rZW4ucmVmZXJlbmNlLCBpbnN0YW5jZS5wcm9wKCdjb250ZXh0JykpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgX3RoaXMuaW5zdGFuY2VzLnNldChyZXNvbHZlZFByb3ZpZGVyLnRva2VuLnJlZmVyZW5jZSwgaW5zdGFuY2UpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9kaXJlY3RpdmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIHZhciBkaXJlY3RpdmUgPSB0aGlzLl9kaXJlY3RpdmVzW2ldO1xuICAgICAgICAgICAgICB2YXIgZGlyZWN0aXZlSW5zdGFuY2UgPSB0aGlzLmluc3RhbmNlcy5nZXQoaWRlbnRpZmllclRva2VuKGRpcmVjdGl2ZS50eXBlKS5yZWZlcmVuY2UpO1xuICAgICAgICAgICAgICBkaXJlY3RpdmUucXVlcmllcy5mb3JFYWNoKGZ1bmN0aW9uIChxdWVyeU1ldGEpIHsgX3RoaXMuX2FkZFF1ZXJ5KHF1ZXJ5TWV0YSwgZGlyZWN0aXZlSW5zdGFuY2UpOyB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHF1ZXJpZXNXaXRoUmVhZHMgPSBbXTtcbiAgICAgICAgICBNYXBXcmFwcGVyLnZhbHVlcyh0aGlzLl9yZXNvbHZlZFByb3ZpZGVycykuZm9yRWFjaChmdW5jdGlvbiAocmVzb2x2ZWRQcm92aWRlcikge1xuICAgICAgICAgICAgICB2YXIgcXVlcmllc0ZvclByb3ZpZGVyID0gX3RoaXMuX2dldFF1ZXJpZXNGb3IocmVzb2x2ZWRQcm92aWRlci50b2tlbik7XG4gICAgICAgICAgICAgIHF1ZXJpZXNXaXRoUmVhZHMucHVzaC5hcHBseShxdWVyaWVzV2l0aFJlYWRzLCBxdWVyaWVzRm9yUHJvdmlkZXIubWFwKGZ1bmN0aW9uIChxdWVyeSkgeyByZXR1cm4gbmV3IF9RdWVyeVdpdGhSZWFkKHF1ZXJ5LCByZXNvbHZlZFByb3ZpZGVyLnRva2VuKTsgfSkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIE9iamVjdC5rZXlzKHRoaXMucmVmZXJlbmNlVG9rZW5zKS5mb3JFYWNoKGZ1bmN0aW9uICh2YXJOYW1lKSB7XG4gICAgICAgICAgICAgIHZhciB0b2tlbiA9IF90aGlzLnJlZmVyZW5jZVRva2Vuc1t2YXJOYW1lXTtcbiAgICAgICAgICAgICAgdmFyIHZhclZhbHVlO1xuICAgICAgICAgICAgICBpZiAoaXNQcmVzZW50KHRva2VuKSkge1xuICAgICAgICAgICAgICAgICAgdmFyVmFsdWUgPSBfdGhpcy5pbnN0YW5jZXMuZ2V0KHRva2VuLnJlZmVyZW5jZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICB2YXJWYWx1ZSA9IF90aGlzLnJlbmRlck5vZGU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgX3RoaXMudmlldy5sb2NhbHMuc2V0KHZhck5hbWUsIHZhclZhbHVlKTtcbiAgICAgICAgICAgICAgdmFyIHZhclRva2VuID0gbmV3IENvbXBpbGVUb2tlbk1ldGFkYXRhKHsgdmFsdWU6IHZhck5hbWUgfSk7XG4gICAgICAgICAgICAgIHF1ZXJpZXNXaXRoUmVhZHMucHVzaC5hcHBseShxdWVyaWVzV2l0aFJlYWRzLCBfdGhpcy5fZ2V0UXVlcmllc0Zvcih2YXJUb2tlbikubWFwKGZ1bmN0aW9uIChxdWVyeSkgeyByZXR1cm4gbmV3IF9RdWVyeVdpdGhSZWFkKHF1ZXJ5LCB2YXJUb2tlbik7IH0pKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBxdWVyaWVzV2l0aFJlYWRzLmZvckVhY2goZnVuY3Rpb24gKHF1ZXJ5V2l0aFJlYWQpIHtcbiAgICAgICAgICAgICAgdmFyIHZhbHVlO1xuICAgICAgICAgICAgICBpZiAoaXNQcmVzZW50KHF1ZXJ5V2l0aFJlYWQucmVhZC5pZGVudGlmaWVyKSkge1xuICAgICAgICAgICAgICAgICAgLy8gcXVlcnkgZm9yIGFuIGlkZW50aWZpZXJcbiAgICAgICAgICAgICAgICAgIHZhbHVlID0gX3RoaXMuaW5zdGFuY2VzLmdldChxdWVyeVdpdGhSZWFkLnJlYWQucmVmZXJlbmNlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIC8vIHF1ZXJ5IGZvciBhIHJlZmVyZW5jZVxuICAgICAgICAgICAgICAgICAgdmFyIHRva2VuID0gX3RoaXMucmVmZXJlbmNlVG9rZW5zW3F1ZXJ5V2l0aFJlYWQucmVhZC52YWx1ZV07XG4gICAgICAgICAgICAgICAgICBpZiAoaXNQcmVzZW50KHRva2VuKSkge1xuICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gX3RoaXMuaW5zdGFuY2VzLmdldCh0b2tlbi5yZWZlcmVuY2UpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBfdGhpcy5lbGVtZW50UmVmO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChpc1ByZXNlbnQodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICBxdWVyeVdpdGhSZWFkLnF1ZXJ5LmFkZFZhbHVlKHZhbHVlLCBfdGhpcy52aWV3KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5jb21wb25lbnQpKSB7XG4gICAgICAgICAgICAgIHZhciBjb21wb25lbnRDb25zdHJ1Y3RvclZpZXdRdWVyeUxpc3QgPSBpc1ByZXNlbnQodGhpcy5jb21wb25lbnQpID9cbiAgICAgICAgICAgICAgICAgIGxpdGVyYWxBcnIodGhpcy5fY29tcG9uZW50Q29uc3RydWN0b3JWaWV3UXVlcnlMaXN0cykgOlxuICAgICAgICAgICAgICAgICAgTlVMTF9FWFBSO1xuICAgICAgICAgICAgICB2YXIgY29tcEV4cHIgPSBpc1ByZXNlbnQodGhpcy5nZXRDb21wb25lbnQoKSkgPyB0aGlzLmdldENvbXBvbmVudCgpIDogTlVMTF9FWFBSO1xuICAgICAgICAgICAgICB0aGlzLnZpZXcuY3JlYXRlTWV0aG9kLmFkZFN0bXQodGhpcy5hcHBFbGVtZW50XG4gICAgICAgICAgICAgICAgICAuY2FsbE1ldGhvZCgnaW5pdENvbXBvbmVudCcsIFtjb21wRXhwciwgY29tcG9uZW50Q29uc3RydWN0b3JWaWV3UXVlcnlMaXN0LCB0aGlzLl9jb21wVmlld0V4cHJdKVxuICAgICAgICAgICAgICAgICAgLnRvU3RtdCgpKTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgQ29tcGlsZUVsZW1lbnQucHJvdG90eXBlLmFmdGVyQ2hpbGRyZW4gPSBmdW5jdGlvbiAoY2hpbGROb2RlQ291bnQpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIE1hcFdyYXBwZXIudmFsdWVzKHRoaXMuX3Jlc29sdmVkUHJvdmlkZXJzKS5mb3JFYWNoKGZ1bmN0aW9uIChyZXNvbHZlZFByb3ZpZGVyKSB7XG4gICAgICAgICAgICAgIC8vIE5vdGU6IGFmdGVyQ2hpbGRyZW4gaXMgY2FsbGVkIGFmdGVyIHJlY3Vyc2luZyBpbnRvIGNoaWxkcmVuLlxuICAgICAgICAgICAgICAvLyBUaGlzIGlzIGdvb2Qgc28gdGhhdCBhbiBpbmplY3RvciBtYXRjaCBpbiBhbiBlbGVtZW50IHRoYXQgaXMgY2xvc2VyIHRvIGEgcmVxdWVzdGluZyBlbGVtZW50XG4gICAgICAgICAgICAgIC8vIG1hdGNoZXMgZmlyc3QuXG4gICAgICAgICAgICAgIHZhciBwcm92aWRlckV4cHIgPSBfdGhpcy5pbnN0YW5jZXMuZ2V0KHJlc29sdmVkUHJvdmlkZXIudG9rZW4ucmVmZXJlbmNlKTtcbiAgICAgICAgICAgICAgLy8gTm90ZTogdmlldyBwcm92aWRlcnMgYXJlIG9ubHkgdmlzaWJsZSBvbiB0aGUgaW5qZWN0b3Igb2YgdGhhdCBlbGVtZW50LlxuICAgICAgICAgICAgICAvLyBUaGlzIGlzIG5vdCBmdWxseSBjb3JyZWN0IGFzIHRoZSBydWxlcyBkdXJpbmcgY29kZWdlbiBkb24ndCBhbGxvdyBhIGRpcmVjdGl2ZVxuICAgICAgICAgICAgICAvLyB0byBnZXQgaG9sZCBvZiBhIHZpZXcgcHJvdmRpZXIgb24gdGhlIHNhbWUgZWxlbWVudC4gV2Ugc3RpbGwgZG8gdGhpcyBzZW1hbnRpY1xuICAgICAgICAgICAgICAvLyBhcyBpdCBzaW1wbGlmaWVzIG91ciBtb2RlbCB0byBoYXZpbmcgb25seSBvbmUgcnVudGltZSBpbmplY3RvciBwZXIgZWxlbWVudC5cbiAgICAgICAgICAgICAgdmFyIHByb3ZpZGVyQ2hpbGROb2RlQ291bnQgPSByZXNvbHZlZFByb3ZpZGVyLnByb3ZpZGVyVHlwZSA9PT0gZXhwb3J0cy5Qcm92aWRlckFzdFR5cGUuUHJpdmF0ZVNlcnZpY2UgPyAwIDogY2hpbGROb2RlQ291bnQ7XG4gICAgICAgICAgICAgIF90aGlzLnZpZXcuaW5qZWN0b3JHZXRNZXRob2QuYWRkU3RtdChjcmVhdGVJbmplY3RJbnRlcm5hbENvbmRpdGlvbihfdGhpcy5ub2RlSW5kZXgsIHByb3ZpZGVyQ2hpbGROb2RlQ291bnQsIHJlc29sdmVkUHJvdmlkZXIsIHByb3ZpZGVyRXhwcikpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIE1hcFdyYXBwZXIudmFsdWVzKHRoaXMuX3F1ZXJpZXMpXG4gICAgICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uIChxdWVyaWVzKSB7IHJldHVybiBxdWVyaWVzLmZvckVhY2goZnVuY3Rpb24gKHF1ZXJ5KSB7IHJldHVybiBxdWVyeS5hZnRlckNoaWxkcmVuKF90aGlzLnZpZXcuY3JlYXRlTWV0aG9kLCBfdGhpcy52aWV3LnVwZGF0ZUNvbnRlbnRRdWVyaWVzTWV0aG9kKTsgfSk7IH0pO1xuICAgICAgfTtcbiAgICAgIENvbXBpbGVFbGVtZW50LnByb3RvdHlwZS5hZGRDb250ZW50Tm9kZSA9IGZ1bmN0aW9uIChuZ0NvbnRlbnRJbmRleCwgbm9kZUV4cHIpIHtcbiAgICAgICAgICB0aGlzLmNvbnRlbnROb2Rlc0J5TmdDb250ZW50SW5kZXhbbmdDb250ZW50SW5kZXhdLnB1c2gobm9kZUV4cHIpO1xuICAgICAgfTtcbiAgICAgIENvbXBpbGVFbGVtZW50LnByb3RvdHlwZS5nZXRDb21wb25lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGlzUHJlc2VudCh0aGlzLmNvbXBvbmVudCkgP1xuICAgICAgICAgICAgICB0aGlzLmluc3RhbmNlcy5nZXQoaWRlbnRpZmllclRva2VuKHRoaXMuY29tcG9uZW50LnR5cGUpLnJlZmVyZW5jZSkgOlxuICAgICAgICAgICAgICBudWxsO1xuICAgICAgfTtcbiAgICAgIENvbXBpbGVFbGVtZW50LnByb3RvdHlwZS5nZXRQcm92aWRlclRva2VucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gTWFwV3JhcHBlci52YWx1ZXModGhpcy5fcmVzb2x2ZWRQcm92aWRlcnMpXG4gICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHJlc29sdmVkUHJvdmlkZXIpIHsgcmV0dXJuIGNyZWF0ZURpVG9rZW5FeHByZXNzaW9uKHJlc29sdmVkUHJvdmlkZXIudG9rZW4pOyB9KTtcbiAgICAgIH07XG4gICAgICBDb21waWxlRWxlbWVudC5wcm90b3R5cGUuX2dldFF1ZXJpZXNGb3IgPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgICAgdmFyIGN1cnJlbnRFbCA9IHRoaXM7XG4gICAgICAgICAgdmFyIGRpc3RhbmNlID0gMDtcbiAgICAgICAgICB2YXIgcXVlcmllcztcbiAgICAgICAgICB3aGlsZSAoIWN1cnJlbnRFbC5pc051bGwoKSkge1xuICAgICAgICAgICAgICBxdWVyaWVzID0gY3VycmVudEVsLl9xdWVyaWVzLmdldCh0b2tlbi5yZWZlcmVuY2UpO1xuICAgICAgICAgICAgICBpZiAoaXNQcmVzZW50KHF1ZXJpZXMpKSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHQucHVzaC5hcHBseShyZXN1bHQsIHF1ZXJpZXMuZmlsdGVyKGZ1bmN0aW9uIChxdWVyeSkgeyByZXR1cm4gcXVlcnkubWV0YS5kZXNjZW5kYW50cyB8fCBkaXN0YW5jZSA8PSAxOyB9KSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGN1cnJlbnRFbC5fZGlyZWN0aXZlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICBkaXN0YW5jZSsrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGN1cnJlbnRFbCA9IGN1cnJlbnRFbC5wYXJlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHF1ZXJpZXMgPSB0aGlzLnZpZXcuY29tcG9uZW50Vmlldy52aWV3UXVlcmllcy5nZXQodG9rZW4ucmVmZXJlbmNlKTtcbiAgICAgICAgICBpZiAoaXNQcmVzZW50KHF1ZXJpZXMpKSB7XG4gICAgICAgICAgICAgIHJlc3VsdC5wdXNoLmFwcGx5KHJlc3VsdCwgcXVlcmllcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgICAgQ29tcGlsZUVsZW1lbnQucHJvdG90eXBlLl9hZGRRdWVyeSA9IGZ1bmN0aW9uIChxdWVyeU1ldGEsIGRpcmVjdGl2ZUluc3RhbmNlKSB7XG4gICAgICAgICAgdmFyIHByb3BOYW1lID0gXCJfcXVlcnlfXCIgKyBxdWVyeU1ldGEuc2VsZWN0b3JzWzBdLm5hbWUgKyBcIl9cIiArIHRoaXMubm9kZUluZGV4ICsgXCJfXCIgKyB0aGlzLl9xdWVyeUNvdW50Kys7XG4gICAgICAgICAgdmFyIHF1ZXJ5TGlzdCA9IGNyZWF0ZVF1ZXJ5TGlzdChxdWVyeU1ldGEsIGRpcmVjdGl2ZUluc3RhbmNlLCBwcm9wTmFtZSwgdGhpcy52aWV3KTtcbiAgICAgICAgICB2YXIgcXVlcnkgPSBuZXcgQ29tcGlsZVF1ZXJ5KHF1ZXJ5TWV0YSwgcXVlcnlMaXN0LCBkaXJlY3RpdmVJbnN0YW5jZSwgdGhpcy52aWV3KTtcbiAgICAgICAgICBhZGRRdWVyeVRvVG9rZW5NYXAodGhpcy5fcXVlcmllcywgcXVlcnkpO1xuICAgICAgICAgIHJldHVybiBxdWVyeTtcbiAgICAgIH07XG4gICAgICBDb21waWxlRWxlbWVudC5wcm90b3R5cGUuX2dldExvY2FsRGVwZW5kZW5jeSA9IGZ1bmN0aW9uIChyZXF1ZXN0aW5nUHJvdmlkZXJUeXBlLCBkZXApIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgICAvLyBjb25zdHJ1Y3RvciBjb250ZW50IHF1ZXJ5XG4gICAgICAgICAgaWYgKCFyZXN1bHQgJiYgaXNQcmVzZW50KGRlcC5xdWVyeSkpIHtcbiAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5fYWRkUXVlcnkoZGVwLnF1ZXJ5LCBudWxsKS5xdWVyeUxpc3Q7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGNvbnN0cnVjdG9yIHZpZXcgcXVlcnlcbiAgICAgICAgICBpZiAoIXJlc3VsdCAmJiBpc1ByZXNlbnQoZGVwLnZpZXdRdWVyeSkpIHtcbiAgICAgICAgICAgICAgcmVzdWx0ID0gY3JlYXRlUXVlcnlMaXN0KGRlcC52aWV3UXVlcnksIG51bGwsIFwiX3ZpZXdRdWVyeV9cIiArIGRlcC52aWV3UXVlcnkuc2VsZWN0b3JzWzBdLm5hbWUgKyBcIl9cIiArIHRoaXMubm9kZUluZGV4ICsgXCJfXCIgKyB0aGlzLl9jb21wb25lbnRDb25zdHJ1Y3RvclZpZXdRdWVyeUxpc3RzLmxlbmd0aCwgdGhpcy52aWV3KTtcbiAgICAgICAgICAgICAgdGhpcy5fY29tcG9uZW50Q29uc3RydWN0b3JWaWV3UXVlcnlMaXN0cy5wdXNoKHJlc3VsdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc1ByZXNlbnQoZGVwLnRva2VuKSkge1xuICAgICAgICAgICAgICAvLyBhY2Nlc3MgYnVpbHRpbnMgd2l0aCBzcGVjaWFsIHZpc2liaWxpdHlcbiAgICAgICAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChkZXAudG9rZW4ucmVmZXJlbmNlID09PVxuICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVJZGVudGlmaWVyVG9rZW4oSWRlbnRpZmllcnMuQ2hhbmdlRGV0ZWN0b3JSZWYpLnJlZmVyZW5jZSkge1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0aW5nUHJvdmlkZXJUeXBlID09PSBleHBvcnRzLlByb3ZpZGVyQXN0VHlwZS5Db21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbXBWaWV3RXhwci5wcm9wKCdyZWYnKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRQcm9wZXJ0eUluVmlldyhUSElTX0VYUFIucHJvcCgncmVmJyksIHRoaXMudmlldywgdGhpcy52aWV3LmNvbXBvbmVudFZpZXcpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBhY2Nlc3MgcmVndWxhciBwcm92aWRlcnMgb24gdGhlIGVsZW1lbnRcbiAgICAgICAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgIHZhciByZXNvbHZlZFByb3ZpZGVyID0gdGhpcy5fcmVzb2x2ZWRQcm92aWRlcnMuZ2V0KGRlcC50b2tlbi5yZWZlcmVuY2UpO1xuICAgICAgICAgICAgICAgICAgLy8gZG9uJ3QgYWxsb3cgZGlyZWN0aXZlcyAvIHB1YmxpYyBzZXJ2aWNlcyB0byBhY2Nlc3MgcHJpdmF0ZSBzZXJ2aWNlcy5cbiAgICAgICAgICAgICAgICAgIC8vIG9ubHkgY29tcG9uZW50cyBhbmQgcHJpdmF0ZSBzZXJ2aWNlcyBjYW4gYWNjZXNzIHByaXZhdGUgc2VydmljZXMuXG4gICAgICAgICAgICAgICAgICBpZiAocmVzb2x2ZWRQcm92aWRlciAmJiAocmVxdWVzdGluZ1Byb3ZpZGVyVHlwZSA9PT0gZXhwb3J0cy5Qcm92aWRlckFzdFR5cGUuRGlyZWN0aXZlIHx8XG4gICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdGluZ1Byb3ZpZGVyVHlwZSA9PT0gZXhwb3J0cy5Qcm92aWRlckFzdFR5cGUuUHVibGljU2VydmljZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlZFByb3ZpZGVyLnByb3ZpZGVyVHlwZSA9PT0gZXhwb3J0cy5Qcm92aWRlckFzdFR5cGUuUHJpdmF0ZVNlcnZpY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuaW5zdGFuY2VzLmdldChkZXAudG9rZW4ucmVmZXJlbmNlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICAgIENvbXBpbGVFbGVtZW50LnByb3RvdHlwZS5fZ2V0RGVwZW5kZW5jeSA9IGZ1bmN0aW9uIChyZXF1ZXN0aW5nUHJvdmlkZXJUeXBlLCBkZXApIHtcbiAgICAgICAgICB2YXIgY3VyckVsZW1lbnQgPSB0aGlzO1xuICAgICAgICAgIHZhciByZXN1bHQgPSBudWxsO1xuICAgICAgICAgIGlmIChkZXAuaXNWYWx1ZSkge1xuICAgICAgICAgICAgICByZXN1bHQgPSBsaXRlcmFsKGRlcC52YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghcmVzdWx0ICYmICFkZXAuaXNTa2lwU2VsZikge1xuICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLl9nZXRMb2NhbERlcGVuZGVuY3kocmVxdWVzdGluZ1Byb3ZpZGVyVHlwZSwgZGVwKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gY2hlY2sgcGFyZW50IGVsZW1lbnRzXG4gICAgICAgICAgd2hpbGUgKCFyZXN1bHQgJiYgIWN1cnJFbGVtZW50LnBhcmVudC5pc051bGwoKSkge1xuICAgICAgICAgICAgICBjdXJyRWxlbWVudCA9IGN1cnJFbGVtZW50LnBhcmVudDtcbiAgICAgICAgICAgICAgcmVzdWx0ID0gY3VyckVsZW1lbnQuX2dldExvY2FsRGVwZW5kZW5jeShleHBvcnRzLlByb3ZpZGVyQXN0VHlwZS5QdWJsaWNTZXJ2aWNlLCBuZXcgQ29tcGlsZURpRGVwZW5kZW5jeU1ldGFkYXRhKHsgdG9rZW46IGRlcC50b2tlbiB9KSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICAgIHJlc3VsdCA9IGluamVjdEZyb21WaWV3UGFyZW50SW5qZWN0b3IoZGVwLnRva2VuLCBkZXAuaXNPcHRpb25hbCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICAgIHJlc3VsdCA9IE5VTExfRVhQUjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGdldFByb3BlcnR5SW5WaWV3KHJlc3VsdCwgdGhpcy52aWV3LCBjdXJyRWxlbWVudC52aWV3KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gQ29tcGlsZUVsZW1lbnQ7XG4gIH0oQ29tcGlsZU5vZGUpKTtcbiAgZnVuY3Rpb24gY3JlYXRlSW5qZWN0SW50ZXJuYWxDb25kaXRpb24obm9kZUluZGV4LCBjaGlsZE5vZGVDb3VudCwgcHJvdmlkZXIsIHByb3ZpZGVyRXhwcikge1xuICAgICAgdmFyIGluZGV4Q29uZGl0aW9uO1xuICAgICAgaWYgKGNoaWxkTm9kZUNvdW50ID4gMCkge1xuICAgICAgICAgIGluZGV4Q29uZGl0aW9uID0gbGl0ZXJhbChub2RlSW5kZXgpXG4gICAgICAgICAgICAgIC5sb3dlckVxdWFscyhJbmplY3RNZXRob2RWYXJzLnJlcXVlc3ROb2RlSW5kZXgpXG4gICAgICAgICAgICAgIC5hbmQoSW5qZWN0TWV0aG9kVmFycy5yZXF1ZXN0Tm9kZUluZGV4Lmxvd2VyRXF1YWxzKGxpdGVyYWwobm9kZUluZGV4ICsgY2hpbGROb2RlQ291bnQpKSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgICBpbmRleENvbmRpdGlvbiA9IGxpdGVyYWwobm9kZUluZGV4KS5pZGVudGljYWwoSW5qZWN0TWV0aG9kVmFycy5yZXF1ZXN0Tm9kZUluZGV4KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgSWZTdG10KEluamVjdE1ldGhvZFZhcnMudG9rZW4uaWRlbnRpY2FsKGNyZWF0ZURpVG9rZW5FeHByZXNzaW9uKHByb3ZpZGVyLnRva2VuKSkuYW5kKGluZGV4Q29uZGl0aW9uKSwgW25ldyBSZXR1cm5TdGF0ZW1lbnQocHJvdmlkZXJFeHByKV0pO1xuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZVByb3ZpZGVyUHJvcGVydHkocHJvcE5hbWUsIHByb3ZpZGVyLCBwcm92aWRlclZhbHVlRXhwcmVzc2lvbnMsIGlzTXVsdGksIGlzRWFnZXIsIGNvbXBpbGVFbGVtZW50KSB7XG4gICAgICB2YXIgdmlldyA9IGNvbXBpbGVFbGVtZW50LnZpZXc7XG4gICAgICB2YXIgcmVzb2x2ZWRQcm92aWRlclZhbHVlRXhwcjtcbiAgICAgIHZhciB0eXBlO1xuICAgICAgaWYgKGlzTXVsdGkpIHtcbiAgICAgICAgICByZXNvbHZlZFByb3ZpZGVyVmFsdWVFeHByID0gbGl0ZXJhbEFycihwcm92aWRlclZhbHVlRXhwcmVzc2lvbnMpO1xuICAgICAgICAgIHR5cGUgPSBuZXcgQXJyYXlUeXBlKERZTkFNSUNfVFlQRSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgICByZXNvbHZlZFByb3ZpZGVyVmFsdWVFeHByID0gcHJvdmlkZXJWYWx1ZUV4cHJlc3Npb25zWzBdO1xuICAgICAgICAgIHR5cGUgPSBwcm92aWRlclZhbHVlRXhwcmVzc2lvbnNbMF0udHlwZTtcbiAgICAgIH1cbiAgICAgIGlmICghdHlwZSkge1xuICAgICAgICAgIHR5cGUgPSBEWU5BTUlDX1RZUEU7XG4gICAgICB9XG4gICAgICBpZiAoaXNFYWdlcikge1xuICAgICAgICAgIHZpZXcuZmllbGRzLnB1c2gobmV3IENsYXNzRmllbGQocHJvcE5hbWUsIHR5cGUpKTtcbiAgICAgICAgICB2aWV3LmNyZWF0ZU1ldGhvZC5hZGRTdG10KFRISVNfRVhQUi5wcm9wKHByb3BOYW1lKS5zZXQocmVzb2x2ZWRQcm92aWRlclZhbHVlRXhwcikudG9TdG10KCkpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICAgdmFyIGludGVybmFsRmllbGQgPSBcIl9cIiArIHByb3BOYW1lO1xuICAgICAgICAgIHZpZXcuZmllbGRzLnB1c2gobmV3IENsYXNzRmllbGQoaW50ZXJuYWxGaWVsZCwgdHlwZSkpO1xuICAgICAgICAgIHZhciBnZXR0ZXIgPSBuZXcgQ29tcGlsZU1ldGhvZCh2aWV3KTtcbiAgICAgICAgICBnZXR0ZXIucmVzZXREZWJ1Z0luZm8oY29tcGlsZUVsZW1lbnQubm9kZUluZGV4LCBjb21waWxlRWxlbWVudC5zb3VyY2VBc3QpO1xuICAgICAgICAgIC8vIE5vdGU6IEVxdWFscyBpcyBpbXBvcnRhbnQgZm9yIEpTIHNvIHRoYXQgaXQgYWxzbyBjaGVja3MgdGhlIHVuZGVmaW5lZCBjYXNlIVxuICAgICAgICAgIGdldHRlci5hZGRTdG10KG5ldyBJZlN0bXQoVEhJU19FWFBSLnByb3AoaW50ZXJuYWxGaWVsZCkuaXNCbGFuaygpLCBbVEhJU19FWFBSLnByb3AoaW50ZXJuYWxGaWVsZCkuc2V0KHJlc29sdmVkUHJvdmlkZXJWYWx1ZUV4cHIpLnRvU3RtdCgpXSkpO1xuICAgICAgICAgIGdldHRlci5hZGRTdG10KG5ldyBSZXR1cm5TdGF0ZW1lbnQoVEhJU19FWFBSLnByb3AoaW50ZXJuYWxGaWVsZCkpKTtcbiAgICAgICAgICB2aWV3LmdldHRlcnMucHVzaChuZXcgQ2xhc3NHZXR0ZXIocHJvcE5hbWUsIGdldHRlci5maW5pc2goKSwgdHlwZSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFRISVNfRVhQUi5wcm9wKHByb3BOYW1lKTtcbiAgfVxuICB2YXIgX1F1ZXJ5V2l0aFJlYWQgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gX1F1ZXJ5V2l0aFJlYWQocXVlcnksIG1hdGNoKSB7XG4gICAgICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5O1xuICAgICAgICAgIHRoaXMucmVhZCA9IHF1ZXJ5Lm1ldGEucmVhZCB8fCBtYXRjaDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfUXVlcnlXaXRoUmVhZDtcbiAgfSgpKTtcblxuICB2YXIgQ29tcGlsZVBpcGUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gQ29tcGlsZVBpcGUodmlldywgbWV0YSkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgICB0aGlzLm1ldGEgPSBtZXRhO1xuICAgICAgICAgIHRoaXMuX3B1cmVQaXBlUHJveHlDb3VudCA9IDA7XG4gICAgICAgICAgdGhpcy5pbnN0YW5jZSA9IFRISVNfRVhQUi5wcm9wKFwiX3BpcGVfXCIgKyBtZXRhLm5hbWUgKyBcIl9cIiArIHZpZXcucGlwZUNvdW50KyspO1xuICAgICAgICAgIHZhciBkZXBzID0gdGhpcy5tZXRhLnR5cGUuZGlEZXBzLm1hcChmdW5jdGlvbiAoZGlEZXApIHtcbiAgICAgICAgICAgICAgaWYgKGRpRGVwLnRva2VuLnJlZmVyZW5jZSA9PT1cbiAgICAgICAgICAgICAgICAgIHJlc29sdmVJZGVudGlmaWVyVG9rZW4oSWRlbnRpZmllcnMuQ2hhbmdlRGV0ZWN0b3JSZWYpLnJlZmVyZW5jZSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldFByb3BlcnR5SW5WaWV3KFRISVNfRVhQUi5wcm9wKCdyZWYnKSwgX3RoaXMudmlldywgX3RoaXMudmlldy5jb21wb25lbnRWaWV3KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gaW5qZWN0RnJvbVZpZXdQYXJlbnRJbmplY3RvcihkaURlcC50b2tlbiwgZmFsc2UpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRoaXMudmlldy5maWVsZHMucHVzaChuZXcgQ2xhc3NGaWVsZCh0aGlzLmluc3RhbmNlLm5hbWUsIGltcG9ydFR5cGUodGhpcy5tZXRhLnR5cGUpKSk7XG4gICAgICAgICAgdGhpcy52aWV3LmNyZWF0ZU1ldGhvZC5yZXNldERlYnVnSW5mbyhudWxsLCBudWxsKTtcbiAgICAgICAgICB0aGlzLnZpZXcuY3JlYXRlTWV0aG9kLmFkZFN0bXQoVEhJU19FWFBSLnByb3AodGhpcy5pbnN0YW5jZS5uYW1lKVxuICAgICAgICAgICAgICAuc2V0KGltcG9ydEV4cHIodGhpcy5tZXRhLnR5cGUpLmluc3RhbnRpYXRlKGRlcHMpKVxuICAgICAgICAgICAgICAudG9TdG10KCkpO1xuICAgICAgfVxuICAgICAgQ29tcGlsZVBpcGUuY2FsbCA9IGZ1bmN0aW9uICh2aWV3LCBuYW1lLCBhcmdzKSB7XG4gICAgICAgICAgdmFyIGNvbXBWaWV3ID0gdmlldy5jb21wb25lbnRWaWV3O1xuICAgICAgICAgIHZhciBtZXRhID0gX2ZpbmRQaXBlTWV0YShjb21wVmlldywgbmFtZSk7XG4gICAgICAgICAgdmFyIHBpcGU7XG4gICAgICAgICAgaWYgKG1ldGEucHVyZSkge1xuICAgICAgICAgICAgICAvLyBwdXJlIHBpcGVzIGxpdmUgb24gdGhlIGNvbXBvbmVudCB2aWV3XG4gICAgICAgICAgICAgIHBpcGUgPSBjb21wVmlldy5wdXJlUGlwZXMuZ2V0KG5hbWUpO1xuICAgICAgICAgICAgICBpZiAoIXBpcGUpIHtcbiAgICAgICAgICAgICAgICAgIHBpcGUgPSBuZXcgQ29tcGlsZVBpcGUoY29tcFZpZXcsIG1ldGEpO1xuICAgICAgICAgICAgICAgICAgY29tcFZpZXcucHVyZVBpcGVzLnNldChuYW1lLCBwaXBlKTtcbiAgICAgICAgICAgICAgICAgIGNvbXBWaWV3LnBpcGVzLnB1c2gocGlwZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIC8vIE5vbiBwdXJlIHBpcGVzIGxpdmUgb24gdGhlIHZpZXcgdGhhdCBjYWxsZWQgaXRcbiAgICAgICAgICAgICAgcGlwZSA9IG5ldyBDb21waWxlUGlwZSh2aWV3LCBtZXRhKTtcbiAgICAgICAgICAgICAgdmlldy5waXBlcy5wdXNoKHBpcGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcGlwZS5fY2FsbCh2aWV3LCBhcmdzKTtcbiAgICAgIH07XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tcGlsZVBpcGUucHJvdG90eXBlLCBcInB1cmVcIiwge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5tZXRhLnB1cmU7IH0sXG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgICAgQ29tcGlsZVBpcGUucHJvdG90eXBlLl9jYWxsID0gZnVuY3Rpb24gKGNhbGxpbmdWaWV3LCBhcmdzKSB7XG4gICAgICAgICAgaWYgKHRoaXMubWV0YS5wdXJlKSB7XG4gICAgICAgICAgICAgIC8vIFB1cmVQaXBlUHJveGllcyBsaXZlIG9uIHRoZSB2aWV3IHRoYXQgY2FsbGVkIHRoZW0uXG4gICAgICAgICAgICAgIHZhciBwdXJlUGlwZVByb3h5SW5zdGFuY2UgPSBUSElTX0VYUFIucHJvcCh0aGlzLmluc3RhbmNlLm5hbWUgKyBcIl9cIiArIHRoaXMuX3B1cmVQaXBlUHJveHlDb3VudCsrKTtcbiAgICAgICAgICAgICAgdmFyIHBpcGVJbnN0YW5jZVNlZW5Gcm9tUHVyZVByb3h5ID0gZ2V0UHJvcGVydHlJblZpZXcodGhpcy5pbnN0YW5jZSwgY2FsbGluZ1ZpZXcsIHRoaXMudmlldyk7XG4gICAgICAgICAgICAgIGNyZWF0ZVB1cmVQcm94eShwaXBlSW5zdGFuY2VTZWVuRnJvbVB1cmVQcm94eS5wcm9wKCd0cmFuc2Zvcm0nKVxuICAgICAgICAgICAgICAgICAgLmNhbGxNZXRob2QoQnVpbHRpbk1ldGhvZC5CaW5kLCBbcGlwZUluc3RhbmNlU2VlbkZyb21QdXJlUHJveHldKSwgYXJncy5sZW5ndGgsIHB1cmVQaXBlUHJveHlJbnN0YW5jZSwgeyBmaWVsZHM6IGNhbGxpbmdWaWV3LmZpZWxkcywgY3RvclN0bXRzOiBjYWxsaW5nVmlldy5jcmVhdGVNZXRob2QgfSk7XG4gICAgICAgICAgICAgIHJldHVybiBpbXBvcnRFeHByKHJlc29sdmVJZGVudGlmaWVyKElkZW50aWZpZXJzLmNhc3RCeVZhbHVlKSlcbiAgICAgICAgICAgICAgICAgIC5jYWxsRm4oW3B1cmVQaXBlUHJveHlJbnN0YW5jZSwgcGlwZUluc3RhbmNlU2VlbkZyb21QdXJlUHJveHkucHJvcCgndHJhbnNmb3JtJyldKVxuICAgICAgICAgICAgICAgICAgLmNhbGxGbihhcmdzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBnZXRQcm9wZXJ0eUluVmlldyh0aGlzLmluc3RhbmNlLCBjYWxsaW5nVmlldywgdGhpcy52aWV3KS5jYWxsTWV0aG9kKCd0cmFuc2Zvcm0nLCBhcmdzKTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgcmV0dXJuIENvbXBpbGVQaXBlO1xuICB9KCkpO1xuICBmdW5jdGlvbiBfZmluZFBpcGVNZXRhKHZpZXcsIG5hbWUpIHtcbiAgICAgIHZhciBwaXBlTWV0YSA9IG51bGw7XG4gICAgICBmb3IgKHZhciBpID0gdmlldy5waXBlTWV0YXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICB2YXIgbG9jYWxQaXBlTWV0YSA9IHZpZXcucGlwZU1ldGFzW2ldO1xuICAgICAgICAgIGlmIChsb2NhbFBpcGVNZXRhLm5hbWUgPT0gbmFtZSkge1xuICAgICAgICAgICAgICBwaXBlTWV0YSA9IGxvY2FsUGlwZU1ldGE7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghcGlwZU1ldGEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbGxlZ2FsIHN0YXRlOiBDb3VsZCBub3QgZmluZCBwaXBlIFwiICsgbmFtZSArIFwiIGFsdGhvdWdoIHRoZSBwYXJzZXIgc2hvdWxkIGhhdmUgZGV0ZWN0ZWQgdGhpcyBlcnJvciFcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGlwZU1ldGE7XG4gIH1cblxuICB2YXIgQ29tcGlsZVZpZXcgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gQ29tcGlsZVZpZXcoY29tcG9uZW50LCBnZW5Db25maWcsIHBpcGVNZXRhcywgc3R5bGVzLCBhbmltYXRpb25zLCB2aWV3SW5kZXgsIGRlY2xhcmF0aW9uRWxlbWVudCwgdGVtcGxhdGVWYXJpYWJsZUJpbmRpbmdzKSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICB0aGlzLmNvbXBvbmVudCA9IGNvbXBvbmVudDtcbiAgICAgICAgICB0aGlzLmdlbkNvbmZpZyA9IGdlbkNvbmZpZztcbiAgICAgICAgICB0aGlzLnBpcGVNZXRhcyA9IHBpcGVNZXRhcztcbiAgICAgICAgICB0aGlzLnN0eWxlcyA9IHN0eWxlcztcbiAgICAgICAgICB0aGlzLmFuaW1hdGlvbnMgPSBhbmltYXRpb25zO1xuICAgICAgICAgIHRoaXMudmlld0luZGV4ID0gdmlld0luZGV4O1xuICAgICAgICAgIHRoaXMuZGVjbGFyYXRpb25FbGVtZW50ID0gZGVjbGFyYXRpb25FbGVtZW50O1xuICAgICAgICAgIHRoaXMudGVtcGxhdGVWYXJpYWJsZUJpbmRpbmdzID0gdGVtcGxhdGVWYXJpYWJsZUJpbmRpbmdzO1xuICAgICAgICAgIHRoaXMubm9kZXMgPSBbXTtcbiAgICAgICAgICAvLyByb290IG5vZGVzIG9yIEFwcEVsZW1lbnRzIGZvciBWaWV3Q29udGFpbmVyc1xuICAgICAgICAgIHRoaXMucm9vdE5vZGVzT3JBcHBFbGVtZW50cyA9IFtdO1xuICAgICAgICAgIHRoaXMubWV0aG9kcyA9IFtdO1xuICAgICAgICAgIHRoaXMuY3RvclN0bXRzID0gW107XG4gICAgICAgICAgdGhpcy5maWVsZHMgPSBbXTtcbiAgICAgICAgICB0aGlzLmdldHRlcnMgPSBbXTtcbiAgICAgICAgICB0aGlzLmRpc3Bvc2FibGVzID0gW107XG4gICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zID0gW107XG4gICAgICAgICAgdGhpcy5wdXJlUGlwZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgdGhpcy5waXBlcyA9IFtdO1xuICAgICAgICAgIHRoaXMubG9jYWxzID0gbmV3IE1hcCgpO1xuICAgICAgICAgIHRoaXMubGl0ZXJhbEFycmF5Q291bnQgPSAwO1xuICAgICAgICAgIHRoaXMubGl0ZXJhbE1hcENvdW50ID0gMDtcbiAgICAgICAgICB0aGlzLnBpcGVDb3VudCA9IDA7XG4gICAgICAgICAgdGhpcy5jcmVhdGVNZXRob2QgPSBuZXcgQ29tcGlsZU1ldGhvZCh0aGlzKTtcbiAgICAgICAgICB0aGlzLmFuaW1hdGlvbkJpbmRpbmdzTWV0aG9kID0gbmV3IENvbXBpbGVNZXRob2QodGhpcyk7XG4gICAgICAgICAgdGhpcy5pbmplY3RvckdldE1ldGhvZCA9IG5ldyBDb21waWxlTWV0aG9kKHRoaXMpO1xuICAgICAgICAgIHRoaXMudXBkYXRlQ29udGVudFF1ZXJpZXNNZXRob2QgPSBuZXcgQ29tcGlsZU1ldGhvZCh0aGlzKTtcbiAgICAgICAgICB0aGlzLmRpcnR5UGFyZW50UXVlcmllc01ldGhvZCA9IG5ldyBDb21waWxlTWV0aG9kKHRoaXMpO1xuICAgICAgICAgIHRoaXMudXBkYXRlVmlld1F1ZXJpZXNNZXRob2QgPSBuZXcgQ29tcGlsZU1ldGhvZCh0aGlzKTtcbiAgICAgICAgICB0aGlzLmRldGVjdENoYW5nZXNJbklucHV0c01ldGhvZCA9IG5ldyBDb21waWxlTWV0aG9kKHRoaXMpO1xuICAgICAgICAgIHRoaXMuZGV0ZWN0Q2hhbmdlc1JlbmRlclByb3BlcnRpZXNNZXRob2QgPSBuZXcgQ29tcGlsZU1ldGhvZCh0aGlzKTtcbiAgICAgICAgICB0aGlzLmFmdGVyQ29udGVudExpZmVjeWNsZUNhbGxiYWNrc01ldGhvZCA9IG5ldyBDb21waWxlTWV0aG9kKHRoaXMpO1xuICAgICAgICAgIHRoaXMuYWZ0ZXJWaWV3TGlmZWN5Y2xlQ2FsbGJhY2tzTWV0aG9kID0gbmV3IENvbXBpbGVNZXRob2QodGhpcyk7XG4gICAgICAgICAgdGhpcy5kZXN0cm95TWV0aG9kID0gbmV3IENvbXBpbGVNZXRob2QodGhpcyk7XG4gICAgICAgICAgdGhpcy5kZXRhY2hNZXRob2QgPSBuZXcgQ29tcGlsZU1ldGhvZCh0aGlzKTtcbiAgICAgICAgICB0aGlzLnZpZXdUeXBlID0gZ2V0Vmlld1R5cGUoY29tcG9uZW50LCB2aWV3SW5kZXgpO1xuICAgICAgICAgIHRoaXMuY2xhc3NOYW1lID0gXCJfVmlld19cIiArIGNvbXBvbmVudC50eXBlLm5hbWUgKyB2aWV3SW5kZXg7XG4gICAgICAgICAgdGhpcy5jbGFzc1R5cGUgPSBpbXBvcnRUeXBlKG5ldyBDb21waWxlSWRlbnRpZmllck1ldGFkYXRhKHsgbmFtZTogdGhpcy5jbGFzc05hbWUgfSkpO1xuICAgICAgICAgIHRoaXMudmlld0ZhY3RvcnkgPSB2YXJpYWJsZShnZXRWaWV3RmFjdG9yeU5hbWUoY29tcG9uZW50LCB2aWV3SW5kZXgpKTtcbiAgICAgICAgICBpZiAodGhpcy52aWV3VHlwZSA9PT0gVmlld1R5cGUuQ09NUE9ORU5UIHx8IHRoaXMudmlld1R5cGUgPT09IFZpZXdUeXBlLkhPU1QpIHtcbiAgICAgICAgICAgICAgdGhpcy5jb21wb25lbnRWaWV3ID0gdGhpcztcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuY29tcG9uZW50VmlldyA9IHRoaXMuZGVjbGFyYXRpb25FbGVtZW50LnZpZXcuY29tcG9uZW50VmlldztcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5jb21wb25lbnRDb250ZXh0ID1cbiAgICAgICAgICAgICAgZ2V0UHJvcGVydHlJblZpZXcoVEhJU19FWFBSLnByb3AoJ2NvbnRleHQnKSwgdGhpcywgdGhpcy5jb21wb25lbnRWaWV3KTtcbiAgICAgICAgICB2YXIgdmlld1F1ZXJpZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgaWYgKHRoaXMudmlld1R5cGUgPT09IFZpZXdUeXBlLkNPTVBPTkVOVCkge1xuICAgICAgICAgICAgICB2YXIgZGlyZWN0aXZlSW5zdGFuY2UgPSBUSElTX0VYUFIucHJvcCgnY29udGV4dCcpO1xuICAgICAgICAgICAgICB0aGlzLmNvbXBvbmVudC52aWV3UXVlcmllcy5mb3JFYWNoKGZ1bmN0aW9uIChxdWVyeU1ldGEsIHF1ZXJ5SW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBwcm9wTmFtZSA9IFwiX3ZpZXdRdWVyeV9cIiArIHF1ZXJ5TWV0YS5zZWxlY3RvcnNbMF0ubmFtZSArIFwiX1wiICsgcXVlcnlJbmRleDtcbiAgICAgICAgICAgICAgICAgIHZhciBxdWVyeUxpc3QgPSBjcmVhdGVRdWVyeUxpc3QocXVlcnlNZXRhLCBkaXJlY3RpdmVJbnN0YW5jZSwgcHJvcE5hbWUsIF90aGlzKTtcbiAgICAgICAgICAgICAgICAgIHZhciBxdWVyeSA9IG5ldyBDb21waWxlUXVlcnkocXVlcnlNZXRhLCBxdWVyeUxpc3QsIGRpcmVjdGl2ZUluc3RhbmNlLCBfdGhpcyk7XG4gICAgICAgICAgICAgICAgICBhZGRRdWVyeVRvVG9rZW5NYXAodmlld1F1ZXJpZXMsIHF1ZXJ5KTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHZhciBjb25zdHJ1Y3RvclZpZXdRdWVyeUNvdW50ID0gMDtcbiAgICAgICAgICAgICAgdGhpcy5jb21wb25lbnQudHlwZS5kaURlcHMuZm9yRWFjaChmdW5jdGlvbiAoZGVwKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoaXNQcmVzZW50KGRlcC52aWV3UXVlcnkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIHF1ZXJ5TGlzdCA9IFRISVNfRVhQUi5wcm9wKCdkZWNsYXJhdGlvbkFwcEVsZW1lbnQnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAucHJvcCgnY29tcG9uZW50Q29uc3RydWN0b3JWaWV3UXVlcmllcycpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC5rZXkobGl0ZXJhbChjb25zdHJ1Y3RvclZpZXdRdWVyeUNvdW50KyspKTtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgcXVlcnkgPSBuZXcgQ29tcGlsZVF1ZXJ5KGRlcC52aWV3UXVlcnksIHF1ZXJ5TGlzdCwgbnVsbCwgX3RoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgIGFkZFF1ZXJ5VG9Ub2tlbk1hcCh2aWV3UXVlcmllcywgcXVlcnkpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy52aWV3UXVlcmllcyA9IHZpZXdRdWVyaWVzO1xuICAgICAgICAgIHRlbXBsYXRlVmFyaWFibGVCaW5kaW5ncy5mb3JFYWNoKGZ1bmN0aW9uIChlbnRyeSkgeyBfdGhpcy5sb2NhbHMuc2V0KGVudHJ5WzFdLCBUSElTX0VYUFIucHJvcCgnY29udGV4dCcpLnByb3AoZW50cnlbMF0pKTsgfSk7XG4gICAgICAgICAgaWYgKCF0aGlzLmRlY2xhcmF0aW9uRWxlbWVudC5pc051bGwoKSkge1xuICAgICAgICAgICAgICB0aGlzLmRlY2xhcmF0aW9uRWxlbWVudC5zZXRFbWJlZGRlZFZpZXcodGhpcyk7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgQ29tcGlsZVZpZXcucHJvdG90eXBlLmNhbGxQaXBlID0gZnVuY3Rpb24gKG5hbWUsIGlucHV0LCBhcmdzKSB7XG4gICAgICAgICAgcmV0dXJuIENvbXBpbGVQaXBlLmNhbGwodGhpcywgbmFtZSwgW2lucHV0XS5jb25jYXQoYXJncykpO1xuICAgICAgfTtcbiAgICAgIENvbXBpbGVWaWV3LnByb3RvdHlwZS5nZXRMb2NhbCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgaWYgKG5hbWUgPT0gRXZlbnRIYW5kbGVyVmFycy5ldmVudC5uYW1lKSB7XG4gICAgICAgICAgICAgIHJldHVybiBFdmVudEhhbmRsZXJWYXJzLmV2ZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgY3VyclZpZXcgPSB0aGlzO1xuICAgICAgICAgIHZhciByZXN1bHQgPSBjdXJyVmlldy5sb2NhbHMuZ2V0KG5hbWUpO1xuICAgICAgICAgIHdoaWxlICghcmVzdWx0ICYmIGlzUHJlc2VudChjdXJyVmlldy5kZWNsYXJhdGlvbkVsZW1lbnQudmlldykpIHtcbiAgICAgICAgICAgICAgY3VyclZpZXcgPSBjdXJyVmlldy5kZWNsYXJhdGlvbkVsZW1lbnQudmlldztcbiAgICAgICAgICAgICAgcmVzdWx0ID0gY3VyclZpZXcubG9jYWxzLmdldChuYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzUHJlc2VudChyZXN1bHQpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBnZXRQcm9wZXJ0eUluVmlldyhyZXN1bHQsIHRoaXMsIGN1cnJWaWV3KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICBDb21waWxlVmlldy5wcm90b3R5cGUuYWZ0ZXJOb2RlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIE1hcFdyYXBwZXIudmFsdWVzKHRoaXMudmlld1F1ZXJpZXMpXG4gICAgICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uIChxdWVyaWVzKSB7IHJldHVybiBxdWVyaWVzLmZvckVhY2goZnVuY3Rpb24gKHF1ZXJ5KSB7IHJldHVybiBxdWVyeS5hZnRlckNoaWxkcmVuKF90aGlzLmNyZWF0ZU1ldGhvZCwgX3RoaXMudXBkYXRlVmlld1F1ZXJpZXNNZXRob2QpOyB9KTsgfSk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIENvbXBpbGVWaWV3O1xuICB9KCkpO1xuICBmdW5jdGlvbiBnZXRWaWV3VHlwZShjb21wb25lbnQsIGVtYmVkZGVkVGVtcGxhdGVJbmRleCkge1xuICAgICAgaWYgKGVtYmVkZGVkVGVtcGxhdGVJbmRleCA+IDApIHtcbiAgICAgICAgICByZXR1cm4gVmlld1R5cGUuRU1CRURERUQ7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChjb21wb25lbnQudHlwZS5pc0hvc3QpIHtcbiAgICAgICAgICByZXR1cm4gVmlld1R5cGUuSE9TVDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAgIHJldHVybiBWaWV3VHlwZS5DT01QT05FTlQ7XG4gICAgICB9XG4gIH1cblxuICB2YXIgQ29tcGlsZUV2ZW50TGlzdGVuZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gQ29tcGlsZUV2ZW50TGlzdGVuZXIoY29tcGlsZUVsZW1lbnQsIGV2ZW50VGFyZ2V0LCBldmVudE5hbWUsIGV2ZW50UGhhc2UsIGxpc3RlbmVySW5kZXgpIHtcbiAgICAgICAgICB0aGlzLmNvbXBpbGVFbGVtZW50ID0gY29tcGlsZUVsZW1lbnQ7XG4gICAgICAgICAgdGhpcy5ldmVudFRhcmdldCA9IGV2ZW50VGFyZ2V0O1xuICAgICAgICAgIHRoaXMuZXZlbnROYW1lID0gZXZlbnROYW1lO1xuICAgICAgICAgIHRoaXMuZXZlbnRQaGFzZSA9IGV2ZW50UGhhc2U7XG4gICAgICAgICAgdGhpcy5faGFzQ29tcG9uZW50SG9zdExpc3RlbmVyID0gZmFsc2U7XG4gICAgICAgICAgdGhpcy5fYWN0aW9uUmVzdWx0RXhwcnMgPSBbXTtcbiAgICAgICAgICB0aGlzLl9tZXRob2QgPSBuZXcgQ29tcGlsZU1ldGhvZChjb21waWxlRWxlbWVudC52aWV3KTtcbiAgICAgICAgICB0aGlzLl9tZXRob2ROYW1lID1cbiAgICAgICAgICAgICAgXCJfaGFuZGxlX1wiICsgc2FuaXRpemVFdmVudE5hbWUoZXZlbnROYW1lKSArIFwiX1wiICsgY29tcGlsZUVsZW1lbnQubm9kZUluZGV4ICsgXCJfXCIgKyBsaXN0ZW5lckluZGV4O1xuICAgICAgICAgIHRoaXMuX2V2ZW50UGFyYW0gPSBuZXcgRm5QYXJhbShFdmVudEhhbmRsZXJWYXJzLmV2ZW50Lm5hbWUsIGltcG9ydFR5cGUodGhpcy5jb21waWxlRWxlbWVudC52aWV3LmdlbkNvbmZpZy5yZW5kZXJUeXBlcy5yZW5kZXJFdmVudCkpO1xuICAgICAgfVxuICAgICAgQ29tcGlsZUV2ZW50TGlzdGVuZXIuZ2V0T3JDcmVhdGUgPSBmdW5jdGlvbiAoY29tcGlsZUVsZW1lbnQsIGV2ZW50VGFyZ2V0LCBldmVudE5hbWUsIGV2ZW50UGhhc2UsIHRhcmdldEV2ZW50TGlzdGVuZXJzKSB7XG4gICAgICAgICAgdmFyIGxpc3RlbmVyID0gdGFyZ2V0RXZlbnRMaXN0ZW5lcnMuZmluZChmdW5jdGlvbiAobGlzdGVuZXIpIHsgcmV0dXJuIGxpc3RlbmVyLmV2ZW50VGFyZ2V0ID09IGV2ZW50VGFyZ2V0ICYmIGxpc3RlbmVyLmV2ZW50TmFtZSA9PSBldmVudE5hbWUgJiZcbiAgICAgICAgICAgICAgbGlzdGVuZXIuZXZlbnRQaGFzZSA9PSBldmVudFBoYXNlOyB9KTtcbiAgICAgICAgICBpZiAoIWxpc3RlbmVyKSB7XG4gICAgICAgICAgICAgIGxpc3RlbmVyID0gbmV3IENvbXBpbGVFdmVudExpc3RlbmVyKGNvbXBpbGVFbGVtZW50LCBldmVudFRhcmdldCwgZXZlbnROYW1lLCBldmVudFBoYXNlLCB0YXJnZXRFdmVudExpc3RlbmVycy5sZW5ndGgpO1xuICAgICAgICAgICAgICB0YXJnZXRFdmVudExpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGxpc3RlbmVyO1xuICAgICAgfTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21waWxlRXZlbnRMaXN0ZW5lci5wcm90b3R5cGUsIFwibWV0aG9kTmFtZVwiLCB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9tZXRob2ROYW1lOyB9LFxuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21waWxlRXZlbnRMaXN0ZW5lci5wcm90b3R5cGUsIFwiaXNBbmltYXRpb25cIiwge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gISF0aGlzLmV2ZW50UGhhc2U7IH0sXG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgICAgQ29tcGlsZUV2ZW50TGlzdGVuZXIucHJvdG90eXBlLmFkZEFjdGlvbiA9IGZ1bmN0aW9uIChob3N0RXZlbnQsIGRpcmVjdGl2ZSwgZGlyZWN0aXZlSW5zdGFuY2UpIHtcbiAgICAgICAgICBpZiAoaXNQcmVzZW50KGRpcmVjdGl2ZSkgJiYgZGlyZWN0aXZlLmlzQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAgIHRoaXMuX2hhc0NvbXBvbmVudEhvc3RMaXN0ZW5lciA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX21ldGhvZC5yZXNldERlYnVnSW5mbyh0aGlzLmNvbXBpbGVFbGVtZW50Lm5vZGVJbmRleCwgaG9zdEV2ZW50KTtcbiAgICAgICAgICB2YXIgY29udGV4dCA9IGRpcmVjdGl2ZUluc3RhbmNlIHx8IHRoaXMuY29tcGlsZUVsZW1lbnQudmlldy5jb21wb25lbnRDb250ZXh0O1xuICAgICAgICAgIHZhciB2aWV3ID0gdGhpcy5jb21waWxlRWxlbWVudC52aWV3O1xuICAgICAgICAgIHZhciBldmFsUmVzdWx0ID0gY29udmVydEFjdGlvbkJpbmRpbmcodmlldywgZGlyZWN0aXZlID8gbnVsbCA6IHZpZXcsIGNvbnRleHQsIGhvc3RFdmVudC5oYW5kbGVyLCB0aGlzLmNvbXBpbGVFbGVtZW50Lm5vZGVJbmRleCArIFwiX1wiICsgdGhpcy5fYWN0aW9uUmVzdWx0RXhwcnMubGVuZ3RoKTtcbiAgICAgICAgICBpZiAoZXZhbFJlc3VsdC5wcmV2ZW50RGVmYXVsdCkge1xuICAgICAgICAgICAgICB0aGlzLl9hY3Rpb25SZXN1bHRFeHBycy5wdXNoKGV2YWxSZXN1bHQucHJldmVudERlZmF1bHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9tZXRob2QuYWRkU3RtdHMoZXZhbFJlc3VsdC5zdG10cyk7XG4gICAgICB9O1xuICAgICAgQ29tcGlsZUV2ZW50TGlzdGVuZXIucHJvdG90eXBlLmZpbmlzaE1ldGhvZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgbWFya1BhdGhUb1Jvb3RTdGFydCA9IHRoaXMuX2hhc0NvbXBvbmVudEhvc3RMaXN0ZW5lciA/XG4gICAgICAgICAgICAgIHRoaXMuY29tcGlsZUVsZW1lbnQuYXBwRWxlbWVudC5wcm9wKCdjb21wb25lbnRWaWV3JykgOlxuICAgICAgICAgICAgICBUSElTX0VYUFI7XG4gICAgICAgICAgdmFyIHJlc3VsdEV4cHIgPSBsaXRlcmFsKHRydWUpO1xuICAgICAgICAgIHRoaXMuX2FjdGlvblJlc3VsdEV4cHJzLmZvckVhY2goZnVuY3Rpb24gKGV4cHIpIHsgcmVzdWx0RXhwciA9IHJlc3VsdEV4cHIuYW5kKGV4cHIpOyB9KTtcbiAgICAgICAgICB2YXIgc3RtdHMgPSBbbWFya1BhdGhUb1Jvb3RTdGFydC5jYWxsTWV0aG9kKCdtYXJrUGF0aFRvUm9vdEFzQ2hlY2tPbmNlJywgW10pLnRvU3RtdCgpXVxuICAgICAgICAgICAgICAuY29uY2F0KHRoaXMuX21ldGhvZC5maW5pc2goKSlcbiAgICAgICAgICAgICAgLmNvbmNhdChbbmV3IFJldHVyblN0YXRlbWVudChyZXN1bHRFeHByKV0pO1xuICAgICAgICAgIC8vIHByaXZhdGUgaXMgZmluZSBoZXJlIGFzIG5vIGNoaWxkIHZpZXcgd2lsbCByZWZlcmVuY2UgdGhlIGV2ZW50IGhhbmRsZXIuLi5cbiAgICAgICAgICB0aGlzLmNvbXBpbGVFbGVtZW50LnZpZXcubWV0aG9kcy5wdXNoKG5ldyBDbGFzc01ldGhvZCh0aGlzLl9tZXRob2ROYW1lLCBbdGhpcy5fZXZlbnRQYXJhbV0sIHN0bXRzLCBCT09MX1RZUEUsIFtTdG10TW9kaWZpZXIuUHJpdmF0ZV0pKTtcbiAgICAgIH07XG4gICAgICBDb21waWxlRXZlbnRMaXN0ZW5lci5wcm90b3R5cGUubGlzdGVuVG9SZW5kZXJlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgbGlzdGVuRXhwcjtcbiAgICAgICAgICB2YXIgZXZlbnRMaXN0ZW5lciA9IFRISVNfRVhQUi5jYWxsTWV0aG9kKCdldmVudEhhbmRsZXInLCBbVEhJU19FWFBSLnByb3AodGhpcy5fbWV0aG9kTmFtZSkuY2FsbE1ldGhvZChCdWlsdGluTWV0aG9kLkJpbmQsIFtUSElTX0VYUFJdKV0pO1xuICAgICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5ldmVudFRhcmdldCkpIHtcbiAgICAgICAgICAgICAgbGlzdGVuRXhwciA9IFZpZXdQcm9wZXJ0aWVzLnJlbmRlcmVyLmNhbGxNZXRob2QoJ2xpc3Rlbkdsb2JhbCcsIFtsaXRlcmFsKHRoaXMuZXZlbnRUYXJnZXQpLCBsaXRlcmFsKHRoaXMuZXZlbnROYW1lKSwgZXZlbnRMaXN0ZW5lcl0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgbGlzdGVuRXhwciA9IFZpZXdQcm9wZXJ0aWVzLnJlbmRlcmVyLmNhbGxNZXRob2QoJ2xpc3RlbicsIFt0aGlzLmNvbXBpbGVFbGVtZW50LnJlbmRlck5vZGUsIGxpdGVyYWwodGhpcy5ldmVudE5hbWUpLCBldmVudExpc3RlbmVyXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBkaXNwb3NhYmxlID0gdmFyaWFibGUoXCJkaXNwb3NhYmxlX1wiICsgdGhpcy5jb21waWxlRWxlbWVudC52aWV3LmRpc3Bvc2FibGVzLmxlbmd0aCk7XG4gICAgICAgICAgdGhpcy5jb21waWxlRWxlbWVudC52aWV3LmRpc3Bvc2FibGVzLnB1c2goZGlzcG9zYWJsZSk7XG4gICAgICAgICAgLy8gcHJpdmF0ZSBpcyBmaW5lIGhlcmUgYXMgbm8gY2hpbGQgdmlldyB3aWxsIHJlZmVyZW5jZSB0aGUgZXZlbnQgaGFuZGxlci4uLlxuICAgICAgICAgIHRoaXMuY29tcGlsZUVsZW1lbnQudmlldy5jcmVhdGVNZXRob2QuYWRkU3RtdChkaXNwb3NhYmxlLnNldChsaXN0ZW5FeHByKS50b0RlY2xTdG10KEZVTkNUSU9OX1RZUEUsIFtTdG10TW9kaWZpZXIuUHJpdmF0ZV0pKTtcbiAgICAgIH07XG4gICAgICBDb21waWxlRXZlbnRMaXN0ZW5lci5wcm90b3R5cGUubGlzdGVuVG9BbmltYXRpb24gPSBmdW5jdGlvbiAoYW5pbWF0aW9uVHJhbnNpdGlvblZhcikge1xuICAgICAgICAgIHZhciBjYWxsYmFja01ldGhvZCA9IHRoaXMuZXZlbnRQaGFzZSA9PSAnc3RhcnQnID8gJ29uU3RhcnQnIDogJ29uRG9uZSc7XG4gICAgICAgICAgcmV0dXJuIGFuaW1hdGlvblRyYW5zaXRpb25WYXJcbiAgICAgICAgICAgICAgLmNhbGxNZXRob2QoY2FsbGJhY2tNZXRob2QsIFtUSElTX0VYUFIucHJvcCh0aGlzLm1ldGhvZE5hbWUpLmNhbGxNZXRob2QoQnVpbHRpbk1ldGhvZC5CaW5kLCBbVEhJU19FWFBSXSldKVxuICAgICAgICAgICAgICAudG9TdG10KCk7XG4gICAgICB9O1xuICAgICAgQ29tcGlsZUV2ZW50TGlzdGVuZXIucHJvdG90eXBlLmxpc3RlblRvRGlyZWN0aXZlID0gZnVuY3Rpb24gKGRpcmVjdGl2ZUluc3RhbmNlLCBvYnNlcnZhYmxlUHJvcE5hbWUpIHtcbiAgICAgICAgICB2YXIgc3Vic2NyaXB0aW9uID0gdmFyaWFibGUoXCJzdWJzY3JpcHRpb25fXCIgKyB0aGlzLmNvbXBpbGVFbGVtZW50LnZpZXcuc3Vic2NyaXB0aW9ucy5sZW5ndGgpO1xuICAgICAgICAgIHRoaXMuY29tcGlsZUVsZW1lbnQudmlldy5zdWJzY3JpcHRpb25zLnB1c2goc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgICB2YXIgZXZlbnRMaXN0ZW5lciA9IFRISVNfRVhQUi5jYWxsTWV0aG9kKCdldmVudEhhbmRsZXInLCBbVEhJU19FWFBSLnByb3AodGhpcy5fbWV0aG9kTmFtZSkuY2FsbE1ldGhvZChCdWlsdGluTWV0aG9kLkJpbmQsIFtUSElTX0VYUFJdKV0pO1xuICAgICAgICAgIHRoaXMuY29tcGlsZUVsZW1lbnQudmlldy5jcmVhdGVNZXRob2QuYWRkU3RtdChzdWJzY3JpcHRpb25cbiAgICAgICAgICAgICAgLnNldChkaXJlY3RpdmVJbnN0YW5jZS5wcm9wKG9ic2VydmFibGVQcm9wTmFtZSlcbiAgICAgICAgICAgICAgLmNhbGxNZXRob2QoQnVpbHRpbk1ldGhvZC5TdWJzY3JpYmVPYnNlcnZhYmxlLCBbZXZlbnRMaXN0ZW5lcl0pKVxuICAgICAgICAgICAgICAudG9EZWNsU3RtdChudWxsLCBbU3RtdE1vZGlmaWVyLkZpbmFsXSkpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBDb21waWxlRXZlbnRMaXN0ZW5lcjtcbiAgfSgpKTtcbiAgZnVuY3Rpb24gY29sbGVjdEV2ZW50TGlzdGVuZXJzKGhvc3RFdmVudHMsIGRpcnMsIGNvbXBpbGVFbGVtZW50KSB7XG4gICAgICB2YXIgZXZlbnRMaXN0ZW5lcnMgPSBbXTtcbiAgICAgIGhvc3RFdmVudHMuZm9yRWFjaChmdW5jdGlvbiAoaG9zdEV2ZW50KSB7XG4gICAgICAgICAgdmFyIGxpc3RlbmVyID0gQ29tcGlsZUV2ZW50TGlzdGVuZXIuZ2V0T3JDcmVhdGUoY29tcGlsZUVsZW1lbnQsIGhvc3RFdmVudC50YXJnZXQsIGhvc3RFdmVudC5uYW1lLCBob3N0RXZlbnQucGhhc2UsIGV2ZW50TGlzdGVuZXJzKTtcbiAgICAgICAgICBsaXN0ZW5lci5hZGRBY3Rpb24oaG9zdEV2ZW50LCBudWxsLCBudWxsKTtcbiAgICAgIH0pO1xuICAgICAgZGlycy5mb3JFYWNoKGZ1bmN0aW9uIChkaXJlY3RpdmVBc3QpIHtcbiAgICAgICAgICB2YXIgZGlyZWN0aXZlSW5zdGFuY2UgPSBjb21waWxlRWxlbWVudC5pbnN0YW5jZXMuZ2V0KGlkZW50aWZpZXJUb2tlbihkaXJlY3RpdmVBc3QuZGlyZWN0aXZlLnR5cGUpLnJlZmVyZW5jZSk7XG4gICAgICAgICAgZGlyZWN0aXZlQXN0Lmhvc3RFdmVudHMuZm9yRWFjaChmdW5jdGlvbiAoaG9zdEV2ZW50KSB7XG4gICAgICAgICAgICAgIHZhciBsaXN0ZW5lciA9IENvbXBpbGVFdmVudExpc3RlbmVyLmdldE9yQ3JlYXRlKGNvbXBpbGVFbGVtZW50LCBob3N0RXZlbnQudGFyZ2V0LCBob3N0RXZlbnQubmFtZSwgaG9zdEV2ZW50LnBoYXNlLCBldmVudExpc3RlbmVycyk7XG4gICAgICAgICAgICAgIGxpc3RlbmVyLmFkZEFjdGlvbihob3N0RXZlbnQsIGRpcmVjdGl2ZUFzdC5kaXJlY3RpdmUsIGRpcmVjdGl2ZUluc3RhbmNlKTtcbiAgICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgZXZlbnRMaXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbiAobGlzdGVuZXIpIHsgcmV0dXJuIGxpc3RlbmVyLmZpbmlzaE1ldGhvZCgpOyB9KTtcbiAgICAgIHJldHVybiBldmVudExpc3RlbmVycztcbiAgfVxuICBmdW5jdGlvbiBiaW5kRGlyZWN0aXZlT3V0cHV0cyhkaXJlY3RpdmVBc3QsIGRpcmVjdGl2ZUluc3RhbmNlLCBldmVudExpc3RlbmVycykge1xuICAgICAgT2JqZWN0LmtleXMoZGlyZWN0aXZlQXN0LmRpcmVjdGl2ZS5vdXRwdXRzKS5mb3JFYWNoKGZ1bmN0aW9uIChvYnNlcnZhYmxlUHJvcE5hbWUpIHtcbiAgICAgICAgICB2YXIgZXZlbnROYW1lID0gZGlyZWN0aXZlQXN0LmRpcmVjdGl2ZS5vdXRwdXRzW29ic2VydmFibGVQcm9wTmFtZV07XG4gICAgICAgICAgZXZlbnRMaXN0ZW5lcnMuZmlsdGVyKGZ1bmN0aW9uIChsaXN0ZW5lcikgeyByZXR1cm4gbGlzdGVuZXIuZXZlbnROYW1lID09IGV2ZW50TmFtZTsgfSkuZm9yRWFjaChmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgbGlzdGVuZXIubGlzdGVuVG9EaXJlY3RpdmUoZGlyZWN0aXZlSW5zdGFuY2UsIG9ic2VydmFibGVQcm9wTmFtZSk7XG4gICAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBiaW5kUmVuZGVyT3V0cHV0cyhldmVudExpc3RlbmVycykge1xuICAgICAgZXZlbnRMaXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICAgICAgICAvLyB0aGUgYW5pbWF0aW9uIGxpc3RlbmVycyBhcmUgaGFuZGxlZCB3aXRoaW4gcHJvcGVydHlfYmluZGVyLnRzIHRvXG4gICAgICAgICAgLy8gYWxsb3cgdGhlbSB0byBiZSBwbGFjZWQgbmV4dCB0byB0aGUgYW5pbWF0aW9uIGZhY3Rvcnkgc3RhdGVtZW50c1xuICAgICAgICAgIGlmICghbGlzdGVuZXIuaXNBbmltYXRpb24pIHtcbiAgICAgICAgICAgICAgbGlzdGVuZXIubGlzdGVuVG9SZW5kZXJlcigpO1xuICAgICAgICAgIH1cbiAgICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIHNhbml0aXplRXZlbnROYW1lKG5hbWUpIHtcbiAgICAgIHJldHVybiBuYW1lLnJlcGxhY2UoL1teYS16QS1aX10vZywgJ18nKTtcbiAgfVxuXG4gIHZhciBTVEFURV9JU19ORVZFUl9DSEVDS0VEID0gVEhJU19FWFBSLnByb3AoJ251bWJlck9mQ2hlY2tzJykuaWRlbnRpY2FsKG5ldyBMaXRlcmFsRXhwcigwKSk7XG4gIHZhciBOT1RfVEhST1dfT05fQ0hBTkdFUyA9IG5vdChEZXRlY3RDaGFuZ2VzVmFycy50aHJvd09uQ2hhbmdlKTtcbiAgZnVuY3Rpb24gYmluZERpcmVjdGl2ZUFmdGVyQ29udGVudExpZmVjeWNsZUNhbGxiYWNrcyhkaXJlY3RpdmVNZXRhLCBkaXJlY3RpdmVJbnN0YW5jZSwgY29tcGlsZUVsZW1lbnQpIHtcbiAgICAgIHZhciB2aWV3ID0gY29tcGlsZUVsZW1lbnQudmlldztcbiAgICAgIHZhciBsaWZlY3ljbGVIb29rcyA9IGRpcmVjdGl2ZU1ldGEudHlwZS5saWZlY3ljbGVIb29rcztcbiAgICAgIHZhciBhZnRlckNvbnRlbnRMaWZlY3ljbGVDYWxsYmFja3NNZXRob2QgPSB2aWV3LmFmdGVyQ29udGVudExpZmVjeWNsZUNhbGxiYWNrc01ldGhvZDtcbiAgICAgIGFmdGVyQ29udGVudExpZmVjeWNsZUNhbGxiYWNrc01ldGhvZC5yZXNldERlYnVnSW5mbyhjb21waWxlRWxlbWVudC5ub2RlSW5kZXgsIGNvbXBpbGVFbGVtZW50LnNvdXJjZUFzdCk7XG4gICAgICBpZiAobGlmZWN5Y2xlSG9va3MuaW5kZXhPZihMaWZlY3ljbGVIb29rcy5BZnRlckNvbnRlbnRJbml0KSAhPT0gLTEpIHtcbiAgICAgICAgICBhZnRlckNvbnRlbnRMaWZlY3ljbGVDYWxsYmFja3NNZXRob2QuYWRkU3RtdChuZXcgSWZTdG10KFNUQVRFX0lTX05FVkVSX0NIRUNLRUQsIFtkaXJlY3RpdmVJbnN0YW5jZS5jYWxsTWV0aG9kKCduZ0FmdGVyQ29udGVudEluaXQnLCBbXSkudG9TdG10KCldKSk7XG4gICAgICB9XG4gICAgICBpZiAobGlmZWN5Y2xlSG9va3MuaW5kZXhPZihMaWZlY3ljbGVIb29rcy5BZnRlckNvbnRlbnRDaGVja2VkKSAhPT0gLTEpIHtcbiAgICAgICAgICBhZnRlckNvbnRlbnRMaWZlY3ljbGVDYWxsYmFja3NNZXRob2QuYWRkU3RtdChkaXJlY3RpdmVJbnN0YW5jZS5jYWxsTWV0aG9kKCduZ0FmdGVyQ29udGVudENoZWNrZWQnLCBbXSkudG9TdG10KCkpO1xuICAgICAgfVxuICB9XG4gIGZ1bmN0aW9uIGJpbmREaXJlY3RpdmVBZnRlclZpZXdMaWZlY3ljbGVDYWxsYmFja3MoZGlyZWN0aXZlTWV0YSwgZGlyZWN0aXZlSW5zdGFuY2UsIGNvbXBpbGVFbGVtZW50KSB7XG4gICAgICB2YXIgdmlldyA9IGNvbXBpbGVFbGVtZW50LnZpZXc7XG4gICAgICB2YXIgbGlmZWN5Y2xlSG9va3MgPSBkaXJlY3RpdmVNZXRhLnR5cGUubGlmZWN5Y2xlSG9va3M7XG4gICAgICB2YXIgYWZ0ZXJWaWV3TGlmZWN5Y2xlQ2FsbGJhY2tzTWV0aG9kID0gdmlldy5hZnRlclZpZXdMaWZlY3ljbGVDYWxsYmFja3NNZXRob2Q7XG4gICAgICBhZnRlclZpZXdMaWZlY3ljbGVDYWxsYmFja3NNZXRob2QucmVzZXREZWJ1Z0luZm8oY29tcGlsZUVsZW1lbnQubm9kZUluZGV4LCBjb21waWxlRWxlbWVudC5zb3VyY2VBc3QpO1xuICAgICAgaWYgKGxpZmVjeWNsZUhvb2tzLmluZGV4T2YoTGlmZWN5Y2xlSG9va3MuQWZ0ZXJWaWV3SW5pdCkgIT09IC0xKSB7XG4gICAgICAgICAgYWZ0ZXJWaWV3TGlmZWN5Y2xlQ2FsbGJhY2tzTWV0aG9kLmFkZFN0bXQobmV3IElmU3RtdChTVEFURV9JU19ORVZFUl9DSEVDS0VELCBbZGlyZWN0aXZlSW5zdGFuY2UuY2FsbE1ldGhvZCgnbmdBZnRlclZpZXdJbml0JywgW10pLnRvU3RtdCgpXSkpO1xuICAgICAgfVxuICAgICAgaWYgKGxpZmVjeWNsZUhvb2tzLmluZGV4T2YoTGlmZWN5Y2xlSG9va3MuQWZ0ZXJWaWV3Q2hlY2tlZCkgIT09IC0xKSB7XG4gICAgICAgICAgYWZ0ZXJWaWV3TGlmZWN5Y2xlQ2FsbGJhY2tzTWV0aG9kLmFkZFN0bXQoZGlyZWN0aXZlSW5zdGFuY2UuY2FsbE1ldGhvZCgnbmdBZnRlclZpZXdDaGVja2VkJywgW10pLnRvU3RtdCgpKTtcbiAgICAgIH1cbiAgfVxuICBmdW5jdGlvbiBiaW5kSW5qZWN0YWJsZURlc3Ryb3lMaWZlY3ljbGVDYWxsYmFja3MocHJvdmlkZXIsIHByb3ZpZGVySW5zdGFuY2UsIGNvbXBpbGVFbGVtZW50KSB7XG4gICAgICB2YXIgb25EZXN0cm95TWV0aG9kID0gY29tcGlsZUVsZW1lbnQudmlldy5kZXN0cm95TWV0aG9kO1xuICAgICAgb25EZXN0cm95TWV0aG9kLnJlc2V0RGVidWdJbmZvKGNvbXBpbGVFbGVtZW50Lm5vZGVJbmRleCwgY29tcGlsZUVsZW1lbnQuc291cmNlQXN0KTtcbiAgICAgIGlmIChwcm92aWRlci5saWZlY3ljbGVIb29rcy5pbmRleE9mKExpZmVjeWNsZUhvb2tzLk9uRGVzdHJveSkgIT09IC0xKSB7XG4gICAgICAgICAgb25EZXN0cm95TWV0aG9kLmFkZFN0bXQocHJvdmlkZXJJbnN0YW5jZS5jYWxsTWV0aG9kKCduZ09uRGVzdHJveScsIFtdKS50b1N0bXQoKSk7XG4gICAgICB9XG4gIH1cbiAgZnVuY3Rpb24gYmluZFBpcGVEZXN0cm95TGlmZWN5Y2xlQ2FsbGJhY2tzKHBpcGVNZXRhLCBwaXBlSW5zdGFuY2UsIHZpZXcpIHtcbiAgICAgIHZhciBvbkRlc3Ryb3lNZXRob2QgPSB2aWV3LmRlc3Ryb3lNZXRob2Q7XG4gICAgICBpZiAocGlwZU1ldGEudHlwZS5saWZlY3ljbGVIb29rcy5pbmRleE9mKExpZmVjeWNsZUhvb2tzLk9uRGVzdHJveSkgIT09IC0xKSB7XG4gICAgICAgICAgb25EZXN0cm95TWV0aG9kLmFkZFN0bXQocGlwZUluc3RhbmNlLmNhbGxNZXRob2QoJ25nT25EZXN0cm95JywgW10pLnRvU3RtdCgpKTtcbiAgICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGJpbmRSZW5kZXJUZXh0KGJvdW5kVGV4dCwgY29tcGlsZU5vZGUsIHZpZXcpIHtcbiAgICAgIHZhciB2YWx1ZUZpZWxkID0gY3JlYXRlQ2hlY2tCaW5kaW5nRmllbGQodmlldyk7XG4gICAgICB2YXIgZXZhbFJlc3VsdCA9IGNvbnZlcnRQcm9wZXJ0eUJpbmRpbmcodmlldywgdmlldywgdmlldy5jb21wb25lbnRDb250ZXh0LCBib3VuZFRleHQudmFsdWUsIHZhbHVlRmllbGQuYmluZGluZ0lkKTtcbiAgICAgIGlmICghZXZhbFJlc3VsdCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgdmlldy5kZXRlY3RDaGFuZ2VzUmVuZGVyUHJvcGVydGllc01ldGhvZC5yZXNldERlYnVnSW5mbyhjb21waWxlTm9kZS5ub2RlSW5kZXgsIGJvdW5kVGV4dCk7XG4gICAgICB2aWV3LmRldGVjdENoYW5nZXNSZW5kZXJQcm9wZXJ0aWVzTWV0aG9kLmFkZFN0bXRzKGNyZWF0ZUNoZWNrQmluZGluZ1N0bXQoZXZhbFJlc3VsdCwgdmFsdWVGaWVsZC5leHByZXNzaW9uLCBEZXRlY3RDaGFuZ2VzVmFycy50aHJvd09uQ2hhbmdlLCBbVEhJU19FWFBSLnByb3AoJ3JlbmRlcmVyJylcbiAgICAgICAgICAgICAgLmNhbGxNZXRob2QoJ3NldFRleHQnLCBbY29tcGlsZU5vZGUucmVuZGVyTm9kZSwgZXZhbFJlc3VsdC5jdXJyVmFsRXhwcl0pXG4gICAgICAgICAgICAgIC50b1N0bXQoKV0pKTtcbiAgfVxuICBmdW5jdGlvbiBiaW5kQW5kV3JpdGVUb1JlbmRlcmVyKGJvdW5kUHJvcHMsIGNvbnRleHQsIGNvbXBpbGVFbGVtZW50LCBpc0hvc3RQcm9wLCBldmVudExpc3RlbmVycykge1xuICAgICAgdmFyIHZpZXcgPSBjb21waWxlRWxlbWVudC52aWV3O1xuICAgICAgdmFyIHJlbmRlck5vZGUgPSBjb21waWxlRWxlbWVudC5yZW5kZXJOb2RlO1xuICAgICAgYm91bmRQcm9wcy5mb3JFYWNoKGZ1bmN0aW9uIChib3VuZFByb3ApIHtcbiAgICAgICAgICB2YXIgYmluZGluZ0ZpZWxkID0gY3JlYXRlQ2hlY2tCaW5kaW5nRmllbGQodmlldyk7XG4gICAgICAgICAgdmlldy5kZXRlY3RDaGFuZ2VzUmVuZGVyUHJvcGVydGllc01ldGhvZC5yZXNldERlYnVnSW5mbyhjb21waWxlRWxlbWVudC5ub2RlSW5kZXgsIGJvdW5kUHJvcCk7XG4gICAgICAgICAgdmFyIGV2YWxSZXN1bHQgPSBjb252ZXJ0UHJvcGVydHlCaW5kaW5nKHZpZXcsIGlzSG9zdFByb3AgPyBudWxsIDogdmlldywgY29udGV4dCwgYm91bmRQcm9wLnZhbHVlLCBiaW5kaW5nRmllbGQuYmluZGluZ0lkKTtcbiAgICAgICAgICB2YXIgdXBkYXRlU3RtdHMgPSBbXTtcbiAgICAgICAgICB2YXIgY29tcGlsZU1ldGhvZCA9IHZpZXcuZGV0ZWN0Q2hhbmdlc1JlbmRlclByb3BlcnRpZXNNZXRob2Q7XG4gICAgICAgICAgc3dpdGNoIChib3VuZFByb3AudHlwZSkge1xuICAgICAgICAgICAgICBjYXNlIGV4cG9ydHMuUHJvcGVydHlCaW5kaW5nVHlwZS5Qcm9wZXJ0eTpcbiAgICAgICAgICAgICAgY2FzZSBleHBvcnRzLlByb3BlcnR5QmluZGluZ1R5cGUuQXR0cmlidXRlOlxuICAgICAgICAgICAgICBjYXNlIGV4cG9ydHMuUHJvcGVydHlCaW5kaW5nVHlwZS5DbGFzczpcbiAgICAgICAgICAgICAgY2FzZSBleHBvcnRzLlByb3BlcnR5QmluZGluZ1R5cGUuU3R5bGU6XG4gICAgICAgICAgICAgICAgICB1cGRhdGVTdG10cy5wdXNoLmFwcGx5KHVwZGF0ZVN0bXRzLCB3cml0ZVRvUmVuZGVyZXIoVEhJU19FWFBSLCBib3VuZFByb3AsIHJlbmRlck5vZGUsIGV2YWxSZXN1bHQuY3VyclZhbEV4cHIsIHZpZXcuZ2VuQ29uZmlnLmxvZ0JpbmRpbmdVcGRhdGUpKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIGV4cG9ydHMuUHJvcGVydHlCaW5kaW5nVHlwZS5BbmltYXRpb246XG4gICAgICAgICAgICAgICAgICBjb21waWxlTWV0aG9kID0gdmlldy5hbmltYXRpb25CaW5kaW5nc01ldGhvZDtcbiAgICAgICAgICAgICAgICAgIHZhciBkZXRhY2hTdG10c18xID0gW107XG4gICAgICAgICAgICAgICAgICB2YXIgYW5pbWF0aW9uTmFtZV8xID0gYm91bmRQcm9wLm5hbWU7XG4gICAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0Vmlld0V4cHIgPSBpc0hvc3RQcm9wID8gY29tcGlsZUVsZW1lbnQuYXBwRWxlbWVudC5wcm9wKCdjb21wb25lbnRWaWV3JykgOiBUSElTX0VYUFI7XG4gICAgICAgICAgICAgICAgICB2YXIgYW5pbWF0aW9uRm5FeHByID0gdGFyZ2V0Vmlld0V4cHIucHJvcCgnY29tcG9uZW50VHlwZScpLnByb3AoJ2FuaW1hdGlvbnMnKS5rZXkobGl0ZXJhbChhbmltYXRpb25OYW1lXzEpKTtcbiAgICAgICAgICAgICAgICAgIC8vIGl0J3MgaW1wb3J0YW50IHRvIG5vcm1hbGl6ZSB0aGUgdm9pZCB2YWx1ZSBhcyBgdm9pZGAgZXhwbGljaXRseVxuICAgICAgICAgICAgICAgICAgLy8gc28gdGhhdCB0aGUgc3R5bGVzIGRhdGEgY2FuIGJlIG9idGFpbmVkIGZyb20gdGhlIHN0cmluZ21hcFxuICAgICAgICAgICAgICAgICAgdmFyIGVtcHR5U3RhdGVWYWx1ZSA9IGxpdGVyYWwoRU1QVFlfQU5JTUFUSU9OX1NUQVRFKTtcbiAgICAgICAgICAgICAgICAgIHZhciB1bml0aWFsaXplZFZhbHVlID0gaW1wb3J0RXhwcihyZXNvbHZlSWRlbnRpZmllcihJZGVudGlmaWVycy5VTklOSVRJQUxJWkVEKSk7XG4gICAgICAgICAgICAgICAgICB2YXIgYW5pbWF0aW9uVHJhbnNpdGlvblZhcl8xID0gdmFyaWFibGUoJ2FuaW1hdGlvblRyYW5zaXRpb25fJyArIGFuaW1hdGlvbk5hbWVfMSk7XG4gICAgICAgICAgICAgICAgICB1cGRhdGVTdG10cy5wdXNoKGFuaW1hdGlvblRyYW5zaXRpb25WYXJfMVxuICAgICAgICAgICAgICAgICAgICAgIC5zZXQoYW5pbWF0aW9uRm5FeHByLmNhbGxGbihbXG4gICAgICAgICAgICAgICAgICAgICAgVEhJU19FWFBSLCByZW5kZXJOb2RlLFxuICAgICAgICAgICAgICAgICAgICAgIGJpbmRpbmdGaWVsZC5leHByZXNzaW9uLmVxdWFscyh1bml0aWFsaXplZFZhbHVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAuY29uZGl0aW9uYWwoZW1wdHlTdGF0ZVZhbHVlLCBiaW5kaW5nRmllbGQuZXhwcmVzc2lvbiksXG4gICAgICAgICAgICAgICAgICAgICAgZXZhbFJlc3VsdC5jdXJyVmFsRXhwci5lcXVhbHModW5pdGlhbGl6ZWRWYWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLmNvbmRpdGlvbmFsKGVtcHR5U3RhdGVWYWx1ZSwgZXZhbFJlc3VsdC5jdXJyVmFsRXhwcilcbiAgICAgICAgICAgICAgICAgIF0pKVxuICAgICAgICAgICAgICAgICAgICAgIC50b0RlY2xTdG10KCkpO1xuICAgICAgICAgICAgICAgICAgZGV0YWNoU3RtdHNfMS5wdXNoKGFuaW1hdGlvblRyYW5zaXRpb25WYXJfMVxuICAgICAgICAgICAgICAgICAgICAgIC5zZXQoYW5pbWF0aW9uRm5FeHByLmNhbGxGbihbVEhJU19FWFBSLCByZW5kZXJOb2RlLCBiaW5kaW5nRmllbGQuZXhwcmVzc2lvbiwgZW1wdHlTdGF0ZVZhbHVlXSkpXG4gICAgICAgICAgICAgICAgICAgICAgLnRvRGVjbFN0bXQoKSk7XG4gICAgICAgICAgICAgICAgICBldmVudExpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChsaXN0ZW5lci5pc0FuaW1hdGlvbiAmJiBsaXN0ZW5lci5ldmVudE5hbWUgPT09IGFuaW1hdGlvbk5hbWVfMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYW5pbWF0aW9uU3RtdCA9IGxpc3RlbmVyLmxpc3RlblRvQW5pbWF0aW9uKGFuaW1hdGlvblRyYW5zaXRpb25WYXJfMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZVN0bXRzLnB1c2goYW5pbWF0aW9uU3RtdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGRldGFjaFN0bXRzXzEucHVzaChhbmltYXRpb25TdG10KTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIHZpZXcuZGV0YWNoTWV0aG9kLmFkZFN0bXRzKGRldGFjaFN0bXRzXzEpO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbXBpbGVNZXRob2QuYWRkU3RtdHMoY3JlYXRlQ2hlY2tCaW5kaW5nU3RtdChldmFsUmVzdWx0LCBiaW5kaW5nRmllbGQuZXhwcmVzc2lvbiwgRGV0ZWN0Q2hhbmdlc1ZhcnMudGhyb3dPbkNoYW5nZSwgdXBkYXRlU3RtdHMpKTtcbiAgICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGJpbmRSZW5kZXJJbnB1dHMoYm91bmRQcm9wcywgY29tcGlsZUVsZW1lbnQsIGV2ZW50TGlzdGVuZXJzKSB7XG4gICAgICBiaW5kQW5kV3JpdGVUb1JlbmRlcmVyKGJvdW5kUHJvcHMsIGNvbXBpbGVFbGVtZW50LnZpZXcuY29tcG9uZW50Q29udGV4dCwgY29tcGlsZUVsZW1lbnQsIGZhbHNlLCBldmVudExpc3RlbmVycyk7XG4gIH1cbiAgZnVuY3Rpb24gYmluZERpcmVjdGl2ZUhvc3RQcm9wcyhkaXJlY3RpdmVBc3QsIGRpcmVjdGl2ZVdyYXBwZXJJbnN0YW5jZSwgY29tcGlsZUVsZW1lbnQsIGV2ZW50TGlzdGVuZXJzLCBlbGVtZW50TmFtZSwgc2NoZW1hUmVnaXN0cnkpIHtcbiAgICAgIC8vIGhvc3QgcHJvcGVydGllcyBhcmUgY2hhbmdlIGRldGVjdGVkIGJ5IHRoZSBEaXJlY3RpdmVXcmFwcGVycyxcbiAgICAgIC8vIGV4Y2VwdCBmb3IgdGhlIGFuaW1hdGlvbiBwcm9wZXJ0aWVzIGFzIHRoZXkgbmVlZCBjbG9zZSBpbnRlZ3JhdGlvbiB3aXRoIGFuaW1hdGlvbiBldmVudHNcbiAgICAgIC8vIGFuZCBEaXJlY3RpdmVXcmFwcGVycyBkb24ndCBzdXBwb3J0XG4gICAgICAvLyBldmVudCBsaXN0ZW5lcnMgcmlnaHQgbm93LlxuICAgICAgYmluZEFuZFdyaXRlVG9SZW5kZXJlcihkaXJlY3RpdmVBc3QuaG9zdFByb3BlcnRpZXMuZmlsdGVyKGZ1bmN0aW9uIChib3VuZFByb3ApIHsgcmV0dXJuIGJvdW5kUHJvcC5pc0FuaW1hdGlvbjsgfSksIGRpcmVjdGl2ZVdyYXBwZXJJbnN0YW5jZS5wcm9wKCdjb250ZXh0JyksIGNvbXBpbGVFbGVtZW50LCB0cnVlLCBldmVudExpc3RlbmVycyk7XG4gICAgICB2YXIgbWV0aG9kQXJncyA9IFtUSElTX0VYUFIsIGNvbXBpbGVFbGVtZW50LnJlbmRlck5vZGUsIERldGVjdENoYW5nZXNWYXJzLnRocm93T25DaGFuZ2VdO1xuICAgICAgLy8gV2UgbmVlZCB0byBwcm92aWRlIHRoZSBTZWN1cml0eUNvbnRleHQgZm9yIHByb3BlcnRpZXMgdGhhdCBjb3VsZCBuZWVkIHNhbml0aXphdGlvbi5cbiAgICAgIGRpcmVjdGl2ZUFzdC5ob3N0UHJvcGVydGllcy5maWx0ZXIoZnVuY3Rpb24gKGJvdW5kUHJvcCkgeyByZXR1cm4gYm91bmRQcm9wLm5lZWRzUnVudGltZVNlY3VyaXR5Q29udGV4dDsgfSlcbiAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbiAoYm91bmRQcm9wKSB7XG4gICAgICAgICAgdmFyIGN0eDtcbiAgICAgICAgICBzd2l0Y2ggKGJvdW5kUHJvcC50eXBlKSB7XG4gICAgICAgICAgICAgIGNhc2UgZXhwb3J0cy5Qcm9wZXJ0eUJpbmRpbmdUeXBlLlByb3BlcnR5OlxuICAgICAgICAgICAgICAgICAgY3R4ID0gc2NoZW1hUmVnaXN0cnkuc2VjdXJpdHlDb250ZXh0KGVsZW1lbnROYW1lLCBib3VuZFByb3AubmFtZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgZXhwb3J0cy5Qcm9wZXJ0eUJpbmRpbmdUeXBlLkF0dHJpYnV0ZTpcbiAgICAgICAgICAgICAgICAgIGN0eCA9IHNjaGVtYVJlZ2lzdHJ5LnNlY3VyaXR5Q29udGV4dChlbGVtZW50TmFtZSwgYm91bmRQcm9wLm5hbWUsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbGxlZ2FsIHN0YXRlOiBPbmx5IHByb3BlcnR5IC8gYXR0cmlidXRlIGJpbmRpbmdzIGNhbiBoYXZlIGFuIHVua25vd24gc2VjdXJpdHkgY29udGV4dCEgQmluZGluZyBcIiArIGJvdW5kUHJvcC5uYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbWV0aG9kQXJncy5wdXNoKGNyZWF0ZUVudW1FeHByZXNzaW9uKElkZW50aWZpZXJzLlNlY3VyaXR5Q29udGV4dCwgY3R4KSk7XG4gICAgICB9KTtcbiAgICAgIGNvbXBpbGVFbGVtZW50LnZpZXcuZGV0ZWN0Q2hhbmdlc1JlbmRlclByb3BlcnRpZXNNZXRob2QuYWRkU3RtdChkaXJlY3RpdmVXcmFwcGVySW5zdGFuY2UuY2FsbE1ldGhvZCgnZGV0ZWN0Q2hhbmdlc0luSG9zdFByb3BzJywgbWV0aG9kQXJncykudG9TdG10KCkpO1xuICB9XG4gIGZ1bmN0aW9uIGJpbmREaXJlY3RpdmVJbnB1dHMoZGlyZWN0aXZlQXN0LCBkaXJlY3RpdmVXcmFwcGVySW5zdGFuY2UsIGRpckluZGV4LCBjb21waWxlRWxlbWVudCkge1xuICAgICAgdmFyIHZpZXcgPSBjb21waWxlRWxlbWVudC52aWV3O1xuICAgICAgdmFyIGRldGVjdENoYW5nZXNJbklucHV0c01ldGhvZCA9IHZpZXcuZGV0ZWN0Q2hhbmdlc0luSW5wdXRzTWV0aG9kO1xuICAgICAgZGV0ZWN0Q2hhbmdlc0luSW5wdXRzTWV0aG9kLnJlc2V0RGVidWdJbmZvKGNvbXBpbGVFbGVtZW50Lm5vZGVJbmRleCwgY29tcGlsZUVsZW1lbnQuc291cmNlQXN0KTtcbiAgICAgIGRpcmVjdGl2ZUFzdC5pbnB1dHMuZm9yRWFjaChmdW5jdGlvbiAoaW5wdXQsIGlucHV0SWR4KSB7XG4gICAgICAgICAgLy8gTm90ZTogV2UgY2FuJ3QgdXNlIGBmaWVsZHMubGVuZ3RoYCBoZXJlLCBhcyB3ZSBhcmUgbm90IGFkZGluZyBhIGZpZWxkIVxuICAgICAgICAgIHZhciBiaW5kaW5nSWQgPSBjb21waWxlRWxlbWVudC5ub2RlSW5kZXggKyBcIl9cIiArIGRpckluZGV4ICsgXCJfXCIgKyBpbnB1dElkeDtcbiAgICAgICAgICBkZXRlY3RDaGFuZ2VzSW5JbnB1dHNNZXRob2QucmVzZXREZWJ1Z0luZm8oY29tcGlsZUVsZW1lbnQubm9kZUluZGV4LCBpbnB1dCk7XG4gICAgICAgICAgdmFyIGV2YWxSZXN1bHQgPSBjb252ZXJ0UHJvcGVydHlCaW5kaW5nKHZpZXcsIHZpZXcsIHZpZXcuY29tcG9uZW50Q29udGV4dCwgaW5wdXQudmFsdWUsIGJpbmRpbmdJZCk7XG4gICAgICAgICAgaWYgKCFldmFsUmVzdWx0KSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGV0ZWN0Q2hhbmdlc0luSW5wdXRzTWV0aG9kLmFkZFN0bXRzKGV2YWxSZXN1bHQuc3RtdHMpO1xuICAgICAgICAgIGRldGVjdENoYW5nZXNJbklucHV0c01ldGhvZC5hZGRTdG10KGRpcmVjdGl2ZVdyYXBwZXJJbnN0YW5jZVxuICAgICAgICAgICAgICAuY2FsbE1ldGhvZChcImNoZWNrX1wiICsgaW5wdXQuZGlyZWN0aXZlTmFtZSwgW1xuICAgICAgICAgICAgICBldmFsUmVzdWx0LmN1cnJWYWxFeHByLCBEZXRlY3RDaGFuZ2VzVmFycy50aHJvd09uQ2hhbmdlLFxuICAgICAgICAgICAgICBldmFsUmVzdWx0LmZvcmNlVXBkYXRlIHx8IGxpdGVyYWwoZmFsc2UpXG4gICAgICAgICAgXSlcbiAgICAgICAgICAgICAgLnRvU3RtdCgpKTtcbiAgICAgIH0pO1xuICAgICAgdmFyIGlzT25QdXNoQ29tcCA9IGRpcmVjdGl2ZUFzdC5kaXJlY3RpdmUuaXNDb21wb25lbnQgJiZcbiAgICAgICAgICAhaXNEZWZhdWx0Q2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3koZGlyZWN0aXZlQXN0LmRpcmVjdGl2ZS5jaGFuZ2VEZXRlY3Rpb24pO1xuICAgICAgdmFyIGRpcmVjdGl2ZURldGVjdENoYW5nZXNFeHByID0gZGlyZWN0aXZlV3JhcHBlckluc3RhbmNlLmNhbGxNZXRob2QoJ2RldGVjdENoYW5nZXNJbklucHV0UHJvcHMnLCBbVEhJU19FWFBSLCBjb21waWxlRWxlbWVudC5yZW5kZXJOb2RlLCBEZXRlY3RDaGFuZ2VzVmFycy50aHJvd09uQ2hhbmdlXSk7XG4gICAgICB2YXIgZGlyZWN0aXZlRGV0ZWN0Q2hhbmdlc1N0bXQgPSBpc09uUHVzaENvbXAgP1xuICAgICAgICAgIG5ldyBJZlN0bXQoZGlyZWN0aXZlRGV0ZWN0Q2hhbmdlc0V4cHIsIFtjb21waWxlRWxlbWVudC5hcHBFbGVtZW50LnByb3AoJ2NvbXBvbmVudFZpZXcnKVxuICAgICAgICAgICAgICAgICAgLmNhbGxNZXRob2QoJ21hcmtBc0NoZWNrT25jZScsIFtdKVxuICAgICAgICAgICAgICAgICAgLnRvU3RtdCgpXSkgOlxuICAgICAgICAgIGRpcmVjdGl2ZURldGVjdENoYW5nZXNFeHByLnRvU3RtdCgpO1xuICAgICAgZGV0ZWN0Q2hhbmdlc0luSW5wdXRzTWV0aG9kLmFkZFN0bXQoZGlyZWN0aXZlRGV0ZWN0Q2hhbmdlc1N0bXQpO1xuICB9XG5cbiAgZnVuY3Rpb24gYmluZFZpZXcodmlldywgcGFyc2VkVGVtcGxhdGUsIHNjaGVtYVJlZ2lzdHJ5KSB7XG4gICAgICB2YXIgdmlzaXRvciA9IG5ldyBWaWV3QmluZGVyVmlzaXRvcih2aWV3LCBzY2hlbWFSZWdpc3RyeSk7XG4gICAgICB0ZW1wbGF0ZVZpc2l0QWxsKHZpc2l0b3IsIHBhcnNlZFRlbXBsYXRlKTtcbiAgICAgIHZpZXcucGlwZXMuZm9yRWFjaChmdW5jdGlvbiAocGlwZSkgeyBiaW5kUGlwZURlc3Ryb3lMaWZlY3ljbGVDYWxsYmFja3MocGlwZS5tZXRhLCBwaXBlLmluc3RhbmNlLCBwaXBlLnZpZXcpOyB9KTtcbiAgfVxuICB2YXIgVmlld0JpbmRlclZpc2l0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gVmlld0JpbmRlclZpc2l0b3IodmlldywgX3NjaGVtYVJlZ2lzdHJ5KSB7XG4gICAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgICB0aGlzLl9zY2hlbWFSZWdpc3RyeSA9IF9zY2hlbWFSZWdpc3RyeTtcbiAgICAgICAgICB0aGlzLl9ub2RlSW5kZXggPSAwO1xuICAgICAgfVxuICAgICAgVmlld0JpbmRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0Qm91bmRUZXh0ID0gZnVuY3Rpb24gKGFzdCwgcGFyZW50KSB7XG4gICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLnZpZXcubm9kZXNbdGhpcy5fbm9kZUluZGV4KytdO1xuICAgICAgICAgIGJpbmRSZW5kZXJUZXh0KGFzdCwgbm9kZSwgdGhpcy52aWV3KTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICBWaWV3QmluZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRUZXh0ID0gZnVuY3Rpb24gKGFzdCwgcGFyZW50KSB7XG4gICAgICAgICAgdGhpcy5fbm9kZUluZGV4Kys7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgVmlld0JpbmRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0TmdDb250ZW50ID0gZnVuY3Rpb24gKGFzdCwgcGFyZW50KSB7IHJldHVybiBudWxsOyB9O1xuICAgICAgVmlld0JpbmRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0RWxlbWVudCA9IGZ1bmN0aW9uIChhc3QsIHBhcmVudCkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgdmFyIGNvbXBpbGVFbGVtZW50ID0gdGhpcy52aWV3Lm5vZGVzW3RoaXMuX25vZGVJbmRleCsrXTtcbiAgICAgICAgICB2YXIgZXZlbnRMaXN0ZW5lcnMgPSBbXTtcbiAgICAgICAgICBjb2xsZWN0RXZlbnRMaXN0ZW5lcnMoYXN0Lm91dHB1dHMsIGFzdC5kaXJlY3RpdmVzLCBjb21waWxlRWxlbWVudCkuZm9yRWFjaChmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgICAgICAgZXZlbnRMaXN0ZW5lcnMucHVzaChlbnRyeSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYmluZFJlbmRlcklucHV0cyhhc3QuaW5wdXRzLCBjb21waWxlRWxlbWVudCwgZXZlbnRMaXN0ZW5lcnMpO1xuICAgICAgICAgIGJpbmRSZW5kZXJPdXRwdXRzKGV2ZW50TGlzdGVuZXJzKTtcbiAgICAgICAgICBhc3QuZGlyZWN0aXZlcy5mb3JFYWNoKGZ1bmN0aW9uIChkaXJlY3RpdmVBc3QsIGRpckluZGV4KSB7XG4gICAgICAgICAgICAgIHZhciBkaXJlY3RpdmVJbnN0YW5jZSA9IGNvbXBpbGVFbGVtZW50Lmluc3RhbmNlcy5nZXQoZGlyZWN0aXZlQXN0LmRpcmVjdGl2ZS50eXBlLnJlZmVyZW5jZSk7XG4gICAgICAgICAgICAgIHZhciBkaXJlY3RpdmVXcmFwcGVySW5zdGFuY2UgPSBjb21waWxlRWxlbWVudC5kaXJlY3RpdmVXcmFwcGVySW5zdGFuY2UuZ2V0KGRpcmVjdGl2ZUFzdC5kaXJlY3RpdmUudHlwZS5yZWZlcmVuY2UpO1xuICAgICAgICAgICAgICBiaW5kRGlyZWN0aXZlSW5wdXRzKGRpcmVjdGl2ZUFzdCwgZGlyZWN0aXZlV3JhcHBlckluc3RhbmNlLCBkaXJJbmRleCwgY29tcGlsZUVsZW1lbnQpO1xuICAgICAgICAgICAgICBiaW5kRGlyZWN0aXZlSG9zdFByb3BzKGRpcmVjdGl2ZUFzdCwgZGlyZWN0aXZlV3JhcHBlckluc3RhbmNlLCBjb21waWxlRWxlbWVudCwgZXZlbnRMaXN0ZW5lcnMsIGFzdC5uYW1lLCBfdGhpcy5fc2NoZW1hUmVnaXN0cnkpO1xuICAgICAgICAgICAgICBiaW5kRGlyZWN0aXZlT3V0cHV0cyhkaXJlY3RpdmVBc3QsIGRpcmVjdGl2ZUluc3RhbmNlLCBldmVudExpc3RlbmVycyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGVtcGxhdGVWaXNpdEFsbCh0aGlzLCBhc3QuY2hpbGRyZW4sIGNvbXBpbGVFbGVtZW50KTtcbiAgICAgICAgICAvLyBhZnRlckNvbnRlbnQgYW5kIGFmdGVyVmlldyBsaWZlY3ljbGVzIG5lZWQgdG8gYmUgY2FsbGVkIGJvdHRvbSB1cFxuICAgICAgICAgIC8vIHNvIHRoYXQgY2hpbGRyZW4gYXJlIG5vdGlmaWVkIGJlZm9yZSBwYXJlbnRzXG4gICAgICAgICAgYXN0LmRpcmVjdGl2ZXMuZm9yRWFjaChmdW5jdGlvbiAoZGlyZWN0aXZlQXN0KSB7XG4gICAgICAgICAgICAgIHZhciBkaXJlY3RpdmVJbnN0YW5jZSA9IGNvbXBpbGVFbGVtZW50Lmluc3RhbmNlcy5nZXQoZGlyZWN0aXZlQXN0LmRpcmVjdGl2ZS50eXBlLnJlZmVyZW5jZSk7XG4gICAgICAgICAgICAgIGJpbmREaXJlY3RpdmVBZnRlckNvbnRlbnRMaWZlY3ljbGVDYWxsYmFja3MoZGlyZWN0aXZlQXN0LmRpcmVjdGl2ZSwgZGlyZWN0aXZlSW5zdGFuY2UsIGNvbXBpbGVFbGVtZW50KTtcbiAgICAgICAgICAgICAgYmluZERpcmVjdGl2ZUFmdGVyVmlld0xpZmVjeWNsZUNhbGxiYWNrcyhkaXJlY3RpdmVBc3QuZGlyZWN0aXZlLCBkaXJlY3RpdmVJbnN0YW5jZSwgY29tcGlsZUVsZW1lbnQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGFzdC5wcm92aWRlcnMuZm9yRWFjaChmdW5jdGlvbiAocHJvdmlkZXJBc3QpIHtcbiAgICAgICAgICAgICAgdmFyIHByb3ZpZGVySW5zdGFuY2UgPSBjb21waWxlRWxlbWVudC5pbnN0YW5jZXMuZ2V0KHByb3ZpZGVyQXN0LnRva2VuLnJlZmVyZW5jZSk7XG4gICAgICAgICAgICAgIGJpbmRJbmplY3RhYmxlRGVzdHJveUxpZmVjeWNsZUNhbGxiYWNrcyhwcm92aWRlckFzdCwgcHJvdmlkZXJJbnN0YW5jZSwgY29tcGlsZUVsZW1lbnQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcbiAgICAgIFZpZXdCaW5kZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEVtYmVkZGVkVGVtcGxhdGUgPSBmdW5jdGlvbiAoYXN0LCBwYXJlbnQpIHtcbiAgICAgICAgICB2YXIgY29tcGlsZUVsZW1lbnQgPSB0aGlzLnZpZXcubm9kZXNbdGhpcy5fbm9kZUluZGV4KytdO1xuICAgICAgICAgIHZhciBldmVudExpc3RlbmVycyA9IGNvbGxlY3RFdmVudExpc3RlbmVycyhhc3Qub3V0cHV0cywgYXN0LmRpcmVjdGl2ZXMsIGNvbXBpbGVFbGVtZW50KTtcbiAgICAgICAgICBhc3QuZGlyZWN0aXZlcy5mb3JFYWNoKGZ1bmN0aW9uIChkaXJlY3RpdmVBc3QsIGRpckluZGV4KSB7XG4gICAgICAgICAgICAgIHZhciBkaXJlY3RpdmVJbnN0YW5jZSA9IGNvbXBpbGVFbGVtZW50Lmluc3RhbmNlcy5nZXQoZGlyZWN0aXZlQXN0LmRpcmVjdGl2ZS50eXBlLnJlZmVyZW5jZSk7XG4gICAgICAgICAgICAgIHZhciBkaXJlY3RpdmVXcmFwcGVySW5zdGFuY2UgPSBjb21waWxlRWxlbWVudC5kaXJlY3RpdmVXcmFwcGVySW5zdGFuY2UuZ2V0KGRpcmVjdGl2ZUFzdC5kaXJlY3RpdmUudHlwZS5yZWZlcmVuY2UpO1xuICAgICAgICAgICAgICBiaW5kRGlyZWN0aXZlSW5wdXRzKGRpcmVjdGl2ZUFzdCwgZGlyZWN0aXZlV3JhcHBlckluc3RhbmNlLCBkaXJJbmRleCwgY29tcGlsZUVsZW1lbnQpO1xuICAgICAgICAgICAgICBiaW5kRGlyZWN0aXZlT3V0cHV0cyhkaXJlY3RpdmVBc3QsIGRpcmVjdGl2ZUluc3RhbmNlLCBldmVudExpc3RlbmVycyk7XG4gICAgICAgICAgICAgIGJpbmREaXJlY3RpdmVBZnRlckNvbnRlbnRMaWZlY3ljbGVDYWxsYmFja3MoZGlyZWN0aXZlQXN0LmRpcmVjdGl2ZSwgZGlyZWN0aXZlSW5zdGFuY2UsIGNvbXBpbGVFbGVtZW50KTtcbiAgICAgICAgICAgICAgYmluZERpcmVjdGl2ZUFmdGVyVmlld0xpZmVjeWNsZUNhbGxiYWNrcyhkaXJlY3RpdmVBc3QuZGlyZWN0aXZlLCBkaXJlY3RpdmVJbnN0YW5jZSwgY29tcGlsZUVsZW1lbnQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGFzdC5wcm92aWRlcnMuZm9yRWFjaChmdW5jdGlvbiAocHJvdmlkZXJBc3QpIHtcbiAgICAgICAgICAgICAgdmFyIHByb3ZpZGVySW5zdGFuY2UgPSBjb21waWxlRWxlbWVudC5pbnN0YW5jZXMuZ2V0KHByb3ZpZGVyQXN0LnRva2VuLnJlZmVyZW5jZSk7XG4gICAgICAgICAgICAgIGJpbmRJbmplY3RhYmxlRGVzdHJveUxpZmVjeWNsZUNhbGxiYWNrcyhwcm92aWRlckFzdCwgcHJvdmlkZXJJbnN0YW5jZSwgY29tcGlsZUVsZW1lbnQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJpbmRWaWV3KGNvbXBpbGVFbGVtZW50LmVtYmVkZGVkVmlldywgYXN0LmNoaWxkcmVuLCB0aGlzLl9zY2hlbWFSZWdpc3RyeSk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgVmlld0JpbmRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0QXR0ciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkgeyByZXR1cm4gbnVsbDsgfTtcbiAgICAgIFZpZXdCaW5kZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdERpcmVjdGl2ZSA9IGZ1bmN0aW9uIChhc3QsIGN0eCkgeyByZXR1cm4gbnVsbDsgfTtcbiAgICAgIFZpZXdCaW5kZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEV2ZW50ID0gZnVuY3Rpb24gKGFzdCwgZXZlbnRUYXJnZXRBbmROYW1lcykge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcbiAgICAgIFZpZXdCaW5kZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFJlZmVyZW5jZSA9IGZ1bmN0aW9uIChhc3QsIGN0eCkgeyByZXR1cm4gbnVsbDsgfTtcbiAgICAgIFZpZXdCaW5kZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFZhcmlhYmxlID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7IHJldHVybiBudWxsOyB9O1xuICAgICAgVmlld0JpbmRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0RGlyZWN0aXZlUHJvcGVydHkgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IHJldHVybiBudWxsOyB9O1xuICAgICAgVmlld0JpbmRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0RWxlbWVudFByb3BlcnR5ID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyByZXR1cm4gbnVsbDsgfTtcbiAgICAgIHJldHVybiBWaWV3QmluZGVyVmlzaXRvcjtcbiAgfSgpKTtcblxuICB2YXIgSU1QTElDSVRfVEVNUExBVEVfVkFSID0gJ1xcJGltcGxpY2l0JztcbiAgdmFyIENMQVNTX0FUVFIkMSA9ICdjbGFzcyc7XG4gIHZhciBTVFlMRV9BVFRSID0gJ3N0eWxlJztcbiAgdmFyIE5HX0NPTlRBSU5FUl9UQUcgPSAnbmctY29udGFpbmVyJztcbiAgdmFyIHBhcmVudFJlbmRlck5vZGVWYXIgPSB2YXJpYWJsZSgncGFyZW50UmVuZGVyTm9kZScpO1xuICB2YXIgcm9vdFNlbGVjdG9yVmFyID0gdmFyaWFibGUoJ3Jvb3RTZWxlY3RvcicpO1xuICBmdW5jdGlvbiBidWlsZFZpZXcodmlldywgdGVtcGxhdGUsIHRhcmdldERlcGVuZGVuY2llcykge1xuICAgICAgdmFyIGJ1aWxkZXJWaXNpdG9yID0gbmV3IFZpZXdCdWlsZGVyVmlzaXRvcih2aWV3LCB0YXJnZXREZXBlbmRlbmNpZXMpO1xuICAgICAgdGVtcGxhdGVWaXNpdEFsbChidWlsZGVyVmlzaXRvciwgdGVtcGxhdGUsIHZpZXcuZGVjbGFyYXRpb25FbGVtZW50LmlzTnVsbCgpID8gdmlldy5kZWNsYXJhdGlvbkVsZW1lbnQgOiB2aWV3LmRlY2xhcmF0aW9uRWxlbWVudC5wYXJlbnQpO1xuICAgICAgcmV0dXJuIGJ1aWxkZXJWaXNpdG9yLm5lc3RlZFZpZXdDb3VudDtcbiAgfVxuICBmdW5jdGlvbiBmaW5pc2hWaWV3KHZpZXcsIHRhcmdldFN0YXRlbWVudHMpIHtcbiAgICAgIHZpZXcuYWZ0ZXJOb2RlcygpO1xuICAgICAgY3JlYXRlVmlld1RvcExldmVsU3RtdHModmlldywgdGFyZ2V0U3RhdGVtZW50cyk7XG4gICAgICB2aWV3Lm5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIENvbXBpbGVFbGVtZW50ICYmIG5vZGUuaGFzRW1iZWRkZWRWaWV3KSB7XG4gICAgICAgICAgICAgIGZpbmlzaFZpZXcobm9kZS5lbWJlZGRlZFZpZXcsIHRhcmdldFN0YXRlbWVudHMpO1xuICAgICAgICAgIH1cbiAgICAgIH0pO1xuICB9XG4gIHZhciBWaWV3QnVpbGRlclZpc2l0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gVmlld0J1aWxkZXJWaXNpdG9yKHZpZXcsIHRhcmdldERlcGVuZGVuY2llcykge1xuICAgICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgICAgdGhpcy50YXJnZXREZXBlbmRlbmNpZXMgPSB0YXJnZXREZXBlbmRlbmNpZXM7XG4gICAgICAgICAgdGhpcy5uZXN0ZWRWaWV3Q291bnQgPSAwO1xuICAgICAgfVxuICAgICAgVmlld0J1aWxkZXJWaXNpdG9yLnByb3RvdHlwZS5faXNSb290Tm9kZSA9IGZ1bmN0aW9uIChwYXJlbnQpIHsgcmV0dXJuIHBhcmVudC52aWV3ICE9PSB0aGlzLnZpZXc7IH07XG4gICAgICBWaWV3QnVpbGRlclZpc2l0b3IucHJvdG90eXBlLl9hZGRSb290Tm9kZUFuZFByb2plY3QgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgIHZhciBwcm9qZWN0ZWROb2RlID0gX2dldE91dGVyQ29udGFpbmVyT3JTZWxmKG5vZGUpO1xuICAgICAgICAgIHZhciBwYXJlbnQgPSBwcm9qZWN0ZWROb2RlLnBhcmVudDtcbiAgICAgICAgICB2YXIgbmdDb250ZW50SW5kZXggPSBwcm9qZWN0ZWROb2RlLnNvdXJjZUFzdC5uZ0NvbnRlbnRJbmRleDtcbiAgICAgICAgICB2YXIgdmNBcHBFbCA9IChub2RlIGluc3RhbmNlb2YgQ29tcGlsZUVsZW1lbnQgJiYgbm9kZS5oYXNWaWV3Q29udGFpbmVyKSA/IG5vZGUuYXBwRWxlbWVudCA6IG51bGw7XG4gICAgICAgICAgaWYgKHRoaXMuX2lzUm9vdE5vZGUocGFyZW50KSkge1xuICAgICAgICAgICAgICAvLyBzdG9yZSBhcHBFbGVtZW50IGFzIHJvb3Qgbm9kZSBvbmx5IGZvciBWaWV3Q29udGFpbmVyc1xuICAgICAgICAgICAgICBpZiAodGhpcy52aWV3LnZpZXdUeXBlICE9PSBWaWV3VHlwZS5DT01QT05FTlQpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMudmlldy5yb290Tm9kZXNPckFwcEVsZW1lbnRzLnB1c2godmNBcHBFbCB8fCBub2RlLnJlbmRlck5vZGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKGlzUHJlc2VudChwYXJlbnQuY29tcG9uZW50KSAmJiBpc1ByZXNlbnQobmdDb250ZW50SW5kZXgpKSB7XG4gICAgICAgICAgICAgIHBhcmVudC5hZGRDb250ZW50Tm9kZShuZ0NvbnRlbnRJbmRleCwgdmNBcHBFbCB8fCBub2RlLnJlbmRlck5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICBWaWV3QnVpbGRlclZpc2l0b3IucHJvdG90eXBlLl9nZXRQYXJlbnRSZW5kZXJOb2RlID0gZnVuY3Rpb24gKHBhcmVudCkge1xuICAgICAgICAgIHBhcmVudCA9IF9nZXRPdXRlckNvbnRhaW5lclBhcmVudE9yU2VsZihwYXJlbnQpO1xuICAgICAgICAgIGlmICh0aGlzLl9pc1Jvb3ROb2RlKHBhcmVudCkpIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMudmlldy52aWV3VHlwZSA9PT0gVmlld1R5cGUuQ09NUE9ORU5UKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcGFyZW50UmVuZGVyTm9kZVZhcjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIC8vIHJvb3Qgbm9kZSBvZiBhbiBlbWJlZGRlZC9ob3N0IHZpZXdcbiAgICAgICAgICAgICAgICAgIHJldHVybiBOVUxMX0VYUFI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBpc1ByZXNlbnQocGFyZW50LmNvbXBvbmVudCkgJiZcbiAgICAgICAgICAgICAgICAgIHBhcmVudC5jb21wb25lbnQudGVtcGxhdGUuZW5jYXBzdWxhdGlvbiAhPT0gX2FuZ3VsYXJfY29yZS5WaWV3RW5jYXBzdWxhdGlvbi5OYXRpdmUgP1xuICAgICAgICAgICAgICAgICAgTlVMTF9FWFBSIDpcbiAgICAgICAgICAgICAgICAgIHBhcmVudC5yZW5kZXJOb2RlO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICBWaWV3QnVpbGRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0Qm91bmRUZXh0ID0gZnVuY3Rpb24gKGFzdCwgcGFyZW50KSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3Zpc2l0VGV4dChhc3QsICcnLCBwYXJlbnQpO1xuICAgICAgfTtcbiAgICAgIFZpZXdCdWlsZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRUZXh0ID0gZnVuY3Rpb24gKGFzdCwgcGFyZW50KSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3Zpc2l0VGV4dChhc3QsIGFzdC52YWx1ZSwgcGFyZW50KTtcbiAgICAgIH07XG4gICAgICBWaWV3QnVpbGRlclZpc2l0b3IucHJvdG90eXBlLl92aXNpdFRleHQgPSBmdW5jdGlvbiAoYXN0LCB2YWx1ZSwgcGFyZW50KSB7XG4gICAgICAgICAgdmFyIGZpZWxkTmFtZSA9IFwiX3RleHRfXCIgKyB0aGlzLnZpZXcubm9kZXMubGVuZ3RoO1xuICAgICAgICAgIHRoaXMudmlldy5maWVsZHMucHVzaChuZXcgQ2xhc3NGaWVsZChmaWVsZE5hbWUsIGltcG9ydFR5cGUodGhpcy52aWV3LmdlbkNvbmZpZy5yZW5kZXJUeXBlcy5yZW5kZXJUZXh0KSkpO1xuICAgICAgICAgIHZhciByZW5kZXJOb2RlID0gVEhJU19FWFBSLnByb3AoZmllbGROYW1lKTtcbiAgICAgICAgICB2YXIgY29tcGlsZU5vZGUgPSBuZXcgQ29tcGlsZU5vZGUocGFyZW50LCB0aGlzLnZpZXcsIHRoaXMudmlldy5ub2Rlcy5sZW5ndGgsIHJlbmRlck5vZGUsIGFzdCk7XG4gICAgICAgICAgdmFyIGNyZWF0ZVJlbmRlck5vZGUgPSBUSElTX0VYUFIucHJvcChmaWVsZE5hbWUpXG4gICAgICAgICAgICAgIC5zZXQoVmlld1Byb3BlcnRpZXMucmVuZGVyZXIuY2FsbE1ldGhvZCgnY3JlYXRlVGV4dCcsIFtcbiAgICAgICAgICAgICAgdGhpcy5fZ2V0UGFyZW50UmVuZGVyTm9kZShwYXJlbnQpLCBsaXRlcmFsKHZhbHVlKSxcbiAgICAgICAgICAgICAgdGhpcy52aWV3LmNyZWF0ZU1ldGhvZC5yZXNldERlYnVnSW5mb0V4cHIodGhpcy52aWV3Lm5vZGVzLmxlbmd0aCwgYXN0KVxuICAgICAgICAgIF0pKVxuICAgICAgICAgICAgICAudG9TdG10KCk7XG4gICAgICAgICAgdGhpcy52aWV3Lm5vZGVzLnB1c2goY29tcGlsZU5vZGUpO1xuICAgICAgICAgIHRoaXMudmlldy5jcmVhdGVNZXRob2QuYWRkU3RtdChjcmVhdGVSZW5kZXJOb2RlKTtcbiAgICAgICAgICB0aGlzLl9hZGRSb290Tm9kZUFuZFByb2plY3QoY29tcGlsZU5vZGUpO1xuICAgICAgICAgIHJldHVybiByZW5kZXJOb2RlO1xuICAgICAgfTtcbiAgICAgIFZpZXdCdWlsZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXROZ0NvbnRlbnQgPSBmdW5jdGlvbiAoYXN0LCBwYXJlbnQpIHtcbiAgICAgICAgICAvLyB0aGUgcHJvamVjdGVkIG5vZGVzIG9yaWdpbmF0ZSBmcm9tIGEgZGlmZmVyZW50IHZpZXcsIHNvIHdlIGRvbid0XG4gICAgICAgICAgLy8gaGF2ZSBkZWJ1ZyBpbmZvcm1hdGlvbiBmb3IgdGhlbS4uLlxuICAgICAgICAgIHRoaXMudmlldy5jcmVhdGVNZXRob2QucmVzZXREZWJ1Z0luZm8obnVsbCwgYXN0KTtcbiAgICAgICAgICB2YXIgcGFyZW50UmVuZGVyTm9kZSA9IHRoaXMuX2dldFBhcmVudFJlbmRlck5vZGUocGFyZW50KTtcbiAgICAgICAgICB2YXIgbm9kZXNFeHByZXNzaW9uID0gVmlld1Byb3BlcnRpZXMucHJvamVjdGFibGVOb2Rlcy5rZXkobGl0ZXJhbChhc3QuaW5kZXgpLCBuZXcgQXJyYXlUeXBlKGltcG9ydFR5cGUodGhpcy52aWV3LmdlbkNvbmZpZy5yZW5kZXJUeXBlcy5yZW5kZXJOb2RlKSkpO1xuICAgICAgICAgIGlmIChwYXJlbnRSZW5kZXJOb2RlICE9PSBOVUxMX0VYUFIpIHtcbiAgICAgICAgICAgICAgdGhpcy52aWV3LmNyZWF0ZU1ldGhvZC5hZGRTdG10KFZpZXdQcm9wZXJ0aWVzLnJlbmRlcmVyXG4gICAgICAgICAgICAgICAgICAuY2FsbE1ldGhvZCgncHJvamVjdE5vZGVzJywgW1xuICAgICAgICAgICAgICAgICAgcGFyZW50UmVuZGVyTm9kZSxcbiAgICAgICAgICAgICAgICAgIGltcG9ydEV4cHIocmVzb2x2ZUlkZW50aWZpZXIoSWRlbnRpZmllcnMuZmxhdHRlbk5lc3RlZFZpZXdSZW5kZXJOb2RlcykpXG4gICAgICAgICAgICAgICAgICAgICAgLmNhbGxGbihbbm9kZXNFeHByZXNzaW9uXSlcbiAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICAgIC50b1N0bXQoKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX2lzUm9vdE5vZGUocGFyZW50KSkge1xuICAgICAgICAgICAgICBpZiAodGhpcy52aWV3LnZpZXdUeXBlICE9PSBWaWV3VHlwZS5DT01QT05FTlQpIHtcbiAgICAgICAgICAgICAgICAgIC8vIHN0b3JlIHJvb3Qgbm9kZXMgb25seSBmb3IgZW1iZWRkZWQvaG9zdCB2aWV3c1xuICAgICAgICAgICAgICAgICAgdGhpcy52aWV3LnJvb3ROb2Rlc09yQXBwRWxlbWVudHMucHVzaChub2Rlc0V4cHJlc3Npb24pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoaXNQcmVzZW50KHBhcmVudC5jb21wb25lbnQpICYmIGlzUHJlc2VudChhc3QubmdDb250ZW50SW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgICBwYXJlbnQuYWRkQ29udGVudE5vZGUoYXN0Lm5nQ29udGVudEluZGV4LCBub2Rlc0V4cHJlc3Npb24pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcbiAgICAgIFZpZXdCdWlsZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRFbGVtZW50ID0gZnVuY3Rpb24gKGFzdCwgcGFyZW50KSB7XG4gICAgICAgICAgdmFyIG5vZGVJbmRleCA9IHRoaXMudmlldy5ub2Rlcy5sZW5ndGg7XG4gICAgICAgICAgdmFyIGNyZWF0ZVJlbmRlck5vZGVFeHByO1xuICAgICAgICAgIHZhciBkZWJ1Z0NvbnRleHRFeHByID0gdGhpcy52aWV3LmNyZWF0ZU1ldGhvZC5yZXNldERlYnVnSW5mb0V4cHIobm9kZUluZGV4LCBhc3QpO1xuICAgICAgICAgIHZhciBkaXJlY3RpdmVzID0gYXN0LmRpcmVjdGl2ZXMubWFwKGZ1bmN0aW9uIChkaXJlY3RpdmVBc3QpIHsgcmV0dXJuIGRpcmVjdGl2ZUFzdC5kaXJlY3RpdmU7IH0pO1xuICAgICAgICAgIHZhciBjb21wb25lbnQgPSBkaXJlY3RpdmVzLmZpbmQoZnVuY3Rpb24gKGRpcmVjdGl2ZSkgeyByZXR1cm4gZGlyZWN0aXZlLmlzQ29tcG9uZW50OyB9KTtcbiAgICAgICAgICBpZiAoYXN0Lm5hbWUgPT09IE5HX0NPTlRBSU5FUl9UQUcpIHtcbiAgICAgICAgICAgICAgY3JlYXRlUmVuZGVyTm9kZUV4cHIgPSBWaWV3UHJvcGVydGllcy5yZW5kZXJlci5jYWxsTWV0aG9kKCdjcmVhdGVUZW1wbGF0ZUFuY2hvcicsIFt0aGlzLl9nZXRQYXJlbnRSZW5kZXJOb2RlKHBhcmVudCksIGRlYnVnQ29udGV4dEV4cHJdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHZhciBodG1sQXR0cnMgPSBfcmVhZEh0bWxBdHRycyhhc3QuYXR0cnMpO1xuICAgICAgICAgICAgICB2YXIgYXR0ck5hbWVBbmRWYWx1ZXMgPSBjcmVhdGVJbmxpbmVBcnJheShfbWVyZ2VIdG1sQW5kRGlyZWN0aXZlQXR0cnMoaHRtbEF0dHJzLCBkaXJlY3RpdmVzKS5tYXAoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIGxpdGVyYWwodik7IH0pKTtcbiAgICAgICAgICAgICAgaWYgKG5vZGVJbmRleCA9PT0gMCAmJiB0aGlzLnZpZXcudmlld1R5cGUgPT09IFZpZXdUeXBlLkhPU1QpIHtcbiAgICAgICAgICAgICAgICAgIGNyZWF0ZVJlbmRlck5vZGVFeHByID1cbiAgICAgICAgICAgICAgICAgICAgICBpbXBvcnRFeHByKHJlc29sdmVJZGVudGlmaWVyKElkZW50aWZpZXJzLnNlbGVjdE9yQ3JlYXRlUmVuZGVySG9zdEVsZW1lbnQpKS5jYWxsRm4oW1xuICAgICAgICAgICAgICAgICAgICAgICAgICBWaWV3UHJvcGVydGllcy5yZW5kZXJlciwgbGl0ZXJhbChhc3QubmFtZSksIGF0dHJOYW1lQW5kVmFsdWVzLCByb290U2VsZWN0b3JWYXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGRlYnVnQ29udGV4dEV4cHJcbiAgICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGNyZWF0ZVJlbmRlck5vZGVFeHByID1cbiAgICAgICAgICAgICAgICAgICAgICBpbXBvcnRFeHByKHJlc29sdmVJZGVudGlmaWVyKElkZW50aWZpZXJzLmNyZWF0ZVJlbmRlckVsZW1lbnQpKS5jYWxsRm4oW1xuICAgICAgICAgICAgICAgICAgICAgICAgICBWaWV3UHJvcGVydGllcy5yZW5kZXJlciwgdGhpcy5fZ2V0UGFyZW50UmVuZGVyTm9kZShwYXJlbnQpLCBsaXRlcmFsKGFzdC5uYW1lKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0ck5hbWVBbmRWYWx1ZXMsIGRlYnVnQ29udGV4dEV4cHJcbiAgICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgZmllbGROYW1lID0gXCJfZWxfXCIgKyBub2RlSW5kZXg7XG4gICAgICAgICAgdGhpcy52aWV3LmZpZWxkcy5wdXNoKG5ldyBDbGFzc0ZpZWxkKGZpZWxkTmFtZSwgaW1wb3J0VHlwZSh0aGlzLnZpZXcuZ2VuQ29uZmlnLnJlbmRlclR5cGVzLnJlbmRlckVsZW1lbnQpKSk7XG4gICAgICAgICAgdGhpcy52aWV3LmNyZWF0ZU1ldGhvZC5hZGRTdG10KFRISVNfRVhQUi5wcm9wKGZpZWxkTmFtZSkuc2V0KGNyZWF0ZVJlbmRlck5vZGVFeHByKS50b1N0bXQoKSk7XG4gICAgICAgICAgdmFyIHJlbmRlck5vZGUgPSBUSElTX0VYUFIucHJvcChmaWVsZE5hbWUpO1xuICAgICAgICAgIHZhciBjb21waWxlRWxlbWVudCA9IG5ldyBDb21waWxlRWxlbWVudChwYXJlbnQsIHRoaXMudmlldywgbm9kZUluZGV4LCByZW5kZXJOb2RlLCBhc3QsIGNvbXBvbmVudCwgZGlyZWN0aXZlcywgYXN0LnByb3ZpZGVycywgYXN0Lmhhc1ZpZXdDb250YWluZXIsIGZhbHNlLCBhc3QucmVmZXJlbmNlcywgdGhpcy50YXJnZXREZXBlbmRlbmNpZXMpO1xuICAgICAgICAgIHRoaXMudmlldy5ub2Rlcy5wdXNoKGNvbXBpbGVFbGVtZW50KTtcbiAgICAgICAgICB2YXIgY29tcFZpZXdFeHByID0gbnVsbDtcbiAgICAgICAgICBpZiAoaXNQcmVzZW50KGNvbXBvbmVudCkpIHtcbiAgICAgICAgICAgICAgdmFyIG5lc3RlZENvbXBvbmVudElkZW50aWZpZXIgPSBuZXcgQ29tcGlsZUlkZW50aWZpZXJNZXRhZGF0YSh7IG5hbWU6IGdldFZpZXdGYWN0b3J5TmFtZShjb21wb25lbnQsIDApIH0pO1xuICAgICAgICAgICAgICB0aGlzLnRhcmdldERlcGVuZGVuY2llcy5wdXNoKG5ldyBWaWV3RmFjdG9yeURlcGVuZGVuY3koY29tcG9uZW50LnR5cGUsIG5lc3RlZENvbXBvbmVudElkZW50aWZpZXIpKTtcbiAgICAgICAgICAgICAgY29tcFZpZXdFeHByID0gdmFyaWFibGUoXCJjb21wVmlld19cIiArIG5vZGVJbmRleCk7IC8vIGZpeCBoaWdobGlnaHRpbmc6IGBcbiAgICAgICAgICAgICAgY29tcGlsZUVsZW1lbnQuc2V0Q29tcG9uZW50Vmlldyhjb21wVmlld0V4cHIpO1xuICAgICAgICAgICAgICB0aGlzLnZpZXcuY3JlYXRlTWV0aG9kLmFkZFN0bXQoY29tcFZpZXdFeHByXG4gICAgICAgICAgICAgICAgICAuc2V0KGltcG9ydEV4cHIobmVzdGVkQ29tcG9uZW50SWRlbnRpZmllcikuY2FsbEZuKFtcbiAgICAgICAgICAgICAgICAgIFZpZXdQcm9wZXJ0aWVzLnZpZXdVdGlscywgY29tcGlsZUVsZW1lbnQuaW5qZWN0b3IsIGNvbXBpbGVFbGVtZW50LmFwcEVsZW1lbnRcbiAgICAgICAgICAgICAgXSkpXG4gICAgICAgICAgICAgICAgICAudG9EZWNsU3RtdCgpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29tcGlsZUVsZW1lbnQuYmVmb3JlQ2hpbGRyZW4oKTtcbiAgICAgICAgICB0aGlzLl9hZGRSb290Tm9kZUFuZFByb2plY3QoY29tcGlsZUVsZW1lbnQpO1xuICAgICAgICAgIHRlbXBsYXRlVmlzaXRBbGwodGhpcywgYXN0LmNoaWxkcmVuLCBjb21waWxlRWxlbWVudCk7XG4gICAgICAgICAgY29tcGlsZUVsZW1lbnQuYWZ0ZXJDaGlsZHJlbih0aGlzLnZpZXcubm9kZXMubGVuZ3RoIC0gbm9kZUluZGV4IC0gMSk7XG4gICAgICAgICAgaWYgKGlzUHJlc2VudChjb21wVmlld0V4cHIpKSB7XG4gICAgICAgICAgICAgIHZhciBjb2RlR2VuQ29udGVudE5vZGVzO1xuICAgICAgICAgICAgICBpZiAodGhpcy52aWV3LmNvbXBvbmVudC50eXBlLmlzSG9zdCkge1xuICAgICAgICAgICAgICAgICAgY29kZUdlbkNvbnRlbnROb2RlcyA9IFZpZXdQcm9wZXJ0aWVzLnByb2plY3RhYmxlTm9kZXM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICBjb2RlR2VuQ29udGVudE5vZGVzID0gbGl0ZXJhbEFycihjb21waWxlRWxlbWVudC5jb250ZW50Tm9kZXNCeU5nQ29udGVudEluZGV4Lm1hcChmdW5jdGlvbiAobm9kZXMpIHsgcmV0dXJuIGNyZWF0ZUZsYXRBcnJheShub2Rlcyk7IH0pKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aGlzLnZpZXcuY3JlYXRlTWV0aG9kLmFkZFN0bXQoY29tcFZpZXdFeHByXG4gICAgICAgICAgICAgICAgICAuY2FsbE1ldGhvZCgnY3JlYXRlJywgW2NvbXBpbGVFbGVtZW50LmdldENvbXBvbmVudCgpLCBjb2RlR2VuQ29udGVudE5vZGVzLCBOVUxMX0VYUFJdKVxuICAgICAgICAgICAgICAgICAgLnRvU3RtdCgpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgVmlld0J1aWxkZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEVtYmVkZGVkVGVtcGxhdGUgPSBmdW5jdGlvbiAoYXN0LCBwYXJlbnQpIHtcbiAgICAgICAgICB2YXIgbm9kZUluZGV4ID0gdGhpcy52aWV3Lm5vZGVzLmxlbmd0aDtcbiAgICAgICAgICB2YXIgZmllbGROYW1lID0gXCJfYW5jaG9yX1wiICsgbm9kZUluZGV4O1xuICAgICAgICAgIHRoaXMudmlldy5maWVsZHMucHVzaChuZXcgQ2xhc3NGaWVsZChmaWVsZE5hbWUsIGltcG9ydFR5cGUodGhpcy52aWV3LmdlbkNvbmZpZy5yZW5kZXJUeXBlcy5yZW5kZXJDb21tZW50KSkpO1xuICAgICAgICAgIHRoaXMudmlldy5jcmVhdGVNZXRob2QuYWRkU3RtdChUSElTX0VYUFIucHJvcChmaWVsZE5hbWUpXG4gICAgICAgICAgICAgIC5zZXQoVmlld1Byb3BlcnRpZXMucmVuZGVyZXIuY2FsbE1ldGhvZCgnY3JlYXRlVGVtcGxhdGVBbmNob3InLCBbXG4gICAgICAgICAgICAgIHRoaXMuX2dldFBhcmVudFJlbmRlck5vZGUocGFyZW50KSxcbiAgICAgICAgICAgICAgdGhpcy52aWV3LmNyZWF0ZU1ldGhvZC5yZXNldERlYnVnSW5mb0V4cHIobm9kZUluZGV4LCBhc3QpXG4gICAgICAgICAgXSkpXG4gICAgICAgICAgICAgIC50b1N0bXQoKSk7XG4gICAgICAgICAgdmFyIHJlbmRlck5vZGUgPSBUSElTX0VYUFIucHJvcChmaWVsZE5hbWUpO1xuICAgICAgICAgIHZhciB0ZW1wbGF0ZVZhcmlhYmxlQmluZGluZ3MgPSBhc3QudmFyaWFibGVzLm1hcChmdW5jdGlvbiAodmFyQXN0KSB7IHJldHVybiBbdmFyQXN0LnZhbHVlLmxlbmd0aCA+IDAgPyB2YXJBc3QudmFsdWUgOiBJTVBMSUNJVF9URU1QTEFURV9WQVIsIHZhckFzdC5uYW1lXTsgfSk7XG4gICAgICAgICAgdmFyIGRpcmVjdGl2ZXMgPSBhc3QuZGlyZWN0aXZlcy5tYXAoZnVuY3Rpb24gKGRpcmVjdGl2ZUFzdCkgeyByZXR1cm4gZGlyZWN0aXZlQXN0LmRpcmVjdGl2ZTsgfSk7XG4gICAgICAgICAgdmFyIGNvbXBpbGVFbGVtZW50ID0gbmV3IENvbXBpbGVFbGVtZW50KHBhcmVudCwgdGhpcy52aWV3LCBub2RlSW5kZXgsIHJlbmRlck5vZGUsIGFzdCwgbnVsbCwgZGlyZWN0aXZlcywgYXN0LnByb3ZpZGVycywgYXN0Lmhhc1ZpZXdDb250YWluZXIsIHRydWUsIGFzdC5yZWZlcmVuY2VzLCB0aGlzLnRhcmdldERlcGVuZGVuY2llcyk7XG4gICAgICAgICAgdGhpcy52aWV3Lm5vZGVzLnB1c2goY29tcGlsZUVsZW1lbnQpO1xuICAgICAgICAgIHRoaXMubmVzdGVkVmlld0NvdW50Kys7XG4gICAgICAgICAgdmFyIGVtYmVkZGVkVmlldyA9IG5ldyBDb21waWxlVmlldyh0aGlzLnZpZXcuY29tcG9uZW50LCB0aGlzLnZpZXcuZ2VuQ29uZmlnLCB0aGlzLnZpZXcucGlwZU1ldGFzLCBOVUxMX0VYUFIsIHRoaXMudmlldy5hbmltYXRpb25zLCB0aGlzLnZpZXcudmlld0luZGV4ICsgdGhpcy5uZXN0ZWRWaWV3Q291bnQsIGNvbXBpbGVFbGVtZW50LCB0ZW1wbGF0ZVZhcmlhYmxlQmluZGluZ3MpO1xuICAgICAgICAgIHRoaXMubmVzdGVkVmlld0NvdW50ICs9IGJ1aWxkVmlldyhlbWJlZGRlZFZpZXcsIGFzdC5jaGlsZHJlbiwgdGhpcy50YXJnZXREZXBlbmRlbmNpZXMpO1xuICAgICAgICAgIGNvbXBpbGVFbGVtZW50LmJlZm9yZUNoaWxkcmVuKCk7XG4gICAgICAgICAgdGhpcy5fYWRkUm9vdE5vZGVBbmRQcm9qZWN0KGNvbXBpbGVFbGVtZW50KTtcbiAgICAgICAgICBjb21waWxlRWxlbWVudC5hZnRlckNoaWxkcmVuKDApO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcbiAgICAgIFZpZXdCdWlsZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRBdHRyID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7IHJldHVybiBudWxsOyB9O1xuICAgICAgVmlld0J1aWxkZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdERpcmVjdGl2ZSA9IGZ1bmN0aW9uIChhc3QsIGN0eCkgeyByZXR1cm4gbnVsbDsgfTtcbiAgICAgIFZpZXdCdWlsZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRFdmVudCA9IGZ1bmN0aW9uIChhc3QsIGV2ZW50VGFyZ2V0QW5kTmFtZXMpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICBWaWV3QnVpbGRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0UmVmZXJlbmNlID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7IHJldHVybiBudWxsOyB9O1xuICAgICAgVmlld0J1aWxkZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFZhcmlhYmxlID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7IHJldHVybiBudWxsOyB9O1xuICAgICAgVmlld0J1aWxkZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdERpcmVjdGl2ZVByb3BlcnR5ID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyByZXR1cm4gbnVsbDsgfTtcbiAgICAgIFZpZXdCdWlsZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRFbGVtZW50UHJvcGVydHkgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IHJldHVybiBudWxsOyB9O1xuICAgICAgcmV0dXJuIFZpZXdCdWlsZGVyVmlzaXRvcjtcbiAgfSgpKTtcbiAgLyoqXG4gICAqIFdhbGtzIHVwIHRoZSBub2RlcyB3aGlsZSB0aGUgZGlyZWN0IHBhcmVudCBpcyBhIGNvbnRhaW5lci5cbiAgICpcbiAgICogUmV0dXJucyB0aGUgb3V0ZXIgY29udGFpbmVyIG9yIHRoZSBub2RlIGl0c2VsZiB3aGVuIGl0IGlzIG5vdCBhIGRpcmVjdCBjaGlsZCBvZiBhIGNvbnRhaW5lci5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICBmdW5jdGlvbiBfZ2V0T3V0ZXJDb250YWluZXJPclNlbGYobm9kZSkge1xuICAgICAgdmFyIHZpZXcgPSBub2RlLnZpZXc7XG4gICAgICB3aGlsZSAoX2lzTmdDb250YWluZXIobm9kZS5wYXJlbnQsIHZpZXcpKSB7XG4gICAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50O1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5vZGU7XG4gIH1cbiAgLyoqXG4gICAqIFdhbGtzIHVwIHRoZSBub2RlcyB3aGlsZSB0aGV5IGFyZSBjb250YWluZXIgYW5kIHJldHVybnMgdGhlIGZpcnN0IHBhcmVudCB3aGljaCBpcyBub3QuXG4gICAqXG4gICAqIFJldHVybnMgdGhlIHBhcmVudCBvZiB0aGUgb3V0ZXIgY29udGFpbmVyIG9yIHRoZSBub2RlIGl0c2VsZiB3aGVuIGl0IGlzIG5vdCBhIGNvbnRhaW5lci5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICBmdW5jdGlvbiBfZ2V0T3V0ZXJDb250YWluZXJQYXJlbnRPclNlbGYoZWwpIHtcbiAgICAgIHZhciB2aWV3ID0gZWwudmlldztcbiAgICAgIHdoaWxlIChfaXNOZ0NvbnRhaW5lcihlbCwgdmlldykpIHtcbiAgICAgICAgICBlbCA9IGVsLnBhcmVudDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBlbDtcbiAgfVxuICBmdW5jdGlvbiBfaXNOZ0NvbnRhaW5lcihub2RlLCB2aWV3KSB7XG4gICAgICByZXR1cm4gIW5vZGUuaXNOdWxsKCkgJiYgbm9kZS5zb3VyY2VBc3QubmFtZSA9PT0gTkdfQ09OVEFJTkVSX1RBRyAmJlxuICAgICAgICAgIG5vZGUudmlldyA9PT0gdmlldztcbiAgfVxuICBmdW5jdGlvbiBfbWVyZ2VIdG1sQW5kRGlyZWN0aXZlQXR0cnMoZGVjbGFyZWRIdG1sQXR0cnMsIGRpcmVjdGl2ZXMpIHtcbiAgICAgIHZhciBtYXBSZXN1bHQgPSB7fTtcbiAgICAgIE9iamVjdC5rZXlzKGRlY2xhcmVkSHRtbEF0dHJzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgbWFwUmVzdWx0W2tleV0gPSBkZWNsYXJlZEh0bWxBdHRyc1trZXldOyB9KTtcbiAgICAgIGRpcmVjdGl2ZXMuZm9yRWFjaChmdW5jdGlvbiAoZGlyZWN0aXZlTWV0YSkge1xuICAgICAgICAgIE9iamVjdC5rZXlzKGRpcmVjdGl2ZU1ldGEuaG9zdEF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgICAgdmFyIHZhbHVlID0gZGlyZWN0aXZlTWV0YS5ob3N0QXR0cmlidXRlc1tuYW1lXTtcbiAgICAgICAgICAgICAgdmFyIHByZXZWYWx1ZSA9IG1hcFJlc3VsdFtuYW1lXTtcbiAgICAgICAgICAgICAgbWFwUmVzdWx0W25hbWVdID0gaXNQcmVzZW50KHByZXZWYWx1ZSkgPyBtZXJnZUF0dHJpYnV0ZVZhbHVlKG5hbWUsIHByZXZWYWx1ZSwgdmFsdWUpIDogdmFsdWU7XG4gICAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHZhciBhcnJSZXN1bHQgPSBbXTtcbiAgICAgIC8vIE5vdGU6IFdlIG5lZWQgdG8gc29ydCB0byBnZXQgYSBkZWZpbmVkIG91dHB1dCBvcmRlclxuICAgICAgLy8gZm9yIHRlc3RzIGFuZCBmb3IgY2FjaGluZyBnZW5lcmF0ZWQgYXJ0aWZhY3RzLi4uXG4gICAgICBPYmplY3Qua2V5cyhtYXBSZXN1bHQpLnNvcnQoKS5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyTmFtZSkgeyBhcnJSZXN1bHQucHVzaChhdHRyTmFtZSwgbWFwUmVzdWx0W2F0dHJOYW1lXSk7IH0pO1xuICAgICAgcmV0dXJuIGFyclJlc3VsdDtcbiAgfVxuICBmdW5jdGlvbiBfcmVhZEh0bWxBdHRycyhhdHRycykge1xuICAgICAgdmFyIGh0bWxBdHRycyA9IHt9O1xuICAgICAgYXR0cnMuZm9yRWFjaChmdW5jdGlvbiAoYXN0KSB7IGh0bWxBdHRyc1thc3QubmFtZV0gPSBhc3QudmFsdWU7IH0pO1xuICAgICAgcmV0dXJuIGh0bWxBdHRycztcbiAgfVxuICBmdW5jdGlvbiBtZXJnZUF0dHJpYnV0ZVZhbHVlKGF0dHJOYW1lLCBhdHRyVmFsdWUxLCBhdHRyVmFsdWUyKSB7XG4gICAgICBpZiAoYXR0ck5hbWUgPT0gQ0xBU1NfQVRUUiQxIHx8IGF0dHJOYW1lID09IFNUWUxFX0FUVFIpIHtcbiAgICAgICAgICByZXR1cm4gYXR0clZhbHVlMSArIFwiIFwiICsgYXR0clZhbHVlMjtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAgIHJldHVybiBhdHRyVmFsdWUyO1xuICAgICAgfVxuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZVZpZXdUb3BMZXZlbFN0bXRzKHZpZXcsIHRhcmdldFN0YXRlbWVudHMpIHtcbiAgICAgIHZhciBub2RlRGVidWdJbmZvc1ZhciA9IE5VTExfRVhQUjtcbiAgICAgIGlmICh2aWV3LmdlbkNvbmZpZy5nZW5EZWJ1Z0luZm8pIHtcbiAgICAgICAgICBub2RlRGVidWdJbmZvc1ZhciA9IHZhcmlhYmxlKFwibm9kZURlYnVnSW5mb3NfXCIgKyB2aWV3LmNvbXBvbmVudC50eXBlLm5hbWUgKyB2aWV3LnZpZXdJbmRleCk7IC8vIGZpeCBoaWdobGlnaHRpbmc6IGBcbiAgICAgICAgICB0YXJnZXRTdGF0ZW1lbnRzLnB1c2gobm9kZURlYnVnSW5mb3NWYXJcbiAgICAgICAgICAgICAgLnNldChsaXRlcmFsQXJyKHZpZXcubm9kZXMubWFwKGNyZWF0ZVN0YXRpY05vZGVEZWJ1Z0luZm8pLCBuZXcgQXJyYXlUeXBlKG5ldyBFeHRlcm5hbFR5cGUocmVzb2x2ZUlkZW50aWZpZXIoSWRlbnRpZmllcnMuU3RhdGljTm9kZURlYnVnSW5mbykpLCBbVHlwZU1vZGlmaWVyLkNvbnN0XSkpKVxuICAgICAgICAgICAgICAudG9EZWNsU3RtdChudWxsLCBbU3RtdE1vZGlmaWVyLkZpbmFsXSkpO1xuICAgICAgfVxuICAgICAgdmFyIHJlbmRlckNvbXBUeXBlVmFyID0gdmFyaWFibGUoXCJyZW5kZXJUeXBlX1wiICsgdmlldy5jb21wb25lbnQudHlwZS5uYW1lKTsgLy8gZml4IGhpZ2hsaWdodGluZzogYFxuICAgICAgaWYgKHZpZXcudmlld0luZGV4ID09PSAwKSB7XG4gICAgICAgICAgdGFyZ2V0U3RhdGVtZW50cy5wdXNoKHJlbmRlckNvbXBUeXBlVmFyLnNldChOVUxMX0VYUFIpXG4gICAgICAgICAgICAgIC50b0RlY2xTdG10KGltcG9ydFR5cGUocmVzb2x2ZUlkZW50aWZpZXIoSWRlbnRpZmllcnMuUmVuZGVyQ29tcG9uZW50VHlwZSkpKSk7XG4gICAgICB9XG4gICAgICB2YXIgdmlld0NsYXNzID0gY3JlYXRlVmlld0NsYXNzKHZpZXcsIHJlbmRlckNvbXBUeXBlVmFyLCBub2RlRGVidWdJbmZvc1Zhcik7XG4gICAgICB0YXJnZXRTdGF0ZW1lbnRzLnB1c2godmlld0NsYXNzKTtcbiAgICAgIHRhcmdldFN0YXRlbWVudHMucHVzaChjcmVhdGVWaWV3RmFjdG9yeSh2aWV3LCB2aWV3Q2xhc3MsIHJlbmRlckNvbXBUeXBlVmFyKSk7XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlU3RhdGljTm9kZURlYnVnSW5mbyhub2RlKSB7XG4gICAgICB2YXIgY29tcGlsZUVsZW1lbnQgPSBub2RlIGluc3RhbmNlb2YgQ29tcGlsZUVsZW1lbnQgPyBub2RlIDogbnVsbDtcbiAgICAgIHZhciBwcm92aWRlclRva2VucyA9IFtdO1xuICAgICAgdmFyIGNvbXBvbmVudFRva2VuID0gTlVMTF9FWFBSO1xuICAgICAgdmFyIHZhclRva2VuRW50cmllcyA9IFtdO1xuICAgICAgaWYgKGlzUHJlc2VudChjb21waWxlRWxlbWVudCkpIHtcbiAgICAgICAgICBwcm92aWRlclRva2VucyA9IGNvbXBpbGVFbGVtZW50LmdldFByb3ZpZGVyVG9rZW5zKCk7XG4gICAgICAgICAgaWYgKGlzUHJlc2VudChjb21waWxlRWxlbWVudC5jb21wb25lbnQpKSB7XG4gICAgICAgICAgICAgIGNvbXBvbmVudFRva2VuID0gY3JlYXRlRGlUb2tlbkV4cHJlc3Npb24oaWRlbnRpZmllclRva2VuKGNvbXBpbGVFbGVtZW50LmNvbXBvbmVudC50eXBlKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIE9iamVjdC5rZXlzKGNvbXBpbGVFbGVtZW50LnJlZmVyZW5jZVRva2VucykuZm9yRWFjaChmdW5jdGlvbiAodmFyTmFtZSkge1xuICAgICAgICAgICAgICB2YXIgdG9rZW4gPSBjb21waWxlRWxlbWVudC5yZWZlcmVuY2VUb2tlbnNbdmFyTmFtZV07XG4gICAgICAgICAgICAgIHZhclRva2VuRW50cmllcy5wdXNoKFt2YXJOYW1lLCBpc1ByZXNlbnQodG9rZW4pID8gY3JlYXRlRGlUb2tlbkV4cHJlc3Npb24odG9rZW4pIDogTlVMTF9FWFBSXSk7XG4gICAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaW1wb3J0RXhwcihyZXNvbHZlSWRlbnRpZmllcihJZGVudGlmaWVycy5TdGF0aWNOb2RlRGVidWdJbmZvKSlcbiAgICAgICAgICAuaW5zdGFudGlhdGUoW1xuICAgICAgICAgIGxpdGVyYWxBcnIocHJvdmlkZXJUb2tlbnMsIG5ldyBBcnJheVR5cGUoRFlOQU1JQ19UWVBFLCBbVHlwZU1vZGlmaWVyLkNvbnN0XSkpLFxuICAgICAgICAgIGNvbXBvbmVudFRva2VuLFxuICAgICAgICAgIGxpdGVyYWxNYXAodmFyVG9rZW5FbnRyaWVzLCBuZXcgTWFwVHlwZShEWU5BTUlDX1RZUEUsIFtUeXBlTW9kaWZpZXIuQ29uc3RdKSlcbiAgICAgIF0sIGltcG9ydFR5cGUocmVzb2x2ZUlkZW50aWZpZXIoSWRlbnRpZmllcnMuU3RhdGljTm9kZURlYnVnSW5mbyksIG51bGwsIFtUeXBlTW9kaWZpZXIuQ29uc3RdKSk7XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlVmlld0NsYXNzKHZpZXcsIHJlbmRlckNvbXBUeXBlVmFyLCBub2RlRGVidWdJbmZvc1Zhcikge1xuICAgICAgdmFyIHZpZXdDb25zdHJ1Y3RvckFyZ3MgPSBbXG4gICAgICAgICAgbmV3IEZuUGFyYW0oVmlld0NvbnN0cnVjdG9yVmFycy52aWV3VXRpbHMubmFtZSwgaW1wb3J0VHlwZShyZXNvbHZlSWRlbnRpZmllcihJZGVudGlmaWVycy5WaWV3VXRpbHMpKSksXG4gICAgICAgICAgbmV3IEZuUGFyYW0oVmlld0NvbnN0cnVjdG9yVmFycy5wYXJlbnRJbmplY3Rvci5uYW1lLCBpbXBvcnRUeXBlKHJlc29sdmVJZGVudGlmaWVyKElkZW50aWZpZXJzLkluamVjdG9yKSkpLFxuICAgICAgICAgIG5ldyBGblBhcmFtKFZpZXdDb25zdHJ1Y3RvclZhcnMuZGVjbGFyYXRpb25FbC5uYW1lLCBpbXBvcnRUeXBlKHJlc29sdmVJZGVudGlmaWVyKElkZW50aWZpZXJzLkFwcEVsZW1lbnQpKSlcbiAgICAgIF07XG4gICAgICB2YXIgc3VwZXJDb25zdHJ1Y3RvckFyZ3MgPSBbXG4gICAgICAgICAgdmFyaWFibGUodmlldy5jbGFzc05hbWUpLCByZW5kZXJDb21wVHlwZVZhciwgVmlld1R5cGVFbnVtLmZyb21WYWx1ZSh2aWV3LnZpZXdUeXBlKSxcbiAgICAgICAgICBWaWV3Q29uc3RydWN0b3JWYXJzLnZpZXdVdGlscywgVmlld0NvbnN0cnVjdG9yVmFycy5wYXJlbnRJbmplY3RvcixcbiAgICAgICAgICBWaWV3Q29uc3RydWN0b3JWYXJzLmRlY2xhcmF0aW9uRWwsXG4gICAgICAgICAgQ2hhbmdlRGV0ZWN0b3JTdGF0dXNFbnVtLmZyb21WYWx1ZShnZXRDaGFuZ2VEZXRlY3Rpb25Nb2RlKHZpZXcpKVxuICAgICAgXTtcbiAgICAgIGlmICh2aWV3LmdlbkNvbmZpZy5nZW5EZWJ1Z0luZm8pIHtcbiAgICAgICAgICBzdXBlckNvbnN0cnVjdG9yQXJncy5wdXNoKG5vZGVEZWJ1Z0luZm9zVmFyKTtcbiAgICAgIH1cbiAgICAgIHZhciB2aWV3TWV0aG9kcyA9IFtcbiAgICAgICAgICBuZXcgQ2xhc3NNZXRob2QoJ2NyZWF0ZUludGVybmFsJywgW25ldyBGblBhcmFtKHJvb3RTZWxlY3RvclZhci5uYW1lLCBTVFJJTkdfVFlQRSldLCBnZW5lcmF0ZUNyZWF0ZU1ldGhvZCh2aWV3KSwgaW1wb3J0VHlwZShyZXNvbHZlSWRlbnRpZmllcihJZGVudGlmaWVycy5BcHBFbGVtZW50KSkpLFxuICAgICAgICAgIG5ldyBDbGFzc01ldGhvZCgnaW5qZWN0b3JHZXRJbnRlcm5hbCcsIFtcbiAgICAgICAgICAgICAgbmV3IEZuUGFyYW0oSW5qZWN0TWV0aG9kVmFycy50b2tlbi5uYW1lLCBEWU5BTUlDX1RZUEUpLFxuICAgICAgICAgICAgICAvLyBOb3RlOiBDYW4ndCB1c2Ugby5JTlRfVFlQRSBoZXJlIGFzIHRoZSBtZXRob2QgaW4gQXBwVmlldyB1c2VzIG51bWJlclxuICAgICAgICAgICAgICBuZXcgRm5QYXJhbShJbmplY3RNZXRob2RWYXJzLnJlcXVlc3ROb2RlSW5kZXgubmFtZSwgTlVNQkVSX1RZUEUpLFxuICAgICAgICAgICAgICBuZXcgRm5QYXJhbShJbmplY3RNZXRob2RWYXJzLm5vdEZvdW5kUmVzdWx0Lm5hbWUsIERZTkFNSUNfVFlQRSlcbiAgICAgICAgICBdLCBhZGRSZXR1cm5WYWx1ZWZOb3RFbXB0eSh2aWV3LmluamVjdG9yR2V0TWV0aG9kLmZpbmlzaCgpLCBJbmplY3RNZXRob2RWYXJzLm5vdEZvdW5kUmVzdWx0KSwgRFlOQU1JQ19UWVBFKSxcbiAgICAgICAgICBuZXcgQ2xhc3NNZXRob2QoJ2RldGVjdENoYW5nZXNJbnRlcm5hbCcsIFtuZXcgRm5QYXJhbShEZXRlY3RDaGFuZ2VzVmFycy50aHJvd09uQ2hhbmdlLm5hbWUsIEJPT0xfVFlQRSldLCBnZW5lcmF0ZURldGVjdENoYW5nZXNNZXRob2QodmlldykpLFxuICAgICAgICAgIG5ldyBDbGFzc01ldGhvZCgnZGlydHlQYXJlbnRRdWVyaWVzSW50ZXJuYWwnLCBbXSwgdmlldy5kaXJ0eVBhcmVudFF1ZXJpZXNNZXRob2QuZmluaXNoKCkpLFxuICAgICAgICAgIG5ldyBDbGFzc01ldGhvZCgnZGVzdHJveUludGVybmFsJywgW10sIHZpZXcuZGVzdHJveU1ldGhvZC5maW5pc2goKSksXG4gICAgICAgICAgbmV3IENsYXNzTWV0aG9kKCdkZXRhY2hJbnRlcm5hbCcsIFtdLCB2aWV3LmRldGFjaE1ldGhvZC5maW5pc2goKSlcbiAgICAgIF0uZmlsdGVyKGZ1bmN0aW9uIChtZXRob2QpIHsgcmV0dXJuIG1ldGhvZC5ib2R5Lmxlbmd0aCA+IDA7IH0pO1xuICAgICAgdmFyIHN1cGVyQ2xhc3MgPSB2aWV3LmdlbkNvbmZpZy5nZW5EZWJ1Z0luZm8gPyBJZGVudGlmaWVycy5EZWJ1Z0FwcFZpZXcgOiBJZGVudGlmaWVycy5BcHBWaWV3O1xuICAgICAgdmFyIHZpZXdDbGFzcyA9IGNyZWF0ZUNsYXNzU3RtdCh7XG4gICAgICAgICAgbmFtZTogdmlldy5jbGFzc05hbWUsXG4gICAgICAgICAgcGFyZW50OiBpbXBvcnRFeHByKHJlc29sdmVJZGVudGlmaWVyKHN1cGVyQ2xhc3MpLCBbZ2V0Q29udGV4dFR5cGUodmlldyldKSxcbiAgICAgICAgICBwYXJlbnRBcmdzOiBzdXBlckNvbnN0cnVjdG9yQXJncyxcbiAgICAgICAgICBjdG9yUGFyYW1zOiB2aWV3Q29uc3RydWN0b3JBcmdzLFxuICAgICAgICAgIGJ1aWxkZXJzOiBbeyBtZXRob2RzOiB2aWV3TWV0aG9kcyB9LCB2aWV3XVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdmlld0NsYXNzO1xuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZVZpZXdGYWN0b3J5KHZpZXcsIHZpZXdDbGFzcywgcmVuZGVyQ29tcFR5cGVWYXIpIHtcbiAgICAgIHZhciB2aWV3RmFjdG9yeUFyZ3MgPSBbXG4gICAgICAgICAgbmV3IEZuUGFyYW0oVmlld0NvbnN0cnVjdG9yVmFycy52aWV3VXRpbHMubmFtZSwgaW1wb3J0VHlwZShyZXNvbHZlSWRlbnRpZmllcihJZGVudGlmaWVycy5WaWV3VXRpbHMpKSksXG4gICAgICAgICAgbmV3IEZuUGFyYW0oVmlld0NvbnN0cnVjdG9yVmFycy5wYXJlbnRJbmplY3Rvci5uYW1lLCBpbXBvcnRUeXBlKHJlc29sdmVJZGVudGlmaWVyKElkZW50aWZpZXJzLkluamVjdG9yKSkpLFxuICAgICAgICAgIG5ldyBGblBhcmFtKFZpZXdDb25zdHJ1Y3RvclZhcnMuZGVjbGFyYXRpb25FbC5uYW1lLCBpbXBvcnRUeXBlKHJlc29sdmVJZGVudGlmaWVyKElkZW50aWZpZXJzLkFwcEVsZW1lbnQpKSlcbiAgICAgIF07XG4gICAgICB2YXIgaW5pdFJlbmRlckNvbXBUeXBlU3RtdHMgPSBbXTtcbiAgICAgIHZhciB0ZW1wbGF0ZVVybEluZm87XG4gICAgICBpZiAodmlldy5jb21wb25lbnQudGVtcGxhdGUudGVtcGxhdGVVcmwgPT0gdmlldy5jb21wb25lbnQudHlwZS5tb2R1bGVVcmwpIHtcbiAgICAgICAgICB0ZW1wbGF0ZVVybEluZm8gPVxuICAgICAgICAgICAgICB2aWV3LmNvbXBvbmVudC50eXBlLm1vZHVsZVVybCArIFwiIGNsYXNzIFwiICsgdmlldy5jb21wb25lbnQudHlwZS5uYW1lICsgXCIgLSBpbmxpbmUgdGVtcGxhdGVcIjtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAgIHRlbXBsYXRlVXJsSW5mbyA9IHZpZXcuY29tcG9uZW50LnRlbXBsYXRlLnRlbXBsYXRlVXJsO1xuICAgICAgfVxuICAgICAgaWYgKHZpZXcudmlld0luZGV4ID09PSAwKSB7XG4gICAgICAgICAgdmFyIGFuaW1hdGlvbnNFeHByID0gbGl0ZXJhbE1hcCh2aWV3LmFuaW1hdGlvbnMubWFwKGZ1bmN0aW9uIChlbnRyeSkgeyByZXR1cm4gW2VudHJ5Lm5hbWUsIGVudHJ5LmZuRXhwXTsgfSkpO1xuICAgICAgICAgIGluaXRSZW5kZXJDb21wVHlwZVN0bXRzID0gW1xuICAgICAgICAgICAgICBuZXcgSWZTdG10KHJlbmRlckNvbXBUeXBlVmFyLmlkZW50aWNhbChOVUxMX0VYUFIpLCBbXG4gICAgICAgICAgICAgICAgICByZW5kZXJDb21wVHlwZVZhclxuICAgICAgICAgICAgICAgICAgICAgIC5zZXQoVmlld0NvbnN0cnVjdG9yVmFycy52aWV3VXRpbHMuY2FsbE1ldGhvZCgnY3JlYXRlUmVuZGVyQ29tcG9uZW50VHlwZScsIFtcbiAgICAgICAgICAgICAgICAgICAgICB2aWV3LmdlbkNvbmZpZy5nZW5EZWJ1Z0luZm8gPyBsaXRlcmFsKHRlbXBsYXRlVXJsSW5mbykgOiBsaXRlcmFsKCcnKSxcbiAgICAgICAgICAgICAgICAgICAgICBsaXRlcmFsKHZpZXcuY29tcG9uZW50LnRlbXBsYXRlLm5nQ29udGVudFNlbGVjdG9ycy5sZW5ndGgpLFxuICAgICAgICAgICAgICAgICAgICAgIFZpZXdFbmNhcHN1bGF0aW9uRW51bS5mcm9tVmFsdWUodmlldy5jb21wb25lbnQudGVtcGxhdGUuZW5jYXBzdWxhdGlvbiksXG4gICAgICAgICAgICAgICAgICAgICAgdmlldy5zdHlsZXMsXG4gICAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uc0V4cHIsXG4gICAgICAgICAgICAgICAgICBdKSlcbiAgICAgICAgICAgICAgICAgICAgICAudG9TdG10KCksXG4gICAgICAgICAgICAgIF0pLFxuICAgICAgICAgIF07XG4gICAgICB9XG4gICAgICByZXR1cm4gZm4odmlld0ZhY3RvcnlBcmdzLCBpbml0UmVuZGVyQ29tcFR5cGVTdG10cy5jb25jYXQoW1xuICAgICAgICAgIG5ldyBSZXR1cm5TdGF0ZW1lbnQodmFyaWFibGUodmlld0NsYXNzLm5hbWUpXG4gICAgICAgICAgICAgIC5pbnN0YW50aWF0ZSh2aWV3Q2xhc3MuY29uc3RydWN0b3JNZXRob2QucGFyYW1zLm1hcChmdW5jdGlvbiAocGFyYW0pIHsgcmV0dXJuIHZhcmlhYmxlKHBhcmFtLm5hbWUpOyB9KSkpLFxuICAgICAgXSksIGltcG9ydFR5cGUocmVzb2x2ZUlkZW50aWZpZXIoSWRlbnRpZmllcnMuQXBwVmlldyksIFtnZXRDb250ZXh0VHlwZSh2aWV3KV0pKVxuICAgICAgICAgIC50b0RlY2xTdG10KHZpZXcudmlld0ZhY3RvcnkubmFtZSwgW1N0bXRNb2RpZmllci5GaW5hbF0pO1xuICB9XG4gIGZ1bmN0aW9uIGdlbmVyYXRlQ3JlYXRlTWV0aG9kKHZpZXcpIHtcbiAgICAgIHZhciBwYXJlbnRSZW5kZXJOb2RlRXhwciA9IE5VTExfRVhQUjtcbiAgICAgIHZhciBwYXJlbnRSZW5kZXJOb2RlU3RtdHMgPSBbXTtcbiAgICAgIGlmICh2aWV3LnZpZXdUeXBlID09PSBWaWV3VHlwZS5DT01QT05FTlQpIHtcbiAgICAgICAgICBwYXJlbnRSZW5kZXJOb2RlRXhwciA9IFZpZXdQcm9wZXJ0aWVzLnJlbmRlcmVyLmNhbGxNZXRob2QoJ2NyZWF0ZVZpZXdSb290JywgW1RISVNfRVhQUi5wcm9wKCdkZWNsYXJhdGlvbkFwcEVsZW1lbnQnKS5wcm9wKCduYXRpdmVFbGVtZW50JyldKTtcbiAgICAgICAgICBwYXJlbnRSZW5kZXJOb2RlU3RtdHMgPVxuICAgICAgICAgICAgICBbcGFyZW50UmVuZGVyTm9kZVZhci5zZXQocGFyZW50UmVuZGVyTm9kZUV4cHIpXG4gICAgICAgICAgICAgICAgICAgICAgLnRvRGVjbFN0bXQoaW1wb3J0VHlwZSh2aWV3LmdlbkNvbmZpZy5yZW5kZXJUeXBlcy5yZW5kZXJOb2RlKSwgW1N0bXRNb2RpZmllci5GaW5hbF0pXTtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHRFeHByO1xuICAgICAgaWYgKHZpZXcudmlld1R5cGUgPT09IFZpZXdUeXBlLkhPU1QpIHtcbiAgICAgICAgICByZXN1bHRFeHByID0gdmlldy5ub2Rlc1swXS5hcHBFbGVtZW50O1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICAgcmVzdWx0RXhwciA9IE5VTExfRVhQUjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJlbnRSZW5kZXJOb2RlU3RtdHMuY29uY2F0KHZpZXcuY3JlYXRlTWV0aG9kLmZpbmlzaCgpLCBbXG4gICAgICAgICAgVEhJU19FWFBSXG4gICAgICAgICAgICAgIC5jYWxsTWV0aG9kKCdpbml0JywgW1xuICAgICAgICAgICAgICBjcmVhdGVGbGF0QXJyYXkodmlldy5yb290Tm9kZXNPckFwcEVsZW1lbnRzKSxcbiAgICAgICAgICAgICAgbGl0ZXJhbEFycih2aWV3Lm5vZGVzLm1hcChmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZS5yZW5kZXJOb2RlOyB9KSksIGxpdGVyYWxBcnIodmlldy5kaXNwb3NhYmxlcyksXG4gICAgICAgICAgICAgIGxpdGVyYWxBcnIodmlldy5zdWJzY3JpcHRpb25zKVxuICAgICAgICAgIF0pXG4gICAgICAgICAgICAgIC50b1N0bXQoKSxcbiAgICAgICAgICBuZXcgUmV0dXJuU3RhdGVtZW50KHJlc3VsdEV4cHIpXG4gICAgICBdKTtcbiAgfVxuICBmdW5jdGlvbiBnZW5lcmF0ZURldGVjdENoYW5nZXNNZXRob2Qodmlldykge1xuICAgICAgdmFyIHN0bXRzID0gW107XG4gICAgICBpZiAodmlldy5hbmltYXRpb25CaW5kaW5nc01ldGhvZC5pc0VtcHR5KCkgJiYgdmlldy5kZXRlY3RDaGFuZ2VzSW5JbnB1dHNNZXRob2QuaXNFbXB0eSgpICYmXG4gICAgICAgICAgdmlldy51cGRhdGVDb250ZW50UXVlcmllc01ldGhvZC5pc0VtcHR5KCkgJiZcbiAgICAgICAgICB2aWV3LmFmdGVyQ29udGVudExpZmVjeWNsZUNhbGxiYWNrc01ldGhvZC5pc0VtcHR5KCkgJiZcbiAgICAgICAgICB2aWV3LmRldGVjdENoYW5nZXNSZW5kZXJQcm9wZXJ0aWVzTWV0aG9kLmlzRW1wdHkoKSAmJlxuICAgICAgICAgIHZpZXcudXBkYXRlVmlld1F1ZXJpZXNNZXRob2QuaXNFbXB0eSgpICYmIHZpZXcuYWZ0ZXJWaWV3TGlmZWN5Y2xlQ2FsbGJhY2tzTWV0aG9kLmlzRW1wdHkoKSkge1xuICAgICAgICAgIHJldHVybiBzdG10cztcbiAgICAgIH1cbiAgICAgIHN0bXRzLnB1c2guYXBwbHkoc3RtdHMsIHZpZXcuYW5pbWF0aW9uQmluZGluZ3NNZXRob2QuZmluaXNoKCkpO1xuICAgICAgc3RtdHMucHVzaC5hcHBseShzdG10cywgdmlldy5kZXRlY3RDaGFuZ2VzSW5JbnB1dHNNZXRob2QuZmluaXNoKCkpO1xuICAgICAgc3RtdHMucHVzaChUSElTX0VYUFIuY2FsbE1ldGhvZCgnZGV0ZWN0Q29udGVudENoaWxkcmVuQ2hhbmdlcycsIFtEZXRlY3RDaGFuZ2VzVmFycy50aHJvd09uQ2hhbmdlXSlcbiAgICAgICAgICAudG9TdG10KCkpO1xuICAgICAgdmFyIGFmdGVyQ29udGVudFN0bXRzID0gdmlldy51cGRhdGVDb250ZW50UXVlcmllc01ldGhvZC5maW5pc2goKS5jb25jYXQodmlldy5hZnRlckNvbnRlbnRMaWZlY3ljbGVDYWxsYmFja3NNZXRob2QuZmluaXNoKCkpO1xuICAgICAgaWYgKGFmdGVyQ29udGVudFN0bXRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBzdG10cy5wdXNoKG5ldyBJZlN0bXQobm90KERldGVjdENoYW5nZXNWYXJzLnRocm93T25DaGFuZ2UpLCBhZnRlckNvbnRlbnRTdG10cykpO1xuICAgICAgfVxuICAgICAgc3RtdHMucHVzaC5hcHBseShzdG10cywgdmlldy5kZXRlY3RDaGFuZ2VzUmVuZGVyUHJvcGVydGllc01ldGhvZC5maW5pc2goKSk7XG4gICAgICBzdG10cy5wdXNoKFRISVNfRVhQUi5jYWxsTWV0aG9kKCdkZXRlY3RWaWV3Q2hpbGRyZW5DaGFuZ2VzJywgW0RldGVjdENoYW5nZXNWYXJzLnRocm93T25DaGFuZ2VdKVxuICAgICAgICAgIC50b1N0bXQoKSk7XG4gICAgICB2YXIgYWZ0ZXJWaWV3U3RtdHMgPSB2aWV3LnVwZGF0ZVZpZXdRdWVyaWVzTWV0aG9kLmZpbmlzaCgpLmNvbmNhdCh2aWV3LmFmdGVyVmlld0xpZmVjeWNsZUNhbGxiYWNrc01ldGhvZC5maW5pc2goKSk7XG4gICAgICBpZiAoYWZ0ZXJWaWV3U3RtdHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHN0bXRzLnB1c2gobmV3IElmU3RtdChub3QoRGV0ZWN0Q2hhbmdlc1ZhcnMudGhyb3dPbkNoYW5nZSksIGFmdGVyVmlld1N0bXRzKSk7XG4gICAgICB9XG4gICAgICB2YXIgdmFyU3RtdHMgPSBbXTtcbiAgICAgIHZhciByZWFkVmFycyA9IGZpbmRSZWFkVmFyTmFtZXMoc3RtdHMpO1xuICAgICAgaWYgKHJlYWRWYXJzLmhhcyhEZXRlY3RDaGFuZ2VzVmFycy5jaGFuZ2VkLm5hbWUpKSB7XG4gICAgICAgICAgdmFyU3RtdHMucHVzaChEZXRlY3RDaGFuZ2VzVmFycy5jaGFuZ2VkLnNldChsaXRlcmFsKHRydWUpKS50b0RlY2xTdG10KEJPT0xfVFlQRSkpO1xuICAgICAgfVxuICAgICAgaWYgKHJlYWRWYXJzLmhhcyhEZXRlY3RDaGFuZ2VzVmFycy5jaGFuZ2VzLm5hbWUpKSB7XG4gICAgICAgICAgdmFyU3RtdHMucHVzaChEZXRlY3RDaGFuZ2VzVmFycy5jaGFuZ2VzLnNldChOVUxMX0VYUFIpXG4gICAgICAgICAgICAgIC50b0RlY2xTdG10KG5ldyBNYXBUeXBlKGltcG9ydFR5cGUocmVzb2x2ZUlkZW50aWZpZXIoSWRlbnRpZmllcnMuU2ltcGxlQ2hhbmdlKSkpKSk7XG4gICAgICB9XG4gICAgICB2YXJTdG10cy5wdXNoLmFwcGx5KHZhclN0bXRzLCBjcmVhdGVTaGFyZWRCaW5kaW5nVmFyaWFibGVzSWZOZWVkZWQoc3RtdHMpKTtcbiAgICAgIHJldHVybiB2YXJTdG10cy5jb25jYXQoc3RtdHMpO1xuICB9XG4gIGZ1bmN0aW9uIGFkZFJldHVyblZhbHVlZk5vdEVtcHR5KHN0YXRlbWVudHMsIHZhbHVlKSB7XG4gICAgICBpZiAoc3RhdGVtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgcmV0dXJuIHN0YXRlbWVudHMuY29uY2F0KFtuZXcgUmV0dXJuU3RhdGVtZW50KHZhbHVlKV0pO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHN0YXRlbWVudHM7XG4gICAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZ2V0Q29udGV4dFR5cGUodmlldykge1xuICAgICAgaWYgKHZpZXcudmlld1R5cGUgPT09IFZpZXdUeXBlLkNPTVBPTkVOVCkge1xuICAgICAgICAgIHJldHVybiBpbXBvcnRUeXBlKHZpZXcuY29tcG9uZW50LnR5cGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIERZTkFNSUNfVFlQRTtcbiAgfVxuICBmdW5jdGlvbiBnZXRDaGFuZ2VEZXRlY3Rpb25Nb2RlKHZpZXcpIHtcbiAgICAgIHZhciBtb2RlO1xuICAgICAgaWYgKHZpZXcudmlld1R5cGUgPT09IFZpZXdUeXBlLkNPTVBPTkVOVCkge1xuICAgICAgICAgIG1vZGUgPSBpc0RlZmF1bHRDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSh2aWV3LmNvbXBvbmVudC5jaGFuZ2VEZXRlY3Rpb24pID9cbiAgICAgICAgICAgICAgQ2hhbmdlRGV0ZWN0b3JTdGF0dXMuQ2hlY2tBbHdheXMgOlxuICAgICAgICAgICAgICBDaGFuZ2VEZXRlY3RvclN0YXR1cy5DaGVja09uY2U7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgICBtb2RlID0gQ2hhbmdlRGV0ZWN0b3JTdGF0dXMuQ2hlY2tBbHdheXM7XG4gICAgICB9XG4gICAgICByZXR1cm4gbW9kZTtcbiAgfVxuXG4gIHZhciBWaWV3Q29tcGlsZVJlc3VsdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBWaWV3Q29tcGlsZVJlc3VsdChzdGF0ZW1lbnRzLCB2aWV3RmFjdG9yeVZhciwgZGVwZW5kZW5jaWVzKSB7XG4gICAgICAgICAgdGhpcy5zdGF0ZW1lbnRzID0gc3RhdGVtZW50cztcbiAgICAgICAgICB0aGlzLnZpZXdGYWN0b3J5VmFyID0gdmlld0ZhY3RvcnlWYXI7XG4gICAgICAgICAgdGhpcy5kZXBlbmRlbmNpZXMgPSBkZXBlbmRlbmNpZXM7XG4gICAgICB9XG4gICAgICByZXR1cm4gVmlld0NvbXBpbGVSZXN1bHQ7XG4gIH0oKSk7XG4gIHZhciBWaWV3Q29tcGlsZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gVmlld0NvbXBpbGVyKF9nZW5Db25maWcsIF9zY2hlbWFSZWdpc3RyeSkge1xuICAgICAgICAgIHRoaXMuX2dlbkNvbmZpZyA9IF9nZW5Db25maWc7XG4gICAgICAgICAgdGhpcy5fc2NoZW1hUmVnaXN0cnkgPSBfc2NoZW1hUmVnaXN0cnk7XG4gICAgICB9XG4gICAgICBWaWV3Q29tcGlsZXIucHJvdG90eXBlLmNvbXBpbGVDb21wb25lbnQgPSBmdW5jdGlvbiAoY29tcG9uZW50LCB0ZW1wbGF0ZSwgc3R5bGVzLCBwaXBlcywgY29tcGlsZWRBbmltYXRpb25zKSB7XG4gICAgICAgICAgdmFyIGRlcGVuZGVuY2llcyA9IFtdO1xuICAgICAgICAgIHZhciB2aWV3ID0gbmV3IENvbXBpbGVWaWV3KGNvbXBvbmVudCwgdGhpcy5fZ2VuQ29uZmlnLCBwaXBlcywgc3R5bGVzLCBjb21waWxlZEFuaW1hdGlvbnMsIDAsIENvbXBpbGVFbGVtZW50LmNyZWF0ZU51bGwoKSwgW10pO1xuICAgICAgICAgIHZhciBzdGF0ZW1lbnRzID0gW107XG4gICAgICAgICAgYnVpbGRWaWV3KHZpZXcsIHRlbXBsYXRlLCBkZXBlbmRlbmNpZXMpO1xuICAgICAgICAgIC8vIE5lZWQgdG8gc2VwYXJhdGUgYmluZGluZyBmcm9tIGNyZWF0aW9uIHRvIGJlIGFibGUgdG8gcmVmZXIgdG9cbiAgICAgICAgICAvLyB2YXJpYWJsZXMgdGhhdCBoYXZlIGJlZW4gZGVjbGFyZWQgYWZ0ZXIgdXNhZ2UuXG4gICAgICAgICAgYmluZFZpZXcodmlldywgdGVtcGxhdGUsIHRoaXMuX3NjaGVtYVJlZ2lzdHJ5KTtcbiAgICAgICAgICBmaW5pc2hWaWV3KHZpZXcsIHN0YXRlbWVudHMpO1xuICAgICAgICAgIHJldHVybiBuZXcgVmlld0NvbXBpbGVSZXN1bHQoc3RhdGVtZW50cywgdmlldy52aWV3RmFjdG9yeS5uYW1lLCBkZXBlbmRlbmNpZXMpO1xuICAgICAgfTtcbiAgICAgIFZpZXdDb21waWxlci5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3RhYmxlIH0sXG4gICAgICBdO1xuICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICBWaWV3Q29tcGlsZXIuY3RvclBhcmFtZXRlcnMgPSBbXG4gICAgICAgICAgeyB0eXBlOiBDb21waWxlckNvbmZpZywgfSxcbiAgICAgICAgICB7IHR5cGU6IEVsZW1lbnRTY2hlbWFSZWdpc3RyeSwgfSxcbiAgICAgIF07XG4gICAgICByZXR1cm4gVmlld0NvbXBpbGVyO1xuICB9KCkpO1xuXG4gIHZhciBTb3VyY2VNb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gU291cmNlTW9kdWxlKGZpbGVVcmwsIG1vZHVsZVVybCwgc291cmNlKSB7XG4gICAgICAgICAgdGhpcy5maWxlVXJsID0gZmlsZVVybDtcbiAgICAgICAgICB0aGlzLm1vZHVsZVVybCA9IG1vZHVsZVVybDtcbiAgICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBTb3VyY2VNb2R1bGU7XG4gIH0oKSk7XG4gIC8vIFJldHVybnMgYWxsIHRoZSBzb3VyY2UgZmlsZXMgYW5kIGEgbWFwcGluZyBmcm9tIG1vZHVsZXMgdG8gZGlyZWN0aXZlc1xuICBmdW5jdGlvbiBhbmFseXplTmdNb2R1bGVzKHByb2dyYW1TdGF0aWNTeW1ib2xzLCBvcHRpb25zLCBtZXRhZGF0YVJlc29sdmVyKSB7XG4gICAgICB2YXIgX2EgPSBfZXh0cmFjdE1vZHVsZXNBbmRQaXBlc09yRGlyZWN0aXZlcyhwcm9ncmFtU3RhdGljU3ltYm9scywgbWV0YWRhdGFSZXNvbHZlciksIHByb2dyYW1OZ01vZHVsZXMgPSBfYS5uZ01vZHVsZXMsIHByb2dyYW1QaXBlc09yRGlyZWN0aXZlcyA9IF9hLnBpcGVzQW5kRGlyZWN0aXZlcztcbiAgICAgIHZhciBtb2R1bGVNZXRhc0J5UmVmID0gbmV3IE1hcCgpO1xuICAgICAgcHJvZ3JhbU5nTW9kdWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChtb2RNZXRhKSB7XG4gICAgICAgICAgaWYgKG9wdGlvbnMudHJhbnNpdGl2ZU1vZHVsZXMpIHtcbiAgICAgICAgICAgICAgLy8gRm9yIGV2ZXJ5IGlucHV0IG1vZHVsZXMgYWRkIHRoZSBsaXN0IG9mIHRyYW5zaXRpdmVseSBpbmNsdWRlZCBtb2R1bGVzXG4gICAgICAgICAgICAgIG1vZE1ldGEudHJhbnNpdGl2ZU1vZHVsZS5tb2R1bGVzLmZvckVhY2goZnVuY3Rpb24gKG1vZE1ldGEpIHsgbW9kdWxlTWV0YXNCeVJlZi5zZXQobW9kTWV0YS50eXBlLnJlZmVyZW5jZSwgbW9kTWV0YSk7IH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgbW9kdWxlTWV0YXNCeVJlZi5zZXQobW9kTWV0YS50eXBlLnJlZmVyZW5jZSwgbW9kTWV0YSk7XG4gICAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB2YXIgbmdNb2R1bGVNZXRhcyA9IE1hcFdyYXBwZXIudmFsdWVzKG1vZHVsZU1ldGFzQnlSZWYpO1xuICAgICAgdmFyIG5nTW9kdWxlQnlQaXBlT3JEaXJlY3RpdmUgPSBuZXcgTWFwKCk7XG4gICAgICB2YXIgbmdNb2R1bGVzQnlGaWxlID0gbmV3IE1hcCgpO1xuICAgICAgdmFyIG5nRGlyZWN0aXZlc0J5RmlsZSA9IG5ldyBNYXAoKTtcbiAgICAgIHZhciBmaWxlUGF0aHMgPSBuZXcgU2V0KCk7XG4gICAgICAvLyBMb29waW5nIG92ZXIgYWxsIG1vZHVsZXMgdG8gY29uc3RydWN0OlxuICAgICAgLy8gLSBhIG1hcCBmcm9tIGZpbGUgdG8gbW9kdWxlcyBgbmdNb2R1bGVzQnlGaWxlYCxcbiAgICAgIC8vIC0gYSBtYXAgZnJvbSBmaWxlIHRvIGRpcmVjdGl2ZXMgYG5nRGlyZWN0aXZlc0J5RmlsZWAsXG4gICAgICAvLyAtIGEgbWFwIGZyb20gZGlyZWN0aXZlL3BpcGUgdG8gbW9kdWxlIGBuZ01vZHVsZUJ5UGlwZU9yRGlyZWN0aXZlYC5cbiAgICAgIG5nTW9kdWxlTWV0YXMuZm9yRWFjaChmdW5jdGlvbiAobmdNb2R1bGVNZXRhKSB7XG4gICAgICAgICAgdmFyIHNyY0ZpbGVVcmwgPSBuZ01vZHVsZU1ldGEudHlwZS5yZWZlcmVuY2UuZmlsZVBhdGg7XG4gICAgICAgICAgZmlsZVBhdGhzLmFkZChzcmNGaWxlVXJsKTtcbiAgICAgICAgICBuZ01vZHVsZXNCeUZpbGUuc2V0KHNyY0ZpbGVVcmwsIChuZ01vZHVsZXNCeUZpbGUuZ2V0KHNyY0ZpbGVVcmwpIHx8IFtdKS5jb25jYXQobmdNb2R1bGVNZXRhLnR5cGUucmVmZXJlbmNlKSk7XG4gICAgICAgICAgbmdNb2R1bGVNZXRhLmRlY2xhcmVkRGlyZWN0aXZlcy5mb3JFYWNoKGZ1bmN0aW9uIChkaXJNZXRhKSB7XG4gICAgICAgICAgICAgIHZhciBmaWxlVXJsID0gZGlyTWV0YS50eXBlLnJlZmVyZW5jZS5maWxlUGF0aDtcbiAgICAgICAgICAgICAgZmlsZVBhdGhzLmFkZChmaWxlVXJsKTtcbiAgICAgICAgICAgICAgbmdEaXJlY3RpdmVzQnlGaWxlLnNldChmaWxlVXJsLCAobmdEaXJlY3RpdmVzQnlGaWxlLmdldChmaWxlVXJsKSB8fCBbXSkuY29uY2F0KGRpck1ldGEudHlwZS5yZWZlcmVuY2UpKTtcbiAgICAgICAgICAgICAgbmdNb2R1bGVCeVBpcGVPckRpcmVjdGl2ZS5zZXQoZGlyTWV0YS50eXBlLnJlZmVyZW5jZSwgbmdNb2R1bGVNZXRhKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBuZ01vZHVsZU1ldGEuZGVjbGFyZWRQaXBlcy5mb3JFYWNoKGZ1bmN0aW9uIChwaXBlTWV0YSkge1xuICAgICAgICAgICAgICB2YXIgZmlsZVVybCA9IHBpcGVNZXRhLnR5cGUucmVmZXJlbmNlLmZpbGVQYXRoO1xuICAgICAgICAgICAgICBmaWxlUGF0aHMuYWRkKGZpbGVVcmwpO1xuICAgICAgICAgICAgICBuZ01vZHVsZUJ5UGlwZU9yRGlyZWN0aXZlLnNldChwaXBlTWV0YS50eXBlLnJlZmVyZW5jZSwgbmdNb2R1bGVNZXRhKTtcbiAgICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgLy8gVGhyb3cgYW4gZXJyb3IgaWYgYW55IG9mIHRoZSBwcm9ncmFtIHBpcGUgb3IgZGlyZWN0aXZlcyBpcyBub3QgZGVjbGFyZWQgYnkgYSBtb2R1bGVcbiAgICAgIHZhciBzeW1ib2xzTWlzc2luZ01vZHVsZSA9IHByb2dyYW1QaXBlc09yRGlyZWN0aXZlcy5maWx0ZXIoZnVuY3Rpb24gKHMpIHsgcmV0dXJuICFuZ01vZHVsZUJ5UGlwZU9yRGlyZWN0aXZlLmhhcyhzKTsgfSk7XG4gICAgICBpZiAoc3ltYm9sc01pc3NpbmdNb2R1bGUubGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIG1lc3NhZ2VzID0gc3ltYm9sc01pc3NpbmdNb2R1bGUubWFwKGZ1bmN0aW9uIChzKSB7IHJldHVybiAoXCJDYW5ub3QgZGV0ZXJtaW5lIHRoZSBtb2R1bGUgZm9yIGNsYXNzIFwiICsgcy5uYW1lICsgXCIgaW4gXCIgKyBzLmZpbGVQYXRoICsgXCIhXCIpOyB9KTtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZXMuam9pbignXFxuJykpO1xuICAgICAgfVxuICAgICAgdmFyIGZpbGVzID0gW107XG4gICAgICBmaWxlUGF0aHMuZm9yRWFjaChmdW5jdGlvbiAoc3JjVXJsKSB7XG4gICAgICAgICAgdmFyIGRpcmVjdGl2ZXMgPSBuZ0RpcmVjdGl2ZXNCeUZpbGUuZ2V0KHNyY1VybCkgfHwgW107XG4gICAgICAgICAgdmFyIG5nTW9kdWxlcyA9IG5nTW9kdWxlc0J5RmlsZS5nZXQoc3JjVXJsKSB8fCBbXTtcbiAgICAgICAgICBmaWxlcy5wdXNoKHsgc3JjVXJsOiBzcmNVcmwsIGRpcmVjdGl2ZXM6IGRpcmVjdGl2ZXMsIG5nTW9kdWxlczogbmdNb2R1bGVzIH0pO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAgIC8vIG1hcCBkaXJlY3RpdmUvcGlwZSB0byBtb2R1bGVcbiAgICAgICAgICBuZ01vZHVsZUJ5UGlwZU9yRGlyZWN0aXZlOiBuZ01vZHVsZUJ5UGlwZU9yRGlyZWN0aXZlLFxuICAgICAgICAgIC8vIGxpc3QgbW9kdWxlcyBhbmQgZGlyZWN0aXZlcyBmb3IgZXZlcnkgc291cmNlIGZpbGVcbiAgICAgICAgICBmaWxlczogZmlsZXMsXG4gICAgICB9O1xuICB9XG4gIHZhciBPZmZsaW5lQ29tcGlsZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gT2ZmbGluZUNvbXBpbGVyKF9tZXRhZGF0YVJlc29sdmVyLCBfZGlyZWN0aXZlTm9ybWFsaXplciwgX3RlbXBsYXRlUGFyc2VyLCBfc3R5bGVDb21waWxlciwgX3ZpZXdDb21waWxlciwgX2RpcldyYXBwZXJDb21waWxlciwgX25nTW9kdWxlQ29tcGlsZXIsIF9vdXRwdXRFbWl0dGVyLCBfbG9jYWxlSWQsIF90cmFuc2xhdGlvbkZvcm1hdCkge1xuICAgICAgICAgIHRoaXMuX21ldGFkYXRhUmVzb2x2ZXIgPSBfbWV0YWRhdGFSZXNvbHZlcjtcbiAgICAgICAgICB0aGlzLl9kaXJlY3RpdmVOb3JtYWxpemVyID0gX2RpcmVjdGl2ZU5vcm1hbGl6ZXI7XG4gICAgICAgICAgdGhpcy5fdGVtcGxhdGVQYXJzZXIgPSBfdGVtcGxhdGVQYXJzZXI7XG4gICAgICAgICAgdGhpcy5fc3R5bGVDb21waWxlciA9IF9zdHlsZUNvbXBpbGVyO1xuICAgICAgICAgIHRoaXMuX3ZpZXdDb21waWxlciA9IF92aWV3Q29tcGlsZXI7XG4gICAgICAgICAgdGhpcy5fZGlyV3JhcHBlckNvbXBpbGVyID0gX2RpcldyYXBwZXJDb21waWxlcjtcbiAgICAgICAgICB0aGlzLl9uZ01vZHVsZUNvbXBpbGVyID0gX25nTW9kdWxlQ29tcGlsZXI7XG4gICAgICAgICAgdGhpcy5fb3V0cHV0RW1pdHRlciA9IF9vdXRwdXRFbWl0dGVyO1xuICAgICAgICAgIHRoaXMuX2xvY2FsZUlkID0gX2xvY2FsZUlkO1xuICAgICAgICAgIHRoaXMuX3RyYW5zbGF0aW9uRm9ybWF0ID0gX3RyYW5zbGF0aW9uRm9ybWF0O1xuICAgICAgICAgIHRoaXMuX2FuaW1hdGlvblBhcnNlciA9IG5ldyBBbmltYXRpb25QYXJzZXIoKTtcbiAgICAgICAgICB0aGlzLl9hbmltYXRpb25Db21waWxlciA9IG5ldyBBbmltYXRpb25Db21waWxlcigpO1xuICAgICAgfVxuICAgICAgT2ZmbGluZUNvbXBpbGVyLnByb3RvdHlwZS5jbGVhckNhY2hlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoaXMuX2RpcmVjdGl2ZU5vcm1hbGl6ZXIuY2xlYXJDYWNoZSgpO1xuICAgICAgICAgIHRoaXMuX21ldGFkYXRhUmVzb2x2ZXIuY2xlYXJDYWNoZSgpO1xuICAgICAgfTtcbiAgICAgIE9mZmxpbmVDb21waWxlci5wcm90b3R5cGUuY29tcGlsZU1vZHVsZXMgPSBmdW5jdGlvbiAoc3RhdGljU3ltYm9scywgb3B0aW9ucykge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgdmFyIF9hID0gYW5hbHl6ZU5nTW9kdWxlcyhzdGF0aWNTeW1ib2xzLCBvcHRpb25zLCB0aGlzLl9tZXRhZGF0YVJlc29sdmVyKSwgbmdNb2R1bGVCeVBpcGVPckRpcmVjdGl2ZSA9IF9hLm5nTW9kdWxlQnlQaXBlT3JEaXJlY3RpdmUsIGZpbGVzID0gX2EuZmlsZXM7XG4gICAgICAgICAgdmFyIHNvdXJjZU1vZHVsZXMgPSBmaWxlcy5tYXAoZnVuY3Rpb24gKGZpbGUpIHsgcmV0dXJuIF90aGlzLl9jb21waWxlU3JjRmlsZShmaWxlLnNyY1VybCwgbmdNb2R1bGVCeVBpcGVPckRpcmVjdGl2ZSwgZmlsZS5kaXJlY3RpdmVzLCBmaWxlLm5nTW9kdWxlcyk7IH0pO1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChzb3VyY2VNb2R1bGVzKVxuICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAobW9kdWxlcykgeyByZXR1cm4gTGlzdFdyYXBwZXIuZmxhdHRlbihtb2R1bGVzKTsgfSk7XG4gICAgICB9O1xuICAgICAgT2ZmbGluZUNvbXBpbGVyLnByb3RvdHlwZS5fY29tcGlsZVNyY0ZpbGUgPSBmdW5jdGlvbiAoc3JjRmlsZVVybCwgbmdNb2R1bGVCeVBpcGVPckRpcmVjdGl2ZSwgZGlyZWN0aXZlcywgbmdNb2R1bGVzKSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICB2YXIgZmlsZVN1ZmZpeCA9IF9zcGxpdFR5cGVzY3JpcHRTdWZmaXgoc3JjRmlsZVVybClbMV07XG4gICAgICAgICAgdmFyIHN0YXRlbWVudHMgPSBbXTtcbiAgICAgICAgICB2YXIgZXhwb3J0ZWRWYXJzID0gW107XG4gICAgICAgICAgdmFyIG91dHB1dFNvdXJjZU1vZHVsZXMgPSBbXTtcbiAgICAgICAgICAvLyBjb21waWxlIGFsbCBuZyBtb2R1bGVzXG4gICAgICAgICAgZXhwb3J0ZWRWYXJzLnB1c2guYXBwbHkoZXhwb3J0ZWRWYXJzLCBuZ01vZHVsZXMubWFwKGZ1bmN0aW9uIChuZ01vZHVsZVR5cGUpIHsgcmV0dXJuIF90aGlzLl9jb21waWxlTW9kdWxlKG5nTW9kdWxlVHlwZSwgc3RhdGVtZW50cyk7IH0pKTtcbiAgICAgICAgICAvLyBjb21waWxlIGRpcmVjdGl2ZSB3cmFwcGVyc1xuICAgICAgICAgIGV4cG9ydGVkVmFycy5wdXNoLmFwcGx5KGV4cG9ydGVkVmFycywgZGlyZWN0aXZlcy5tYXAoZnVuY3Rpb24gKGRpcmVjdGl2ZVR5cGUpIHsgcmV0dXJuIF90aGlzLl9jb21waWxlRGlyZWN0aXZlV3JhcHBlcihkaXJlY3RpdmVUeXBlLCBzdGF0ZW1lbnRzKTsgfSkpO1xuICAgICAgICAgIC8vIGNvbXBpbGUgY29tcG9uZW50c1xuICAgICAgICAgIHJldHVybiBQcm9taXNlXG4gICAgICAgICAgICAgIC5hbGwoZGlyZWN0aXZlcy5tYXAoZnVuY3Rpb24gKGRpclR5cGUpIHtcbiAgICAgICAgICAgICAgdmFyIGNvbXBNZXRhID0gX3RoaXMuX21ldGFkYXRhUmVzb2x2ZXIuZ2V0RGlyZWN0aXZlTWV0YWRhdGEoZGlyVHlwZSk7XG4gICAgICAgICAgICAgIGlmICghY29tcE1ldGEuaXNDb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobnVsbCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFyIG5nTW9kdWxlID0gbmdNb2R1bGVCeVBpcGVPckRpcmVjdGl2ZS5nZXQoZGlyVHlwZSk7XG4gICAgICAgICAgICAgIGlmICghbmdNb2R1bGUpIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludGVybmFsIEVycm9yOiBjYW5ub3QgZGV0ZXJtaW5lIHRoZSBtb2R1bGUgZm9yIGNvbXBvbmVudCBcIiArIGNvbXBNZXRhLnR5cGUubmFtZSArIFwiIVwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZVxuICAgICAgICAgICAgICAgICAgLmFsbChbY29tcE1ldGFdLmNvbmNhdChuZ01vZHVsZS50cmFuc2l0aXZlTW9kdWxlLmRpcmVjdGl2ZXMpLm1hcChmdW5jdGlvbiAoZGlyTWV0YSkgeyByZXR1cm4gX3RoaXMuX2RpcmVjdGl2ZU5vcm1hbGl6ZXIubm9ybWFsaXplRGlyZWN0aXZlKGRpck1ldGEpLmFzeW5jUmVzdWx0OyB9KSlcbiAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChub3JtYWxpemVkQ29tcFdpdGhEaXJlY3RpdmVzKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgY29tcE1ldGEgPSBub3JtYWxpemVkQ29tcFdpdGhEaXJlY3RpdmVzWzBdLCBkaXJNZXRhcyA9IG5vcm1hbGl6ZWRDb21wV2l0aERpcmVjdGl2ZXMuc2xpY2UoMSk7XG4gICAgICAgICAgICAgICAgICBfYXNzZXJ0Q29tcG9uZW50KGNvbXBNZXRhKTtcbiAgICAgICAgICAgICAgICAgIC8vIGNvbXBpbGUgc3R5bGVzXG4gICAgICAgICAgICAgICAgICB2YXIgc3R5bGVzQ29tcGlsZVJlc3VsdHMgPSBfdGhpcy5fc3R5bGVDb21waWxlci5jb21waWxlQ29tcG9uZW50KGNvbXBNZXRhKTtcbiAgICAgICAgICAgICAgICAgIHN0eWxlc0NvbXBpbGVSZXN1bHRzLmV4dGVybmFsU3R5bGVzaGVldHMuZm9yRWFjaChmdW5jdGlvbiAoY29tcGlsZWRTdHlsZVNoZWV0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgb3V0cHV0U291cmNlTW9kdWxlcy5wdXNoKF90aGlzLl9jb2RnZW5TdHlsZXMoc3JjRmlsZVVybCwgY29tcGlsZWRTdHlsZVNoZWV0LCBmaWxlU3VmZml4KSk7XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIC8vIGNvbXBpbGUgY29tcG9uZW50c1xuICAgICAgICAgICAgICAgICAgZXhwb3J0ZWRWYXJzLnB1c2goX3RoaXMuX2NvbXBpbGVDb21wb25lbnRGYWN0b3J5KGNvbXBNZXRhLCBmaWxlU3VmZml4LCBzdGF0ZW1lbnRzKSwgX3RoaXMuX2NvbXBpbGVDb21wb25lbnQoY29tcE1ldGEsIGRpck1ldGFzLCBuZ01vZHVsZS50cmFuc2l0aXZlTW9kdWxlLnBpcGVzLCBuZ01vZHVsZS5zY2hlbWFzLCBzdHlsZXNDb21waWxlUmVzdWx0cy5jb21wb25lbnRTdHlsZXNoZWV0LCBmaWxlU3VmZml4LCBzdGF0ZW1lbnRzKSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pKVxuICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGlmIChzdGF0ZW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgIHZhciBzcmNNb2R1bGUgPSBfdGhpcy5fY29kZWdlblNvdXJjZU1vZHVsZShzcmNGaWxlVXJsLCBfbmdmYWN0b3J5TW9kdWxlVXJsKHNyY0ZpbGVVcmwpLCBzdGF0ZW1lbnRzLCBleHBvcnRlZFZhcnMpO1xuICAgICAgICAgICAgICAgICAgb3V0cHV0U291cmNlTW9kdWxlcy51bnNoaWZ0KHNyY01vZHVsZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIG91dHB1dFNvdXJjZU1vZHVsZXM7XG4gICAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgT2ZmbGluZUNvbXBpbGVyLnByb3RvdHlwZS5fY29tcGlsZU1vZHVsZSA9IGZ1bmN0aW9uIChuZ01vZHVsZVR5cGUsIHRhcmdldFN0YXRlbWVudHMpIHtcbiAgICAgICAgICB2YXIgbmdNb2R1bGUgPSB0aGlzLl9tZXRhZGF0YVJlc29sdmVyLmdldE5nTW9kdWxlTWV0YWRhdGEobmdNb2R1bGVUeXBlKTtcbiAgICAgICAgICB2YXIgcHJvdmlkZXJzID0gW107XG4gICAgICAgICAgaWYgKHRoaXMuX2xvY2FsZUlkKSB7XG4gICAgICAgICAgICAgIHByb3ZpZGVycy5wdXNoKG5ldyBDb21waWxlUHJvdmlkZXJNZXRhZGF0YSh7XG4gICAgICAgICAgICAgICAgICB0b2tlbjogcmVzb2x2ZUlkZW50aWZpZXJUb2tlbihJZGVudGlmaWVycy5MT0NBTEVfSUQpLFxuICAgICAgICAgICAgICAgICAgdXNlVmFsdWU6IHRoaXMuX2xvY2FsZUlkLFxuICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLl90cmFuc2xhdGlvbkZvcm1hdCkge1xuICAgICAgICAgICAgICBwcm92aWRlcnMucHVzaChuZXcgQ29tcGlsZVByb3ZpZGVyTWV0YWRhdGEoe1xuICAgICAgICAgICAgICAgICAgdG9rZW46IHJlc29sdmVJZGVudGlmaWVyVG9rZW4oSWRlbnRpZmllcnMuVFJBTlNMQVRJT05TX0ZPUk1BVCksXG4gICAgICAgICAgICAgICAgICB1c2VWYWx1ZTogdGhpcy5fdHJhbnNsYXRpb25Gb3JtYXRcbiAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgYXBwQ29tcGlsZVJlc3VsdCA9IHRoaXMuX25nTW9kdWxlQ29tcGlsZXIuY29tcGlsZShuZ01vZHVsZSwgcHJvdmlkZXJzKTtcbiAgICAgICAgICBhcHBDb21waWxlUmVzdWx0LmRlcGVuZGVuY2llcy5mb3JFYWNoKGZ1bmN0aW9uIChkZXApIHtcbiAgICAgICAgICAgICAgZGVwLnBsYWNlaG9sZGVyLm5hbWUgPSBfY29tcG9uZW50RmFjdG9yeU5hbWUoZGVwLmNvbXApO1xuICAgICAgICAgICAgICBkZXAucGxhY2Vob2xkZXIubW9kdWxlVXJsID0gX25nZmFjdG9yeU1vZHVsZVVybChkZXAuY29tcC5tb2R1bGVVcmwpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRhcmdldFN0YXRlbWVudHMucHVzaC5hcHBseSh0YXJnZXRTdGF0ZW1lbnRzLCBhcHBDb21waWxlUmVzdWx0LnN0YXRlbWVudHMpO1xuICAgICAgICAgIHJldHVybiBhcHBDb21waWxlUmVzdWx0Lm5nTW9kdWxlRmFjdG9yeVZhcjtcbiAgICAgIH07XG4gICAgICBPZmZsaW5lQ29tcGlsZXIucHJvdG90eXBlLl9jb21waWxlRGlyZWN0aXZlV3JhcHBlciA9IGZ1bmN0aW9uIChkaXJlY3RpdmVUeXBlLCB0YXJnZXRTdGF0ZW1lbnRzKSB7XG4gICAgICAgICAgdmFyIGRpck1ldGEgPSB0aGlzLl9tZXRhZGF0YVJlc29sdmVyLmdldERpcmVjdGl2ZU1ldGFkYXRhKGRpcmVjdGl2ZVR5cGUpO1xuICAgICAgICAgIHZhciBkaXJDb21waWxlUmVzdWx0ID0gdGhpcy5fZGlyV3JhcHBlckNvbXBpbGVyLmNvbXBpbGUoZGlyTWV0YSk7XG4gICAgICAgICAgdGFyZ2V0U3RhdGVtZW50cy5wdXNoLmFwcGx5KHRhcmdldFN0YXRlbWVudHMsIGRpckNvbXBpbGVSZXN1bHQuc3RhdGVtZW50cyk7XG4gICAgICAgICAgcmV0dXJuIGRpckNvbXBpbGVSZXN1bHQuZGlyV3JhcHBlckNsYXNzVmFyO1xuICAgICAgfTtcbiAgICAgIE9mZmxpbmVDb21waWxlci5wcm90b3R5cGUuX2NvbXBpbGVDb21wb25lbnRGYWN0b3J5ID0gZnVuY3Rpb24gKGNvbXBNZXRhLCBmaWxlU3VmZml4LCB0YXJnZXRTdGF0ZW1lbnRzKSB7XG4gICAgICAgICAgdmFyIGhvc3RNZXRhID0gY3JlYXRlSG9zdENvbXBvbmVudE1ldGEoY29tcE1ldGEpO1xuICAgICAgICAgIHZhciBob3N0Vmlld0ZhY3RvcnlWYXIgPSB0aGlzLl9jb21waWxlQ29tcG9uZW50KGhvc3RNZXRhLCBbY29tcE1ldGFdLCBbXSwgW10sIG51bGwsIGZpbGVTdWZmaXgsIHRhcmdldFN0YXRlbWVudHMpO1xuICAgICAgICAgIHZhciBjb21wRmFjdG9yeVZhciA9IF9jb21wb25lbnRGYWN0b3J5TmFtZShjb21wTWV0YS50eXBlKTtcbiAgICAgICAgICB0YXJnZXRTdGF0ZW1lbnRzLnB1c2godmFyaWFibGUoY29tcEZhY3RvcnlWYXIpXG4gICAgICAgICAgICAgIC5zZXQoaW1wb3J0RXhwcihyZXNvbHZlSWRlbnRpZmllcihJZGVudGlmaWVycy5Db21wb25lbnRGYWN0b3J5KSwgW2ltcG9ydFR5cGUoY29tcE1ldGEudHlwZSldKVxuICAgICAgICAgICAgICAuaW5zdGFudGlhdGUoW1xuICAgICAgICAgICAgICBsaXRlcmFsKGNvbXBNZXRhLnNlbGVjdG9yKSxcbiAgICAgICAgICAgICAgdmFyaWFibGUoaG9zdFZpZXdGYWN0b3J5VmFyKSxcbiAgICAgICAgICAgICAgaW1wb3J0RXhwcihjb21wTWV0YS50eXBlKSxcbiAgICAgICAgICBdLCBpbXBvcnRUeXBlKHJlc29sdmVJZGVudGlmaWVyKElkZW50aWZpZXJzLkNvbXBvbmVudEZhY3RvcnkpLCBbaW1wb3J0VHlwZShjb21wTWV0YS50eXBlKV0sIFtUeXBlTW9kaWZpZXIuQ29uc3RdKSkpXG4gICAgICAgICAgICAgIC50b0RlY2xTdG10KG51bGwsIFtTdG10TW9kaWZpZXIuRmluYWxdKSk7XG4gICAgICAgICAgcmV0dXJuIGNvbXBGYWN0b3J5VmFyO1xuICAgICAgfTtcbiAgICAgIE9mZmxpbmVDb21waWxlci5wcm90b3R5cGUuX2NvbXBpbGVDb21wb25lbnQgPSBmdW5jdGlvbiAoY29tcE1ldGEsIGRpcmVjdGl2ZXMsIHBpcGVzLCBzY2hlbWFzLCBjb21wb25lbnRTdHlsZXMsIGZpbGVTdWZmaXgsIHRhcmdldFN0YXRlbWVudHMpIHtcbiAgICAgICAgICB2YXIgcGFyc2VkQW5pbWF0aW9ucyA9IHRoaXMuX2FuaW1hdGlvblBhcnNlci5wYXJzZUNvbXBvbmVudChjb21wTWV0YSk7XG4gICAgICAgICAgdmFyIHBhcnNlZFRlbXBsYXRlID0gdGhpcy5fdGVtcGxhdGVQYXJzZXIucGFyc2UoY29tcE1ldGEsIGNvbXBNZXRhLnRlbXBsYXRlLnRlbXBsYXRlLCBkaXJlY3RpdmVzLCBwaXBlcywgc2NoZW1hcywgY29tcE1ldGEudHlwZS5uYW1lKTtcbiAgICAgICAgICB2YXIgc3R5bGVzRXhwciA9IGNvbXBvbmVudFN0eWxlcyA/IHZhcmlhYmxlKGNvbXBvbmVudFN0eWxlcy5zdHlsZXNWYXIpIDogbGl0ZXJhbEFycihbXSk7XG4gICAgICAgICAgdmFyIGNvbXBpbGVkQW5pbWF0aW9ucyA9IHRoaXMuX2FuaW1hdGlvbkNvbXBpbGVyLmNvbXBpbGUoY29tcE1ldGEudHlwZS5uYW1lLCBwYXJzZWRBbmltYXRpb25zKTtcbiAgICAgICAgICB2YXIgdmlld1Jlc3VsdCA9IHRoaXMuX3ZpZXdDb21waWxlci5jb21waWxlQ29tcG9uZW50KGNvbXBNZXRhLCBwYXJzZWRUZW1wbGF0ZSwgc3R5bGVzRXhwciwgcGlwZXMsIGNvbXBpbGVkQW5pbWF0aW9ucyk7XG4gICAgICAgICAgaWYgKGNvbXBvbmVudFN0eWxlcykge1xuICAgICAgICAgICAgICB0YXJnZXRTdGF0ZW1lbnRzLnB1c2guYXBwbHkodGFyZ2V0U3RhdGVtZW50cywgX3Jlc29sdmVTdHlsZVN0YXRlbWVudHMoY29tcG9uZW50U3R5bGVzLCBmaWxlU3VmZml4KSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbXBpbGVkQW5pbWF0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChlbnRyeSkgeyBlbnRyeS5zdGF0ZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKHN0YXRlbWVudCkgeyB0YXJnZXRTdGF0ZW1lbnRzLnB1c2goc3RhdGVtZW50KTsgfSk7IH0pO1xuICAgICAgICAgIHRhcmdldFN0YXRlbWVudHMucHVzaC5hcHBseSh0YXJnZXRTdGF0ZW1lbnRzLCBfcmVzb2x2ZVZpZXdTdGF0ZW1lbnRzKHZpZXdSZXN1bHQpKTtcbiAgICAgICAgICByZXR1cm4gdmlld1Jlc3VsdC52aWV3RmFjdG9yeVZhcjtcbiAgICAgIH07XG4gICAgICBPZmZsaW5lQ29tcGlsZXIucHJvdG90eXBlLl9jb2RnZW5TdHlsZXMgPSBmdW5jdGlvbiAoZmlsZVVybCwgc3R5bGVzQ29tcGlsZVJlc3VsdCwgZmlsZVN1ZmZpeCkge1xuICAgICAgICAgIF9yZXNvbHZlU3R5bGVTdGF0ZW1lbnRzKHN0eWxlc0NvbXBpbGVSZXN1bHQsIGZpbGVTdWZmaXgpO1xuICAgICAgICAgIHJldHVybiB0aGlzLl9jb2RlZ2VuU291cmNlTW9kdWxlKGZpbGVVcmwsIF9zdHlsZXNNb2R1bGVVcmwoc3R5bGVzQ29tcGlsZVJlc3VsdC5tZXRhLm1vZHVsZVVybCwgc3R5bGVzQ29tcGlsZVJlc3VsdC5pc1NoaW1tZWQsIGZpbGVTdWZmaXgpLCBzdHlsZXNDb21waWxlUmVzdWx0LnN0YXRlbWVudHMsIFtzdHlsZXNDb21waWxlUmVzdWx0LnN0eWxlc1Zhcl0pO1xuICAgICAgfTtcbiAgICAgIE9mZmxpbmVDb21waWxlci5wcm90b3R5cGUuX2NvZGVnZW5Tb3VyY2VNb2R1bGUgPSBmdW5jdGlvbiAoZmlsZVVybCwgbW9kdWxlVXJsLCBzdGF0ZW1lbnRzLCBleHBvcnRlZFZhcnMpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFNvdXJjZU1vZHVsZShmaWxlVXJsLCBtb2R1bGVVcmwsIHRoaXMuX291dHB1dEVtaXR0ZXIuZW1pdFN0YXRlbWVudHMobW9kdWxlVXJsLCBzdGF0ZW1lbnRzLCBleHBvcnRlZFZhcnMpKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gT2ZmbGluZUNvbXBpbGVyO1xuICB9KCkpO1xuICBmdW5jdGlvbiBfcmVzb2x2ZVZpZXdTdGF0ZW1lbnRzKGNvbXBpbGVSZXN1bHQpIHtcbiAgICAgIGNvbXBpbGVSZXN1bHQuZGVwZW5kZW5jaWVzLmZvckVhY2goZnVuY3Rpb24gKGRlcCkge1xuICAgICAgICAgIGlmIChkZXAgaW5zdGFuY2VvZiBWaWV3RmFjdG9yeURlcGVuZGVuY3kpIHtcbiAgICAgICAgICAgICAgdmFyIHZmZCA9IGRlcDtcbiAgICAgICAgICAgICAgdmZkLnBsYWNlaG9sZGVyLm1vZHVsZVVybCA9IF9uZ2ZhY3RvcnlNb2R1bGVVcmwodmZkLmNvbXAubW9kdWxlVXJsKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoZGVwIGluc3RhbmNlb2YgQ29tcG9uZW50RmFjdG9yeURlcGVuZGVuY3kpIHtcbiAgICAgICAgICAgICAgdmFyIGNmZCA9IGRlcDtcbiAgICAgICAgICAgICAgY2ZkLnBsYWNlaG9sZGVyLm5hbWUgPSBfY29tcG9uZW50RmFjdG9yeU5hbWUoY2ZkLmNvbXApO1xuICAgICAgICAgICAgICBjZmQucGxhY2Vob2xkZXIubW9kdWxlVXJsID0gX25nZmFjdG9yeU1vZHVsZVVybChjZmQuY29tcC5tb2R1bGVVcmwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChkZXAgaW5zdGFuY2VvZiBEaXJlY3RpdmVXcmFwcGVyRGVwZW5kZW5jeSkge1xuICAgICAgICAgICAgICB2YXIgZHdkID0gZGVwO1xuICAgICAgICAgICAgICBkd2QucGxhY2Vob2xkZXIubW9kdWxlVXJsID0gX25nZmFjdG9yeU1vZHVsZVVybChkd2QuZGlyLm1vZHVsZVVybCk7XG4gICAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gY29tcGlsZVJlc3VsdC5zdGF0ZW1lbnRzO1xuICB9XG4gIGZ1bmN0aW9uIF9yZXNvbHZlU3R5bGVTdGF0ZW1lbnRzKGNvbXBpbGVSZXN1bHQsIGZpbGVTdWZmaXgpIHtcbiAgICAgIGNvbXBpbGVSZXN1bHQuZGVwZW5kZW5jaWVzLmZvckVhY2goZnVuY3Rpb24gKGRlcCkge1xuICAgICAgICAgIGRlcC52YWx1ZVBsYWNlaG9sZGVyLm1vZHVsZVVybCA9IF9zdHlsZXNNb2R1bGVVcmwoZGVwLm1vZHVsZVVybCwgZGVwLmlzU2hpbW1lZCwgZmlsZVN1ZmZpeCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBjb21waWxlUmVzdWx0LnN0YXRlbWVudHM7XG4gIH1cbiAgZnVuY3Rpb24gX25nZmFjdG9yeU1vZHVsZVVybChkaXJVcmwpIHtcbiAgICAgIHZhciB1cmxXaXRoU3VmZml4ID0gX3NwbGl0VHlwZXNjcmlwdFN1ZmZpeChkaXJVcmwpO1xuICAgICAgcmV0dXJuIHVybFdpdGhTdWZmaXhbMF0gKyBcIi5uZ2ZhY3RvcnlcIiArIHVybFdpdGhTdWZmaXhbMV07XG4gIH1cbiAgZnVuY3Rpb24gX2NvbXBvbmVudEZhY3RvcnlOYW1lKGNvbXApIHtcbiAgICAgIHJldHVybiBjb21wLm5hbWUgKyBcIk5nRmFjdG9yeVwiO1xuICB9XG4gIGZ1bmN0aW9uIF9zdHlsZXNNb2R1bGVVcmwoc3R5bGVzaGVldFVybCwgc2hpbSwgc3VmZml4KSB7XG4gICAgICByZXR1cm4gc2hpbSA/IHN0eWxlc2hlZXRVcmwgKyBcIi5zaGltXCIgKyBzdWZmaXggOiBcIlwiICsgc3R5bGVzaGVldFVybCArIHN1ZmZpeDtcbiAgfVxuICBmdW5jdGlvbiBfYXNzZXJ0Q29tcG9uZW50KG1ldGEpIHtcbiAgICAgIGlmICghbWV0YS5pc0NvbXBvbmVudCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBjb21waWxlICdcIiArIG1ldGEudHlwZS5uYW1lICsgXCInIGJlY2F1c2UgaXQgaXMgbm90IGEgY29tcG9uZW50LlwiKTtcbiAgICAgIH1cbiAgfVxuICBmdW5jdGlvbiBfc3BsaXRUeXBlc2NyaXB0U3VmZml4KHBhdGgpIHtcbiAgICAgIGlmIChwYXRoLmVuZHNXaXRoKCcuZC50cycpKSB7XG4gICAgICAgICAgcmV0dXJuIFtwYXRoLnNsaWNlKDAsIC01KSwgJy50cyddO1xuICAgICAgfVxuICAgICAgdmFyIGxhc3REb3QgPSBwYXRoLmxhc3RJbmRleE9mKCcuJyk7XG4gICAgICBpZiAobGFzdERvdCAhPT0gLTEpIHtcbiAgICAgICAgICByZXR1cm4gW3BhdGguc3Vic3RyaW5nKDAsIGxhc3REb3QpLCBwYXRoLnN1YnN0cmluZyhsYXN0RG90KV07XG4gICAgICB9XG4gICAgICByZXR1cm4gW3BhdGgsICcnXTtcbiAgfVxuICAvLyBHcm91cCB0aGUgc3ltYm9scyBieSB0eXBlczpcbiAgLy8gLSBOZ01vZHVsZXMsXG4gIC8vIC0gUGlwZXMgYW5kIERpcmVjdGl2ZXMuXG4gIGZ1bmN0aW9uIF9leHRyYWN0TW9kdWxlc0FuZFBpcGVzT3JEaXJlY3RpdmVzKHByb2dyYW1TdGF0aWNTeW1ib2xzLCBtZXRhZGF0YVJlc29sdmVyKSB7XG4gICAgICB2YXIgbmdNb2R1bGVzID0gW107XG4gICAgICB2YXIgcGlwZXNBbmREaXJlY3RpdmVzID0gW107XG4gICAgICBwcm9ncmFtU3RhdGljU3ltYm9scy5mb3JFYWNoKGZ1bmN0aW9uIChzdGF0aWNTeW1ib2wpIHtcbiAgICAgICAgICB2YXIgbmdNb2R1bGUgPSBtZXRhZGF0YVJlc29sdmVyLmdldE5nTW9kdWxlTWV0YWRhdGEoc3RhdGljU3ltYm9sLCBmYWxzZSk7XG4gICAgICAgICAgdmFyIGRpcmVjdGl2ZSA9IG1ldGFkYXRhUmVzb2x2ZXIuZ2V0RGlyZWN0aXZlTWV0YWRhdGEoc3RhdGljU3ltYm9sLCBmYWxzZSk7XG4gICAgICAgICAgdmFyIHBpcGUgPSBtZXRhZGF0YVJlc29sdmVyLmdldFBpcGVNZXRhZGF0YShzdGF0aWNTeW1ib2wsIGZhbHNlKTtcbiAgICAgICAgICBpZiAobmdNb2R1bGUpIHtcbiAgICAgICAgICAgICAgbmdNb2R1bGVzLnB1c2gobmdNb2R1bGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChkaXJlY3RpdmUpIHtcbiAgICAgICAgICAgICAgcGlwZXNBbmREaXJlY3RpdmVzLnB1c2goc3RhdGljU3ltYm9sKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAocGlwZSkge1xuICAgICAgICAgICAgICBwaXBlc0FuZERpcmVjdGl2ZXMucHVzaChzdGF0aWNTeW1ib2wpO1xuICAgICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHsgbmdNb2R1bGVzOiBuZ01vZHVsZXMsIHBpcGVzQW5kRGlyZWN0aXZlczogcGlwZXNBbmREaXJlY3RpdmVzIH07XG4gIH1cblxuICAvKipcbiAgICogQGxpY2Vuc2VcbiAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAqXG4gICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICovXG4gIC8qKlxuICAgKiBBbiBpbnRlcmZhY2UgZm9yIHJldHJpZXZpbmcgZG9jdW1lbnRzIGJ5IFVSTCB0aGF0IHRoZSBjb21waWxlciB1c2VzXG4gICAqIHRvIGxvYWQgdGVtcGxhdGVzLlxuICAgKi9cbiAgdmFyIFJlc291cmNlTG9hZGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIFJlc291cmNlTG9hZGVyKCkge1xuICAgICAgfVxuICAgICAgUmVzb3VyY2VMb2FkZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICh1cmwpIHsgcmV0dXJuIG51bGw7IH07XG4gICAgICByZXR1cm4gUmVzb3VyY2VMb2FkZXI7XG4gIH0oKSk7XG5cbiAgdmFyIF9BU1NFVF9TQ0hFTUUgPSAnYXNzZXQ6JztcbiAgLyoqXG4gICAqIENyZWF0ZSBhIHtAbGluayBVcmxSZXNvbHZlcn0gd2l0aCBubyBwYWNrYWdlIHByZWZpeC5cbiAgICovXG4gIGZ1bmN0aW9uIGNyZWF0ZVVybFJlc29sdmVyV2l0aG91dFBhY2thZ2VQcmVmaXgoKSB7XG4gICAgICByZXR1cm4gbmV3IFVybFJlc29sdmVyKCk7XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlT2ZmbGluZUNvbXBpbGVVcmxSZXNvbHZlcigpIHtcbiAgICAgIHJldHVybiBuZXcgVXJsUmVzb2x2ZXIoX0FTU0VUX1NDSEVNRSk7XG4gIH1cbiAgLyoqXG4gICAqIEEgZGVmYXVsdCBwcm92aWRlciBmb3Ige0BsaW5rIFBBQ0tBR0VfUk9PVF9VUkx9IHRoYXQgbWFwcyB0byAnLycuXG4gICAqL1xuICB2YXIgREVGQVVMVF9QQUNLQUdFX1VSTF9QUk9WSURFUiA9IHtcbiAgICAgIHByb3ZpZGU6IF9hbmd1bGFyX2NvcmUuUEFDS0FHRV9ST09UX1VSTCxcbiAgICAgIHVzZVZhbHVlOiAnLydcbiAgfTtcbiAgLyoqXG4gICAqIFVzZWQgYnkgdGhlIHtAbGluayBDb21waWxlcn0gd2hlbiByZXNvbHZpbmcgSFRNTCBhbmQgQ1NTIHRlbXBsYXRlIFVSTHMuXG4gICAqXG4gICAqIFRoaXMgY2xhc3MgY2FuIGJlIG92ZXJyaWRkZW4gYnkgdGhlIGFwcGxpY2F0aW9uIGRldmVsb3BlciB0byBjcmVhdGUgY3VzdG9tIGJlaGF2aW9yLlxuICAgKlxuICAgKiBTZWUge0BsaW5rIENvbXBpbGVyfVxuICAgKlxuICAgKiAjIyBFeGFtcGxlXG4gICAqXG4gICAqIHtAZXhhbXBsZSBjb21waWxlci90cy91cmxfcmVzb2x2ZXIvdXJsX3Jlc29sdmVyLnRzIHJlZ2lvbj0ndXJsX3Jlc29sdmVyJ31cbiAgICpcbiAgICogQHNlY3VyaXR5ICBXaGVuIGNvbXBpbGluZyB0ZW1wbGF0ZXMgYXQgcnVudGltZSwgeW91IG11c3RcbiAgICogZW5zdXJlIHRoYXQgdGhlIGVudGlyZSB0ZW1wbGF0ZSBjb21lcyBmcm9tIGEgdHJ1c3RlZCBzb3VyY2UuXG4gICAqIEF0dGFja2VyLWNvbnRyb2xsZWQgZGF0YSBpbnRyb2R1Y2VkIGJ5IGEgdGVtcGxhdGUgY291bGQgZXhwb3NlIHlvdXJcbiAgICogYXBwbGljYXRpb24gdG8gWFNTIHJpc2tzLiBGb3IgbW9yZSBkZXRhaWwsIHNlZSB0aGUgW1NlY3VyaXR5IEd1aWRlXShodHRwOi8vZy5jby9uZy9zZWN1cml0eSkuXG4gICAqL1xuICB2YXIgVXJsUmVzb2x2ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gVXJsUmVzb2x2ZXIoX3BhY2thZ2VQcmVmaXgpIHtcbiAgICAgICAgICBpZiAoX3BhY2thZ2VQcmVmaXggPT09IHZvaWQgMCkgeyBfcGFja2FnZVByZWZpeCA9IG51bGw7IH1cbiAgICAgICAgICB0aGlzLl9wYWNrYWdlUHJlZml4ID0gX3BhY2thZ2VQcmVmaXg7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIFJlc29sdmVzIHRoZSBgdXJsYCBnaXZlbiB0aGUgYGJhc2VVcmxgOlxuICAgICAgICogLSB3aGVuIHRoZSBgdXJsYCBpcyBudWxsLCB0aGUgYGJhc2VVcmxgIGlzIHJldHVybmVkLFxuICAgICAgICogLSBpZiBgdXJsYCBpcyByZWxhdGl2ZSAoJ3BhdGgvdG8vaGVyZScsICcuL3BhdGgvdG8vaGVyZScpLCB0aGUgcmVzb2x2ZWQgdXJsIGlzIGEgY29tYmluYXRpb24gb2ZcbiAgICAgICAqIGBiYXNlVXJsYCBhbmQgYHVybGAsXG4gICAgICAgKiAtIGlmIGB1cmxgIGlzIGFic29sdXRlIChpdCBoYXMgYSBzY2hlbWU6ICdodHRwOi8vJywgJ2h0dHBzOi8vJyBvciBzdGFydCB3aXRoICcvJyksIHRoZSBgdXJsYCBpc1xuICAgICAgICogcmV0dXJuZWQgYXMgaXMgKGlnbm9yaW5nIHRoZSBgYmFzZVVybGApXG4gICAgICAgKi9cbiAgICAgIFVybFJlc29sdmVyLnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24gKGJhc2VVcmwsIHVybCkge1xuICAgICAgICAgIHZhciByZXNvbHZlZFVybCA9IHVybDtcbiAgICAgICAgICBpZiAoaXNQcmVzZW50KGJhc2VVcmwpICYmIGJhc2VVcmwubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICByZXNvbHZlZFVybCA9IF9yZXNvbHZlVXJsKGJhc2VVcmwsIHJlc29sdmVkVXJsKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHJlc29sdmVkUGFydHMgPSBfc3BsaXQocmVzb2x2ZWRVcmwpO1xuICAgICAgICAgIHZhciBwcmVmaXggPSB0aGlzLl9wYWNrYWdlUHJlZml4O1xuICAgICAgICAgIGlmIChpc1ByZXNlbnQocHJlZml4KSAmJiBpc1ByZXNlbnQocmVzb2x2ZWRQYXJ0cykgJiZcbiAgICAgICAgICAgICAgcmVzb2x2ZWRQYXJ0c1tfQ29tcG9uZW50SW5kZXguU2NoZW1lXSA9PSAncGFja2FnZScpIHtcbiAgICAgICAgICAgICAgdmFyIHBhdGggPSByZXNvbHZlZFBhcnRzW19Db21wb25lbnRJbmRleC5QYXRoXTtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuX3BhY2thZ2VQcmVmaXggPT09IF9BU1NFVF9TQ0hFTUUpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBwYXRoU2VnZW1lbnRzID0gcGF0aC5zcGxpdCgvXFwvLyk7XG4gICAgICAgICAgICAgICAgICByZXNvbHZlZFVybCA9IFwiYXNzZXQ6XCIgKyBwYXRoU2VnZW1lbnRzWzBdICsgXCIvbGliL1wiICsgcGF0aFNlZ2VtZW50cy5zbGljZSgxKS5qb2luKCcvJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICBwcmVmaXggPSBwcmVmaXgucmVwbGFjZSgvXFwvKyQvLCAnJyk7XG4gICAgICAgICAgICAgICAgICBwYXRoID0gcGF0aC5yZXBsYWNlKC9eXFwvKy8sICcnKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBwcmVmaXggKyBcIi9cIiArIHBhdGg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc29sdmVkVXJsO1xuICAgICAgfTtcbiAgICAgIFVybFJlc29sdmVyLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdGFibGUgfSxcbiAgICAgIF07XG4gICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgIFVybFJlc29sdmVyLmN0b3JQYXJhbWV0ZXJzID0gW1xuICAgICAgICAgIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdCwgYXJnczogW19hbmd1bGFyX2NvcmUuUEFDS0FHRV9ST09UX1VSTCxdIH0sXSB9LFxuICAgICAgXTtcbiAgICAgIHJldHVybiBVcmxSZXNvbHZlcjtcbiAgfSgpKTtcbiAgLyoqXG4gICAqIEV4dHJhY3QgdGhlIHNjaGVtZSBvZiBhIFVSTC5cbiAgICovXG4gIGZ1bmN0aW9uIGdldFVybFNjaGVtZSh1cmwpIHtcbiAgICAgIHZhciBtYXRjaCA9IF9zcGxpdCh1cmwpO1xuICAgICAgcmV0dXJuIChtYXRjaCAmJiBtYXRjaFtfQ29tcG9uZW50SW5kZXguU2NoZW1lXSkgfHwgJyc7XG4gIH1cbiAgLy8gVGhlIGNvZGUgYmVsb3cgaXMgYWRhcHRlZCBmcm9tIFRyYWNldXI6XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9nb29nbGUvdHJhY2V1ci1jb21waWxlci9ibG9iLzk1MTFjMWRhZmE5NzJiZjBkZTEyMDJhOGE4NjNiYWQwMmYwZjk1YTgvc3JjL3J1bnRpbWUvdXJsLmpzXG4gIC8qKlxuICAgKiBCdWlsZHMgYSBVUkkgc3RyaW5nIGZyb20gYWxyZWFkeS1lbmNvZGVkIHBhcnRzLlxuICAgKlxuICAgKiBObyBlbmNvZGluZyBpcyBwZXJmb3JtZWQuICBBbnkgY29tcG9uZW50IG1heSBiZSBvbWl0dGVkIGFzIGVpdGhlciBudWxsIG9yXG4gICAqIHVuZGVmaW5lZC5cbiAgICpcbiAgICogQHBhcmFtIG9wdF9zY2hlbWUgVGhlIHNjaGVtZSBzdWNoIGFzICdodHRwJy5cbiAgICogQHBhcmFtIG9wdF91c2VySW5mbyBUaGUgdXNlciBuYW1lIGJlZm9yZSB0aGUgJ0AnLlxuICAgKiBAcGFyYW0gb3B0X2RvbWFpbiBUaGUgZG9tYWluIHN1Y2ggYXMgJ3d3dy5nb29nbGUuY29tJywgYWxyZWFkeVxuICAgKiAgICAgVVJJLWVuY29kZWQuXG4gICAqIEBwYXJhbSBvcHRfcG9ydCBUaGUgcG9ydCBudW1iZXIuXG4gICAqIEBwYXJhbSBvcHRfcGF0aCBUaGUgcGF0aCwgYWxyZWFkeSBVUkktZW5jb2RlZC4gIElmIGl0IGlzIG5vdFxuICAgKiAgICAgZW1wdHksIGl0IG11c3QgYmVnaW4gd2l0aCBhIHNsYXNoLlxuICAgKiBAcGFyYW0gb3B0X3F1ZXJ5RGF0YSBUaGUgVVJJLWVuY29kZWQgcXVlcnkgZGF0YS5cbiAgICogQHBhcmFtIG9wdF9mcmFnbWVudCBUaGUgVVJJLWVuY29kZWQgZnJhZ21lbnQgaWRlbnRpZmllci5cbiAgICogQHJldHVybiBUaGUgZnVsbHkgY29tYmluZWQgVVJJLlxuICAgKi9cbiAgZnVuY3Rpb24gX2J1aWxkRnJvbUVuY29kZWRQYXJ0cyhvcHRfc2NoZW1lLCBvcHRfdXNlckluZm8sIG9wdF9kb21haW4sIG9wdF9wb3J0LCBvcHRfcGF0aCwgb3B0X3F1ZXJ5RGF0YSwgb3B0X2ZyYWdtZW50KSB7XG4gICAgICB2YXIgb3V0ID0gW107XG4gICAgICBpZiAoaXNQcmVzZW50KG9wdF9zY2hlbWUpKSB7XG4gICAgICAgICAgb3V0LnB1c2gob3B0X3NjaGVtZSArICc6Jyk7XG4gICAgICB9XG4gICAgICBpZiAoaXNQcmVzZW50KG9wdF9kb21haW4pKSB7XG4gICAgICAgICAgb3V0LnB1c2goJy8vJyk7XG4gICAgICAgICAgaWYgKGlzUHJlc2VudChvcHRfdXNlckluZm8pKSB7XG4gICAgICAgICAgICAgIG91dC5wdXNoKG9wdF91c2VySW5mbyArICdAJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG91dC5wdXNoKG9wdF9kb21haW4pO1xuICAgICAgICAgIGlmIChpc1ByZXNlbnQob3B0X3BvcnQpKSB7XG4gICAgICAgICAgICAgIG91dC5wdXNoKCc6JyArIG9wdF9wb3J0KTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaXNQcmVzZW50KG9wdF9wYXRoKSkge1xuICAgICAgICAgIG91dC5wdXNoKG9wdF9wYXRoKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1ByZXNlbnQob3B0X3F1ZXJ5RGF0YSkpIHtcbiAgICAgICAgICBvdXQucHVzaCgnPycgKyBvcHRfcXVlcnlEYXRhKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1ByZXNlbnQob3B0X2ZyYWdtZW50KSkge1xuICAgICAgICAgIG91dC5wdXNoKCcjJyArIG9wdF9mcmFnbWVudCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3V0LmpvaW4oJycpO1xuICB9XG4gIC8qKlxuICAgKiBBIHJlZ3VsYXIgZXhwcmVzc2lvbiBmb3IgYnJlYWtpbmcgYSBVUkkgaW50byBpdHMgY29tcG9uZW50IHBhcnRzLlxuICAgKlxuICAgKiB7QGxpbmsgaHR0cDovL3d3dy5nYml2LmNvbS9wcm90b2NvbHMvdXJpL3JmYy9yZmMzOTg2Lmh0bWwjUkZDMjIzNH0gc2F5c1xuICAgKiBBcyB0aGUgXCJmaXJzdC1tYXRjaC13aW5zXCIgYWxnb3JpdGhtIGlzIGlkZW50aWNhbCB0byB0aGUgXCJncmVlZHlcIlxuICAgKiBkaXNhbWJpZ3VhdGlvbiBtZXRob2QgdXNlZCBieSBQT1NJWCByZWd1bGFyIGV4cHJlc3Npb25zLCBpdCBpcyBuYXR1cmFsIGFuZFxuICAgKiBjb21tb25wbGFjZSB0byB1c2UgYSByZWd1bGFyIGV4cHJlc3Npb24gZm9yIHBhcnNpbmcgdGhlIHBvdGVudGlhbCBmaXZlXG4gICAqIGNvbXBvbmVudHMgb2YgYSBVUkkgcmVmZXJlbmNlLlxuICAgKlxuICAgKiBUaGUgZm9sbG93aW5nIGxpbmUgaXMgdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiBmb3IgYnJlYWtpbmctZG93biBhXG4gICAqIHdlbGwtZm9ybWVkIFVSSSByZWZlcmVuY2UgaW50byBpdHMgY29tcG9uZW50cy5cbiAgICpcbiAgICogPHByZT5cbiAgICogXigoW146Lz8jXSspOik/KC8vKFteLz8jXSopKT8oW14/I10qKShcXD8oW14jXSopKT8oIyguKikpP1xuICAgKiAgMTIgICAgICAgICAgICAzICA0ICAgICAgICAgIDUgICAgICAgNiAgNyAgICAgICAgOCA5XG4gICAqIDwvcHJlPlxuICAgKlxuICAgKiBUaGUgbnVtYmVycyBpbiB0aGUgc2Vjb25kIGxpbmUgYWJvdmUgYXJlIG9ubHkgdG8gYXNzaXN0IHJlYWRhYmlsaXR5OyB0aGV5XG4gICAqIGluZGljYXRlIHRoZSByZWZlcmVuY2UgcG9pbnRzIGZvciBlYWNoIHN1YmV4cHJlc3Npb24gKGkuZS4sIGVhY2ggcGFpcmVkXG4gICAqIHBhcmVudGhlc2lzKS4gV2UgcmVmZXIgdG8gdGhlIHZhbHVlIG1hdGNoZWQgZm9yIHN1YmV4cHJlc3Npb24gPG4+IGFzICQ8bj4uXG4gICAqIEZvciBleGFtcGxlLCBtYXRjaGluZyB0aGUgYWJvdmUgZXhwcmVzc2lvbiB0b1xuICAgKiA8cHJlPlxuICAgKiAgICAgaHR0cDovL3d3dy5pY3MudWNpLmVkdS9wdWIvaWV0Zi91cmkvI1JlbGF0ZWRcbiAgICogPC9wcmU+XG4gICAqIHJlc3VsdHMgaW4gdGhlIGZvbGxvd2luZyBzdWJleHByZXNzaW9uIG1hdGNoZXM6XG4gICAqIDxwcmU+XG4gICAqICAgICQxID0gaHR0cDpcbiAgICogICAgJDIgPSBodHRwXG4gICAqICAgICQzID0gLy93d3cuaWNzLnVjaS5lZHVcbiAgICogICAgJDQgPSB3d3cuaWNzLnVjaS5lZHVcbiAgICogICAgJDUgPSAvcHViL2lldGYvdXJpL1xuICAgKiAgICAkNiA9IDx1bmRlZmluZWQ+XG4gICAqICAgICQ3ID0gPHVuZGVmaW5lZD5cbiAgICogICAgJDggPSAjUmVsYXRlZFxuICAgKiAgICAkOSA9IFJlbGF0ZWRcbiAgICogPC9wcmU+XG4gICAqIHdoZXJlIDx1bmRlZmluZWQ+IGluZGljYXRlcyB0aGF0IHRoZSBjb21wb25lbnQgaXMgbm90IHByZXNlbnQsIGFzIGlzIHRoZVxuICAgKiBjYXNlIGZvciB0aGUgcXVlcnkgY29tcG9uZW50IGluIHRoZSBhYm92ZSBleGFtcGxlLiBUaGVyZWZvcmUsIHdlIGNhblxuICAgKiBkZXRlcm1pbmUgdGhlIHZhbHVlIG9mIHRoZSBmaXZlIGNvbXBvbmVudHMgYXNcbiAgICogPHByZT5cbiAgICogICAgc2NoZW1lICAgID0gJDJcbiAgICogICAgYXV0aG9yaXR5ID0gJDRcbiAgICogICAgcGF0aCAgICAgID0gJDVcbiAgICogICAgcXVlcnkgICAgID0gJDdcbiAgICogICAgZnJhZ21lbnQgID0gJDlcbiAgICogPC9wcmU+XG4gICAqXG4gICAqIFRoZSByZWd1bGFyIGV4cHJlc3Npb24gaGFzIGJlZW4gbW9kaWZpZWQgc2xpZ2h0bHkgdG8gZXhwb3NlIHRoZVxuICAgKiB1c2VySW5mbywgZG9tYWluLCBhbmQgcG9ydCBzZXBhcmF0ZWx5IGZyb20gdGhlIGF1dGhvcml0eS5cbiAgICogVGhlIG1vZGlmaWVkIHZlcnNpb24geWllbGRzXG4gICAqIDxwcmU+XG4gICAqICAgICQxID0gaHR0cCAgICAgICAgICAgICAgc2NoZW1lXG4gICAqICAgICQyID0gPHVuZGVmaW5lZD4gICAgICAgdXNlckluZm8gLVxcXG4gICAqICAgICQzID0gd3d3Lmljcy51Y2kuZWR1ICAgZG9tYWluICAgICB8IGF1dGhvcml0eVxuICAgKiAgICAkNCA9IDx1bmRlZmluZWQ+ICAgICAgIHBvcnQgICAgIC0vXG4gICAqICAgICQ1ID0gL3B1Yi9pZXRmL3VyaS8gICAgcGF0aFxuICAgKiAgICAkNiA9IDx1bmRlZmluZWQ+ICAgICAgIHF1ZXJ5IHdpdGhvdXQgP1xuICAgKiAgICAkNyA9IFJlbGF0ZWQgICAgICAgICAgIGZyYWdtZW50IHdpdGhvdXQgI1xuICAgKiA8L3ByZT5cbiAgICogQHR5cGUgeyFSZWdFeHB9XG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgdmFyIF9zcGxpdFJlID0gbmV3IFJlZ0V4cCgnXicgK1xuICAgICAgJyg/OicgK1xuICAgICAgJyhbXjovPyMuXSspJyArXG4gICAgICAvLyB1c2VkIGJ5IG90aGVyIFVSTCBwYXJ0cyBzdWNoIGFzIDosXG4gICAgICAvLyA/LCAvLCAjLCBhbmQgLlxuICAgICAgJzopPycgK1xuICAgICAgJyg/Oi8vJyArXG4gICAgICAnKD86KFteLz8jXSopQCk/JyArXG4gICAgICAnKFtcXFxcd1xcXFxkXFxcXC1cXFxcdTAxMDAtXFxcXHVmZmZmLiVdKiknICtcbiAgICAgIC8vIGRpZ2l0cywgZGFzaGVzLCBkb3RzLCBwZXJjZW50XG4gICAgICAvLyBlc2NhcGVzLCBhbmQgdW5pY29kZSBjaGFyYWN0ZXJzLlxuICAgICAgJyg/OjooWzAtOV0rKSk/JyArXG4gICAgICAnKT8nICtcbiAgICAgICcoW14/I10rKT8nICtcbiAgICAgICcoPzpcXFxcPyhbXiNdKikpPycgK1xuICAgICAgJyg/OiMoLiopKT8nICtcbiAgICAgICckJyk7XG4gIC8qKlxuICAgKiBUaGUgaW5kZXggb2YgZWFjaCBVUkkgY29tcG9uZW50IGluIHRoZSByZXR1cm4gdmFsdWUgb2YgZ29vZy51cmkudXRpbHMuc3BsaXQuXG4gICAqIEBlbnVtIHtudW1iZXJ9XG4gICAqL1xuICB2YXIgX0NvbXBvbmVudEluZGV4O1xuICAoZnVuY3Rpb24gKF9Db21wb25lbnRJbmRleCkge1xuICAgICAgX0NvbXBvbmVudEluZGV4W19Db21wb25lbnRJbmRleFtcIlNjaGVtZVwiXSA9IDFdID0gXCJTY2hlbWVcIjtcbiAgICAgIF9Db21wb25lbnRJbmRleFtfQ29tcG9uZW50SW5kZXhbXCJVc2VySW5mb1wiXSA9IDJdID0gXCJVc2VySW5mb1wiO1xuICAgICAgX0NvbXBvbmVudEluZGV4W19Db21wb25lbnRJbmRleFtcIkRvbWFpblwiXSA9IDNdID0gXCJEb21haW5cIjtcbiAgICAgIF9Db21wb25lbnRJbmRleFtfQ29tcG9uZW50SW5kZXhbXCJQb3J0XCJdID0gNF0gPSBcIlBvcnRcIjtcbiAgICAgIF9Db21wb25lbnRJbmRleFtfQ29tcG9uZW50SW5kZXhbXCJQYXRoXCJdID0gNV0gPSBcIlBhdGhcIjtcbiAgICAgIF9Db21wb25lbnRJbmRleFtfQ29tcG9uZW50SW5kZXhbXCJRdWVyeURhdGFcIl0gPSA2XSA9IFwiUXVlcnlEYXRhXCI7XG4gICAgICBfQ29tcG9uZW50SW5kZXhbX0NvbXBvbmVudEluZGV4W1wiRnJhZ21lbnRcIl0gPSA3XSA9IFwiRnJhZ21lbnRcIjtcbiAgfSkoX0NvbXBvbmVudEluZGV4IHx8IChfQ29tcG9uZW50SW5kZXggPSB7fSkpO1xuICAvKipcbiAgICogU3BsaXRzIGEgVVJJIGludG8gaXRzIGNvbXBvbmVudCBwYXJ0cy5cbiAgICpcbiAgICogRWFjaCBjb21wb25lbnQgY2FuIGJlIGFjY2Vzc2VkIHZpYSB0aGUgY29tcG9uZW50IGluZGljZXM7IGZvciBleGFtcGxlOlxuICAgKiA8cHJlPlxuICAgKiBnb29nLnVyaS51dGlscy5zcGxpdChzb21lU3RyKVtnb29nLnVyaS51dGlscy5Db21wb250ZW50SW5kZXguUVVFUllfREFUQV07XG4gICAqIDwvcHJlPlxuICAgKlxuICAgKiBAcGFyYW0gdXJpIFRoZSBVUkkgc3RyaW5nIHRvIGV4YW1pbmUuXG4gICAqIEByZXR1cm4gRWFjaCBjb21wb25lbnQgc3RpbGwgVVJJLWVuY29kZWQuXG4gICAqICAgICBFYWNoIGNvbXBvbmVudCB0aGF0IGlzIHByZXNlbnQgd2lsbCBjb250YWluIHRoZSBlbmNvZGVkIHZhbHVlLCB3aGVyZWFzXG4gICAqICAgICBjb21wb25lbnRzIHRoYXQgYXJlIG5vdCBwcmVzZW50IHdpbGwgYmUgdW5kZWZpbmVkIG9yIGVtcHR5LCBkZXBlbmRpbmdcbiAgICogICAgIG9uIHRoZSBicm93c2VyJ3MgcmVndWxhciBleHByZXNzaW9uIGltcGxlbWVudGF0aW9uLiAgTmV2ZXIgbnVsbCwgc2luY2VcbiAgICogICAgIGFyYml0cmFyeSBzdHJpbmdzIG1heSBzdGlsbCBsb29rIGxpa2UgcGF0aCBuYW1lcy5cbiAgICovXG4gIGZ1bmN0aW9uIF9zcGxpdCh1cmkpIHtcbiAgICAgIHJldHVybiB1cmkubWF0Y2goX3NwbGl0UmUpO1xuICB9XG4gIC8qKlxuICAgICogUmVtb3ZlcyBkb3Qgc2VnbWVudHMgaW4gZ2l2ZW4gcGF0aCBjb21wb25lbnQsIGFzIGRlc2NyaWJlZCBpblxuICAgICogUkZDIDM5ODYsIHNlY3Rpb24gNS4yLjQuXG4gICAgKlxuICAgICogQHBhcmFtIHBhdGggQSBub24tZW1wdHkgcGF0aCBjb21wb25lbnQuXG4gICAgKiBAcmV0dXJuIFBhdGggY29tcG9uZW50IHdpdGggcmVtb3ZlZCBkb3Qgc2VnbWVudHMuXG4gICAgKi9cbiAgZnVuY3Rpb24gX3JlbW92ZURvdFNlZ21lbnRzKHBhdGgpIHtcbiAgICAgIGlmIChwYXRoID09ICcvJylcbiAgICAgICAgICByZXR1cm4gJy8nO1xuICAgICAgdmFyIGxlYWRpbmdTbGFzaCA9IHBhdGhbMF0gPT0gJy8nID8gJy8nIDogJyc7XG4gICAgICB2YXIgdHJhaWxpbmdTbGFzaCA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXSA9PT0gJy8nID8gJy8nIDogJyc7XG4gICAgICB2YXIgc2VnbWVudHMgPSBwYXRoLnNwbGl0KCcvJyk7XG4gICAgICB2YXIgb3V0ID0gW107XG4gICAgICB2YXIgdXAgPSAwO1xuICAgICAgZm9yICh2YXIgcG9zID0gMDsgcG9zIDwgc2VnbWVudHMubGVuZ3RoOyBwb3MrKykge1xuICAgICAgICAgIHZhciBzZWdtZW50ID0gc2VnbWVudHNbcG9zXTtcbiAgICAgICAgICBzd2l0Y2ggKHNlZ21lbnQpIHtcbiAgICAgICAgICAgICAgY2FzZSAnJzpcbiAgICAgICAgICAgICAgY2FzZSAnLic6XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAnLi4nOlxuICAgICAgICAgICAgICAgICAgaWYgKG91dC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgb3V0LnBvcCgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgdXArKztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgb3V0LnB1c2goc2VnbWVudCk7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGxlYWRpbmdTbGFzaCA9PSAnJykge1xuICAgICAgICAgIHdoaWxlICh1cC0tID4gMCkge1xuICAgICAgICAgICAgICBvdXQudW5zaGlmdCgnLi4nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG91dC5sZW5ndGggPT09IDApXG4gICAgICAgICAgICAgIG91dC5wdXNoKCcuJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbGVhZGluZ1NsYXNoICsgb3V0LmpvaW4oJy8nKSArIHRyYWlsaW5nU2xhc2g7XG4gIH1cbiAgLyoqXG4gICAqIFRha2VzIGFuIGFycmF5IG9mIHRoZSBwYXJ0cyBmcm9tIHNwbGl0IGFuZCBjYW5vbmljYWxpemVzIHRoZSBwYXRoIHBhcnRcbiAgICogYW5kIHRoZW4gam9pbnMgYWxsIHRoZSBwYXJ0cy5cbiAgICovXG4gIGZ1bmN0aW9uIF9qb2luQW5kQ2Fub25pY2FsaXplUGF0aChwYXJ0cykge1xuICAgICAgdmFyIHBhdGggPSBwYXJ0c1tfQ29tcG9uZW50SW5kZXguUGF0aF07XG4gICAgICBwYXRoID0gaXNCbGFuayhwYXRoKSA/ICcnIDogX3JlbW92ZURvdFNlZ21lbnRzKHBhdGgpO1xuICAgICAgcGFydHNbX0NvbXBvbmVudEluZGV4LlBhdGhdID0gcGF0aDtcbiAgICAgIHJldHVybiBfYnVpbGRGcm9tRW5jb2RlZFBhcnRzKHBhcnRzW19Db21wb25lbnRJbmRleC5TY2hlbWVdLCBwYXJ0c1tfQ29tcG9uZW50SW5kZXguVXNlckluZm9dLCBwYXJ0c1tfQ29tcG9uZW50SW5kZXguRG9tYWluXSwgcGFydHNbX0NvbXBvbmVudEluZGV4LlBvcnRdLCBwYXRoLCBwYXJ0c1tfQ29tcG9uZW50SW5kZXguUXVlcnlEYXRhXSwgcGFydHNbX0NvbXBvbmVudEluZGV4LkZyYWdtZW50XSk7XG4gIH1cbiAgLyoqXG4gICAqIFJlc29sdmVzIGEgVVJMLlxuICAgKiBAcGFyYW0gYmFzZSBUaGUgVVJMIGFjdGluZyBhcyB0aGUgYmFzZSBVUkwuXG4gICAqIEBwYXJhbSB0byBUaGUgVVJMIHRvIHJlc29sdmUuXG4gICAqL1xuICBmdW5jdGlvbiBfcmVzb2x2ZVVybChiYXNlLCB1cmwpIHtcbiAgICAgIHZhciBwYXJ0cyA9IF9zcGxpdChlbmNvZGVVUkkodXJsKSk7XG4gICAgICB2YXIgYmFzZVBhcnRzID0gX3NwbGl0KGJhc2UpO1xuICAgICAgaWYgKGlzUHJlc2VudChwYXJ0c1tfQ29tcG9uZW50SW5kZXguU2NoZW1lXSkpIHtcbiAgICAgICAgICByZXR1cm4gX2pvaW5BbmRDYW5vbmljYWxpemVQYXRoKHBhcnRzKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAgIHBhcnRzW19Db21wb25lbnRJbmRleC5TY2hlbWVdID0gYmFzZVBhcnRzW19Db21wb25lbnRJbmRleC5TY2hlbWVdO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IF9Db21wb25lbnRJbmRleC5TY2hlbWU7IGkgPD0gX0NvbXBvbmVudEluZGV4LlBvcnQ7IGkrKykge1xuICAgICAgICAgIGlmIChpc0JsYW5rKHBhcnRzW2ldKSkge1xuICAgICAgICAgICAgICBwYXJ0c1tpXSA9IGJhc2VQYXJ0c1tpXTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocGFydHNbX0NvbXBvbmVudEluZGV4LlBhdGhdWzBdID09ICcvJykge1xuICAgICAgICAgIHJldHVybiBfam9pbkFuZENhbm9uaWNhbGl6ZVBhdGgocGFydHMpO1xuICAgICAgfVxuICAgICAgdmFyIHBhdGggPSBiYXNlUGFydHNbX0NvbXBvbmVudEluZGV4LlBhdGhdO1xuICAgICAgaWYgKGlzQmxhbmsocGF0aCkpXG4gICAgICAgICAgcGF0aCA9ICcvJztcbiAgICAgIHZhciBpbmRleCA9IHBhdGgubGFzdEluZGV4T2YoJy8nKTtcbiAgICAgIHBhdGggPSBwYXRoLnN1YnN0cmluZygwLCBpbmRleCArIDEpICsgcGFydHNbX0NvbXBvbmVudEluZGV4LlBhdGhdO1xuICAgICAgcGFydHNbX0NvbXBvbmVudEluZGV4LlBhdGhdID0gcGF0aDtcbiAgICAgIHJldHVybiBfam9pbkFuZENhbm9uaWNhbGl6ZVBhdGgocGFydHMpO1xuICB9XG5cbiAgdmFyIERpcmVjdGl2ZU5vcm1hbGl6ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gRGlyZWN0aXZlTm9ybWFsaXplcihfcmVzb3VyY2VMb2FkZXIsIF91cmxSZXNvbHZlciwgX2h0bWxQYXJzZXIsIF9jb25maWcpIHtcbiAgICAgICAgICB0aGlzLl9yZXNvdXJjZUxvYWRlciA9IF9yZXNvdXJjZUxvYWRlcjtcbiAgICAgICAgICB0aGlzLl91cmxSZXNvbHZlciA9IF91cmxSZXNvbHZlcjtcbiAgICAgICAgICB0aGlzLl9odG1sUGFyc2VyID0gX2h0bWxQYXJzZXI7XG4gICAgICAgICAgdGhpcy5fY29uZmlnID0gX2NvbmZpZztcbiAgICAgICAgICB0aGlzLl9yZXNvdXJjZUxvYWRlckNhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgfVxuICAgICAgRGlyZWN0aXZlTm9ybWFsaXplci5wcm90b3R5cGUuY2xlYXJDYWNoZSA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fcmVzb3VyY2VMb2FkZXJDYWNoZS5jbGVhcigpOyB9O1xuICAgICAgRGlyZWN0aXZlTm9ybWFsaXplci5wcm90b3R5cGUuY2xlYXJDYWNoZUZvciA9IGZ1bmN0aW9uIChub3JtYWxpemVkRGlyZWN0aXZlKSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICBpZiAoIW5vcm1hbGl6ZWREaXJlY3RpdmUuaXNDb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9yZXNvdXJjZUxvYWRlckNhY2hlLmRlbGV0ZShub3JtYWxpemVkRGlyZWN0aXZlLnRlbXBsYXRlLnRlbXBsYXRlVXJsKTtcbiAgICAgICAgICBub3JtYWxpemVkRGlyZWN0aXZlLnRlbXBsYXRlLmV4dGVybmFsU3R5bGVzaGVldHMuZm9yRWFjaChmdW5jdGlvbiAoc3R5bGVzaGVldCkgeyBfdGhpcy5fcmVzb3VyY2VMb2FkZXJDYWNoZS5kZWxldGUoc3R5bGVzaGVldC5tb2R1bGVVcmwpOyB9KTtcbiAgICAgIH07XG4gICAgICBEaXJlY3RpdmVOb3JtYWxpemVyLnByb3RvdHlwZS5fZmV0Y2ggPSBmdW5jdGlvbiAodXJsKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuX3Jlc291cmNlTG9hZGVyQ2FjaGUuZ2V0KHVybCk7XG4gICAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5fcmVzb3VyY2VMb2FkZXIuZ2V0KHVybCk7XG4gICAgICAgICAgICAgIHRoaXMuX3Jlc291cmNlTG9hZGVyQ2FjaGUuc2V0KHVybCwgcmVzdWx0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgICBEaXJlY3RpdmVOb3JtYWxpemVyLnByb3RvdHlwZS5ub3JtYWxpemVEaXJlY3RpdmUgPSBmdW5jdGlvbiAoZGlyZWN0aXZlKSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICBpZiAoIWRpcmVjdGl2ZS5pc0NvbXBvbmVudCkge1xuICAgICAgICAgICAgICAvLyBGb3Igbm9uIGNvbXBvbmVudHMgdGhlcmUgaXMgbm90aGluZyB0byBiZSBub3JtYWxpemVkIHlldC5cbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTeW5jQXN5bmNSZXN1bHQoZGlyZWN0aXZlLCBQcm9taXNlLnJlc29sdmUoZGlyZWN0aXZlKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBub3JtYWxpemVkVGVtcGxhdGVTeW5jID0gbnVsbDtcbiAgICAgICAgICB2YXIgbm9ybWFsaXplZFRlbXBsYXRlQXN5bmM7XG4gICAgICAgICAgaWYgKGlzUHJlc2VudChkaXJlY3RpdmUudGVtcGxhdGUudGVtcGxhdGUpKSB7XG4gICAgICAgICAgICAgIG5vcm1hbGl6ZWRUZW1wbGF0ZVN5bmMgPSB0aGlzLm5vcm1hbGl6ZVRlbXBsYXRlU3luYyhkaXJlY3RpdmUudHlwZSwgZGlyZWN0aXZlLnRlbXBsYXRlKTtcbiAgICAgICAgICAgICAgbm9ybWFsaXplZFRlbXBsYXRlQXN5bmMgPSBQcm9taXNlLnJlc29sdmUobm9ybWFsaXplZFRlbXBsYXRlU3luYyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKGRpcmVjdGl2ZS50ZW1wbGF0ZS50ZW1wbGF0ZVVybCkge1xuICAgICAgICAgICAgICBub3JtYWxpemVkVGVtcGxhdGVBc3luYyA9IHRoaXMubm9ybWFsaXplVGVtcGxhdGVBc3luYyhkaXJlY3RpdmUudHlwZSwgZGlyZWN0aXZlLnRlbXBsYXRlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHRlbXBsYXRlIHNwZWNpZmllZCBmb3IgY29tcG9uZW50IFwiICsgZGlyZWN0aXZlLnR5cGUubmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChub3JtYWxpemVkVGVtcGxhdGVTeW5jICYmIG5vcm1hbGl6ZWRUZW1wbGF0ZVN5bmMuc3R5bGVVcmxzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAvLyBzeW5jIGNhc2VcbiAgICAgICAgICAgICAgdmFyIG5vcm1hbGl6ZWREaXJlY3RpdmUgPSBfY2xvbmVEaXJlY3RpdmVXaXRoVGVtcGxhdGUoZGlyZWN0aXZlLCBub3JtYWxpemVkVGVtcGxhdGVTeW5jKTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTeW5jQXN5bmNSZXN1bHQobm9ybWFsaXplZERpcmVjdGl2ZSwgUHJvbWlzZS5yZXNvbHZlKG5vcm1hbGl6ZWREaXJlY3RpdmUpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIC8vIGFzeW5jIGNhc2VcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTeW5jQXN5bmNSZXN1bHQobnVsbCwgbm9ybWFsaXplZFRlbXBsYXRlQXN5bmNcbiAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChub3JtYWxpemVkVGVtcGxhdGUpIHsgcmV0dXJuIF90aGlzLm5vcm1hbGl6ZUV4dGVybmFsU3R5bGVzaGVldHMobm9ybWFsaXplZFRlbXBsYXRlKTsgfSlcbiAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChub3JtYWxpemVkVGVtcGxhdGUpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBfY2xvbmVEaXJlY3RpdmVXaXRoVGVtcGxhdGUoZGlyZWN0aXZlLCBub3JtYWxpemVkVGVtcGxhdGUpO1xuICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIERpcmVjdGl2ZU5vcm1hbGl6ZXIucHJvdG90eXBlLm5vcm1hbGl6ZVRlbXBsYXRlU3luYyA9IGZ1bmN0aW9uIChkaXJlY3RpdmVUeXBlLCB0ZW1wbGF0ZSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLm5vcm1hbGl6ZUxvYWRlZFRlbXBsYXRlKGRpcmVjdGl2ZVR5cGUsIHRlbXBsYXRlLCB0ZW1wbGF0ZS50ZW1wbGF0ZSwgZGlyZWN0aXZlVHlwZS5tb2R1bGVVcmwpO1xuICAgICAgfTtcbiAgICAgIERpcmVjdGl2ZU5vcm1hbGl6ZXIucHJvdG90eXBlLm5vcm1hbGl6ZVRlbXBsYXRlQXN5bmMgPSBmdW5jdGlvbiAoZGlyZWN0aXZlVHlwZSwgdGVtcGxhdGUpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHZhciB0ZW1wbGF0ZVVybCA9IHRoaXMuX3VybFJlc29sdmVyLnJlc29sdmUoZGlyZWN0aXZlVHlwZS5tb2R1bGVVcmwsIHRlbXBsYXRlLnRlbXBsYXRlVXJsKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fZmV0Y2godGVtcGxhdGVVcmwpXG4gICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gX3RoaXMubm9ybWFsaXplTG9hZGVkVGVtcGxhdGUoZGlyZWN0aXZlVHlwZSwgdGVtcGxhdGUsIHZhbHVlLCB0ZW1wbGF0ZVVybCk7IH0pO1xuICAgICAgfTtcbiAgICAgIERpcmVjdGl2ZU5vcm1hbGl6ZXIucHJvdG90eXBlLm5vcm1hbGl6ZUxvYWRlZFRlbXBsYXRlID0gZnVuY3Rpb24gKGRpcmVjdGl2ZVR5cGUsIHRlbXBsYXRlTWV0YSwgdGVtcGxhdGUsIHRlbXBsYXRlQWJzVXJsKSB7XG4gICAgICAgICAgdmFyIGludGVycG9sYXRpb25Db25maWcgPSBJbnRlcnBvbGF0aW9uQ29uZmlnLmZyb21BcnJheSh0ZW1wbGF0ZU1ldGEuaW50ZXJwb2xhdGlvbik7XG4gICAgICAgICAgdmFyIHJvb3ROb2Rlc0FuZEVycm9ycyA9IHRoaXMuX2h0bWxQYXJzZXIucGFyc2UodGVtcGxhdGUsIGRpcmVjdGl2ZVR5cGUubmFtZSwgZmFsc2UsIGludGVycG9sYXRpb25Db25maWcpO1xuICAgICAgICAgIGlmIChyb290Tm9kZXNBbmRFcnJvcnMuZXJyb3JzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgdmFyIGVycm9yU3RyaW5nID0gcm9vdE5vZGVzQW5kRXJyb3JzLmVycm9ycy5qb2luKCdcXG4nKTtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGVtcGxhdGUgcGFyc2UgZXJyb3JzOlxcblwiICsgZXJyb3JTdHJpbmcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgdGVtcGxhdGVNZXRhZGF0YVN0eWxlcyA9IHRoaXMubm9ybWFsaXplU3R5bGVzaGVldChuZXcgQ29tcGlsZVN0eWxlc2hlZXRNZXRhZGF0YSh7XG4gICAgICAgICAgICAgIHN0eWxlczogdGVtcGxhdGVNZXRhLnN0eWxlcyxcbiAgICAgICAgICAgICAgc3R5bGVVcmxzOiB0ZW1wbGF0ZU1ldGEuc3R5bGVVcmxzLFxuICAgICAgICAgICAgICBtb2R1bGVVcmw6IGRpcmVjdGl2ZVR5cGUubW9kdWxlVXJsXG4gICAgICAgICAgfSkpO1xuICAgICAgICAgIHZhciB2aXNpdG9yID0gbmV3IFRlbXBsYXRlUHJlcGFyc2VWaXNpdG9yKCk7XG4gICAgICAgICAgdmlzaXRBbGwodmlzaXRvciwgcm9vdE5vZGVzQW5kRXJyb3JzLnJvb3ROb2Rlcyk7XG4gICAgICAgICAgdmFyIHRlbXBsYXRlU3R5bGVzID0gdGhpcy5ub3JtYWxpemVTdHlsZXNoZWV0KG5ldyBDb21waWxlU3R5bGVzaGVldE1ldGFkYXRhKHsgc3R5bGVzOiB2aXNpdG9yLnN0eWxlcywgc3R5bGVVcmxzOiB2aXNpdG9yLnN0eWxlVXJscywgbW9kdWxlVXJsOiB0ZW1wbGF0ZUFic1VybCB9KSk7XG4gICAgICAgICAgdmFyIGVuY2Fwc3VsYXRpb24gPSB0ZW1wbGF0ZU1ldGEuZW5jYXBzdWxhdGlvbjtcbiAgICAgICAgICBpZiAoaXNCbGFuayhlbmNhcHN1bGF0aW9uKSkge1xuICAgICAgICAgICAgICBlbmNhcHN1bGF0aW9uID0gdGhpcy5fY29uZmlnLmRlZmF1bHRFbmNhcHN1bGF0aW9uO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgc3R5bGVzID0gdGVtcGxhdGVNZXRhZGF0YVN0eWxlcy5zdHlsZXMuY29uY2F0KHRlbXBsYXRlU3R5bGVzLnN0eWxlcyk7XG4gICAgICAgICAgdmFyIHN0eWxlVXJscyA9IHRlbXBsYXRlTWV0YWRhdGFTdHlsZXMuc3R5bGVVcmxzLmNvbmNhdCh0ZW1wbGF0ZVN0eWxlcy5zdHlsZVVybHMpO1xuICAgICAgICAgIGlmIChlbmNhcHN1bGF0aW9uID09PSBfYW5ndWxhcl9jb3JlLlZpZXdFbmNhcHN1bGF0aW9uLkVtdWxhdGVkICYmIHN0eWxlcy5sZW5ndGggPT09IDAgJiZcbiAgICAgICAgICAgICAgc3R5bGVVcmxzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICBlbmNhcHN1bGF0aW9uID0gX2FuZ3VsYXJfY29yZS5WaWV3RW5jYXBzdWxhdGlvbi5Ob25lO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3IENvbXBpbGVUZW1wbGF0ZU1ldGFkYXRhKHtcbiAgICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogZW5jYXBzdWxhdGlvbixcbiAgICAgICAgICAgICAgdGVtcGxhdGU6IHRlbXBsYXRlLFxuICAgICAgICAgICAgICB0ZW1wbGF0ZVVybDogdGVtcGxhdGVBYnNVcmwsIHN0eWxlczogc3R5bGVzLCBzdHlsZVVybHM6IHN0eWxlVXJscyxcbiAgICAgICAgICAgICAgZXh0ZXJuYWxTdHlsZXNoZWV0czogdGVtcGxhdGVNZXRhLmV4dGVybmFsU3R5bGVzaGVldHMsXG4gICAgICAgICAgICAgIG5nQ29udGVudFNlbGVjdG9yczogdmlzaXRvci5uZ0NvbnRlbnRTZWxlY3RvcnMsXG4gICAgICAgICAgICAgIGFuaW1hdGlvbnM6IHRlbXBsYXRlTWV0YS5hbmltYXRpb25zLFxuICAgICAgICAgICAgICBpbnRlcnBvbGF0aW9uOiB0ZW1wbGF0ZU1ldGEuaW50ZXJwb2xhdGlvbixcbiAgICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBEaXJlY3RpdmVOb3JtYWxpemVyLnByb3RvdHlwZS5ub3JtYWxpemVFeHRlcm5hbFN0eWxlc2hlZXRzID0gZnVuY3Rpb24gKHRlbXBsYXRlTWV0YSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9sb2FkTWlzc2luZ0V4dGVybmFsU3R5bGVzaGVldHModGVtcGxhdGVNZXRhLnN0eWxlVXJscylcbiAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGV4dGVybmFsU3R5bGVzaGVldHMpIHsgcmV0dXJuIG5ldyBDb21waWxlVGVtcGxhdGVNZXRhZGF0YSh7XG4gICAgICAgICAgICAgIGVuY2Fwc3VsYXRpb246IHRlbXBsYXRlTWV0YS5lbmNhcHN1bGF0aW9uLFxuICAgICAgICAgICAgICB0ZW1wbGF0ZTogdGVtcGxhdGVNZXRhLnRlbXBsYXRlLFxuICAgICAgICAgICAgICB0ZW1wbGF0ZVVybDogdGVtcGxhdGVNZXRhLnRlbXBsYXRlVXJsLFxuICAgICAgICAgICAgICBzdHlsZXM6IHRlbXBsYXRlTWV0YS5zdHlsZXMsXG4gICAgICAgICAgICAgIHN0eWxlVXJsczogdGVtcGxhdGVNZXRhLnN0eWxlVXJscyxcbiAgICAgICAgICAgICAgZXh0ZXJuYWxTdHlsZXNoZWV0czogZXh0ZXJuYWxTdHlsZXNoZWV0cyxcbiAgICAgICAgICAgICAgbmdDb250ZW50U2VsZWN0b3JzOiB0ZW1wbGF0ZU1ldGEubmdDb250ZW50U2VsZWN0b3JzLFxuICAgICAgICAgICAgICBhbmltYXRpb25zOiB0ZW1wbGF0ZU1ldGEuYW5pbWF0aW9ucyxcbiAgICAgICAgICAgICAgaW50ZXJwb2xhdGlvbjogdGVtcGxhdGVNZXRhLmludGVycG9sYXRpb25cbiAgICAgICAgICB9KTsgfSk7XG4gICAgICB9O1xuICAgICAgRGlyZWN0aXZlTm9ybWFsaXplci5wcm90b3R5cGUuX2xvYWRNaXNzaW5nRXh0ZXJuYWxTdHlsZXNoZWV0cyA9IGZ1bmN0aW9uIChzdHlsZVVybHMsIGxvYWRlZFN0eWxlc2hlZXRzKSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICBpZiAobG9hZGVkU3R5bGVzaGVldHMgPT09IHZvaWQgMCkgeyBsb2FkZWRTdHlsZXNoZWV0cyA9IG5ldyBNYXAoKTsgfVxuICAgICAgICAgIHJldHVybiBQcm9taXNlXG4gICAgICAgICAgICAgIC5hbGwoc3R5bGVVcmxzLmZpbHRlcihmdW5jdGlvbiAoc3R5bGVVcmwpIHsgcmV0dXJuICFsb2FkZWRTdHlsZXNoZWV0cy5oYXMoc3R5bGVVcmwpOyB9KVxuICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChzdHlsZVVybCkgeyByZXR1cm4gX3RoaXMuX2ZldGNoKHN0eWxlVXJsKS50aGVuKGZ1bmN0aW9uIChsb2FkZWRTdHlsZSkge1xuICAgICAgICAgICAgICB2YXIgc3R5bGVzaGVldCA9IF90aGlzLm5vcm1hbGl6ZVN0eWxlc2hlZXQobmV3IENvbXBpbGVTdHlsZXNoZWV0TWV0YWRhdGEoeyBzdHlsZXM6IFtsb2FkZWRTdHlsZV0sIG1vZHVsZVVybDogc3R5bGVVcmwgfSkpO1xuICAgICAgICAgICAgICBsb2FkZWRTdHlsZXNoZWV0cy5zZXQoc3R5bGVVcmwsIHN0eWxlc2hlZXQpO1xuICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuX2xvYWRNaXNzaW5nRXh0ZXJuYWxTdHlsZXNoZWV0cyhzdHlsZXNoZWV0LnN0eWxlVXJscywgbG9hZGVkU3R5bGVzaGVldHMpO1xuICAgICAgICAgIH0pOyB9KSlcbiAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKF8pIHsgcmV0dXJuIE1hcFdyYXBwZXIudmFsdWVzKGxvYWRlZFN0eWxlc2hlZXRzKTsgfSk7XG4gICAgICB9O1xuICAgICAgRGlyZWN0aXZlTm9ybWFsaXplci5wcm90b3R5cGUubm9ybWFsaXplU3R5bGVzaGVldCA9IGZ1bmN0aW9uIChzdHlsZXNoZWV0KSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICB2YXIgYWxsU3R5bGVVcmxzID0gc3R5bGVzaGVldC5zdHlsZVVybHMuZmlsdGVyKGlzU3R5bGVVcmxSZXNvbHZhYmxlKVxuICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uICh1cmwpIHsgcmV0dXJuIF90aGlzLl91cmxSZXNvbHZlci5yZXNvbHZlKHN0eWxlc2hlZXQubW9kdWxlVXJsLCB1cmwpOyB9KTtcbiAgICAgICAgICB2YXIgYWxsU3R5bGVzID0gc3R5bGVzaGVldC5zdHlsZXMubWFwKGZ1bmN0aW9uIChzdHlsZSkge1xuICAgICAgICAgICAgICB2YXIgc3R5bGVXaXRoSW1wb3J0cyA9IGV4dHJhY3RTdHlsZVVybHMoX3RoaXMuX3VybFJlc29sdmVyLCBzdHlsZXNoZWV0Lm1vZHVsZVVybCwgc3R5bGUpO1xuICAgICAgICAgICAgICBhbGxTdHlsZVVybHMucHVzaC5hcHBseShhbGxTdHlsZVVybHMsIHN0eWxlV2l0aEltcG9ydHMuc3R5bGVVcmxzKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHN0eWxlV2l0aEltcG9ydHMuc3R5bGU7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIG5ldyBDb21waWxlU3R5bGVzaGVldE1ldGFkYXRhKHsgc3R5bGVzOiBhbGxTdHlsZXMsIHN0eWxlVXJsczogYWxsU3R5bGVVcmxzLCBtb2R1bGVVcmw6IHN0eWxlc2hlZXQubW9kdWxlVXJsIH0pO1xuICAgICAgfTtcbiAgICAgIERpcmVjdGl2ZU5vcm1hbGl6ZXIuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0YWJsZSB9LFxuICAgICAgXTtcbiAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgRGlyZWN0aXZlTm9ybWFsaXplci5jdG9yUGFyYW1ldGVycyA9IFtcbiAgICAgICAgICB7IHR5cGU6IFJlc291cmNlTG9hZGVyLCB9LFxuICAgICAgICAgIHsgdHlwZTogVXJsUmVzb2x2ZXIsIH0sXG4gICAgICAgICAgeyB0eXBlOiBIdG1sUGFyc2VyLCB9LFxuICAgICAgICAgIHsgdHlwZTogQ29tcGlsZXJDb25maWcsIH0sXG4gICAgICBdO1xuICAgICAgcmV0dXJuIERpcmVjdGl2ZU5vcm1hbGl6ZXI7XG4gIH0oKSk7XG4gIHZhciBUZW1wbGF0ZVByZXBhcnNlVmlzaXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBUZW1wbGF0ZVByZXBhcnNlVmlzaXRvcigpIHtcbiAgICAgICAgICB0aGlzLm5nQ29udGVudFNlbGVjdG9ycyA9IFtdO1xuICAgICAgICAgIHRoaXMuc3R5bGVzID0gW107XG4gICAgICAgICAgdGhpcy5zdHlsZVVybHMgPSBbXTtcbiAgICAgICAgICB0aGlzLm5nTm9uQmluZGFibGVTdGFja0NvdW50ID0gMDtcbiAgICAgIH1cbiAgICAgIFRlbXBsYXRlUHJlcGFyc2VWaXNpdG9yLnByb3RvdHlwZS52aXNpdEVsZW1lbnQgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgICAgdmFyIHByZXBhcnNlZEVsZW1lbnQgPSBwcmVwYXJzZUVsZW1lbnQoYXN0KTtcbiAgICAgICAgICBzd2l0Y2ggKHByZXBhcnNlZEVsZW1lbnQudHlwZSkge1xuICAgICAgICAgICAgICBjYXNlIFByZXBhcnNlZEVsZW1lbnRUeXBlLk5HX0NPTlRFTlQ6XG4gICAgICAgICAgICAgICAgICBpZiAodGhpcy5uZ05vbkJpbmRhYmxlU3RhY2tDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgIHRoaXMubmdDb250ZW50U2VsZWN0b3JzLnB1c2gocHJlcGFyc2VkRWxlbWVudC5zZWxlY3RBdHRyKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFByZXBhcnNlZEVsZW1lbnRUeXBlLlNUWUxFOlxuICAgICAgICAgICAgICAgICAgdmFyIHRleHRDb250ZW50ID0gJyc7XG4gICAgICAgICAgICAgICAgICBhc3QuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBUZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRleHRDb250ZW50ICs9IGNoaWxkLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgdGhpcy5zdHlsZXMucHVzaCh0ZXh0Q29udGVudCk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBQcmVwYXJzZWRFbGVtZW50VHlwZS5TVFlMRVNIRUVUOlxuICAgICAgICAgICAgICAgICAgdGhpcy5zdHlsZVVybHMucHVzaChwcmVwYXJzZWRFbGVtZW50LmhyZWZBdHRyKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwcmVwYXJzZWRFbGVtZW50Lm5vbkJpbmRhYmxlKSB7XG4gICAgICAgICAgICAgIHRoaXMubmdOb25CaW5kYWJsZVN0YWNrQ291bnQrKztcbiAgICAgICAgICB9XG4gICAgICAgICAgdmlzaXRBbGwodGhpcywgYXN0LmNoaWxkcmVuKTtcbiAgICAgICAgICBpZiAocHJlcGFyc2VkRWxlbWVudC5ub25CaW5kYWJsZSkge1xuICAgICAgICAgICAgICB0aGlzLm5nTm9uQmluZGFibGVTdGFja0NvdW50LS07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcbiAgICAgIFRlbXBsYXRlUHJlcGFyc2VWaXNpdG9yLnByb3RvdHlwZS52aXNpdENvbW1lbnQgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IHJldHVybiBudWxsOyB9O1xuICAgICAgVGVtcGxhdGVQcmVwYXJzZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0QXR0cmlidXRlID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyByZXR1cm4gbnVsbDsgfTtcbiAgICAgIFRlbXBsYXRlUHJlcGFyc2VWaXNpdG9yLnByb3RvdHlwZS52aXNpdFRleHQgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IHJldHVybiBudWxsOyB9O1xuICAgICAgVGVtcGxhdGVQcmVwYXJzZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0RXhwYW5zaW9uID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyByZXR1cm4gbnVsbDsgfTtcbiAgICAgIFRlbXBsYXRlUHJlcGFyc2VWaXNpdG9yLnByb3RvdHlwZS52aXNpdEV4cGFuc2lvbkNhc2UgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IHJldHVybiBudWxsOyB9O1xuICAgICAgcmV0dXJuIFRlbXBsYXRlUHJlcGFyc2VWaXNpdG9yO1xuICB9KCkpO1xuICBmdW5jdGlvbiBfY2xvbmVEaXJlY3RpdmVXaXRoVGVtcGxhdGUoZGlyZWN0aXZlLCB0ZW1wbGF0ZSkge1xuICAgICAgcmV0dXJuIG5ldyBDb21waWxlRGlyZWN0aXZlTWV0YWRhdGEoe1xuICAgICAgICAgIHR5cGU6IGRpcmVjdGl2ZS50eXBlLFxuICAgICAgICAgIGlzQ29tcG9uZW50OiBkaXJlY3RpdmUuaXNDb21wb25lbnQsXG4gICAgICAgICAgc2VsZWN0b3I6IGRpcmVjdGl2ZS5zZWxlY3RvcixcbiAgICAgICAgICBleHBvcnRBczogZGlyZWN0aXZlLmV4cG9ydEFzLFxuICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogZGlyZWN0aXZlLmNoYW5nZURldGVjdGlvbixcbiAgICAgICAgICBpbnB1dHM6IGRpcmVjdGl2ZS5pbnB1dHMsXG4gICAgICAgICAgb3V0cHV0czogZGlyZWN0aXZlLm91dHB1dHMsXG4gICAgICAgICAgaG9zdExpc3RlbmVyczogZGlyZWN0aXZlLmhvc3RMaXN0ZW5lcnMsXG4gICAgICAgICAgaG9zdFByb3BlcnRpZXM6IGRpcmVjdGl2ZS5ob3N0UHJvcGVydGllcyxcbiAgICAgICAgICBob3N0QXR0cmlidXRlczogZGlyZWN0aXZlLmhvc3RBdHRyaWJ1dGVzLFxuICAgICAgICAgIHByb3ZpZGVyczogZGlyZWN0aXZlLnByb3ZpZGVycyxcbiAgICAgICAgICB2aWV3UHJvdmlkZXJzOiBkaXJlY3RpdmUudmlld1Byb3ZpZGVycyxcbiAgICAgICAgICBxdWVyaWVzOiBkaXJlY3RpdmUucXVlcmllcyxcbiAgICAgICAgICB2aWV3UXVlcmllczogZGlyZWN0aXZlLnZpZXdRdWVyaWVzLFxuICAgICAgICAgIGVudHJ5Q29tcG9uZW50czogZGlyZWN0aXZlLmVudHJ5Q29tcG9uZW50cywgdGVtcGxhdGU6IHRlbXBsYXRlLFxuICAgICAgfSk7XG4gIH1cblxuICAvKlxuICAgKiBSZXNvbHZlIGEgYFR5cGVgIGZvciB7QGxpbmsgRGlyZWN0aXZlfS5cbiAgICpcbiAgICogVGhpcyBpbnRlcmZhY2UgY2FuIGJlIG92ZXJyaWRkZW4gYnkgdGhlIGFwcGxpY2F0aW9uIGRldmVsb3BlciB0byBjcmVhdGUgY3VzdG9tIGJlaGF2aW9yLlxuICAgKlxuICAgKiBTZWUge0BsaW5rIENvbXBpbGVyfVxuICAgKi9cbiAgdmFyIERpcmVjdGl2ZVJlc29sdmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIERpcmVjdGl2ZVJlc29sdmVyKF9yZWZsZWN0b3IpIHtcbiAgICAgICAgICBpZiAoX3JlZmxlY3RvciA9PT0gdm9pZCAwKSB7IF9yZWZsZWN0b3IgPSByZWZsZWN0b3I7IH1cbiAgICAgICAgICB0aGlzLl9yZWZsZWN0b3IgPSBfcmVmbGVjdG9yO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBSZXR1cm4ge0BsaW5rIERpcmVjdGl2ZX0gZm9yIGEgZ2l2ZW4gYFR5cGVgLlxuICAgICAgICovXG4gICAgICBEaXJlY3RpdmVSZXNvbHZlci5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uICh0eXBlLCB0aHJvd0lmTm90Rm91bmQpIHtcbiAgICAgICAgICBpZiAodGhyb3dJZk5vdEZvdW5kID09PSB2b2lkIDApIHsgdGhyb3dJZk5vdEZvdW5kID0gdHJ1ZTsgfVxuICAgICAgICAgIHZhciB0eXBlTWV0YWRhdGEgPSB0aGlzLl9yZWZsZWN0b3IuYW5ub3RhdGlvbnMoX2FuZ3VsYXJfY29yZS5yZXNvbHZlRm9yd2FyZFJlZih0eXBlKSk7XG4gICAgICAgICAgaWYgKHR5cGVNZXRhZGF0YSkge1xuICAgICAgICAgICAgICB2YXIgbWV0YWRhdGEgPSB0eXBlTWV0YWRhdGEuZmluZChpc0RpcmVjdGl2ZU1ldGFkYXRhKTtcbiAgICAgICAgICAgICAgaWYgKG1ldGFkYXRhKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgcHJvcGVydHlNZXRhZGF0YSA9IHRoaXMuX3JlZmxlY3Rvci5wcm9wTWV0YWRhdGEodHlwZSk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbWVyZ2VXaXRoUHJvcGVydHlNZXRhZGF0YShtZXRhZGF0YSwgcHJvcGVydHlNZXRhZGF0YSwgdHlwZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRocm93SWZOb3RGb3VuZCkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBEaXJlY3RpdmUgYW5ub3RhdGlvbiBmb3VuZCBvbiBcIiArIHN0cmluZ2lmeSh0eXBlKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcbiAgICAgIERpcmVjdGl2ZVJlc29sdmVyLnByb3RvdHlwZS5fbWVyZ2VXaXRoUHJvcGVydHlNZXRhZGF0YSA9IGZ1bmN0aW9uIChkbSwgcHJvcGVydHlNZXRhZGF0YSwgZGlyZWN0aXZlVHlwZSkge1xuICAgICAgICAgIHZhciBpbnB1dHMgPSBbXTtcbiAgICAgICAgICB2YXIgb3V0cHV0cyA9IFtdO1xuICAgICAgICAgIHZhciBob3N0ID0ge307XG4gICAgICAgICAgdmFyIHF1ZXJpZXMgPSB7fTtcbiAgICAgICAgICBPYmplY3Qua2V5cyhwcm9wZXJ0eU1ldGFkYXRhKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wTmFtZSkge1xuICAgICAgICAgICAgICBwcm9wZXJ0eU1ldGFkYXRhW3Byb3BOYW1lXS5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoYSBpbnN0YW5jZW9mIF9hbmd1bGFyX2NvcmUuSW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoYS5iaW5kaW5nUHJvcGVydHlOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0cy5wdXNoKHByb3BOYW1lICsgXCI6IFwiICsgYS5iaW5kaW5nUHJvcGVydHlOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0cy5wdXNoKHByb3BOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBlbHNlIGlmIChhIGluc3RhbmNlb2YgX2FuZ3VsYXJfY29yZS5PdXRwdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgb3V0cHV0ID0gYTtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAob3V0cHV0LmJpbmRpbmdQcm9wZXJ0eU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0cy5wdXNoKHByb3BOYW1lICsgXCI6IFwiICsgb3V0cHV0LmJpbmRpbmdQcm9wZXJ0eU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0cy5wdXNoKHByb3BOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBlbHNlIGlmIChhIGluc3RhbmNlb2YgX2FuZ3VsYXJfY29yZS5Ib3N0QmluZGluZykge1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBob3N0QmluZGluZyA9IGE7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGhvc3RCaW5kaW5nLmhvc3RQcm9wZXJ0eU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0V2l0aCA9IGhvc3RCaW5kaW5nLmhvc3RQcm9wZXJ0eU5hbWVbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGFydFdpdGggPT09ICcoJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQEhvc3RCaW5kaW5nIGNhbiBub3QgYmluZCB0byBldmVudHMuIFVzZSBASG9zdExpc3RlbmVyIGluc3RlYWQuXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHN0YXJ0V2l0aCA9PT0gJ1snKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJASG9zdEJpbmRpbmcgcGFyYW1ldGVyIHNob3VsZCBiZSBhIHByb3BlcnR5IG5hbWUsICdjbGFzcy48bmFtZT4nLCBvciAnYXR0ci48bmFtZT4nLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICBob3N0WyhcIltcIiArIGhvc3RCaW5kaW5nLmhvc3RQcm9wZXJ0eU5hbWUgKyBcIl1cIildID0gcHJvcE5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBob3N0WyhcIltcIiArIHByb3BOYW1lICsgXCJdXCIpXSA9IHByb3BOYW1lO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGEgaW5zdGFuY2VvZiBfYW5ndWxhcl9jb3JlLkhvc3RMaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBob3N0TGlzdGVuZXIgPSBhO1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBhcmdzID0gaG9zdExpc3RlbmVyLmFyZ3MgfHwgW107XG4gICAgICAgICAgICAgICAgICAgICAgaG9zdFsoXCIoXCIgKyBob3N0TGlzdGVuZXIuZXZlbnROYW1lICsgXCIpXCIpXSA9IHByb3BOYW1lICsgXCIoXCIgKyBhcmdzLmpvaW4oJywnKSArIFwiKVwiO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYSBpbnN0YW5jZW9mIF9hbmd1bGFyX2NvcmUuUXVlcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICBxdWVyaWVzW3Byb3BOYW1lXSA9IGE7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiB0aGlzLl9tZXJnZShkbSwgaW5wdXRzLCBvdXRwdXRzLCBob3N0LCBxdWVyaWVzLCBkaXJlY3RpdmVUeXBlKTtcbiAgICAgIH07XG4gICAgICBEaXJlY3RpdmVSZXNvbHZlci5wcm90b3R5cGUuX2V4dHJhY3RQdWJsaWNOYW1lID0gZnVuY3Rpb24gKGRlZikgeyByZXR1cm4gc3BsaXRBdENvbG9uKGRlZiwgW251bGwsIGRlZl0pWzFdLnRyaW0oKTsgfTtcbiAgICAgIERpcmVjdGl2ZVJlc29sdmVyLnByb3RvdHlwZS5fbWVyZ2UgPSBmdW5jdGlvbiAoZGlyZWN0aXZlLCBpbnB1dHMsIG91dHB1dHMsIGhvc3QsIHF1ZXJpZXMsIGRpcmVjdGl2ZVR5cGUpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHZhciBtZXJnZWRJbnB1dHMgPSBpbnB1dHM7XG4gICAgICAgICAgaWYgKGRpcmVjdGl2ZS5pbnB1dHMpIHtcbiAgICAgICAgICAgICAgdmFyIGlucHV0TmFtZXNfMSA9IGRpcmVjdGl2ZS5pbnB1dHMubWFwKGZ1bmN0aW9uIChkZWYpIHsgcmV0dXJuIF90aGlzLl9leHRyYWN0UHVibGljTmFtZShkZWYpOyB9KTtcbiAgICAgICAgICAgICAgaW5wdXRzLmZvckVhY2goZnVuY3Rpb24gKGlucHV0RGVmKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgcHVibGljTmFtZSA9IF90aGlzLl9leHRyYWN0UHVibGljTmFtZShpbnB1dERlZik7XG4gICAgICAgICAgICAgICAgICBpZiAoaW5wdXROYW1lc18xLmluZGV4T2YocHVibGljTmFtZSkgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIklucHV0ICdcIiArIHB1YmxpY05hbWUgKyBcIicgZGVmaW5lZCBtdWx0aXBsZSB0aW1lcyBpbiAnXCIgKyBzdHJpbmdpZnkoZGlyZWN0aXZlVHlwZSkgKyBcIidcIik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBtZXJnZWRJbnB1dHMudW5zaGlmdC5hcHBseShtZXJnZWRJbnB1dHMsIGRpcmVjdGl2ZS5pbnB1dHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgbWVyZ2VkT3V0cHV0cyA9IG91dHB1dHM7XG4gICAgICAgICAgaWYgKGRpcmVjdGl2ZS5vdXRwdXRzKSB7XG4gICAgICAgICAgICAgIHZhciBvdXRwdXROYW1lc18xID0gZGlyZWN0aXZlLm91dHB1dHMubWFwKGZ1bmN0aW9uIChkZWYpIHsgcmV0dXJuIF90aGlzLl9leHRyYWN0UHVibGljTmFtZShkZWYpOyB9KTtcbiAgICAgICAgICAgICAgb3V0cHV0cy5mb3JFYWNoKGZ1bmN0aW9uIChvdXRwdXREZWYpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBwdWJsaWNOYW1lID0gX3RoaXMuX2V4dHJhY3RQdWJsaWNOYW1lKG91dHB1dERlZik7XG4gICAgICAgICAgICAgICAgICBpZiAob3V0cHV0TmFtZXNfMS5pbmRleE9mKHB1YmxpY05hbWUpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJPdXRwdXQgZXZlbnQgJ1wiICsgcHVibGljTmFtZSArIFwiJyBkZWZpbmVkIG11bHRpcGxlIHRpbWVzIGluICdcIiArIHN0cmluZ2lmeShkaXJlY3RpdmVUeXBlKSArIFwiJ1wiKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIG1lcmdlZE91dHB1dHMudW5zaGlmdC5hcHBseShtZXJnZWRPdXRwdXRzLCBkaXJlY3RpdmUub3V0cHV0cyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBtZXJnZWRIb3N0ID0gZGlyZWN0aXZlLmhvc3QgPyBTdHJpbmdNYXBXcmFwcGVyLm1lcmdlKGRpcmVjdGl2ZS5ob3N0LCBob3N0KSA6IGhvc3Q7XG4gICAgICAgICAgdmFyIG1lcmdlZFF1ZXJpZXMgPSBkaXJlY3RpdmUucXVlcmllcyA/IFN0cmluZ01hcFdyYXBwZXIubWVyZ2UoZGlyZWN0aXZlLnF1ZXJpZXMsIHF1ZXJpZXMpIDogcXVlcmllcztcbiAgICAgICAgICBpZiAoZGlyZWN0aXZlIGluc3RhbmNlb2YgX2FuZ3VsYXJfY29yZS5Db21wb25lbnQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBfYW5ndWxhcl9jb3JlLkNvbXBvbmVudCh7XG4gICAgICAgICAgICAgICAgICBzZWxlY3RvcjogZGlyZWN0aXZlLnNlbGVjdG9yLFxuICAgICAgICAgICAgICAgICAgaW5wdXRzOiBtZXJnZWRJbnB1dHMsXG4gICAgICAgICAgICAgICAgICBvdXRwdXRzOiBtZXJnZWRPdXRwdXRzLFxuICAgICAgICAgICAgICAgICAgaG9zdDogbWVyZ2VkSG9zdCxcbiAgICAgICAgICAgICAgICAgIGV4cG9ydEFzOiBkaXJlY3RpdmUuZXhwb3J0QXMsXG4gICAgICAgICAgICAgICAgICBtb2R1bGVJZDogZGlyZWN0aXZlLm1vZHVsZUlkLFxuICAgICAgICAgICAgICAgICAgcXVlcmllczogbWVyZ2VkUXVlcmllcyxcbiAgICAgICAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogZGlyZWN0aXZlLmNoYW5nZURldGVjdGlvbixcbiAgICAgICAgICAgICAgICAgIHByb3ZpZGVyczogZGlyZWN0aXZlLnByb3ZpZGVycyxcbiAgICAgICAgICAgICAgICAgIHZpZXdQcm92aWRlcnM6IGRpcmVjdGl2ZS52aWV3UHJvdmlkZXJzLFxuICAgICAgICAgICAgICAgICAgZW50cnlDb21wb25lbnRzOiBkaXJlY3RpdmUuZW50cnlDb21wb25lbnRzLFxuICAgICAgICAgICAgICAgICAgdGVtcGxhdGU6IGRpcmVjdGl2ZS50ZW1wbGF0ZSxcbiAgICAgICAgICAgICAgICAgIHRlbXBsYXRlVXJsOiBkaXJlY3RpdmUudGVtcGxhdGVVcmwsXG4gICAgICAgICAgICAgICAgICBzdHlsZXM6IGRpcmVjdGl2ZS5zdHlsZXMsXG4gICAgICAgICAgICAgICAgICBzdHlsZVVybHM6IGRpcmVjdGl2ZS5zdHlsZVVybHMsXG4gICAgICAgICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiBkaXJlY3RpdmUuZW5jYXBzdWxhdGlvbixcbiAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbnM6IGRpcmVjdGl2ZS5hbmltYXRpb25zLFxuICAgICAgICAgICAgICAgICAgaW50ZXJwb2xhdGlvbjogZGlyZWN0aXZlLmludGVycG9sYXRpb25cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gbmV3IF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlKHtcbiAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiBkaXJlY3RpdmUuc2VsZWN0b3IsXG4gICAgICAgICAgICAgICAgICBpbnB1dHM6IG1lcmdlZElucHV0cyxcbiAgICAgICAgICAgICAgICAgIG91dHB1dHM6IG1lcmdlZE91dHB1dHMsXG4gICAgICAgICAgICAgICAgICBob3N0OiBtZXJnZWRIb3N0LFxuICAgICAgICAgICAgICAgICAgZXhwb3J0QXM6IGRpcmVjdGl2ZS5leHBvcnRBcyxcbiAgICAgICAgICAgICAgICAgIHF1ZXJpZXM6IG1lcmdlZFF1ZXJpZXMsXG4gICAgICAgICAgICAgICAgICBwcm92aWRlcnM6IGRpcmVjdGl2ZS5wcm92aWRlcnNcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIERpcmVjdGl2ZVJlc29sdmVyLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdGFibGUgfSxcbiAgICAgIF07XG4gICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgIERpcmVjdGl2ZVJlc29sdmVyLmN0b3JQYXJhbWV0ZXJzID0gW1xuICAgICAgICAgIHsgdHlwZTogUmVmbGVjdG9yUmVhZGVyLCB9LFxuICAgICAgXTtcbiAgICAgIHJldHVybiBEaXJlY3RpdmVSZXNvbHZlcjtcbiAgfSgpKTtcbiAgZnVuY3Rpb24gaXNEaXJlY3RpdmVNZXRhZGF0YSh0eXBlKSB7XG4gICAgICByZXR1cm4gdHlwZSBpbnN0YW5jZW9mIF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFzTGlmZWN5Y2xlSG9vayhob29rLCB0b2tlbikge1xuICAgICAgcmV0dXJuIHJlZmxlY3Rvci5oYXNMaWZlY3ljbGVIb29rKHRva2VuLCBnZXRIb29rTmFtZShob29rKSk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0SG9va05hbWUoaG9vaykge1xuICAgICAgc3dpdGNoIChob29rKSB7XG4gICAgICAgICAgY2FzZSBMaWZlY3ljbGVIb29rcy5PbkluaXQ6XG4gICAgICAgICAgICAgIHJldHVybiAnbmdPbkluaXQnO1xuICAgICAgICAgIGNhc2UgTGlmZWN5Y2xlSG9va3MuT25EZXN0cm95OlxuICAgICAgICAgICAgICByZXR1cm4gJ25nT25EZXN0cm95JztcbiAgICAgICAgICBjYXNlIExpZmVjeWNsZUhvb2tzLkRvQ2hlY2s6XG4gICAgICAgICAgICAgIHJldHVybiAnbmdEb0NoZWNrJztcbiAgICAgICAgICBjYXNlIExpZmVjeWNsZUhvb2tzLk9uQ2hhbmdlczpcbiAgICAgICAgICAgICAgcmV0dXJuICduZ09uQ2hhbmdlcyc7XG4gICAgICAgICAgY2FzZSBMaWZlY3ljbGVIb29rcy5BZnRlckNvbnRlbnRJbml0OlxuICAgICAgICAgICAgICByZXR1cm4gJ25nQWZ0ZXJDb250ZW50SW5pdCc7XG4gICAgICAgICAgY2FzZSBMaWZlY3ljbGVIb29rcy5BZnRlckNvbnRlbnRDaGVja2VkOlxuICAgICAgICAgICAgICByZXR1cm4gJ25nQWZ0ZXJDb250ZW50Q2hlY2tlZCc7XG4gICAgICAgICAgY2FzZSBMaWZlY3ljbGVIb29rcy5BZnRlclZpZXdJbml0OlxuICAgICAgICAgICAgICByZXR1cm4gJ25nQWZ0ZXJWaWV3SW5pdCc7XG4gICAgICAgICAgY2FzZSBMaWZlY3ljbGVIb29rcy5BZnRlclZpZXdDaGVja2VkOlxuICAgICAgICAgICAgICByZXR1cm4gJ25nQWZ0ZXJWaWV3Q2hlY2tlZCc7XG4gICAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBfaXNOZ01vZHVsZU1ldGFkYXRhKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIF9hbmd1bGFyX2NvcmUuTmdNb2R1bGU7XG4gIH1cbiAgLyoqXG4gICAqIFJlc29sdmVzIHR5cGVzIHRvIHtAbGluayBOZ01vZHVsZX0uXG4gICAqL1xuICB2YXIgTmdNb2R1bGVSZXNvbHZlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBOZ01vZHVsZVJlc29sdmVyKF9yZWZsZWN0b3IpIHtcbiAgICAgICAgICBpZiAoX3JlZmxlY3RvciA9PT0gdm9pZCAwKSB7IF9yZWZsZWN0b3IgPSByZWZsZWN0b3I7IH1cbiAgICAgICAgICB0aGlzLl9yZWZsZWN0b3IgPSBfcmVmbGVjdG9yO1xuICAgICAgfVxuICAgICAgTmdNb2R1bGVSZXNvbHZlci5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uICh0eXBlLCB0aHJvd0lmTm90Rm91bmQpIHtcbiAgICAgICAgICBpZiAodGhyb3dJZk5vdEZvdW5kID09PSB2b2lkIDApIHsgdGhyb3dJZk5vdEZvdW5kID0gdHJ1ZTsgfVxuICAgICAgICAgIHZhciBuZ01vZHVsZU1ldGEgPSB0aGlzLl9yZWZsZWN0b3IuYW5ub3RhdGlvbnModHlwZSkuZmluZChfaXNOZ01vZHVsZU1ldGFkYXRhKTtcbiAgICAgICAgICBpZiAoaXNQcmVzZW50KG5nTW9kdWxlTWV0YSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG5nTW9kdWxlTWV0YTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGlmICh0aHJvd0lmTm90Rm91bmQpIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIE5nTW9kdWxlIG1ldGFkYXRhIGZvdW5kIGZvciAnXCIgKyBzdHJpbmdpZnkodHlwZSkgKyBcIicuXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICBOZ01vZHVsZVJlc29sdmVyLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdGFibGUgfSxcbiAgICAgIF07XG4gICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgIE5nTW9kdWxlUmVzb2x2ZXIuY3RvclBhcmFtZXRlcnMgPSBbXG4gICAgICAgICAgeyB0eXBlOiBSZWZsZWN0b3JSZWFkZXIsIH0sXG4gICAgICBdO1xuICAgICAgcmV0dXJuIE5nTW9kdWxlUmVzb2x2ZXI7XG4gIH0oKSk7XG5cbiAgZnVuY3Rpb24gX2lzUGlwZU1ldGFkYXRhKHR5cGUpIHtcbiAgICAgIHJldHVybiB0eXBlIGluc3RhbmNlb2YgX2FuZ3VsYXJfY29yZS5QaXBlO1xuICB9XG4gIC8qKlxuICAgKiBSZXNvbHZlIGEgYFR5cGVgIGZvciB7QGxpbmsgUGlwZX0uXG4gICAqXG4gICAqIFRoaXMgaW50ZXJmYWNlIGNhbiBiZSBvdmVycmlkZGVuIGJ5IHRoZSBhcHBsaWNhdGlvbiBkZXZlbG9wZXIgdG8gY3JlYXRlIGN1c3RvbSBiZWhhdmlvci5cbiAgICpcbiAgICogU2VlIHtAbGluayBDb21waWxlcn1cbiAgICovXG4gIHZhciBQaXBlUmVzb2x2ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gUGlwZVJlc29sdmVyKF9yZWZsZWN0b3IpIHtcbiAgICAgICAgICBpZiAoX3JlZmxlY3RvciA9PT0gdm9pZCAwKSB7IF9yZWZsZWN0b3IgPSByZWZsZWN0b3I7IH1cbiAgICAgICAgICB0aGlzLl9yZWZsZWN0b3IgPSBfcmVmbGVjdG9yO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBSZXR1cm4ge0BsaW5rIFBpcGV9IGZvciBhIGdpdmVuIGBUeXBlYC5cbiAgICAgICAqL1xuICAgICAgUGlwZVJlc29sdmVyLnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24gKHR5cGUsIHRocm93SWZOb3RGb3VuZCkge1xuICAgICAgICAgIGlmICh0aHJvd0lmTm90Rm91bmQgPT09IHZvaWQgMCkgeyB0aHJvd0lmTm90Rm91bmQgPSB0cnVlOyB9XG4gICAgICAgICAgdmFyIG1ldGFzID0gdGhpcy5fcmVmbGVjdG9yLmFubm90YXRpb25zKF9hbmd1bGFyX2NvcmUucmVzb2x2ZUZvcndhcmRSZWYodHlwZSkpO1xuICAgICAgICAgIGlmIChpc1ByZXNlbnQobWV0YXMpKSB7XG4gICAgICAgICAgICAgIHZhciBhbm5vdGF0aW9uID0gbWV0YXMuZmluZChfaXNQaXBlTWV0YWRhdGEpO1xuICAgICAgICAgICAgICBpZiAoaXNQcmVzZW50KGFubm90YXRpb24pKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gYW5ub3RhdGlvbjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhyb3dJZk5vdEZvdW5kKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIFBpcGUgZGVjb3JhdG9yIGZvdW5kIG9uIFwiICsgc3RyaW5naWZ5KHR5cGUpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgUGlwZVJlc29sdmVyLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdGFibGUgfSxcbiAgICAgIF07XG4gICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgIFBpcGVSZXNvbHZlci5jdG9yUGFyYW1ldGVycyA9IFtcbiAgICAgICAgICB7IHR5cGU6IFJlZmxlY3RvclJlYWRlciwgfSxcbiAgICAgIF07XG4gICAgICByZXR1cm4gUGlwZVJlc29sdmVyO1xuICB9KCkpO1xuXG4gIC8qKlxuICAgKiBAbGljZW5zZVxuICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICpcbiAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgKi9cbiAgdmFyIF9fZXh0ZW5kcyQxNyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgfTtcbiAgdmFyIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyKF9uZ01vZHVsZVJlc29sdmVyLCBfZGlyZWN0aXZlUmVzb2x2ZXIsIF9waXBlUmVzb2x2ZXIsIF9zY2hlbWFSZWdpc3RyeSwgX3JlZmxlY3Rvcikge1xuICAgICAgICAgIGlmIChfcmVmbGVjdG9yID09PSB2b2lkIDApIHsgX3JlZmxlY3RvciA9IHJlZmxlY3RvcjsgfVxuICAgICAgICAgIHRoaXMuX25nTW9kdWxlUmVzb2x2ZXIgPSBfbmdNb2R1bGVSZXNvbHZlcjtcbiAgICAgICAgICB0aGlzLl9kaXJlY3RpdmVSZXNvbHZlciA9IF9kaXJlY3RpdmVSZXNvbHZlcjtcbiAgICAgICAgICB0aGlzLl9waXBlUmVzb2x2ZXIgPSBfcGlwZVJlc29sdmVyO1xuICAgICAgICAgIHRoaXMuX3NjaGVtYVJlZ2lzdHJ5ID0gX3NjaGVtYVJlZ2lzdHJ5O1xuICAgICAgICAgIHRoaXMuX3JlZmxlY3RvciA9IF9yZWZsZWN0b3I7XG4gICAgICAgICAgdGhpcy5fZGlyZWN0aXZlQ2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgdGhpcy5fcGlwZUNhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgICAgIHRoaXMuX25nTW9kdWxlQ2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgdGhpcy5fbmdNb2R1bGVPZlR5cGVzID0gbmV3IE1hcCgpO1xuICAgICAgICAgIHRoaXMuX2Fub255bW91c1R5cGVzID0gbmV3IE1hcCgpO1xuICAgICAgICAgIHRoaXMuX2Fub255bW91c1R5cGVJbmRleCA9IDA7XG4gICAgICB9XG4gICAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuc2FuaXRpemVUb2tlbk5hbWUgPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgICAgICB2YXIgaWRlbnRpZmllciA9IHN0cmluZ2lmeSh0b2tlbik7XG4gICAgICAgICAgaWYgKGlkZW50aWZpZXIuaW5kZXhPZignKCcpID49IDApIHtcbiAgICAgICAgICAgICAgLy8gY2FzZTogYW5vbnltb3VzIGZ1bmN0aW9ucyFcbiAgICAgICAgICAgICAgdmFyIGZvdW5kID0gdGhpcy5fYW5vbnltb3VzVHlwZXMuZ2V0KHRva2VuKTtcbiAgICAgICAgICAgICAgaWYgKCFmb3VuZCkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5fYW5vbnltb3VzVHlwZXMuc2V0KHRva2VuLCB0aGlzLl9hbm9ueW1vdXNUeXBlSW5kZXgrKyk7XG4gICAgICAgICAgICAgICAgICBmb3VuZCA9IHRoaXMuX2Fub255bW91c1R5cGVzLmdldCh0b2tlbik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWRlbnRpZmllciA9IFwiYW5vbnltb3VzX3Rva2VuX1wiICsgZm91bmQgKyBcIl9cIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHNhbml0aXplSWRlbnRpZmllcihpZGVudGlmaWVyKTtcbiAgICAgIH07XG4gICAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuY2xlYXJDYWNoZUZvciA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgICAgdGhpcy5fZGlyZWN0aXZlQ2FjaGUuZGVsZXRlKHR5cGUpO1xuICAgICAgICAgIHRoaXMuX3BpcGVDYWNoZS5kZWxldGUodHlwZSk7XG4gICAgICAgICAgdGhpcy5fbmdNb2R1bGVPZlR5cGVzLmRlbGV0ZSh0eXBlKTtcbiAgICAgICAgICAvLyBDbGVhciBhbGwgb2YgdGhlIE5nTW9kdWxlIGFzIHRoZXkgY29udGFpbiB0cmFuc2l0aXZlIGluZm9ybWF0aW9uIVxuICAgICAgICAgIHRoaXMuX25nTW9kdWxlQ2FjaGUuY2xlYXIoKTtcbiAgICAgIH07XG4gICAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuY2xlYXJDYWNoZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGlzLl9kaXJlY3RpdmVDYWNoZS5jbGVhcigpO1xuICAgICAgICAgIHRoaXMuX3BpcGVDYWNoZS5jbGVhcigpO1xuICAgICAgICAgIHRoaXMuX25nTW9kdWxlQ2FjaGUuY2xlYXIoKTtcbiAgICAgICAgICB0aGlzLl9uZ01vZHVsZU9mVHlwZXMuY2xlYXIoKTtcbiAgICAgIH07XG4gICAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuZ2V0QW5pbWF0aW9uRW50cnlNZXRhZGF0YSA9IGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgdmFyIGRlZnMgPSBlbnRyeS5kZWZpbml0aW9ucy5tYXAoZnVuY3Rpb24gKGRlZikgeyByZXR1cm4gX3RoaXMuZ2V0QW5pbWF0aW9uU3RhdGVNZXRhZGF0YShkZWYpOyB9KTtcbiAgICAgICAgICByZXR1cm4gbmV3IENvbXBpbGVBbmltYXRpb25FbnRyeU1ldGFkYXRhKGVudHJ5Lm5hbWUsIGRlZnMpO1xuICAgICAgfTtcbiAgICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5nZXRBbmltYXRpb25TdGF0ZU1ldGFkYXRhID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgX2FuZ3VsYXJfY29yZS5BbmltYXRpb25TdGF0ZURlY2xhcmF0aW9uTWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgdmFyIHN0eWxlcyA9IHRoaXMuZ2V0QW5pbWF0aW9uU3R5bGVNZXRhZGF0YSh2YWx1ZS5zdHlsZXMpO1xuICAgICAgICAgICAgICByZXR1cm4gbmV3IENvbXBpbGVBbmltYXRpb25TdGF0ZURlY2xhcmF0aW9uTWV0YWRhdGEodmFsdWUuc3RhdGVOYW1lRXhwciwgc3R5bGVzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgX2FuZ3VsYXJfY29yZS5BbmltYXRpb25TdGF0ZVRyYW5zaXRpb25NZXRhZGF0YSkge1xuICAgICAgICAgICAgICByZXR1cm4gbmV3IENvbXBpbGVBbmltYXRpb25TdGF0ZVRyYW5zaXRpb25NZXRhZGF0YSh2YWx1ZS5zdGF0ZUNoYW5nZUV4cHIsIHRoaXMuZ2V0QW5pbWF0aW9uTWV0YWRhdGEodmFsdWUuc3RlcHMpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLmdldEFuaW1hdGlvblN0eWxlTWV0YWRhdGEgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IENvbXBpbGVBbmltYXRpb25TdHlsZU1ldGFkYXRhKHZhbHVlLm9mZnNldCwgdmFsdWUuc3R5bGVzKTtcbiAgICAgIH07XG4gICAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuZ2V0QW5pbWF0aW9uTWV0YWRhdGEgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIF9hbmd1bGFyX2NvcmUuQW5pbWF0aW9uU3R5bGVNZXRhZGF0YSkge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRBbmltYXRpb25TdHlsZU1ldGFkYXRhKHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgX2FuZ3VsYXJfY29yZS5BbmltYXRpb25LZXlmcmFtZXNTZXF1ZW5jZU1ldGFkYXRhKSB7XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgQ29tcGlsZUFuaW1hdGlvbktleWZyYW1lc1NlcXVlbmNlTWV0YWRhdGEodmFsdWUuc3RlcHMubWFwKGZ1bmN0aW9uIChlbnRyeSkgeyByZXR1cm4gX3RoaXMuZ2V0QW5pbWF0aW9uU3R5bGVNZXRhZGF0YShlbnRyeSk7IH0pKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgX2FuZ3VsYXJfY29yZS5BbmltYXRpb25BbmltYXRlTWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgdmFyIGFuaW1hdGVEYXRhID0gdGhpc1xuICAgICAgICAgICAgICAgICAgLmdldEFuaW1hdGlvbk1ldGFkYXRhKHZhbHVlLnN0eWxlcyk7XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgQ29tcGlsZUFuaW1hdGlvbkFuaW1hdGVNZXRhZGF0YSh2YWx1ZS50aW1pbmdzLCBhbmltYXRlRGF0YSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIF9hbmd1bGFyX2NvcmUuQW5pbWF0aW9uV2l0aFN0ZXBzTWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgdmFyIHN0ZXBzID0gdmFsdWUuc3RlcHMubWFwKGZ1bmN0aW9uIChzdGVwKSB7IHJldHVybiBfdGhpcy5nZXRBbmltYXRpb25NZXRhZGF0YShzdGVwKTsgfSk7XG4gICAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIF9hbmd1bGFyX2NvcmUuQW5pbWF0aW9uR3JvdXBNZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb21waWxlQW5pbWF0aW9uR3JvdXBNZXRhZGF0YShzdGVwcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb21waWxlQW5pbWF0aW9uU2VxdWVuY2VNZXRhZGF0YShzdGVwcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcbiAgICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5nZXREaXJlY3RpdmVNZXRhZGF0YSA9IGZ1bmN0aW9uIChkaXJlY3RpdmVUeXBlLCB0aHJvd0lmTm90Rm91bmQpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIGlmICh0aHJvd0lmTm90Rm91bmQgPT09IHZvaWQgMCkgeyB0aHJvd0lmTm90Rm91bmQgPSB0cnVlOyB9XG4gICAgICAgICAgZGlyZWN0aXZlVHlwZSA9IF9hbmd1bGFyX2NvcmUucmVzb2x2ZUZvcndhcmRSZWYoZGlyZWN0aXZlVHlwZSk7XG4gICAgICAgICAgdmFyIG1ldGEgPSB0aGlzLl9kaXJlY3RpdmVDYWNoZS5nZXQoZGlyZWN0aXZlVHlwZSk7XG4gICAgICAgICAgaWYgKCFtZXRhKSB7XG4gICAgICAgICAgICAgIHZhciBkaXJNZXRhID0gdGhpcy5fZGlyZWN0aXZlUmVzb2x2ZXIucmVzb2x2ZShkaXJlY3RpdmVUeXBlLCB0aHJvd0lmTm90Rm91bmQpO1xuICAgICAgICAgICAgICBpZiAoIWRpck1ldGEpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhciB0ZW1wbGF0ZU1ldGEgPSBudWxsO1xuICAgICAgICAgICAgICB2YXIgY2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kgPSBudWxsO1xuICAgICAgICAgICAgICB2YXIgdmlld1Byb3ZpZGVycyA9IFtdO1xuICAgICAgICAgICAgICB2YXIgbW9kdWxlVXJsID0gc3RhdGljVHlwZU1vZHVsZVVybChkaXJlY3RpdmVUeXBlKTtcbiAgICAgICAgICAgICAgdmFyIGVudHJ5Q29tcG9uZW50TWV0YWRhdGEgPSBbXTtcbiAgICAgICAgICAgICAgdmFyIHNlbGVjdG9yID0gZGlyTWV0YS5zZWxlY3RvcjtcbiAgICAgICAgICAgICAgaWYgKGRpck1ldGEgaW5zdGFuY2VvZiBfYW5ndWxhcl9jb3JlLkNvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgICAgLy8gQ29tcG9uZW50XG4gICAgICAgICAgICAgICAgICBhc3NlcnRBcnJheU9mU3RyaW5ncygnc3R5bGVzJywgZGlyTWV0YS5zdHlsZXMpO1xuICAgICAgICAgICAgICAgICAgYXNzZXJ0QXJyYXlPZlN0cmluZ3MoJ3N0eWxlVXJscycsIGRpck1ldGEuc3R5bGVVcmxzKTtcbiAgICAgICAgICAgICAgICAgIGFzc2VydEludGVycG9sYXRpb25TeW1ib2xzKCdpbnRlcnBvbGF0aW9uJywgZGlyTWV0YS5pbnRlcnBvbGF0aW9uKTtcbiAgICAgICAgICAgICAgICAgIHZhciBhbmltYXRpb25zID0gZGlyTWV0YS5hbmltYXRpb25zID9cbiAgICAgICAgICAgICAgICAgICAgICBkaXJNZXRhLmFuaW1hdGlvbnMubWFwKGZ1bmN0aW9uIChlKSB7IHJldHVybiBfdGhpcy5nZXRBbmltYXRpb25FbnRyeU1ldGFkYXRhKGUpOyB9KSA6XG4gICAgICAgICAgICAgICAgICAgICAgbnVsbDtcbiAgICAgICAgICAgICAgICAgIHRlbXBsYXRlTWV0YSA9IG5ldyBDb21waWxlVGVtcGxhdGVNZXRhZGF0YSh7XG4gICAgICAgICAgICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogZGlyTWV0YS5lbmNhcHN1bGF0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBkaXJNZXRhLnRlbXBsYXRlLFxuICAgICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlVXJsOiBkaXJNZXRhLnRlbXBsYXRlVXJsLFxuICAgICAgICAgICAgICAgICAgICAgIHN0eWxlczogZGlyTWV0YS5zdHlsZXMsXG4gICAgICAgICAgICAgICAgICAgICAgc3R5bGVVcmxzOiBkaXJNZXRhLnN0eWxlVXJscyxcbiAgICAgICAgICAgICAgICAgICAgICBhbmltYXRpb25zOiBhbmltYXRpb25zLFxuICAgICAgICAgICAgICAgICAgICAgIGludGVycG9sYXRpb246IGRpck1ldGEuaW50ZXJwb2xhdGlvblxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSA9IGRpck1ldGEuY2hhbmdlRGV0ZWN0aW9uO1xuICAgICAgICAgICAgICAgICAgaWYgKGRpck1ldGEudmlld1Byb3ZpZGVycykge1xuICAgICAgICAgICAgICAgICAgICAgIHZpZXdQcm92aWRlcnMgPSB0aGlzLmdldFByb3ZpZGVyc01ldGFkYXRhKGRpck1ldGEudmlld1Byb3ZpZGVycywgZW50cnlDb21wb25lbnRNZXRhZGF0YSwgXCJ2aWV3UHJvdmlkZXJzIGZvciBcXFwiXCIgKyBzdHJpbmdpZnkoZGlyZWN0aXZlVHlwZSkgKyBcIlxcXCJcIik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBtb2R1bGVVcmwgPSBjb21wb25lbnRNb2R1bGVVcmwodGhpcy5fcmVmbGVjdG9yLCBkaXJlY3RpdmVUeXBlLCBkaXJNZXRhKTtcbiAgICAgICAgICAgICAgICAgIGlmIChkaXJNZXRhLmVudHJ5Q29tcG9uZW50cykge1xuICAgICAgICAgICAgICAgICAgICAgIGVudHJ5Q29tcG9uZW50TWV0YWRhdGEgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICBmbGF0dGVuQXJyYXkoZGlyTWV0YS5lbnRyeUNvbXBvbmVudHMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uICh0eXBlKSB7IHJldHVybiBfdGhpcy5nZXRUeXBlTWV0YWRhdGEodHlwZSwgc3RhdGljVHlwZU1vZHVsZVVybCh0eXBlKSk7IH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY29uY2F0KGVudHJ5Q29tcG9uZW50TWV0YWRhdGEpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKCFzZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yID0gdGhpcy5fc2NoZW1hUmVnaXN0cnkuZ2V0RGVmYXVsdENvbXBvbmVudEVsZW1lbnROYW1lKCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAvLyBEaXJlY3RpdmVcbiAgICAgICAgICAgICAgICAgIGlmICghc2VsZWN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEaXJlY3RpdmUgXCIgKyBzdHJpbmdpZnkoZGlyZWN0aXZlVHlwZSkgKyBcIiBoYXMgbm8gc2VsZWN0b3IsIHBsZWFzZSBhZGQgaXQhXCIpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhciBwcm92aWRlcnMgPSBbXTtcbiAgICAgICAgICAgICAgaWYgKGlzUHJlc2VudChkaXJNZXRhLnByb3ZpZGVycykpIHtcbiAgICAgICAgICAgICAgICAgIHByb3ZpZGVycyA9IHRoaXMuZ2V0UHJvdmlkZXJzTWV0YWRhdGEoZGlyTWV0YS5wcm92aWRlcnMsIGVudHJ5Q29tcG9uZW50TWV0YWRhdGEsIFwicHJvdmlkZXJzIGZvciBcXFwiXCIgKyBzdHJpbmdpZnkoZGlyZWN0aXZlVHlwZSkgKyBcIlxcXCJcIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFyIHF1ZXJpZXMgPSBbXTtcbiAgICAgICAgICAgICAgdmFyIHZpZXdRdWVyaWVzID0gW107XG4gICAgICAgICAgICAgIGlmIChpc1ByZXNlbnQoZGlyTWV0YS5xdWVyaWVzKSkge1xuICAgICAgICAgICAgICAgICAgcXVlcmllcyA9IHRoaXMuZ2V0UXVlcmllc01ldGFkYXRhKGRpck1ldGEucXVlcmllcywgZmFsc2UsIGRpcmVjdGl2ZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgdmlld1F1ZXJpZXMgPSB0aGlzLmdldFF1ZXJpZXNNZXRhZGF0YShkaXJNZXRhLnF1ZXJpZXMsIHRydWUsIGRpcmVjdGl2ZVR5cGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG1ldGEgPSBDb21waWxlRGlyZWN0aXZlTWV0YWRhdGEuY3JlYXRlKHtcbiAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiBzZWxlY3RvcixcbiAgICAgICAgICAgICAgICAgIGV4cG9ydEFzOiBkaXJNZXRhLmV4cG9ydEFzLFxuICAgICAgICAgICAgICAgICAgaXNDb21wb25lbnQ6ICEhdGVtcGxhdGVNZXRhLFxuICAgICAgICAgICAgICAgICAgdHlwZTogdGhpcy5nZXRUeXBlTWV0YWRhdGEoZGlyZWN0aXZlVHlwZSwgbW9kdWxlVXJsKSxcbiAgICAgICAgICAgICAgICAgIHRlbXBsYXRlOiB0ZW1wbGF0ZU1ldGEsXG4gICAgICAgICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IGNoYW5nZURldGVjdGlvblN0cmF0ZWd5LFxuICAgICAgICAgICAgICAgICAgaW5wdXRzOiBkaXJNZXRhLmlucHV0cyxcbiAgICAgICAgICAgICAgICAgIG91dHB1dHM6IGRpck1ldGEub3V0cHV0cyxcbiAgICAgICAgICAgICAgICAgIGhvc3Q6IGRpck1ldGEuaG9zdCxcbiAgICAgICAgICAgICAgICAgIHByb3ZpZGVyczogcHJvdmlkZXJzLFxuICAgICAgICAgICAgICAgICAgdmlld1Byb3ZpZGVyczogdmlld1Byb3ZpZGVycyxcbiAgICAgICAgICAgICAgICAgIHF1ZXJpZXM6IHF1ZXJpZXMsXG4gICAgICAgICAgICAgICAgICB2aWV3UXVlcmllczogdmlld1F1ZXJpZXMsXG4gICAgICAgICAgICAgICAgICBlbnRyeUNvbXBvbmVudHM6IGVudHJ5Q29tcG9uZW50TWV0YWRhdGFcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHRoaXMuX2RpcmVjdGl2ZUNhY2hlLnNldChkaXJlY3RpdmVUeXBlLCBtZXRhKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG1ldGE7XG4gICAgICB9O1xuICAgICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLmdldE5nTW9kdWxlTWV0YWRhdGEgPSBmdW5jdGlvbiAobW9kdWxlVHlwZSwgdGhyb3dJZk5vdEZvdW5kKSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICBpZiAodGhyb3dJZk5vdEZvdW5kID09PSB2b2lkIDApIHsgdGhyb3dJZk5vdEZvdW5kID0gdHJ1ZTsgfVxuICAgICAgICAgIG1vZHVsZVR5cGUgPSBfYW5ndWxhcl9jb3JlLnJlc29sdmVGb3J3YXJkUmVmKG1vZHVsZVR5cGUpO1xuICAgICAgICAgIHZhciBjb21waWxlTWV0YSA9IHRoaXMuX25nTW9kdWxlQ2FjaGUuZ2V0KG1vZHVsZVR5cGUpO1xuICAgICAgICAgIGlmICghY29tcGlsZU1ldGEpIHtcbiAgICAgICAgICAgICAgdmFyIG1ldGEgPSB0aGlzLl9uZ01vZHVsZVJlc29sdmVyLnJlc29sdmUobW9kdWxlVHlwZSwgdGhyb3dJZk5vdEZvdW5kKTtcbiAgICAgICAgICAgICAgaWYgKCFtZXRhKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2YXIgZGVjbGFyZWREaXJlY3RpdmVzXzEgPSBbXTtcbiAgICAgICAgICAgICAgdmFyIGV4cG9ydGVkRGlyZWN0aXZlc18xID0gW107XG4gICAgICAgICAgICAgIHZhciBkZWNsYXJlZFBpcGVzXzEgPSBbXTtcbiAgICAgICAgICAgICAgdmFyIGV4cG9ydGVkUGlwZXNfMSA9IFtdO1xuICAgICAgICAgICAgICB2YXIgaW1wb3J0ZWRNb2R1bGVzXzEgPSBbXTtcbiAgICAgICAgICAgICAgdmFyIGV4cG9ydGVkTW9kdWxlc18xID0gW107XG4gICAgICAgICAgICAgIHZhciBwcm92aWRlcnNfMSA9IFtdO1xuICAgICAgICAgICAgICB2YXIgZW50cnlDb21wb25lbnRzXzEgPSBbXTtcbiAgICAgICAgICAgICAgdmFyIGJvb3RzdHJhcENvbXBvbmVudHMgPSBbXTtcbiAgICAgICAgICAgICAgdmFyIHNjaGVtYXMgPSBbXTtcbiAgICAgICAgICAgICAgaWYgKG1ldGEuaW1wb3J0cykge1xuICAgICAgICAgICAgICAgICAgZmxhdHRlbkFycmF5KG1ldGEuaW1wb3J0cykuZm9yRWFjaChmdW5jdGlvbiAoaW1wb3J0ZWRUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIGltcG9ydGVkTW9kdWxlVHlwZTtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNWYWxpZFR5cGUoaW1wb3J0ZWRUeXBlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpbXBvcnRlZE1vZHVsZVR5cGUgPSBpbXBvcnRlZFR5cGU7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGltcG9ydGVkVHlwZSAmJiBpbXBvcnRlZFR5cGUubmdNb2R1bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1vZHVsZVdpdGhQcm92aWRlcnMgPSBpbXBvcnRlZFR5cGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGltcG9ydGVkTW9kdWxlVHlwZSA9IG1vZHVsZVdpdGhQcm92aWRlcnMubmdNb2R1bGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtb2R1bGVXaXRoUHJvdmlkZXJzLnByb3ZpZGVycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJzXzEucHVzaC5hcHBseShwcm92aWRlcnNfMSwgX3RoaXMuZ2V0UHJvdmlkZXJzTWV0YWRhdGEobW9kdWxlV2l0aFByb3ZpZGVycy5wcm92aWRlcnMsIGVudHJ5Q29tcG9uZW50c18xLCBcInByb3ZpZGVyIGZvciB0aGUgTmdNb2R1bGUgJ1wiICsgc3RyaW5naWZ5KGltcG9ydGVkTW9kdWxlVHlwZSkgKyBcIidcIikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGlmIChpbXBvcnRlZE1vZHVsZVR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGltcG9ydGVkTWV0YSA9IF90aGlzLmdldE5nTW9kdWxlTWV0YWRhdGEoaW1wb3J0ZWRNb2R1bGVUeXBlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbXBvcnRlZE1ldGEgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgXCIgKyBfdGhpcy5fZ2V0VHlwZURlc2NyaXB0b3IoaW1wb3J0ZWRUeXBlKSArIFwiICdcIiArIHN0cmluZ2lmeShpbXBvcnRlZFR5cGUpICsgXCInIGltcG9ydGVkIGJ5IHRoZSBtb2R1bGUgJ1wiICsgc3RyaW5naWZ5KG1vZHVsZVR5cGUpICsgXCInXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGltcG9ydGVkTW9kdWxlc18xLnB1c2goaW1wb3J0ZWRNZXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgdmFsdWUgJ1wiICsgc3RyaW5naWZ5KGltcG9ydGVkVHlwZSkgKyBcIicgaW1wb3J0ZWQgYnkgdGhlIG1vZHVsZSAnXCIgKyBzdHJpbmdpZnkobW9kdWxlVHlwZSkgKyBcIidcIik7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKG1ldGEuZXhwb3J0cykge1xuICAgICAgICAgICAgICAgICAgZmxhdHRlbkFycmF5KG1ldGEuZXhwb3J0cykuZm9yRWFjaChmdW5jdGlvbiAoZXhwb3J0ZWRUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1ZhbGlkVHlwZShleHBvcnRlZFR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgdmFsdWUgJ1wiICsgc3RyaW5naWZ5KGV4cG9ydGVkVHlwZSkgKyBcIicgZXhwb3J0ZWQgYnkgdGhlIG1vZHVsZSAnXCIgKyBzdHJpbmdpZnkobW9kdWxlVHlwZSkgKyBcIidcIik7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIHZhciBleHBvcnRlZERpck1ldGE7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIGV4cG9ydGVkUGlwZU1ldGE7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIGV4cG9ydGVkTW9kdWxlTWV0YTtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoZXhwb3J0ZWREaXJNZXRhID0gX3RoaXMuZ2V0RGlyZWN0aXZlTWV0YWRhdGEoZXhwb3J0ZWRUeXBlLCBmYWxzZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwb3J0ZWREaXJlY3RpdmVzXzEucHVzaChleHBvcnRlZERpck1ldGEpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChleHBvcnRlZFBpcGVNZXRhID0gX3RoaXMuZ2V0UGlwZU1ldGFkYXRhKGV4cG9ydGVkVHlwZSwgZmFsc2UpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGV4cG9ydGVkUGlwZXNfMS5wdXNoKGV4cG9ydGVkUGlwZU1ldGEpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChleHBvcnRlZE1vZHVsZU1ldGEgPSBfdGhpcy5nZXROZ01vZHVsZU1ldGFkYXRhKGV4cG9ydGVkVHlwZSwgZmFsc2UpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGV4cG9ydGVkTW9kdWxlc18xLnB1c2goZXhwb3J0ZWRNb2R1bGVNZXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgXCIgKyBfdGhpcy5fZ2V0VHlwZURlc2NyaXB0b3IoZXhwb3J0ZWRUeXBlKSArIFwiICdcIiArIHN0cmluZ2lmeShleHBvcnRlZFR5cGUpICsgXCInIGV4cG9ydGVkIGJ5IHRoZSBtb2R1bGUgJ1wiICsgc3RyaW5naWZ5KG1vZHVsZVR5cGUpICsgXCInXCIpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIE5vdGU6IFRoaXMgd2lsbCBiZSBtb2RpZmllZCBsYXRlciwgc28gd2UgcmVseSBvblxuICAgICAgICAgICAgICAvLyBnZXR0aW5nIGEgbmV3IGluc3RhbmNlIGV2ZXJ5IHRpbWUhXG4gICAgICAgICAgICAgIHZhciB0cmFuc2l0aXZlTW9kdWxlXzEgPSB0aGlzLl9nZXRUcmFuc2l0aXZlTmdNb2R1bGVNZXRhZGF0YShpbXBvcnRlZE1vZHVsZXNfMSwgZXhwb3J0ZWRNb2R1bGVzXzEpO1xuICAgICAgICAgICAgICBpZiAobWV0YS5kZWNsYXJhdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgIGZsYXR0ZW5BcnJheShtZXRhLmRlY2xhcmF0aW9ucykuZm9yRWFjaChmdW5jdGlvbiAoZGVjbGFyZWRUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1ZhbGlkVHlwZShkZWNsYXJlZFR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgdmFsdWUgJ1wiICsgc3RyaW5naWZ5KGRlY2xhcmVkVHlwZSkgKyBcIicgZGVjbGFyZWQgYnkgdGhlIG1vZHVsZSAnXCIgKyBzdHJpbmdpZnkobW9kdWxlVHlwZSkgKyBcIidcIik7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIHZhciBkZWNsYXJlZERpck1ldGE7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIGRlY2xhcmVkUGlwZU1ldGE7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGRlY2xhcmVkRGlyTWV0YSA9IF90aGlzLmdldERpcmVjdGl2ZU1ldGFkYXRhKGRlY2xhcmVkVHlwZSwgZmFsc2UpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9hZGREaXJlY3RpdmVUb01vZHVsZShkZWNsYXJlZERpck1ldGEsIG1vZHVsZVR5cGUsIHRyYW5zaXRpdmVNb2R1bGVfMSwgZGVjbGFyZWREaXJlY3RpdmVzXzEsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChkZWNsYXJlZFBpcGVNZXRhID0gX3RoaXMuZ2V0UGlwZU1ldGFkYXRhKGRlY2xhcmVkVHlwZSwgZmFsc2UpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9hZGRQaXBlVG9Nb2R1bGUoZGVjbGFyZWRQaXBlTWV0YSwgbW9kdWxlVHlwZSwgdHJhbnNpdGl2ZU1vZHVsZV8xLCBkZWNsYXJlZFBpcGVzXzEsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBcIiArIF90aGlzLl9nZXRUeXBlRGVzY3JpcHRvcihkZWNsYXJlZFR5cGUpICsgXCIgJ1wiICsgc3RyaW5naWZ5KGRlY2xhcmVkVHlwZSkgKyBcIicgZGVjbGFyZWQgYnkgdGhlIG1vZHVsZSAnXCIgKyBzdHJpbmdpZnkobW9kdWxlVHlwZSkgKyBcIidcIik7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gVGhlIHByb3ZpZGVycyBvZiB0aGUgbW9kdWxlIGhhdmUgdG8gZ28gbGFzdFxuICAgICAgICAgICAgICAvLyBzbyB0aGF0IHRoZXkgb3ZlcndyaXRlIGFueSBvdGhlciBwcm92aWRlciB3ZSBhbHJlYWR5IGFkZGVkLlxuICAgICAgICAgICAgICBpZiAobWV0YS5wcm92aWRlcnMpIHtcbiAgICAgICAgICAgICAgICAgIHByb3ZpZGVyc18xLnB1c2guYXBwbHkocHJvdmlkZXJzXzEsIHRoaXMuZ2V0UHJvdmlkZXJzTWV0YWRhdGEobWV0YS5wcm92aWRlcnMsIGVudHJ5Q29tcG9uZW50c18xLCBcInByb3ZpZGVyIGZvciB0aGUgTmdNb2R1bGUgJ1wiICsgc3RyaW5naWZ5KG1vZHVsZVR5cGUpICsgXCInXCIpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAobWV0YS5lbnRyeUNvbXBvbmVudHMpIHtcbiAgICAgICAgICAgICAgICAgIGVudHJ5Q29tcG9uZW50c18xLnB1c2guYXBwbHkoZW50cnlDb21wb25lbnRzXzEsIGZsYXR0ZW5BcnJheShtZXRhLmVudHJ5Q29tcG9uZW50cylcbiAgICAgICAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uICh0eXBlKSB7IHJldHVybiBfdGhpcy5nZXRUeXBlTWV0YWRhdGEodHlwZSwgc3RhdGljVHlwZU1vZHVsZVVybCh0eXBlKSk7IH0pKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAobWV0YS5ib290c3RyYXApIHtcbiAgICAgICAgICAgICAgICAgIHZhciB0eXBlTWV0YWRhdGEgPSBmbGF0dGVuQXJyYXkobWV0YS5ib290c3RyYXApLm1hcChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNWYWxpZFR5cGUodHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCB2YWx1ZSAnXCIgKyBzdHJpbmdpZnkodHlwZSkgKyBcIicgdXNlZCBpbiB0aGUgYm9vdHN0cmFwIHByb3BlcnR5IG9mIG1vZHVsZSAnXCIgKyBzdHJpbmdpZnkobW9kdWxlVHlwZSkgKyBcIidcIik7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5nZXRUeXBlTWV0YWRhdGEodHlwZSwgc3RhdGljVHlwZU1vZHVsZVVybCh0eXBlKSk7XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIGJvb3RzdHJhcENvbXBvbmVudHMucHVzaC5hcHBseShib290c3RyYXBDb21wb25lbnRzLCB0eXBlTWV0YWRhdGEpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVudHJ5Q29tcG9uZW50c18xLnB1c2guYXBwbHkoZW50cnlDb21wb25lbnRzXzEsIGJvb3RzdHJhcENvbXBvbmVudHMpO1xuICAgICAgICAgICAgICBpZiAobWV0YS5zY2hlbWFzKSB7XG4gICAgICAgICAgICAgICAgICBzY2hlbWFzLnB1c2guYXBwbHkoc2NoZW1hcywgZmxhdHRlbkFycmF5KG1ldGEuc2NoZW1hcykpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIChfYSA9IHRyYW5zaXRpdmVNb2R1bGVfMS5lbnRyeUNvbXBvbmVudHMpLnB1c2guYXBwbHkoX2EsIGVudHJ5Q29tcG9uZW50c18xKTtcbiAgICAgICAgICAgICAgKF9iID0gdHJhbnNpdGl2ZU1vZHVsZV8xLnByb3ZpZGVycykucHVzaC5hcHBseShfYiwgcHJvdmlkZXJzXzEpO1xuICAgICAgICAgICAgICBjb21waWxlTWV0YSA9IG5ldyBDb21waWxlTmdNb2R1bGVNZXRhZGF0YSh7XG4gICAgICAgICAgICAgICAgICB0eXBlOiB0aGlzLmdldFR5cGVNZXRhZGF0YShtb2R1bGVUeXBlLCBzdGF0aWNUeXBlTW9kdWxlVXJsKG1vZHVsZVR5cGUpKSxcbiAgICAgICAgICAgICAgICAgIHByb3ZpZGVyczogcHJvdmlkZXJzXzEsXG4gICAgICAgICAgICAgICAgICBlbnRyeUNvbXBvbmVudHM6IGVudHJ5Q29tcG9uZW50c18xLFxuICAgICAgICAgICAgICAgICAgYm9vdHN0cmFwQ29tcG9uZW50czogYm9vdHN0cmFwQ29tcG9uZW50cyxcbiAgICAgICAgICAgICAgICAgIHNjaGVtYXM6IHNjaGVtYXMsXG4gICAgICAgICAgICAgICAgICBkZWNsYXJlZERpcmVjdGl2ZXM6IGRlY2xhcmVkRGlyZWN0aXZlc18xLFxuICAgICAgICAgICAgICAgICAgZXhwb3J0ZWREaXJlY3RpdmVzOiBleHBvcnRlZERpcmVjdGl2ZXNfMSxcbiAgICAgICAgICAgICAgICAgIGRlY2xhcmVkUGlwZXM6IGRlY2xhcmVkUGlwZXNfMSxcbiAgICAgICAgICAgICAgICAgIGV4cG9ydGVkUGlwZXM6IGV4cG9ydGVkUGlwZXNfMSxcbiAgICAgICAgICAgICAgICAgIGltcG9ydGVkTW9kdWxlczogaW1wb3J0ZWRNb2R1bGVzXzEsXG4gICAgICAgICAgICAgICAgICBleHBvcnRlZE1vZHVsZXM6IGV4cG9ydGVkTW9kdWxlc18xLFxuICAgICAgICAgICAgICAgICAgdHJhbnNpdGl2ZU1vZHVsZTogdHJhbnNpdGl2ZU1vZHVsZV8xLFxuICAgICAgICAgICAgICAgICAgaWQ6IG1ldGEuaWQsXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB0cmFuc2l0aXZlTW9kdWxlXzEubW9kdWxlcy5wdXNoKGNvbXBpbGVNZXRhKTtcbiAgICAgICAgICAgICAgdGhpcy5fdmVyaWZ5TW9kdWxlKGNvbXBpbGVNZXRhKTtcbiAgICAgICAgICAgICAgdGhpcy5fbmdNb2R1bGVDYWNoZS5zZXQobW9kdWxlVHlwZSwgY29tcGlsZU1ldGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gY29tcGlsZU1ldGE7XG4gICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgIH07XG4gICAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuX3ZlcmlmeU1vZHVsZSA9IGZ1bmN0aW9uIChtb2R1bGVNZXRhKSB7XG4gICAgICAgICAgbW9kdWxlTWV0YS5leHBvcnRlZERpcmVjdGl2ZXMuZm9yRWFjaChmdW5jdGlvbiAoZGlyTWV0YSkge1xuICAgICAgICAgICAgICBpZiAoIW1vZHVsZU1ldGEudHJhbnNpdGl2ZU1vZHVsZS5kaXJlY3RpdmVzU2V0LmhhcyhkaXJNZXRhLnR5cGUucmVmZXJlbmNlKSkge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgZXhwb3J0IGRpcmVjdGl2ZSBcIiArIHN0cmluZ2lmeShkaXJNZXRhLnR5cGUucmVmZXJlbmNlKSArIFwiIGZyb20gXCIgKyBzdHJpbmdpZnkobW9kdWxlTWV0YS50eXBlLnJlZmVyZW5jZSkgKyBcIiBhcyBpdCB3YXMgbmVpdGhlciBkZWNsYXJlZCBub3IgaW1wb3J0ZWQhXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgbW9kdWxlTWV0YS5leHBvcnRlZFBpcGVzLmZvckVhY2goZnVuY3Rpb24gKHBpcGVNZXRhKSB7XG4gICAgICAgICAgICAgIGlmICghbW9kdWxlTWV0YS50cmFuc2l0aXZlTW9kdWxlLnBpcGVzU2V0LmhhcyhwaXBlTWV0YS50eXBlLnJlZmVyZW5jZSkpIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IGV4cG9ydCBwaXBlIFwiICsgc3RyaW5naWZ5KHBpcGVNZXRhLnR5cGUucmVmZXJlbmNlKSArIFwiIGZyb20gXCIgKyBzdHJpbmdpZnkobW9kdWxlTWV0YS50eXBlLnJlZmVyZW5jZSkgKyBcIiBhcyBpdCB3YXMgbmVpdGhlciBkZWNsYXJlZCBub3IgaW1wb3J0ZWQhXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLl9nZXRUeXBlRGVzY3JpcHRvciA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX2RpcmVjdGl2ZVJlc29sdmVyLnJlc29sdmUodHlwZSwgZmFsc2UpKSB7XG4gICAgICAgICAgICAgIHJldHVybiAnZGlyZWN0aXZlJztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRoaXMuX3BpcGVSZXNvbHZlci5yZXNvbHZlKHR5cGUsIGZhbHNlKSkge1xuICAgICAgICAgICAgICByZXR1cm4gJ3BpcGUnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy5fbmdNb2R1bGVSZXNvbHZlci5yZXNvbHZlKHR5cGUsIGZhbHNlKSkge1xuICAgICAgICAgICAgICByZXR1cm4gJ21vZHVsZSc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0eXBlLnByb3ZpZGUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuICdwcm92aWRlcic7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiAndmFsdWUnO1xuICAgICAgfTtcbiAgICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5fYWRkVHlwZVRvTW9kdWxlID0gZnVuY3Rpb24gKHR5cGUsIG1vZHVsZVR5cGUpIHtcbiAgICAgICAgICB2YXIgb2xkTW9kdWxlID0gdGhpcy5fbmdNb2R1bGVPZlR5cGVzLmdldCh0eXBlKTtcbiAgICAgICAgICBpZiAob2xkTW9kdWxlICYmIG9sZE1vZHVsZSAhPT0gbW9kdWxlVHlwZSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKFwiVHlwZSBcIiArIHN0cmluZ2lmeSh0eXBlKSArIFwiIGlzIHBhcnQgb2YgdGhlIGRlY2xhcmF0aW9ucyBvZiAyIG1vZHVsZXM6IFwiICsgc3RyaW5naWZ5KG9sZE1vZHVsZSkgKyBcIiBhbmQgXCIgKyBzdHJpbmdpZnkobW9kdWxlVHlwZSkgKyBcIiEgXCIpICtcbiAgICAgICAgICAgICAgICAgIChcIlBsZWFzZSBjb25zaWRlciBtb3ZpbmcgXCIgKyBzdHJpbmdpZnkodHlwZSkgKyBcIiB0byBhIGhpZ2hlciBtb2R1bGUgdGhhdCBpbXBvcnRzIFwiICsgc3RyaW5naWZ5KG9sZE1vZHVsZSkgKyBcIiBhbmQgXCIgKyBzdHJpbmdpZnkobW9kdWxlVHlwZSkgKyBcIi4gXCIpICtcbiAgICAgICAgICAgICAgICAgIChcIllvdSBjYW4gYWxzbyBjcmVhdGUgYSBuZXcgTmdNb2R1bGUgdGhhdCBleHBvcnRzIGFuZCBpbmNsdWRlcyBcIiArIHN0cmluZ2lmeSh0eXBlKSArIFwiIHRoZW4gaW1wb3J0IHRoYXQgTmdNb2R1bGUgaW4gXCIgKyBzdHJpbmdpZnkob2xkTW9kdWxlKSArIFwiIGFuZCBcIiArIHN0cmluZ2lmeShtb2R1bGVUeXBlKSArIFwiLlwiKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX25nTW9kdWxlT2ZUeXBlcy5zZXQodHlwZSwgbW9kdWxlVHlwZSk7XG4gICAgICB9O1xuICAgICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLl9nZXRUcmFuc2l0aXZlTmdNb2R1bGVNZXRhZGF0YSA9IGZ1bmN0aW9uIChpbXBvcnRlZE1vZHVsZXMsIGV4cG9ydGVkTW9kdWxlcykge1xuICAgICAgICAgIC8vIGNvbGxlY3QgYHByb3ZpZGVyc2AgLyBgZW50cnlDb21wb25lbnRzYCBmcm9tIGFsbCBpbXBvcnRlZCBhbmQgYWxsIGV4cG9ydGVkIG1vZHVsZXNcbiAgICAgICAgICB2YXIgdHJhbnNpdGl2ZU1vZHVsZXMgPSBnZXRUcmFuc2l0aXZlTW9kdWxlcyhpbXBvcnRlZE1vZHVsZXMuY29uY2F0KGV4cG9ydGVkTW9kdWxlcyksIHRydWUpO1xuICAgICAgICAgIHZhciBwcm92aWRlcnMgPSBmbGF0dGVuQXJyYXkodHJhbnNpdGl2ZU1vZHVsZXMubWFwKGZ1bmN0aW9uIChuZ01vZHVsZSkgeyByZXR1cm4gbmdNb2R1bGUucHJvdmlkZXJzOyB9KSk7XG4gICAgICAgICAgdmFyIGVudHJ5Q29tcG9uZW50cyA9IGZsYXR0ZW5BcnJheSh0cmFuc2l0aXZlTW9kdWxlcy5tYXAoZnVuY3Rpb24gKG5nTW9kdWxlKSB7IHJldHVybiBuZ01vZHVsZS5lbnRyeUNvbXBvbmVudHM7IH0pKTtcbiAgICAgICAgICB2YXIgdHJhbnNpdGl2ZUV4cG9ydGVkTW9kdWxlcyA9IGdldFRyYW5zaXRpdmVNb2R1bGVzKGltcG9ydGVkTW9kdWxlcywgZmFsc2UpO1xuICAgICAgICAgIHZhciBkaXJlY3RpdmVzID0gZmxhdHRlbkFycmF5KHRyYW5zaXRpdmVFeHBvcnRlZE1vZHVsZXMubWFwKGZ1bmN0aW9uIChuZ01vZHVsZSkgeyByZXR1cm4gbmdNb2R1bGUuZXhwb3J0ZWREaXJlY3RpdmVzOyB9KSk7XG4gICAgICAgICAgdmFyIHBpcGVzID0gZmxhdHRlbkFycmF5KHRyYW5zaXRpdmVFeHBvcnRlZE1vZHVsZXMubWFwKGZ1bmN0aW9uIChuZ01vZHVsZSkgeyByZXR1cm4gbmdNb2R1bGUuZXhwb3J0ZWRQaXBlczsgfSkpO1xuICAgICAgICAgIHJldHVybiBuZXcgVHJhbnNpdGl2ZUNvbXBpbGVOZ01vZHVsZU1ldGFkYXRhKHRyYW5zaXRpdmVNb2R1bGVzLCBwcm92aWRlcnMsIGVudHJ5Q29tcG9uZW50cywgZGlyZWN0aXZlcywgcGlwZXMpO1xuICAgICAgfTtcbiAgICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5fYWRkRGlyZWN0aXZlVG9Nb2R1bGUgPSBmdW5jdGlvbiAoZGlyTWV0YSwgbW9kdWxlVHlwZSwgdHJhbnNpdGl2ZU1vZHVsZSwgZGVjbGFyZWREaXJlY3RpdmVzLCBmb3JjZSkge1xuICAgICAgICAgIGlmIChmb3JjZSA9PT0gdm9pZCAwKSB7IGZvcmNlID0gZmFsc2U7IH1cbiAgICAgICAgICBpZiAoZm9yY2UgfHwgIXRyYW5zaXRpdmVNb2R1bGUuZGlyZWN0aXZlc1NldC5oYXMoZGlyTWV0YS50eXBlLnJlZmVyZW5jZSkpIHtcbiAgICAgICAgICAgICAgdHJhbnNpdGl2ZU1vZHVsZS5kaXJlY3RpdmVzU2V0LmFkZChkaXJNZXRhLnR5cGUucmVmZXJlbmNlKTtcbiAgICAgICAgICAgICAgdHJhbnNpdGl2ZU1vZHVsZS5kaXJlY3RpdmVzLnB1c2goZGlyTWV0YSk7XG4gICAgICAgICAgICAgIGRlY2xhcmVkRGlyZWN0aXZlcy5wdXNoKGRpck1ldGEpO1xuICAgICAgICAgICAgICB0aGlzLl9hZGRUeXBlVG9Nb2R1bGUoZGlyTWV0YS50eXBlLnJlZmVyZW5jZSwgbW9kdWxlVHlwZSk7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9O1xuICAgICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLl9hZGRQaXBlVG9Nb2R1bGUgPSBmdW5jdGlvbiAocGlwZU1ldGEsIG1vZHVsZVR5cGUsIHRyYW5zaXRpdmVNb2R1bGUsIGRlY2xhcmVkUGlwZXMsIGZvcmNlKSB7XG4gICAgICAgICAgaWYgKGZvcmNlID09PSB2b2lkIDApIHsgZm9yY2UgPSBmYWxzZTsgfVxuICAgICAgICAgIGlmIChmb3JjZSB8fCAhdHJhbnNpdGl2ZU1vZHVsZS5waXBlc1NldC5oYXMocGlwZU1ldGEudHlwZS5yZWZlcmVuY2UpKSB7XG4gICAgICAgICAgICAgIHRyYW5zaXRpdmVNb2R1bGUucGlwZXNTZXQuYWRkKHBpcGVNZXRhLnR5cGUucmVmZXJlbmNlKTtcbiAgICAgICAgICAgICAgdHJhbnNpdGl2ZU1vZHVsZS5waXBlcy5wdXNoKHBpcGVNZXRhKTtcbiAgICAgICAgICAgICAgZGVjbGFyZWRQaXBlcy5wdXNoKHBpcGVNZXRhKTtcbiAgICAgICAgICAgICAgdGhpcy5fYWRkVHlwZVRvTW9kdWxlKHBpcGVNZXRhLnR5cGUucmVmZXJlbmNlLCBtb2R1bGVUeXBlKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH07XG4gICAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuZ2V0VHlwZU1ldGFkYXRhID0gZnVuY3Rpb24gKHR5cGUsIG1vZHVsZVVybCwgZGVwZW5kZW5jaWVzKSB7XG4gICAgICAgICAgaWYgKGRlcGVuZGVuY2llcyA9PT0gdm9pZCAwKSB7IGRlcGVuZGVuY2llcyA9IG51bGw7IH1cbiAgICAgICAgICB0eXBlID0gX2FuZ3VsYXJfY29yZS5yZXNvbHZlRm9yd2FyZFJlZih0eXBlKTtcbiAgICAgICAgICByZXR1cm4gbmV3IENvbXBpbGVUeXBlTWV0YWRhdGEoe1xuICAgICAgICAgICAgICBuYW1lOiB0aGlzLnNhbml0aXplVG9rZW5OYW1lKHR5cGUpLFxuICAgICAgICAgICAgICBtb2R1bGVVcmw6IG1vZHVsZVVybCxcbiAgICAgICAgICAgICAgcmVmZXJlbmNlOiB0eXBlLFxuICAgICAgICAgICAgICBkaURlcHM6IHRoaXMuZ2V0RGVwZW5kZW5jaWVzTWV0YWRhdGEodHlwZSwgZGVwZW5kZW5jaWVzKSxcbiAgICAgICAgICAgICAgbGlmZWN5Y2xlSG9va3M6IExJRkVDWUNMRV9IT09LU19WQUxVRVMuZmlsdGVyKGZ1bmN0aW9uIChob29rKSB7IHJldHVybiBoYXNMaWZlY3ljbGVIb29rKGhvb2ssIHR5cGUpOyB9KSxcbiAgICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuZ2V0RmFjdG9yeU1ldGFkYXRhID0gZnVuY3Rpb24gKGZhY3RvcnksIG1vZHVsZVVybCwgZGVwZW5kZW5jaWVzKSB7XG4gICAgICAgICAgaWYgKGRlcGVuZGVuY2llcyA9PT0gdm9pZCAwKSB7IGRlcGVuZGVuY2llcyA9IG51bGw7IH1cbiAgICAgICAgICBmYWN0b3J5ID0gX2FuZ3VsYXJfY29yZS5yZXNvbHZlRm9yd2FyZFJlZihmYWN0b3J5KTtcbiAgICAgICAgICByZXR1cm4gbmV3IENvbXBpbGVGYWN0b3J5TWV0YWRhdGEoe1xuICAgICAgICAgICAgICBuYW1lOiB0aGlzLnNhbml0aXplVG9rZW5OYW1lKGZhY3RvcnkpLFxuICAgICAgICAgICAgICBtb2R1bGVVcmw6IG1vZHVsZVVybCxcbiAgICAgICAgICAgICAgcmVmZXJlbmNlOiBmYWN0b3J5LFxuICAgICAgICAgICAgICBkaURlcHM6IHRoaXMuZ2V0RGVwZW5kZW5jaWVzTWV0YWRhdGEoZmFjdG9yeSwgZGVwZW5kZW5jaWVzKVxuICAgICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5nZXRQaXBlTWV0YWRhdGEgPSBmdW5jdGlvbiAocGlwZVR5cGUsIHRocm93SWZOb3RGb3VuZCkge1xuICAgICAgICAgIGlmICh0aHJvd0lmTm90Rm91bmQgPT09IHZvaWQgMCkgeyB0aHJvd0lmTm90Rm91bmQgPSB0cnVlOyB9XG4gICAgICAgICAgcGlwZVR5cGUgPSBfYW5ndWxhcl9jb3JlLnJlc29sdmVGb3J3YXJkUmVmKHBpcGVUeXBlKTtcbiAgICAgICAgICB2YXIgbWV0YSA9IHRoaXMuX3BpcGVDYWNoZS5nZXQocGlwZVR5cGUpO1xuICAgICAgICAgIGlmICghbWV0YSkge1xuICAgICAgICAgICAgICB2YXIgcGlwZU1ldGEgPSB0aGlzLl9waXBlUmVzb2x2ZXIucmVzb2x2ZShwaXBlVHlwZSwgdGhyb3dJZk5vdEZvdW5kKTtcbiAgICAgICAgICAgICAgaWYgKCFwaXBlTWV0YSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbWV0YSA9IG5ldyBDb21waWxlUGlwZU1ldGFkYXRhKHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6IHRoaXMuZ2V0VHlwZU1ldGFkYXRhKHBpcGVUeXBlLCBzdGF0aWNUeXBlTW9kdWxlVXJsKHBpcGVUeXBlKSksXG4gICAgICAgICAgICAgICAgICBuYW1lOiBwaXBlTWV0YS5uYW1lLFxuICAgICAgICAgICAgICAgICAgcHVyZTogcGlwZU1ldGEucHVyZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgdGhpcy5fcGlwZUNhY2hlLnNldChwaXBlVHlwZSwgbWV0YSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBtZXRhO1xuICAgICAgfTtcbiAgICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5nZXREZXBlbmRlbmNpZXNNZXRhZGF0YSA9IGZ1bmN0aW9uICh0eXBlT3JGdW5jLCBkZXBlbmRlbmNpZXMpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHZhciBoYXNVbmtub3duRGVwcyA9IGZhbHNlO1xuICAgICAgICAgIHZhciBwYXJhbXMgPSBkZXBlbmRlbmNpZXMgfHwgdGhpcy5fcmVmbGVjdG9yLnBhcmFtZXRlcnModHlwZU9yRnVuYykgfHwgW107XG4gICAgICAgICAgdmFyIGRlcGVuZGVuY2llc01ldGFkYXRhID0gcGFyYW1zLm1hcChmdW5jdGlvbiAocGFyYW0pIHtcbiAgICAgICAgICAgICAgdmFyIGlzQXR0cmlidXRlID0gZmFsc2U7XG4gICAgICAgICAgICAgIHZhciBpc0hvc3QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgdmFyIGlzU2VsZiA9IGZhbHNlO1xuICAgICAgICAgICAgICB2YXIgaXNTa2lwU2VsZiA9IGZhbHNlO1xuICAgICAgICAgICAgICB2YXIgaXNPcHRpb25hbCA9IGZhbHNlO1xuICAgICAgICAgICAgICB2YXIgcXVlcnkgPSBudWxsO1xuICAgICAgICAgICAgICB2YXIgdmlld1F1ZXJ5ID0gbnVsbDtcbiAgICAgICAgICAgICAgdmFyIHRva2VuID0gbnVsbDtcbiAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGFyYW0pKSB7XG4gICAgICAgICAgICAgICAgICBwYXJhbS5mb3JFYWNoKGZ1bmN0aW9uIChwYXJhbUVudHJ5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtRW50cnkgaW5zdGFuY2VvZiBfYW5ndWxhcl9jb3JlLkhvc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaXNIb3N0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocGFyYW1FbnRyeSBpbnN0YW5jZW9mIF9hbmd1bGFyX2NvcmUuU2VsZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpc1NlbGYgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChwYXJhbUVudHJ5IGluc3RhbmNlb2YgX2FuZ3VsYXJfY29yZS5Ta2lwU2VsZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpc1NraXBTZWxmID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocGFyYW1FbnRyeSBpbnN0YW5jZW9mIF9hbmd1bGFyX2NvcmUuT3B0aW9uYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaXNPcHRpb25hbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhcmFtRW50cnkgaW5zdGFuY2VvZiBfYW5ndWxhcl9jb3JlLkF0dHJpYnV0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpc0F0dHJpYnV0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuID0gcGFyYW1FbnRyeS5hdHRyaWJ1dGVOYW1lO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChwYXJhbUVudHJ5IGluc3RhbmNlb2YgX2FuZ3VsYXJfY29yZS5RdWVyeSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1FbnRyeS5pc1ZpZXdRdWVyeSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlld1F1ZXJ5ID0gcGFyYW1FbnRyeTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5ID0gcGFyYW1FbnRyeTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChwYXJhbUVudHJ5IGluc3RhbmNlb2YgX2FuZ3VsYXJfY29yZS5JbmplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSBwYXJhbUVudHJ5LnRva2VuO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpc1ZhbGlkVHlwZShwYXJhbUVudHJ5KSAmJiBpc0JsYW5rKHRva2VuKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHBhcmFtRW50cnk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICB0b2tlbiA9IHBhcmFtO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChpc0JsYW5rKHRva2VuKSkge1xuICAgICAgICAgICAgICAgICAgaGFzVW5rbm93bkRlcHMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb21waWxlRGlEZXBlbmRlbmN5TWV0YWRhdGEoe1xuICAgICAgICAgICAgICAgICAgaXNBdHRyaWJ1dGU6IGlzQXR0cmlidXRlLFxuICAgICAgICAgICAgICAgICAgaXNIb3N0OiBpc0hvc3QsXG4gICAgICAgICAgICAgICAgICBpc1NlbGY6IGlzU2VsZixcbiAgICAgICAgICAgICAgICAgIGlzU2tpcFNlbGY6IGlzU2tpcFNlbGYsXG4gICAgICAgICAgICAgICAgICBpc09wdGlvbmFsOiBpc09wdGlvbmFsLFxuICAgICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5ID8gX3RoaXMuZ2V0UXVlcnlNZXRhZGF0YShxdWVyeSwgbnVsbCwgdHlwZU9yRnVuYykgOiBudWxsLFxuICAgICAgICAgICAgICAgICAgdmlld1F1ZXJ5OiB2aWV3UXVlcnkgPyBfdGhpcy5nZXRRdWVyeU1ldGFkYXRhKHZpZXdRdWVyeSwgbnVsbCwgdHlwZU9yRnVuYykgOiBudWxsLFxuICAgICAgICAgICAgICAgICAgdG9rZW46IF90aGlzLmdldFRva2VuTWV0YWRhdGEodG9rZW4pXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmIChoYXNVbmtub3duRGVwcykge1xuICAgICAgICAgICAgICB2YXIgZGVwc1Rva2VucyA9IGRlcGVuZGVuY2llc01ldGFkYXRhLm1hcChmdW5jdGlvbiAoZGVwKSB7IHJldHVybiBkZXAgPyBzdHJpbmdpZnkoZGVwLnRva2VuKSA6ICc/JzsgfSkuam9pbignLCAnKTtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgcmVzb2x2ZSBhbGwgcGFyYW1ldGVycyBmb3IgXCIgKyBzdHJpbmdpZnkodHlwZU9yRnVuYykgKyBcIjogKFwiICsgZGVwc1Rva2VucyArIFwiKS5cIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBkZXBlbmRlbmNpZXNNZXRhZGF0YTtcbiAgICAgIH07XG4gICAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuZ2V0VG9rZW5NZXRhZGF0YSA9IGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgICAgIHRva2VuID0gX2FuZ3VsYXJfY29yZS5yZXNvbHZlRm9yd2FyZFJlZih0b2tlbik7XG4gICAgICAgICAgdmFyIGNvbXBpbGVUb2tlbjtcbiAgICAgICAgICBpZiAodHlwZW9mIHRva2VuID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICBjb21waWxlVG9rZW4gPSBuZXcgQ29tcGlsZVRva2VuTWV0YWRhdGEoeyB2YWx1ZTogdG9rZW4gfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBjb21waWxlVG9rZW4gPSBuZXcgQ29tcGlsZVRva2VuTWV0YWRhdGEoe1xuICAgICAgICAgICAgICAgICAgaWRlbnRpZmllcjogbmV3IENvbXBpbGVJZGVudGlmaWVyTWV0YWRhdGEoe1xuICAgICAgICAgICAgICAgICAgICAgIHJlZmVyZW5jZTogdG9rZW4sXG4gICAgICAgICAgICAgICAgICAgICAgbmFtZTogdGhpcy5zYW5pdGl6ZVRva2VuTmFtZSh0b2tlbiksXG4gICAgICAgICAgICAgICAgICAgICAgbW9kdWxlVXJsOiBzdGF0aWNUeXBlTW9kdWxlVXJsKHRva2VuKVxuICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBjb21waWxlVG9rZW47XG4gICAgICB9O1xuICAgICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLmdldFByb3ZpZGVyc01ldGFkYXRhID0gZnVuY3Rpb24gKHByb3ZpZGVycywgdGFyZ2V0RW50cnlDb21wb25lbnRzLCBkZWJ1Z0luZm8pIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHZhciBjb21waWxlUHJvdmlkZXJzID0gW107XG4gICAgICAgICAgcHJvdmlkZXJzLmZvckVhY2goZnVuY3Rpb24gKHByb3ZpZGVyLCBwcm92aWRlcklkeCkge1xuICAgICAgICAgICAgICBwcm92aWRlciA9IF9hbmd1bGFyX2NvcmUucmVzb2x2ZUZvcndhcmRSZWYocHJvdmlkZXIpO1xuICAgICAgICAgICAgICBpZiAocHJvdmlkZXIgJiYgdHlwZW9mIHByb3ZpZGVyID09ICdvYmplY3QnICYmIHByb3ZpZGVyLmhhc093blByb3BlcnR5KCdwcm92aWRlJykpIHtcbiAgICAgICAgICAgICAgICAgIHByb3ZpZGVyID0gbmV3IFByb3ZpZGVyTWV0YShwcm92aWRlci5wcm92aWRlLCBwcm92aWRlcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFyIGNvbXBpbGVQcm92aWRlcjtcbiAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocHJvdmlkZXIpKSB7XG4gICAgICAgICAgICAgICAgICBjb21waWxlUHJvdmlkZXIgPSBfdGhpcy5nZXRQcm92aWRlcnNNZXRhZGF0YShwcm92aWRlciwgdGFyZ2V0RW50cnlDb21wb25lbnRzLCBkZWJ1Z0luZm8pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgaWYgKHByb3ZpZGVyIGluc3RhbmNlb2YgUHJvdmlkZXJNZXRhKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgdG9rZW5NZXRhID0gX3RoaXMuZ2V0VG9rZW5NZXRhZGF0YShwcm92aWRlci50b2tlbik7XG4gICAgICAgICAgICAgICAgICBpZiAodG9rZW5NZXRhLnJlZmVyZW5jZSA9PT1cbiAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlSWRlbnRpZmllclRva2VuKElkZW50aWZpZXJzLkFOQUxZWkVfRk9SX0VOVFJZX0NPTVBPTkVOVFMpLnJlZmVyZW5jZSkge1xuICAgICAgICAgICAgICAgICAgICAgIHRhcmdldEVudHJ5Q29tcG9uZW50cy5wdXNoLmFwcGx5KHRhcmdldEVudHJ5Q29tcG9uZW50cywgX3RoaXMuX2dldEVudHJ5Q29tcG9uZW50c0Zyb21Qcm92aWRlcihwcm92aWRlcikpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgY29tcGlsZVByb3ZpZGVyID0gX3RoaXMuZ2V0UHJvdmlkZXJNZXRhZGF0YShwcm92aWRlcik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSBpZiAoaXNWYWxpZFR5cGUocHJvdmlkZXIpKSB7XG4gICAgICAgICAgICAgICAgICBjb21waWxlUHJvdmlkZXIgPSBfdGhpcy5nZXRUeXBlTWV0YWRhdGEocHJvdmlkZXIsIHN0YXRpY1R5cGVNb2R1bGVVcmwocHJvdmlkZXIpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHZhciBwcm92aWRlcnNJbmZvID0gcHJvdmlkZXJzLnJlZHVjZShmdW5jdGlvbiAoc29GYXIsIHNlZW5Qcm92aWRlciwgc2VlblByb3ZpZGVySWR4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHNlZW5Qcm92aWRlcklkeCA8IHByb3ZpZGVySWR4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHNvRmFyLnB1c2goXCJcIiArIHN0cmluZ2lmeShzZWVuUHJvdmlkZXIpKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc2VlblByb3ZpZGVySWR4ID09IHByb3ZpZGVySWR4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHNvRmFyLnB1c2goXCI/XCIgKyBzdHJpbmdpZnkoc2VlblByb3ZpZGVyKSArIFwiP1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc2VlblByb3ZpZGVySWR4ID09IHByb3ZpZGVySWR4ICsgMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBzb0Zhci5wdXNoKCcuLi4nKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNvRmFyO1xuICAgICAgICAgICAgICAgICAgfSwgW10pXG4gICAgICAgICAgICAgICAgICAgICAgLmpvaW4oJywgJyk7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIFwiICsgKGRlYnVnSW5mbyA/IGRlYnVnSW5mbyA6ICdwcm92aWRlcicpICsgXCIgLSBvbmx5IGluc3RhbmNlcyBvZiBQcm92aWRlciBhbmQgVHlwZSBhcmUgYWxsb3dlZCwgZ290OiBbXCIgKyBwcm92aWRlcnNJbmZvICsgXCJdXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChjb21waWxlUHJvdmlkZXIpIHtcbiAgICAgICAgICAgICAgICAgIGNvbXBpbGVQcm92aWRlcnMucHVzaChjb21waWxlUHJvdmlkZXIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIGNvbXBpbGVQcm92aWRlcnM7XG4gICAgICB9O1xuICAgICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLl9nZXRFbnRyeUNvbXBvbmVudHNGcm9tUHJvdmlkZXIgPSBmdW5jdGlvbiAocHJvdmlkZXIpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHZhciBjb21wb25lbnRzID0gW107XG4gICAgICAgICAgdmFyIGNvbGxlY3RlZElkZW50aWZpZXJzID0gW107XG4gICAgICAgICAgaWYgKHByb3ZpZGVyLnVzZUZhY3RvcnkgfHwgcHJvdmlkZXIudXNlRXhpc3RpbmcgfHwgcHJvdmlkZXIudXNlQ2xhc3MpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIEFOQUxZWkVfRk9SX0VOVFJZX0NPTVBPTkVOVFMgdG9rZW4gb25seSBzdXBwb3J0cyB1c2VWYWx1ZSFcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghcHJvdmlkZXIubXVsdGkpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIEFOQUxZWkVfRk9SX0VOVFJZX0NPTVBPTkVOVFMgdG9rZW4gb25seSBzdXBwb3J0cyAnbXVsdGkgPSB0cnVlJyFcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnZlcnRUb0NvbXBpbGVWYWx1ZShwcm92aWRlci51c2VWYWx1ZSwgY29sbGVjdGVkSWRlbnRpZmllcnMpO1xuICAgICAgICAgIGNvbGxlY3RlZElkZW50aWZpZXJzLmZvckVhY2goZnVuY3Rpb24gKGlkZW50aWZpZXIpIHtcbiAgICAgICAgICAgICAgdmFyIGRpck1ldGEgPSBfdGhpcy5nZXREaXJlY3RpdmVNZXRhZGF0YShpZGVudGlmaWVyLnJlZmVyZW5jZSwgZmFsc2UpO1xuICAgICAgICAgICAgICBpZiAoZGlyTWV0YSkge1xuICAgICAgICAgICAgICAgICAgY29tcG9uZW50cy5wdXNoKGRpck1ldGEudHlwZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gY29tcG9uZW50cztcbiAgICAgIH07XG4gICAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuZ2V0UHJvdmlkZXJNZXRhZGF0YSA9IGZ1bmN0aW9uIChwcm92aWRlcikge1xuICAgICAgICAgIHZhciBjb21waWxlRGVwcztcbiAgICAgICAgICB2YXIgY29tcGlsZVR5cGVNZXRhZGF0YSA9IG51bGw7XG4gICAgICAgICAgdmFyIGNvbXBpbGVGYWN0b3J5TWV0YWRhdGEgPSBudWxsO1xuICAgICAgICAgIGlmIChwcm92aWRlci51c2VDbGFzcykge1xuICAgICAgICAgICAgICBjb21waWxlVHlwZU1ldGFkYXRhID0gdGhpcy5nZXRUeXBlTWV0YWRhdGEocHJvdmlkZXIudXNlQ2xhc3MsIHN0YXRpY1R5cGVNb2R1bGVVcmwocHJvdmlkZXIudXNlQ2xhc3MpLCBwcm92aWRlci5kZXBlbmRlbmNpZXMpO1xuICAgICAgICAgICAgICBjb21waWxlRGVwcyA9IGNvbXBpbGVUeXBlTWV0YWRhdGEuZGlEZXBzO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChwcm92aWRlci51c2VGYWN0b3J5KSB7XG4gICAgICAgICAgICAgIGNvbXBpbGVGYWN0b3J5TWV0YWRhdGEgPSB0aGlzLmdldEZhY3RvcnlNZXRhZGF0YShwcm92aWRlci51c2VGYWN0b3J5LCBzdGF0aWNUeXBlTW9kdWxlVXJsKHByb3ZpZGVyLnVzZUZhY3RvcnkpLCBwcm92aWRlci5kZXBlbmRlbmNpZXMpO1xuICAgICAgICAgICAgICBjb21waWxlRGVwcyA9IGNvbXBpbGVGYWN0b3J5TWV0YWRhdGEuZGlEZXBzO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3IENvbXBpbGVQcm92aWRlck1ldGFkYXRhKHtcbiAgICAgICAgICAgICAgdG9rZW46IHRoaXMuZ2V0VG9rZW5NZXRhZGF0YShwcm92aWRlci50b2tlbiksXG4gICAgICAgICAgICAgIHVzZUNsYXNzOiBjb21waWxlVHlwZU1ldGFkYXRhLFxuICAgICAgICAgICAgICB1c2VWYWx1ZTogY29udmVydFRvQ29tcGlsZVZhbHVlKHByb3ZpZGVyLnVzZVZhbHVlLCBbXSksXG4gICAgICAgICAgICAgIHVzZUZhY3Rvcnk6IGNvbXBpbGVGYWN0b3J5TWV0YWRhdGEsXG4gICAgICAgICAgICAgIHVzZUV4aXN0aW5nOiBwcm92aWRlci51c2VFeGlzdGluZyA/IHRoaXMuZ2V0VG9rZW5NZXRhZGF0YShwcm92aWRlci51c2VFeGlzdGluZykgOiBudWxsLFxuICAgICAgICAgICAgICBkZXBzOiBjb21waWxlRGVwcyxcbiAgICAgICAgICAgICAgbXVsdGk6IHByb3ZpZGVyLm11bHRpXG4gICAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLmdldFF1ZXJpZXNNZXRhZGF0YSA9IGZ1bmN0aW9uIChxdWVyaWVzLCBpc1ZpZXdRdWVyeSwgZGlyZWN0aXZlVHlwZSkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgdmFyIHJlcyA9IFtdO1xuICAgICAgICAgIE9iamVjdC5rZXlzKHF1ZXJpZXMpLmZvckVhY2goZnVuY3Rpb24gKHByb3BlcnR5TmFtZSkge1xuICAgICAgICAgICAgICB2YXIgcXVlcnkgPSBxdWVyaWVzW3Byb3BlcnR5TmFtZV07XG4gICAgICAgICAgICAgIGlmIChxdWVyeS5pc1ZpZXdRdWVyeSA9PT0gaXNWaWV3UXVlcnkpIHtcbiAgICAgICAgICAgICAgICAgIHJlcy5wdXNoKF90aGlzLmdldFF1ZXJ5TWV0YWRhdGEocXVlcnksIHByb3BlcnR5TmFtZSwgZGlyZWN0aXZlVHlwZSkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH07XG4gICAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuX3F1ZXJ5VmFyQmluZGluZ3MgPSBmdW5jdGlvbiAoc2VsZWN0b3IpIHsgcmV0dXJuIHNlbGVjdG9yLnNwbGl0KC9cXHMqLFxccyovKTsgfTtcbiAgICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5nZXRRdWVyeU1ldGFkYXRhID0gZnVuY3Rpb24gKHEsIHByb3BlcnR5TmFtZSwgdHlwZU9yRnVuYykge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgdmFyIHNlbGVjdG9ycztcbiAgICAgICAgICBpZiAodHlwZW9mIHEuc2VsZWN0b3IgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIHNlbGVjdG9ycyA9IHRoaXMuX3F1ZXJ5VmFyQmluZGluZ3MocS5zZWxlY3RvcikubWFwKGZ1bmN0aW9uICh2YXJOYW1lKSB7IHJldHVybiBfdGhpcy5nZXRUb2tlbk1ldGFkYXRhKHZhck5hbWUpOyB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGlmICghcS5zZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgY29uc3RydWN0IGEgcXVlcnkgZm9yIHRoZSBwcm9wZXJ0eSBcXFwiXCIgKyBwcm9wZXJ0eU5hbWUgKyBcIlxcXCIgb2YgXFxcIlwiICsgc3RyaW5naWZ5KHR5cGVPckZ1bmMpICsgXCJcXFwiIHNpbmNlIHRoZSBxdWVyeSBzZWxlY3RvciB3YXNuJ3QgZGVmaW5lZC5cIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc2VsZWN0b3JzID0gW3RoaXMuZ2V0VG9rZW5NZXRhZGF0YShxLnNlbGVjdG9yKV07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuZXcgQ29tcGlsZVF1ZXJ5TWV0YWRhdGEoe1xuICAgICAgICAgICAgICBzZWxlY3RvcnM6IHNlbGVjdG9ycyxcbiAgICAgICAgICAgICAgZmlyc3Q6IHEuZmlyc3QsXG4gICAgICAgICAgICAgIGRlc2NlbmRhbnRzOiBxLmRlc2NlbmRhbnRzLCBwcm9wZXJ0eU5hbWU6IHByb3BlcnR5TmFtZSxcbiAgICAgICAgICAgICAgcmVhZDogcS5yZWFkID8gdGhpcy5nZXRUb2tlbk1ldGFkYXRhKHEucmVhZCkgOiBudWxsXG4gICAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0YWJsZSB9LFxuICAgICAgXTtcbiAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIuY3RvclBhcmFtZXRlcnMgPSBbXG4gICAgICAgICAgeyB0eXBlOiBOZ01vZHVsZVJlc29sdmVyLCB9LFxuICAgICAgICAgIHsgdHlwZTogRGlyZWN0aXZlUmVzb2x2ZXIsIH0sXG4gICAgICAgICAgeyB0eXBlOiBQaXBlUmVzb2x2ZXIsIH0sXG4gICAgICAgICAgeyB0eXBlOiBFbGVtZW50U2NoZW1hUmVnaXN0cnksIH0sXG4gICAgICAgICAgeyB0eXBlOiBSZWZsZWN0b3JSZWFkZXIsIH0sXG4gICAgICBdO1xuICAgICAgcmV0dXJuIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyO1xuICB9KCkpO1xuICBmdW5jdGlvbiBnZXRUcmFuc2l0aXZlTW9kdWxlcyhtb2R1bGVzLCBpbmNsdWRlSW1wb3J0cywgdGFyZ2V0TW9kdWxlcywgdmlzaXRlZE1vZHVsZXMpIHtcbiAgICAgIGlmICh0YXJnZXRNb2R1bGVzID09PSB2b2lkIDApIHsgdGFyZ2V0TW9kdWxlcyA9IFtdOyB9XG4gICAgICBpZiAodmlzaXRlZE1vZHVsZXMgPT09IHZvaWQgMCkgeyB2aXNpdGVkTW9kdWxlcyA9IG5ldyBTZXQoKTsgfVxuICAgICAgbW9kdWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChuZ01vZHVsZSkge1xuICAgICAgICAgIGlmICghdmlzaXRlZE1vZHVsZXMuaGFzKG5nTW9kdWxlLnR5cGUucmVmZXJlbmNlKSkge1xuICAgICAgICAgICAgICB2aXNpdGVkTW9kdWxlcy5hZGQobmdNb2R1bGUudHlwZS5yZWZlcmVuY2UpO1xuICAgICAgICAgICAgICB2YXIgbmVzdGVkTW9kdWxlcyA9IGluY2x1ZGVJbXBvcnRzID9cbiAgICAgICAgICAgICAgICAgIG5nTW9kdWxlLmltcG9ydGVkTW9kdWxlcy5jb25jYXQobmdNb2R1bGUuZXhwb3J0ZWRNb2R1bGVzKSA6XG4gICAgICAgICAgICAgICAgICBuZ01vZHVsZS5leHBvcnRlZE1vZHVsZXM7XG4gICAgICAgICAgICAgIGdldFRyYW5zaXRpdmVNb2R1bGVzKG5lc3RlZE1vZHVsZXMsIGluY2x1ZGVJbXBvcnRzLCB0YXJnZXRNb2R1bGVzLCB2aXNpdGVkTW9kdWxlcyk7XG4gICAgICAgICAgICAgIC8vIEFkZCBhZnRlciByZWN1cnNpbmcgc28gaW1wb3J0ZWQvZXhwb3J0ZWQgbW9kdWxlcyBhcmUgYmVmb3JlIHRoZSBtb2R1bGUgaXRzZWxmLlxuICAgICAgICAgICAgICAvLyBUaGlzIGlzIGltcG9ydGFudCBmb3Igb3ZlcndyaXRpbmcgcHJvdmlkZXJzIG9mIGltcG9ydGVkIG1vZHVsZXMhXG4gICAgICAgICAgICAgIHRhcmdldE1vZHVsZXMucHVzaChuZ01vZHVsZSk7XG4gICAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGFyZ2V0TW9kdWxlcztcbiAgfVxuICBmdW5jdGlvbiBmbGF0dGVuQXJyYXkodHJlZSwgb3V0KSB7XG4gICAgICBpZiAob3V0ID09PSB2b2lkIDApIHsgb3V0ID0gW107IH1cbiAgICAgIGlmICh0cmVlKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIHZhciBpdGVtID0gX2FuZ3VsYXJfY29yZS5yZXNvbHZlRm9yd2FyZFJlZih0cmVlW2ldKTtcbiAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICAgIGZsYXR0ZW5BcnJheShpdGVtLCBvdXQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgb3V0LnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gb3V0O1xuICB9XG4gIGZ1bmN0aW9uIGlzVmFsaWRUeXBlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNTdGF0aWNTeW1ib2wodmFsdWUpIHx8ICh2YWx1ZSBpbnN0YW5jZW9mIF9hbmd1bGFyX2NvcmUuVHlwZSk7XG4gIH1cbiAgZnVuY3Rpb24gc3RhdGljVHlwZU1vZHVsZVVybCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzU3RhdGljU3ltYm9sKHZhbHVlKSA/IHZhbHVlLmZpbGVQYXRoIDogbnVsbDtcbiAgfVxuICBmdW5jdGlvbiBjb21wb25lbnRNb2R1bGVVcmwocmVmbGVjdG9yLCB0eXBlLCBjbXBNZXRhZGF0YSkge1xuICAgICAgaWYgKGlzU3RhdGljU3ltYm9sKHR5cGUpKSB7XG4gICAgICAgICAgcmV0dXJuIHN0YXRpY1R5cGVNb2R1bGVVcmwodHlwZSk7XG4gICAgICB9XG4gICAgICB2YXIgbW9kdWxlSWQgPSBjbXBNZXRhZGF0YS5tb2R1bGVJZDtcbiAgICAgIGlmICh0eXBlb2YgbW9kdWxlSWQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgdmFyIHNjaGVtZSA9IGdldFVybFNjaGVtZShtb2R1bGVJZCk7XG4gICAgICAgICAgcmV0dXJuIHNjaGVtZSA/IG1vZHVsZUlkIDogXCJwYWNrYWdlOlwiICsgbW9kdWxlSWQgKyBNT0RVTEVfU1VGRklYO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAobW9kdWxlSWQgIT09IG51bGwgJiYgbW9kdWxlSWQgIT09IHZvaWQgMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcigoXCJtb2R1bGVJZCBzaG91bGQgYmUgYSBzdHJpbmcgaW4gXFxcIlwiICsgc3RyaW5naWZ5KHR5cGUpICsgXCJcXFwiLiBTZWUgaHR0cHM6Ly9nb28uZ2wvd0lERGlMIGZvciBtb3JlIGluZm9ybWF0aW9uLlxcblwiKSArXG4gICAgICAgICAgICAgIFwiSWYgeW91J3JlIHVzaW5nIFdlYnBhY2sgeW91IHNob3VsZCBpbmxpbmUgdGhlIHRlbXBsYXRlIGFuZCB0aGUgc3R5bGVzLCBzZWUgaHR0cHM6Ly9nb28uZ2wvWDJKOHpjLlwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZWZsZWN0b3IuaW1wb3J0VXJpKHR5cGUpO1xuICB9XG4gIGZ1bmN0aW9uIGNvbnZlcnRUb0NvbXBpbGVWYWx1ZSh2YWx1ZSwgdGFyZ2V0SWRlbnRpZmllcnMpIHtcbiAgICAgIHJldHVybiB2aXNpdFZhbHVlKHZhbHVlLCBuZXcgX0NvbXBpbGVWYWx1ZUNvbnZlcnRlcigpLCB0YXJnZXRJZGVudGlmaWVycyk7XG4gIH1cbiAgdmFyIF9Db21waWxlVmFsdWVDb252ZXJ0ZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDE3KF9Db21waWxlVmFsdWVDb252ZXJ0ZXIsIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBfQ29tcGlsZVZhbHVlQ29udmVydGVyKCkge1xuICAgICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgX0NvbXBpbGVWYWx1ZUNvbnZlcnRlci5wcm90b3R5cGUudmlzaXRPdGhlciA9IGZ1bmN0aW9uICh2YWx1ZSwgdGFyZ2V0SWRlbnRpZmllcnMpIHtcbiAgICAgICAgICB2YXIgaWRlbnRpZmllcjtcbiAgICAgICAgICBpZiAoaXNTdGF0aWNTeW1ib2wodmFsdWUpKSB7XG4gICAgICAgICAgICAgIGlkZW50aWZpZXIgPSBuZXcgQ29tcGlsZUlkZW50aWZpZXJNZXRhZGF0YSh7IG5hbWU6IHZhbHVlLm5hbWUsIG1vZHVsZVVybDogdmFsdWUuZmlsZVBhdGgsIHJlZmVyZW5jZTogdmFsdWUgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBpZGVudGlmaWVyID0gbmV3IENvbXBpbGVJZGVudGlmaWVyTWV0YWRhdGEoeyByZWZlcmVuY2U6IHZhbHVlIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0YXJnZXRJZGVudGlmaWVycy5wdXNoKGlkZW50aWZpZXIpO1xuICAgICAgICAgIHJldHVybiBpZGVudGlmaWVyO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBfQ29tcGlsZVZhbHVlQ29udmVydGVyO1xuICB9KFZhbHVlVHJhbnNmb3JtZXIpKTtcblxuICB2YXIgQ29tcG9uZW50RmFjdG9yeURlcGVuZGVuY3kkMSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBDb21wb25lbnRGYWN0b3J5RGVwZW5kZW5jeShjb21wLCBwbGFjZWhvbGRlcikge1xuICAgICAgICAgIHRoaXMuY29tcCA9IGNvbXA7XG4gICAgICAgICAgdGhpcy5wbGFjZWhvbGRlciA9IHBsYWNlaG9sZGVyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIENvbXBvbmVudEZhY3RvcnlEZXBlbmRlbmN5O1xuICB9KCkpO1xuICB2YXIgTmdNb2R1bGVDb21waWxlUmVzdWx0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIE5nTW9kdWxlQ29tcGlsZVJlc3VsdChzdGF0ZW1lbnRzLCBuZ01vZHVsZUZhY3RvcnlWYXIsIGRlcGVuZGVuY2llcykge1xuICAgICAgICAgIHRoaXMuc3RhdGVtZW50cyA9IHN0YXRlbWVudHM7XG4gICAgICAgICAgdGhpcy5uZ01vZHVsZUZhY3RvcnlWYXIgPSBuZ01vZHVsZUZhY3RvcnlWYXI7XG4gICAgICAgICAgdGhpcy5kZXBlbmRlbmNpZXMgPSBkZXBlbmRlbmNpZXM7XG4gICAgICB9XG4gICAgICByZXR1cm4gTmdNb2R1bGVDb21waWxlUmVzdWx0O1xuICB9KCkpO1xuICB2YXIgTmdNb2R1bGVDb21waWxlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBOZ01vZHVsZUNvbXBpbGVyKCkge1xuICAgICAgfVxuICAgICAgTmdNb2R1bGVDb21waWxlci5wcm90b3R5cGUuY29tcGlsZSA9IGZ1bmN0aW9uIChuZ01vZHVsZU1ldGEsIGV4dHJhUHJvdmlkZXJzKSB7XG4gICAgICAgICAgdmFyIHNvdXJjZUZpbGVOYW1lID0gaXNQcmVzZW50KG5nTW9kdWxlTWV0YS50eXBlLm1vZHVsZVVybCkgP1xuICAgICAgICAgICAgICBcImluIE5nTW9kdWxlIFwiICsgbmdNb2R1bGVNZXRhLnR5cGUubmFtZSArIFwiIGluIFwiICsgbmdNb2R1bGVNZXRhLnR5cGUubW9kdWxlVXJsIDpcbiAgICAgICAgICAgICAgXCJpbiBOZ01vZHVsZSBcIiArIG5nTW9kdWxlTWV0YS50eXBlLm5hbWU7XG4gICAgICAgICAgdmFyIHNvdXJjZUZpbGUgPSBuZXcgUGFyc2VTb3VyY2VGaWxlKCcnLCBzb3VyY2VGaWxlTmFtZSk7XG4gICAgICAgICAgdmFyIHNvdXJjZVNwYW4gPSBuZXcgUGFyc2VTb3VyY2VTcGFuKG5ldyBQYXJzZUxvY2F0aW9uKHNvdXJjZUZpbGUsIG51bGwsIG51bGwsIG51bGwpLCBuZXcgUGFyc2VMb2NhdGlvbihzb3VyY2VGaWxlLCBudWxsLCBudWxsLCBudWxsKSk7XG4gICAgICAgICAgdmFyIGRlcHMgPSBbXTtcbiAgICAgICAgICB2YXIgYm9vdHN0cmFwQ29tcG9uZW50RmFjdG9yaWVzID0gW107XG4gICAgICAgICAgdmFyIGVudHJ5Q29tcG9uZW50RmFjdG9yaWVzID0gbmdNb2R1bGVNZXRhLnRyYW5zaXRpdmVNb2R1bGUuZW50cnlDb21wb25lbnRzLm1hcChmdW5jdGlvbiAoZW50cnlDb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgdmFyIGlkID0gbmV3IENvbXBpbGVJZGVudGlmaWVyTWV0YWRhdGEoeyBuYW1lOiBlbnRyeUNvbXBvbmVudC5uYW1lIH0pO1xuICAgICAgICAgICAgICBpZiAobmdNb2R1bGVNZXRhLmJvb3RzdHJhcENvbXBvbmVudHMuaW5kZXhPZihlbnRyeUNvbXBvbmVudCkgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgYm9vdHN0cmFwQ29tcG9uZW50RmFjdG9yaWVzLnB1c2goaWQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGRlcHMucHVzaChuZXcgQ29tcG9uZW50RmFjdG9yeURlcGVuZGVuY3kkMShlbnRyeUNvbXBvbmVudCwgaWQpKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHZhciBidWlsZGVyID0gbmV3IF9JbmplY3RvckJ1aWxkZXIobmdNb2R1bGVNZXRhLCBlbnRyeUNvbXBvbmVudEZhY3RvcmllcywgYm9vdHN0cmFwQ29tcG9uZW50RmFjdG9yaWVzLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICB2YXIgcHJvdmlkZXJQYXJzZXIgPSBuZXcgTmdNb2R1bGVQcm92aWRlckFuYWx5emVyKG5nTW9kdWxlTWV0YSwgZXh0cmFQcm92aWRlcnMsIHNvdXJjZVNwYW4pO1xuICAgICAgICAgIHByb3ZpZGVyUGFyc2VyLnBhcnNlKCkuZm9yRWFjaChmdW5jdGlvbiAocHJvdmlkZXIpIHsgcmV0dXJuIGJ1aWxkZXIuYWRkUHJvdmlkZXIocHJvdmlkZXIpOyB9KTtcbiAgICAgICAgICB2YXIgaW5qZWN0b3JDbGFzcyA9IGJ1aWxkZXIuYnVpbGQoKTtcbiAgICAgICAgICB2YXIgbmdNb2R1bGVGYWN0b3J5VmFyID0gbmdNb2R1bGVNZXRhLnR5cGUubmFtZSArIFwiTmdGYWN0b3J5XCI7XG4gICAgICAgICAgdmFyIG5nTW9kdWxlRmFjdG9yeVN0bXQgPSB2YXJpYWJsZShuZ01vZHVsZUZhY3RvcnlWYXIpXG4gICAgICAgICAgICAgIC5zZXQoaW1wb3J0RXhwcihyZXNvbHZlSWRlbnRpZmllcihJZGVudGlmaWVycy5OZ01vZHVsZUZhY3RvcnkpKVxuICAgICAgICAgICAgICAuaW5zdGFudGlhdGUoW3ZhcmlhYmxlKGluamVjdG9yQ2xhc3MubmFtZSksIGltcG9ydEV4cHIobmdNb2R1bGVNZXRhLnR5cGUpXSwgaW1wb3J0VHlwZShyZXNvbHZlSWRlbnRpZmllcihJZGVudGlmaWVycy5OZ01vZHVsZUZhY3RvcnkpLCBbaW1wb3J0VHlwZShuZ01vZHVsZU1ldGEudHlwZSldLCBbVHlwZU1vZGlmaWVyLkNvbnN0XSkpKVxuICAgICAgICAgICAgICAudG9EZWNsU3RtdChudWxsLCBbU3RtdE1vZGlmaWVyLkZpbmFsXSk7XG4gICAgICAgICAgdmFyIHN0bXRzID0gW2luamVjdG9yQ2xhc3MsIG5nTW9kdWxlRmFjdG9yeVN0bXRdO1xuICAgICAgICAgIGlmIChuZ01vZHVsZU1ldGEuaWQpIHtcbiAgICAgICAgICAgICAgdmFyIHJlZ2lzdGVyRmFjdG9yeVN0bXQgPSBpbXBvcnRFeHByKHJlc29sdmVJZGVudGlmaWVyKElkZW50aWZpZXJzLlJlZ2lzdGVyTW9kdWxlRmFjdG9yeUZuKSlcbiAgICAgICAgICAgICAgICAgIC5jYWxsRm4oW2xpdGVyYWwobmdNb2R1bGVNZXRhLmlkKSwgdmFyaWFibGUobmdNb2R1bGVGYWN0b3J5VmFyKV0pXG4gICAgICAgICAgICAgICAgICAudG9TdG10KCk7XG4gICAgICAgICAgICAgIHN0bXRzLnB1c2gocmVnaXN0ZXJGYWN0b3J5U3RtdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuZXcgTmdNb2R1bGVDb21waWxlUmVzdWx0KHN0bXRzLCBuZ01vZHVsZUZhY3RvcnlWYXIsIGRlcHMpO1xuICAgICAgfTtcbiAgICAgIE5nTW9kdWxlQ29tcGlsZXIuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0YWJsZSB9LFxuICAgICAgXTtcbiAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgTmdNb2R1bGVDb21waWxlci5jdG9yUGFyYW1ldGVycyA9IFtdO1xuICAgICAgcmV0dXJuIE5nTW9kdWxlQ29tcGlsZXI7XG4gIH0oKSk7XG4gIHZhciBfSW5qZWN0b3JCdWlsZGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIF9JbmplY3RvckJ1aWxkZXIoX25nTW9kdWxlTWV0YSwgX2VudHJ5Q29tcG9uZW50RmFjdG9yaWVzLCBfYm9vdHN0cmFwQ29tcG9uZW50RmFjdG9yaWVzLCBfc291cmNlU3Bhbikge1xuICAgICAgICAgIHRoaXMuX25nTW9kdWxlTWV0YSA9IF9uZ01vZHVsZU1ldGE7XG4gICAgICAgICAgdGhpcy5fZW50cnlDb21wb25lbnRGYWN0b3JpZXMgPSBfZW50cnlDb21wb25lbnRGYWN0b3JpZXM7XG4gICAgICAgICAgdGhpcy5fYm9vdHN0cmFwQ29tcG9uZW50RmFjdG9yaWVzID0gX2Jvb3RzdHJhcENvbXBvbmVudEZhY3RvcmllcztcbiAgICAgICAgICB0aGlzLl9zb3VyY2VTcGFuID0gX3NvdXJjZVNwYW47XG4gICAgICAgICAgdGhpcy5maWVsZHMgPSBbXTtcbiAgICAgICAgICB0aGlzLmdldHRlcnMgPSBbXTtcbiAgICAgICAgICB0aGlzLm1ldGhvZHMgPSBbXTtcbiAgICAgICAgICB0aGlzLmN0b3JTdG10cyA9IFtdO1xuICAgICAgICAgIHRoaXMuX3Rva2VucyA9IFtdO1xuICAgICAgICAgIHRoaXMuX2luc3RhbmNlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICB0aGlzLl9jcmVhdGVTdG10cyA9IFtdO1xuICAgICAgICAgIHRoaXMuX2Rlc3Ryb3lTdG10cyA9IFtdO1xuICAgICAgfVxuICAgICAgX0luamVjdG9yQnVpbGRlci5wcm90b3R5cGUuYWRkUHJvdmlkZXIgPSBmdW5jdGlvbiAocmVzb2x2ZWRQcm92aWRlcikge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgdmFyIHByb3ZpZGVyVmFsdWVFeHByZXNzaW9ucyA9IHJlc29sdmVkUHJvdmlkZXIucHJvdmlkZXJzLm1hcChmdW5jdGlvbiAocHJvdmlkZXIpIHsgcmV0dXJuIF90aGlzLl9nZXRQcm92aWRlclZhbHVlKHByb3ZpZGVyKTsgfSk7XG4gICAgICAgICAgdmFyIHByb3BOYW1lID0gXCJfXCIgKyByZXNvbHZlZFByb3ZpZGVyLnRva2VuLm5hbWUgKyBcIl9cIiArIHRoaXMuX2luc3RhbmNlcy5zaXplO1xuICAgICAgICAgIHZhciBpbnN0YW5jZSA9IHRoaXMuX2NyZWF0ZVByb3ZpZGVyUHJvcGVydHkocHJvcE5hbWUsIHJlc29sdmVkUHJvdmlkZXIsIHByb3ZpZGVyVmFsdWVFeHByZXNzaW9ucywgcmVzb2x2ZWRQcm92aWRlci5tdWx0aVByb3ZpZGVyLCByZXNvbHZlZFByb3ZpZGVyLmVhZ2VyKTtcbiAgICAgICAgICBpZiAocmVzb2x2ZWRQcm92aWRlci5saWZlY3ljbGVIb29rcy5pbmRleE9mKExpZmVjeWNsZUhvb2tzLk9uRGVzdHJveSkgIT09IC0xKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2Rlc3Ryb3lTdG10cy5wdXNoKGluc3RhbmNlLmNhbGxNZXRob2QoJ25nT25EZXN0cm95JywgW10pLnRvU3RtdCgpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fdG9rZW5zLnB1c2gocmVzb2x2ZWRQcm92aWRlci50b2tlbik7XG4gICAgICAgICAgdGhpcy5faW5zdGFuY2VzLnNldChyZXNvbHZlZFByb3ZpZGVyLnRva2VuLnJlZmVyZW5jZSwgaW5zdGFuY2UpO1xuICAgICAgfTtcbiAgICAgIF9JbmplY3RvckJ1aWxkZXIucHJvdG90eXBlLmJ1aWxkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgdmFyIGdldE1ldGhvZFN0bXRzID0gdGhpcy5fdG9rZW5zLm1hcChmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgICAgICAgICAgdmFyIHByb3ZpZGVyRXhwciA9IF90aGlzLl9pbnN0YW5jZXMuZ2V0KHRva2VuLnJlZmVyZW5jZSk7XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgSWZTdG10KEluamVjdE1ldGhvZFZhcnMkMS50b2tlbi5pZGVudGljYWwoY3JlYXRlRGlUb2tlbkV4cHJlc3Npb24odG9rZW4pKSwgW25ldyBSZXR1cm5TdGF0ZW1lbnQocHJvdmlkZXJFeHByKV0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHZhciBtZXRob2RzID0gW1xuICAgICAgICAgICAgICBuZXcgQ2xhc3NNZXRob2QoJ2NyZWF0ZUludGVybmFsJywgW10sIHRoaXMuX2NyZWF0ZVN0bXRzLmNvbmNhdChuZXcgUmV0dXJuU3RhdGVtZW50KHRoaXMuX2luc3RhbmNlcy5nZXQodGhpcy5fbmdNb2R1bGVNZXRhLnR5cGUucmVmZXJlbmNlKSkpLCBpbXBvcnRUeXBlKHRoaXMuX25nTW9kdWxlTWV0YS50eXBlKSksXG4gICAgICAgICAgICAgIG5ldyBDbGFzc01ldGhvZCgnZ2V0SW50ZXJuYWwnLCBbXG4gICAgICAgICAgICAgICAgICBuZXcgRm5QYXJhbShJbmplY3RNZXRob2RWYXJzJDEudG9rZW4ubmFtZSwgRFlOQU1JQ19UWVBFKSxcbiAgICAgICAgICAgICAgICAgIG5ldyBGblBhcmFtKEluamVjdE1ldGhvZFZhcnMkMS5ub3RGb3VuZFJlc3VsdC5uYW1lLCBEWU5BTUlDX1RZUEUpXG4gICAgICAgICAgICAgIF0sIGdldE1ldGhvZFN0bXRzLmNvbmNhdChbbmV3IFJldHVyblN0YXRlbWVudChJbmplY3RNZXRob2RWYXJzJDEubm90Rm91bmRSZXN1bHQpXSksIERZTkFNSUNfVFlQRSksXG4gICAgICAgICAgICAgIG5ldyBDbGFzc01ldGhvZCgnZGVzdHJveUludGVybmFsJywgW10sIHRoaXMuX2Rlc3Ryb3lTdG10cyksXG4gICAgICAgICAgXTtcbiAgICAgICAgICB2YXIgcGFyZW50QXJncyA9IFtcbiAgICAgICAgICAgICAgdmFyaWFibGUoSW5qZWN0b3JQcm9wcy5wYXJlbnQubmFtZSksXG4gICAgICAgICAgICAgIGxpdGVyYWxBcnIodGhpcy5fZW50cnlDb21wb25lbnRGYWN0b3JpZXMubWFwKGZ1bmN0aW9uIChjb21wb25lbnRGYWN0b3J5KSB7IHJldHVybiBpbXBvcnRFeHByKGNvbXBvbmVudEZhY3RvcnkpOyB9KSksXG4gICAgICAgICAgICAgIGxpdGVyYWxBcnIodGhpcy5fYm9vdHN0cmFwQ29tcG9uZW50RmFjdG9yaWVzLm1hcChmdW5jdGlvbiAoY29tcG9uZW50RmFjdG9yeSkgeyByZXR1cm4gaW1wb3J0RXhwcihjb21wb25lbnRGYWN0b3J5KTsgfSkpXG4gICAgICAgICAgXTtcbiAgICAgICAgICB2YXIgaW5qQ2xhc3NOYW1lID0gdGhpcy5fbmdNb2R1bGVNZXRhLnR5cGUubmFtZSArIFwiSW5qZWN0b3JcIjtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlQ2xhc3NTdG10KHtcbiAgICAgICAgICAgICAgbmFtZTogaW5qQ2xhc3NOYW1lLFxuICAgICAgICAgICAgICBjdG9yUGFyYW1zOiBbbmV3IEZuUGFyYW0oSW5qZWN0b3JQcm9wcy5wYXJlbnQubmFtZSwgaW1wb3J0VHlwZShyZXNvbHZlSWRlbnRpZmllcihJZGVudGlmaWVycy5JbmplY3RvcikpKV0sXG4gICAgICAgICAgICAgIHBhcmVudDogaW1wb3J0RXhwcihyZXNvbHZlSWRlbnRpZmllcihJZGVudGlmaWVycy5OZ01vZHVsZUluamVjdG9yKSwgW2ltcG9ydFR5cGUodGhpcy5fbmdNb2R1bGVNZXRhLnR5cGUpXSksXG4gICAgICAgICAgICAgIHBhcmVudEFyZ3M6IHBhcmVudEFyZ3MsXG4gICAgICAgICAgICAgIGJ1aWxkZXJzOiBbeyBtZXRob2RzOiBtZXRob2RzIH0sIHRoaXNdXG4gICAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgX0luamVjdG9yQnVpbGRlci5wcm90b3R5cGUuX2dldFByb3ZpZGVyVmFsdWUgPSBmdW5jdGlvbiAocHJvdmlkZXIpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgICAgaWYgKGlzUHJlc2VudChwcm92aWRlci51c2VFeGlzdGluZykpIHtcbiAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5fZ2V0RGVwZW5kZW5jeShuZXcgQ29tcGlsZURpRGVwZW5kZW5jeU1ldGFkYXRhKHsgdG9rZW46IHByb3ZpZGVyLnVzZUV4aXN0aW5nIH0pKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoaXNQcmVzZW50KHByb3ZpZGVyLnVzZUZhY3RvcnkpKSB7XG4gICAgICAgICAgICAgIHZhciBkZXBzID0gcHJvdmlkZXIuZGVwcyB8fCBwcm92aWRlci51c2VGYWN0b3J5LmRpRGVwcztcbiAgICAgICAgICAgICAgdmFyIGRlcHNFeHByID0gZGVwcy5tYXAoZnVuY3Rpb24gKGRlcCkgeyByZXR1cm4gX3RoaXMuX2dldERlcGVuZGVuY3koZGVwKTsgfSk7XG4gICAgICAgICAgICAgIHJlc3VsdCA9IGltcG9ydEV4cHIocHJvdmlkZXIudXNlRmFjdG9yeSkuY2FsbEZuKGRlcHNFeHByKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoaXNQcmVzZW50KHByb3ZpZGVyLnVzZUNsYXNzKSkge1xuICAgICAgICAgICAgICB2YXIgZGVwcyA9IHByb3ZpZGVyLmRlcHMgfHwgcHJvdmlkZXIudXNlQ2xhc3MuZGlEZXBzO1xuICAgICAgICAgICAgICB2YXIgZGVwc0V4cHIgPSBkZXBzLm1hcChmdW5jdGlvbiAoZGVwKSB7IHJldHVybiBfdGhpcy5fZ2V0RGVwZW5kZW5jeShkZXApOyB9KTtcbiAgICAgICAgICAgICAgcmVzdWx0ID1cbiAgICAgICAgICAgICAgICAgIGltcG9ydEV4cHIocHJvdmlkZXIudXNlQ2xhc3MpLmluc3RhbnRpYXRlKGRlcHNFeHByLCBpbXBvcnRUeXBlKHByb3ZpZGVyLnVzZUNsYXNzKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICByZXN1bHQgPSBjb252ZXJ0VmFsdWVUb091dHB1dEFzdChwcm92aWRlci51c2VWYWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgICAgX0luamVjdG9yQnVpbGRlci5wcm90b3R5cGUuX2NyZWF0ZVByb3ZpZGVyUHJvcGVydHkgPSBmdW5jdGlvbiAocHJvcE5hbWUsIHByb3ZpZGVyLCBwcm92aWRlclZhbHVlRXhwcmVzc2lvbnMsIGlzTXVsdGksIGlzRWFnZXIpIHtcbiAgICAgICAgICB2YXIgcmVzb2x2ZWRQcm92aWRlclZhbHVlRXhwcjtcbiAgICAgICAgICB2YXIgdHlwZTtcbiAgICAgICAgICBpZiAoaXNNdWx0aSkge1xuICAgICAgICAgICAgICByZXNvbHZlZFByb3ZpZGVyVmFsdWVFeHByID0gbGl0ZXJhbEFycihwcm92aWRlclZhbHVlRXhwcmVzc2lvbnMpO1xuICAgICAgICAgICAgICB0eXBlID0gbmV3IEFycmF5VHlwZShEWU5BTUlDX1RZUEUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzb2x2ZWRQcm92aWRlclZhbHVlRXhwciA9IHByb3ZpZGVyVmFsdWVFeHByZXNzaW9uc1swXTtcbiAgICAgICAgICAgICAgdHlwZSA9IHByb3ZpZGVyVmFsdWVFeHByZXNzaW9uc1swXS50eXBlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXR5cGUpIHtcbiAgICAgICAgICAgICAgdHlwZSA9IERZTkFNSUNfVFlQRTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzRWFnZXIpIHtcbiAgICAgICAgICAgICAgdGhpcy5maWVsZHMucHVzaChuZXcgQ2xhc3NGaWVsZChwcm9wTmFtZSwgdHlwZSkpO1xuICAgICAgICAgICAgICB0aGlzLl9jcmVhdGVTdG10cy5wdXNoKFRISVNfRVhQUi5wcm9wKHByb3BOYW1lKS5zZXQocmVzb2x2ZWRQcm92aWRlclZhbHVlRXhwcikudG9TdG10KCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIGludGVybmFsRmllbGQgPSBcIl9cIiArIHByb3BOYW1lO1xuICAgICAgICAgICAgICB0aGlzLmZpZWxkcy5wdXNoKG5ldyBDbGFzc0ZpZWxkKGludGVybmFsRmllbGQsIHR5cGUpKTtcbiAgICAgICAgICAgICAgLy8gTm90ZTogRXF1YWxzIGlzIGltcG9ydGFudCBmb3IgSlMgc28gdGhhdCBpdCBhbHNvIGNoZWNrcyB0aGUgdW5kZWZpbmVkIGNhc2UhXG4gICAgICAgICAgICAgIHZhciBnZXR0ZXJTdG10cyA9IFtcbiAgICAgICAgICAgICAgICAgIG5ldyBJZlN0bXQoVEhJU19FWFBSLnByb3AoaW50ZXJuYWxGaWVsZCkuaXNCbGFuaygpLCBbVEhJU19FWFBSLnByb3AoaW50ZXJuYWxGaWVsZCkuc2V0KHJlc29sdmVkUHJvdmlkZXJWYWx1ZUV4cHIpLnRvU3RtdCgpXSksXG4gICAgICAgICAgICAgICAgICBuZXcgUmV0dXJuU3RhdGVtZW50KFRISVNfRVhQUi5wcm9wKGludGVybmFsRmllbGQpKVxuICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICB0aGlzLmdldHRlcnMucHVzaChuZXcgQ2xhc3NHZXR0ZXIocHJvcE5hbWUsIGdldHRlclN0bXRzLCB0eXBlKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBUSElTX0VYUFIucHJvcChwcm9wTmFtZSk7XG4gICAgICB9O1xuICAgICAgX0luamVjdG9yQnVpbGRlci5wcm90b3R5cGUuX2dldERlcGVuZGVuY3kgPSBmdW5jdGlvbiAoZGVwKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IG51bGw7XG4gICAgICAgICAgaWYgKGRlcC5pc1ZhbHVlKSB7XG4gICAgICAgICAgICAgIHJlc3VsdCA9IGxpdGVyYWwoZGVwLnZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFkZXAuaXNTa2lwU2VsZikge1xuICAgICAgICAgICAgICBpZiAoZGVwLnRva2VuICYmXG4gICAgICAgICAgICAgICAgICAoZGVwLnRva2VuLnJlZmVyZW5jZSA9PT0gcmVzb2x2ZUlkZW50aWZpZXJUb2tlbihJZGVudGlmaWVycy5JbmplY3RvcikucmVmZXJlbmNlIHx8XG4gICAgICAgICAgICAgICAgICAgICAgZGVwLnRva2VuLnJlZmVyZW5jZSA9PT1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZUlkZW50aWZpZXJUb2tlbihJZGVudGlmaWVycy5Db21wb25lbnRGYWN0b3J5UmVzb2x2ZXIpLnJlZmVyZW5jZSkpIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IFRISVNfRVhQUjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5faW5zdGFuY2VzLmdldChkZXAudG9rZW4ucmVmZXJlbmNlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgICB2YXIgYXJncyA9IFtjcmVhdGVEaVRva2VuRXhwcmVzc2lvbihkZXAudG9rZW4pXTtcbiAgICAgICAgICAgICAgaWYgKGRlcC5pc09wdGlvbmFsKSB7XG4gICAgICAgICAgICAgICAgICBhcmdzLnB1c2goTlVMTF9FWFBSKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXN1bHQgPSBJbmplY3RvclByb3BzLnBhcmVudC5jYWxsTWV0aG9kKCdnZXQnLCBhcmdzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgICByZXR1cm4gX0luamVjdG9yQnVpbGRlcjtcbiAgfSgpKTtcbiAgdmFyIEluamVjdG9yUHJvcHMgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gSW5qZWN0b3JQcm9wcygpIHtcbiAgICAgIH1cbiAgICAgIEluamVjdG9yUHJvcHMucGFyZW50ID0gVEhJU19FWFBSLnByb3AoJ3BhcmVudCcpO1xuICAgICAgcmV0dXJuIEluamVjdG9yUHJvcHM7XG4gIH0oKSk7XG4gIHZhciBJbmplY3RNZXRob2RWYXJzJDEgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gSW5qZWN0TWV0aG9kVmFycygpIHtcbiAgICAgIH1cbiAgICAgIEluamVjdE1ldGhvZFZhcnMudG9rZW4gPSB2YXJpYWJsZSgndG9rZW4nKTtcbiAgICAgIEluamVjdE1ldGhvZFZhcnMubm90Rm91bmRSZXN1bHQgPSB2YXJpYWJsZSgnbm90Rm91bmRSZXN1bHQnKTtcbiAgICAgIHJldHVybiBJbmplY3RNZXRob2RWYXJzO1xuICB9KCkpO1xuXG4gIHZhciBfU0lOR0xFX1FVT1RFX0VTQ0FQRV9TVFJJTkdfUkUgPSAvJ3xcXFxcfFxcbnxcXHJ8XFwkL2c7XG4gIHZhciBfTEVHQUxfSURFTlRJRklFUl9SRSA9IC9eWyRBLVpfXVswLTlBLVpfJF0qJC9pO1xuICB2YXIgQ0FUQ0hfRVJST1JfVkFSJDIgPSB2YXJpYWJsZSgnZXJyb3InKTtcbiAgdmFyIENBVENIX1NUQUNLX1ZBUiQyID0gdmFyaWFibGUoJ3N0YWNrJyk7XG4gIHZhciBfRW1pdHRlZExpbmUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gX0VtaXR0ZWRMaW5lKGluZGVudCkge1xuICAgICAgICAgIHRoaXMuaW5kZW50ID0gaW5kZW50O1xuICAgICAgICAgIHRoaXMucGFydHMgPSBbXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfRW1pdHRlZExpbmU7XG4gIH0oKSk7XG4gIHZhciBFbWl0dGVyVmlzaXRvckNvbnRleHQgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gRW1pdHRlclZpc2l0b3JDb250ZXh0KF9leHBvcnRlZFZhcnMsIF9pbmRlbnQpIHtcbiAgICAgICAgICB0aGlzLl9leHBvcnRlZFZhcnMgPSBfZXhwb3J0ZWRWYXJzO1xuICAgICAgICAgIHRoaXMuX2luZGVudCA9IF9pbmRlbnQ7XG4gICAgICAgICAgdGhpcy5fY2xhc3NlcyA9IFtdO1xuICAgICAgICAgIHRoaXMuX2xpbmVzID0gW25ldyBfRW1pdHRlZExpbmUoX2luZGVudCldO1xuICAgICAgfVxuICAgICAgRW1pdHRlclZpc2l0b3JDb250ZXh0LmNyZWF0ZVJvb3QgPSBmdW5jdGlvbiAoZXhwb3J0ZWRWYXJzKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBFbWl0dGVyVmlzaXRvckNvbnRleHQoZXhwb3J0ZWRWYXJzLCAwKTtcbiAgICAgIH07XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRW1pdHRlclZpc2l0b3JDb250ZXh0LnByb3RvdHlwZSwgXCJfY3VycmVudExpbmVcIiwge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fbGluZXNbdGhpcy5fbGluZXMubGVuZ3RoIC0gMV07IH0sXG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgICAgRW1pdHRlclZpc2l0b3JDb250ZXh0LnByb3RvdHlwZS5pc0V4cG9ydGVkVmFyID0gZnVuY3Rpb24gKHZhck5hbWUpIHsgcmV0dXJuIHRoaXMuX2V4cG9ydGVkVmFycy5pbmRleE9mKHZhck5hbWUpICE9PSAtMTsgfTtcbiAgICAgIEVtaXR0ZXJWaXNpdG9yQ29udGV4dC5wcm90b3R5cGUucHJpbnRsbiA9IGZ1bmN0aW9uIChsYXN0UGFydCkge1xuICAgICAgICAgIGlmIChsYXN0UGFydCA9PT0gdm9pZCAwKSB7IGxhc3RQYXJ0ID0gJyc7IH1cbiAgICAgICAgICB0aGlzLnByaW50KGxhc3RQYXJ0LCB0cnVlKTtcbiAgICAgIH07XG4gICAgICBFbWl0dGVyVmlzaXRvckNvbnRleHQucHJvdG90eXBlLmxpbmVJc0VtcHR5ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fY3VycmVudExpbmUucGFydHMubGVuZ3RoID09PSAwOyB9O1xuICAgICAgRW1pdHRlclZpc2l0b3JDb250ZXh0LnByb3RvdHlwZS5wcmludCA9IGZ1bmN0aW9uIChwYXJ0LCBuZXdMaW5lKSB7XG4gICAgICAgICAgaWYgKG5ld0xpbmUgPT09IHZvaWQgMCkgeyBuZXdMaW5lID0gZmFsc2U7IH1cbiAgICAgICAgICBpZiAocGFydC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRMaW5lLnBhcnRzLnB1c2gocGFydCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChuZXdMaW5lKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2xpbmVzLnB1c2gobmV3IF9FbWl0dGVkTGluZSh0aGlzLl9pbmRlbnQpKTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgRW1pdHRlclZpc2l0b3JDb250ZXh0LnByb3RvdHlwZS5yZW1vdmVFbXB0eUxhc3RMaW5lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmICh0aGlzLmxpbmVJc0VtcHR5KCkpIHtcbiAgICAgICAgICAgICAgdGhpcy5fbGluZXMucG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIEVtaXR0ZXJWaXNpdG9yQ29udGV4dC5wcm90b3R5cGUuaW5jSW5kZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoaXMuX2luZGVudCsrO1xuICAgICAgICAgIHRoaXMuX2N1cnJlbnRMaW5lLmluZGVudCA9IHRoaXMuX2luZGVudDtcbiAgICAgIH07XG4gICAgICBFbWl0dGVyVmlzaXRvckNvbnRleHQucHJvdG90eXBlLmRlY0luZGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGlzLl9pbmRlbnQtLTtcbiAgICAgICAgICB0aGlzLl9jdXJyZW50TGluZS5pbmRlbnQgPSB0aGlzLl9pbmRlbnQ7XG4gICAgICB9O1xuICAgICAgRW1pdHRlclZpc2l0b3JDb250ZXh0LnByb3RvdHlwZS5wdXNoQ2xhc3MgPSBmdW5jdGlvbiAoY2xhenopIHsgdGhpcy5fY2xhc3Nlcy5wdXNoKGNsYXp6KTsgfTtcbiAgICAgIEVtaXR0ZXJWaXNpdG9yQ29udGV4dC5wcm90b3R5cGUucG9wQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9jbGFzc2VzLnBvcCgpOyB9O1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEVtaXR0ZXJWaXNpdG9yQ29udGV4dC5wcm90b3R5cGUsIFwiY3VycmVudENsYXNzXCIsIHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NsYXNzZXMubGVuZ3RoID4gMCA/IHRoaXMuX2NsYXNzZXNbdGhpcy5fY2xhc3Nlcy5sZW5ndGggLSAxXSA6IG51bGw7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBFbWl0dGVyVmlzaXRvckNvbnRleHQucHJvdG90eXBlLnRvU291cmNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBsaW5lcyA9IHRoaXMuX2xpbmVzO1xuICAgICAgICAgIGlmIChsaW5lc1tsaW5lcy5sZW5ndGggLSAxXS5wYXJ0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgbGluZXMgPSBsaW5lcy5zbGljZSgwLCBsaW5lcy5sZW5ndGggLSAxKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGxpbmVzXG4gICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgICAgICAgICAgaWYgKGxpbmUucGFydHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jcmVhdGVJbmRlbnQobGluZS5pbmRlbnQpICsgbGluZS5wYXJ0cy5qb2luKCcnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIC5qb2luKCdcXG4nKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gRW1pdHRlclZpc2l0b3JDb250ZXh0O1xuICB9KCkpO1xuICB2YXIgQWJzdHJhY3RFbWl0dGVyVmlzaXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yKF9lc2NhcGVEb2xsYXJJblN0cmluZ3MpIHtcbiAgICAgICAgICB0aGlzLl9lc2NhcGVEb2xsYXJJblN0cmluZ3MgPSBfZXNjYXBlRG9sbGFySW5TdHJpbmdzO1xuICAgICAgfVxuICAgICAgQWJzdHJhY3RFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRFeHByZXNzaW9uU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjdHgpIHtcbiAgICAgICAgICBzdG10LmV4cHIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgICAgY3R4LnByaW50bG4oJzsnKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFJldHVyblN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY3R4KSB7XG4gICAgICAgICAgY3R4LnByaW50KFwicmV0dXJuIFwiKTtcbiAgICAgICAgICBzdG10LnZhbHVlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICAgIGN0eC5wcmludGxuKCc7Jyk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgQWJzdHJhY3RFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRJZlN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY3R4KSB7XG4gICAgICAgICAgY3R4LnByaW50KFwiaWYgKFwiKTtcbiAgICAgICAgICBzdG10LmNvbmRpdGlvbi52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgICBjdHgucHJpbnQoXCIpIHtcIik7XG4gICAgICAgICAgdmFyIGhhc0Vsc2VDYXNlID0gaXNQcmVzZW50KHN0bXQuZmFsc2VDYXNlKSAmJiBzdG10LmZhbHNlQ2FzZS5sZW5ndGggPiAwO1xuICAgICAgICAgIGlmIChzdG10LnRydWVDYXNlLmxlbmd0aCA8PSAxICYmICFoYXNFbHNlQ2FzZSkge1xuICAgICAgICAgICAgICBjdHgucHJpbnQoXCIgXCIpO1xuICAgICAgICAgICAgICB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhzdG10LnRydWVDYXNlLCBjdHgpO1xuICAgICAgICAgICAgICBjdHgucmVtb3ZlRW1wdHlMYXN0TGluZSgpO1xuICAgICAgICAgICAgICBjdHgucHJpbnQoXCIgXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgY3R4LnByaW50bG4oKTtcbiAgICAgICAgICAgICAgY3R4LmluY0luZGVudCgpO1xuICAgICAgICAgICAgICB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhzdG10LnRydWVDYXNlLCBjdHgpO1xuICAgICAgICAgICAgICBjdHguZGVjSW5kZW50KCk7XG4gICAgICAgICAgICAgIGlmIChoYXNFbHNlQ2FzZSkge1xuICAgICAgICAgICAgICAgICAgY3R4LnByaW50bG4oXCJ9IGVsc2Uge1wiKTtcbiAgICAgICAgICAgICAgICAgIGN0eC5pbmNJbmRlbnQoKTtcbiAgICAgICAgICAgICAgICAgIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKHN0bXQuZmFsc2VDYXNlLCBjdHgpO1xuICAgICAgICAgICAgICAgICAgY3R4LmRlY0luZGVudCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGN0eC5wcmludGxuKFwifVwiKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFRocm93U3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjdHgpIHtcbiAgICAgICAgICBjdHgucHJpbnQoXCJ0aHJvdyBcIik7XG4gICAgICAgICAgc3RtdC5lcnJvci52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgICBjdHgucHJpbnRsbihcIjtcIik7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgQWJzdHJhY3RFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRDb21tZW50U3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjdHgpIHtcbiAgICAgICAgICB2YXIgbGluZXMgPSBzdG10LmNvbW1lbnQuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgIGxpbmVzLmZvckVhY2goZnVuY3Rpb24gKGxpbmUpIHsgY3R4LnByaW50bG4oXCIvLyBcIiArIGxpbmUpOyB9KTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFdyaXRlVmFyRXhwciA9IGZ1bmN0aW9uIChleHByLCBjdHgpIHtcbiAgICAgICAgICB2YXIgbGluZVdhc0VtcHR5ID0gY3R4LmxpbmVJc0VtcHR5KCk7XG4gICAgICAgICAgaWYgKCFsaW5lV2FzRW1wdHkpIHtcbiAgICAgICAgICAgICAgY3R4LnByaW50KCcoJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGN0eC5wcmludChleHByLm5hbWUgKyBcIiA9IFwiKTtcbiAgICAgICAgICBleHByLnZhbHVlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICAgIGlmICghbGluZVdhc0VtcHR5KSB7XG4gICAgICAgICAgICAgIGN0eC5wcmludCgnKScpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFdyaXRlS2V5RXhwciA9IGZ1bmN0aW9uIChleHByLCBjdHgpIHtcbiAgICAgICAgICB2YXIgbGluZVdhc0VtcHR5ID0gY3R4LmxpbmVJc0VtcHR5KCk7XG4gICAgICAgICAgaWYgKCFsaW5lV2FzRW1wdHkpIHtcbiAgICAgICAgICAgICAgY3R4LnByaW50KCcoJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGV4cHIucmVjZWl2ZXIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgICAgY3R4LnByaW50KFwiW1wiKTtcbiAgICAgICAgICBleHByLmluZGV4LnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICAgIGN0eC5wcmludChcIl0gPSBcIik7XG4gICAgICAgICAgZXhwci52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgICBpZiAoIWxpbmVXYXNFbXB0eSkge1xuICAgICAgICAgICAgICBjdHgucHJpbnQoJyknKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgQWJzdHJhY3RFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRXcml0ZVByb3BFeHByID0gZnVuY3Rpb24gKGV4cHIsIGN0eCkge1xuICAgICAgICAgIHZhciBsaW5lV2FzRW1wdHkgPSBjdHgubGluZUlzRW1wdHkoKTtcbiAgICAgICAgICBpZiAoIWxpbmVXYXNFbXB0eSkge1xuICAgICAgICAgICAgICBjdHgucHJpbnQoJygnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZXhwci5yZWNlaXZlci52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgICBjdHgucHJpbnQoXCIuXCIgKyBleHByLm5hbWUgKyBcIiA9IFwiKTtcbiAgICAgICAgICBleHByLnZhbHVlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICAgIGlmICghbGluZVdhc0VtcHR5KSB7XG4gICAgICAgICAgICAgIGN0eC5wcmludCgnKScpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEludm9rZU1ldGhvZEV4cHIgPSBmdW5jdGlvbiAoZXhwciwgY3R4KSB7XG4gICAgICAgICAgZXhwci5yZWNlaXZlci52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgICB2YXIgbmFtZSA9IGV4cHIubmFtZTtcbiAgICAgICAgICBpZiAoaXNQcmVzZW50KGV4cHIuYnVpbHRpbikpIHtcbiAgICAgICAgICAgICAgbmFtZSA9IHRoaXMuZ2V0QnVpbHRpbk1ldGhvZE5hbWUoZXhwci5idWlsdGluKTtcbiAgICAgICAgICAgICAgaWYgKGlzQmxhbmsobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgIC8vIHNvbWUgYnVpbHRpbnMganVzdCBtZWFuIHRvIHNraXAgdGhlIGNhbGwuXG4gICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjdHgucHJpbnQoXCIuXCIgKyBuYW1lICsgXCIoXCIpO1xuICAgICAgICAgIHRoaXMudmlzaXRBbGxFeHByZXNzaW9ucyhleHByLmFyZ3MsIGN0eCwgXCIsXCIpO1xuICAgICAgICAgIGN0eC5wcmludChcIilcIik7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgQWJzdHJhY3RFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRJbnZva2VGdW5jdGlvbkV4cHIgPSBmdW5jdGlvbiAoZXhwciwgY3R4KSB7XG4gICAgICAgICAgZXhwci5mbi52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgICBjdHgucHJpbnQoXCIoXCIpO1xuICAgICAgICAgIHRoaXMudmlzaXRBbGxFeHByZXNzaW9ucyhleHByLmFyZ3MsIGN0eCwgJywnKTtcbiAgICAgICAgICBjdHgucHJpbnQoXCIpXCIpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcbiAgICAgIEFic3RyYWN0RW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0UmVhZFZhckV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgICB2YXIgdmFyTmFtZSA9IGFzdC5uYW1lO1xuICAgICAgICAgIGlmIChpc1ByZXNlbnQoYXN0LmJ1aWx0aW4pKSB7XG4gICAgICAgICAgICAgIHN3aXRjaCAoYXN0LmJ1aWx0aW4pIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgQnVpbHRpblZhci5TdXBlcjpcbiAgICAgICAgICAgICAgICAgICAgICB2YXJOYW1lID0gJ3N1cGVyJztcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgQnVpbHRpblZhci5UaGlzOlxuICAgICAgICAgICAgICAgICAgICAgIHZhck5hbWUgPSAndGhpcyc7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIEJ1aWx0aW5WYXIuQ2F0Y2hFcnJvcjpcbiAgICAgICAgICAgICAgICAgICAgICB2YXJOYW1lID0gQ0FUQ0hfRVJST1JfVkFSJDIubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgQnVpbHRpblZhci5DYXRjaFN0YWNrOlxuICAgICAgICAgICAgICAgICAgICAgIHZhck5hbWUgPSBDQVRDSF9TVEFDS19WQVIkMi5uYW1lO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGJ1aWx0aW4gdmFyaWFibGUgXCIgKyBhc3QuYnVpbHRpbik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgY3R4LnByaW50KHZhck5hbWUpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcbiAgICAgIEFic3RyYWN0RW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0SW5zdGFudGlhdGVFeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgICAgY3R4LnByaW50KFwibmV3IFwiKTtcbiAgICAgICAgICBhc3QuY2xhc3NFeHByLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICAgIGN0eC5wcmludChcIihcIik7XG4gICAgICAgICAgdGhpcy52aXNpdEFsbEV4cHJlc3Npb25zKGFzdC5hcmdzLCBjdHgsICcsJyk7XG4gICAgICAgICAgY3R4LnByaW50KFwiKVwiKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdExpdGVyYWxFeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4LCBhYnNlbnRWYWx1ZSkge1xuICAgICAgICAgIGlmIChhYnNlbnRWYWx1ZSA9PT0gdm9pZCAwKSB7IGFic2VudFZhbHVlID0gJ251bGwnOyB9XG4gICAgICAgICAgdmFyIHZhbHVlID0gYXN0LnZhbHVlO1xuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIGN0eC5wcmludChlc2NhcGVJZGVudGlmaWVyKHZhbHVlLCB0aGlzLl9lc2NhcGVEb2xsYXJJblN0cmluZ3MpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoaXNCbGFuayh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgY3R4LnByaW50KGFic2VudFZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGN0eC5wcmludChcIlwiICsgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdENvbmRpdGlvbmFsRXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICAgIGN0eC5wcmludChcIihcIik7XG4gICAgICAgICAgYXN0LmNvbmRpdGlvbi52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgICBjdHgucHJpbnQoJz8gJyk7XG4gICAgICAgICAgYXN0LnRydWVDYXNlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICAgIGN0eC5wcmludCgnOiAnKTtcbiAgICAgICAgICBhc3QuZmFsc2VDYXNlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICAgIGN0eC5wcmludChcIilcIik7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgQWJzdHJhY3RFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXROb3RFeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgICAgY3R4LnByaW50KCchJyk7XG4gICAgICAgICAgYXN0LmNvbmRpdGlvbi52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEJpbmFyeU9wZXJhdG9yRXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICAgIHZhciBvcFN0cjtcbiAgICAgICAgICBzd2l0Y2ggKGFzdC5vcGVyYXRvcikge1xuICAgICAgICAgICAgICBjYXNlIEJpbmFyeU9wZXJhdG9yLkVxdWFsczpcbiAgICAgICAgICAgICAgICAgIG9wU3RyID0gJz09JztcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIEJpbmFyeU9wZXJhdG9yLklkZW50aWNhbDpcbiAgICAgICAgICAgICAgICAgIG9wU3RyID0gJz09PSc7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5Ob3RFcXVhbHM6XG4gICAgICAgICAgICAgICAgICBvcFN0ciA9ICchPSc7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5Ob3RJZGVudGljYWw6XG4gICAgICAgICAgICAgICAgICBvcFN0ciA9ICchPT0nO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgQmluYXJ5T3BlcmF0b3IuQW5kOlxuICAgICAgICAgICAgICAgICAgb3BTdHIgPSAnJiYnO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgQmluYXJ5T3BlcmF0b3IuT3I6XG4gICAgICAgICAgICAgICAgICBvcFN0ciA9ICd8fCc7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5QbHVzOlxuICAgICAgICAgICAgICAgICAgb3BTdHIgPSAnKyc7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5NaW51czpcbiAgICAgICAgICAgICAgICAgIG9wU3RyID0gJy0nO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgQmluYXJ5T3BlcmF0b3IuRGl2aWRlOlxuICAgICAgICAgICAgICAgICAgb3BTdHIgPSAnLyc7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5NdWx0aXBseTpcbiAgICAgICAgICAgICAgICAgIG9wU3RyID0gJyonO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgQmluYXJ5T3BlcmF0b3IuTW9kdWxvOlxuICAgICAgICAgICAgICAgICAgb3BTdHIgPSAnJSc7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5Mb3dlcjpcbiAgICAgICAgICAgICAgICAgIG9wU3RyID0gJzwnO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgQmluYXJ5T3BlcmF0b3IuTG93ZXJFcXVhbHM6XG4gICAgICAgICAgICAgICAgICBvcFN0ciA9ICc8PSc7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5CaWdnZXI6XG4gICAgICAgICAgICAgICAgICBvcFN0ciA9ICc+JztcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIEJpbmFyeU9wZXJhdG9yLkJpZ2dlckVxdWFsczpcbiAgICAgICAgICAgICAgICAgIG9wU3RyID0gJz49JztcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBvcGVyYXRvciBcIiArIGFzdC5vcGVyYXRvcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGN0eC5wcmludChcIihcIik7XG4gICAgICAgICAgYXN0Lmxocy52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgICBjdHgucHJpbnQoXCIgXCIgKyBvcFN0ciArIFwiIFwiKTtcbiAgICAgICAgICBhc3QucmhzLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICAgIGN0eC5wcmludChcIilcIik7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgQWJzdHJhY3RFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRSZWFkUHJvcEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgICBhc3QucmVjZWl2ZXIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgICAgY3R4LnByaW50KFwiLlwiKTtcbiAgICAgICAgICBjdHgucHJpbnQoYXN0Lm5hbWUpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcbiAgICAgIEFic3RyYWN0RW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0UmVhZEtleUV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgICBhc3QucmVjZWl2ZXIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgICAgY3R4LnByaW50KFwiW1wiKTtcbiAgICAgICAgICBhc3QuaW5kZXgudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgICAgY3R4LnByaW50KFwiXVwiKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdExpdGVyYWxBcnJheUV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgICB2YXIgdXNlTmV3TGluZSA9IGFzdC5lbnRyaWVzLmxlbmd0aCA+IDE7XG4gICAgICAgICAgY3R4LnByaW50KFwiW1wiLCB1c2VOZXdMaW5lKTtcbiAgICAgICAgICBjdHguaW5jSW5kZW50KCk7XG4gICAgICAgICAgdGhpcy52aXNpdEFsbEV4cHJlc3Npb25zKGFzdC5lbnRyaWVzLCBjdHgsICcsJywgdXNlTmV3TGluZSk7XG4gICAgICAgICAgY3R4LmRlY0luZGVudCgpO1xuICAgICAgICAgIGN0eC5wcmludChcIl1cIiwgdXNlTmV3TGluZSk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgQWJzdHJhY3RFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRMaXRlcmFsTWFwRXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgdmFyIHVzZU5ld0xpbmUgPSBhc3QuZW50cmllcy5sZW5ndGggPiAxO1xuICAgICAgICAgIGN0eC5wcmludChcIntcIiwgdXNlTmV3TGluZSk7XG4gICAgICAgICAgY3R4LmluY0luZGVudCgpO1xuICAgICAgICAgIHRoaXMudmlzaXRBbGxPYmplY3RzKGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICAgICAgICBjdHgucHJpbnQoZXNjYXBlSWRlbnRpZmllcihlbnRyeVswXSwgX3RoaXMuX2VzY2FwZURvbGxhckluU3RyaW5ncywgZmFsc2UpICsgXCI6IFwiKTtcbiAgICAgICAgICAgICAgZW50cnlbMV0udmlzaXRFeHByZXNzaW9uKF90aGlzLCBjdHgpO1xuICAgICAgICAgIH0sIGFzdC5lbnRyaWVzLCBjdHgsICcsJywgdXNlTmV3TGluZSk7XG4gICAgICAgICAgY3R4LmRlY0luZGVudCgpO1xuICAgICAgICAgIGN0eC5wcmludChcIn1cIiwgdXNlTmV3TGluZSk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgQWJzdHJhY3RFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRBbGxFeHByZXNzaW9ucyA9IGZ1bmN0aW9uIChleHByZXNzaW9ucywgY3R4LCBzZXBhcmF0b3IsIG5ld0xpbmUpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIGlmIChuZXdMaW5lID09PSB2b2lkIDApIHsgbmV3TGluZSA9IGZhbHNlOyB9XG4gICAgICAgICAgdGhpcy52aXNpdEFsbE9iamVjdHMoZnVuY3Rpb24gKGV4cHIpIHsgcmV0dXJuIGV4cHIudmlzaXRFeHByZXNzaW9uKF90aGlzLCBjdHgpOyB9LCBleHByZXNzaW9ucywgY3R4LCBzZXBhcmF0b3IsIG5ld0xpbmUpO1xuICAgICAgfTtcbiAgICAgIEFic3RyYWN0RW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0QWxsT2JqZWN0cyA9IGZ1bmN0aW9uIChoYW5kbGVyLCBleHByZXNzaW9ucywgY3R4LCBzZXBhcmF0b3IsIG5ld0xpbmUpIHtcbiAgICAgICAgICBpZiAobmV3TGluZSA9PT0gdm9pZCAwKSB7IG5ld0xpbmUgPSBmYWxzZTsgfVxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhwcmVzc2lvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICBjdHgucHJpbnQoc2VwYXJhdG9yLCBuZXdMaW5lKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBoYW5kbGVyKGV4cHJlc3Npb25zW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG5ld0xpbmUpIHtcbiAgICAgICAgICAgICAgY3R4LnByaW50bG4oKTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgQWJzdHJhY3RFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRBbGxTdGF0ZW1lbnRzID0gZnVuY3Rpb24gKHN0YXRlbWVudHMsIGN0eCkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgc3RhdGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChzdG10KSB7IHJldHVybiBzdG10LnZpc2l0U3RhdGVtZW50KF90aGlzLCBjdHgpOyB9KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gQWJzdHJhY3RFbWl0dGVyVmlzaXRvcjtcbiAgfSgpKTtcbiAgZnVuY3Rpb24gZXNjYXBlSWRlbnRpZmllcihpbnB1dCwgZXNjYXBlRG9sbGFyLCBhbHdheXNRdW90ZSkge1xuICAgICAgaWYgKGFsd2F5c1F1b3RlID09PSB2b2lkIDApIHsgYWx3YXlzUXVvdGUgPSB0cnVlOyB9XG4gICAgICBpZiAoaXNCbGFuayhpbnB1dCkpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHZhciBib2R5ID0gaW5wdXQucmVwbGFjZShfU0lOR0xFX1FVT1RFX0VTQ0FQRV9TVFJJTkdfUkUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgbWF0Y2ggPSBbXTtcbiAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICBtYXRjaFtfaSAtIDBdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1hdGNoWzBdID09ICckJykge1xuICAgICAgICAgICAgICByZXR1cm4gZXNjYXBlRG9sbGFyID8gJ1xcXFwkJyA6ICckJztcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAobWF0Y2hbMF0gPT0gJ1xcbicpIHtcbiAgICAgICAgICAgICAgcmV0dXJuICdcXFxcbic7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKG1hdGNoWzBdID09ICdcXHInKSB7XG4gICAgICAgICAgICAgIHJldHVybiAnXFxcXHInO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFwiXFxcXFwiICsgbWF0Y2hbMF07XG4gICAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB2YXIgcmVxdWlyZXNRdW90ZXMgPSBhbHdheXNRdW90ZSB8fCAhX0xFR0FMX0lERU5USUZJRVJfUkUudGVzdChib2R5KTtcbiAgICAgIHJldHVybiByZXF1aXJlc1F1b3RlcyA/IFwiJ1wiICsgYm9keSArIFwiJ1wiIDogYm9keTtcbiAgfVxuICBmdW5jdGlvbiBfY3JlYXRlSW5kZW50KGNvdW50KSB7XG4gICAgICB2YXIgcmVzID0gJyc7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgICByZXMgKz0gJyAgJztcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXM7XG4gIH1cblxuICAvKipcbiAgICogQGxpY2Vuc2VcbiAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAqXG4gICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICovXG4gIHZhciBfX2V4dGVuZHMkMTggPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gIH07XG4gIHZhciBfZGVidWdNb2R1bGVVcmwgPSAnYXNzZXQ6Ly9kZWJ1Zy9saWInO1xuICBmdW5jdGlvbiBkZWJ1Z091dHB1dEFzdEFzVHlwZVNjcmlwdChhc3QpIHtcbiAgICAgIHZhciBjb252ZXJ0ZXIgPSBuZXcgX1RzRW1pdHRlclZpc2l0b3IoX2RlYnVnTW9kdWxlVXJsKTtcbiAgICAgIHZhciBjdHggPSBFbWl0dGVyVmlzaXRvckNvbnRleHQuY3JlYXRlUm9vdChbXSk7XG4gICAgICB2YXIgYXN0cyA9IEFycmF5LmlzQXJyYXkoYXN0KSA/IGFzdCA6IFthc3RdO1xuICAgICAgYXN0cy5mb3JFYWNoKGZ1bmN0aW9uIChhc3QpIHtcbiAgICAgICAgICBpZiAoYXN0IGluc3RhbmNlb2YgU3RhdGVtZW50KSB7XG4gICAgICAgICAgICAgIGFzdC52aXNpdFN0YXRlbWVudChjb252ZXJ0ZXIsIGN0eCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKGFzdCBpbnN0YW5jZW9mIEV4cHJlc3Npb24pIHtcbiAgICAgICAgICAgICAgYXN0LnZpc2l0RXhwcmVzc2lvbihjb252ZXJ0ZXIsIGN0eCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKGFzdCBpbnN0YW5jZW9mIFR5cGUkMSkge1xuICAgICAgICAgICAgICBhc3QudmlzaXRUeXBlKGNvbnZlcnRlciwgY3R4KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRvbid0IGtub3cgaG93IHRvIHByaW50IGRlYnVnIGluZm8gZm9yIFwiICsgYXN0KTtcbiAgICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBjdHgudG9Tb3VyY2UoKTtcbiAgfVxuICB2YXIgVHlwZVNjcmlwdEVtaXR0ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gVHlwZVNjcmlwdEVtaXR0ZXIoX2ltcG9ydEdlbmVyYXRvcikge1xuICAgICAgICAgIHRoaXMuX2ltcG9ydEdlbmVyYXRvciA9IF9pbXBvcnRHZW5lcmF0b3I7XG4gICAgICB9XG4gICAgICBUeXBlU2NyaXB0RW1pdHRlci5wcm90b3R5cGUuZW1pdFN0YXRlbWVudHMgPSBmdW5jdGlvbiAobW9kdWxlVXJsLCBzdG10cywgZXhwb3J0ZWRWYXJzKSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICB2YXIgY29udmVydGVyID0gbmV3IF9Uc0VtaXR0ZXJWaXNpdG9yKG1vZHVsZVVybCk7XG4gICAgICAgICAgdmFyIGN0eCA9IEVtaXR0ZXJWaXNpdG9yQ29udGV4dC5jcmVhdGVSb290KGV4cG9ydGVkVmFycyk7XG4gICAgICAgICAgY29udmVydGVyLnZpc2l0QWxsU3RhdGVtZW50cyhzdG10cywgY3R4KTtcbiAgICAgICAgICB2YXIgc3JjUGFydHMgPSBbXTtcbiAgICAgICAgICBjb252ZXJ0ZXIuaW1wb3J0c1dpdGhQcmVmaXhlcy5mb3JFYWNoKGZ1bmN0aW9uIChwcmVmaXgsIGltcG9ydGVkTW9kdWxlVXJsKSB7XG4gICAgICAgICAgICAgIC8vIE5vdGU6IGNhbid0IHdyaXRlIHRoZSByZWFsIHdvcmQgZm9yIGltcG9ydCBhcyBpdCBzY3Jld3MgdXAgc3lzdGVtLmpzIGF1dG8gZGV0ZWN0aW9uLi4uXG4gICAgICAgICAgICAgIHNyY1BhcnRzLnB1c2goXCJpbXBcIiArXG4gICAgICAgICAgICAgICAgICAoXCJvcnQgKiBhcyBcIiArIHByZWZpeCArIFwiIGZyb20gJ1wiICsgX3RoaXMuX2ltcG9ydEdlbmVyYXRvci5nZXRJbXBvcnRQYXRoKG1vZHVsZVVybCwgaW1wb3J0ZWRNb2R1bGVVcmwpICsgXCInO1wiKSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc3JjUGFydHMucHVzaChjdHgudG9Tb3VyY2UoKSk7XG4gICAgICAgICAgcmV0dXJuIHNyY1BhcnRzLmpvaW4oJ1xcbicpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBUeXBlU2NyaXB0RW1pdHRlcjtcbiAgfSgpKTtcbiAgdmFyIF9Uc0VtaXR0ZXJWaXNpdG9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQxOChfVHNFbWl0dGVyVmlzaXRvciwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIF9Uc0VtaXR0ZXJWaXNpdG9yKF9tb2R1bGVVcmwpIHtcbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBmYWxzZSk7XG4gICAgICAgICAgdGhpcy5fbW9kdWxlVXJsID0gX21vZHVsZVVybDtcbiAgICAgICAgICB0aGlzLmltcG9ydHNXaXRoUHJlZml4ZXMgPSBuZXcgTWFwKCk7XG4gICAgICB9XG4gICAgICBfVHNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRUeXBlID0gZnVuY3Rpb24gKHQsIGN0eCwgZGVmYXVsdFR5cGUpIHtcbiAgICAgICAgICBpZiAoZGVmYXVsdFR5cGUgPT09IHZvaWQgMCkgeyBkZWZhdWx0VHlwZSA9ICdhbnknOyB9XG4gICAgICAgICAgaWYgKGlzUHJlc2VudCh0KSkge1xuICAgICAgICAgICAgICB0LnZpc2l0VHlwZSh0aGlzLCBjdHgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgY3R4LnByaW50KGRlZmF1bHRUeXBlKTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgX1RzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0TGl0ZXJhbEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLnZpc2l0TGl0ZXJhbEV4cHIuY2FsbCh0aGlzLCBhc3QsIGN0eCwgJyhudWxsIGFzIGFueSknKTtcbiAgICAgIH07XG4gICAgICAvLyBUZW1wb3Jhcnkgd29ya2Fyb3VuZCB0byBzdXBwb3J0IHN0cmljdE51bGxDaGVjayBlbmFibGVkIGNvbnN1bWVycyBvZiBuZ2MgZW1pdC5cbiAgICAgIC8vIEluIFNOQyBtb2RlLCBbXSBoYXZlIHRoZSB0eXBlIG5ldmVyW10sIHNvIHdlIGNhc3QgaGVyZSB0byBhbnlbXS5cbiAgICAgIC8vIFRPRE86IG5hcnJvdyB0aGUgY2FzdCB0byBhIG1vcmUgZXhwbGljaXQgdHlwZSwgb3IgdXNlIGEgcGF0dGVybiB0aGF0IGRvZXMgbm90XG4gICAgICAvLyBzdGFydCB3aXRoIFtdLmNvbmNhdC4gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIvcHVsbC8xMTg0NlxuICAgICAgX1RzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0TGl0ZXJhbEFycmF5RXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICAgIGlmIChhc3QuZW50cmllcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgY3R4LnByaW50KCcoJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciByZXN1bHQgPSBfc3VwZXIucHJvdG90eXBlLnZpc2l0TGl0ZXJhbEFycmF5RXhwci5jYWxsKHRoaXMsIGFzdCwgY3R4KTtcbiAgICAgICAgICBpZiAoYXN0LmVudHJpZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgIGN0eC5wcmludCgnIGFzIGFueVtdKScpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICAgIF9Uc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEV4dGVybmFsRXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICAgIHRoaXMuX3Zpc2l0SWRlbnRpZmllcihhc3QudmFsdWUsIGFzdC50eXBlUGFyYW1zLCBjdHgpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcbiAgICAgIF9Uc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdERlY2xhcmVWYXJTdG10ID0gZnVuY3Rpb24gKHN0bXQsIGN0eCkge1xuICAgICAgICAgIGlmIChjdHguaXNFeHBvcnRlZFZhcihzdG10Lm5hbWUpKSB7XG4gICAgICAgICAgICAgIGN0eC5wcmludChcImV4cG9ydCBcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzdG10Lmhhc01vZGlmaWVyKFN0bXRNb2RpZmllci5GaW5hbCkpIHtcbiAgICAgICAgICAgICAgY3R4LnByaW50KFwiY29uc3RcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBjdHgucHJpbnQoXCJ2YXJcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGN0eC5wcmludChcIiBcIiArIHN0bXQubmFtZSArIFwiOlwiKTtcbiAgICAgICAgICB0aGlzLnZpc2l0VHlwZShzdG10LnR5cGUsIGN0eCk7XG4gICAgICAgICAgY3R4LnByaW50KFwiID0gXCIpO1xuICAgICAgICAgIHN0bXQudmFsdWUudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgICAgY3R4LnByaW50bG4oXCI7XCIpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcbiAgICAgIF9Uc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdENhc3RFeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgICAgY3R4LnByaW50KFwiKDxcIik7XG4gICAgICAgICAgYXN0LnR5cGUudmlzaXRUeXBlKHRoaXMsIGN0eCk7XG4gICAgICAgICAgY3R4LnByaW50KFwiPlwiKTtcbiAgICAgICAgICBhc3QudmFsdWUudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgICAgY3R4LnByaW50KFwiKVwiKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICBfVHNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXREZWNsYXJlQ2xhc3NTdG10ID0gZnVuY3Rpb24gKHN0bXQsIGN0eCkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgY3R4LnB1c2hDbGFzcyhzdG10KTtcbiAgICAgICAgICBpZiAoY3R4LmlzRXhwb3J0ZWRWYXIoc3RtdC5uYW1lKSkge1xuICAgICAgICAgICAgICBjdHgucHJpbnQoXCJleHBvcnQgXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjdHgucHJpbnQoXCJjbGFzcyBcIiArIHN0bXQubmFtZSk7XG4gICAgICAgICAgaWYgKGlzUHJlc2VudChzdG10LnBhcmVudCkpIHtcbiAgICAgICAgICAgICAgY3R4LnByaW50KFwiIGV4dGVuZHMgXCIpO1xuICAgICAgICAgICAgICBzdG10LnBhcmVudC52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY3R4LnByaW50bG4oXCIge1wiKTtcbiAgICAgICAgICBjdHguaW5jSW5kZW50KCk7XG4gICAgICAgICAgc3RtdC5maWVsZHMuZm9yRWFjaChmdW5jdGlvbiAoZmllbGQpIHsgcmV0dXJuIF90aGlzLl92aXNpdENsYXNzRmllbGQoZmllbGQsIGN0eCk7IH0pO1xuICAgICAgICAgIGlmIChpc1ByZXNlbnQoc3RtdC5jb25zdHJ1Y3Rvck1ldGhvZCkpIHtcbiAgICAgICAgICAgICAgdGhpcy5fdmlzaXRDbGFzc0NvbnN0cnVjdG9yKHN0bXQsIGN0eCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0bXQuZ2V0dGVycy5mb3JFYWNoKGZ1bmN0aW9uIChnZXR0ZXIpIHsgcmV0dXJuIF90aGlzLl92aXNpdENsYXNzR2V0dGVyKGdldHRlciwgY3R4KTsgfSk7XG4gICAgICAgICAgc3RtdC5tZXRob2RzLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkgeyByZXR1cm4gX3RoaXMuX3Zpc2l0Q2xhc3NNZXRob2QobWV0aG9kLCBjdHgpOyB9KTtcbiAgICAgICAgICBjdHguZGVjSW5kZW50KCk7XG4gICAgICAgICAgY3R4LnByaW50bG4oXCJ9XCIpO1xuICAgICAgICAgIGN0eC5wb3BDbGFzcygpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcbiAgICAgIF9Uc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS5fdmlzaXRDbGFzc0ZpZWxkID0gZnVuY3Rpb24gKGZpZWxkLCBjdHgpIHtcbiAgICAgICAgICBpZiAoZmllbGQuaGFzTW9kaWZpZXIoU3RtdE1vZGlmaWVyLlByaXZhdGUpKSB7XG4gICAgICAgICAgICAgIC8vIGNvbW1lbnQgb3V0IGFzIGEgd29ya2Fyb3VuZCBmb3IgIzEwOTY3XG4gICAgICAgICAgICAgIGN0eC5wcmludChcIi8qcHJpdmF0ZSovIFwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY3R4LnByaW50KGZpZWxkLm5hbWUpO1xuICAgICAgICAgIGN0eC5wcmludCgnOicpO1xuICAgICAgICAgIHRoaXMudmlzaXRUeXBlKGZpZWxkLnR5cGUsIGN0eCk7XG4gICAgICAgICAgY3R4LnByaW50bG4oXCI7XCIpO1xuICAgICAgfTtcbiAgICAgIF9Uc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS5fdmlzaXRDbGFzc0dldHRlciA9IGZ1bmN0aW9uIChnZXR0ZXIsIGN0eCkge1xuICAgICAgICAgIGlmIChnZXR0ZXIuaGFzTW9kaWZpZXIoU3RtdE1vZGlmaWVyLlByaXZhdGUpKSB7XG4gICAgICAgICAgICAgIGN0eC5wcmludChcInByaXZhdGUgXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjdHgucHJpbnQoXCJnZXQgXCIgKyBnZXR0ZXIubmFtZSArIFwiKClcIik7XG4gICAgICAgICAgY3R4LnByaW50KCc6Jyk7XG4gICAgICAgICAgdGhpcy52aXNpdFR5cGUoZ2V0dGVyLnR5cGUsIGN0eCk7XG4gICAgICAgICAgY3R4LnByaW50bG4oXCIge1wiKTtcbiAgICAgICAgICBjdHguaW5jSW5kZW50KCk7XG4gICAgICAgICAgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoZ2V0dGVyLmJvZHksIGN0eCk7XG4gICAgICAgICAgY3R4LmRlY0luZGVudCgpO1xuICAgICAgICAgIGN0eC5wcmludGxuKFwifVwiKTtcbiAgICAgIH07XG4gICAgICBfVHNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUuX3Zpc2l0Q2xhc3NDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uIChzdG10LCBjdHgpIHtcbiAgICAgICAgICBjdHgucHJpbnQoXCJjb25zdHJ1Y3RvcihcIik7XG4gICAgICAgICAgdGhpcy5fdmlzaXRQYXJhbXMoc3RtdC5jb25zdHJ1Y3Rvck1ldGhvZC5wYXJhbXMsIGN0eCk7XG4gICAgICAgICAgY3R4LnByaW50bG4oXCIpIHtcIik7XG4gICAgICAgICAgY3R4LmluY0luZGVudCgpO1xuICAgICAgICAgIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKHN0bXQuY29uc3RydWN0b3JNZXRob2QuYm9keSwgY3R4KTtcbiAgICAgICAgICBjdHguZGVjSW5kZW50KCk7XG4gICAgICAgICAgY3R4LnByaW50bG4oXCJ9XCIpO1xuICAgICAgfTtcbiAgICAgIF9Uc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS5fdmlzaXRDbGFzc01ldGhvZCA9IGZ1bmN0aW9uIChtZXRob2QsIGN0eCkge1xuICAgICAgICAgIGlmIChtZXRob2QuaGFzTW9kaWZpZXIoU3RtdE1vZGlmaWVyLlByaXZhdGUpKSB7XG4gICAgICAgICAgICAgIGN0eC5wcmludChcInByaXZhdGUgXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjdHgucHJpbnQobWV0aG9kLm5hbWUgKyBcIihcIik7XG4gICAgICAgICAgdGhpcy5fdmlzaXRQYXJhbXMobWV0aG9kLnBhcmFtcywgY3R4KTtcbiAgICAgICAgICBjdHgucHJpbnQoXCIpOlwiKTtcbiAgICAgICAgICB0aGlzLnZpc2l0VHlwZShtZXRob2QudHlwZSwgY3R4LCAndm9pZCcpO1xuICAgICAgICAgIGN0eC5wcmludGxuKFwiIHtcIik7XG4gICAgICAgICAgY3R4LmluY0luZGVudCgpO1xuICAgICAgICAgIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKG1ldGhvZC5ib2R5LCBjdHgpO1xuICAgICAgICAgIGN0eC5kZWNJbmRlbnQoKTtcbiAgICAgICAgICBjdHgucHJpbnRsbihcIn1cIik7XG4gICAgICB9O1xuICAgICAgX1RzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0RnVuY3Rpb25FeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgICAgY3R4LnByaW50KFwiKFwiKTtcbiAgICAgICAgICB0aGlzLl92aXNpdFBhcmFtcyhhc3QucGFyYW1zLCBjdHgpO1xuICAgICAgICAgIGN0eC5wcmludChcIik6XCIpO1xuICAgICAgICAgIHRoaXMudmlzaXRUeXBlKGFzdC50eXBlLCBjdHgsICd2b2lkJyk7XG4gICAgICAgICAgY3R4LnByaW50bG4oXCIgPT4ge1wiKTtcbiAgICAgICAgICBjdHguaW5jSW5kZW50KCk7XG4gICAgICAgICAgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoYXN0LnN0YXRlbWVudHMsIGN0eCk7XG4gICAgICAgICAgY3R4LmRlY0luZGVudCgpO1xuICAgICAgICAgIGN0eC5wcmludChcIn1cIik7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgX1RzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0RGVjbGFyZUZ1bmN0aW9uU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjdHgpIHtcbiAgICAgICAgICBpZiAoY3R4LmlzRXhwb3J0ZWRWYXIoc3RtdC5uYW1lKSkge1xuICAgICAgICAgICAgICBjdHgucHJpbnQoXCJleHBvcnQgXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjdHgucHJpbnQoXCJmdW5jdGlvbiBcIiArIHN0bXQubmFtZSArIFwiKFwiKTtcbiAgICAgICAgICB0aGlzLl92aXNpdFBhcmFtcyhzdG10LnBhcmFtcywgY3R4KTtcbiAgICAgICAgICBjdHgucHJpbnQoXCIpOlwiKTtcbiAgICAgICAgICB0aGlzLnZpc2l0VHlwZShzdG10LnR5cGUsIGN0eCwgJ3ZvaWQnKTtcbiAgICAgICAgICBjdHgucHJpbnRsbihcIiB7XCIpO1xuICAgICAgICAgIGN0eC5pbmNJbmRlbnQoKTtcbiAgICAgICAgICB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhzdG10LnN0YXRlbWVudHMsIGN0eCk7XG4gICAgICAgICAgY3R4LmRlY0luZGVudCgpO1xuICAgICAgICAgIGN0eC5wcmludGxuKFwifVwiKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICBfVHNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRUcnlDYXRjaFN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY3R4KSB7XG4gICAgICAgICAgY3R4LnByaW50bG4oXCJ0cnkge1wiKTtcbiAgICAgICAgICBjdHguaW5jSW5kZW50KCk7XG4gICAgICAgICAgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoc3RtdC5ib2R5U3RtdHMsIGN0eCk7XG4gICAgICAgICAgY3R4LmRlY0luZGVudCgpO1xuICAgICAgICAgIGN0eC5wcmludGxuKFwifSBjYXRjaCAoXCIgKyBDQVRDSF9FUlJPUl9WQVIkMi5uYW1lICsgXCIpIHtcIik7XG4gICAgICAgICAgY3R4LmluY0luZGVudCgpO1xuICAgICAgICAgIHZhciBjYXRjaFN0bXRzID0gW0NBVENIX1NUQUNLX1ZBUiQyLnNldChDQVRDSF9FUlJPUl9WQVIkMi5wcm9wKCdzdGFjaycpKS50b0RlY2xTdG10KG51bGwsIFtcbiAgICAgICAgICAgICAgICAgIFN0bXRNb2RpZmllci5GaW5hbFxuICAgICAgICAgICAgICBdKV0uY29uY2F0KHN0bXQuY2F0Y2hTdG10cyk7XG4gICAgICAgICAgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoY2F0Y2hTdG10cywgY3R4KTtcbiAgICAgICAgICBjdHguZGVjSW5kZW50KCk7XG4gICAgICAgICAgY3R4LnByaW50bG4oXCJ9XCIpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcbiAgICAgIF9Uc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEJ1aWx0aW50VHlwZSA9IGZ1bmN0aW9uICh0eXBlLCBjdHgpIHtcbiAgICAgICAgICB2YXIgdHlwZVN0cjtcbiAgICAgICAgICBzd2l0Y2ggKHR5cGUubmFtZSkge1xuICAgICAgICAgICAgICBjYXNlIEJ1aWx0aW5UeXBlTmFtZS5Cb29sOlxuICAgICAgICAgICAgICAgICAgdHlwZVN0ciA9ICdib29sZWFuJztcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIEJ1aWx0aW5UeXBlTmFtZS5EeW5hbWljOlxuICAgICAgICAgICAgICAgICAgdHlwZVN0ciA9ICdhbnknO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgQnVpbHRpblR5cGVOYW1lLkZ1bmN0aW9uOlxuICAgICAgICAgICAgICAgICAgdHlwZVN0ciA9ICdGdW5jdGlvbic7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBCdWlsdGluVHlwZU5hbWUuTnVtYmVyOlxuICAgICAgICAgICAgICAgICAgdHlwZVN0ciA9ICdudW1iZXInO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgQnVpbHRpblR5cGVOYW1lLkludDpcbiAgICAgICAgICAgICAgICAgIHR5cGVTdHIgPSAnbnVtYmVyJztcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIEJ1aWx0aW5UeXBlTmFtZS5TdHJpbmc6XG4gICAgICAgICAgICAgICAgICB0eXBlU3RyID0gJ3N0cmluZyc7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIGJ1aWx0aW4gdHlwZSBcIiArIHR5cGUubmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGN0eC5wcmludCh0eXBlU3RyKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICBfVHNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRFeHRlcm5hbFR5cGUgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgICB0aGlzLl92aXNpdElkZW50aWZpZXIoYXN0LnZhbHVlLCBhc3QudHlwZVBhcmFtcywgY3R4KTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICBfVHNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRBcnJheVR5cGUgPSBmdW5jdGlvbiAodHlwZSwgY3R4KSB7XG4gICAgICAgICAgdGhpcy52aXNpdFR5cGUodHlwZS5vZiwgY3R4KTtcbiAgICAgICAgICBjdHgucHJpbnQoXCJbXVwiKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICBfVHNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRNYXBUeXBlID0gZnVuY3Rpb24gKHR5cGUsIGN0eCkge1xuICAgICAgICAgIGN0eC5wcmludChcIntba2V5OiBzdHJpbmddOlwiKTtcbiAgICAgICAgICB0aGlzLnZpc2l0VHlwZSh0eXBlLnZhbHVlVHlwZSwgY3R4KTtcbiAgICAgICAgICBjdHgucHJpbnQoXCJ9XCIpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcbiAgICAgIF9Uc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS5nZXRCdWlsdGluTWV0aG9kTmFtZSA9IGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAgICAgICB2YXIgbmFtZTtcbiAgICAgICAgICBzd2l0Y2ggKG1ldGhvZCkge1xuICAgICAgICAgICAgICBjYXNlIEJ1aWx0aW5NZXRob2QuQ29uY2F0QXJyYXk6XG4gICAgICAgICAgICAgICAgICBuYW1lID0gJ2NvbmNhdCc7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBCdWlsdGluTWV0aG9kLlN1YnNjcmliZU9ic2VydmFibGU6XG4gICAgICAgICAgICAgICAgICBuYW1lID0gJ3N1YnNjcmliZSc7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBCdWlsdGluTWV0aG9kLkJpbmQ6XG4gICAgICAgICAgICAgICAgICBuYW1lID0gJ2JpbmQnO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGJ1aWx0aW4gbWV0aG9kOiBcIiArIG1ldGhvZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgfTtcbiAgICAgIF9Uc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS5fdmlzaXRQYXJhbXMgPSBmdW5jdGlvbiAocGFyYW1zLCBjdHgpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHRoaXMudmlzaXRBbGxPYmplY3RzKGZ1bmN0aW9uIChwYXJhbSkge1xuICAgICAgICAgICAgICBjdHgucHJpbnQocGFyYW0ubmFtZSk7XG4gICAgICAgICAgICAgIGN0eC5wcmludCgnOicpO1xuICAgICAgICAgICAgICBfdGhpcy52aXNpdFR5cGUocGFyYW0udHlwZSwgY3R4KTtcbiAgICAgICAgICB9LCBwYXJhbXMsIGN0eCwgJywnKTtcbiAgICAgIH07XG4gICAgICBfVHNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUuX3Zpc2l0SWRlbnRpZmllciA9IGZ1bmN0aW9uICh2YWx1ZSwgdHlwZVBhcmFtcywgY3R4KSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICBpZiAoaXNCbGFuayh2YWx1ZS5uYW1lKSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnRlcm5hbCBlcnJvcjogdW5rbm93biBpZGVudGlmaWVyIFwiICsgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNQcmVzZW50KHZhbHVlLm1vZHVsZVVybCkgJiYgdmFsdWUubW9kdWxlVXJsICE9IHRoaXMuX21vZHVsZVVybCkge1xuICAgICAgICAgICAgICB2YXIgcHJlZml4ID0gdGhpcy5pbXBvcnRzV2l0aFByZWZpeGVzLmdldCh2YWx1ZS5tb2R1bGVVcmwpO1xuICAgICAgICAgICAgICBpZiAoaXNCbGFuayhwcmVmaXgpKSB7XG4gICAgICAgICAgICAgICAgICBwcmVmaXggPSBcImltcG9ydFwiICsgdGhpcy5pbXBvcnRzV2l0aFByZWZpeGVzLnNpemU7XG4gICAgICAgICAgICAgICAgICB0aGlzLmltcG9ydHNXaXRoUHJlZml4ZXMuc2V0KHZhbHVlLm1vZHVsZVVybCwgcHJlZml4KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjdHgucHJpbnQocHJlZml4ICsgXCIuXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodmFsdWUucmVmZXJlbmNlICYmIHZhbHVlLnJlZmVyZW5jZS5tZW1iZXJzKSB7XG4gICAgICAgICAgICAgIGN0eC5wcmludCh2YWx1ZS5yZWZlcmVuY2UubmFtZSk7XG4gICAgICAgICAgICAgIGN0eC5wcmludCgnLicpO1xuICAgICAgICAgICAgICBjdHgucHJpbnQodmFsdWUucmVmZXJlbmNlLm1lbWJlcnMuam9pbignLicpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGN0eC5wcmludCh2YWx1ZS5uYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzUHJlc2VudCh0eXBlUGFyYW1zKSAmJiB0eXBlUGFyYW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgY3R4LnByaW50KFwiPFwiKTtcbiAgICAgICAgICAgICAgdGhpcy52aXNpdEFsbE9iamVjdHMoZnVuY3Rpb24gKHR5cGUpIHsgcmV0dXJuIHR5cGUudmlzaXRUeXBlKF90aGlzLCBjdHgpOyB9LCB0eXBlUGFyYW1zLCBjdHgsICcsJyk7XG4gICAgICAgICAgICAgIGN0eC5wcmludChcIj5cIik7XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHJldHVybiBfVHNFbWl0dGVyVmlzaXRvcjtcbiAgfShBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yKSk7XG5cbiAgZnVuY3Rpb24gaW50ZXJwcmV0U3RhdGVtZW50cyhzdGF0ZW1lbnRzLCByZXN1bHRWYXIpIHtcbiAgICAgIHZhciBzdG10c1dpdGhSZXR1cm4gPSBzdGF0ZW1lbnRzLmNvbmNhdChbbmV3IFJldHVyblN0YXRlbWVudCh2YXJpYWJsZShyZXN1bHRWYXIpKV0pO1xuICAgICAgdmFyIGN0eCA9IG5ldyBfRXhlY3V0aW9uQ29udGV4dChudWxsLCBudWxsLCBudWxsLCBuZXcgTWFwKCkpO1xuICAgICAgdmFyIHZpc2l0b3IgPSBuZXcgU3RhdGVtZW50SW50ZXJwcmV0ZXIoKTtcbiAgICAgIHZhciByZXN1bHQgPSB2aXNpdG9yLnZpc2l0QWxsU3RhdGVtZW50cyhzdG10c1dpdGhSZXR1cm4sIGN0eCk7XG4gICAgICByZXR1cm4gaXNQcmVzZW50KHJlc3VsdCkgPyByZXN1bHQudmFsdWUgOiBudWxsO1xuICB9XG4gIGZ1bmN0aW9uIF9leGVjdXRlRnVuY3Rpb25TdGF0ZW1lbnRzKHZhck5hbWVzLCB2YXJWYWx1ZXMsIHN0YXRlbWVudHMsIGN0eCwgdmlzaXRvcikge1xuICAgICAgdmFyIGNoaWxkQ3R4ID0gY3R4LmNyZWF0ZUNoaWxkV2lodExvY2FsVmFycygpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YXJOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNoaWxkQ3R4LnZhcnMuc2V0KHZhck5hbWVzW2ldLCB2YXJWYWx1ZXNbaV0pO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9IHZpc2l0b3IudmlzaXRBbGxTdGF0ZW1lbnRzKHN0YXRlbWVudHMsIGNoaWxkQ3R4KTtcbiAgICAgIHJldHVybiBpc1ByZXNlbnQocmVzdWx0KSA/IHJlc3VsdC52YWx1ZSA6IG51bGw7XG4gIH1cbiAgdmFyIF9FeGVjdXRpb25Db250ZXh0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIF9FeGVjdXRpb25Db250ZXh0KHBhcmVudCwgaW5zdGFuY2UsIGNsYXNzTmFtZSwgdmFycykge1xuICAgICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgICAgIHRoaXMuaW5zdGFuY2UgPSBpbnN0YW5jZTtcbiAgICAgICAgICB0aGlzLmNsYXNzTmFtZSA9IGNsYXNzTmFtZTtcbiAgICAgICAgICB0aGlzLnZhcnMgPSB2YXJzO1xuICAgICAgfVxuICAgICAgX0V4ZWN1dGlvbkNvbnRleHQucHJvdG90eXBlLmNyZWF0ZUNoaWxkV2lodExvY2FsVmFycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IF9FeGVjdXRpb25Db250ZXh0KHRoaXMsIHRoaXMuaW5zdGFuY2UsIHRoaXMuY2xhc3NOYW1lLCBuZXcgTWFwKCkpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBfRXhlY3V0aW9uQ29udGV4dDtcbiAgfSgpKTtcbiAgdmFyIFJldHVyblZhbHVlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIFJldHVyblZhbHVlKHZhbHVlKSB7XG4gICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFJldHVyblZhbHVlO1xuICB9KCkpO1xuICBmdW5jdGlvbiBjcmVhdGVEeW5hbWljQ2xhc3MoX2NsYXNzU3RtdCwgX2N0eCwgX3Zpc2l0b3IpIHtcbiAgICAgIHZhciBwcm9wZXJ0eURlc2NyaXB0b3JzID0ge307XG4gICAgICBfY2xhc3NTdG10LmdldHRlcnMuZm9yRWFjaChmdW5jdGlvbiAoZ2V0dGVyKSB7XG4gICAgICAgICAgLy8gTm90ZTogdXNlIGBmdW5jdGlvbmAgaW5zdGVhZCBvZiBhcnJvdyBmdW5jdGlvbiB0byBjYXB0dXJlIGB0aGlzYFxuICAgICAgICAgIHByb3BlcnR5RGVzY3JpcHRvcnNbZ2V0dGVyLm5hbWVdID0ge1xuICAgICAgICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBpbnN0YW5jZUN0eCA9IG5ldyBfRXhlY3V0aW9uQ29udGV4dChfY3R4LCB0aGlzLCBfY2xhc3NTdG10Lm5hbWUsIF9jdHgudmFycyk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gX2V4ZWN1dGVGdW5jdGlvblN0YXRlbWVudHMoW10sIFtdLCBnZXR0ZXIuYm9keSwgaW5zdGFuY2VDdHgsIF92aXNpdG9yKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICB9KTtcbiAgICAgIF9jbGFzc1N0bXQubWV0aG9kcy5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAgICAgICB2YXIgcGFyYW1OYW1lcyA9IG1ldGhvZC5wYXJhbXMubWFwKGZ1bmN0aW9uIChwYXJhbSkgeyByZXR1cm4gcGFyYW0ubmFtZTsgfSk7XG4gICAgICAgICAgLy8gTm90ZTogdXNlIGBmdW5jdGlvbmAgaW5zdGVhZCBvZiBhcnJvdyBmdW5jdGlvbiB0byBjYXB0dXJlIGB0aGlzYFxuICAgICAgICAgIHByb3BlcnR5RGVzY3JpcHRvcnNbbWV0aG9kLm5hbWVdID0ge1xuICAgICAgICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICBhcmdzW19pIC0gMF0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgdmFyIGluc3RhbmNlQ3R4ID0gbmV3IF9FeGVjdXRpb25Db250ZXh0KF9jdHgsIHRoaXMsIF9jbGFzc1N0bXQubmFtZSwgX2N0eC52YXJzKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBfZXhlY3V0ZUZ1bmN0aW9uU3RhdGVtZW50cyhwYXJhbU5hbWVzLCBhcmdzLCBtZXRob2QuYm9keSwgaW5zdGFuY2VDdHgsIF92aXNpdG9yKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICB9KTtcbiAgICAgIHZhciBjdG9yUGFyYW1OYW1lcyA9IF9jbGFzc1N0bXQuY29uc3RydWN0b3JNZXRob2QucGFyYW1zLm1hcChmdW5jdGlvbiAocGFyYW0pIHsgcmV0dXJuIHBhcmFtLm5hbWU7IH0pO1xuICAgICAgLy8gTm90ZTogdXNlIGBmdW5jdGlvbmAgaW5zdGVhZCBvZiBhcnJvdyBmdW5jdGlvbiB0byBjYXB0dXJlIGB0aGlzYFxuICAgICAgdmFyIGN0b3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgIGFyZ3NbX2kgLSAwXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBpbnN0YW5jZUN0eCA9IG5ldyBfRXhlY3V0aW9uQ29udGV4dChfY3R4LCB0aGlzLCBfY2xhc3NTdG10Lm5hbWUsIF9jdHgudmFycyk7XG4gICAgICAgICAgX2NsYXNzU3RtdC5maWVsZHMuZm9yRWFjaChmdW5jdGlvbiAoZmllbGQpIHsgX3RoaXNbZmllbGQubmFtZV0gPSB1bmRlZmluZWQ7IH0pO1xuICAgICAgICAgIF9leGVjdXRlRnVuY3Rpb25TdGF0ZW1lbnRzKGN0b3JQYXJhbU5hbWVzLCBhcmdzLCBfY2xhc3NTdG10LmNvbnN0cnVjdG9yTWV0aG9kLmJvZHksIGluc3RhbmNlQ3R4LCBfdmlzaXRvcik7XG4gICAgICB9O1xuICAgICAgdmFyIHN1cGVyQ2xhc3MgPSBfY2xhc3NTdG10LnBhcmVudCA/IF9jbGFzc1N0bXQucGFyZW50LnZpc2l0RXhwcmVzc2lvbihfdmlzaXRvciwgX2N0eCkgOiBPYmplY3Q7XG4gICAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUsIHByb3BlcnR5RGVzY3JpcHRvcnMpO1xuICAgICAgcmV0dXJuIGN0b3I7XG4gIH1cbiAgdmFyIFN0YXRlbWVudEludGVycHJldGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIFN0YXRlbWVudEludGVycHJldGVyKCkge1xuICAgICAgfVxuICAgICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLmRlYnVnQXN0ID0gZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gZGVidWdPdXRwdXRBc3RBc1R5cGVTY3JpcHQoYXN0KTsgfTtcbiAgICAgIFN0YXRlbWVudEludGVycHJldGVyLnByb3RvdHlwZS52aXNpdERlY2xhcmVWYXJTdG10ID0gZnVuY3Rpb24gKHN0bXQsIGN0eCkge1xuICAgICAgICAgIGN0eC52YXJzLnNldChzdG10Lm5hbWUsIHN0bXQudmFsdWUudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCkpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcbiAgICAgIFN0YXRlbWVudEludGVycHJldGVyLnByb3RvdHlwZS52aXNpdFdyaXRlVmFyRXhwciA9IGZ1bmN0aW9uIChleHByLCBjdHgpIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBleHByLnZhbHVlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICAgIHZhciBjdXJyQ3R4ID0gY3R4O1xuICAgICAgICAgIHdoaWxlIChjdXJyQ3R4ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgaWYgKGN1cnJDdHgudmFycy5oYXMoZXhwci5uYW1lKSkge1xuICAgICAgICAgICAgICAgICAgY3VyckN0eC52YXJzLnNldChleHByLm5hbWUsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjdXJyQ3R4ID0gY3VyckN0eC5wYXJlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBkZWNsYXJlZCB2YXJpYWJsZSBcIiArIGV4cHIubmFtZSk7XG4gICAgICB9O1xuICAgICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0UmVhZFZhckV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgICB2YXIgdmFyTmFtZSA9IGFzdC5uYW1lO1xuICAgICAgICAgIGlmIChpc1ByZXNlbnQoYXN0LmJ1aWx0aW4pKSB7XG4gICAgICAgICAgICAgIHN3aXRjaCAoYXN0LmJ1aWx0aW4pIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgQnVpbHRpblZhci5TdXBlcjpcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3R4Lmluc3RhbmNlLl9fcHJvdG9fXztcbiAgICAgICAgICAgICAgICAgIGNhc2UgQnVpbHRpblZhci5UaGlzOlxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjdHguaW5zdGFuY2U7XG4gICAgICAgICAgICAgICAgICBjYXNlIEJ1aWx0aW5WYXIuQ2F0Y2hFcnJvcjpcbiAgICAgICAgICAgICAgICAgICAgICB2YXJOYW1lID0gQ0FUQ0hfRVJST1JfVkFSJDE7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIEJ1aWx0aW5WYXIuQ2F0Y2hTdGFjazpcbiAgICAgICAgICAgICAgICAgICAgICB2YXJOYW1lID0gQ0FUQ0hfU1RBQ0tfVkFSJDE7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gYnVpbHRpbiB2YXJpYWJsZSBcIiArIGFzdC5idWlsdGluKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgY3VyckN0eCA9IGN0eDtcbiAgICAgICAgICB3aGlsZSAoY3VyckN0eCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIGlmIChjdXJyQ3R4LnZhcnMuaGFzKHZhck5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gY3VyckN0eC52YXJzLmdldCh2YXJOYW1lKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjdXJyQ3R4ID0gY3VyckN0eC5wYXJlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBkZWNsYXJlZCB2YXJpYWJsZSBcIiArIHZhck5hbWUpO1xuICAgICAgfTtcbiAgICAgIFN0YXRlbWVudEludGVycHJldGVyLnByb3RvdHlwZS52aXNpdFdyaXRlS2V5RXhwciA9IGZ1bmN0aW9uIChleHByLCBjdHgpIHtcbiAgICAgICAgICB2YXIgcmVjZWl2ZXIgPSBleHByLnJlY2VpdmVyLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICAgIHZhciBpbmRleCA9IGV4cHIuaW5kZXgudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgICAgdmFyIHZhbHVlID0gZXhwci52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgICByZWNlaXZlcltpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9O1xuICAgICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0V3JpdGVQcm9wRXhwciA9IGZ1bmN0aW9uIChleHByLCBjdHgpIHtcbiAgICAgICAgICB2YXIgcmVjZWl2ZXIgPSBleHByLnJlY2VpdmVyLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICAgIHZhciB2YWx1ZSA9IGV4cHIudmFsdWUudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgICAgcmVjZWl2ZXJbZXhwci5uYW1lXSA9IHZhbHVlO1xuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH07XG4gICAgICBTdGF0ZW1lbnRJbnRlcnByZXRlci5wcm90b3R5cGUudmlzaXRJbnZva2VNZXRob2RFeHByID0gZnVuY3Rpb24gKGV4cHIsIGN0eCkge1xuICAgICAgICAgIHZhciByZWNlaXZlciA9IGV4cHIucmVjZWl2ZXIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgICAgdmFyIGFyZ3MgPSB0aGlzLnZpc2l0QWxsRXhwcmVzc2lvbnMoZXhwci5hcmdzLCBjdHgpO1xuICAgICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgICAgaWYgKGlzUHJlc2VudChleHByLmJ1aWx0aW4pKSB7XG4gICAgICAgICAgICAgIHN3aXRjaCAoZXhwci5idWlsdGluKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIEJ1aWx0aW5NZXRob2QuQ29uY2F0QXJyYXk6XG4gICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVjZWl2ZXIuY29uY2F0KGFyZ3NbMF0pO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBCdWlsdGluTWV0aG9kLlN1YnNjcmliZU9ic2VydmFibGU6XG4gICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVjZWl2ZXIuc3Vic2NyaWJlKHsgbmV4dDogYXJnc1swXSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgQnVpbHRpbk1ldGhvZC5CaW5kOlxuICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlY2VpdmVyLmJpbmQoYXJnc1swXSk7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gYnVpbHRpbiBtZXRob2QgXCIgKyBleHByLmJ1aWx0aW4pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICByZXN1bHQgPSByZWNlaXZlcltleHByLm5hbWVdLmFwcGx5KHJlY2VpdmVyLCBhcmdzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgICBTdGF0ZW1lbnRJbnRlcnByZXRlci5wcm90b3R5cGUudmlzaXRJbnZva2VGdW5jdGlvbkV4cHIgPSBmdW5jdGlvbiAoc3RtdCwgY3R4KSB7XG4gICAgICAgICAgdmFyIGFyZ3MgPSB0aGlzLnZpc2l0QWxsRXhwcmVzc2lvbnMoc3RtdC5hcmdzLCBjdHgpO1xuICAgICAgICAgIHZhciBmbkV4cHIgPSBzdG10LmZuO1xuICAgICAgICAgIGlmIChmbkV4cHIgaW5zdGFuY2VvZiBSZWFkVmFyRXhwciAmJiBmbkV4cHIuYnVpbHRpbiA9PT0gQnVpbHRpblZhci5TdXBlcikge1xuICAgICAgICAgICAgICBjdHguaW5zdGFuY2UuY29uc3RydWN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yLmFwcGx5KGN0eC5pbnN0YW5jZSwgYXJncyk7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIGZuID0gc3RtdC5mbi52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICBTdGF0ZW1lbnRJbnRlcnByZXRlci5wcm90b3R5cGUudmlzaXRSZXR1cm5TdG10ID0gZnVuY3Rpb24gKHN0bXQsIGN0eCkge1xuICAgICAgICAgIHJldHVybiBuZXcgUmV0dXJuVmFsdWUoc3RtdC52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KSk7XG4gICAgICB9O1xuICAgICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0RGVjbGFyZUNsYXNzU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjdHgpIHtcbiAgICAgICAgICB2YXIgY2xhenogPSBjcmVhdGVEeW5hbWljQ2xhc3Moc3RtdCwgY3R4LCB0aGlzKTtcbiAgICAgICAgICBjdHgudmFycy5zZXQoc3RtdC5uYW1lLCBjbGF6eik7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0RXhwcmVzc2lvblN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY3R4KSB7XG4gICAgICAgICAgcmV0dXJuIHN0bXQuZXhwci52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgIH07XG4gICAgICBTdGF0ZW1lbnRJbnRlcnByZXRlci5wcm90b3R5cGUudmlzaXRJZlN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY3R4KSB7XG4gICAgICAgICAgdmFyIGNvbmRpdGlvbiA9IHN0bXQuY29uZGl0aW9uLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICAgIGlmIChjb25kaXRpb24pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKHN0bXQudHJ1ZUNhc2UsIGN0eCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKGlzUHJlc2VudChzdG10LmZhbHNlQ2FzZSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKHN0bXQuZmFsc2VDYXNlLCBjdHgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICBTdGF0ZW1lbnRJbnRlcnByZXRlci5wcm90b3R5cGUudmlzaXRUcnlDYXRjaFN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY3R4KSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKHN0bXQuYm9keVN0bXRzLCBjdHgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICB2YXIgY2hpbGRDdHggPSBjdHguY3JlYXRlQ2hpbGRXaWh0TG9jYWxWYXJzKCk7XG4gICAgICAgICAgICAgIGNoaWxkQ3R4LnZhcnMuc2V0KENBVENIX0VSUk9SX1ZBUiQxLCBlKTtcbiAgICAgICAgICAgICAgY2hpbGRDdHgudmFycy5zZXQoQ0FUQ0hfU1RBQ0tfVkFSJDEsIGUuc3RhY2spO1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoc3RtdC5jYXRjaFN0bXRzLCBjaGlsZEN0eCk7XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIFN0YXRlbWVudEludGVycHJldGVyLnByb3RvdHlwZS52aXNpdFRocm93U3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjdHgpIHtcbiAgICAgICAgICB0aHJvdyBzdG10LmVycm9yLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgfTtcbiAgICAgIFN0YXRlbWVudEludGVycHJldGVyLnByb3RvdHlwZS52aXNpdENvbW1lbnRTdG10ID0gZnVuY3Rpb24gKHN0bXQsIGNvbnRleHQpIHsgcmV0dXJuIG51bGw7IH07XG4gICAgICBTdGF0ZW1lbnRJbnRlcnByZXRlci5wcm90b3R5cGUudmlzaXRJbnN0YW50aWF0ZUV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgICB2YXIgYXJncyA9IHRoaXMudmlzaXRBbGxFeHByZXNzaW9ucyhhc3QuYXJncywgY3R4KTtcbiAgICAgICAgICB2YXIgY2xhenogPSBhc3QuY2xhc3NFeHByLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICAgIHJldHVybiBuZXcgKGNsYXp6LmJpbmQuYXBwbHkoY2xhenosIFt2b2lkIDBdLmNvbmNhdChhcmdzKSkpKCk7XG4gICAgICB9O1xuICAgICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0TGl0ZXJhbEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHsgcmV0dXJuIGFzdC52YWx1ZTsgfTtcbiAgICAgIFN0YXRlbWVudEludGVycHJldGVyLnByb3RvdHlwZS52aXNpdEV4dGVybmFsRXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICAgIHJldHVybiBhc3QudmFsdWUucmVmZXJlbmNlO1xuICAgICAgfTtcbiAgICAgIFN0YXRlbWVudEludGVycHJldGVyLnByb3RvdHlwZS52aXNpdENvbmRpdGlvbmFsRXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICAgIGlmIChhc3QuY29uZGl0aW9uLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBhc3QudHJ1ZUNhc2UudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKGlzUHJlc2VudChhc3QuZmFsc2VDYXNlKSkge1xuICAgICAgICAgICAgICByZXR1cm4gYXN0LmZhbHNlQ2FzZS52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0Tm90RXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICAgIHJldHVybiAhYXN0LmNvbmRpdGlvbi52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgIH07XG4gICAgICBTdGF0ZW1lbnRJbnRlcnByZXRlci5wcm90b3R5cGUudmlzaXRDYXN0RXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICAgIHJldHVybiBhc3QudmFsdWUudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICB9O1xuICAgICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0RnVuY3Rpb25FeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgICAgdmFyIHBhcmFtTmFtZXMgPSBhc3QucGFyYW1zLm1hcChmdW5jdGlvbiAocGFyYW0pIHsgcmV0dXJuIHBhcmFtLm5hbWU7IH0pO1xuICAgICAgICAgIHJldHVybiBfZGVjbGFyZUZuKHBhcmFtTmFtZXMsIGFzdC5zdGF0ZW1lbnRzLCBjdHgsIHRoaXMpO1xuICAgICAgfTtcbiAgICAgIFN0YXRlbWVudEludGVycHJldGVyLnByb3RvdHlwZS52aXNpdERlY2xhcmVGdW5jdGlvblN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY3R4KSB7XG4gICAgICAgICAgdmFyIHBhcmFtTmFtZXMgPSBzdG10LnBhcmFtcy5tYXAoZnVuY3Rpb24gKHBhcmFtKSB7IHJldHVybiBwYXJhbS5uYW1lOyB9KTtcbiAgICAgICAgICBjdHgudmFycy5zZXQoc3RtdC5uYW1lLCBfZGVjbGFyZUZuKHBhcmFtTmFtZXMsIHN0bXQuc3RhdGVtZW50cywgY3R4LCB0aGlzKSk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0QmluYXJ5T3BlcmF0b3JFeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICB2YXIgbGhzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gYXN0Lmxocy52aXNpdEV4cHJlc3Npb24oX3RoaXMsIGN0eCk7IH07XG4gICAgICAgICAgdmFyIHJocyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFzdC5yaHMudmlzaXRFeHByZXNzaW9uKF90aGlzLCBjdHgpOyB9O1xuICAgICAgICAgIHN3aXRjaCAoYXN0Lm9wZXJhdG9yKSB7XG4gICAgICAgICAgICAgIGNhc2UgQmluYXJ5T3BlcmF0b3IuRXF1YWxzOlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGxocygpID09IHJocygpO1xuICAgICAgICAgICAgICBjYXNlIEJpbmFyeU9wZXJhdG9yLklkZW50aWNhbDpcbiAgICAgICAgICAgICAgICAgIHJldHVybiBsaHMoKSA9PT0gcmhzKCk7XG4gICAgICAgICAgICAgIGNhc2UgQmluYXJ5T3BlcmF0b3IuTm90RXF1YWxzOlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGxocygpICE9IHJocygpO1xuICAgICAgICAgICAgICBjYXNlIEJpbmFyeU9wZXJhdG9yLk5vdElkZW50aWNhbDpcbiAgICAgICAgICAgICAgICAgIHJldHVybiBsaHMoKSAhPT0gcmhzKCk7XG4gICAgICAgICAgICAgIGNhc2UgQmluYXJ5T3BlcmF0b3IuQW5kOlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGxocygpICYmIHJocygpO1xuICAgICAgICAgICAgICBjYXNlIEJpbmFyeU9wZXJhdG9yLk9yOlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGxocygpIHx8IHJocygpO1xuICAgICAgICAgICAgICBjYXNlIEJpbmFyeU9wZXJhdG9yLlBsdXM6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbGhzKCkgKyByaHMoKTtcbiAgICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5NaW51czpcbiAgICAgICAgICAgICAgICAgIHJldHVybiBsaHMoKSAtIHJocygpO1xuICAgICAgICAgICAgICBjYXNlIEJpbmFyeU9wZXJhdG9yLkRpdmlkZTpcbiAgICAgICAgICAgICAgICAgIHJldHVybiBsaHMoKSAvIHJocygpO1xuICAgICAgICAgICAgICBjYXNlIEJpbmFyeU9wZXJhdG9yLk11bHRpcGx5OlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGxocygpICogcmhzKCk7XG4gICAgICAgICAgICAgIGNhc2UgQmluYXJ5T3BlcmF0b3IuTW9kdWxvOlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGxocygpICUgcmhzKCk7XG4gICAgICAgICAgICAgIGNhc2UgQmluYXJ5T3BlcmF0b3IuTG93ZXI6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbGhzKCkgPCByaHMoKTtcbiAgICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5Mb3dlckVxdWFsczpcbiAgICAgICAgICAgICAgICAgIHJldHVybiBsaHMoKSA8PSByaHMoKTtcbiAgICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5CaWdnZXI6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbGhzKCkgPiByaHMoKTtcbiAgICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5CaWdnZXJFcXVhbHM6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbGhzKCkgPj0gcmhzKCk7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG9wZXJhdG9yIFwiICsgYXN0Lm9wZXJhdG9yKTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0UmVhZFByb3BFeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgICB2YXIgcmVjZWl2ZXIgPSBhc3QucmVjZWl2ZXIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgICAgcmVzdWx0ID0gcmVjZWl2ZXJbYXN0Lm5hbWVdO1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0UmVhZEtleUV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgICB2YXIgcmVjZWl2ZXIgPSBhc3QucmVjZWl2ZXIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgICAgdmFyIHByb3AgPSBhc3QuaW5kZXgudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgICAgcmV0dXJuIHJlY2VpdmVyW3Byb3BdO1xuICAgICAgfTtcbiAgICAgIFN0YXRlbWVudEludGVycHJldGVyLnByb3RvdHlwZS52aXNpdExpdGVyYWxBcnJheUV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy52aXNpdEFsbEV4cHJlc3Npb25zKGFzdC5lbnRyaWVzLCBjdHgpO1xuICAgICAgfTtcbiAgICAgIFN0YXRlbWVudEludGVycHJldGVyLnByb3RvdHlwZS52aXNpdExpdGVyYWxNYXBFeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgICAgYXN0LmVudHJpZXMuZm9yRWFjaChmdW5jdGlvbiAoZW50cnkpIHsgcmV0dXJuIHJlc3VsdFtlbnRyeVswXV0gPVxuICAgICAgICAgICAgICBlbnRyeVsxXS52aXNpdEV4cHJlc3Npb24oX3RoaXMsIGN0eCk7IH0pO1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0QWxsRXhwcmVzc2lvbnMgPSBmdW5jdGlvbiAoZXhwcmVzc2lvbnMsIGN0eCkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgcmV0dXJuIGV4cHJlc3Npb25zLm1hcChmdW5jdGlvbiAoZXhwcikgeyByZXR1cm4gZXhwci52aXNpdEV4cHJlc3Npb24oX3RoaXMsIGN0eCk7IH0pO1xuICAgICAgfTtcbiAgICAgIFN0YXRlbWVudEludGVycHJldGVyLnByb3RvdHlwZS52aXNpdEFsbFN0YXRlbWVudHMgPSBmdW5jdGlvbiAoc3RhdGVtZW50cywgY3R4KSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGF0ZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIHZhciBzdG10ID0gc3RhdGVtZW50c1tpXTtcbiAgICAgICAgICAgICAgdmFyIHZhbCA9IHN0bXQudmlzaXRTdGF0ZW1lbnQodGhpcywgY3R4KTtcbiAgICAgICAgICAgICAgaWYgKHZhbCBpbnN0YW5jZW9mIFJldHVyblZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBTdGF0ZW1lbnRJbnRlcnByZXRlcjtcbiAgfSgpKTtcbiAgZnVuY3Rpb24gX2RlY2xhcmVGbih2YXJOYW1lcywgc3RhdGVtZW50cywgY3R4LCB2aXNpdG9yKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgYXJnc1tfaSAtIDBdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIF9leGVjdXRlRnVuY3Rpb25TdGF0ZW1lbnRzKHZhck5hbWVzLCBhcmdzLCBzdGF0ZW1lbnRzLCBjdHgsIHZpc2l0b3IpO1xuICAgICAgfTtcbiAgfVxuICB2YXIgQ0FUQ0hfRVJST1JfVkFSJDEgPSAnZXJyb3InO1xuICB2YXIgQ0FUQ0hfU1RBQ0tfVkFSJDEgPSAnc3RhY2snO1xuXG4gIC8qKlxuICAgKiBAbGljZW5zZVxuICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICpcbiAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgKi9cbiAgdmFyIF9fZXh0ZW5kcyQyMCA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgfTtcbiAgdmFyIEFic3RyYWN0SnNFbWl0dGVyVmlzaXRvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkMjAoQWJzdHJhY3RKc0VtaXR0ZXJWaXNpdG9yLCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gQWJzdHJhY3RKc0VtaXR0ZXJWaXNpdG9yKCkge1xuICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGZhbHNlKTtcbiAgICAgIH1cbiAgICAgIEFic3RyYWN0SnNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXREZWNsYXJlQ2xhc3NTdG10ID0gZnVuY3Rpb24gKHN0bXQsIGN0eCkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgY3R4LnB1c2hDbGFzcyhzdG10KTtcbiAgICAgICAgICB0aGlzLl92aXNpdENsYXNzQ29uc3RydWN0b3Ioc3RtdCwgY3R4KTtcbiAgICAgICAgICBpZiAoaXNQcmVzZW50KHN0bXQucGFyZW50KSkge1xuICAgICAgICAgICAgICBjdHgucHJpbnQoc3RtdC5uYW1lICsgXCIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShcIik7XG4gICAgICAgICAgICAgIHN0bXQucGFyZW50LnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICAgICAgICBjdHgucHJpbnRsbihcIi5wcm90b3R5cGUpO1wiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3RtdC5nZXR0ZXJzLmZvckVhY2goZnVuY3Rpb24gKGdldHRlcikgeyByZXR1cm4gX3RoaXMuX3Zpc2l0Q2xhc3NHZXR0ZXIoc3RtdCwgZ2V0dGVyLCBjdHgpOyB9KTtcbiAgICAgICAgICBzdG10Lm1ldGhvZHMuZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7IHJldHVybiBfdGhpcy5fdmlzaXRDbGFzc01ldGhvZChzdG10LCBtZXRob2QsIGN0eCk7IH0pO1xuICAgICAgICAgIGN0eC5wb3BDbGFzcygpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcbiAgICAgIEFic3RyYWN0SnNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUuX3Zpc2l0Q2xhc3NDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uIChzdG10LCBjdHgpIHtcbiAgICAgICAgICBjdHgucHJpbnQoXCJmdW5jdGlvbiBcIiArIHN0bXQubmFtZSArIFwiKFwiKTtcbiAgICAgICAgICBpZiAoaXNQcmVzZW50KHN0bXQuY29uc3RydWN0b3JNZXRob2QpKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3Zpc2l0UGFyYW1zKHN0bXQuY29uc3RydWN0b3JNZXRob2QucGFyYW1zLCBjdHgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjdHgucHJpbnRsbihcIikge1wiKTtcbiAgICAgICAgICBjdHguaW5jSW5kZW50KCk7XG4gICAgICAgICAgaWYgKGlzUHJlc2VudChzdG10LmNvbnN0cnVjdG9yTWV0aG9kKSkge1xuICAgICAgICAgICAgICBpZiAoc3RtdC5jb25zdHJ1Y3Rvck1ldGhvZC5ib2R5Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgIGN0eC5wcmludGxuKFwidmFyIHNlbGYgPSB0aGlzO1wiKTtcbiAgICAgICAgICAgICAgICAgIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKHN0bXQuY29uc3RydWN0b3JNZXRob2QuYm9keSwgY3R4KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjdHguZGVjSW5kZW50KCk7XG4gICAgICAgICAgY3R4LnByaW50bG4oXCJ9XCIpO1xuICAgICAgfTtcbiAgICAgIEFic3RyYWN0SnNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUuX3Zpc2l0Q2xhc3NHZXR0ZXIgPSBmdW5jdGlvbiAoc3RtdCwgZ2V0dGVyLCBjdHgpIHtcbiAgICAgICAgICBjdHgucHJpbnRsbihcIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShcIiArIHN0bXQubmFtZSArIFwiLnByb3RvdHlwZSwgJ1wiICsgZ2V0dGVyLm5hbWUgKyBcIicsIHsgZ2V0OiBmdW5jdGlvbigpIHtcIik7XG4gICAgICAgICAgY3R4LmluY0luZGVudCgpO1xuICAgICAgICAgIGlmIChnZXR0ZXIuYm9keS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIGN0eC5wcmludGxuKFwidmFyIHNlbGYgPSB0aGlzO1wiKTtcbiAgICAgICAgICAgICAgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoZ2V0dGVyLmJvZHksIGN0eCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGN0eC5kZWNJbmRlbnQoKTtcbiAgICAgICAgICBjdHgucHJpbnRsbihcIn19KTtcIik7XG4gICAgICB9O1xuICAgICAgQWJzdHJhY3RKc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS5fdmlzaXRDbGFzc01ldGhvZCA9IGZ1bmN0aW9uIChzdG10LCBtZXRob2QsIGN0eCkge1xuICAgICAgICAgIGN0eC5wcmludChzdG10Lm5hbWUgKyBcIi5wcm90b3R5cGUuXCIgKyBtZXRob2QubmFtZSArIFwiID0gZnVuY3Rpb24oXCIpO1xuICAgICAgICAgIHRoaXMuX3Zpc2l0UGFyYW1zKG1ldGhvZC5wYXJhbXMsIGN0eCk7XG4gICAgICAgICAgY3R4LnByaW50bG4oXCIpIHtcIik7XG4gICAgICAgICAgY3R4LmluY0luZGVudCgpO1xuICAgICAgICAgIGlmIChtZXRob2QuYm9keS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIGN0eC5wcmludGxuKFwidmFyIHNlbGYgPSB0aGlzO1wiKTtcbiAgICAgICAgICAgICAgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMobWV0aG9kLmJvZHksIGN0eCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGN0eC5kZWNJbmRlbnQoKTtcbiAgICAgICAgICBjdHgucHJpbnRsbihcIn07XCIpO1xuICAgICAgfTtcbiAgICAgIEFic3RyYWN0SnNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRSZWFkVmFyRXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICAgIGlmIChhc3QuYnVpbHRpbiA9PT0gQnVpbHRpblZhci5UaGlzKSB7XG4gICAgICAgICAgICAgIGN0eC5wcmludCgnc2VsZicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChhc3QuYnVpbHRpbiA9PT0gQnVpbHRpblZhci5TdXBlcikge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCInc3VwZXInIG5lZWRzIHRvIGJlIGhhbmRsZWQgYXQgYSBwYXJlbnQgYXN0IG5vZGUsIG5vdCBhdCB0aGUgdmFyaWFibGUgbGV2ZWwhXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS52aXNpdFJlYWRWYXJFeHByLmNhbGwodGhpcywgYXN0LCBjdHgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICBBYnN0cmFjdEpzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0RGVjbGFyZVZhclN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY3R4KSB7XG4gICAgICAgICAgY3R4LnByaW50KFwidmFyIFwiICsgc3RtdC5uYW1lICsgXCIgPSBcIik7XG4gICAgICAgICAgc3RtdC52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgICBjdHgucHJpbnRsbihcIjtcIik7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgQWJzdHJhY3RKc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdENhc3RFeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgICAgYXN0LnZhbHVlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcbiAgICAgIEFic3RyYWN0SnNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRJbnZva2VGdW5jdGlvbkV4cHIgPSBmdW5jdGlvbiAoZXhwciwgY3R4KSB7XG4gICAgICAgICAgdmFyIGZuRXhwciA9IGV4cHIuZm47XG4gICAgICAgICAgaWYgKGZuRXhwciBpbnN0YW5jZW9mIFJlYWRWYXJFeHByICYmIGZuRXhwci5idWlsdGluID09PSBCdWlsdGluVmFyLlN1cGVyKSB7XG4gICAgICAgICAgICAgIGN0eC5jdXJyZW50Q2xhc3MucGFyZW50LnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICAgICAgICBjdHgucHJpbnQoXCIuY2FsbCh0aGlzXCIpO1xuICAgICAgICAgICAgICBpZiAoZXhwci5hcmdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgIGN0eC5wcmludChcIiwgXCIpO1xuICAgICAgICAgICAgICAgICAgdGhpcy52aXNpdEFsbEV4cHJlc3Npb25zKGV4cHIuYXJncywgY3R4LCAnLCcpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGN0eC5wcmludChcIilcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLnZpc2l0SW52b2tlRnVuY3Rpb25FeHByLmNhbGwodGhpcywgZXhwciwgY3R4KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgQWJzdHJhY3RKc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEZ1bmN0aW9uRXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICAgIGN0eC5wcmludChcImZ1bmN0aW9uKFwiKTtcbiAgICAgICAgICB0aGlzLl92aXNpdFBhcmFtcyhhc3QucGFyYW1zLCBjdHgpO1xuICAgICAgICAgIGN0eC5wcmludGxuKFwiKSB7XCIpO1xuICAgICAgICAgIGN0eC5pbmNJbmRlbnQoKTtcbiAgICAgICAgICB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhhc3Quc3RhdGVtZW50cywgY3R4KTtcbiAgICAgICAgICBjdHguZGVjSW5kZW50KCk7XG4gICAgICAgICAgY3R4LnByaW50KFwifVwiKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICBBYnN0cmFjdEpzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0RGVjbGFyZUZ1bmN0aW9uU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjdHgpIHtcbiAgICAgICAgICBjdHgucHJpbnQoXCJmdW5jdGlvbiBcIiArIHN0bXQubmFtZSArIFwiKFwiKTtcbiAgICAgICAgICB0aGlzLl92aXNpdFBhcmFtcyhzdG10LnBhcmFtcywgY3R4KTtcbiAgICAgICAgICBjdHgucHJpbnRsbihcIikge1wiKTtcbiAgICAgICAgICBjdHguaW5jSW5kZW50KCk7XG4gICAgICAgICAgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoc3RtdC5zdGF0ZW1lbnRzLCBjdHgpO1xuICAgICAgICAgIGN0eC5kZWNJbmRlbnQoKTtcbiAgICAgICAgICBjdHgucHJpbnRsbihcIn1cIik7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgQWJzdHJhY3RKc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFRyeUNhdGNoU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjdHgpIHtcbiAgICAgICAgICBjdHgucHJpbnRsbihcInRyeSB7XCIpO1xuICAgICAgICAgIGN0eC5pbmNJbmRlbnQoKTtcbiAgICAgICAgICB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhzdG10LmJvZHlTdG10cywgY3R4KTtcbiAgICAgICAgICBjdHguZGVjSW5kZW50KCk7XG4gICAgICAgICAgY3R4LnByaW50bG4oXCJ9IGNhdGNoIChcIiArIENBVENIX0VSUk9SX1ZBUiQyLm5hbWUgKyBcIikge1wiKTtcbiAgICAgICAgICBjdHguaW5jSW5kZW50KCk7XG4gICAgICAgICAgdmFyIGNhdGNoU3RtdHMgPSBbQ0FUQ0hfU1RBQ0tfVkFSJDIuc2V0KENBVENIX0VSUk9SX1ZBUiQyLnByb3AoJ3N0YWNrJykpLnRvRGVjbFN0bXQobnVsbCwgW1xuICAgICAgICAgICAgICAgICAgU3RtdE1vZGlmaWVyLkZpbmFsXG4gICAgICAgICAgICAgIF0pXS5jb25jYXQoc3RtdC5jYXRjaFN0bXRzKTtcbiAgICAgICAgICB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhjYXRjaFN0bXRzLCBjdHgpO1xuICAgICAgICAgIGN0eC5kZWNJbmRlbnQoKTtcbiAgICAgICAgICBjdHgucHJpbnRsbihcIn1cIik7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgQWJzdHJhY3RKc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS5fdmlzaXRQYXJhbXMgPSBmdW5jdGlvbiAocGFyYW1zLCBjdHgpIHtcbiAgICAgICAgICB0aGlzLnZpc2l0QWxsT2JqZWN0cyhmdW5jdGlvbiAocGFyYW0pIHsgcmV0dXJuIGN0eC5wcmludChwYXJhbS5uYW1lKTsgfSwgcGFyYW1zLCBjdHgsICcsJyk7XG4gICAgICB9O1xuICAgICAgQWJzdHJhY3RKc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS5nZXRCdWlsdGluTWV0aG9kTmFtZSA9IGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAgICAgICB2YXIgbmFtZTtcbiAgICAgICAgICBzd2l0Y2ggKG1ldGhvZCkge1xuICAgICAgICAgICAgICBjYXNlIEJ1aWx0aW5NZXRob2QuQ29uY2F0QXJyYXk6XG4gICAgICAgICAgICAgICAgICBuYW1lID0gJ2NvbmNhdCc7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBCdWlsdGluTWV0aG9kLlN1YnNjcmliZU9ic2VydmFibGU6XG4gICAgICAgICAgICAgICAgICBuYW1lID0gJ3N1YnNjcmliZSc7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBCdWlsdGluTWV0aG9kLkJpbmQ6XG4gICAgICAgICAgICAgICAgICBuYW1lID0gJ2JpbmQnO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGJ1aWx0aW4gbWV0aG9kOiBcIiArIG1ldGhvZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBBYnN0cmFjdEpzRW1pdHRlclZpc2l0b3I7XG4gIH0oQWJzdHJhY3RFbWl0dGVyVmlzaXRvcikpO1xuXG4gIC8qKlxuICAgKiBAbGljZW5zZVxuICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICpcbiAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgKi9cbiAgdmFyIF9fZXh0ZW5kcyQxOSA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgfTtcbiAgZnVuY3Rpb24gZXZhbEV4cHJlc3Npb24oc291cmNlVXJsLCBleHByLCBkZWNsYXJhdGlvbnMsIHZhcnMpIHtcbiAgICAgIHZhciBmbkJvZHkgPSBkZWNsYXJhdGlvbnMgKyBcIlxcbnJldHVybiBcIiArIGV4cHIgKyBcIlxcbi8vIyBzb3VyY2VVUkw9XCIgKyBzb3VyY2VVcmw7XG4gICAgICB2YXIgZm5BcmdOYW1lcyA9IFtdO1xuICAgICAgdmFyIGZuQXJnVmFsdWVzID0gW107XG4gICAgICBmb3IgKHZhciBhcmdOYW1lIGluIHZhcnMpIHtcbiAgICAgICAgICBmbkFyZ05hbWVzLnB1c2goYXJnTmFtZSk7XG4gICAgICAgICAgZm5BcmdWYWx1ZXMucHVzaCh2YXJzW2FyZ05hbWVdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgKEZ1bmN0aW9uLmJpbmQuYXBwbHkoRnVuY3Rpb24sIFt2b2lkIDBdLmNvbmNhdChmbkFyZ05hbWVzLmNvbmNhdChmbkJvZHkpKSkpKCkuYXBwbHkodm9pZCAwLCBmbkFyZ1ZhbHVlcyk7XG4gIH1cbiAgZnVuY3Rpb24gaml0U3RhdGVtZW50cyhzb3VyY2VVcmwsIHN0YXRlbWVudHMsIHJlc3VsdFZhcikge1xuICAgICAgdmFyIGNvbnZlcnRlciA9IG5ldyBKaXRFbWl0dGVyVmlzaXRvcigpO1xuICAgICAgdmFyIGN0eCA9IEVtaXR0ZXJWaXNpdG9yQ29udGV4dC5jcmVhdGVSb290KFtyZXN1bHRWYXJdKTtcbiAgICAgIGNvbnZlcnRlci52aXNpdEFsbFN0YXRlbWVudHMoc3RhdGVtZW50cywgY3R4KTtcbiAgICAgIHJldHVybiBldmFsRXhwcmVzc2lvbihzb3VyY2VVcmwsIHJlc3VsdFZhciwgY3R4LnRvU291cmNlKCksIGNvbnZlcnRlci5nZXRBcmdzKCkpO1xuICB9XG4gIHZhciBKaXRFbWl0dGVyVmlzaXRvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkMTkoSml0RW1pdHRlclZpc2l0b3IsIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBKaXRFbWl0dGVyVmlzaXRvcigpIHtcbiAgICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICB0aGlzLl9ldmFsQXJnTmFtZXMgPSBbXTtcbiAgICAgICAgICB0aGlzLl9ldmFsQXJnVmFsdWVzID0gW107XG4gICAgICB9XG4gICAgICBKaXRFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUuZ2V0QXJncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9ldmFsQXJnTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgcmVzdWx0W3RoaXMuX2V2YWxBcmdOYW1lc1tpXV0gPSB0aGlzLl9ldmFsQXJnVmFsdWVzW2ldO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICAgIEppdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEV4dGVybmFsRXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IGFzdC52YWx1ZS5yZWZlcmVuY2U7XG4gICAgICAgICAgdmFyIGlkID0gdGhpcy5fZXZhbEFyZ1ZhbHVlcy5pbmRleE9mKHZhbHVlKTtcbiAgICAgICAgICBpZiAoaWQgPT09IC0xKSB7XG4gICAgICAgICAgICAgIGlkID0gdGhpcy5fZXZhbEFyZ1ZhbHVlcy5sZW5ndGg7XG4gICAgICAgICAgICAgIHRoaXMuX2V2YWxBcmdWYWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICAgIHZhciBuYW1lID0gaXNQcmVzZW50KGFzdC52YWx1ZS5uYW1lKSA/IHNhbml0aXplSWRlbnRpZmllcihhc3QudmFsdWUubmFtZSkgOiAndmFsJztcbiAgICAgICAgICAgICAgdGhpcy5fZXZhbEFyZ05hbWVzLnB1c2goc2FuaXRpemVJZGVudGlmaWVyKFwiaml0X1wiICsgbmFtZSArIGlkKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGN0eC5wcmludCh0aGlzLl9ldmFsQXJnTmFtZXNbaWRdKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICByZXR1cm4gSml0RW1pdHRlclZpc2l0b3I7XG4gIH0oQWJzdHJhY3RKc0VtaXR0ZXJWaXNpdG9yKSk7XG5cbiAgLyoqXG4gICAqIEBsaWNlbnNlXG4gICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgKlxuICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAqL1xuICAvKipcbiAgICogVGhpcyBmaWxlIGlzIGEgcG9ydCBvZiBzaGFkb3dDU1MgZnJvbSB3ZWJjb21wb25lbnRzLmpzIHRvIFR5cGVTY3JpcHQuXG4gICAqXG4gICAqIFBsZWFzZSBtYWtlIHN1cmUgdG8ga2VlcCB0byBlZGl0cyBpbiBzeW5jIHdpdGggdGhlIHNvdXJjZSBmaWxlLlxuICAgKlxuICAgKiBTb3VyY2U6XG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJjb21wb25lbnRzL3dlYmNvbXBvbmVudHNqcy9ibG9iLzRlZmVjZDdlMGUvc3JjL1NoYWRvd0NTUy9TaGFkb3dDU1MuanNcbiAgICpcbiAgICogVGhlIG9yaWdpbmFsIGZpbGUgbGV2ZWwgY29tbWVudCBpcyByZXByb2R1Y2VkIGJlbG93XG4gICAqL1xuICAvKlxuICAgIFRoaXMgaXMgYSBsaW1pdGVkIHNoaW0gZm9yIFNoYWRvd0RPTSBjc3Mgc3R5bGluZy5cbiAgICBodHRwczovL2R2Y3MudzMub3JnL2hnL3dlYmNvbXBvbmVudHMvcmF3LWZpbGUvdGlwL3NwZWMvc2hhZG93L2luZGV4Lmh0bWwjc3R5bGVzXG5cbiAgICBUaGUgaW50ZW50aW9uIGhlcmUgaXMgdG8gc3VwcG9ydCBvbmx5IHRoZSBzdHlsaW5nIGZlYXR1cmVzIHdoaWNoIGNhbiBiZVxuICAgIHJlbGF0aXZlbHkgc2ltcGx5IGltcGxlbWVudGVkLiBUaGUgZ29hbCBpcyB0byBhbGxvdyB1c2VycyB0byBhdm9pZCB0aGVcbiAgICBtb3N0IG9idmlvdXMgcGl0ZmFsbHMgYW5kIGRvIHNvIHdpdGhvdXQgY29tcHJvbWlzaW5nIHBlcmZvcm1hbmNlIHNpZ25pZmljYW50bHkuXG4gICAgRm9yIFNoYWRvd0RPTSBzdHlsaW5nIHRoYXQncyBub3QgY292ZXJlZCBoZXJlLCBhIHNldCBvZiBiZXN0IHByYWN0aWNlc1xuICAgIGNhbiBiZSBwcm92aWRlZCB0aGF0IHNob3VsZCBhbGxvdyB1c2VycyB0byBhY2NvbXBsaXNoIG1vcmUgY29tcGxleCBzdHlsaW5nLlxuXG4gICAgVGhlIGZvbGxvd2luZyBpcyBhIGxpc3Qgb2Ygc3BlY2lmaWMgU2hhZG93RE9NIHN0eWxpbmcgZmVhdHVyZXMgYW5kIGEgYnJpZWZcbiAgICBkaXNjdXNzaW9uIG9mIHRoZSBhcHByb2FjaCB1c2VkIHRvIHNoaW0uXG5cbiAgICBTaGltbWVkIGZlYXR1cmVzOlxuXG4gICAgKiA6aG9zdCwgOmhvc3QtY29udGV4dDogU2hhZG93RE9NIGFsbG93cyBzdHlsaW5nIG9mIHRoZSBzaGFkb3dSb290J3MgaG9zdFxuICAgIGVsZW1lbnQgdXNpbmcgdGhlIDpob3N0IHJ1bGUuIFRvIHNoaW0gdGhpcyBmZWF0dXJlLCB0aGUgOmhvc3Qgc3R5bGVzIGFyZVxuICAgIHJlZm9ybWF0dGVkIGFuZCBwcmVmaXhlZCB3aXRoIGEgZ2l2ZW4gc2NvcGUgbmFtZSBhbmQgcHJvbW90ZWQgdG8gYVxuICAgIGRvY3VtZW50IGxldmVsIHN0eWxlc2hlZXQuXG4gICAgRm9yIGV4YW1wbGUsIGdpdmVuIGEgc2NvcGUgbmFtZSBvZiAuZm9vLCBhIHJ1bGUgbGlrZSB0aGlzOlxuXG4gICAgICA6aG9zdCB7XG4gICAgICAgICAgYmFja2dyb3VuZDogcmVkO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICBiZWNvbWVzOlxuXG4gICAgICAuZm9vIHtcbiAgICAgICAgYmFja2dyb3VuZDogcmVkO1xuICAgICAgfVxuXG4gICAgKiBlbmNhcHN1bGF0aW9uOiBTdHlsZXMgZGVmaW5lZCB3aXRoaW4gU2hhZG93RE9NLCBhcHBseSBvbmx5IHRvXG4gICAgZG9tIGluc2lkZSB0aGUgU2hhZG93RE9NLiBQb2x5bWVyIHVzZXMgb25lIG9mIHR3byB0ZWNobmlxdWVzIHRvIGltcGxlbWVudFxuICAgIHRoaXMgZmVhdHVyZS5cblxuICAgIEJ5IGRlZmF1bHQsIHJ1bGVzIGFyZSBwcmVmaXhlZCB3aXRoIHRoZSBob3N0IGVsZW1lbnQgdGFnIG5hbWVcbiAgICBhcyBhIGRlc2NlbmRhbnQgc2VsZWN0b3IuIFRoaXMgZW5zdXJlcyBzdHlsaW5nIGRvZXMgbm90IGxlYWsgb3V0IG9mIHRoZSAndG9wJ1xuICAgIG9mIHRoZSBlbGVtZW50J3MgU2hhZG93RE9NLiBGb3IgZXhhbXBsZSxcblxuICAgIGRpdiB7XG4gICAgICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xuICAgICAgfVxuXG4gICAgYmVjb21lczpcblxuICAgIHgtZm9vIGRpdiB7XG4gICAgICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xuICAgICAgfVxuXG4gICAgYmVjb21lczpcblxuXG4gICAgQWx0ZXJuYXRpdmVseSwgaWYgV2ViQ29tcG9uZW50cy5TaGFkb3dDU1Muc3RyaWN0U3R5bGluZyBpcyBzZXQgdG8gdHJ1ZSB0aGVuXG4gICAgc2VsZWN0b3JzIGFyZSBzY29wZWQgYnkgYWRkaW5nIGFuIGF0dHJpYnV0ZSBzZWxlY3RvciBzdWZmaXggdG8gZWFjaFxuICAgIHNpbXBsZSBzZWxlY3RvciB0aGF0IGNvbnRhaW5zIHRoZSBob3N0IGVsZW1lbnQgdGFnIG5hbWUuIEVhY2ggZWxlbWVudFxuICAgIGluIHRoZSBlbGVtZW50J3MgU2hhZG93RE9NIHRlbXBsYXRlIGlzIGFsc28gZ2l2ZW4gdGhlIHNjb3BlIGF0dHJpYnV0ZS5cbiAgICBUaHVzLCB0aGVzZSBydWxlcyBtYXRjaCBvbmx5IGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgc2NvcGUgYXR0cmlidXRlLlxuICAgIEZvciBleGFtcGxlLCBnaXZlbiBhIHNjb3BlIG5hbWUgb2YgeC1mb28sIGEgcnVsZSBsaWtlIHRoaXM6XG5cbiAgICAgIGRpdiB7XG4gICAgICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xuICAgICAgfVxuXG4gICAgYmVjb21lczpcblxuICAgICAgZGl2W3gtZm9vXSB7XG4gICAgICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xuICAgICAgfVxuXG4gICAgTm90ZSB0aGF0IGVsZW1lbnRzIHRoYXQgYXJlIGR5bmFtaWNhbGx5IGFkZGVkIHRvIGEgc2NvcGUgbXVzdCBoYXZlIHRoZSBzY29wZVxuICAgIHNlbGVjdG9yIGFkZGVkIHRvIHRoZW0gbWFudWFsbHkuXG5cbiAgICAqIHVwcGVyL2xvd2VyIGJvdW5kIGVuY2Fwc3VsYXRpb246IFN0eWxlcyB3aGljaCBhcmUgZGVmaW5lZCBvdXRzaWRlIGFcbiAgICBzaGFkb3dSb290IHNob3VsZCBub3QgY3Jvc3MgdGhlIFNoYWRvd0RPTSBib3VuZGFyeSBhbmQgc2hvdWxkIG5vdCBhcHBseVxuICAgIGluc2lkZSBhIHNoYWRvd1Jvb3QuXG5cbiAgICBUaGlzIHN0eWxpbmcgYmVoYXZpb3IgaXMgbm90IGVtdWxhdGVkLiBTb21lIHBvc3NpYmxlIHdheXMgdG8gZG8gdGhpcyB0aGF0XG4gICAgd2VyZSByZWplY3RlZCBkdWUgdG8gY29tcGxleGl0eSBhbmQvb3IgcGVyZm9ybWFuY2UgY29uY2VybnMgaW5jbHVkZTogKDEpIHJlc2V0XG4gICAgZXZlcnkgcG9zc2libGUgcHJvcGVydHkgZm9yIGV2ZXJ5IHBvc3NpYmxlIHNlbGVjdG9yIGZvciBhIGdpdmVuIHNjb3BlIG5hbWU7XG4gICAgKDIpIHJlLWltcGxlbWVudCBjc3MgaW4gamF2YXNjcmlwdC5cblxuICAgIEFzIGFuIGFsdGVybmF0aXZlLCB1c2VycyBzaG91bGQgbWFrZSBzdXJlIHRvIHVzZSBzZWxlY3RvcnNcbiAgICBzcGVjaWZpYyB0byB0aGUgc2NvcGUgaW4gd2hpY2ggdGhleSBhcmUgd29ya2luZy5cblxuICAgICogOjpkaXN0cmlidXRlZDogVGhpcyBiZWhhdmlvciBpcyBub3QgZW11bGF0ZWQuIEl0J3Mgb2Z0ZW4gbm90IG5lY2Vzc2FyeVxuICAgIHRvIHN0eWxlIHRoZSBjb250ZW50cyBvZiBhIHNwZWNpZmljIGluc2VydGlvbiBwb2ludCBhbmQgaW5zdGVhZCwgZGVzY2VuZGFudHNcbiAgICBvZiB0aGUgaG9zdCBlbGVtZW50IGNhbiBiZSBzdHlsZWQgc2VsZWN0aXZlbHkuIFVzZXJzIGNhbiBhbHNvIGNyZWF0ZSBhblxuICAgIGV4dHJhIG5vZGUgYXJvdW5kIGFuIGluc2VydGlvbiBwb2ludCBhbmQgc3R5bGUgdGhhdCBub2RlJ3MgY29udGVudHNcbiAgICB2aWEgZGVzY2VuZGVudCBzZWxlY3RvcnMuIEZvciBleGFtcGxlLCB3aXRoIGEgc2hhZG93Um9vdCBsaWtlIHRoaXM6XG5cbiAgICAgIDxzdHlsZT5cbiAgICAgICAgOjpjb250ZW50KGRpdikge1xuICAgICAgICAgIGJhY2tncm91bmQ6IHJlZDtcbiAgICAgICAgfVxuICAgICAgPC9zdHlsZT5cbiAgICAgIDxjb250ZW50PjwvY29udGVudD5cblxuICAgIGNvdWxkIGJlY29tZTpcblxuICAgICAgPHN0eWxlPlxuICAgICAgICAvICpAcG9seWZpbGwgLmNvbnRlbnQtY29udGFpbmVyIGRpdiAqIC9cbiAgICAgICAgOjpjb250ZW50KGRpdikge1xuICAgICAgICAgIGJhY2tncm91bmQ6IHJlZDtcbiAgICAgICAgfVxuICAgICAgPC9zdHlsZT5cbiAgICAgIDxkaXYgY2xhc3M9XCJjb250ZW50LWNvbnRhaW5lclwiPlxuICAgICAgICA8Y29udGVudD48L2NvbnRlbnQ+XG4gICAgICA8L2Rpdj5cblxuICAgIE5vdGUgdGhlIHVzZSBvZiBAcG9seWZpbGwgaW4gdGhlIGNvbW1lbnQgYWJvdmUgYSBTaGFkb3dET00gc3BlY2lmaWMgc3R5bGVcbiAgICBkZWNsYXJhdGlvbi4gVGhpcyBpcyBhIGRpcmVjdGl2ZSB0byB0aGUgc3R5bGluZyBzaGltIHRvIHVzZSB0aGUgc2VsZWN0b3JcbiAgICBpbiBjb21tZW50cyBpbiBsaWV1IG9mIHRoZSBuZXh0IHNlbGVjdG9yIHdoZW4gcnVubmluZyB1bmRlciBwb2x5ZmlsbC5cbiAgKi9cbiAgdmFyIFNoYWRvd0NzcyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBTaGFkb3dDc3MoKSB7XG4gICAgICAgICAgdGhpcy5zdHJpY3RTdHlsaW5nID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIC8qXG4gICAgICAqIFNoaW0gc29tZSBjc3NUZXh0IHdpdGggdGhlIGdpdmVuIHNlbGVjdG9yLiBSZXR1cm5zIGNzc1RleHQgdGhhdCBjYW5cbiAgICAgICogYmUgaW5jbHVkZWQgaW4gdGhlIGRvY3VtZW50IHZpYSBXZWJDb21wb25lbnRzLlNoYWRvd0NTUy5hZGRDc3NUb0RvY3VtZW50KGNzcykuXG4gICAgICAqXG4gICAgICAqIFdoZW4gc3RyaWN0U3R5bGluZyBpcyB0cnVlOlxuICAgICAgKiAtIHNlbGVjdG9yIGlzIHRoZSBhdHRyaWJ1dGUgYWRkZWQgdG8gYWxsIGVsZW1lbnRzIGluc2lkZSB0aGUgaG9zdCxcbiAgICAgICogLSBob3N0U2VsZWN0b3IgaXMgdGhlIGF0dHJpYnV0ZSBhZGRlZCB0byB0aGUgaG9zdCBpdHNlbGYuXG4gICAgICAqL1xuICAgICAgU2hhZG93Q3NzLnByb3RvdHlwZS5zaGltQ3NzVGV4dCA9IGZ1bmN0aW9uIChjc3NUZXh0LCBzZWxlY3RvciwgaG9zdFNlbGVjdG9yKSB7XG4gICAgICAgICAgaWYgKGhvc3RTZWxlY3RvciA9PT0gdm9pZCAwKSB7IGhvc3RTZWxlY3RvciA9ICcnOyB9XG4gICAgICAgICAgdmFyIHNvdXJjZU1hcHBpbmdVcmwgPSBleHRyYWN0U291cmNlTWFwcGluZ1VybChjc3NUZXh0KTtcbiAgICAgICAgICBjc3NUZXh0ID0gc3RyaXBDb21tZW50cyhjc3NUZXh0KTtcbiAgICAgICAgICBjc3NUZXh0ID0gdGhpcy5faW5zZXJ0RGlyZWN0aXZlcyhjc3NUZXh0KTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fc2NvcGVDc3NUZXh0KGNzc1RleHQsIHNlbGVjdG9yLCBob3N0U2VsZWN0b3IpICsgc291cmNlTWFwcGluZ1VybDtcbiAgICAgIH07XG4gICAgICBTaGFkb3dDc3MucHJvdG90eXBlLl9pbnNlcnREaXJlY3RpdmVzID0gZnVuY3Rpb24gKGNzc1RleHQpIHtcbiAgICAgICAgICBjc3NUZXh0ID0gdGhpcy5faW5zZXJ0UG9seWZpbGxEaXJlY3RpdmVzSW5Dc3NUZXh0KGNzc1RleHQpO1xuICAgICAgICAgIHJldHVybiB0aGlzLl9pbnNlcnRQb2x5ZmlsbFJ1bGVzSW5Dc3NUZXh0KGNzc1RleHQpO1xuICAgICAgfTtcbiAgICAgIC8qXG4gICAgICAgKiBQcm9jZXNzIHN0eWxlcyB0byBjb252ZXJ0IG5hdGl2ZSBTaGFkb3dET00gcnVsZXMgdGhhdCB3aWxsIHRyaXBcbiAgICAgICAqIHVwIHRoZSBjc3MgcGFyc2VyOyB3ZSByZWx5IG9uIGRlY29yYXRpbmcgdGhlIHN0eWxlc2hlZXQgd2l0aCBpbmVydCBydWxlcy5cbiAgICAgICAqXG4gICAgICAgKiBGb3IgZXhhbXBsZSwgd2UgY29udmVydCB0aGlzIHJ1bGU6XG4gICAgICAgKlxuICAgICAgICogcG9seWZpbGwtbmV4dC1zZWxlY3RvciB7IGNvbnRlbnQ6ICc6aG9zdCBtZW51LWl0ZW0nOyB9XG4gICAgICAgKiA6OmNvbnRlbnQgbWVudS1pdGVtIHtcbiAgICAgICAqXG4gICAgICAgKiB0byB0aGlzOlxuICAgICAgICpcbiAgICAgICAqIHNjb3BlTmFtZSBtZW51LWl0ZW0ge1xuICAgICAgICpcbiAgICAgICoqL1xuICAgICAgU2hhZG93Q3NzLnByb3RvdHlwZS5faW5zZXJ0UG9seWZpbGxEaXJlY3RpdmVzSW5Dc3NUZXh0ID0gZnVuY3Rpb24gKGNzc1RleHQpIHtcbiAgICAgICAgICAvLyBEaWZmZXJlbmNlIHdpdGggd2ViY29tcG9uZW50cy5qczogZG9lcyBub3QgaGFuZGxlIGNvbW1lbnRzXG4gICAgICAgICAgcmV0dXJuIGNzc1RleHQucmVwbGFjZShfY3NzQ29udGVudE5leHRTZWxlY3RvclJlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHZhciBtID0gW107XG4gICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICBtW19pIC0gMF0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBtWzJdICsgJ3snO1xuICAgICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIC8qXG4gICAgICAgKiBQcm9jZXNzIHN0eWxlcyB0byBhZGQgcnVsZXMgd2hpY2ggd2lsbCBvbmx5IGFwcGx5IHVuZGVyIHRoZSBwb2x5ZmlsbFxuICAgICAgICpcbiAgICAgICAqIEZvciBleGFtcGxlLCB3ZSBjb252ZXJ0IHRoaXMgcnVsZTpcbiAgICAgICAqXG4gICAgICAgKiBwb2x5ZmlsbC1ydWxlIHtcbiAgICAgICAqICAgY29udGVudDogJzpob3N0IG1lbnUtaXRlbSc7XG4gICAgICAgKiAuLi5cbiAgICAgICAqIH1cbiAgICAgICAqXG4gICAgICAgKiB0byB0aGlzOlxuICAgICAgICpcbiAgICAgICAqIHNjb3BlTmFtZSBtZW51LWl0ZW0gey4uLn1cbiAgICAgICAqXG4gICAgICAqKi9cbiAgICAgIFNoYWRvd0Nzcy5wcm90b3R5cGUuX2luc2VydFBvbHlmaWxsUnVsZXNJbkNzc1RleHQgPSBmdW5jdGlvbiAoY3NzVGV4dCkge1xuICAgICAgICAgIC8vIERpZmZlcmVuY2Ugd2l0aCB3ZWJjb21wb25lbnRzLmpzOiBkb2VzIG5vdCBoYW5kbGUgY29tbWVudHNcbiAgICAgICAgICByZXR1cm4gY3NzVGV4dC5yZXBsYWNlKF9jc3NDb250ZW50UnVsZVJlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHZhciBtID0gW107XG4gICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICBtW19pIC0gMF0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhciBydWxlID0gbVswXS5yZXBsYWNlKG1bMV0sICcnKS5yZXBsYWNlKG1bMl0sICcnKTtcbiAgICAgICAgICAgICAgcmV0dXJuIG1bNF0gKyBydWxlO1xuICAgICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIC8qIEVuc3VyZSBzdHlsZXMgYXJlIHNjb3BlZC4gUHNldWRvLXNjb3BpbmcgdGFrZXMgYSBydWxlIGxpa2U6XG4gICAgICAgKlxuICAgICAgICogIC5mb28gey4uLiB9XG4gICAgICAgKlxuICAgICAgICogIGFuZCBjb252ZXJ0cyB0aGlzIHRvXG4gICAgICAgKlxuICAgICAgICogIHNjb3BlTmFtZSAuZm9vIHsgLi4uIH1cbiAgICAgICovXG4gICAgICBTaGFkb3dDc3MucHJvdG90eXBlLl9zY29wZUNzc1RleHQgPSBmdW5jdGlvbiAoY3NzVGV4dCwgc2NvcGVTZWxlY3RvciwgaG9zdFNlbGVjdG9yKSB7XG4gICAgICAgICAgdmFyIHVuc2NvcGVkUnVsZXMgPSB0aGlzLl9leHRyYWN0VW5zY29wZWRSdWxlc0Zyb21Dc3NUZXh0KGNzc1RleHQpO1xuICAgICAgICAgIC8vIHJlcGxhY2UgOmhvc3QgYW5kIDpob3N0LWNvbnRleHQgLXNoYWRvd2Nzc2hvc3QgYW5kIC1zaGFkb3djc3Nob3N0IHJlc3BlY3RpdmVseVxuICAgICAgICAgIGNzc1RleHQgPSB0aGlzLl9pbnNlcnRQb2x5ZmlsbEhvc3RJbkNzc1RleHQoY3NzVGV4dCk7XG4gICAgICAgICAgY3NzVGV4dCA9IHRoaXMuX2NvbnZlcnRDb2xvbkhvc3QoY3NzVGV4dCk7XG4gICAgICAgICAgY3NzVGV4dCA9IHRoaXMuX2NvbnZlcnRDb2xvbkhvc3RDb250ZXh0KGNzc1RleHQpO1xuICAgICAgICAgIGNzc1RleHQgPSB0aGlzLl9jb252ZXJ0U2hhZG93RE9NU2VsZWN0b3JzKGNzc1RleHQpO1xuICAgICAgICAgIGlmIChzY29wZVNlbGVjdG9yKSB7XG4gICAgICAgICAgICAgIGNzc1RleHQgPSB0aGlzLl9zY29wZVNlbGVjdG9ycyhjc3NUZXh0LCBzY29wZVNlbGVjdG9yLCBob3N0U2VsZWN0b3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjc3NUZXh0ID0gY3NzVGV4dCArICdcXG4nICsgdW5zY29wZWRSdWxlcztcbiAgICAgICAgICByZXR1cm4gY3NzVGV4dC50cmltKCk7XG4gICAgICB9O1xuICAgICAgLypcbiAgICAgICAqIFByb2Nlc3Mgc3R5bGVzIHRvIGFkZCBydWxlcyB3aGljaCB3aWxsIG9ubHkgYXBwbHkgdW5kZXIgdGhlIHBvbHlmaWxsXG4gICAgICAgKiBhbmQgZG8gbm90IHByb2Nlc3MgdmlhIENTU09NLiAoQ1NTT00gaXMgZGVzdHJ1Y3RpdmUgdG8gcnVsZXMgb24gcmFyZVxuICAgICAgICogb2NjYXNpb25zLCBlLmcuIC13ZWJraXQtY2FsYyBvbiBTYWZhcmkuKVxuICAgICAgICogRm9yIGV4YW1wbGUsIHdlIGNvbnZlcnQgdGhpcyBydWxlOlxuICAgICAgICpcbiAgICAgICAqIEBwb2x5ZmlsbC11bnNjb3BlZC1ydWxlIHtcbiAgICAgICAqICAgY29udGVudDogJ21lbnUtaXRlbSc7XG4gICAgICAgKiAuLi4gfVxuICAgICAgICpcbiAgICAgICAqIHRvIHRoaXM6XG4gICAgICAgKlxuICAgICAgICogbWVudS1pdGVtIHsuLi59XG4gICAgICAgKlxuICAgICAgKiovXG4gICAgICBTaGFkb3dDc3MucHJvdG90eXBlLl9leHRyYWN0VW5zY29wZWRSdWxlc0Zyb21Dc3NUZXh0ID0gZnVuY3Rpb24gKGNzc1RleHQpIHtcbiAgICAgICAgICAvLyBEaWZmZXJlbmNlIHdpdGggd2ViY29tcG9uZW50cy5qczogZG9lcyBub3QgaGFuZGxlIGNvbW1lbnRzXG4gICAgICAgICAgdmFyIHIgPSAnJztcbiAgICAgICAgICB2YXIgbTtcbiAgICAgICAgICBfY3NzQ29udGVudFVuc2NvcGVkUnVsZVJlLmxhc3RJbmRleCA9IDA7XG4gICAgICAgICAgd2hpbGUgKChtID0gX2Nzc0NvbnRlbnRVbnNjb3BlZFJ1bGVSZS5leGVjKGNzc1RleHQpKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICB2YXIgcnVsZSA9IG1bMF0ucmVwbGFjZShtWzJdLCAnJykucmVwbGFjZShtWzFdLCBtWzRdKTtcbiAgICAgICAgICAgICAgciArPSBydWxlICsgJ1xcblxcbic7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByO1xuICAgICAgfTtcbiAgICAgIC8qXG4gICAgICAgKiBjb252ZXJ0IGEgcnVsZSBsaWtlIDpob3N0KC5mb28pID4gLmJhciB7IH1cbiAgICAgICAqXG4gICAgICAgKiB0b1xuICAgICAgICpcbiAgICAgICAqIC5mb288c2NvcGVOYW1lPiA+IC5iYXJcbiAgICAgICovXG4gICAgICBTaGFkb3dDc3MucHJvdG90eXBlLl9jb252ZXJ0Q29sb25Ib3N0ID0gZnVuY3Rpb24gKGNzc1RleHQpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fY29udmVydENvbG9uUnVsZShjc3NUZXh0LCBfY3NzQ29sb25Ib3N0UmUsIHRoaXMuX2NvbG9uSG9zdFBhcnRSZXBsYWNlcik7XG4gICAgICB9O1xuICAgICAgLypcbiAgICAgICAqIGNvbnZlcnQgYSBydWxlIGxpa2UgOmhvc3QtY29udGV4dCguZm9vKSA+IC5iYXIgeyB9XG4gICAgICAgKlxuICAgICAgICogdG9cbiAgICAgICAqXG4gICAgICAgKiAuZm9vPHNjb3BlTmFtZT4gPiAuYmFyLCAuZm9vIHNjb3BlTmFtZSA+IC5iYXIgeyB9XG4gICAgICAgKlxuICAgICAgICogYW5kXG4gICAgICAgKlxuICAgICAgICogOmhvc3QtY29udGV4dCguZm9vOmhvc3QpIC5iYXIgeyAuLi4gfVxuICAgICAgICpcbiAgICAgICAqIHRvXG4gICAgICAgKlxuICAgICAgICogLmZvbzxzY29wZU5hbWU+IC5iYXIgeyAuLi4gfVxuICAgICAgKi9cbiAgICAgIFNoYWRvd0Nzcy5wcm90b3R5cGUuX2NvbnZlcnRDb2xvbkhvc3RDb250ZXh0ID0gZnVuY3Rpb24gKGNzc1RleHQpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fY29udmVydENvbG9uUnVsZShjc3NUZXh0LCBfY3NzQ29sb25Ib3N0Q29udGV4dFJlLCB0aGlzLl9jb2xvbkhvc3RDb250ZXh0UGFydFJlcGxhY2VyKTtcbiAgICAgIH07XG4gICAgICBTaGFkb3dDc3MucHJvdG90eXBlLl9jb252ZXJ0Q29sb25SdWxlID0gZnVuY3Rpb24gKGNzc1RleHQsIHJlZ0V4cCwgcGFydFJlcGxhY2VyKSB7XG4gICAgICAgICAgLy8gbVsxXSA9IDpob3N0KC1jb250ZXh0KSwgbVsyXSA9IGNvbnRlbnRzIG9mICgpLCBtWzNdIHJlc3Qgb2YgcnVsZVxuICAgICAgICAgIHJldHVybiBjc3NUZXh0LnJlcGxhY2UocmVnRXhwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHZhciBtID0gW107XG4gICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICBtW19pIC0gMF0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChtWzJdKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgcGFydHMgPSBtWzJdLnNwbGl0KCcsJyk7XG4gICAgICAgICAgICAgICAgICB2YXIgciA9IFtdO1xuICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBwID0gcGFydHNbaV0udHJpbSgpO1xuICAgICAgICAgICAgICAgICAgICAgIGlmICghcClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgci5wdXNoKHBhcnRSZXBsYWNlcihfcG9seWZpbGxIb3N0Tm9Db21iaW5hdG9yLCBwLCBtWzNdKSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICByZXR1cm4gci5qb2luKCcsJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gX3BvbHlmaWxsSG9zdE5vQ29tYmluYXRvciArIG1bM107XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBTaGFkb3dDc3MucHJvdG90eXBlLl9jb2xvbkhvc3RDb250ZXh0UGFydFJlcGxhY2VyID0gZnVuY3Rpb24gKGhvc3QsIHBhcnQsIHN1ZmZpeCkge1xuICAgICAgICAgIGlmIChwYXJ0LmluZGV4T2YoX3BvbHlmaWxsSG9zdCkgPiAtMSkge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY29sb25Ib3N0UGFydFJlcGxhY2VyKGhvc3QsIHBhcnQsIHN1ZmZpeCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gaG9zdCArIHBhcnQgKyBzdWZmaXggKyAnLCAnICsgcGFydCArICcgJyArIGhvc3QgKyBzdWZmaXg7XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIFNoYWRvd0Nzcy5wcm90b3R5cGUuX2NvbG9uSG9zdFBhcnRSZXBsYWNlciA9IGZ1bmN0aW9uIChob3N0LCBwYXJ0LCBzdWZmaXgpIHtcbiAgICAgICAgICByZXR1cm4gaG9zdCArIHBhcnQucmVwbGFjZShfcG9seWZpbGxIb3N0LCAnJykgKyBzdWZmaXg7XG4gICAgICB9O1xuICAgICAgLypcbiAgICAgICAqIENvbnZlcnQgY29tYmluYXRvcnMgbGlrZSA6OnNoYWRvdyBhbmQgcHNldWRvLWVsZW1lbnRzIGxpa2UgOjpjb250ZW50XG4gICAgICAgKiBieSByZXBsYWNpbmcgd2l0aCBzcGFjZS5cbiAgICAgICovXG4gICAgICBTaGFkb3dDc3MucHJvdG90eXBlLl9jb252ZXJ0U2hhZG93RE9NU2VsZWN0b3JzID0gZnVuY3Rpb24gKGNzc1RleHQpIHtcbiAgICAgICAgICByZXR1cm4gX3NoYWRvd0RPTVNlbGVjdG9yc1JlLnJlZHVjZShmdW5jdGlvbiAocmVzdWx0LCBwYXR0ZXJuKSB7IHJldHVybiByZXN1bHQucmVwbGFjZShwYXR0ZXJuLCAnICcpOyB9LCBjc3NUZXh0KTtcbiAgICAgIH07XG4gICAgICAvLyBjaGFuZ2UgYSBzZWxlY3RvciBsaWtlICdkaXYnIHRvICduYW1lIGRpdidcbiAgICAgIFNoYWRvd0Nzcy5wcm90b3R5cGUuX3Njb3BlU2VsZWN0b3JzID0gZnVuY3Rpb24gKGNzc1RleHQsIHNjb3BlU2VsZWN0b3IsIGhvc3RTZWxlY3Rvcikge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgcmV0dXJuIHByb2Nlc3NSdWxlcyhjc3NUZXh0LCBmdW5jdGlvbiAocnVsZSkge1xuICAgICAgICAgICAgICB2YXIgc2VsZWN0b3IgPSBydWxlLnNlbGVjdG9yO1xuICAgICAgICAgICAgICB2YXIgY29udGVudCA9IHJ1bGUuY29udGVudDtcbiAgICAgICAgICAgICAgaWYgKHJ1bGUuc2VsZWN0b3JbMF0gIT0gJ0AnKSB7XG4gICAgICAgICAgICAgICAgICBzZWxlY3RvciA9XG4gICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3Njb3BlU2VsZWN0b3IocnVsZS5zZWxlY3Rvciwgc2NvcGVTZWxlY3RvciwgaG9zdFNlbGVjdG9yLCBfdGhpcy5zdHJpY3RTdHlsaW5nKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIGlmIChydWxlLnNlbGVjdG9yLnN0YXJ0c1dpdGgoJ0BtZWRpYScpIHx8IHJ1bGUuc2VsZWN0b3Iuc3RhcnRzV2l0aCgnQHN1cHBvcnRzJykgfHxcbiAgICAgICAgICAgICAgICAgIHJ1bGUuc2VsZWN0b3Iuc3RhcnRzV2l0aCgnQHBhZ2UnKSB8fCBydWxlLnNlbGVjdG9yLnN0YXJ0c1dpdGgoJ0Bkb2N1bWVudCcpKSB7XG4gICAgICAgICAgICAgICAgICBjb250ZW50ID0gX3RoaXMuX3Njb3BlU2VsZWN0b3JzKHJ1bGUuY29udGVudCwgc2NvcGVTZWxlY3RvciwgaG9zdFNlbGVjdG9yKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gbmV3IENzc1J1bGUoc2VsZWN0b3IsIGNvbnRlbnQpO1xuICAgICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIFNoYWRvd0Nzcy5wcm90b3R5cGUuX3Njb3BlU2VsZWN0b3IgPSBmdW5jdGlvbiAoc2VsZWN0b3IsIHNjb3BlU2VsZWN0b3IsIGhvc3RTZWxlY3Rvciwgc3RyaWN0KSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICByZXR1cm4gc2VsZWN0b3Iuc3BsaXQoJywnKVxuICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChwYXJ0KSB7IHJldHVybiBwYXJ0LnRyaW0oKS5zcGxpdChfc2hhZG93RGVlcFNlbGVjdG9ycyk7IH0pXG4gICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGRlZXBQYXJ0cykge1xuICAgICAgICAgICAgICB2YXIgc2hhbGxvd1BhcnQgPSBkZWVwUGFydHNbMF0sIG90aGVyUGFydHMgPSBkZWVwUGFydHMuc2xpY2UoMSk7XG4gICAgICAgICAgICAgIHZhciBhcHBseVNjb3BlID0gZnVuY3Rpb24gKHNoYWxsb3dQYXJ0KSB7XG4gICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuX3NlbGVjdG9yTmVlZHNTY29waW5nKHNoYWxsb3dQYXJ0LCBzY29wZVNlbGVjdG9yKSkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdHJpY3QgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fYXBwbHlTdHJpY3RTZWxlY3RvclNjb3BlKHNoYWxsb3dQYXJ0LCBzY29wZVNlbGVjdG9yLCBob3N0U2VsZWN0b3IpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2FwcGx5U2VsZWN0b3JTY29wZShzaGFsbG93UGFydCwgc2NvcGVTZWxlY3RvciwgaG9zdFNlbGVjdG9yKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzaGFsbG93UGFydDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgcmV0dXJuIFthcHBseVNjb3BlKHNoYWxsb3dQYXJ0KV0uY29uY2F0KG90aGVyUGFydHMpLmpvaW4oJyAnKTtcbiAgICAgICAgICB9KVxuICAgICAgICAgICAgICAuam9pbignLCAnKTtcbiAgICAgIH07XG4gICAgICBTaGFkb3dDc3MucHJvdG90eXBlLl9zZWxlY3Rvck5lZWRzU2NvcGluZyA9IGZ1bmN0aW9uIChzZWxlY3Rvciwgc2NvcGVTZWxlY3Rvcikge1xuICAgICAgICAgIHZhciByZSA9IHRoaXMuX21ha2VTY29wZU1hdGNoZXIoc2NvcGVTZWxlY3Rvcik7XG4gICAgICAgICAgcmV0dXJuICFyZS50ZXN0KHNlbGVjdG9yKTtcbiAgICAgIH07XG4gICAgICBTaGFkb3dDc3MucHJvdG90eXBlLl9tYWtlU2NvcGVNYXRjaGVyID0gZnVuY3Rpb24gKHNjb3BlU2VsZWN0b3IpIHtcbiAgICAgICAgICB2YXIgbHJlID0gL1xcWy9nO1xuICAgICAgICAgIHZhciBycmUgPSAvXFxdL2c7XG4gICAgICAgICAgc2NvcGVTZWxlY3RvciA9IHNjb3BlU2VsZWN0b3IucmVwbGFjZShscmUsICdcXFxcWycpLnJlcGxhY2UocnJlLCAnXFxcXF0nKTtcbiAgICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cCgnXignICsgc2NvcGVTZWxlY3RvciArICcpJyArIF9zZWxlY3RvclJlU3VmZml4LCAnbScpO1xuICAgICAgfTtcbiAgICAgIFNoYWRvd0Nzcy5wcm90b3R5cGUuX2FwcGx5U2VsZWN0b3JTY29wZSA9IGZ1bmN0aW9uIChzZWxlY3Rvciwgc2NvcGVTZWxlY3RvciwgaG9zdFNlbGVjdG9yKSB7XG4gICAgICAgICAgLy8gRGlmZmVyZW5jZSBmcm9tIHdlYmNvbXBvbmVudHMuanM6IHNjb3BlU2VsZWN0b3IgY291bGQgbm90IGJlIGFuIGFycmF5XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2FwcGx5U2ltcGxlU2VsZWN0b3JTY29wZShzZWxlY3Rvciwgc2NvcGVTZWxlY3RvciwgaG9zdFNlbGVjdG9yKTtcbiAgICAgIH07XG4gICAgICAvLyBzY29wZSB2aWEgbmFtZSBhbmQgW2lzPW5hbWVdXG4gICAgICBTaGFkb3dDc3MucHJvdG90eXBlLl9hcHBseVNpbXBsZVNlbGVjdG9yU2NvcGUgPSBmdW5jdGlvbiAoc2VsZWN0b3IsIHNjb3BlU2VsZWN0b3IsIGhvc3RTZWxlY3Rvcikge1xuICAgICAgICAgIC8vIEluIEFuZHJvaWQgYnJvd3NlciwgdGhlIGxhc3RJbmRleCBpcyBub3QgcmVzZXQgd2hlbiB0aGUgcmVnZXggaXMgdXNlZCBpbiBTdHJpbmcucmVwbGFjZSgpXG4gICAgICAgICAgX3BvbHlmaWxsSG9zdFJlLmxhc3RJbmRleCA9IDA7XG4gICAgICAgICAgaWYgKF9wb2x5ZmlsbEhvc3RSZS50ZXN0KHNlbGVjdG9yKSkge1xuICAgICAgICAgICAgICB2YXIgcmVwbGFjZUJ5XzEgPSB0aGlzLnN0cmljdFN0eWxpbmcgPyBcIltcIiArIGhvc3RTZWxlY3RvciArIFwiXVwiIDogc2NvcGVTZWxlY3RvcjtcbiAgICAgICAgICAgICAgcmV0dXJuIHNlbGVjdG9yXG4gICAgICAgICAgICAgICAgICAucmVwbGFjZShfcG9seWZpbGxIb3N0Tm9Db21iaW5hdG9yUmUsIGZ1bmN0aW9uIChobmMsIHNlbGVjdG9yKSB7IHJldHVybiBzZWxlY3RvclswXSA9PT0gJzonID8gcmVwbGFjZUJ5XzEgKyBzZWxlY3RvciA6IHNlbGVjdG9yICsgcmVwbGFjZUJ5XzE7IH0pXG4gICAgICAgICAgICAgICAgICAucmVwbGFjZShfcG9seWZpbGxIb3N0UmUsIHJlcGxhY2VCeV8xICsgJyAnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHNjb3BlU2VsZWN0b3IgKyAnICcgKyBzZWxlY3RvcjtcbiAgICAgIH07XG4gICAgICAvLyByZXR1cm4gYSBzZWxlY3RvciB3aXRoIFtuYW1lXSBzdWZmaXggb24gZWFjaCBzaW1wbGUgc2VsZWN0b3JcbiAgICAgIC8vIGUuZy4gLmZvby5iYXIgPiAuem90IGJlY29tZXMgLmZvb1tuYW1lXS5iYXJbbmFtZV0gPiAuem90W25hbWVdICAvKiogQGludGVybmFsICovXG4gICAgICBTaGFkb3dDc3MucHJvdG90eXBlLl9hcHBseVN0cmljdFNlbGVjdG9yU2NvcGUgPSBmdW5jdGlvbiAoc2VsZWN0b3IsIHNjb3BlU2VsZWN0b3IsIGhvc3RTZWxlY3Rvcikge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgdmFyIGlzUmUgPSAvXFxbaXM9KFteXFxdXSopXFxdL2c7XG4gICAgICAgICAgc2NvcGVTZWxlY3RvciA9IHNjb3BlU2VsZWN0b3IucmVwbGFjZShpc1JlLCBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgICB2YXIgcGFydHMgPSBbXTtcbiAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgIHBhcnRzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBwYXJ0c1swXTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YXIgYXR0ck5hbWUgPSAnWycgKyBzY29wZVNlbGVjdG9yICsgJ10nO1xuICAgICAgICAgIHZhciBfc2NvcGVTZWxlY3RvclBhcnQgPSBmdW5jdGlvbiAocCkge1xuICAgICAgICAgICAgICB2YXIgc2NvcGVkUCA9IHAudHJpbSgpO1xuICAgICAgICAgICAgICBpZiAoIXNjb3BlZFApIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAocC5pbmRleE9mKF9wb2x5ZmlsbEhvc3ROb0NvbWJpbmF0b3IpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgIHNjb3BlZFAgPSBfdGhpcy5fYXBwbHlTaW1wbGVTZWxlY3RvclNjb3BlKHAsIHNjb3BlU2VsZWN0b3IsIGhvc3RTZWxlY3Rvcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAvLyByZW1vdmUgOmhvc3Qgc2luY2UgaXQgc2hvdWxkIGJlIHVubmVjZXNzYXJ5XG4gICAgICAgICAgICAgICAgICB2YXIgdCA9IHAucmVwbGFjZShfcG9seWZpbGxIb3N0UmUsICcnKTtcbiAgICAgICAgICAgICAgICAgIGlmICh0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgbWF0Y2hlcyA9IHQubWF0Y2goLyhbXjpdKikoOiopKC4qKS8pO1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaGVzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlZFAgPSBtYXRjaGVzWzFdICsgYXR0ck5hbWUgKyBtYXRjaGVzWzJdICsgbWF0Y2hlc1szXTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHNjb3BlZFA7XG4gICAgICAgICAgfTtcbiAgICAgICAgICB2YXIgYXR0clNlbGVjdG9ySW5kZXggPSAwO1xuICAgICAgICAgIHZhciBhdHRyU2VsZWN0b3JzID0gW107XG4gICAgICAgICAgLy8gcmVwbGFjZSBhdHRyaWJ1dGUgc2VsZWN0b3JzIHdpdGggcGxhY2Vob2xkZXJzIHRvIGF2b2lkIGlzc3VlIHdpdGggd2hpdGUgc3BhY2UgYmVpbmcgdHJlYXRlZFxuICAgICAgICAgIC8vIGFzIHNlcGFyYXRvclxuICAgICAgICAgIHNlbGVjdG9yID0gc2VsZWN0b3IucmVwbGFjZSgvXFxbW15cXF1dKlxcXS9nLCBmdW5jdGlvbiAoYXR0clNlbGVjdG9yKSB7XG4gICAgICAgICAgICAgIHZhciByZXBsYWNlQnkgPSBcIl9fYXR0cl9zZWxfXCIgKyBhdHRyU2VsZWN0b3JJbmRleCArIFwiX19cIjtcbiAgICAgICAgICAgICAgYXR0clNlbGVjdG9ycy5wdXNoKGF0dHJTZWxlY3Rvcik7XG4gICAgICAgICAgICAgIGF0dHJTZWxlY3RvckluZGV4Kys7XG4gICAgICAgICAgICAgIHJldHVybiByZXBsYWNlQnk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdmFyIHNjb3BlZFNlbGVjdG9yID0gJyc7XG4gICAgICAgICAgdmFyIHN0YXJ0SW5kZXggPSAwO1xuICAgICAgICAgIHZhciByZXM7XG4gICAgICAgICAgdmFyIHNlcCA9IC8oIHw+fFxcK3x+KD8hPSkpXFxzKi9nO1xuICAgICAgICAgIHZhciBzY29wZUFmdGVyID0gc2VsZWN0b3IuaW5kZXhPZihfcG9seWZpbGxIb3N0Tm9Db21iaW5hdG9yKTtcbiAgICAgICAgICB3aGlsZSAoKHJlcyA9IHNlcC5leGVjKHNlbGVjdG9yKSkgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgdmFyIHNlcGFyYXRvciA9IHJlc1sxXTtcbiAgICAgICAgICAgICAgdmFyIHBhcnQgPSBzZWxlY3Rvci5zbGljZShzdGFydEluZGV4LCByZXMuaW5kZXgpLnRyaW0oKTtcbiAgICAgICAgICAgICAgLy8gaWYgYSBzZWxlY3RvciBhcHBlYXJzIGJlZm9yZSA6aG9zdC1jb250ZXh0IGl0IHNob3VsZCBub3QgYmUgc2hpbW1lZCBhcyBpdFxuICAgICAgICAgICAgICAvLyBtYXRjaGVzIG9uIGFuY2VzdG9yIGVsZW1lbnRzIGFuZCBub3Qgb24gZWxlbWVudHMgaW4gdGhlIGhvc3QncyBzaGFkb3dcbiAgICAgICAgICAgICAgdmFyIHNjb3BlZFBhcnQgPSBzdGFydEluZGV4ID49IHNjb3BlQWZ0ZXIgPyBfc2NvcGVTZWxlY3RvclBhcnQocGFydCkgOiBwYXJ0O1xuICAgICAgICAgICAgICBzY29wZWRTZWxlY3RvciArPSBzY29wZWRQYXJ0ICsgXCIgXCIgKyBzZXBhcmF0b3IgKyBcIiBcIjtcbiAgICAgICAgICAgICAgc3RhcnRJbmRleCA9IHNlcC5sYXN0SW5kZXg7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNjb3BlZFNlbGVjdG9yICs9IF9zY29wZVNlbGVjdG9yUGFydChzZWxlY3Rvci5zdWJzdHJpbmcoc3RhcnRJbmRleCkpO1xuICAgICAgICAgIC8vIHJlcGxhY2UgdGhlIHBsYWNlaG9sZGVycyB3aXRoIHRoZWlyIG9yaWdpbmFsIHZhbHVlc1xuICAgICAgICAgIHJldHVybiBzY29wZWRTZWxlY3Rvci5yZXBsYWNlKC9fX2F0dHJfc2VsXyhcXGQrKV9fL2csIGZ1bmN0aW9uIChwaCwgaW5kZXgpIHsgcmV0dXJuIGF0dHJTZWxlY3RvcnNbK2luZGV4XTsgfSk7XG4gICAgICB9O1xuICAgICAgU2hhZG93Q3NzLnByb3RvdHlwZS5faW5zZXJ0UG9seWZpbGxIb3N0SW5Dc3NUZXh0ID0gZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgICAgICAgcmV0dXJuIHNlbGVjdG9yLnJlcGxhY2UoX2NvbG9uSG9zdENvbnRleHRSZSwgX3BvbHlmaWxsSG9zdENvbnRleHQpXG4gICAgICAgICAgICAgIC5yZXBsYWNlKF9jb2xvbkhvc3RSZSwgX3BvbHlmaWxsSG9zdCk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIFNoYWRvd0NzcztcbiAgfSgpKTtcbiAgdmFyIF9jc3NDb250ZW50TmV4dFNlbGVjdG9yUmUgPSAvcG9seWZpbGwtbmV4dC1zZWxlY3RvcltefV0qY29udGVudDpbXFxzXSo/KFsnXCJdKSguKj8pXFwxWztcXHNdKn0oW157XSo/KXsvZ2ltO1xuICB2YXIgX2Nzc0NvbnRlbnRSdWxlUmUgPSAvKHBvbHlmaWxsLXJ1bGUpW159XSooY29udGVudDpbXFxzXSooWydcIl0pKC4qPylcXDMpWztcXHNdKltefV0qfS9naW07XG4gIHZhciBfY3NzQ29udGVudFVuc2NvcGVkUnVsZVJlID0gLyhwb2x5ZmlsbC11bnNjb3BlZC1ydWxlKVtefV0qKGNvbnRlbnQ6W1xcc10qKFsnXCJdKSguKj8pXFwzKVs7XFxzXSpbXn1dKn0vZ2ltO1xuICB2YXIgX3BvbHlmaWxsSG9zdCA9ICctc2hhZG93Y3NzaG9zdCc7XG4gIC8vIG5vdGU6IDpob3N0LWNvbnRleHQgcHJlLXByb2Nlc3NlZCB0byAtc2hhZG93Y3NzaG9zdGNvbnRleHQuXG4gIHZhciBfcG9seWZpbGxIb3N0Q29udGV4dCA9ICctc2hhZG93Y3NzY29udGV4dCc7XG4gIHZhciBfcGFyZW5TdWZmaXggPSAnKSg/OlxcXFwoKCcgK1xuICAgICAgJyg/OlxcXFwoW14pKF0qXFxcXCl8W14pKF0qKSs/JyArXG4gICAgICAnKVxcXFwpKT8oW14se10qKSc7XG4gIHZhciBfY3NzQ29sb25Ib3N0UmUgPSBuZXcgUmVnRXhwKCcoJyArIF9wb2x5ZmlsbEhvc3QgKyBfcGFyZW5TdWZmaXgsICdnaW0nKTtcbiAgdmFyIF9jc3NDb2xvbkhvc3RDb250ZXh0UmUgPSBuZXcgUmVnRXhwKCcoJyArIF9wb2x5ZmlsbEhvc3RDb250ZXh0ICsgX3BhcmVuU3VmZml4LCAnZ2ltJyk7XG4gIHZhciBfcG9seWZpbGxIb3N0Tm9Db21iaW5hdG9yID0gX3BvbHlmaWxsSG9zdCArICctbm8tY29tYmluYXRvcic7XG4gIHZhciBfcG9seWZpbGxIb3N0Tm9Db21iaW5hdG9yUmUgPSAvLXNoYWRvd2Nzc2hvc3Qtbm8tY29tYmluYXRvcihbXlxcc10qKS87XG4gIHZhciBfc2hhZG93RE9NU2VsZWN0b3JzUmUgPSBbXG4gICAgICAvOjpzaGFkb3cvZyxcbiAgICAgIC86OmNvbnRlbnQvZyxcbiAgICAgIC8vIERlcHJlY2F0ZWQgc2VsZWN0b3JzXG4gICAgICAvXFwvc2hhZG93LWRlZXBcXC8vZyxcbiAgICAgIC9cXC9zaGFkb3dcXC8vZyxcbiAgXTtcbiAgdmFyIF9zaGFkb3dEZWVwU2VsZWN0b3JzID0gLyg/Oj4+Pil8KD86XFwvZGVlcFxcLykvZztcbiAgdmFyIF9zZWxlY3RvclJlU3VmZml4ID0gJyhbPlxcXFxzfitcXFsuLHs6XVtcXFxcc1xcXFxTXSopPyQnO1xuICB2YXIgX3BvbHlmaWxsSG9zdFJlID0gLy1zaGFkb3djc3Nob3N0L2dpbTtcbiAgdmFyIF9jb2xvbkhvc3RSZSA9IC86aG9zdC9naW07XG4gIHZhciBfY29sb25Ib3N0Q29udGV4dFJlID0gLzpob3N0LWNvbnRleHQvZ2ltO1xuICB2YXIgX2NvbW1lbnRSZSA9IC9cXC9cXCpcXHMqW1xcc1xcU10qP1xcKlxcLy9nO1xuICBmdW5jdGlvbiBzdHJpcENvbW1lbnRzKGlucHV0KSB7XG4gICAgICByZXR1cm4gaW5wdXQucmVwbGFjZShfY29tbWVudFJlLCAnJyk7XG4gIH1cbiAgLy8gYWxsIGNvbW1lbnRzIGV4Y2VwdCBpbmxpbmUgc291cmNlIG1hcHBpbmdcbiAgdmFyIF9zb3VyY2VNYXBwaW5nVXJsUmUgPSAvXFwvXFwqXFxzKiNcXHMqc291cmNlTWFwcGluZ1VSTD1bXFxzXFxTXSs/XFwqXFwvLztcbiAgZnVuY3Rpb24gZXh0cmFjdFNvdXJjZU1hcHBpbmdVcmwoaW5wdXQpIHtcbiAgICAgIHZhciBtYXRjaGVyID0gaW5wdXQubWF0Y2goX3NvdXJjZU1hcHBpbmdVcmxSZSk7XG4gICAgICByZXR1cm4gbWF0Y2hlciA/IG1hdGNoZXJbMF0gOiAnJztcbiAgfVxuICB2YXIgX3J1bGVSZSA9IC8oXFxzKikoW147XFx7XFx9XSs/KShcXHMqKSgoPzp7JUJMT0NLJX0/XFxzKjs/KXwoPzpcXHMqOykpL2c7XG4gIHZhciBfY3VybHlSZSA9IC8oW3t9XSkvZztcbiAgdmFyIE9QRU5fQ1VSTFkgPSAneyc7XG4gIHZhciBDTE9TRV9DVVJMWSA9ICd9JztcbiAgdmFyIEJMT0NLX1BMQUNFSE9MREVSID0gJyVCTE9DSyUnO1xuICB2YXIgQ3NzUnVsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBDc3NSdWxlKHNlbGVjdG9yLCBjb250ZW50KSB7XG4gICAgICAgICAgdGhpcy5zZWxlY3RvciA9IHNlbGVjdG9yO1xuICAgICAgICAgIHRoaXMuY29udGVudCA9IGNvbnRlbnQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gQ3NzUnVsZTtcbiAgfSgpKTtcbiAgZnVuY3Rpb24gcHJvY2Vzc1J1bGVzKGlucHV0LCBydWxlQ2FsbGJhY2spIHtcbiAgICAgIHZhciBpbnB1dFdpdGhFc2NhcGVkQmxvY2tzID0gZXNjYXBlQmxvY2tzKGlucHV0KTtcbiAgICAgIHZhciBuZXh0QmxvY2tJbmRleCA9IDA7XG4gICAgICByZXR1cm4gaW5wdXRXaXRoRXNjYXBlZEJsb2Nrcy5lc2NhcGVkU3RyaW5nLnJlcGxhY2UoX3J1bGVSZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBtID0gW107XG4gICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgbVtfaSAtIDBdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHNlbGVjdG9yID0gbVsyXTtcbiAgICAgICAgICB2YXIgY29udGVudCA9ICcnO1xuICAgICAgICAgIHZhciBzdWZmaXggPSBtWzRdO1xuICAgICAgICAgIHZhciBjb250ZW50UHJlZml4ID0gJyc7XG4gICAgICAgICAgaWYgKHN1ZmZpeCAmJiBzdWZmaXguc3RhcnRzV2l0aCgneycgKyBCTE9DS19QTEFDRUhPTERFUikpIHtcbiAgICAgICAgICAgICAgY29udGVudCA9IGlucHV0V2l0aEVzY2FwZWRCbG9ja3MuYmxvY2tzW25leHRCbG9ja0luZGV4KytdO1xuICAgICAgICAgICAgICBzdWZmaXggPSBzdWZmaXguc3Vic3RyaW5nKEJMT0NLX1BMQUNFSE9MREVSLmxlbmd0aCArIDEpO1xuICAgICAgICAgICAgICBjb250ZW50UHJlZml4ID0gJ3snO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgcnVsZSA9IHJ1bGVDYWxsYmFjayhuZXcgQ3NzUnVsZShzZWxlY3RvciwgY29udGVudCkpO1xuICAgICAgICAgIHJldHVybiBcIlwiICsgbVsxXSArIHJ1bGUuc2VsZWN0b3IgKyBtWzNdICsgY29udGVudFByZWZpeCArIHJ1bGUuY29udGVudCArIHN1ZmZpeDtcbiAgICAgIH0pO1xuICB9XG4gIHZhciBTdHJpbmdXaXRoRXNjYXBlZEJsb2NrcyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBTdHJpbmdXaXRoRXNjYXBlZEJsb2Nrcyhlc2NhcGVkU3RyaW5nLCBibG9ja3MpIHtcbiAgICAgICAgICB0aGlzLmVzY2FwZWRTdHJpbmcgPSBlc2NhcGVkU3RyaW5nO1xuICAgICAgICAgIHRoaXMuYmxvY2tzID0gYmxvY2tzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFN0cmluZ1dpdGhFc2NhcGVkQmxvY2tzO1xuICB9KCkpO1xuICBmdW5jdGlvbiBlc2NhcGVCbG9ja3MoaW5wdXQpIHtcbiAgICAgIHZhciBpbnB1dFBhcnRzID0gaW5wdXQuc3BsaXQoX2N1cmx5UmUpO1xuICAgICAgdmFyIHJlc3VsdFBhcnRzID0gW107XG4gICAgICB2YXIgZXNjYXBlZEJsb2NrcyA9IFtdO1xuICAgICAgdmFyIGJyYWNrZXRDb3VudCA9IDA7XG4gICAgICB2YXIgY3VycmVudEJsb2NrUGFydHMgPSBbXTtcbiAgICAgIGZvciAodmFyIHBhcnRJbmRleCA9IDA7IHBhcnRJbmRleCA8IGlucHV0UGFydHMubGVuZ3RoOyBwYXJ0SW5kZXgrKykge1xuICAgICAgICAgIHZhciBwYXJ0ID0gaW5wdXRQYXJ0c1twYXJ0SW5kZXhdO1xuICAgICAgICAgIGlmIChwYXJ0ID09IENMT1NFX0NVUkxZKSB7XG4gICAgICAgICAgICAgIGJyYWNrZXRDb3VudC0tO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYnJhY2tldENvdW50ID4gMCkge1xuICAgICAgICAgICAgICBjdXJyZW50QmxvY2tQYXJ0cy5wdXNoKHBhcnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKGN1cnJlbnRCbG9ja1BhcnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgIGVzY2FwZWRCbG9ja3MucHVzaChjdXJyZW50QmxvY2tQYXJ0cy5qb2luKCcnKSk7XG4gICAgICAgICAgICAgICAgICByZXN1bHRQYXJ0cy5wdXNoKEJMT0NLX1BMQUNFSE9MREVSKTtcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnRCbG9ja1BhcnRzID0gW107XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVzdWx0UGFydHMucHVzaChwYXJ0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHBhcnQgPT0gT1BFTl9DVVJMWSkge1xuICAgICAgICAgICAgICBicmFja2V0Q291bnQrKztcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY3VycmVudEJsb2NrUGFydHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGVzY2FwZWRCbG9ja3MucHVzaChjdXJyZW50QmxvY2tQYXJ0cy5qb2luKCcnKSk7XG4gICAgICAgICAgcmVzdWx0UGFydHMucHVzaChCTE9DS19QTEFDRUhPTERFUik7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IFN0cmluZ1dpdGhFc2NhcGVkQmxvY2tzKHJlc3VsdFBhcnRzLmpvaW4oJycpLCBlc2NhcGVkQmxvY2tzKTtcbiAgfVxuXG4gIHZhciBDT01QT05FTlRfVkFSSUFCTEUgPSAnJUNPTVAlJztcbiAgdmFyIEhPU1RfQVRUUiA9IFwiX25naG9zdC1cIiArIENPTVBPTkVOVF9WQVJJQUJMRTtcbiAgdmFyIENPTlRFTlRfQVRUUiA9IFwiX25nY29udGVudC1cIiArIENPTVBPTkVOVF9WQVJJQUJMRTtcbiAgdmFyIFN0eWxlc0NvbXBpbGVEZXBlbmRlbmN5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIFN0eWxlc0NvbXBpbGVEZXBlbmRlbmN5KG1vZHVsZVVybCwgaXNTaGltbWVkLCB2YWx1ZVBsYWNlaG9sZGVyKSB7XG4gICAgICAgICAgdGhpcy5tb2R1bGVVcmwgPSBtb2R1bGVVcmw7XG4gICAgICAgICAgdGhpcy5pc1NoaW1tZWQgPSBpc1NoaW1tZWQ7XG4gICAgICAgICAgdGhpcy52YWx1ZVBsYWNlaG9sZGVyID0gdmFsdWVQbGFjZWhvbGRlcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBTdHlsZXNDb21waWxlRGVwZW5kZW5jeTtcbiAgfSgpKTtcbiAgdmFyIFN0eWxlc0NvbXBpbGVSZXN1bHQgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gU3R5bGVzQ29tcGlsZVJlc3VsdChjb21wb25lbnRTdHlsZXNoZWV0LCBleHRlcm5hbFN0eWxlc2hlZXRzKSB7XG4gICAgICAgICAgdGhpcy5jb21wb25lbnRTdHlsZXNoZWV0ID0gY29tcG9uZW50U3R5bGVzaGVldDtcbiAgICAgICAgICB0aGlzLmV4dGVybmFsU3R5bGVzaGVldHMgPSBleHRlcm5hbFN0eWxlc2hlZXRzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFN0eWxlc0NvbXBpbGVSZXN1bHQ7XG4gIH0oKSk7XG4gIHZhciBDb21waWxlZFN0eWxlc2hlZXQgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gQ29tcGlsZWRTdHlsZXNoZWV0KHN0YXRlbWVudHMsIHN0eWxlc1ZhciwgZGVwZW5kZW5jaWVzLCBpc1NoaW1tZWQsIG1ldGEpIHtcbiAgICAgICAgICB0aGlzLnN0YXRlbWVudHMgPSBzdGF0ZW1lbnRzO1xuICAgICAgICAgIHRoaXMuc3R5bGVzVmFyID0gc3R5bGVzVmFyO1xuICAgICAgICAgIHRoaXMuZGVwZW5kZW5jaWVzID0gZGVwZW5kZW5jaWVzO1xuICAgICAgICAgIHRoaXMuaXNTaGltbWVkID0gaXNTaGltbWVkO1xuICAgICAgICAgIHRoaXMubWV0YSA9IG1ldGE7XG4gICAgICB9XG4gICAgICByZXR1cm4gQ29tcGlsZWRTdHlsZXNoZWV0O1xuICB9KCkpO1xuICB2YXIgU3R5bGVDb21waWxlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBTdHlsZUNvbXBpbGVyKF91cmxSZXNvbHZlcikge1xuICAgICAgICAgIHRoaXMuX3VybFJlc29sdmVyID0gX3VybFJlc29sdmVyO1xuICAgICAgICAgIHRoaXMuX3NoYWRvd0NzcyA9IG5ldyBTaGFkb3dDc3MoKTtcbiAgICAgIH1cbiAgICAgIFN0eWxlQ29tcGlsZXIucHJvdG90eXBlLmNvbXBpbGVDb21wb25lbnQgPSBmdW5jdGlvbiAoY29tcCkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgdmFyIGV4dGVybmFsU3R5bGVzaGVldHMgPSBbXTtcbiAgICAgICAgICB2YXIgY29tcG9uZW50U3R5bGVzaGVldCA9IHRoaXMuX2NvbXBpbGVTdHlsZXMoY29tcCwgbmV3IENvbXBpbGVTdHlsZXNoZWV0TWV0YWRhdGEoe1xuICAgICAgICAgICAgICBzdHlsZXM6IGNvbXAudGVtcGxhdGUuc3R5bGVzLFxuICAgICAgICAgICAgICBzdHlsZVVybHM6IGNvbXAudGVtcGxhdGUuc3R5bGVVcmxzLFxuICAgICAgICAgICAgICBtb2R1bGVVcmw6IGNvbXAudHlwZS5tb2R1bGVVcmxcbiAgICAgICAgICB9KSwgdHJ1ZSk7XG4gICAgICAgICAgY29tcC50ZW1wbGF0ZS5leHRlcm5hbFN0eWxlc2hlZXRzLmZvckVhY2goZnVuY3Rpb24gKHN0eWxlc2hlZXRNZXRhKSB7XG4gICAgICAgICAgICAgIHZhciBjb21waWxlZFN0eWxlc2hlZXQgPSBfdGhpcy5fY29tcGlsZVN0eWxlcyhjb21wLCBzdHlsZXNoZWV0TWV0YSwgZmFsc2UpO1xuICAgICAgICAgICAgICBleHRlcm5hbFN0eWxlc2hlZXRzLnB1c2goY29tcGlsZWRTdHlsZXNoZWV0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gbmV3IFN0eWxlc0NvbXBpbGVSZXN1bHQoY29tcG9uZW50U3R5bGVzaGVldCwgZXh0ZXJuYWxTdHlsZXNoZWV0cyk7XG4gICAgICB9O1xuICAgICAgU3R5bGVDb21waWxlci5wcm90b3R5cGUuX2NvbXBpbGVTdHlsZXMgPSBmdW5jdGlvbiAoY29tcCwgc3R5bGVzaGVldCwgaXNDb21wb25lbnRTdHlsZXNoZWV0KSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICB2YXIgc2hpbSA9IGNvbXAudGVtcGxhdGUuZW5jYXBzdWxhdGlvbiA9PT0gX2FuZ3VsYXJfY29yZS5WaWV3RW5jYXBzdWxhdGlvbi5FbXVsYXRlZDtcbiAgICAgICAgICB2YXIgc3R5bGVFeHByZXNzaW9ucyA9IHN0eWxlc2hlZXQuc3R5bGVzLm1hcChmdW5jdGlvbiAocGxhaW5TdHlsZSkgeyByZXR1cm4gbGl0ZXJhbChfdGhpcy5fc2hpbUlmTmVlZGVkKHBsYWluU3R5bGUsIHNoaW0pKTsgfSk7XG4gICAgICAgICAgdmFyIGRlcGVuZGVuY2llcyA9IFtdO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzaGVldC5zdHlsZVVybHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFyIGlkZW50aWZpZXIgPSBuZXcgQ29tcGlsZUlkZW50aWZpZXJNZXRhZGF0YSh7IG5hbWU6IGdldFN0eWxlc1Zhck5hbWUobnVsbCkgfSk7XG4gICAgICAgICAgICAgIGRlcGVuZGVuY2llcy5wdXNoKG5ldyBTdHlsZXNDb21waWxlRGVwZW5kZW5jeShzdHlsZXNoZWV0LnN0eWxlVXJsc1tpXSwgc2hpbSwgaWRlbnRpZmllcikpO1xuICAgICAgICAgICAgICBzdHlsZUV4cHJlc3Npb25zLnB1c2gobmV3IEV4dGVybmFsRXhwcihpZGVudGlmaWVyKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHN0eWxlcyB2YXJpYWJsZSBjb250YWlucyBwbGFpbiBzdHJpbmdzIGFuZCBhcnJheXMgb2Ygb3RoZXIgc3R5bGVzIGFycmF5cyAocmVjdXJzaXZlKSxcbiAgICAgICAgICAvLyBzbyB3ZSBzZXQgaXRzIHR5cGUgdG8gZHluYW1pYy5cbiAgICAgICAgICB2YXIgc3R5bGVzVmFyID0gZ2V0U3R5bGVzVmFyTmFtZShpc0NvbXBvbmVudFN0eWxlc2hlZXQgPyBjb21wIDogbnVsbCk7XG4gICAgICAgICAgdmFyIHN0bXQgPSB2YXJpYWJsZShzdHlsZXNWYXIpXG4gICAgICAgICAgICAgIC5zZXQobGl0ZXJhbEFycihzdHlsZUV4cHJlc3Npb25zLCBuZXcgQXJyYXlUeXBlKERZTkFNSUNfVFlQRSwgW1R5cGVNb2RpZmllci5Db25zdF0pKSlcbiAgICAgICAgICAgICAgLnRvRGVjbFN0bXQobnVsbCwgW1N0bXRNb2RpZmllci5GaW5hbF0pO1xuICAgICAgICAgIHJldHVybiBuZXcgQ29tcGlsZWRTdHlsZXNoZWV0KFtzdG10XSwgc3R5bGVzVmFyLCBkZXBlbmRlbmNpZXMsIHNoaW0sIHN0eWxlc2hlZXQpO1xuICAgICAgfTtcbiAgICAgIFN0eWxlQ29tcGlsZXIucHJvdG90eXBlLl9zaGltSWZOZWVkZWQgPSBmdW5jdGlvbiAoc3R5bGUsIHNoaW0pIHtcbiAgICAgICAgICByZXR1cm4gc2hpbSA/IHRoaXMuX3NoYWRvd0Nzcy5zaGltQ3NzVGV4dChzdHlsZSwgQ09OVEVOVF9BVFRSLCBIT1NUX0FUVFIpIDogc3R5bGU7XG4gICAgICB9O1xuICAgICAgU3R5bGVDb21waWxlci5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3RhYmxlIH0sXG4gICAgICBdO1xuICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICBTdHlsZUNvbXBpbGVyLmN0b3JQYXJhbWV0ZXJzID0gW1xuICAgICAgICAgIHsgdHlwZTogVXJsUmVzb2x2ZXIsIH0sXG4gICAgICBdO1xuICAgICAgcmV0dXJuIFN0eWxlQ29tcGlsZXI7XG4gIH0oKSk7XG4gIGZ1bmN0aW9uIGdldFN0eWxlc1Zhck5hbWUoY29tcG9uZW50KSB7XG4gICAgICB2YXIgcmVzdWx0ID0gXCJzdHlsZXNcIjtcbiAgICAgIGlmIChjb21wb25lbnQpIHtcbiAgICAgICAgICByZXN1bHQgKz0gXCJfXCIgKyBjb21wb25lbnQudHlwZS5uYW1lO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbiBpbnRlcm5hbCBtb2R1bGUgb2YgdGhlIEFuZ3VsYXIgY29tcGlsZXIgdGhhdCBiZWdpbnMgd2l0aCBjb21wb25lbnQgdHlwZXMsXG4gICAqIGV4dHJhY3RzIHRlbXBsYXRlcywgYW5kIGV2ZW50dWFsbHkgcHJvZHVjZXMgYSBjb21waWxlZCB2ZXJzaW9uIG9mIHRoZSBjb21wb25lbnRcbiAgICogcmVhZHkgZm9yIGxpbmtpbmcgaW50byBhbiBhcHBsaWNhdGlvbi5cbiAgICpcbiAgICogQHNlY3VyaXR5ICBXaGVuIGNvbXBpbGluZyB0ZW1wbGF0ZXMgYXQgcnVudGltZSwgeW91IG11c3QgZW5zdXJlIHRoYXQgdGhlIGVudGlyZSB0ZW1wbGF0ZSBjb21lc1xuICAgKiBmcm9tIGEgdHJ1c3RlZCBzb3VyY2UuIEF0dGFja2VyLWNvbnRyb2xsZWQgZGF0YSBpbnRyb2R1Y2VkIGJ5IGEgdGVtcGxhdGUgY291bGQgZXhwb3NlIHlvdXJcbiAgICogYXBwbGljYXRpb24gdG8gWFNTIHJpc2tzLiAgRm9yIG1vcmUgZGV0YWlsLCBzZWUgdGhlIFtTZWN1cml0eSBHdWlkZV0oaHR0cDovL2cuY28vbmcvc2VjdXJpdHkpLlxuICAgKi9cbiAgdmFyIFJ1bnRpbWVDb21waWxlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBSdW50aW1lQ29tcGlsZXIoX2luamVjdG9yLCBfbWV0YWRhdGFSZXNvbHZlciwgX3RlbXBsYXRlTm9ybWFsaXplciwgX3RlbXBsYXRlUGFyc2VyLCBfc3R5bGVDb21waWxlciwgX3ZpZXdDb21waWxlciwgX25nTW9kdWxlQ29tcGlsZXIsIF9kaXJlY3RpdmVXcmFwcGVyQ29tcGlsZXIsIF9jb21waWxlckNvbmZpZykge1xuICAgICAgICAgIHRoaXMuX2luamVjdG9yID0gX2luamVjdG9yO1xuICAgICAgICAgIHRoaXMuX21ldGFkYXRhUmVzb2x2ZXIgPSBfbWV0YWRhdGFSZXNvbHZlcjtcbiAgICAgICAgICB0aGlzLl90ZW1wbGF0ZU5vcm1hbGl6ZXIgPSBfdGVtcGxhdGVOb3JtYWxpemVyO1xuICAgICAgICAgIHRoaXMuX3RlbXBsYXRlUGFyc2VyID0gX3RlbXBsYXRlUGFyc2VyO1xuICAgICAgICAgIHRoaXMuX3N0eWxlQ29tcGlsZXIgPSBfc3R5bGVDb21waWxlcjtcbiAgICAgICAgICB0aGlzLl92aWV3Q29tcGlsZXIgPSBfdmlld0NvbXBpbGVyO1xuICAgICAgICAgIHRoaXMuX25nTW9kdWxlQ29tcGlsZXIgPSBfbmdNb2R1bGVDb21waWxlcjtcbiAgICAgICAgICB0aGlzLl9kaXJlY3RpdmVXcmFwcGVyQ29tcGlsZXIgPSBfZGlyZWN0aXZlV3JhcHBlckNvbXBpbGVyO1xuICAgICAgICAgIHRoaXMuX2NvbXBpbGVyQ29uZmlnID0gX2NvbXBpbGVyQ29uZmlnO1xuICAgICAgICAgIHRoaXMuX2NvbXBpbGVkVGVtcGxhdGVDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgICB0aGlzLl9jb21waWxlZEhvc3RUZW1wbGF0ZUNhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgICAgIHRoaXMuX2NvbXBpbGVkRGlyZWN0aXZlV3JhcHBlckNhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgICAgIHRoaXMuX2NvbXBpbGVkTmdNb2R1bGVDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgICB0aGlzLl9hbmltYXRpb25QYXJzZXIgPSBuZXcgQW5pbWF0aW9uUGFyc2VyKCk7XG4gICAgICAgICAgdGhpcy5fYW5pbWF0aW9uQ29tcGlsZXIgPSBuZXcgQW5pbWF0aW9uQ29tcGlsZXIoKTtcbiAgICAgIH1cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSdW50aW1lQ29tcGlsZXIucHJvdG90eXBlLCBcImluamVjdG9yXCIsIHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2luamVjdG9yOyB9LFxuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIFJ1bnRpbWVDb21waWxlci5wcm90b3R5cGUuY29tcGlsZU1vZHVsZVN5bmMgPSBmdW5jdGlvbiAobW9kdWxlVHlwZSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9jb21waWxlTW9kdWxlQW5kQ29tcG9uZW50cyhtb2R1bGVUeXBlLCB0cnVlKS5zeW5jUmVzdWx0O1xuICAgICAgfTtcbiAgICAgIFJ1bnRpbWVDb21waWxlci5wcm90b3R5cGUuY29tcGlsZU1vZHVsZUFzeW5jID0gZnVuY3Rpb24gKG1vZHVsZVR5cGUpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fY29tcGlsZU1vZHVsZUFuZENvbXBvbmVudHMobW9kdWxlVHlwZSwgZmFsc2UpLmFzeW5jUmVzdWx0O1xuICAgICAgfTtcbiAgICAgIFJ1bnRpbWVDb21waWxlci5wcm90b3R5cGUuY29tcGlsZU1vZHVsZUFuZEFsbENvbXBvbmVudHNTeW5jID0gZnVuY3Rpb24gKG1vZHVsZVR5cGUpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fY29tcGlsZU1vZHVsZUFuZEFsbENvbXBvbmVudHMobW9kdWxlVHlwZSwgdHJ1ZSkuc3luY1Jlc3VsdDtcbiAgICAgIH07XG4gICAgICBSdW50aW1lQ29tcGlsZXIucHJvdG90eXBlLmNvbXBpbGVNb2R1bGVBbmRBbGxDb21wb25lbnRzQXN5bmMgPSBmdW5jdGlvbiAobW9kdWxlVHlwZSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9jb21waWxlTW9kdWxlQW5kQWxsQ29tcG9uZW50cyhtb2R1bGVUeXBlLCBmYWxzZSkuYXN5bmNSZXN1bHQ7XG4gICAgICB9O1xuICAgICAgUnVudGltZUNvbXBpbGVyLnByb3RvdHlwZS5fY29tcGlsZU1vZHVsZUFuZENvbXBvbmVudHMgPSBmdW5jdGlvbiAobW9kdWxlVHlwZSwgaXNTeW5jKSB7XG4gICAgICAgICAgdmFyIGNvbXBvbmVudFByb21pc2UgPSB0aGlzLl9jb21waWxlQ29tcG9uZW50cyhtb2R1bGVUeXBlLCBpc1N5bmMpO1xuICAgICAgICAgIHZhciBuZ01vZHVsZUZhY3RvcnkgPSB0aGlzLl9jb21waWxlTW9kdWxlKG1vZHVsZVR5cGUpO1xuICAgICAgICAgIHJldHVybiBuZXcgU3luY0FzeW5jUmVzdWx0KG5nTW9kdWxlRmFjdG9yeSwgY29tcG9uZW50UHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5nTW9kdWxlRmFjdG9yeTsgfSkpO1xuICAgICAgfTtcbiAgICAgIFJ1bnRpbWVDb21waWxlci5wcm90b3R5cGUuX2NvbXBpbGVNb2R1bGVBbmRBbGxDb21wb25lbnRzID0gZnVuY3Rpb24gKG1vZHVsZVR5cGUsIGlzU3luYykge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgdmFyIGNvbXBvbmVudFByb21pc2UgPSB0aGlzLl9jb21waWxlQ29tcG9uZW50cyhtb2R1bGVUeXBlLCBpc1N5bmMpO1xuICAgICAgICAgIHZhciBuZ01vZHVsZUZhY3RvcnkgPSB0aGlzLl9jb21waWxlTW9kdWxlKG1vZHVsZVR5cGUpO1xuICAgICAgICAgIHZhciBtb2R1bGVNZXRhID0gdGhpcy5fbWV0YWRhdGFSZXNvbHZlci5nZXROZ01vZHVsZU1ldGFkYXRhKG1vZHVsZVR5cGUpO1xuICAgICAgICAgIHZhciBjb21wb25lbnRGYWN0b3JpZXMgPSBbXTtcbiAgICAgICAgICB2YXIgdGVtcGxhdGVzID0gbmV3IFNldCgpO1xuICAgICAgICAgIG1vZHVsZU1ldGEudHJhbnNpdGl2ZU1vZHVsZS5tb2R1bGVzLmZvckVhY2goZnVuY3Rpb24gKGxvY2FsTW9kdWxlTWV0YSkge1xuICAgICAgICAgICAgICBsb2NhbE1vZHVsZU1ldGEuZGVjbGFyZWREaXJlY3RpdmVzLmZvckVhY2goZnVuY3Rpb24gKGRpck1ldGEpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChkaXJNZXRhLmlzQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIHRlbXBsYXRlID0gX3RoaXMuX2NyZWF0ZUNvbXBpbGVkSG9zdFRlbXBsYXRlKGRpck1ldGEudHlwZS5yZWZlcmVuY2UsIGxvY2FsTW9kdWxlTWV0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGVzLmFkZCh0ZW1wbGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50RmFjdG9yaWVzLnB1c2godGVtcGxhdGUucHJveHlDb21wb25lbnRGYWN0b3J5KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdmFyIHN5bmNSZXN1bHQgPSBuZXcgX2FuZ3VsYXJfY29yZS5Nb2R1bGVXaXRoQ29tcG9uZW50RmFjdG9yaWVzKG5nTW9kdWxlRmFjdG9yeSwgY29tcG9uZW50RmFjdG9yaWVzKTtcbiAgICAgICAgICAvLyBOb3RlOiBob3N0IGNvbXBvbmVudHMgdGhlbXNlbHZlcyBjYW4gYWx3YXlzIGJlIGNvbXBpbGVkIHN5bmNocm9ub3VzbHkgYXMgdGhleSBoYXZlIGFuXG4gICAgICAgICAgLy8gaW5saW5lIHRlbXBsYXRlLiBIb3dldmVyLCB3ZSBzdGlsbCBuZWVkIHRvIHdhaXQgZm9yIHRoZSBjb21wb25lbnRzIHRoYXQgdGhleVxuICAgICAgICAgIC8vIHJlZmVyZW5jZSB0byBiZSBsb2FkZWQgLyBjb21waWxlZC5cbiAgICAgICAgICB2YXIgY29tcGlsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdGVtcGxhdGVzLmZvckVhY2goZnVuY3Rpb24gKHRlbXBsYXRlKSB7IF90aGlzLl9jb21waWxlVGVtcGxhdGUodGVtcGxhdGUpOyB9KTtcbiAgICAgICAgICAgICAgcmV0dXJuIHN5bmNSZXN1bHQ7XG4gICAgICAgICAgfTtcbiAgICAgICAgICB2YXIgYXN5bmNSZXN1bHQgPSBpc1N5bmMgPyBQcm9taXNlLnJlc29sdmUoY29tcGlsZSgpKSA6IGNvbXBvbmVudFByb21pc2UudGhlbihjb21waWxlKTtcbiAgICAgICAgICByZXR1cm4gbmV3IFN5bmNBc3luY1Jlc3VsdChzeW5jUmVzdWx0LCBhc3luY1Jlc3VsdCk7XG4gICAgICB9O1xuICAgICAgUnVudGltZUNvbXBpbGVyLnByb3RvdHlwZS5fY29tcGlsZU1vZHVsZSA9IGZ1bmN0aW9uIChtb2R1bGVUeXBlKSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICB2YXIgbmdNb2R1bGVGYWN0b3J5ID0gdGhpcy5fY29tcGlsZWROZ01vZHVsZUNhY2hlLmdldChtb2R1bGVUeXBlKTtcbiAgICAgICAgICBpZiAoIW5nTW9kdWxlRmFjdG9yeSkge1xuICAgICAgICAgICAgICB2YXIgbW9kdWxlTWV0YV8xID0gdGhpcy5fbWV0YWRhdGFSZXNvbHZlci5nZXROZ01vZHVsZU1ldGFkYXRhKG1vZHVsZVR5cGUpO1xuICAgICAgICAgICAgICAvLyBBbHdheXMgcHJvdmlkZSBhIGJvdW5kIENvbXBpbGVyXG4gICAgICAgICAgICAgIHZhciBleHRyYVByb3ZpZGVycyA9IFt0aGlzLl9tZXRhZGF0YVJlc29sdmVyLmdldFByb3ZpZGVyTWV0YWRhdGEobmV3IFByb3ZpZGVyTWV0YShfYW5ndWxhcl9jb3JlLkNvbXBpbGVyLCB7IHVzZUZhY3Rvcnk6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBNb2R1bGVCb3VuZENvbXBpbGVyKF90aGlzLCBtb2R1bGVNZXRhXzEudHlwZS5yZWZlcmVuY2UpOyB9IH0pKV07XG4gICAgICAgICAgICAgIHZhciBjb21waWxlUmVzdWx0ID0gdGhpcy5fbmdNb2R1bGVDb21waWxlci5jb21waWxlKG1vZHVsZU1ldGFfMSwgZXh0cmFQcm92aWRlcnMpO1xuICAgICAgICAgICAgICBjb21waWxlUmVzdWx0LmRlcGVuZGVuY2llcy5mb3JFYWNoKGZ1bmN0aW9uIChkZXApIHtcbiAgICAgICAgICAgICAgICAgIGRlcC5wbGFjZWhvbGRlci5yZWZlcmVuY2UgPVxuICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9hc3NlcnRDb21wb25lbnRLbm93bihkZXAuY29tcC5yZWZlcmVuY2UsIHRydWUpLnByb3h5Q29tcG9uZW50RmFjdG9yeTtcbiAgICAgICAgICAgICAgICAgIGRlcC5wbGFjZWhvbGRlci5uYW1lID0gXCJjb21wRmFjdG9yeV9cIiArIGRlcC5jb21wLm5hbWU7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBpZiAoIXRoaXMuX2NvbXBpbGVyQ29uZmlnLnVzZUppdCkge1xuICAgICAgICAgICAgICAgICAgbmdNb2R1bGVGYWN0b3J5ID1cbiAgICAgICAgICAgICAgICAgICAgICBpbnRlcnByZXRTdGF0ZW1lbnRzKGNvbXBpbGVSZXN1bHQuc3RhdGVtZW50cywgY29tcGlsZVJlc3VsdC5uZ01vZHVsZUZhY3RvcnlWYXIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgbmdNb2R1bGVGYWN0b3J5ID0gaml0U3RhdGVtZW50cyhcIi9cIiArIG1vZHVsZU1ldGFfMS50eXBlLm5hbWUgKyBcIi9tb2R1bGUubmdmYWN0b3J5LmpzXCIsIGNvbXBpbGVSZXN1bHQuc3RhdGVtZW50cywgY29tcGlsZVJlc3VsdC5uZ01vZHVsZUZhY3RvcnlWYXIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRoaXMuX2NvbXBpbGVkTmdNb2R1bGVDYWNoZS5zZXQobW9kdWxlTWV0YV8xLnR5cGUucmVmZXJlbmNlLCBuZ01vZHVsZUZhY3RvcnkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmdNb2R1bGVGYWN0b3J5O1xuICAgICAgfTtcbiAgICAgIC8qKlxuICAgICAgICogQGludGVybmFsXG4gICAgICAgKi9cbiAgICAgIFJ1bnRpbWVDb21waWxlci5wcm90b3R5cGUuX2NvbXBpbGVDb21wb25lbnRzID0gZnVuY3Rpb24gKG1haW5Nb2R1bGUsIGlzU3luYykge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgdmFyIHRlbXBsYXRlcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgICB2YXIgbG9hZGluZ1Byb21pc2VzID0gW107XG4gICAgICAgICAgdmFyIG5nTW9kdWxlID0gdGhpcy5fbWV0YWRhdGFSZXNvbHZlci5nZXROZ01vZHVsZU1ldGFkYXRhKG1haW5Nb2R1bGUpO1xuICAgICAgICAgIHZhciBtb2R1bGVCeURpcmVjdGl2ZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgICBuZ01vZHVsZS50cmFuc2l0aXZlTW9kdWxlLm1vZHVsZXMuZm9yRWFjaChmdW5jdGlvbiAobG9jYWxNb2R1bGVNZXRhKSB7XG4gICAgICAgICAgICAgIGxvY2FsTW9kdWxlTWV0YS5kZWNsYXJlZERpcmVjdGl2ZXMuZm9yRWFjaChmdW5jdGlvbiAoZGlyTWV0YSkge1xuICAgICAgICAgICAgICAgICAgbW9kdWxlQnlEaXJlY3RpdmUuc2V0KGRpck1ldGEudHlwZS5yZWZlcmVuY2UsIGxvY2FsTW9kdWxlTWV0YSk7XG4gICAgICAgICAgICAgICAgICBfdGhpcy5fY29tcGlsZURpcmVjdGl2ZVdyYXBwZXIoZGlyTWV0YSwgbG9jYWxNb2R1bGVNZXRhKTtcbiAgICAgICAgICAgICAgICAgIGlmIChkaXJNZXRhLmlzQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGVzLmFkZChfdGhpcy5fY3JlYXRlQ29tcGlsZWRUZW1wbGF0ZShkaXJNZXRhLCBsb2NhbE1vZHVsZU1ldGEpKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgbmdNb2R1bGUudHJhbnNpdGl2ZU1vZHVsZS5tb2R1bGVzLmZvckVhY2goZnVuY3Rpb24gKGxvY2FsTW9kdWxlTWV0YSkge1xuICAgICAgICAgICAgICBsb2NhbE1vZHVsZU1ldGEuZGVjbGFyZWREaXJlY3RpdmVzLmZvckVhY2goZnVuY3Rpb24gKGRpck1ldGEpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChkaXJNZXRhLmlzQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgZGlyTWV0YS5lbnRyeUNvbXBvbmVudHMuZm9yRWFjaChmdW5jdGlvbiAoZW50cnlDb21wb25lbnRUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtb2R1bGVNZXRhID0gbW9kdWxlQnlEaXJlY3RpdmUuZ2V0KGVudHJ5Q29tcG9uZW50VHlwZS5yZWZlcmVuY2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZXMuYWRkKF90aGlzLl9jcmVhdGVDb21waWxlZEhvc3RUZW1wbGF0ZShlbnRyeUNvbXBvbmVudFR5cGUucmVmZXJlbmNlLCBtb2R1bGVNZXRhKSk7XG4gICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBsb2NhbE1vZHVsZU1ldGEuZW50cnlDb21wb25lbnRzLmZvckVhY2goZnVuY3Rpb24gKGVudHJ5Q29tcG9uZW50VHlwZSkge1xuICAgICAgICAgICAgICAgICAgdmFyIG1vZHVsZU1ldGEgPSBtb2R1bGVCeURpcmVjdGl2ZS5nZXQoZW50cnlDb21wb25lbnRUeXBlLnJlZmVyZW5jZSk7XG4gICAgICAgICAgICAgICAgICB0ZW1wbGF0ZXMuYWRkKF90aGlzLl9jcmVhdGVDb21waWxlZEhvc3RUZW1wbGF0ZShlbnRyeUNvbXBvbmVudFR5cGUucmVmZXJlbmNlLCBtb2R1bGVNZXRhKSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRlbXBsYXRlcy5mb3JFYWNoKGZ1bmN0aW9uICh0ZW1wbGF0ZSkge1xuICAgICAgICAgICAgICBpZiAodGVtcGxhdGUubG9hZGluZykge1xuICAgICAgICAgICAgICAgICAgaWYgKGlzU3luYykge1xuICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBDb21wb25lbnRTdGlsbExvYWRpbmdFcnJvcih0ZW1wbGF0ZS5jb21wVHlwZS5yZWZlcmVuY2UpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgbG9hZGluZ1Byb21pc2VzLnB1c2godGVtcGxhdGUubG9hZGluZyk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YXIgY29tcGlsZSA9IGZ1bmN0aW9uICgpIHsgdGVtcGxhdGVzLmZvckVhY2goZnVuY3Rpb24gKHRlbXBsYXRlKSB7IF90aGlzLl9jb21waWxlVGVtcGxhdGUodGVtcGxhdGUpOyB9KTsgfTtcbiAgICAgICAgICBpZiAoaXNTeW5jKSB7XG4gICAgICAgICAgICAgIGNvbXBpbGUoKTtcbiAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShudWxsKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChsb2FkaW5nUHJvbWlzZXMpLnRoZW4oY29tcGlsZSk7XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIFJ1bnRpbWVDb21waWxlci5wcm90b3R5cGUuY2xlYXJDYWNoZUZvciA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgICAgdGhpcy5fY29tcGlsZWROZ01vZHVsZUNhY2hlLmRlbGV0ZSh0eXBlKTtcbiAgICAgICAgICB0aGlzLl9tZXRhZGF0YVJlc29sdmVyLmNsZWFyQ2FjaGVGb3IodHlwZSk7XG4gICAgICAgICAgdGhpcy5fY29tcGlsZWRIb3N0VGVtcGxhdGVDYWNoZS5kZWxldGUodHlwZSk7XG4gICAgICAgICAgdmFyIGNvbXBpbGVkVGVtcGxhdGUgPSB0aGlzLl9jb21waWxlZFRlbXBsYXRlQ2FjaGUuZ2V0KHR5cGUpO1xuICAgICAgICAgIGlmIChjb21waWxlZFRlbXBsYXRlKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3RlbXBsYXRlTm9ybWFsaXplci5jbGVhckNhY2hlRm9yKGNvbXBpbGVkVGVtcGxhdGUubm9ybWFsaXplZENvbXBNZXRhKTtcbiAgICAgICAgICAgICAgdGhpcy5fY29tcGlsZWRUZW1wbGF0ZUNhY2hlLmRlbGV0ZSh0eXBlKTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgUnVudGltZUNvbXBpbGVyLnByb3RvdHlwZS5jbGVhckNhY2hlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoaXMuX21ldGFkYXRhUmVzb2x2ZXIuY2xlYXJDYWNoZSgpO1xuICAgICAgICAgIHRoaXMuX2NvbXBpbGVkVGVtcGxhdGVDYWNoZS5jbGVhcigpO1xuICAgICAgICAgIHRoaXMuX2NvbXBpbGVkSG9zdFRlbXBsYXRlQ2FjaGUuY2xlYXIoKTtcbiAgICAgICAgICB0aGlzLl90ZW1wbGF0ZU5vcm1hbGl6ZXIuY2xlYXJDYWNoZSgpO1xuICAgICAgICAgIHRoaXMuX2NvbXBpbGVkTmdNb2R1bGVDYWNoZS5jbGVhcigpO1xuICAgICAgfTtcbiAgICAgIFJ1bnRpbWVDb21waWxlci5wcm90b3R5cGUuX2NyZWF0ZUNvbXBpbGVkSG9zdFRlbXBsYXRlID0gZnVuY3Rpb24gKGNvbXBUeXBlLCBuZ01vZHVsZSkge1xuICAgICAgICAgIGlmICghbmdNb2R1bGUpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29tcG9uZW50IFwiICsgc3RyaW5naWZ5KGNvbXBUeXBlKSArIFwiIGlzIG5vdCBwYXJ0IG9mIGFueSBOZ01vZHVsZSBvciB0aGUgbW9kdWxlIGhhcyBub3QgYmVlbiBpbXBvcnRlZCBpbnRvIHlvdXIgbW9kdWxlLlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGNvbXBpbGVkVGVtcGxhdGUgPSB0aGlzLl9jb21waWxlZEhvc3RUZW1wbGF0ZUNhY2hlLmdldChjb21wVHlwZSk7XG4gICAgICAgICAgaWYgKCFjb21waWxlZFRlbXBsYXRlKSB7XG4gICAgICAgICAgICAgIHZhciBjb21wTWV0YSA9IHRoaXMuX21ldGFkYXRhUmVzb2x2ZXIuZ2V0RGlyZWN0aXZlTWV0YWRhdGEoY29tcFR5cGUpO1xuICAgICAgICAgICAgICBhc3NlcnRDb21wb25lbnQoY29tcE1ldGEpO1xuICAgICAgICAgICAgICB2YXIgaG9zdE1ldGEgPSBjcmVhdGVIb3N0Q29tcG9uZW50TWV0YShjb21wTWV0YSk7XG4gICAgICAgICAgICAgIGNvbXBpbGVkVGVtcGxhdGUgPSBuZXcgQ29tcGlsZWRUZW1wbGF0ZSh0cnVlLCBjb21wTWV0YS5zZWxlY3RvciwgY29tcE1ldGEudHlwZSwgbmdNb2R1bGUsIFtjb21wTWV0YV0sIHRoaXMuX3RlbXBsYXRlTm9ybWFsaXplci5ub3JtYWxpemVEaXJlY3RpdmUoaG9zdE1ldGEpKTtcbiAgICAgICAgICAgICAgdGhpcy5fY29tcGlsZWRIb3N0VGVtcGxhdGVDYWNoZS5zZXQoY29tcFR5cGUsIGNvbXBpbGVkVGVtcGxhdGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gY29tcGlsZWRUZW1wbGF0ZTtcbiAgICAgIH07XG4gICAgICBSdW50aW1lQ29tcGlsZXIucHJvdG90eXBlLl9jcmVhdGVDb21waWxlZFRlbXBsYXRlID0gZnVuY3Rpb24gKGNvbXBNZXRhLCBuZ01vZHVsZSkge1xuICAgICAgICAgIHZhciBjb21waWxlZFRlbXBsYXRlID0gdGhpcy5fY29tcGlsZWRUZW1wbGF0ZUNhY2hlLmdldChjb21wTWV0YS50eXBlLnJlZmVyZW5jZSk7XG4gICAgICAgICAgaWYgKCFjb21waWxlZFRlbXBsYXRlKSB7XG4gICAgICAgICAgICAgIGFzc2VydENvbXBvbmVudChjb21wTWV0YSk7XG4gICAgICAgICAgICAgIGNvbXBpbGVkVGVtcGxhdGUgPSBuZXcgQ29tcGlsZWRUZW1wbGF0ZShmYWxzZSwgY29tcE1ldGEuc2VsZWN0b3IsIGNvbXBNZXRhLnR5cGUsIG5nTW9kdWxlLCBuZ01vZHVsZS50cmFuc2l0aXZlTW9kdWxlLmRpcmVjdGl2ZXMsIHRoaXMuX3RlbXBsYXRlTm9ybWFsaXplci5ub3JtYWxpemVEaXJlY3RpdmUoY29tcE1ldGEpKTtcbiAgICAgICAgICAgICAgdGhpcy5fY29tcGlsZWRUZW1wbGF0ZUNhY2hlLnNldChjb21wTWV0YS50eXBlLnJlZmVyZW5jZSwgY29tcGlsZWRUZW1wbGF0ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBjb21waWxlZFRlbXBsYXRlO1xuICAgICAgfTtcbiAgICAgIFJ1bnRpbWVDb21waWxlci5wcm90b3R5cGUuX2Fzc2VydENvbXBvbmVudEtub3duID0gZnVuY3Rpb24gKGNvbXBUeXBlLCBpc0hvc3QpIHtcbiAgICAgICAgICB2YXIgY29tcGlsZWRUZW1wbGF0ZSA9IGlzSG9zdCA/IHRoaXMuX2NvbXBpbGVkSG9zdFRlbXBsYXRlQ2FjaGUuZ2V0KGNvbXBUeXBlKSA6XG4gICAgICAgICAgICAgIHRoaXMuX2NvbXBpbGVkVGVtcGxhdGVDYWNoZS5nZXQoY29tcFR5cGUpO1xuICAgICAgICAgIGlmICghY29tcGlsZWRUZW1wbGF0ZSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbGxlZ2FsIHN0YXRlOiBDb21waWxlZCB2aWV3IGZvciBjb21wb25lbnQgXCIgKyBzdHJpbmdpZnkoY29tcFR5cGUpICsgXCIgZG9lcyBub3QgZXhpc3QhXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gY29tcGlsZWRUZW1wbGF0ZTtcbiAgICAgIH07XG4gICAgICBSdW50aW1lQ29tcGlsZXIucHJvdG90eXBlLl9hc3NlcnRDb21wb25lbnRMb2FkZWQgPSBmdW5jdGlvbiAoY29tcFR5cGUsIGlzSG9zdCkge1xuICAgICAgICAgIHZhciBjb21waWxlZFRlbXBsYXRlID0gdGhpcy5fYXNzZXJ0Q29tcG9uZW50S25vd24oY29tcFR5cGUsIGlzSG9zdCk7XG4gICAgICAgICAgaWYgKGNvbXBpbGVkVGVtcGxhdGUubG9hZGluZykge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbGxlZ2FsIHN0YXRlOiBDb21waWxlZFRlbXBsYXRlIGZvciBcIiArIHN0cmluZ2lmeShjb21wVHlwZSkgKyBcIiAoaXNIb3N0OiBcIiArIGlzSG9zdCArIFwiKSBpcyBzdGlsbCBsb2FkaW5nIVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGNvbXBpbGVkVGVtcGxhdGU7XG4gICAgICB9O1xuICAgICAgUnVudGltZUNvbXBpbGVyLnByb3RvdHlwZS5fYXNzZXJ0RGlyZWN0aXZlV3JhcHBlciA9IGZ1bmN0aW9uIChkaXJUeXBlKSB7XG4gICAgICAgICAgdmFyIGRpcldyYXBwZXIgPSB0aGlzLl9jb21waWxlZERpcmVjdGl2ZVdyYXBwZXJDYWNoZS5nZXQoZGlyVHlwZSk7XG4gICAgICAgICAgaWYgKCFkaXJXcmFwcGVyKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIklsbGVnYWwgc3RhdGU6IERpcmVjdGl2ZSB3cmFwcGVyIGZvciBcIiArIHN0cmluZ2lmeShkaXJUeXBlKSArIFwiIGhhcyBub3QgYmVlbiBjb21waWxlZCFcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBkaXJXcmFwcGVyO1xuICAgICAgfTtcbiAgICAgIFJ1bnRpbWVDb21waWxlci5wcm90b3R5cGUuX2NvbXBpbGVEaXJlY3RpdmVXcmFwcGVyID0gZnVuY3Rpb24gKGRpck1ldGEsIG1vZHVsZU1ldGEpIHtcbiAgICAgICAgICB2YXIgY29tcGlsZVJlc3VsdCA9IHRoaXMuX2RpcmVjdGl2ZVdyYXBwZXJDb21waWxlci5jb21waWxlKGRpck1ldGEpO1xuICAgICAgICAgIHZhciBzdGF0ZW1lbnRzID0gY29tcGlsZVJlc3VsdC5zdGF0ZW1lbnRzO1xuICAgICAgICAgIHZhciBkaXJlY3RpdmVXcmFwcGVyQ2xhc3M7XG4gICAgICAgICAgaWYgKCF0aGlzLl9jb21waWxlckNvbmZpZy51c2VKaXQpIHtcbiAgICAgICAgICAgICAgZGlyZWN0aXZlV3JhcHBlckNsYXNzID0gaW50ZXJwcmV0U3RhdGVtZW50cyhzdGF0ZW1lbnRzLCBjb21waWxlUmVzdWx0LmRpcldyYXBwZXJDbGFzc1Zhcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBkaXJlY3RpdmVXcmFwcGVyQ2xhc3MgPSBqaXRTdGF0ZW1lbnRzKFwiL1wiICsgbW9kdWxlTWV0YS50eXBlLm5hbWUgKyBcIi9cIiArIGRpck1ldGEudHlwZS5uYW1lICsgXCIvd3JhcHBlci5uZ2ZhY3RvcnkuanNcIiwgc3RhdGVtZW50cywgY29tcGlsZVJlc3VsdC5kaXJXcmFwcGVyQ2xhc3NWYXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9jb21waWxlZERpcmVjdGl2ZVdyYXBwZXJDYWNoZS5zZXQoZGlyTWV0YS50eXBlLnJlZmVyZW5jZSwgZGlyZWN0aXZlV3JhcHBlckNsYXNzKTtcbiAgICAgIH07XG4gICAgICBSdW50aW1lQ29tcGlsZXIucHJvdG90eXBlLl9jb21waWxlVGVtcGxhdGUgPSBmdW5jdGlvbiAodGVtcGxhdGUpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIGlmICh0ZW1wbGF0ZS5pc0NvbXBpbGVkKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGNvbXBNZXRhID0gdGVtcGxhdGUubm9ybWFsaXplZENvbXBNZXRhO1xuICAgICAgICAgIHZhciBleHRlcm5hbFN0eWxlc2hlZXRzQnlNb2R1bGVVcmwgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgdmFyIHN0eWxlc0NvbXBpbGVSZXN1bHQgPSB0aGlzLl9zdHlsZUNvbXBpbGVyLmNvbXBpbGVDb21wb25lbnQoY29tcE1ldGEpO1xuICAgICAgICAgIHN0eWxlc0NvbXBpbGVSZXN1bHQuZXh0ZXJuYWxTdHlsZXNoZWV0cy5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IGV4dGVybmFsU3R5bGVzaGVldHNCeU1vZHVsZVVybC5zZXQoci5tZXRhLm1vZHVsZVVybCwgcik7IH0pO1xuICAgICAgICAgIHRoaXMuX3Jlc29sdmVTdHlsZXNDb21waWxlUmVzdWx0KHN0eWxlc0NvbXBpbGVSZXN1bHQuY29tcG9uZW50U3R5bGVzaGVldCwgZXh0ZXJuYWxTdHlsZXNoZWV0c0J5TW9kdWxlVXJsKTtcbiAgICAgICAgICB2YXIgdmlld0NvbXBNZXRhcyA9IHRlbXBsYXRlLnZpZXdDb21wb25lbnRUeXBlcy5tYXAoZnVuY3Rpb24gKGNvbXBUeXBlKSB7IHJldHVybiBfdGhpcy5fYXNzZXJ0Q29tcG9uZW50TG9hZGVkKGNvbXBUeXBlLCBmYWxzZSkubm9ybWFsaXplZENvbXBNZXRhOyB9KTtcbiAgICAgICAgICB2YXIgcGFyc2VkQW5pbWF0aW9ucyA9IHRoaXMuX2FuaW1hdGlvblBhcnNlci5wYXJzZUNvbXBvbmVudChjb21wTWV0YSk7XG4gICAgICAgICAgdmFyIHBhcnNlZFRlbXBsYXRlID0gdGhpcy5fdGVtcGxhdGVQYXJzZXIucGFyc2UoY29tcE1ldGEsIGNvbXBNZXRhLnRlbXBsYXRlLnRlbXBsYXRlLCB0ZW1wbGF0ZS52aWV3RGlyZWN0aXZlcy5jb25jYXQodmlld0NvbXBNZXRhcyksIHRlbXBsYXRlLnZpZXdQaXBlcywgdGVtcGxhdGUuc2NoZW1hcywgY29tcE1ldGEudHlwZS5uYW1lKTtcbiAgICAgICAgICB2YXIgY29tcGlsZWRBbmltYXRpb25zID0gdGhpcy5fYW5pbWF0aW9uQ29tcGlsZXIuY29tcGlsZShjb21wTWV0YS50eXBlLm5hbWUsIHBhcnNlZEFuaW1hdGlvbnMpO1xuICAgICAgICAgIHZhciBjb21waWxlUmVzdWx0ID0gdGhpcy5fdmlld0NvbXBpbGVyLmNvbXBpbGVDb21wb25lbnQoY29tcE1ldGEsIHBhcnNlZFRlbXBsYXRlLCB2YXJpYWJsZShzdHlsZXNDb21waWxlUmVzdWx0LmNvbXBvbmVudFN0eWxlc2hlZXQuc3R5bGVzVmFyKSwgdGVtcGxhdGUudmlld1BpcGVzLCBjb21waWxlZEFuaW1hdGlvbnMpO1xuICAgICAgICAgIGNvbXBpbGVSZXN1bHQuZGVwZW5kZW5jaWVzLmZvckVhY2goZnVuY3Rpb24gKGRlcCkge1xuICAgICAgICAgICAgICB2YXIgZGVwVGVtcGxhdGU7XG4gICAgICAgICAgICAgIGlmIChkZXAgaW5zdGFuY2VvZiBWaWV3RmFjdG9yeURlcGVuZGVuY3kpIHtcbiAgICAgICAgICAgICAgICAgIHZhciB2ZmQgPSBkZXA7XG4gICAgICAgICAgICAgICAgICBkZXBUZW1wbGF0ZSA9IF90aGlzLl9hc3NlcnRDb21wb25lbnRMb2FkZWQodmZkLmNvbXAucmVmZXJlbmNlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICB2ZmQucGxhY2Vob2xkZXIucmVmZXJlbmNlID0gZGVwVGVtcGxhdGUucHJveHlWaWV3RmFjdG9yeTtcbiAgICAgICAgICAgICAgICAgIHZmZC5wbGFjZWhvbGRlci5uYW1lID0gXCJ2aWV3RmFjdG9yeV9cIiArIHZmZC5jb21wLm5hbWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSBpZiAoZGVwIGluc3RhbmNlb2YgQ29tcG9uZW50RmFjdG9yeURlcGVuZGVuY3kpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBjZmQgPSBkZXA7XG4gICAgICAgICAgICAgICAgICBkZXBUZW1wbGF0ZSA9IF90aGlzLl9hc3NlcnRDb21wb25lbnRMb2FkZWQoY2ZkLmNvbXAucmVmZXJlbmNlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgIGNmZC5wbGFjZWhvbGRlci5yZWZlcmVuY2UgPSBkZXBUZW1wbGF0ZS5wcm94eUNvbXBvbmVudEZhY3Rvcnk7XG4gICAgICAgICAgICAgICAgICBjZmQucGxhY2Vob2xkZXIubmFtZSA9IFwiY29tcEZhY3RvcnlfXCIgKyBjZmQuY29tcC5uYW1lO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgaWYgKGRlcCBpbnN0YW5jZW9mIERpcmVjdGl2ZVdyYXBwZXJEZXBlbmRlbmN5KSB7XG4gICAgICAgICAgICAgICAgICB2YXIgZHdkID0gZGVwO1xuICAgICAgICAgICAgICAgICAgZHdkLnBsYWNlaG9sZGVyLnJlZmVyZW5jZSA9IF90aGlzLl9hc3NlcnREaXJlY3RpdmVXcmFwcGVyKGR3ZC5kaXIucmVmZXJlbmNlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHZhciBzdGF0ZW1lbnRzID0gc3R5bGVzQ29tcGlsZVJlc3VsdC5jb21wb25lbnRTdHlsZXNoZWV0LnN0YXRlbWVudHMuY29uY2F0KGNvbXBpbGVSZXN1bHQuc3RhdGVtZW50cyk7XG4gICAgICAgICAgY29tcGlsZWRBbmltYXRpb25zLmZvckVhY2goZnVuY3Rpb24gKGVudHJ5KSB7IGVudHJ5LnN0YXRlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoc3RhdGVtZW50KSB7IHN0YXRlbWVudHMucHVzaChzdGF0ZW1lbnQpOyB9KTsgfSk7XG4gICAgICAgICAgdmFyIGZhY3Rvcnk7XG4gICAgICAgICAgaWYgKCF0aGlzLl9jb21waWxlckNvbmZpZy51c2VKaXQpIHtcbiAgICAgICAgICAgICAgZmFjdG9yeSA9IGludGVycHJldFN0YXRlbWVudHMoc3RhdGVtZW50cywgY29tcGlsZVJlc3VsdC52aWV3RmFjdG9yeVZhcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBmYWN0b3J5ID0gaml0U3RhdGVtZW50cyhcIi9cIiArIHRlbXBsYXRlLm5nTW9kdWxlLnR5cGUubmFtZSArIFwiL1wiICsgdGVtcGxhdGUuY29tcFR5cGUubmFtZSArIFwiL1wiICsgKHRlbXBsYXRlLmlzSG9zdCA/ICdob3N0JyA6ICdjb21wb25lbnQnKSArIFwiLm5nZmFjdG9yeS5qc1wiLCBzdGF0ZW1lbnRzLCBjb21waWxlUmVzdWx0LnZpZXdGYWN0b3J5VmFyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGVtcGxhdGUuY29tcGlsZWQoZmFjdG9yeSk7XG4gICAgICB9O1xuICAgICAgUnVudGltZUNvbXBpbGVyLnByb3RvdHlwZS5fcmVzb2x2ZVN0eWxlc0NvbXBpbGVSZXN1bHQgPSBmdW5jdGlvbiAocmVzdWx0LCBleHRlcm5hbFN0eWxlc2hlZXRzQnlNb2R1bGVVcmwpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHJlc3VsdC5kZXBlbmRlbmNpZXMuZm9yRWFjaChmdW5jdGlvbiAoZGVwLCBpKSB7XG4gICAgICAgICAgICAgIHZhciBuZXN0ZWRDb21waWxlUmVzdWx0ID0gZXh0ZXJuYWxTdHlsZXNoZWV0c0J5TW9kdWxlVXJsLmdldChkZXAubW9kdWxlVXJsKTtcbiAgICAgICAgICAgICAgdmFyIG5lc3RlZFN0eWxlc0FyciA9IF90aGlzLl9yZXNvbHZlQW5kRXZhbFN0eWxlc0NvbXBpbGVSZXN1bHQobmVzdGVkQ29tcGlsZVJlc3VsdCwgZXh0ZXJuYWxTdHlsZXNoZWV0c0J5TW9kdWxlVXJsKTtcbiAgICAgICAgICAgICAgZGVwLnZhbHVlUGxhY2Vob2xkZXIucmVmZXJlbmNlID0gbmVzdGVkU3R5bGVzQXJyO1xuICAgICAgICAgICAgICBkZXAudmFsdWVQbGFjZWhvbGRlci5uYW1lID0gXCJpbXBvcnRlZFN0eWxlc1wiICsgaTtcbiAgICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBSdW50aW1lQ29tcGlsZXIucHJvdG90eXBlLl9yZXNvbHZlQW5kRXZhbFN0eWxlc0NvbXBpbGVSZXN1bHQgPSBmdW5jdGlvbiAocmVzdWx0LCBleHRlcm5hbFN0eWxlc2hlZXRzQnlNb2R1bGVVcmwpIHtcbiAgICAgICAgICB0aGlzLl9yZXNvbHZlU3R5bGVzQ29tcGlsZVJlc3VsdChyZXN1bHQsIGV4dGVybmFsU3R5bGVzaGVldHNCeU1vZHVsZVVybCk7XG4gICAgICAgICAgaWYgKCF0aGlzLl9jb21waWxlckNvbmZpZy51c2VKaXQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGludGVycHJldFN0YXRlbWVudHMocmVzdWx0LnN0YXRlbWVudHMsIHJlc3VsdC5zdHlsZXNWYXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGppdFN0YXRlbWVudHMoXCIvXCIgKyByZXN1bHQubWV0YS5tb2R1bGVVcmwgKyBcIi5jc3MuanNcIiwgcmVzdWx0LnN0YXRlbWVudHMsIHJlc3VsdC5zdHlsZXNWYXIpO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICBSdW50aW1lQ29tcGlsZXIuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0YWJsZSB9LFxuICAgICAgXTtcbiAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgUnVudGltZUNvbXBpbGVyLmN0b3JQYXJhbWV0ZXJzID0gW1xuICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3RvciwgfSxcbiAgICAgICAgICB7IHR5cGU6IENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLCB9LFxuICAgICAgICAgIHsgdHlwZTogRGlyZWN0aXZlTm9ybWFsaXplciwgfSxcbiAgICAgICAgICB7IHR5cGU6IFRlbXBsYXRlUGFyc2VyLCB9LFxuICAgICAgICAgIHsgdHlwZTogU3R5bGVDb21waWxlciwgfSxcbiAgICAgICAgICB7IHR5cGU6IFZpZXdDb21waWxlciwgfSxcbiAgICAgICAgICB7IHR5cGU6IE5nTW9kdWxlQ29tcGlsZXIsIH0sXG4gICAgICAgICAgeyB0eXBlOiBEaXJlY3RpdmVXcmFwcGVyQ29tcGlsZXIsIH0sXG4gICAgICAgICAgeyB0eXBlOiBDb21waWxlckNvbmZpZywgfSxcbiAgICAgIF07XG4gICAgICByZXR1cm4gUnVudGltZUNvbXBpbGVyO1xuICB9KCkpO1xuICB2YXIgQ29tcGlsZWRUZW1wbGF0ZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBDb21waWxlZFRlbXBsYXRlKGlzSG9zdCwgc2VsZWN0b3IsIGNvbXBUeXBlLCBuZ01vZHVsZSwgdmlld0RpcmVjdGl2ZUFuZENvbXBvbmVudHMsIF9ub3JtYWxpemVSZXN1bHQpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHRoaXMuaXNIb3N0ID0gaXNIb3N0O1xuICAgICAgICAgIHRoaXMuY29tcFR5cGUgPSBjb21wVHlwZTtcbiAgICAgICAgICB0aGlzLm5nTW9kdWxlID0gbmdNb2R1bGU7XG4gICAgICAgICAgdGhpcy5fdmlld0ZhY3RvcnkgPSBudWxsO1xuICAgICAgICAgIHRoaXMubG9hZGluZyA9IG51bGw7XG4gICAgICAgICAgdGhpcy5fbm9ybWFsaXplZENvbXBNZXRhID0gbnVsbDtcbiAgICAgICAgICB0aGlzLmlzQ29tcGlsZWQgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLmlzQ29tcGlsZWRXaXRoRGVwcyA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMudmlld0NvbXBvbmVudFR5cGVzID0gW107XG4gICAgICAgICAgdGhpcy52aWV3RGlyZWN0aXZlcyA9IFtdO1xuICAgICAgICAgIHRoaXMudmlld1BpcGVzID0gbmdNb2R1bGUudHJhbnNpdGl2ZU1vZHVsZS5waXBlcztcbiAgICAgICAgICB0aGlzLnNjaGVtYXMgPSBuZ01vZHVsZS5zY2hlbWFzO1xuICAgICAgICAgIHZpZXdEaXJlY3RpdmVBbmRDb21wb25lbnRzLmZvckVhY2goZnVuY3Rpb24gKGRpck1ldGEpIHtcbiAgICAgICAgICAgICAgaWYgKGRpck1ldGEuaXNDb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICAgIF90aGlzLnZpZXdDb21wb25lbnRUeXBlcy5wdXNoKGRpck1ldGEudHlwZS5yZWZlcmVuY2UpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgX3RoaXMudmlld0RpcmVjdGl2ZXMucHVzaChkaXJNZXRhKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRoaXMucHJveHlWaWV3RmFjdG9yeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgIGFyZ3NbX2kgLSAwXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCFfdGhpcy5fdmlld0ZhY3RvcnkpIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIklsbGVnYWwgc3RhdGU6IENvbXBpbGVkVGVtcGxhdGUgZm9yIFwiICsgc3RyaW5naWZ5KF90aGlzLmNvbXBUeXBlKSArIFwiIGlzIG5vdCBjb21waWxlZCB5ZXQhXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fdmlld0ZhY3RvcnkuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICB0aGlzLnByb3h5Q29tcG9uZW50RmFjdG9yeSA9IGlzSG9zdCA/XG4gICAgICAgICAgICAgIG5ldyBfYW5ndWxhcl9jb3JlLkNvbXBvbmVudEZhY3Rvcnkoc2VsZWN0b3IsIHRoaXMucHJveHlWaWV3RmFjdG9yeSwgY29tcFR5cGUucmVmZXJlbmNlKSA6XG4gICAgICAgICAgICAgIG51bGw7XG4gICAgICAgICAgaWYgKF9ub3JtYWxpemVSZXN1bHQuc3luY1Jlc3VsdCkge1xuICAgICAgICAgICAgICB0aGlzLl9ub3JtYWxpemVkQ29tcE1ldGEgPSBfbm9ybWFsaXplUmVzdWx0LnN5bmNSZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLmxvYWRpbmcgPSBfbm9ybWFsaXplUmVzdWx0LmFzeW5jUmVzdWx0LnRoZW4oZnVuY3Rpb24gKG5vcm1hbGl6ZWRDb21wTWV0YSkge1xuICAgICAgICAgICAgICAgICAgX3RoaXMuX25vcm1hbGl6ZWRDb21wTWV0YSA9IG5vcm1hbGl6ZWRDb21wTWV0YTtcbiAgICAgICAgICAgICAgICAgIF90aGlzLmxvYWRpbmcgPSBudWxsO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tcGlsZWRUZW1wbGF0ZS5wcm90b3R5cGUsIFwibm9ybWFsaXplZENvbXBNZXRhXCIsIHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMubG9hZGluZykge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGVtcGxhdGUgaXMgc3RpbGwgbG9hZGluZyBmb3IgXCIgKyB0aGlzLmNvbXBUeXBlLm5hbWUgKyBcIiFcIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25vcm1hbGl6ZWRDb21wTWV0YTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIENvbXBpbGVkVGVtcGxhdGUucHJvdG90eXBlLmNvbXBpbGVkID0gZnVuY3Rpb24gKHZpZXdGYWN0b3J5KSB7XG4gICAgICAgICAgdGhpcy5fdmlld0ZhY3RvcnkgPSB2aWV3RmFjdG9yeTtcbiAgICAgICAgICB0aGlzLmlzQ29tcGlsZWQgPSB0cnVlO1xuICAgICAgfTtcbiAgICAgIENvbXBpbGVkVGVtcGxhdGUucHJvdG90eXBlLmRlcHNDb21waWxlZCA9IGZ1bmN0aW9uICgpIHsgdGhpcy5pc0NvbXBpbGVkV2l0aERlcHMgPSB0cnVlOyB9O1xuICAgICAgcmV0dXJuIENvbXBpbGVkVGVtcGxhdGU7XG4gIH0oKSk7XG4gIGZ1bmN0aW9uIGFzc2VydENvbXBvbmVudChtZXRhKSB7XG4gICAgICBpZiAoIW1ldGEuaXNDb21wb25lbnQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgY29tcGlsZSAnXCIgKyBtZXRhLnR5cGUubmFtZSArIFwiJyBiZWNhdXNlIGl0IGlzIG5vdCBhIGNvbXBvbmVudC5cIik7XG4gICAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEltcGxlbWVudHMgYENvbXBpbGVyYCBieSBkZWxlZ2F0aW5nIHRvIHRoZSBSdW50aW1lQ29tcGlsZXIgdXNpbmcgYSBrbm93biBtb2R1bGUuXG4gICAqL1xuICB2YXIgTW9kdWxlQm91bmRDb21waWxlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBNb2R1bGVCb3VuZENvbXBpbGVyKF9kZWxlZ2F0ZSwgX25nTW9kdWxlKSB7XG4gICAgICAgICAgdGhpcy5fZGVsZWdhdGUgPSBfZGVsZWdhdGU7XG4gICAgICAgICAgdGhpcy5fbmdNb2R1bGUgPSBfbmdNb2R1bGU7XG4gICAgICB9XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlQm91bmRDb21waWxlci5wcm90b3R5cGUsIFwiX2luamVjdG9yXCIsIHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2RlbGVnYXRlLmluamVjdG9yOyB9LFxuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIE1vZHVsZUJvdW5kQ29tcGlsZXIucHJvdG90eXBlLmNvbXBpbGVNb2R1bGVTeW5jID0gZnVuY3Rpb24gKG1vZHVsZVR5cGUpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fZGVsZWdhdGUuY29tcGlsZU1vZHVsZVN5bmMobW9kdWxlVHlwZSk7XG4gICAgICB9O1xuICAgICAgTW9kdWxlQm91bmRDb21waWxlci5wcm90b3R5cGUuY29tcGlsZU1vZHVsZUFzeW5jID0gZnVuY3Rpb24gKG1vZHVsZVR5cGUpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fZGVsZWdhdGUuY29tcGlsZU1vZHVsZUFzeW5jKG1vZHVsZVR5cGUpO1xuICAgICAgfTtcbiAgICAgIE1vZHVsZUJvdW5kQ29tcGlsZXIucHJvdG90eXBlLmNvbXBpbGVNb2R1bGVBbmRBbGxDb21wb25lbnRzU3luYyA9IGZ1bmN0aW9uIChtb2R1bGVUeXBlKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2RlbGVnYXRlLmNvbXBpbGVNb2R1bGVBbmRBbGxDb21wb25lbnRzU3luYyhtb2R1bGVUeXBlKTtcbiAgICAgIH07XG4gICAgICBNb2R1bGVCb3VuZENvbXBpbGVyLnByb3RvdHlwZS5jb21waWxlTW9kdWxlQW5kQWxsQ29tcG9uZW50c0FzeW5jID0gZnVuY3Rpb24gKG1vZHVsZVR5cGUpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fZGVsZWdhdGUuY29tcGlsZU1vZHVsZUFuZEFsbENvbXBvbmVudHNBc3luYyhtb2R1bGVUeXBlKTtcbiAgICAgIH07XG4gICAgICAvKipcbiAgICAgICAqIENsZWFycyBhbGwgY2FjaGVzXG4gICAgICAgKi9cbiAgICAgIE1vZHVsZUJvdW5kQ29tcGlsZXIucHJvdG90eXBlLmNsZWFyQ2FjaGUgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX2RlbGVnYXRlLmNsZWFyQ2FjaGUoKTsgfTtcbiAgICAgIC8qKlxuICAgICAgICogQ2xlYXJzIHRoZSBjYWNoZSBmb3IgdGhlIGdpdmVuIGNvbXBvbmVudC9uZ01vZHVsZS5cbiAgICAgICAqL1xuICAgICAgTW9kdWxlQm91bmRDb21waWxlci5wcm90b3R5cGUuY2xlYXJDYWNoZUZvciA9IGZ1bmN0aW9uICh0eXBlKSB7IHRoaXMuX2RlbGVnYXRlLmNsZWFyQ2FjaGVGb3IodHlwZSk7IH07XG4gICAgICByZXR1cm4gTW9kdWxlQm91bmRDb21waWxlcjtcbiAgfSgpKTtcblxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gPT09PT09PT09PT0gUyBUIE8gUCAgIC0gIFMgVCBPIFAgICAtICBTIFQgTyBQICAgLSAgUyBUIE8gUCAgIC0gIFMgVCBPIFAgICAtICBTIFQgTyBQICA9PT09PT09PT09PVxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy9cbiAgLy8gICAgICAgIERPIE5PVCBFRElUIFRISVMgTElTVCBPRiBTRUNVUklUWSBTRU5TSVRJVkUgUFJPUEVSVElFUyBXSVRIT1VUIEEgU0VDVVJJVFkgUkVWSUVXIVxuICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZWFjaCBvdXQgdG8gbXByb2JzdCBmb3IgZGV0YWlscy5cbiAgLy9cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvKiogTWFwIGZyb20gdGFnTmFtZXxwcm9wZXJ0eU5hbWUgU2VjdXJpdHlDb250ZXh0LiBQcm9wZXJ0aWVzIGFwcGx5aW5nIHRvIGFsbCB0YWdzIHVzZSAnKicuICovXG4gIHZhciBTRUNVUklUWV9TQ0hFTUEgPSB7fTtcbiAgZnVuY3Rpb24gcmVnaXN0ZXJDb250ZXh0KGN0eCwgc3BlY3MpIHtcbiAgICAgIGZvciAodmFyIF9pID0gMCwgc3BlY3NfMSA9IHNwZWNzOyBfaSA8IHNwZWNzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgdmFyIHNwZWMgPSBzcGVjc18xW19pXTtcbiAgICAgICAgICBTRUNVUklUWV9TQ0hFTUFbc3BlYy50b0xvd2VyQ2FzZSgpXSA9IGN0eDtcbiAgICAgIH1cbiAgfVxuICAvLyBDYXNlIGlzIGluc2lnbmlmaWNhbnQgYmVsb3csIGFsbCBlbGVtZW50IGFuZCBhdHRyaWJ1dGUgbmFtZXMgYXJlIGxvd2VyLWNhc2VkIGZvciBsb29rdXAuXG4gIHJlZ2lzdGVyQ29udGV4dChfYW5ndWxhcl9jb3JlLlNlY3VyaXR5Q29udGV4dC5IVE1MLCBbXG4gICAgICAnaWZyYW1lfHNyY2RvYycsXG4gICAgICAnKnxpbm5lckhUTUwnLFxuICAgICAgJyp8b3V0ZXJIVE1MJyxcbiAgXSk7XG4gIHJlZ2lzdGVyQ29udGV4dChfYW5ndWxhcl9jb3JlLlNlY3VyaXR5Q29udGV4dC5TVFlMRSwgWycqfHN0eWxlJ10pO1xuICAvLyBOQjogbm8gU0NSSVBUIGNvbnRleHRzIGhlcmUsIHRoZXkgYXJlIG5ldmVyIGFsbG93ZWQgZHVlIHRvIHRoZSBwYXJzZXIgc3RyaXBwaW5nIHRoZW0uXG4gIHJlZ2lzdGVyQ29udGV4dChfYW5ndWxhcl9jb3JlLlNlY3VyaXR5Q29udGV4dC5VUkwsIFtcbiAgICAgICcqfGZvcm1BY3Rpb24nLCAnYXJlYXxocmVmJywgJ2FyZWF8cGluZycsICdhdWRpb3xzcmMnLCAnYXxocmVmJyxcbiAgICAgICdhfHBpbmcnLCAnYmxvY2txdW90ZXxjaXRlJywgJ2JvZHl8YmFja2dyb3VuZCcsICdkZWx8Y2l0ZScsICdmb3JtfGFjdGlvbicsXG4gICAgICAnaW1nfHNyYycsICdpbWd8c3Jjc2V0JywgJ2lucHV0fHNyYycsICdpbnN8Y2l0ZScsICdxfGNpdGUnLFxuICAgICAgJ3NvdXJjZXxzcmMnLCAnc291cmNlfHNyY3NldCcsICd0cmFja3xzcmMnLCAndmlkZW98cG9zdGVyJywgJ3ZpZGVvfHNyYycsXG4gIF0pO1xuICByZWdpc3RlckNvbnRleHQoX2FuZ3VsYXJfY29yZS5TZWN1cml0eUNvbnRleHQuUkVTT1VSQ0VfVVJMLCBbXG4gICAgICAnYXBwbGV0fGNvZGUnLFxuICAgICAgJ2FwcGxldHxjb2RlYmFzZScsXG4gICAgICAnYmFzZXxocmVmJyxcbiAgICAgICdlbWJlZHxzcmMnLFxuICAgICAgJ2ZyYW1lfHNyYycsXG4gICAgICAnaGVhZHxwcm9maWxlJyxcbiAgICAgICdodG1sfG1hbmlmZXN0JyxcbiAgICAgICdpZnJhbWV8c3JjJyxcbiAgICAgICdsaW5rfGhyZWYnLFxuICAgICAgJ21lZGlhfHNyYycsXG4gICAgICAnb2JqZWN0fGNvZGViYXNlJyxcbiAgICAgICdvYmplY3R8ZGF0YScsXG4gICAgICAnc2NyaXB0fHNyYycsXG4gIF0pO1xuXG4gIC8qKlxuICAgKiBAbGljZW5zZVxuICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICpcbiAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgKi9cbiAgdmFyIF9fZXh0ZW5kcyQyMSA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgfTtcbiAgdmFyIEJPT0xFQU4gPSAnYm9vbGVhbic7XG4gIHZhciBOVU1CRVIgPSAnbnVtYmVyJztcbiAgdmFyIFNUUklORyA9ICdzdHJpbmcnO1xuICB2YXIgT0JKRUNUID0gJ29iamVjdCc7XG4gIC8qKlxuICAgKiBUaGlzIGFycmF5IHJlcHJlc2VudHMgdGhlIERPTSBzY2hlbWEuIEl0IGVuY29kZXMgaW5oZXJpdGFuY2UsIHByb3BlcnRpZXMsIGFuZCBldmVudHMuXG4gICAqXG4gICAqICMjIE92ZXJ2aWV3XG4gICAqXG4gICAqIEVhY2ggbGluZSByZXByZXNlbnRzIG9uZSBraW5kIG9mIGVsZW1lbnQuIFRoZSBgZWxlbWVudF9pbmhlcml0YW5jZWAgYW5kIHByb3BlcnRpZXMgYXJlIGpvaW5lZFxuICAgKiB1c2luZyBgZWxlbWVudF9pbmhlcml0YW5jZXxwcm9wZXJ0aWVzYCBzeW50YXguXG4gICAqXG4gICAqICMjIEVsZW1lbnQgSW5oZXJpdGFuY2VcbiAgICpcbiAgICogVGhlIGBlbGVtZW50X2luaGVyaXRhbmNlYCBjYW4gYmUgZnVydGhlciBzdWJkaXZpZGVkIGFzIGBlbGVtZW50MSxlbGVtZW50MiwuLi5ecGFyZW50RWxlbWVudGAuXG4gICAqIEhlcmUgdGhlIGluZGl2aWR1YWwgZWxlbWVudHMgYXJlIHNlcGFyYXRlZCBieSBgLGAgKGNvbW1hcykuIEV2ZXJ5IGVsZW1lbnQgaW4gdGhlIGxpc3RcbiAgICogaGFzIGlkZW50aWNhbCBwcm9wZXJ0aWVzLlxuICAgKlxuICAgKiBBbiBgZWxlbWVudGAgbWF5IGluaGVyaXQgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIGZyb20gYHBhcmVudEVsZW1lbnRgIElmIG5vIGBecGFyZW50RWxlbWVudGAgaXNcbiAgICogc3BlY2lmaWVkIHRoZW4gYFwiXCJgIChibGFuaykgZWxlbWVudCBpcyBhc3N1bWVkLlxuICAgKlxuICAgKiBOT1RFOiBUaGUgYmxhbmsgZWxlbWVudCBpbmhlcml0cyBmcm9tIHJvb3QgYFtFbGVtZW50XWAgZWxlbWVudCwgdGhlIHN1cGVyIGVsZW1lbnQgb2YgYWxsXG4gICAqIGVsZW1lbnRzLlxuICAgKlxuICAgKiBOT1RFIGFuIGVsZW1lbnQgcHJlZml4IHN1Y2ggYXMgYDpzdmc6YCBoYXMgbm8gc3BlY2lhbCBtZWFuaW5nIHRvIHRoZSBzY2hlbWEuXG4gICAqXG4gICAqICMjIFByb3BlcnRpZXNcbiAgICpcbiAgICogRWFjaCBlbGVtZW50IGhhcyBhIHNldCBvZiBwcm9wZXJ0aWVzIHNlcGFyYXRlZCBieSBgLGAgKGNvbW1hcykuIEVhY2ggcHJvcGVydHkgY2FuIGJlIHByZWZpeGVkXG4gICAqIGJ5IGEgc3BlY2lhbCBjaGFyYWN0ZXIgZGVzaWduYXRpbmcgaXRzIHR5cGU6XG4gICAqXG4gICAqIC0gKG5vIHByZWZpeCk6IHByb3BlcnR5IGlzIGEgc3RyaW5nLlxuICAgKiAtIGAqYDogcHJvcGVydHkgcmVwcmVzZW50cyBhbiBldmVudC5cbiAgICogLSBgIWA6IHByb3BlcnR5IGlzIGEgYm9vbGVhbi5cbiAgICogLSBgI2A6IHByb3BlcnR5IGlzIGEgbnVtYmVyLlxuICAgKiAtIGAlYDogcHJvcGVydHkgaXMgYW4gb2JqZWN0LlxuICAgKlxuICAgKiAjIyBRdWVyeVxuICAgKlxuICAgKiBUaGUgY2xhc3MgY3JlYXRlcyBhbiBpbnRlcm5hbCBzcXVhcyByZXByZXNlbnRhdGlvbiB3aGljaCBhbGxvd3MgdG8gZWFzaWx5IGFuc3dlciB0aGUgcXVlcnkgb2ZcbiAgICogaWYgYSBnaXZlbiBwcm9wZXJ0eSBleGlzdCBvbiBhIGdpdmVuIGVsZW1lbnQuXG4gICAqXG4gICAqIE5PVEU6IFdlIGRvbid0IHlldCBzdXBwb3J0IHF1ZXJ5aW5nIGZvciB0eXBlcyBvciBldmVudHMuXG4gICAqIE5PVEU6IFRoaXMgc2NoZW1hIGlzIGF1dG8gZXh0cmFjdGVkIGZyb20gYHNjaGVtYV9leHRyYWN0b3IudHNgIGxvY2F0ZWQgaW4gdGhlIHRlc3QgZm9sZGVyLFxuICAgKiAgICAgICBzZWUgZG9tX2VsZW1lbnRfc2NoZW1hX3JlZ2lzdHJ5X3NwZWMudHNcbiAgICovXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyA9PT09PT09PT09PSBTIFQgTyBQICAgLSAgUyBUIE8gUCAgIC0gIFMgVCBPIFAgICAtICBTIFQgTyBQICAgLSAgUyBUIE8gUCAgIC0gIFMgVCBPIFAgID09PT09PT09PT09XG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvL1xuICAvLyAgICAgICAgICAgICAgICAgICAgICAgRE8gTk9UIEVESVQgVEhJUyBET00gU0NIRU1BIFdJVEhPVVQgQSBTRUNVUklUWSBSRVZJRVchXG4gIC8vXG4gIC8vIE5ld2x5IGFkZGVkIHByb3BlcnRpZXMgbXVzdCBiZSBzZWN1cml0eSByZXZpZXdlZCBhbmQgYXNzaWduZWQgYW4gYXBwcm9wcmlhdGUgU2VjdXJpdHlDb250ZXh0IGluXG4gIC8vIGRvbV9zZWN1cml0eV9zY2hlbWEudHMuIFJlYWNoIG91dCB0byBtcHJvYnN0ICYgcmphbWV0IGZvciBkZXRhaWxzLlxuICAvL1xuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIHZhciBTQ0hFTUEgPSBbXG4gICAgICAnW0VsZW1lbnRdfHRleHRDb250ZW50LCVjbGFzc0xpc3QsY2xhc3NOYW1lLGlkLGlubmVySFRNTCwqYmVmb3JlY29weSwqYmVmb3JlY3V0LCpiZWZvcmVwYXN0ZSwqY29weSwqY3V0LCpwYXN0ZSwqc2VhcmNoLCpzZWxlY3RzdGFydCwqd2Via2l0ZnVsbHNjcmVlbmNoYW5nZSwqd2Via2l0ZnVsbHNjcmVlbmVycm9yLCp3aGVlbCxvdXRlckhUTUwsI3Njcm9sbExlZnQsI3Njcm9sbFRvcCcsXG4gICAgICAnW0hUTUxFbGVtZW50XV5bRWxlbWVudF18YWNjZXNzS2V5LGNvbnRlbnRFZGl0YWJsZSxkaXIsIWRyYWdnYWJsZSwhaGlkZGVuLGlubmVyVGV4dCxsYW5nLCphYm9ydCwqYmVmb3JlY29weSwqYmVmb3JlY3V0LCpiZWZvcmVwYXN0ZSwqYmx1ciwqY2FuY2VsLCpjYW5wbGF5LCpjYW5wbGF5dGhyb3VnaCwqY2hhbmdlLCpjbGljaywqY2xvc2UsKmNvbnRleHRtZW51LCpjb3B5LCpjdWVjaGFuZ2UsKmN1dCwqZGJsY2xpY2ssKmRyYWcsKmRyYWdlbmQsKmRyYWdlbnRlciwqZHJhZ2xlYXZlLCpkcmFnb3ZlciwqZHJhZ3N0YXJ0LCpkcm9wLCpkdXJhdGlvbmNoYW5nZSwqZW1wdGllZCwqZW5kZWQsKmVycm9yLCpmb2N1cywqaW5wdXQsKmludmFsaWQsKmtleWRvd24sKmtleXByZXNzLCprZXl1cCwqbG9hZCwqbG9hZGVkZGF0YSwqbG9hZGVkbWV0YWRhdGEsKmxvYWRzdGFydCwqbWVzc2FnZSwqbW91c2Vkb3duLCptb3VzZWVudGVyLCptb3VzZWxlYXZlLCptb3VzZW1vdmUsKm1vdXNlb3V0LCptb3VzZW92ZXIsKm1vdXNldXAsKm1vdXNld2hlZWwsKm1vemZ1bGxzY3JlZW5jaGFuZ2UsKm1vemZ1bGxzY3JlZW5lcnJvciwqbW96cG9pbnRlcmxvY2tjaGFuZ2UsKm1venBvaW50ZXJsb2NrZXJyb3IsKnBhc3RlLCpwYXVzZSwqcGxheSwqcGxheWluZywqcHJvZ3Jlc3MsKnJhdGVjaGFuZ2UsKnJlc2V0LCpyZXNpemUsKnNjcm9sbCwqc2VhcmNoLCpzZWVrZWQsKnNlZWtpbmcsKnNlbGVjdCwqc2VsZWN0c3RhcnQsKnNob3csKnN0YWxsZWQsKnN1Ym1pdCwqc3VzcGVuZCwqdGltZXVwZGF0ZSwqdG9nZ2xlLCp2b2x1bWVjaGFuZ2UsKndhaXRpbmcsKndlYmdsY29udGV4dGNyZWF0aW9uZXJyb3IsKndlYmdsY29udGV4dGxvc3QsKndlYmdsY29udGV4dHJlc3RvcmVkLCp3ZWJraXRmdWxsc2NyZWVuY2hhbmdlLCp3ZWJraXRmdWxsc2NyZWVuZXJyb3IsKndoZWVsLG91dGVyVGV4dCwhc3BlbGxjaGVjaywlc3R5bGUsI3RhYkluZGV4LHRpdGxlLCF0cmFuc2xhdGUnLFxuICAgICAgJ2FiYnIsYWRkcmVzcyxhcnRpY2xlLGFzaWRlLGIsYmRpLGJkbyxjaXRlLGNvZGUsZGQsZGZuLGR0LGVtLGZpZ2NhcHRpb24sZmlndXJlLGZvb3RlcixoZWFkZXIsaSxrYmQsbWFpbixtYXJrLG5hdixub3NjcmlwdCxyYixycCxydCxydGMscnVieSxzLHNhbXAsc2VjdGlvbixzbWFsbCxzdHJvbmcsc3ViLHN1cCx1LHZhcix3YnJeW0hUTUxFbGVtZW50XXxhY2Nlc3NLZXksY29udGVudEVkaXRhYmxlLGRpciwhZHJhZ2dhYmxlLCFoaWRkZW4saW5uZXJUZXh0LGxhbmcsKmFib3J0LCpiZWZvcmVjb3B5LCpiZWZvcmVjdXQsKmJlZm9yZXBhc3RlLCpibHVyLCpjYW5jZWwsKmNhbnBsYXksKmNhbnBsYXl0aHJvdWdoLCpjaGFuZ2UsKmNsaWNrLCpjbG9zZSwqY29udGV4dG1lbnUsKmNvcHksKmN1ZWNoYW5nZSwqY3V0LCpkYmxjbGljaywqZHJhZywqZHJhZ2VuZCwqZHJhZ2VudGVyLCpkcmFnbGVhdmUsKmRyYWdvdmVyLCpkcmFnc3RhcnQsKmRyb3AsKmR1cmF0aW9uY2hhbmdlLCplbXB0aWVkLCplbmRlZCwqZXJyb3IsKmZvY3VzLCppbnB1dCwqaW52YWxpZCwqa2V5ZG93biwqa2V5cHJlc3MsKmtleXVwLCpsb2FkLCpsb2FkZWRkYXRhLCpsb2FkZWRtZXRhZGF0YSwqbG9hZHN0YXJ0LCptZXNzYWdlLCptb3VzZWRvd24sKm1vdXNlZW50ZXIsKm1vdXNlbGVhdmUsKm1vdXNlbW92ZSwqbW91c2VvdXQsKm1vdXNlb3ZlciwqbW91c2V1cCwqbW91c2V3aGVlbCwqbW96ZnVsbHNjcmVlbmNoYW5nZSwqbW96ZnVsbHNjcmVlbmVycm9yLCptb3pwb2ludGVybG9ja2NoYW5nZSwqbW96cG9pbnRlcmxvY2tlcnJvciwqcGFzdGUsKnBhdXNlLCpwbGF5LCpwbGF5aW5nLCpwcm9ncmVzcywqcmF0ZWNoYW5nZSwqcmVzZXQsKnJlc2l6ZSwqc2Nyb2xsLCpzZWFyY2gsKnNlZWtlZCwqc2Vla2luZywqc2VsZWN0LCpzZWxlY3RzdGFydCwqc2hvdywqc3RhbGxlZCwqc3VibWl0LCpzdXNwZW5kLCp0aW1ldXBkYXRlLCp0b2dnbGUsKnZvbHVtZWNoYW5nZSwqd2FpdGluZywqd2ViZ2xjb250ZXh0Y3JlYXRpb25lcnJvciwqd2ViZ2xjb250ZXh0bG9zdCwqd2ViZ2xjb250ZXh0cmVzdG9yZWQsKndlYmtpdGZ1bGxzY3JlZW5jaGFuZ2UsKndlYmtpdGZ1bGxzY3JlZW5lcnJvciwqd2hlZWwsb3V0ZXJUZXh0LCFzcGVsbGNoZWNrLCVzdHlsZSwjdGFiSW5kZXgsdGl0bGUsIXRyYW5zbGF0ZScsXG4gICAgICAnbWVkaWFeW0hUTUxFbGVtZW50XXwhYXV0b3BsYXksIWNvbnRyb2xzLCVjcm9zc09yaWdpbiwjY3VycmVudFRpbWUsIWRlZmF1bHRNdXRlZCwjZGVmYXVsdFBsYXliYWNrUmF0ZSwhZGlzYWJsZVJlbW90ZVBsYXliYWNrLCFsb29wLCFtdXRlZCwqZW5jcnlwdGVkLCNwbGF5YmFja1JhdGUscHJlbG9hZCxzcmMsJXNyY09iamVjdCwjdm9sdW1lJyxcbiAgICAgICc6c3ZnOl5bSFRNTEVsZW1lbnRdfCphYm9ydCwqYmx1ciwqY2FuY2VsLCpjYW5wbGF5LCpjYW5wbGF5dGhyb3VnaCwqY2hhbmdlLCpjbGljaywqY2xvc2UsKmNvbnRleHRtZW51LCpjdWVjaGFuZ2UsKmRibGNsaWNrLCpkcmFnLCpkcmFnZW5kLCpkcmFnZW50ZXIsKmRyYWdsZWF2ZSwqZHJhZ292ZXIsKmRyYWdzdGFydCwqZHJvcCwqZHVyYXRpb25jaGFuZ2UsKmVtcHRpZWQsKmVuZGVkLCplcnJvciwqZm9jdXMsKmlucHV0LCppbnZhbGlkLCprZXlkb3duLCprZXlwcmVzcywqa2V5dXAsKmxvYWQsKmxvYWRlZGRhdGEsKmxvYWRlZG1ldGFkYXRhLCpsb2Fkc3RhcnQsKm1vdXNlZG93biwqbW91c2VlbnRlciwqbW91c2VsZWF2ZSwqbW91c2Vtb3ZlLCptb3VzZW91dCwqbW91c2VvdmVyLCptb3VzZXVwLCptb3VzZXdoZWVsLCpwYXVzZSwqcGxheSwqcGxheWluZywqcHJvZ3Jlc3MsKnJhdGVjaGFuZ2UsKnJlc2V0LCpyZXNpemUsKnNjcm9sbCwqc2Vla2VkLCpzZWVraW5nLCpzZWxlY3QsKnNob3csKnN0YWxsZWQsKnN1Ym1pdCwqc3VzcGVuZCwqdGltZXVwZGF0ZSwqdG9nZ2xlLCp2b2x1bWVjaGFuZ2UsKndhaXRpbmcsJXN0eWxlLCN0YWJJbmRleCcsXG4gICAgICAnOnN2ZzpncmFwaGljc146c3ZnOnwnLFxuICAgICAgJzpzdmc6YW5pbWF0aW9uXjpzdmc6fCpiZWdpbiwqZW5kLCpyZXBlYXQnLFxuICAgICAgJzpzdmc6Z2VvbWV0cnleOnN2Zzp8JyxcbiAgICAgICc6c3ZnOmNvbXBvbmVudFRyYW5zZmVyRnVuY3Rpb25eOnN2Zzp8JyxcbiAgICAgICc6c3ZnOmdyYWRpZW50Xjpzdmc6fCcsXG4gICAgICAnOnN2Zzp0ZXh0Q29udGVudF46c3ZnOmdyYXBoaWNzfCcsXG4gICAgICAnOnN2Zzp0ZXh0UG9zaXRpb25pbmdeOnN2Zzp0ZXh0Q29udGVudHwnLFxuICAgICAgJ2FeW0hUTUxFbGVtZW50XXxjaGFyc2V0LGNvb3Jkcyxkb3dubG9hZCxoYXNoLGhvc3QsaG9zdG5hbWUsaHJlZixocmVmbGFuZyxuYW1lLHBhc3N3b3JkLHBhdGhuYW1lLHBpbmcscG9ydCxwcm90b2NvbCxyZWZlcnJlclBvbGljeSxyZWwscmV2LHNlYXJjaCxzaGFwZSx0YXJnZXQsdGV4dCx0eXBlLHVzZXJuYW1lJyxcbiAgICAgICdhcmVhXltIVE1MRWxlbWVudF18YWx0LGNvb3JkcyxoYXNoLGhvc3QsaG9zdG5hbWUsaHJlZiwhbm9IcmVmLHBhc3N3b3JkLHBhdGhuYW1lLHBpbmcscG9ydCxwcm90b2NvbCxyZWZlcnJlclBvbGljeSxzZWFyY2gsc2hhcGUsdGFyZ2V0LHVzZXJuYW1lJyxcbiAgICAgICdhdWRpb15tZWRpYXwnLFxuICAgICAgJ2JyXltIVE1MRWxlbWVudF18Y2xlYXInLFxuICAgICAgJ2Jhc2VeW0hUTUxFbGVtZW50XXxocmVmLHRhcmdldCcsXG4gICAgICAnYm9keV5bSFRNTEVsZW1lbnRdfGFMaW5rLGJhY2tncm91bmQsYmdDb2xvcixsaW5rLCpiZWZvcmV1bmxvYWQsKmJsdXIsKmVycm9yLCpmb2N1cywqaGFzaGNoYW5nZSwqbGFuZ3VhZ2VjaGFuZ2UsKmxvYWQsKm1lc3NhZ2UsKm9mZmxpbmUsKm9ubGluZSwqcGFnZWhpZGUsKnBhZ2VzaG93LCpwb3BzdGF0ZSwqcmVqZWN0aW9uaGFuZGxlZCwqcmVzaXplLCpzY3JvbGwsKnN0b3JhZ2UsKnVuaGFuZGxlZHJlamVjdGlvbiwqdW5sb2FkLHRleHQsdkxpbmsnLFxuICAgICAgJ2J1dHRvbl5bSFRNTEVsZW1lbnRdfCFhdXRvZm9jdXMsIWRpc2FibGVkLGZvcm1BY3Rpb24sZm9ybUVuY3R5cGUsZm9ybU1ldGhvZCwhZm9ybU5vVmFsaWRhdGUsZm9ybVRhcmdldCxuYW1lLHR5cGUsdmFsdWUnLFxuICAgICAgJ2NhbnZhc15bSFRNTEVsZW1lbnRdfCNoZWlnaHQsI3dpZHRoJyxcbiAgICAgICdjb250ZW50XltIVE1MRWxlbWVudF18c2VsZWN0JyxcbiAgICAgICdkbF5bSFRNTEVsZW1lbnRdfCFjb21wYWN0JyxcbiAgICAgICdkYXRhbGlzdF5bSFRNTEVsZW1lbnRdfCcsXG4gICAgICAnZGV0YWlsc15bSFRNTEVsZW1lbnRdfCFvcGVuJyxcbiAgICAgICdkaWFsb2deW0hUTUxFbGVtZW50XXwhb3BlbixyZXR1cm5WYWx1ZScsXG4gICAgICAnZGlyXltIVE1MRWxlbWVudF18IWNvbXBhY3QnLFxuICAgICAgJ2Rpdl5bSFRNTEVsZW1lbnRdfGFsaWduJyxcbiAgICAgICdlbWJlZF5bSFRNTEVsZW1lbnRdfGFsaWduLGhlaWdodCxuYW1lLHNyYyx0eXBlLHdpZHRoJyxcbiAgICAgICdmaWVsZHNldF5bSFRNTEVsZW1lbnRdfCFkaXNhYmxlZCxuYW1lJyxcbiAgICAgICdmb250XltIVE1MRWxlbWVudF18Y29sb3IsZmFjZSxzaXplJyxcbiAgICAgICdmb3JtXltIVE1MRWxlbWVudF18YWNjZXB0Q2hhcnNldCxhY3Rpb24sYXV0b2NvbXBsZXRlLGVuY29kaW5nLGVuY3R5cGUsbWV0aG9kLG5hbWUsIW5vVmFsaWRhdGUsdGFyZ2V0JyxcbiAgICAgICdmcmFtZV5bSFRNTEVsZW1lbnRdfGZyYW1lQm9yZGVyLGxvbmdEZXNjLG1hcmdpbkhlaWdodCxtYXJnaW5XaWR0aCxuYW1lLCFub1Jlc2l6ZSxzY3JvbGxpbmcsc3JjJyxcbiAgICAgICdmcmFtZXNldF5bSFRNTEVsZW1lbnRdfGNvbHMsKmJlZm9yZXVubG9hZCwqYmx1ciwqZXJyb3IsKmZvY3VzLCpoYXNoY2hhbmdlLCpsYW5ndWFnZWNoYW5nZSwqbG9hZCwqbWVzc2FnZSwqb2ZmbGluZSwqb25saW5lLCpwYWdlaGlkZSwqcGFnZXNob3csKnBvcHN0YXRlLCpyZWplY3Rpb25oYW5kbGVkLCpyZXNpemUsKnNjcm9sbCwqc3RvcmFnZSwqdW5oYW5kbGVkcmVqZWN0aW9uLCp1bmxvYWQscm93cycsXG4gICAgICAnaHJeW0hUTUxFbGVtZW50XXxhbGlnbixjb2xvciwhbm9TaGFkZSxzaXplLHdpZHRoJyxcbiAgICAgICdoZWFkXltIVE1MRWxlbWVudF18JyxcbiAgICAgICdoMSxoMixoMyxoNCxoNSxoNl5bSFRNTEVsZW1lbnRdfGFsaWduJyxcbiAgICAgICdodG1sXltIVE1MRWxlbWVudF18dmVyc2lvbicsXG4gICAgICAnaWZyYW1lXltIVE1MRWxlbWVudF18YWxpZ24sIWFsbG93RnVsbHNjcmVlbixmcmFtZUJvcmRlcixoZWlnaHQsbG9uZ0Rlc2MsbWFyZ2luSGVpZ2h0LG1hcmdpbldpZHRoLG5hbWUscmVmZXJyZXJQb2xpY3ksJXNhbmRib3gsc2Nyb2xsaW5nLHNyYyxzcmNkb2Msd2lkdGgnLFxuICAgICAgJ2ltZ15bSFRNTEVsZW1lbnRdfGFsaWduLGFsdCxib3JkZXIsJWNyb3NzT3JpZ2luLCNoZWlnaHQsI2hzcGFjZSwhaXNNYXAsbG9uZ0Rlc2MsbG93c3JjLG5hbWUscmVmZXJyZXJQb2xpY3ksc2l6ZXMsc3JjLHNyY3NldCx1c2VNYXAsI3ZzcGFjZSwjd2lkdGgnLFxuICAgICAgJ2lucHV0XltIVE1MRWxlbWVudF18YWNjZXB0LGFsaWduLGFsdCxhdXRvY2FwaXRhbGl6ZSxhdXRvY29tcGxldGUsIWF1dG9mb2N1cywhY2hlY2tlZCwhZGVmYXVsdENoZWNrZWQsZGVmYXVsdFZhbHVlLGRpck5hbWUsIWRpc2FibGVkLCVmaWxlcyxmb3JtQWN0aW9uLGZvcm1FbmN0eXBlLGZvcm1NZXRob2QsIWZvcm1Ob1ZhbGlkYXRlLGZvcm1UYXJnZXQsI2hlaWdodCwhaW5jcmVtZW50YWwsIWluZGV0ZXJtaW5hdGUsbWF4LCNtYXhMZW5ndGgsbWluLCNtaW5MZW5ndGgsIW11bHRpcGxlLG5hbWUscGF0dGVybixwbGFjZWhvbGRlciwhcmVhZE9ubHksIXJlcXVpcmVkLHNlbGVjdGlvbkRpcmVjdGlvbiwjc2VsZWN0aW9uRW5kLCNzZWxlY3Rpb25TdGFydCwjc2l6ZSxzcmMsc3RlcCx0eXBlLHVzZU1hcCx2YWx1ZSwldmFsdWVBc0RhdGUsI3ZhbHVlQXNOdW1iZXIsI3dpZHRoJyxcbiAgICAgICdrZXlnZW5eW0hUTUxFbGVtZW50XXwhYXV0b2ZvY3VzLGNoYWxsZW5nZSwhZGlzYWJsZWQsa2V5dHlwZSxuYW1lJyxcbiAgICAgICdsaV5bSFRNTEVsZW1lbnRdfHR5cGUsI3ZhbHVlJyxcbiAgICAgICdsYWJlbF5bSFRNTEVsZW1lbnRdfGh0bWxGb3InLFxuICAgICAgJ2xlZ2VuZF5bSFRNTEVsZW1lbnRdfGFsaWduJyxcbiAgICAgICdsaW5rXltIVE1MRWxlbWVudF18YXMsY2hhcnNldCwlY3Jvc3NPcmlnaW4sIWRpc2FibGVkLGhyZWYsaHJlZmxhbmcsaW50ZWdyaXR5LG1lZGlhLHJlbCwlcmVsTGlzdCxyZXYsJXNpemVzLHRhcmdldCx0eXBlJyxcbiAgICAgICdtYXBeW0hUTUxFbGVtZW50XXxuYW1lJyxcbiAgICAgICdtYXJxdWVlXltIVE1MRWxlbWVudF18YmVoYXZpb3IsYmdDb2xvcixkaXJlY3Rpb24saGVpZ2h0LCNoc3BhY2UsI2xvb3AsI3Njcm9sbEFtb3VudCwjc2Nyb2xsRGVsYXksIXRydWVTcGVlZCwjdnNwYWNlLHdpZHRoJyxcbiAgICAgICdtZW51XltIVE1MRWxlbWVudF18IWNvbXBhY3QnLFxuICAgICAgJ21ldGFeW0hUTUxFbGVtZW50XXxjb250ZW50LGh0dHBFcXVpdixuYW1lLHNjaGVtZScsXG4gICAgICAnbWV0ZXJeW0hUTUxFbGVtZW50XXwjaGlnaCwjbG93LCNtYXgsI21pbiwjb3B0aW11bSwjdmFsdWUnLFxuICAgICAgJ2lucyxkZWxeW0hUTUxFbGVtZW50XXxjaXRlLGRhdGVUaW1lJyxcbiAgICAgICdvbF5bSFRNTEVsZW1lbnRdfCFjb21wYWN0LCFyZXZlcnNlZCwjc3RhcnQsdHlwZScsXG4gICAgICAnb2JqZWN0XltIVE1MRWxlbWVudF18YWxpZ24sYXJjaGl2ZSxib3JkZXIsY29kZSxjb2RlQmFzZSxjb2RlVHlwZSxkYXRhLCFkZWNsYXJlLGhlaWdodCwjaHNwYWNlLG5hbWUsc3RhbmRieSx0eXBlLHVzZU1hcCwjdnNwYWNlLHdpZHRoJyxcbiAgICAgICdvcHRncm91cF5bSFRNTEVsZW1lbnRdfCFkaXNhYmxlZCxsYWJlbCcsXG4gICAgICAnb3B0aW9uXltIVE1MRWxlbWVudF18IWRlZmF1bHRTZWxlY3RlZCwhZGlzYWJsZWQsbGFiZWwsIXNlbGVjdGVkLHRleHQsdmFsdWUnLFxuICAgICAgJ291dHB1dF5bSFRNTEVsZW1lbnRdfGRlZmF1bHRWYWx1ZSwlaHRtbEZvcixuYW1lLHZhbHVlJyxcbiAgICAgICdwXltIVE1MRWxlbWVudF18YWxpZ24nLFxuICAgICAgJ3BhcmFtXltIVE1MRWxlbWVudF18bmFtZSx0eXBlLHZhbHVlLHZhbHVlVHlwZScsXG4gICAgICAncGljdHVyZV5bSFRNTEVsZW1lbnRdfCcsXG4gICAgICAncHJlXltIVE1MRWxlbWVudF18I3dpZHRoJyxcbiAgICAgICdwcm9ncmVzc15bSFRNTEVsZW1lbnRdfCNtYXgsI3ZhbHVlJyxcbiAgICAgICdxLGJsb2NrcXVvdGUsY2l0ZV5bSFRNTEVsZW1lbnRdfCcsXG4gICAgICAnc2NyaXB0XltIVE1MRWxlbWVudF18IWFzeW5jLGNoYXJzZXQsJWNyb3NzT3JpZ2luLCFkZWZlcixldmVudCxodG1sRm9yLGludGVncml0eSxzcmMsdGV4dCx0eXBlJyxcbiAgICAgICdzZWxlY3ReW0hUTUxFbGVtZW50XXwhYXV0b2ZvY3VzLCFkaXNhYmxlZCwjbGVuZ3RoLCFtdWx0aXBsZSxuYW1lLCFyZXF1aXJlZCwjc2VsZWN0ZWRJbmRleCwjc2l6ZSx2YWx1ZScsXG4gICAgICAnc2hhZG93XltIVE1MRWxlbWVudF18JyxcbiAgICAgICdzb3VyY2VeW0hUTUxFbGVtZW50XXxtZWRpYSxzaXplcyxzcmMsc3Jjc2V0LHR5cGUnLFxuICAgICAgJ3NwYW5eW0hUTUxFbGVtZW50XXwnLFxuICAgICAgJ3N0eWxlXltIVE1MRWxlbWVudF18IWRpc2FibGVkLG1lZGlhLHR5cGUnLFxuICAgICAgJ2NhcHRpb25eW0hUTUxFbGVtZW50XXxhbGlnbicsXG4gICAgICAndGgsdGReW0hUTUxFbGVtZW50XXxhYmJyLGFsaWduLGF4aXMsYmdDb2xvcixjaCxjaE9mZiwjY29sU3BhbixoZWFkZXJzLGhlaWdodCwhbm9XcmFwLCNyb3dTcGFuLHNjb3BlLHZBbGlnbix3aWR0aCcsXG4gICAgICAnY29sLGNvbGdyb3VwXltIVE1MRWxlbWVudF18YWxpZ24sY2gsY2hPZmYsI3NwYW4sdkFsaWduLHdpZHRoJyxcbiAgICAgICd0YWJsZV5bSFRNTEVsZW1lbnRdfGFsaWduLGJnQ29sb3IsYm9yZGVyLCVjYXB0aW9uLGNlbGxQYWRkaW5nLGNlbGxTcGFjaW5nLGZyYW1lLHJ1bGVzLHN1bW1hcnksJXRGb290LCV0SGVhZCx3aWR0aCcsXG4gICAgICAndHJeW0hUTUxFbGVtZW50XXxhbGlnbixiZ0NvbG9yLGNoLGNoT2ZmLHZBbGlnbicsXG4gICAgICAndGZvb3QsdGhlYWQsdGJvZHleW0hUTUxFbGVtZW50XXxhbGlnbixjaCxjaE9mZix2QWxpZ24nLFxuICAgICAgJ3RlbXBsYXRlXltIVE1MRWxlbWVudF18JyxcbiAgICAgICd0ZXh0YXJlYV5bSFRNTEVsZW1lbnRdfGF1dG9jYXBpdGFsaXplLCFhdXRvZm9jdXMsI2NvbHMsZGVmYXVsdFZhbHVlLGRpck5hbWUsIWRpc2FibGVkLCNtYXhMZW5ndGgsI21pbkxlbmd0aCxuYW1lLHBsYWNlaG9sZGVyLCFyZWFkT25seSwhcmVxdWlyZWQsI3Jvd3Msc2VsZWN0aW9uRGlyZWN0aW9uLCNzZWxlY3Rpb25FbmQsI3NlbGVjdGlvblN0YXJ0LHZhbHVlLHdyYXAnLFxuICAgICAgJ3RpdGxlXltIVE1MRWxlbWVudF18dGV4dCcsXG4gICAgICAndHJhY2teW0hUTUxFbGVtZW50XXwhZGVmYXVsdCxraW5kLGxhYmVsLHNyYyxzcmNsYW5nJyxcbiAgICAgICd1bF5bSFRNTEVsZW1lbnRdfCFjb21wYWN0LHR5cGUnLFxuICAgICAgJ3Vua25vd25eW0hUTUxFbGVtZW50XXwnLFxuICAgICAgJ3ZpZGVvXm1lZGlhfCNoZWlnaHQscG9zdGVyLCN3aWR0aCcsXG4gICAgICAnOnN2ZzphXjpzdmc6Z3JhcGhpY3N8JyxcbiAgICAgICc6c3ZnOmFuaW1hdGVeOnN2ZzphbmltYXRpb258JyxcbiAgICAgICc6c3ZnOmFuaW1hdGVNb3Rpb25eOnN2ZzphbmltYXRpb258JyxcbiAgICAgICc6c3ZnOmFuaW1hdGVUcmFuc2Zvcm1eOnN2ZzphbmltYXRpb258JyxcbiAgICAgICc6c3ZnOmNpcmNsZV46c3ZnOmdlb21ldHJ5fCcsXG4gICAgICAnOnN2ZzpjbGlwUGF0aF46c3ZnOmdyYXBoaWNzfCcsXG4gICAgICAnOnN2ZzpjdXJzb3JeOnN2Zzp8JyxcbiAgICAgICc6c3ZnOmRlZnNeOnN2ZzpncmFwaGljc3wnLFxuICAgICAgJzpzdmc6ZGVzY146c3ZnOnwnLFxuICAgICAgJzpzdmc6ZGlzY2FyZF46c3ZnOnwnLFxuICAgICAgJzpzdmc6ZWxsaXBzZV46c3ZnOmdlb21ldHJ5fCcsXG4gICAgICAnOnN2ZzpmZUJsZW5kXjpzdmc6fCcsXG4gICAgICAnOnN2ZzpmZUNvbG9yTWF0cml4Xjpzdmc6fCcsXG4gICAgICAnOnN2ZzpmZUNvbXBvbmVudFRyYW5zZmVyXjpzdmc6fCcsXG4gICAgICAnOnN2ZzpmZUNvbXBvc2l0ZV46c3ZnOnwnLFxuICAgICAgJzpzdmc6ZmVDb252b2x2ZU1hdHJpeF46c3ZnOnwnLFxuICAgICAgJzpzdmc6ZmVEaWZmdXNlTGlnaHRpbmdeOnN2Zzp8JyxcbiAgICAgICc6c3ZnOmZlRGlzcGxhY2VtZW50TWFwXjpzdmc6fCcsXG4gICAgICAnOnN2ZzpmZURpc3RhbnRMaWdodF46c3ZnOnwnLFxuICAgICAgJzpzdmc6ZmVEcm9wU2hhZG93Xjpzdmc6fCcsXG4gICAgICAnOnN2ZzpmZUZsb29kXjpzdmc6fCcsXG4gICAgICAnOnN2ZzpmZUZ1bmNBXjpzdmc6Y29tcG9uZW50VHJhbnNmZXJGdW5jdGlvbnwnLFxuICAgICAgJzpzdmc6ZmVGdW5jQl46c3ZnOmNvbXBvbmVudFRyYW5zZmVyRnVuY3Rpb258JyxcbiAgICAgICc6c3ZnOmZlRnVuY0deOnN2Zzpjb21wb25lbnRUcmFuc2ZlckZ1bmN0aW9ufCcsXG4gICAgICAnOnN2ZzpmZUZ1bmNSXjpzdmc6Y29tcG9uZW50VHJhbnNmZXJGdW5jdGlvbnwnLFxuICAgICAgJzpzdmc6ZmVHYXVzc2lhbkJsdXJeOnN2Zzp8JyxcbiAgICAgICc6c3ZnOmZlSW1hZ2VeOnN2Zzp8JyxcbiAgICAgICc6c3ZnOmZlTWVyZ2VeOnN2Zzp8JyxcbiAgICAgICc6c3ZnOmZlTWVyZ2VOb2RlXjpzdmc6fCcsXG4gICAgICAnOnN2ZzpmZU1vcnBob2xvZ3leOnN2Zzp8JyxcbiAgICAgICc6c3ZnOmZlT2Zmc2V0Xjpzdmc6fCcsXG4gICAgICAnOnN2ZzpmZVBvaW50TGlnaHReOnN2Zzp8JyxcbiAgICAgICc6c3ZnOmZlU3BlY3VsYXJMaWdodGluZ146c3ZnOnwnLFxuICAgICAgJzpzdmc6ZmVTcG90TGlnaHReOnN2Zzp8JyxcbiAgICAgICc6c3ZnOmZlVGlsZV46c3ZnOnwnLFxuICAgICAgJzpzdmc6ZmVUdXJidWxlbmNlXjpzdmc6fCcsXG4gICAgICAnOnN2ZzpmaWx0ZXJeOnN2Zzp8JyxcbiAgICAgICc6c3ZnOmZvcmVpZ25PYmplY3ReOnN2ZzpncmFwaGljc3wnLFxuICAgICAgJzpzdmc6Z146c3ZnOmdyYXBoaWNzfCcsXG4gICAgICAnOnN2ZzppbWFnZV46c3ZnOmdyYXBoaWNzfCcsXG4gICAgICAnOnN2ZzpsaW5lXjpzdmc6Z2VvbWV0cnl8JyxcbiAgICAgICc6c3ZnOmxpbmVhckdyYWRpZW50Xjpzdmc6Z3JhZGllbnR8JyxcbiAgICAgICc6c3ZnOm1wYXRoXjpzdmc6fCcsXG4gICAgICAnOnN2ZzptYXJrZXJeOnN2Zzp8JyxcbiAgICAgICc6c3ZnOm1hc2teOnN2Zzp8JyxcbiAgICAgICc6c3ZnOm1ldGFkYXRhXjpzdmc6fCcsXG4gICAgICAnOnN2ZzpwYXRoXjpzdmc6Z2VvbWV0cnl8JyxcbiAgICAgICc6c3ZnOnBhdHRlcm5eOnN2Zzp8JyxcbiAgICAgICc6c3ZnOnBvbHlnb25eOnN2ZzpnZW9tZXRyeXwnLFxuICAgICAgJzpzdmc6cG9seWxpbmVeOnN2ZzpnZW9tZXRyeXwnLFxuICAgICAgJzpzdmc6cmFkaWFsR3JhZGllbnReOnN2ZzpncmFkaWVudHwnLFxuICAgICAgJzpzdmc6cmVjdF46c3ZnOmdlb21ldHJ5fCcsXG4gICAgICAnOnN2ZzpzdmdeOnN2ZzpncmFwaGljc3wjY3VycmVudFNjYWxlLCN6b29tQW5kUGFuJyxcbiAgICAgICc6c3ZnOnNjcmlwdF46c3ZnOnx0eXBlJyxcbiAgICAgICc6c3ZnOnNldF46c3ZnOmFuaW1hdGlvbnwnLFxuICAgICAgJzpzdmc6c3RvcF46c3ZnOnwnLFxuICAgICAgJzpzdmc6c3R5bGVeOnN2Zzp8IWRpc2FibGVkLG1lZGlhLHRpdGxlLHR5cGUnLFxuICAgICAgJzpzdmc6c3dpdGNoXjpzdmc6Z3JhcGhpY3N8JyxcbiAgICAgICc6c3ZnOnN5bWJvbF46c3ZnOnwnLFxuICAgICAgJzpzdmc6dHNwYW5eOnN2Zzp0ZXh0UG9zaXRpb25pbmd8JyxcbiAgICAgICc6c3ZnOnRleHReOnN2Zzp0ZXh0UG9zaXRpb25pbmd8JyxcbiAgICAgICc6c3ZnOnRleHRQYXRoXjpzdmc6dGV4dENvbnRlbnR8JyxcbiAgICAgICc6c3ZnOnRpdGxlXjpzdmc6fCcsXG4gICAgICAnOnN2Zzp1c2VeOnN2ZzpncmFwaGljc3wnLFxuICAgICAgJzpzdmc6dmlld146c3ZnOnwjem9vbUFuZFBhbicsXG4gICAgICAnZGF0YV5bSFRNTEVsZW1lbnRdfHZhbHVlJyxcbiAgICAgICdtZW51aXRlbV5bSFRNTEVsZW1lbnRdfHR5cGUsbGFiZWwsaWNvbiwhZGlzYWJsZWQsIWNoZWNrZWQscmFkaW9ncm91cCwhZGVmYXVsdCcsXG4gICAgICAnc3VtbWFyeV5bSFRNTEVsZW1lbnRdfCcsXG4gICAgICAndGltZV5bSFRNTEVsZW1lbnRdfGRhdGVUaW1lJyxcbiAgXTtcbiAgdmFyIF9BVFRSX1RPX1BST1AgPSB7XG4gICAgICAnY2xhc3MnOiAnY2xhc3NOYW1lJyxcbiAgICAgICdmb3JtYWN0aW9uJzogJ2Zvcm1BY3Rpb24nLFxuICAgICAgJ2lubmVySHRtbCc6ICdpbm5lckhUTUwnLFxuICAgICAgJ3JlYWRvbmx5JzogJ3JlYWRPbmx5JyxcbiAgICAgICd0YWJpbmRleCc6ICd0YWJJbmRleCcsXG4gIH07XG4gIHZhciBEb21FbGVtZW50U2NoZW1hUmVnaXN0cnkgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDIxKERvbUVsZW1lbnRTY2hlbWFSZWdpc3RyeSwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIERvbUVsZW1lbnRTY2hlbWFSZWdpc3RyeSgpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgIHRoaXMuX3NjaGVtYSA9IHt9O1xuICAgICAgICAgIFNDSEVNQS5mb3JFYWNoKGZ1bmN0aW9uIChlbmNvZGVkVHlwZSkge1xuICAgICAgICAgICAgICB2YXIgdHlwZSA9IHt9O1xuICAgICAgICAgICAgICB2YXIgX2EgPSBlbmNvZGVkVHlwZS5zcGxpdCgnfCcpLCBzdHJUeXBlID0gX2FbMF0sIHN0clByb3BlcnRpZXMgPSBfYVsxXTtcbiAgICAgICAgICAgICAgdmFyIHByb3BlcnRpZXMgPSBzdHJQcm9wZXJ0aWVzLnNwbGl0KCcsJyk7XG4gICAgICAgICAgICAgIHZhciBfYiA9IHN0clR5cGUuc3BsaXQoJ14nKSwgdHlwZU5hbWVzID0gX2JbMF0sIHN1cGVyTmFtZSA9IF9iWzFdO1xuICAgICAgICAgICAgICB0eXBlTmFtZXMuc3BsaXQoJywnKS5mb3JFYWNoKGZ1bmN0aW9uICh0YWcpIHsgcmV0dXJuIF90aGlzLl9zY2hlbWFbdGFnLnRvTG93ZXJDYXNlKCldID0gdHlwZTsgfSk7XG4gICAgICAgICAgICAgIHZhciBzdXBlclR5cGUgPSBzdXBlck5hbWUgJiYgX3RoaXMuX3NjaGVtYVtzdXBlck5hbWUudG9Mb3dlckNhc2UoKV07XG4gICAgICAgICAgICAgIGlmIChzdXBlclR5cGUpIHtcbiAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHN1cGVyVHlwZSkuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkgeyB0eXBlW3Byb3BdID0gc3VwZXJUeXBlW3Byb3BdOyB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBwcm9wZXJ0aWVzLmZvckVhY2goZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgICBpZiAocHJvcGVydHkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAocHJvcGVydHlbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnKic6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBkb24ndCB5ZXQgc3VwcG9ydCBldmVudHMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBldmVyIGFsbG93aW5nIHRvIGJpbmQgdG8gZXZlbnRzLCBHTyBUSFJPVUdIIEEgU0VDVVJJVFkgUkVWSUVXLCBhbGxvd2luZyBldmVudHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdpbGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFsbW9zdCBjZXJ0YWlubHkgaW50cm9kdWNlIGJhZCBYU1MgdnVsbmVyYWJpbGl0aWVzLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHlwZVtwcm9wZXJ0eS5zdWJzdHJpbmcoMSldID0gRVZFTlQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnISc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlW3Byb3BlcnR5LnN1YnN0cmluZygxKV0gPSBCT09MRUFOO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJyMnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZVtwcm9wZXJ0eS5zdWJzdHJpbmcoMSldID0gTlVNQkVSO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJyUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZVtwcm9wZXJ0eS5zdWJzdHJpbmcoMSldID0gT0JKRUNUO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlW3Byb3BlcnR5XSA9IFNUUklORztcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgRG9tRWxlbWVudFNjaGVtYVJlZ2lzdHJ5LnByb3RvdHlwZS5oYXNQcm9wZXJ0eSA9IGZ1bmN0aW9uICh0YWdOYW1lLCBwcm9wTmFtZSwgc2NoZW1hTWV0YXMpIHtcbiAgICAgICAgICBpZiAoc2NoZW1hTWV0YXMuc29tZShmdW5jdGlvbiAoc2NoZW1hKSB7IHJldHVybiBzY2hlbWEubmFtZSA9PT0gX2FuZ3VsYXJfY29yZS5OT19FUlJPUlNfU0NIRU1BLm5hbWU7IH0pKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGFnTmFtZS5pbmRleE9mKCctJykgPiAtMSkge1xuICAgICAgICAgICAgICBpZiAodGFnTmFtZSA9PT0gJ25nLWNvbnRhaW5lcicgfHwgdGFnTmFtZSA9PT0gJ25nLWNvbnRlbnQnKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHNjaGVtYU1ldGFzLnNvbWUoZnVuY3Rpb24gKHNjaGVtYSkgeyByZXR1cm4gc2NoZW1hLm5hbWUgPT09IF9hbmd1bGFyX2NvcmUuQ1VTVE9NX0VMRU1FTlRTX1NDSEVNQS5uYW1lOyB9KSkge1xuICAgICAgICAgICAgICAgICAgLy8gQ2FuJ3QgdGVsbCBub3cgYXMgd2UgZG9uJ3Qga25vdyB3aGljaCBwcm9wZXJ0aWVzIGEgY3VzdG9tIGVsZW1lbnQgd2lsbCBnZXRcbiAgICAgICAgICAgICAgICAgIC8vIG9uY2UgaXQgaXMgaW5zdGFudGlhdGVkXG4gICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgZWxlbWVudFByb3BlcnRpZXMgPSB0aGlzLl9zY2hlbWFbdGFnTmFtZS50b0xvd2VyQ2FzZSgpXSB8fCB0aGlzLl9zY2hlbWFbJ3Vua25vd24nXTtcbiAgICAgICAgICByZXR1cm4gISFlbGVtZW50UHJvcGVydGllc1twcm9wTmFtZV07XG4gICAgICB9O1xuICAgICAgRG9tRWxlbWVudFNjaGVtYVJlZ2lzdHJ5LnByb3RvdHlwZS5oYXNFbGVtZW50ID0gZnVuY3Rpb24gKHRhZ05hbWUsIHNjaGVtYU1ldGFzKSB7XG4gICAgICAgICAgaWYgKHNjaGVtYU1ldGFzLnNvbWUoZnVuY3Rpb24gKHNjaGVtYSkgeyByZXR1cm4gc2NoZW1hLm5hbWUgPT09IF9hbmd1bGFyX2NvcmUuTk9fRVJST1JTX1NDSEVNQS5uYW1lOyB9KSkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRhZ05hbWUuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICAgICAgICAgICAgaWYgKHRhZ05hbWUgPT09ICduZy1jb250YWluZXInIHx8IHRhZ05hbWUgPT09ICduZy1jb250ZW50Jykge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHNjaGVtYU1ldGFzLnNvbWUoZnVuY3Rpb24gKHNjaGVtYSkgeyByZXR1cm4gc2NoZW1hLm5hbWUgPT09IF9hbmd1bGFyX2NvcmUuQ1VTVE9NX0VMRU1FTlRTX1NDSEVNQS5uYW1lOyB9KSkge1xuICAgICAgICAgICAgICAgICAgLy8gQWxsb3cgYW55IGN1c3RvbSBlbGVtZW50c1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuICEhdGhpcy5fc2NoZW1hW3RhZ05hbWUudG9Mb3dlckNhc2UoKV07XG4gICAgICB9O1xuICAgICAgLyoqXG4gICAgICAgKiBzZWN1cml0eUNvbnRleHQgcmV0dXJucyB0aGUgc2VjdXJpdHkgY29udGV4dCBmb3IgdGhlIGdpdmVuIHByb3BlcnR5IG9uIHRoZSBnaXZlbiBET00gdGFnLlxuICAgICAgICpcbiAgICAgICAqIFRhZyBhbmQgcHJvcGVydHkgbmFtZSBhcmUgc3RhdGljYWxseSBrbm93biBhbmQgY2Fubm90IGNoYW5nZSBhdCBydW50aW1lLCBpLmUuIGl0IGlzIG5vdFxuICAgICAgICogcG9zc2libGUgdG8gYmluZCBhIHZhbHVlIGludG8gYSBjaGFuZ2luZyBhdHRyaWJ1dGUgb3IgdGFnIG5hbWUuXG4gICAgICAgKlxuICAgICAgICogVGhlIGZpbHRlcmluZyBpcyB3aGl0ZSBsaXN0IGJhc2VkLiBBbGwgYXR0cmlidXRlcyBpbiB0aGUgc2NoZW1hIGFib3ZlIGFyZSBhc3N1bWVkIHRvIGhhdmUgdGhlXG4gICAgICAgKiAnTk9ORScgc2VjdXJpdHkgY29udGV4dCwgaS5lLiB0aGF0IHRoZXkgYXJlIHNhZmUgaW5lcnQgc3RyaW5nIHZhbHVlcy4gT25seSBzcGVjaWZpYyB3ZWxsIGtub3duXG4gICAgICAgKiBhdHRhY2sgdmVjdG9ycyBhcmUgYXNzaWduZWQgdGhlaXIgYXBwcm9wcmlhdGUgY29udGV4dC5cbiAgICAgICAqL1xuICAgICAgRG9tRWxlbWVudFNjaGVtYVJlZ2lzdHJ5LnByb3RvdHlwZS5zZWN1cml0eUNvbnRleHQgPSBmdW5jdGlvbiAodGFnTmFtZSwgcHJvcE5hbWUsIGlzQXR0cmlidXRlKSB7XG4gICAgICAgICAgaWYgKGlzQXR0cmlidXRlKSB7XG4gICAgICAgICAgICAgIC8vIE5COiBGb3Igc2VjdXJpdHkgcHVycG9zZXMsIHVzZSB0aGUgbWFwcGVkIHByb3BlcnR5IG5hbWUsIG5vdCB0aGUgYXR0cmlidXRlIG5hbWUuXG4gICAgICAgICAgICAgIHByb3BOYW1lID0gdGhpcy5nZXRNYXBwZWRQcm9wTmFtZShwcm9wTmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIE1ha2Ugc3VyZSBjb21wYXJpc29ucyBhcmUgY2FzZSBpbnNlbnNpdGl2ZSwgc28gdGhhdCBjYXNlIGRpZmZlcmVuY2VzIGJldHdlZW4gYXR0cmlidXRlIGFuZFxuICAgICAgICAgIC8vIHByb3BlcnR5IG5hbWVzIGRvIG5vdCBoYXZlIGEgc2VjdXJpdHkgaW1wYWN0LlxuICAgICAgICAgIHRhZ05hbWUgPSB0YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgcHJvcE5hbWUgPSBwcm9wTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgIHZhciBjdHggPSBTRUNVUklUWV9TQ0hFTUFbdGFnTmFtZSArICd8JyArIHByb3BOYW1lXTtcbiAgICAgICAgICBpZiAoY3R4KSB7XG4gICAgICAgICAgICAgIHJldHVybiBjdHg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGN0eCA9IFNFQ1VSSVRZX1NDSEVNQVsnKnwnICsgcHJvcE5hbWVdO1xuICAgICAgICAgIHJldHVybiBjdHggPyBjdHggOiBfYW5ndWxhcl9jb3JlLlNlY3VyaXR5Q29udGV4dC5OT05FO1xuICAgICAgfTtcbiAgICAgIERvbUVsZW1lbnRTY2hlbWFSZWdpc3RyeS5wcm90b3R5cGUuZ2V0TWFwcGVkUHJvcE5hbWUgPSBmdW5jdGlvbiAocHJvcE5hbWUpIHsgcmV0dXJuIF9BVFRSX1RPX1BST1BbcHJvcE5hbWVdIHx8IHByb3BOYW1lOyB9O1xuICAgICAgRG9tRWxlbWVudFNjaGVtYVJlZ2lzdHJ5LnByb3RvdHlwZS5nZXREZWZhdWx0Q29tcG9uZW50RWxlbWVudE5hbWUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnbmctY29tcG9uZW50JzsgfTtcbiAgICAgIERvbUVsZW1lbnRTY2hlbWFSZWdpc3RyeS5wcm90b3R5cGUudmFsaWRhdGVQcm9wZXJ0eSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgaWYgKG5hbWUudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKCdvbicpKSB7XG4gICAgICAgICAgICAgIHZhciBtc2cgPSAoXCJCaW5kaW5nIHRvIGV2ZW50IHByb3BlcnR5ICdcIiArIG5hbWUgKyBcIicgaXMgZGlzYWxsb3dlZCBmb3Igc2VjdXJpdHkgcmVhc29ucywgXCIpICtcbiAgICAgICAgICAgICAgICAgIChcInBsZWFzZSB1c2UgKFwiICsgbmFtZS5zbGljZSgyKSArIFwiKT0uLi5cIikgK1xuICAgICAgICAgICAgICAgICAgKFwiXFxuSWYgJ1wiICsgbmFtZSArIFwiJyBpcyBhIGRpcmVjdGl2ZSBpbnB1dCwgbWFrZSBzdXJlIHRoZSBkaXJlY3RpdmUgaXMgaW1wb3J0ZWQgYnkgdGhlXCIpICtcbiAgICAgICAgICAgICAgICAgIFwiIGN1cnJlbnQgbW9kdWxlLlwiO1xuICAgICAgICAgICAgICByZXR1cm4geyBlcnJvcjogdHJ1ZSwgbXNnOiBtc2cgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiB7IGVycm9yOiBmYWxzZSB9O1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICBEb21FbGVtZW50U2NoZW1hUmVnaXN0cnkucHJvdG90eXBlLnZhbGlkYXRlQXR0cmlidXRlID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICBpZiAobmFtZS50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoJ29uJykpIHtcbiAgICAgICAgICAgICAgdmFyIG1zZyA9IChcIkJpbmRpbmcgdG8gZXZlbnQgYXR0cmlidXRlICdcIiArIG5hbWUgKyBcIicgaXMgZGlzYWxsb3dlZCBmb3Igc2VjdXJpdHkgcmVhc29ucywgXCIpICtcbiAgICAgICAgICAgICAgICAgIChcInBsZWFzZSB1c2UgKFwiICsgbmFtZS5zbGljZSgyKSArIFwiKT0uLi5cIik7XG4gICAgICAgICAgICAgIHJldHVybiB7IGVycm9yOiB0cnVlLCBtc2c6IG1zZyB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHsgZXJyb3I6IGZhbHNlIH07XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIERvbUVsZW1lbnRTY2hlbWFSZWdpc3RyeS5wcm90b3R5cGUuYWxsS25vd25FbGVtZW50TmFtZXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBPYmplY3Qua2V5cyh0aGlzLl9zY2hlbWEpOyB9O1xuICAgICAgRG9tRWxlbWVudFNjaGVtYVJlZ2lzdHJ5LmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdGFibGUgfSxcbiAgICAgIF07XG4gICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgIERvbUVsZW1lbnRTY2hlbWFSZWdpc3RyeS5jdG9yUGFyYW1ldGVycyA9IFtdO1xuICAgICAgcmV0dXJuIERvbUVsZW1lbnRTY2hlbWFSZWdpc3RyeTtcbiAgfShFbGVtZW50U2NoZW1hUmVnaXN0cnkpKTtcblxuICB2YXIgX05PX1JFU09VUkNFX0xPQURFUiA9IHtcbiAgICAgIGdldDogZnVuY3Rpb24gKHVybCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIFJlc291cmNlTG9hZGVyIGltcGxlbWVudGF0aW9uIGhhcyBiZWVuIHByb3ZpZGVkLiBDYW4ndCByZWFkIHRoZSB1cmwgXFxcIlwiICsgdXJsICsgXCJcXFwiXCIpO1xuICAgICAgfVxuICB9O1xuICAvKipcbiAgICogQSBzZXQgb2YgcHJvdmlkZXJzIHRoYXQgcHJvdmlkZSBgUnVudGltZUNvbXBpbGVyYCBhbmQgaXRzIGRlcGVuZGVuY2llcyB0byB1c2UgZm9yXG4gICAqIHRlbXBsYXRlIGNvbXBpbGF0aW9uLlxuICAgKi9cbiAgdmFyIENPTVBJTEVSX1BST1ZJREVSUyA9IFtcbiAgICAgIHsgcHJvdmlkZTogUmVmbGVjdG9yLCB1c2VWYWx1ZTogcmVmbGVjdG9yIH0sXG4gICAgICB7IHByb3ZpZGU6IFJlZmxlY3RvclJlYWRlciwgdXNlRXhpc3Rpbmc6IFJlZmxlY3RvciB9LFxuICAgICAgeyBwcm92aWRlOiBSZXNvdXJjZUxvYWRlciwgdXNlVmFsdWU6IF9OT19SRVNPVVJDRV9MT0FERVIgfSxcbiAgICAgIENvbnNvbGUsXG4gICAgICBMZXhlcixcbiAgICAgIFBhcnNlcixcbiAgICAgIEh0bWxQYXJzZXIsXG4gICAgICB7XG4gICAgICAgICAgcHJvdmlkZTogSTE4Tkh0bWxQYXJzZXIsXG4gICAgICAgICAgdXNlRmFjdG9yeTogZnVuY3Rpb24gKHBhcnNlciwgdHJhbnNsYXRpb25zLCBmb3JtYXQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBJMThOSHRtbFBhcnNlcihwYXJzZXIsIHRyYW5zbGF0aW9ucywgZm9ybWF0KTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGRlcHM6IFtcbiAgICAgICAgICAgICAgSHRtbFBhcnNlcixcbiAgICAgICAgICAgICAgW25ldyBfYW5ndWxhcl9jb3JlLk9wdGlvbmFsKCksIG5ldyBfYW5ndWxhcl9jb3JlLkluamVjdChfYW5ndWxhcl9jb3JlLlRSQU5TTEFUSU9OUyldLFxuICAgICAgICAgICAgICBbbmV3IF9hbmd1bGFyX2NvcmUuT3B0aW9uYWwoKSwgbmV3IF9hbmd1bGFyX2NvcmUuSW5qZWN0KF9hbmd1bGFyX2NvcmUuVFJBTlNMQVRJT05TX0ZPUk1BVCldLFxuICAgICAgICAgIF1cbiAgICAgIH0sXG4gICAgICBUZW1wbGF0ZVBhcnNlcixcbiAgICAgIERpcmVjdGl2ZU5vcm1hbGl6ZXIsXG4gICAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlcixcbiAgICAgIERFRkFVTFRfUEFDS0FHRV9VUkxfUFJPVklERVIsXG4gICAgICBTdHlsZUNvbXBpbGVyLFxuICAgICAgVmlld0NvbXBpbGVyLFxuICAgICAgTmdNb2R1bGVDb21waWxlcixcbiAgICAgIERpcmVjdGl2ZVdyYXBwZXJDb21waWxlcixcbiAgICAgIHsgcHJvdmlkZTogQ29tcGlsZXJDb25maWcsIHVzZVZhbHVlOiBuZXcgQ29tcGlsZXJDb25maWcoKSB9LFxuICAgICAgUnVudGltZUNvbXBpbGVyLFxuICAgICAgeyBwcm92aWRlOiBfYW5ndWxhcl9jb3JlLkNvbXBpbGVyLCB1c2VFeGlzdGluZzogUnVudGltZUNvbXBpbGVyIH0sXG4gICAgICBEb21FbGVtZW50U2NoZW1hUmVnaXN0cnksXG4gICAgICB7IHByb3ZpZGU6IEVsZW1lbnRTY2hlbWFSZWdpc3RyeSwgdXNlRXhpc3Rpbmc6IERvbUVsZW1lbnRTY2hlbWFSZWdpc3RyeSB9LFxuICAgICAgVXJsUmVzb2x2ZXIsXG4gICAgICBEaXJlY3RpdmVSZXNvbHZlcixcbiAgICAgIFBpcGVSZXNvbHZlcixcbiAgICAgIE5nTW9kdWxlUmVzb2x2ZXJcbiAgXTtcbiAgdmFyIFJ1bnRpbWVDb21waWxlckZhY3RvcnkgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gUnVudGltZUNvbXBpbGVyRmFjdG9yeShkZWZhdWx0T3B0aW9ucykge1xuICAgICAgICAgIHRoaXMuX2RlZmF1bHRPcHRpb25zID0gW3tcbiAgICAgICAgICAgICAgICAgIHVzZURlYnVnOiBfYW5ndWxhcl9jb3JlLmlzRGV2TW9kZSgpLFxuICAgICAgICAgICAgICAgICAgdXNlSml0OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgZGVmYXVsdEVuY2Fwc3VsYXRpb246IF9hbmd1bGFyX2NvcmUuVmlld0VuY2Fwc3VsYXRpb24uRW11bGF0ZWRcbiAgICAgICAgICAgICAgfV0uY29uY2F0KGRlZmF1bHRPcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIFJ1bnRpbWVDb21waWxlckZhY3RvcnkucHJvdG90eXBlLmNyZWF0ZUNvbXBpbGVyID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSBbXTsgfVxuICAgICAgICAgIHZhciBtZXJnZWRPcHRpb25zID0gX21lcmdlT3B0aW9ucyh0aGlzLl9kZWZhdWx0T3B0aW9ucy5jb25jYXQob3B0aW9ucykpO1xuICAgICAgICAgIHZhciBpbmplY3RvciA9IF9hbmd1bGFyX2NvcmUuUmVmbGVjdGl2ZUluamVjdG9yLnJlc29sdmVBbmRDcmVhdGUoW1xuICAgICAgICAgICAgICBDT01QSUxFUl9QUk9WSURFUlMsIHtcbiAgICAgICAgICAgICAgICAgIHByb3ZpZGU6IENvbXBpbGVyQ29uZmlnLFxuICAgICAgICAgICAgICAgICAgdXNlRmFjdG9yeTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ29tcGlsZXJDb25maWcoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBsZXQgZXhwbGljaXQgdmFsdWVzIGZyb20gdGhlIGNvbXBpbGVyIG9wdGlvbnMgb3ZlcndyaXRlIG9wdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZnJvbSB0aGUgYXBwIHByb3ZpZGVycy4gRS5nLiBpbXBvcnRhbnQgZm9yIHRoZSB0ZXN0aW5nIHBsYXRmb3JtLlxuICAgICAgICAgICAgICAgICAgICAgICAgICBnZW5EZWJ1Z0luZm86IG1lcmdlZE9wdGlvbnMudXNlRGVidWcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxldCBleHBsaWNpdCB2YWx1ZXMgZnJvbSB0aGUgY29tcGlsZXIgb3B0aW9ucyBvdmVyd3JpdGUgb3B0aW9uc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmcm9tIHRoZSBhcHAgcHJvdmlkZXJzXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHVzZUppdDogbWVyZ2VkT3B0aW9ucy51c2VKaXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxldCBleHBsaWNpdCB2YWx1ZXMgZnJvbSB0aGUgY29tcGlsZXIgb3B0aW9ucyBvdmVyd3JpdGUgb3B0aW9uc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmcm9tIHRoZSBhcHAgcHJvdmlkZXJzXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRFbmNhcHN1bGF0aW9uOiBtZXJnZWRPcHRpb25zLmRlZmF1bHRFbmNhcHN1bGF0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dCaW5kaW5nVXBkYXRlOiBtZXJnZWRPcHRpb25zLnVzZURlYnVnXG4gICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgZGVwczogW11cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgbWVyZ2VkT3B0aW9ucy5wcm92aWRlcnNcbiAgICAgICAgICBdKTtcbiAgICAgICAgICByZXR1cm4gaW5qZWN0b3IuZ2V0KF9hbmd1bGFyX2NvcmUuQ29tcGlsZXIpO1xuICAgICAgfTtcbiAgICAgIFJ1bnRpbWVDb21waWxlckZhY3RvcnkuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0YWJsZSB9LFxuICAgICAgXTtcbiAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgUnVudGltZUNvbXBpbGVyRmFjdG9yeS5jdG9yUGFyYW1ldGVycyA9IFtcbiAgICAgICAgICB7IHR5cGU6IEFycmF5LCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdCwgYXJnczogW19hbmd1bGFyX2NvcmUuQ09NUElMRVJfT1BUSU9OUyxdIH0sXSB9LFxuICAgICAgXTtcbiAgICAgIHJldHVybiBSdW50aW1lQ29tcGlsZXJGYWN0b3J5O1xuICB9KCkpO1xuICBmdW5jdGlvbiBfaW5pdFJlZmxlY3RvcigpIHtcbiAgICAgIHJlZmxlY3Rvci5yZWZsZWN0aW9uQ2FwYWJpbGl0aWVzID0gbmV3IFJlZmxlY3Rpb25DYXBhYmlsaXRpZXMoKTtcbiAgfVxuICAvKipcbiAgICogQSBwbGF0Zm9ybSB0aGF0IGluY2x1ZGVkIGNvcmVQbGF0Zm9ybSBhbmQgdGhlIGNvbXBpbGVyLlxuICAgKlxuICAgKiBAZXhwZXJpbWVudGFsXG4gICAqL1xuICB2YXIgcGxhdGZvcm1Db3JlRHluYW1pYyA9IF9hbmd1bGFyX2NvcmUuY3JlYXRlUGxhdGZvcm1GYWN0b3J5KF9hbmd1bGFyX2NvcmUucGxhdGZvcm1Db3JlLCAnY29yZUR5bmFtaWMnLCBbXG4gICAgICB7IHByb3ZpZGU6IF9hbmd1bGFyX2NvcmUuQ09NUElMRVJfT1BUSU9OUywgdXNlVmFsdWU6IHt9LCBtdWx0aTogdHJ1ZSB9LFxuICAgICAgeyBwcm92aWRlOiBfYW5ndWxhcl9jb3JlLkNvbXBpbGVyRmFjdG9yeSwgdXNlQ2xhc3M6IFJ1bnRpbWVDb21waWxlckZhY3RvcnkgfSxcbiAgICAgIHsgcHJvdmlkZTogX2FuZ3VsYXJfY29yZS5QTEFURk9STV9JTklUSUFMSVpFUiwgdXNlVmFsdWU6IF9pbml0UmVmbGVjdG9yLCBtdWx0aTogdHJ1ZSB9LFxuICBdKTtcbiAgZnVuY3Rpb24gX21lcmdlT3B0aW9ucyhvcHRpb25zQXJyKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAgIHVzZURlYnVnOiBfbGFzdERlZmluZWQob3B0aW9uc0Fyci5tYXAoZnVuY3Rpb24gKG9wdGlvbnMpIHsgcmV0dXJuIG9wdGlvbnMudXNlRGVidWc7IH0pKSxcbiAgICAgICAgICB1c2VKaXQ6IF9sYXN0RGVmaW5lZChvcHRpb25zQXJyLm1hcChmdW5jdGlvbiAob3B0aW9ucykgeyByZXR1cm4gb3B0aW9ucy51c2VKaXQ7IH0pKSxcbiAgICAgICAgICBkZWZhdWx0RW5jYXBzdWxhdGlvbjogX2xhc3REZWZpbmVkKG9wdGlvbnNBcnIubWFwKGZ1bmN0aW9uIChvcHRpb25zKSB7IHJldHVybiBvcHRpb25zLmRlZmF1bHRFbmNhcHN1bGF0aW9uOyB9KSksXG4gICAgICAgICAgcHJvdmlkZXJzOiBfbWVyZ2VBcnJheXMob3B0aW9uc0Fyci5tYXAoZnVuY3Rpb24gKG9wdGlvbnMpIHsgcmV0dXJuIG9wdGlvbnMucHJvdmlkZXJzOyB9KSlcbiAgICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gX2xhc3REZWZpbmVkKGFyZ3MpIHtcbiAgICAgIGZvciAodmFyIGkgPSBhcmdzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgaWYgKGFyZ3NbaV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICByZXR1cm4gYXJnc1tpXTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGZ1bmN0aW9uIF9tZXJnZUFycmF5cyhwYXJ0cykge1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgcGFydHMuZm9yRWFjaChmdW5jdGlvbiAocGFydCkgeyByZXR1cm4gcGFydCAmJiByZXN1bHQucHVzaC5hcHBseShyZXN1bHQsIHBhcnQpOyB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQGxpY2Vuc2VcbiAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAqXG4gICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICovXG4gIC8vIGFzc2V0OjxwYWNrYWdlLW5hbWU+LzxyZWFsbT4vPHBhdGgtdG8tbW9kdWxlPlxuICB2YXIgX0FTU0VUX1VSTF9SRSA9IC9hc3NldDooW15cXC9dKylcXC8oW15cXC9dKylcXC8oLispLztcbiAgLyoqXG4gICAqIEludGVyZmFjZSB0aGF0IGRlZmluZXMgaG93IGltcG9ydCBzdGF0ZW1lbnRzIHNob3VsZCBiZSBnZW5lcmF0ZWQuXG4gICAqL1xuICB2YXIgSW1wb3J0R2VuZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIEltcG9ydEdlbmVyYXRvcigpIHtcbiAgICAgIH1cbiAgICAgIEltcG9ydEdlbmVyYXRvci5wYXJzZUFzc2V0VXJsID0gZnVuY3Rpb24gKHVybCkgeyByZXR1cm4gQXNzZXRVcmwucGFyc2UodXJsKTsgfTtcbiAgICAgIHJldHVybiBJbXBvcnRHZW5lcmF0b3I7XG4gIH0oKSk7XG4gIHZhciBBc3NldFVybCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBBc3NldFVybChwYWNrYWdlTmFtZSwgZmlyc3RMZXZlbERpciwgbW9kdWxlUGF0aCkge1xuICAgICAgICAgIHRoaXMucGFja2FnZU5hbWUgPSBwYWNrYWdlTmFtZTtcbiAgICAgICAgICB0aGlzLmZpcnN0TGV2ZWxEaXIgPSBmaXJzdExldmVsRGlyO1xuICAgICAgICAgIHRoaXMubW9kdWxlUGF0aCA9IG1vZHVsZVBhdGg7XG4gICAgICB9XG4gICAgICBBc3NldFVybC5wYXJzZSA9IGZ1bmN0aW9uICh1cmwsIGFsbG93Tm9uTWF0Y2hpbmcpIHtcbiAgICAgICAgICBpZiAoYWxsb3dOb25NYXRjaGluZyA9PT0gdm9pZCAwKSB7IGFsbG93Tm9uTWF0Y2hpbmcgPSB0cnVlOyB9XG4gICAgICAgICAgdmFyIG1hdGNoID0gdXJsLm1hdGNoKF9BU1NFVF9VUkxfUkUpO1xuICAgICAgICAgIGlmIChtYXRjaCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXR1cm4gbmV3IEFzc2V0VXJsKG1hdGNoWzFdLCBtYXRjaFsyXSwgbWF0Y2hbM10pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYWxsb3dOb25NYXRjaGluZykge1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVXJsIFwiICsgdXJsICsgXCIgaXMgbm90IGEgdmFsaWQgYXNzZXQ6IHVybFwiKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gQXNzZXRVcmw7XG4gIH0oKSk7XG5cbiAgZXhwb3J0cy5URU1QTEFURV9UUkFOU0ZPUk1TID0gVEVNUExBVEVfVFJBTlNGT1JNUztcbiAgZXhwb3J0cy5Db21waWxlckNvbmZpZyA9IENvbXBpbGVyQ29uZmlnO1xuICBleHBvcnRzLlJlbmRlclR5cGVzID0gUmVuZGVyVHlwZXM7XG4gIGV4cG9ydHMuUnVudGltZUNvbXBpbGVyID0gUnVudGltZUNvbXBpbGVyO1xuICBleHBvcnRzLkRpcmVjdGl2ZVJlc29sdmVyID0gRGlyZWN0aXZlUmVzb2x2ZXI7XG4gIGV4cG9ydHMuUGlwZVJlc29sdmVyID0gUGlwZVJlc29sdmVyO1xuICBleHBvcnRzLk5nTW9kdWxlUmVzb2x2ZXIgPSBOZ01vZHVsZVJlc29sdmVyO1xuICBleHBvcnRzLkRFRkFVTFRfSU5URVJQT0xBVElPTl9DT05GSUcgPSBERUZBVUxUX0lOVEVSUE9MQVRJT05fQ09ORklHO1xuICBleHBvcnRzLkludGVycG9sYXRpb25Db25maWcgPSBJbnRlcnBvbGF0aW9uQ29uZmlnO1xuICBleHBvcnRzLk5nTW9kdWxlQ29tcGlsZXIgPSBOZ01vZHVsZUNvbXBpbGVyO1xuICBleHBvcnRzLkRpcmVjdGl2ZVdyYXBwZXJDb21waWxlciA9IERpcmVjdGl2ZVdyYXBwZXJDb21waWxlcjtcbiAgZXhwb3J0cy5WaWV3Q29tcGlsZXIgPSBWaWV3Q29tcGlsZXI7XG4gIGV4cG9ydHMuVGV4dEFzdCA9IFRleHRBc3Q7XG4gIGV4cG9ydHMuQm91bmRUZXh0QXN0ID0gQm91bmRUZXh0QXN0O1xuICBleHBvcnRzLkF0dHJBc3QgPSBBdHRyQXN0O1xuICBleHBvcnRzLkJvdW5kRWxlbWVudFByb3BlcnR5QXN0ID0gQm91bmRFbGVtZW50UHJvcGVydHlBc3Q7XG4gIGV4cG9ydHMuQm91bmRFdmVudEFzdCA9IEJvdW5kRXZlbnRBc3Q7XG4gIGV4cG9ydHMuUmVmZXJlbmNlQXN0ID0gUmVmZXJlbmNlQXN0O1xuICBleHBvcnRzLlZhcmlhYmxlQXN0ID0gVmFyaWFibGVBc3Q7XG4gIGV4cG9ydHMuRWxlbWVudEFzdCA9IEVsZW1lbnRBc3Q7XG4gIGV4cG9ydHMuRW1iZWRkZWRUZW1wbGF0ZUFzdCA9IEVtYmVkZGVkVGVtcGxhdGVBc3Q7XG4gIGV4cG9ydHMuQm91bmREaXJlY3RpdmVQcm9wZXJ0eUFzdCA9IEJvdW5kRGlyZWN0aXZlUHJvcGVydHlBc3Q7XG4gIGV4cG9ydHMuRGlyZWN0aXZlQXN0ID0gRGlyZWN0aXZlQXN0O1xuICBleHBvcnRzLlByb3ZpZGVyQXN0ID0gUHJvdmlkZXJBc3Q7XG4gIGV4cG9ydHMuTmdDb250ZW50QXN0ID0gTmdDb250ZW50QXN0O1xuICBleHBvcnRzLnRlbXBsYXRlVmlzaXRBbGwgPSB0ZW1wbGF0ZVZpc2l0QWxsO1xuICBleHBvcnRzLkNvbXBpbGVNZXRhZGF0YVdpdGhJZGVudGlmaWVyID0gQ29tcGlsZU1ldGFkYXRhV2l0aElkZW50aWZpZXI7XG4gIGV4cG9ydHMuQ29tcGlsZUFuaW1hdGlvbkVudHJ5TWV0YWRhdGEgPSBDb21waWxlQW5pbWF0aW9uRW50cnlNZXRhZGF0YTtcbiAgZXhwb3J0cy5Db21waWxlQW5pbWF0aW9uU3RhdGVNZXRhZGF0YSA9IENvbXBpbGVBbmltYXRpb25TdGF0ZU1ldGFkYXRhO1xuICBleHBvcnRzLkNvbXBpbGVBbmltYXRpb25TdGF0ZURlY2xhcmF0aW9uTWV0YWRhdGEgPSBDb21waWxlQW5pbWF0aW9uU3RhdGVEZWNsYXJhdGlvbk1ldGFkYXRhO1xuICBleHBvcnRzLkNvbXBpbGVBbmltYXRpb25TdGF0ZVRyYW5zaXRpb25NZXRhZGF0YSA9IENvbXBpbGVBbmltYXRpb25TdGF0ZVRyYW5zaXRpb25NZXRhZGF0YTtcbiAgZXhwb3J0cy5Db21waWxlQW5pbWF0aW9uTWV0YWRhdGEgPSBDb21waWxlQW5pbWF0aW9uTWV0YWRhdGE7XG4gIGV4cG9ydHMuQ29tcGlsZUFuaW1hdGlvbktleWZyYW1lc1NlcXVlbmNlTWV0YWRhdGEgPSBDb21waWxlQW5pbWF0aW9uS2V5ZnJhbWVzU2VxdWVuY2VNZXRhZGF0YTtcbiAgZXhwb3J0cy5Db21waWxlQW5pbWF0aW9uU3R5bGVNZXRhZGF0YSA9IENvbXBpbGVBbmltYXRpb25TdHlsZU1ldGFkYXRhO1xuICBleHBvcnRzLkNvbXBpbGVBbmltYXRpb25BbmltYXRlTWV0YWRhdGEgPSBDb21waWxlQW5pbWF0aW9uQW5pbWF0ZU1ldGFkYXRhO1xuICBleHBvcnRzLkNvbXBpbGVBbmltYXRpb25XaXRoU3RlcHNNZXRhZGF0YSA9IENvbXBpbGVBbmltYXRpb25XaXRoU3RlcHNNZXRhZGF0YTtcbiAgZXhwb3J0cy5Db21waWxlQW5pbWF0aW9uU2VxdWVuY2VNZXRhZGF0YSA9IENvbXBpbGVBbmltYXRpb25TZXF1ZW5jZU1ldGFkYXRhO1xuICBleHBvcnRzLkNvbXBpbGVBbmltYXRpb25Hcm91cE1ldGFkYXRhID0gQ29tcGlsZUFuaW1hdGlvbkdyb3VwTWV0YWRhdGE7XG4gIGV4cG9ydHMuQ29tcGlsZUlkZW50aWZpZXJNZXRhZGF0YSA9IENvbXBpbGVJZGVudGlmaWVyTWV0YWRhdGE7XG4gIGV4cG9ydHMuQ29tcGlsZURpRGVwZW5kZW5jeU1ldGFkYXRhID0gQ29tcGlsZURpRGVwZW5kZW5jeU1ldGFkYXRhO1xuICBleHBvcnRzLkNvbXBpbGVQcm92aWRlck1ldGFkYXRhID0gQ29tcGlsZVByb3ZpZGVyTWV0YWRhdGE7XG4gIGV4cG9ydHMuQ29tcGlsZUZhY3RvcnlNZXRhZGF0YSA9IENvbXBpbGVGYWN0b3J5TWV0YWRhdGE7XG4gIGV4cG9ydHMuQ29tcGlsZVRva2VuTWV0YWRhdGEgPSBDb21waWxlVG9rZW5NZXRhZGF0YTtcbiAgZXhwb3J0cy5Db21waWxlVHlwZU1ldGFkYXRhID0gQ29tcGlsZVR5cGVNZXRhZGF0YTtcbiAgZXhwb3J0cy5Db21waWxlUXVlcnlNZXRhZGF0YSA9IENvbXBpbGVRdWVyeU1ldGFkYXRhO1xuICBleHBvcnRzLkNvbXBpbGVTdHlsZXNoZWV0TWV0YWRhdGEgPSBDb21waWxlU3R5bGVzaGVldE1ldGFkYXRhO1xuICBleHBvcnRzLkNvbXBpbGVUZW1wbGF0ZU1ldGFkYXRhID0gQ29tcGlsZVRlbXBsYXRlTWV0YWRhdGE7XG4gIGV4cG9ydHMuQ29tcGlsZURpcmVjdGl2ZU1ldGFkYXRhID0gQ29tcGlsZURpcmVjdGl2ZU1ldGFkYXRhO1xuICBleHBvcnRzLmNyZWF0ZUhvc3RDb21wb25lbnRNZXRhID0gY3JlYXRlSG9zdENvbXBvbmVudE1ldGE7XG4gIGV4cG9ydHMuQ29tcGlsZVBpcGVNZXRhZGF0YSA9IENvbXBpbGVQaXBlTWV0YWRhdGE7XG4gIGV4cG9ydHMuQ29tcGlsZU5nTW9kdWxlTWV0YWRhdGEgPSBDb21waWxlTmdNb2R1bGVNZXRhZGF0YTtcbiAgZXhwb3J0cy5UcmFuc2l0aXZlQ29tcGlsZU5nTW9kdWxlTWV0YWRhdGEgPSBUcmFuc2l0aXZlQ29tcGlsZU5nTW9kdWxlTWV0YWRhdGE7XG4gIGV4cG9ydHMucmVtb3ZlSWRlbnRpZmllckR1cGxpY2F0ZXMgPSByZW1vdmVJZGVudGlmaWVyRHVwbGljYXRlcztcbiAgZXhwb3J0cy5pc1N0YXRpY1N5bWJvbCA9IGlzU3RhdGljU3ltYm9sO1xuICBleHBvcnRzLlByb3ZpZGVyTWV0YSA9IFByb3ZpZGVyTWV0YTtcbiAgZXhwb3J0cy5Tb3VyY2VNb2R1bGUgPSBTb3VyY2VNb2R1bGU7XG4gIGV4cG9ydHMuYW5hbHl6ZU5nTW9kdWxlcyA9IGFuYWx5emVOZ01vZHVsZXM7XG4gIGV4cG9ydHMuT2ZmbGluZUNvbXBpbGVyID0gT2ZmbGluZUNvbXBpbGVyO1xuICBleHBvcnRzLmNyZWF0ZVVybFJlc29sdmVyV2l0aG91dFBhY2thZ2VQcmVmaXggPSBjcmVhdGVVcmxSZXNvbHZlcldpdGhvdXRQYWNrYWdlUHJlZml4O1xuICBleHBvcnRzLmNyZWF0ZU9mZmxpbmVDb21waWxlVXJsUmVzb2x2ZXIgPSBjcmVhdGVPZmZsaW5lQ29tcGlsZVVybFJlc29sdmVyO1xuICBleHBvcnRzLkRFRkFVTFRfUEFDS0FHRV9VUkxfUFJPVklERVIgPSBERUZBVUxUX1BBQ0tBR0VfVVJMX1BST1ZJREVSO1xuICBleHBvcnRzLlVybFJlc29sdmVyID0gVXJsUmVzb2x2ZXI7XG4gIGV4cG9ydHMuZ2V0VXJsU2NoZW1lID0gZ2V0VXJsU2NoZW1lO1xuICBleHBvcnRzLlJlc291cmNlTG9hZGVyID0gUmVzb3VyY2VMb2FkZXI7XG4gIGV4cG9ydHMuQ09NUElMRVJfUFJPVklERVJTID0gQ09NUElMRVJfUFJPVklERVJTO1xuICBleHBvcnRzLlJ1bnRpbWVDb21waWxlckZhY3RvcnkgPSBSdW50aW1lQ29tcGlsZXJGYWN0b3J5O1xuICBleHBvcnRzLnBsYXRmb3JtQ29yZUR5bmFtaWMgPSBwbGF0Zm9ybUNvcmVEeW5hbWljO1xuICBleHBvcnRzLkVsZW1lbnRTY2hlbWFSZWdpc3RyeSA9IEVsZW1lbnRTY2hlbWFSZWdpc3RyeTtcbiAgZXhwb3J0cy5JMThOSHRtbFBhcnNlciA9IEkxOE5IdG1sUGFyc2VyO1xuICBleHBvcnRzLk1lc3NhZ2VCdW5kbGUgPSBNZXNzYWdlQnVuZGxlO1xuICBleHBvcnRzLlhsaWZmID0gWGxpZmY7XG4gIGV4cG9ydHMuWG1iID0gWG1iO1xuICBleHBvcnRzLlh0YiA9IFh0YjtcbiAgZXhwb3J0cy5EaXJlY3RpdmVOb3JtYWxpemVyID0gRGlyZWN0aXZlTm9ybWFsaXplcjtcbiAgZXhwb3J0cy5MZXhlciA9IExleGVyO1xuICBleHBvcnRzLlRva2VuID0gVG9rZW47XG4gIGV4cG9ydHMuRU9GID0gRU9GO1xuICBleHBvcnRzLmlzSWRlbnRpZmllciA9IGlzSWRlbnRpZmllcjtcbiAgZXhwb3J0cy5pc1F1b3RlID0gaXNRdW90ZTtcbiAgZXhwb3J0cy5TcGxpdEludGVycG9sYXRpb24gPSBTcGxpdEludGVycG9sYXRpb247XG4gIGV4cG9ydHMuVGVtcGxhdGVCaW5kaW5nUGFyc2VSZXN1bHQgPSBUZW1wbGF0ZUJpbmRpbmdQYXJzZVJlc3VsdDtcbiAgZXhwb3J0cy5QYXJzZXIgPSBQYXJzZXI7XG4gIGV4cG9ydHMuX1BhcnNlQVNUID0gX1BhcnNlQVNUO1xuICBleHBvcnRzLkNvbXBpbGVNZXRhZGF0YVJlc29sdmVyID0gQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXI7XG4gIGV4cG9ydHMuSHRtbFBhcnNlciA9IEh0bWxQYXJzZXI7XG4gIGV4cG9ydHMuUGFyc2VUcmVlUmVzdWx0ID0gUGFyc2VUcmVlUmVzdWx0O1xuICBleHBvcnRzLlRyZWVFcnJvciA9IFRyZWVFcnJvcjtcbiAgZXhwb3J0cy5JbXBvcnRHZW5lcmF0b3IgPSBJbXBvcnRHZW5lcmF0b3I7XG4gIGV4cG9ydHMuQXNzZXRVcmwgPSBBc3NldFVybDtcbiAgZXhwb3J0cy5kZWJ1Z091dHB1dEFzdEFzVHlwZVNjcmlwdCA9IGRlYnVnT3V0cHV0QXN0QXNUeXBlU2NyaXB0O1xuICBleHBvcnRzLlR5cGVTY3JpcHRFbWl0dGVyID0gVHlwZVNjcmlwdEVtaXR0ZXI7XG4gIGV4cG9ydHMuUGFyc2VMb2NhdGlvbiA9IFBhcnNlTG9jYXRpb247XG4gIGV4cG9ydHMuUGFyc2VTb3VyY2VGaWxlID0gUGFyc2VTb3VyY2VGaWxlO1xuICBleHBvcnRzLlBhcnNlU291cmNlU3BhbiA9IFBhcnNlU291cmNlU3BhbjtcbiAgZXhwb3J0cy5QYXJzZUVycm9yID0gUGFyc2VFcnJvcjtcbiAgZXhwb3J0cy5Eb21FbGVtZW50U2NoZW1hUmVnaXN0cnkgPSBEb21FbGVtZW50U2NoZW1hUmVnaXN0cnk7XG4gIGV4cG9ydHMuQ3NzU2VsZWN0b3IgPSBDc3NTZWxlY3RvcjtcbiAgZXhwb3J0cy5TZWxlY3Rvck1hdGNoZXIgPSBTZWxlY3Rvck1hdGNoZXI7XG4gIGV4cG9ydHMuU2VsZWN0b3JMaXN0Q29udGV4dCA9IFNlbGVjdG9yTGlzdENvbnRleHQ7XG4gIGV4cG9ydHMuU2VsZWN0b3JDb250ZXh0ID0gU2VsZWN0b3JDb250ZXh0O1xuICBleHBvcnRzLlN0eWxlc0NvbXBpbGVEZXBlbmRlbmN5ID0gU3R5bGVzQ29tcGlsZURlcGVuZGVuY3k7XG4gIGV4cG9ydHMuU3R5bGVzQ29tcGlsZVJlc3VsdCA9IFN0eWxlc0NvbXBpbGVSZXN1bHQ7XG4gIGV4cG9ydHMuQ29tcGlsZWRTdHlsZXNoZWV0ID0gQ29tcGlsZWRTdHlsZXNoZWV0O1xuICBleHBvcnRzLlN0eWxlQ29tcGlsZXIgPSBTdHlsZUNvbXBpbGVyO1xuICBleHBvcnRzLlRlbXBsYXRlUGFyc2VFcnJvciA9IFRlbXBsYXRlUGFyc2VFcnJvcjtcbiAgZXhwb3J0cy5UZW1wbGF0ZVBhcnNlUmVzdWx0ID0gVGVtcGxhdGVQYXJzZVJlc3VsdDtcbiAgZXhwb3J0cy5UZW1wbGF0ZVBhcnNlciA9IFRlbXBsYXRlUGFyc2VyO1xuICBleHBvcnRzLnNwbGl0Q2xhc3NlcyA9IHNwbGl0Q2xhc3NlcztcblxufSkpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L0Bhbmd1bGFyL2NvbXBpbGVyL2J1bmRsZXMvY29tcGlsZXIudW1kLmpzXG4vLyBtb2R1bGUgaWQgPSAyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQGxpY2Vuc2UgQW5ndWxhciB2Mi4xLjJcbiAqIChjKSAyMDEwLTIwMTYgR29vZ2xlLCBJbmMuIGh0dHBzOi8vYW5ndWxhci5pby9cbiAqIExpY2Vuc2U6IE1JVFxuICovXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cywgcmVxdWlyZSgncnhqcy9TdWJqZWN0JyksIHJlcXVpcmUoJ3J4anMvT2JzZXJ2YWJsZScpKSA6XG4gICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cycsICdyeGpzL1N1YmplY3QnLCAncnhqcy9PYnNlcnZhYmxlJ10sIGZhY3RvcnkpIDpcbiAgICAoZmFjdG9yeSgoZ2xvYmFsLm5nID0gZ2xvYmFsLm5nIHx8IHt9LCBnbG9iYWwubmcuY29yZSA9IGdsb2JhbC5uZy5jb3JlIHx8IHt9KSxnbG9iYWwuUngsZ2xvYmFsLlJ4KSk7XG59KHRoaXMsIGZ1bmN0aW9uIChleHBvcnRzLHJ4anNfU3ViamVjdCxyeGpzX09ic2VydmFibGUpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIHZhciBnbG9iYWxTY29wZTtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBXb3JrZXJHbG9iYWxTY29wZSAhPT0gJ3VuZGVmaW5lZCcgJiYgc2VsZiBpbnN0YW5jZW9mIFdvcmtlckdsb2JhbFNjb3BlKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBSZXBsYWNlIGFueSB3aXRoIFdvcmtlckdsb2JhbFNjb3BlIGZyb20gbGliLndlYndvcmtlci5kLnRzICMzNDkyXG4gICAgICAgICAgICBnbG9iYWxTY29wZSA9IHNlbGY7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBnbG9iYWxTY29wZSA9IGdsb2JhbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZ2xvYmFsU2NvcGUgPSB3aW5kb3c7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNjaGVkdWxlTWljcm9UYXNrKGZuKSB7XG4gICAgICAgIFpvbmUuY3VycmVudC5zY2hlZHVsZU1pY3JvVGFzaygnc2NoZWR1bGVNaWNyb3Rhc2snLCBmbik7XG4gICAgfVxuICAgIC8vIE5lZWQgdG8gZGVjbGFyZSBhIG5ldyB2YXJpYWJsZSBmb3IgZ2xvYmFsIGhlcmUgc2luY2UgVHlwZVNjcmlwdFxuICAgIC8vIGV4cG9ydHMgdGhlIG9yaWdpbmFsIHZhbHVlIG9mIHRoZSBzeW1ib2wuXG4gICAgdmFyIGdsb2JhbCQxID0gZ2xvYmFsU2NvcGU7XG4gICAgZnVuY3Rpb24gZ2V0VHlwZU5hbWVGb3JEZWJ1Z2dpbmcodHlwZSkge1xuICAgICAgICByZXR1cm4gdHlwZVsnbmFtZSddIHx8IHR5cGVvZiB0eXBlO1xuICAgIH1cbiAgICAvLyBUT0RPOiByZW1vdmUgY2FsbHMgdG8gYXNzZXJ0IGluIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRcbiAgICAvLyBOb3RlOiBDYW4ndCBqdXN0IGV4cG9ydCB0aGlzIGFuZCBpbXBvcnQgaW4gaW4gb3RoZXIgZmlsZXNcbiAgICAvLyBhcyBgYXNzZXJ0YCBpcyBhIHJlc2VydmVkIGtleXdvcmQgaW4gRGFydFxuICAgIGdsb2JhbCQxLmFzc2VydCA9IGZ1bmN0aW9uIGFzc2VydChjb25kaXRpb24pIHtcbiAgICAgICAgLy8gVE9ETzogdG8gYmUgZml4ZWQgcHJvcGVybHkgdmlhICMyODMwLCBub29wIGZvciBub3dcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGlzUHJlc2VudChvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iaiAhPSBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc0JsYW5rKG9iaikge1xuICAgICAgICByZXR1cm4gb2JqID09IG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0cmluZ2lmeSh0b2tlbikge1xuICAgICAgICBpZiAodHlwZW9mIHRva2VuID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b2tlbiA9PT0gdW5kZWZpbmVkIHx8IHRva2VuID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gJycgKyB0b2tlbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9rZW4ub3ZlcnJpZGRlbk5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0b2tlbi5vdmVycmlkZGVuTmFtZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9rZW4ubmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRva2VuLm5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlcyA9IHRva2VuLnRvU3RyaW5nKCk7XG4gICAgICAgIHZhciBuZXdMaW5lSW5kZXggPSByZXMuaW5kZXhPZignXFxuJyk7XG4gICAgICAgIHJldHVybiBuZXdMaW5lSW5kZXggPT09IC0xID8gcmVzIDogcmVzLnN1YnN0cmluZygwLCBuZXdMaW5lSW5kZXgpO1xuICAgIH1cbiAgICAvLyBKUyBoYXMgTmFOICE9PSBOYU5cbiAgICBmdW5jdGlvbiBsb29zZUlkZW50aWNhbChhLCBiKSB7XG4gICAgICAgIHJldHVybiBhID09PSBiIHx8IHR5cGVvZiBhID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgYiA9PT0gJ251bWJlcicgJiYgaXNOYU4oYSkgJiYgaXNOYU4oYik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzSnNPYmplY3Qobykge1xuICAgICAgICByZXR1cm4gbyAhPT0gbnVsbCAmJiAodHlwZW9mIG8gPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIG8gPT09ICdvYmplY3QnKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHJpbnQob2JqKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKG9iaik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdhcm4ob2JqKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihvYmopO1xuICAgIH1cbiAgICB2YXIgX3N5bWJvbEl0ZXJhdG9yID0gbnVsbDtcbiAgICBmdW5jdGlvbiBnZXRTeW1ib2xJdGVyYXRvcigpIHtcbiAgICAgICAgaWYgKCFfc3ltYm9sSXRlcmF0b3IpIHtcbiAgICAgICAgICAgIGlmIChnbG9iYWxTY29wZS5TeW1ib2wgJiYgU3ltYm9sLml0ZXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgX3N5bWJvbEl0ZXJhdG9yID0gU3ltYm9sLml0ZXJhdG9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gZXM2LXNoaW0gc3BlY2lmaWMgbG9naWNcbiAgICAgICAgICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE1hcC5wcm90b3R5cGUpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleSAhPT0gJ2VudHJpZXMnICYmIGtleSAhPT0gJ3NpemUnICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBNYXAucHJvdG90eXBlW2tleV0gPT09IE1hcC5wcm90b3R5cGVbJ2VudHJpZXMnXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3N5bWJvbEl0ZXJhdG9yID0ga2V5O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfc3ltYm9sSXRlcmF0b3I7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzUHJpbWl0aXZlKG9iaikge1xuICAgICAgICByZXR1cm4gIWlzSnNPYmplY3Qob2JqKTtcbiAgICB9XG5cbiAgICB2YXIgX25leHRDbGFzc0lkID0gMDtcbiAgICB2YXIgUmVmbGVjdCA9IGdsb2JhbCQxLlJlZmxlY3Q7XG4gICAgZnVuY3Rpb24gZXh0cmFjdEFubm90YXRpb24oYW5ub3RhdGlvbikge1xuICAgICAgICBpZiAodHlwZW9mIGFubm90YXRpb24gPT09ICdmdW5jdGlvbicgJiYgYW5ub3RhdGlvbi5oYXNPd25Qcm9wZXJ0eSgnYW5ub3RhdGlvbicpKSB7XG4gICAgICAgICAgICAvLyBpdCBpcyBhIGRlY29yYXRvciwgZXh0cmFjdCBhbm5vdGF0aW9uXG4gICAgICAgICAgICBhbm5vdGF0aW9uID0gYW5ub3RhdGlvbi5hbm5vdGF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhbm5vdGF0aW9uO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhcHBseVBhcmFtcyhmbk9yQXJyYXksIGtleSkge1xuICAgICAgICBpZiAoZm5PckFycmF5ID09PSBPYmplY3QgfHwgZm5PckFycmF5ID09PSBTdHJpbmcgfHwgZm5PckFycmF5ID09PSBGdW5jdGlvbiB8fFxuICAgICAgICAgICAgZm5PckFycmF5ID09PSBOdW1iZXIgfHwgZm5PckFycmF5ID09PSBBcnJheSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCB1c2UgbmF0aXZlIFwiICsgc3RyaW5naWZ5KGZuT3JBcnJheSkgKyBcIiBhcyBjb25zdHJ1Y3RvclwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGZuT3JBcnJheSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIGZuT3JBcnJheTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShmbk9yQXJyYXkpKSB7XG4gICAgICAgICAgICB2YXIgYW5ub3RhdGlvbnMgPSBmbk9yQXJyYXk7XG4gICAgICAgICAgICB2YXIgYW5ub0xlbmd0aCA9IGFubm90YXRpb25zLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICB2YXIgZm4gPSBmbk9yQXJyYXlbYW5ub0xlbmd0aF07XG4gICAgICAgICAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTGFzdCBwb3NpdGlvbiBvZiBDbGFzcyBtZXRob2QgYXJyYXkgbXVzdCBiZSBGdW5jdGlvbiBpbiBrZXkgXCIgKyBrZXkgKyBcIiB3YXMgJ1wiICsgc3RyaW5naWZ5KGZuKSArIFwiJ1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhbm5vTGVuZ3RoICE9IGZuLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk51bWJlciBvZiBhbm5vdGF0aW9ucyAoXCIgKyBhbm5vTGVuZ3RoICsgXCIpIGRvZXMgbm90IG1hdGNoIG51bWJlciBvZiBhcmd1bWVudHMgKFwiICsgZm4ubGVuZ3RoICsgXCIpIGluIHRoZSBmdW5jdGlvbjogXCIgKyBzdHJpbmdpZnkoZm4pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBwYXJhbXNBbm5vdGF0aW9ucyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gYW5ub3RhdGlvbnMubGVuZ3RoIC0gMTsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFyYW1Bbm5vdGF0aW9ucyA9IFtdO1xuICAgICAgICAgICAgICAgIHBhcmFtc0Fubm90YXRpb25zLnB1c2gocGFyYW1Bbm5vdGF0aW9ucyk7XG4gICAgICAgICAgICAgICAgdmFyIGFubm90YXRpb24gPSBhbm5vdGF0aW9uc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhbm5vdGF0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGFubm90YXRpb24ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtQW5ub3RhdGlvbnMucHVzaChleHRyYWN0QW5ub3RhdGlvbihhbm5vdGF0aW9uW2pdKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGFubm90YXRpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1Bbm5vdGF0aW9ucy5wdXNoKGV4dHJhY3RBbm5vdGF0aW9uKGFubm90YXRpb24pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtQW5ub3RhdGlvbnMucHVzaChhbm5vdGF0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBSZWZsZWN0LmRlZmluZU1ldGFkYXRhKCdwYXJhbWV0ZXJzJywgcGFyYW1zQW5ub3RhdGlvbnMsIGZuKTtcbiAgICAgICAgICAgIHJldHVybiBmbjtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJPbmx5IEZ1bmN0aW9uIG9yIEFycmF5IGlzIHN1cHBvcnRlZCBpbiBDbGFzcyBkZWZpbml0aW9uIGZvciBrZXkgJ1wiICsga2V5ICsgXCInIGlzICdcIiArIHN0cmluZ2lmeShmbk9yQXJyYXkpICsgXCInXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm92aWRlcyBhIHdheSBmb3IgZXhwcmVzc2luZyBFUzYgY2xhc3NlcyB3aXRoIHBhcmFtZXRlciBhbm5vdGF0aW9ucyBpbiBFUzUuXG4gICAgICpcbiAgICAgKiAjIyBCYXNpYyBFeGFtcGxlXG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiB2YXIgR3JlZXRlciA9IG5nLkNsYXNzKHtcbiAgICAgKiAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICogICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICogICB9LFxuICAgICAqXG4gICAgICogICBncmVldDogZnVuY3Rpb24oKSB7XG4gICAgICogICAgIGFsZXJ0KCdIZWxsbyAnICsgdGhpcy5uYW1lICsgJyEnKTtcbiAgICAgKiAgIH1cbiAgICAgKiB9KTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIGlzIGVxdWl2YWxlbnQgdG8gRVM2OlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogY2xhc3MgR3JlZXRlciB7XG4gICAgICogICBjb25zdHJ1Y3RvcihuYW1lKSB7XG4gICAgICogICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICogICB9XG4gICAgICpcbiAgICAgKiAgIGdyZWV0KCkge1xuICAgICAqICAgICBhbGVydCgnSGVsbG8gJyArIHRoaXMubmFtZSArICchJyk7XG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogb3IgZXF1aXZhbGVudCB0byBFUzU6XG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiB2YXIgR3JlZXRlciA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICogICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEdyZWV0ZXIucHJvdG90eXBlLmdyZWV0ID0gZnVuY3Rpb24gKCkge1xuICAgICAqICAgYWxlcnQoJ0hlbGxvICcgKyB0aGlzLm5hbWUgKyAnIScpO1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqICMjIyBFeGFtcGxlIHdpdGggcGFyYW1ldGVyIGFubm90YXRpb25zXG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiB2YXIgTXlTZXJ2aWNlID0gbmcuQ2xhc3Moe1xuICAgICAqICAgY29uc3RydWN0b3I6IFtTdHJpbmcsIFtuZXcgT3B0aW9uYWwoKSwgU2VydmljZV0sIGZ1bmN0aW9uKG5hbWUsIG15U2VydmljZSkge1xuICAgICAqICAgICAuLi5cbiAgICAgKiAgIH1dXG4gICAgICogfSk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBpcyBlcXVpdmFsZW50IHRvIEVTNjpcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIGNsYXNzIE15U2VydmljZSB7XG4gICAgICogICBjb25zdHJ1Y3RvcihuYW1lOiBzdHJpbmcsIEBPcHRpb25hbCgpIG15U2VydmljZTogU2VydmljZSkge1xuICAgICAqICAgICAuLi5cbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZSB3aXRoIGluaGVyaXRhbmNlXG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiB2YXIgU2hhcGUgPSBuZy5DbGFzcyh7XG4gICAgICogICBjb25zdHJ1Y3RvcjogKGNvbG9yKSB7XG4gICAgICogICAgIHRoaXMuY29sb3IgPSBjb2xvcjtcbiAgICAgKiAgIH1cbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIHZhciBTcXVhcmUgPSBuZy5DbGFzcyh7XG4gICAgICogICBleHRlbmRzOiBTaGFwZSxcbiAgICAgKiAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbihjb2xvciwgc2l6ZSkge1xuICAgICAqICAgICBTaGFwZS5jYWxsKHRoaXMsIGNvbG9yKTtcbiAgICAgKiAgICAgdGhpcy5zaXplID0gc2l6ZTtcbiAgICAgKiAgIH1cbiAgICAgKiB9KTtcbiAgICAgKiBgYGBcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgZnVuY3Rpb24gQ2xhc3MoY2xzRGVmKSB7XG4gICAgICAgIHZhciBjb25zdHJ1Y3RvciA9IGFwcGx5UGFyYW1zKGNsc0RlZi5oYXNPd25Qcm9wZXJ0eSgnY29uc3RydWN0b3InKSA/IGNsc0RlZi5jb25zdHJ1Y3RvciA6IHVuZGVmaW5lZCwgJ2NvbnN0cnVjdG9yJyk7XG4gICAgICAgIHZhciBwcm90byA9IGNvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgICAgICAgaWYgKGNsc0RlZi5oYXNPd25Qcm9wZXJ0eSgnZXh0ZW5kcycpKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNsc0RlZi5leHRlbmRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgY29uc3RydWN0b3IucHJvdG90eXBlID0gcHJvdG8gPVxuICAgICAgICAgICAgICAgICAgICBPYmplY3QuY3JlYXRlKGNsc0RlZi5leHRlbmRzLnByb3RvdHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDbGFzcyBkZWZpbml0aW9uICdleHRlbmRzJyBwcm9wZXJ0eSBtdXN0IGJlIGEgY29uc3RydWN0b3IgZnVuY3Rpb24gd2FzOiBcIiArIHN0cmluZ2lmeShjbHNEZWYuZXh0ZW5kcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBjbHNEZWYpIHtcbiAgICAgICAgICAgIGlmIChrZXkgIT09ICdleHRlbmRzJyAmJiBrZXkgIT09ICdwcm90b3R5cGUnICYmIGNsc0RlZi5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgcHJvdG9ba2V5XSA9IGFwcGx5UGFyYW1zKGNsc0RlZltrZXldLCBrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzICYmIHRoaXMuYW5ub3RhdGlvbnMgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgUmVmbGVjdC5kZWZpbmVNZXRhZGF0YSgnYW5ub3RhdGlvbnMnLCB0aGlzLmFubm90YXRpb25zLCBjb25zdHJ1Y3Rvcik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvbnN0cnVjdG9yTmFtZSA9IGNvbnN0cnVjdG9yWyduYW1lJ107XG4gICAgICAgIGlmICghY29uc3RydWN0b3JOYW1lIHx8IGNvbnN0cnVjdG9yTmFtZSA9PT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgICAgICAgY29uc3RydWN0b3JbJ292ZXJyaWRkZW5OYW1lJ10gPSBcImNsYXNzXCIgKyBfbmV4dENsYXNzSWQrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29uc3RydWN0b3I7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1ha2VEZWNvcmF0b3IobmFtZSwgcHJvcHMsIHBhcmVudENsYXNzLCBjaGFpbkZuKSB7XG4gICAgICAgIGlmIChjaGFpbkZuID09PSB2b2lkIDApIHsgY2hhaW5GbiA9IG51bGw7IH1cbiAgICAgICAgdmFyIG1ldGFDdG9yID0gbWFrZU1ldGFkYXRhQ3RvcihbcHJvcHNdKTtcbiAgICAgICAgZnVuY3Rpb24gRGVjb3JhdG9yRmFjdG9yeShvYmpPclR5cGUpIHtcbiAgICAgICAgICAgIGlmICghKFJlZmxlY3QgJiYgUmVmbGVjdC5nZXRNZXRhZGF0YSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAncmVmbGVjdC1tZXRhZGF0YSBzaGltIGlzIHJlcXVpcmVkIHdoZW4gdXNpbmcgY2xhc3MgZGVjb3JhdG9ycyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIERlY29yYXRvckZhY3RvcnkpIHtcbiAgICAgICAgICAgICAgICBtZXRhQ3Rvci5jYWxsKHRoaXMsIG9iak9yVHlwZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgYW5ub3RhdGlvbkluc3RhbmNlID0gbmV3IERlY29yYXRvckZhY3Rvcnkob2JqT3JUeXBlKTtcbiAgICAgICAgICAgIHZhciBjaGFpbkFubm90YXRpb24gPSB0eXBlb2YgdGhpcyA9PT0gJ2Z1bmN0aW9uJyAmJiBBcnJheS5pc0FycmF5KHRoaXMuYW5ub3RhdGlvbnMpID8gdGhpcy5hbm5vdGF0aW9ucyA6IFtdO1xuICAgICAgICAgICAgY2hhaW5Bbm5vdGF0aW9uLnB1c2goYW5ub3RhdGlvbkluc3RhbmNlKTtcbiAgICAgICAgICAgIHZhciBUeXBlRGVjb3JhdG9yID0gZnVuY3Rpb24gVHlwZURlY29yYXRvcihjbHMpIHtcbiAgICAgICAgICAgICAgICB2YXIgYW5ub3RhdGlvbnMgPSBSZWZsZWN0LmdldE93bk1ldGFkYXRhKCdhbm5vdGF0aW9ucycsIGNscykgfHwgW107XG4gICAgICAgICAgICAgICAgYW5ub3RhdGlvbnMucHVzaChhbm5vdGF0aW9uSW5zdGFuY2UpO1xuICAgICAgICAgICAgICAgIFJlZmxlY3QuZGVmaW5lTWV0YWRhdGEoJ2Fubm90YXRpb25zJywgYW5ub3RhdGlvbnMsIGNscyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNscztcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBUeXBlRGVjb3JhdG9yLmFubm90YXRpb25zID0gY2hhaW5Bbm5vdGF0aW9uO1xuICAgICAgICAgICAgVHlwZURlY29yYXRvci5DbGFzcyA9IENsYXNzO1xuICAgICAgICAgICAgaWYgKGNoYWluRm4pXG4gICAgICAgICAgICAgICAgY2hhaW5GbihUeXBlRGVjb3JhdG9yKTtcbiAgICAgICAgICAgIHJldHVybiBUeXBlRGVjb3JhdG9yO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJlbnRDbGFzcykge1xuICAgICAgICAgICAgRGVjb3JhdG9yRmFjdG9yeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHBhcmVudENsYXNzLnByb3RvdHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgRGVjb3JhdG9yRmFjdG9yeS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAoXCJAXCIgKyBuYW1lKTsgfTtcbiAgICAgICAgRGVjb3JhdG9yRmFjdG9yeS5hbm5vdGF0aW9uQ2xzID0gRGVjb3JhdG9yRmFjdG9yeTtcbiAgICAgICAgcmV0dXJuIERlY29yYXRvckZhY3Rvcnk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1ha2VNZXRhZGF0YUN0b3IocHJvcHMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGN0b3IoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgYXJnc1tfaSAtIDBdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByb3BzLmZvckVhY2goZnVuY3Rpb24gKHByb3AsIGkpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJnVmFsID0gYXJnc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwcm9wKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBwbGFpbiBwYXJhbWV0ZXJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXNbcHJvcFswXV0gPSBhcmdWYWwgPT09IHVuZGVmaW5lZCA/IHByb3BbMV0gOiBhcmdWYWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiBwcm9wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpc1twcm9wTmFtZV0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ1ZhbCAmJiBhcmdWYWwuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpID8gYXJnVmFsW3Byb3BOYW1lXSA6IHByb3BbcHJvcE5hbWVdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1ha2VQYXJhbURlY29yYXRvcihuYW1lLCBwcm9wcywgcGFyZW50Q2xhc3MpIHtcbiAgICAgICAgdmFyIG1ldGFDdG9yID0gbWFrZU1ldGFkYXRhQ3Rvcihwcm9wcyk7XG4gICAgICAgIGZ1bmN0aW9uIFBhcmFtRGVjb3JhdG9yRmFjdG9yeSgpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIGFyZ3NbX2kgLSAwXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIFBhcmFtRGVjb3JhdG9yRmFjdG9yeSkge1xuICAgICAgICAgICAgICAgIG1ldGFDdG9yLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGFubm90YXRpb25JbnN0YW5jZSA9IG5ldyAoKF9hID0gUGFyYW1EZWNvcmF0b3JGYWN0b3J5KS5iaW5kLmFwcGx5KF9hLCBbdm9pZCAwXS5jb25jYXQoYXJncykpKSgpO1xuICAgICAgICAgICAgUGFyYW1EZWNvcmF0b3IuYW5ub3RhdGlvbiA9IGFubm90YXRpb25JbnN0YW5jZTtcbiAgICAgICAgICAgIHJldHVybiBQYXJhbURlY29yYXRvcjtcbiAgICAgICAgICAgIGZ1bmN0aW9uIFBhcmFtRGVjb3JhdG9yKGNscywgdW51c2VkS2V5LCBpbmRleCkge1xuICAgICAgICAgICAgICAgIHZhciBwYXJhbWV0ZXJzID0gUmVmbGVjdC5nZXRNZXRhZGF0YSgncGFyYW1ldGVycycsIGNscykgfHwgW107XG4gICAgICAgICAgICAgICAgLy8gdGhlcmUgbWlnaHQgYmUgZ2FwcyBpZiBzb21lIGluIGJldHdlZW4gcGFyYW1ldGVycyBkbyBub3QgaGF2ZSBhbm5vdGF0aW9ucy5cbiAgICAgICAgICAgICAgICAvLyB3ZSBwYWQgd2l0aCBudWxscy5cbiAgICAgICAgICAgICAgICB3aGlsZSAocGFyYW1ldGVycy5sZW5ndGggPD0gaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1ldGVycy5wdXNoKG51bGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzW2luZGV4XSA9IHBhcmFtZXRlcnNbaW5kZXhdIHx8IFtdO1xuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnNbaW5kZXhdLnB1c2goYW5ub3RhdGlvbkluc3RhbmNlKTtcbiAgICAgICAgICAgICAgICBSZWZsZWN0LmRlZmluZU1ldGFkYXRhKCdwYXJhbWV0ZXJzJywgcGFyYW1ldGVycywgY2xzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2xzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJlbnRDbGFzcykge1xuICAgICAgICAgICAgUGFyYW1EZWNvcmF0b3JGYWN0b3J5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUocGFyZW50Q2xhc3MucHJvdG90eXBlKTtcbiAgICAgICAgfVxuICAgICAgICBQYXJhbURlY29yYXRvckZhY3RvcnkucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKFwiQFwiICsgbmFtZSk7IH07XG4gICAgICAgIFBhcmFtRGVjb3JhdG9yRmFjdG9yeS5hbm5vdGF0aW9uQ2xzID0gUGFyYW1EZWNvcmF0b3JGYWN0b3J5O1xuICAgICAgICByZXR1cm4gUGFyYW1EZWNvcmF0b3JGYWN0b3J5O1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYWtlUHJvcERlY29yYXRvcihuYW1lLCBwcm9wcywgcGFyZW50Q2xhc3MpIHtcbiAgICAgICAgdmFyIG1ldGFDdG9yID0gbWFrZU1ldGFkYXRhQ3Rvcihwcm9wcyk7XG4gICAgICAgIGZ1bmN0aW9uIFByb3BEZWNvcmF0b3JGYWN0b3J5KCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgYXJnc1tfaSAtIDBdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgUHJvcERlY29yYXRvckZhY3RvcnkpIHtcbiAgICAgICAgICAgICAgICBtZXRhQ3Rvci5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBkZWNvcmF0b3JJbnN0YW5jZSA9IG5ldyAoKF9hID0gUHJvcERlY29yYXRvckZhY3RvcnkpLmJpbmQuYXBwbHkoX2EsIFt2b2lkIDBdLmNvbmNhdChhcmdzKSkpKCk7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gUHJvcERlY29yYXRvcih0YXJnZXQsIG5hbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWV0YSA9IFJlZmxlY3QuZ2V0T3duTWV0YWRhdGEoJ3Byb3BNZXRhZGF0YScsIHRhcmdldC5jb25zdHJ1Y3RvcikgfHwge307XG4gICAgICAgICAgICAgICAgbWV0YVtuYW1lXSA9IG1ldGEuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgbWV0YVtuYW1lXSB8fCBbXTtcbiAgICAgICAgICAgICAgICBtZXRhW25hbWVdLnVuc2hpZnQoZGVjb3JhdG9ySW5zdGFuY2UpO1xuICAgICAgICAgICAgICAgIFJlZmxlY3QuZGVmaW5lTWV0YWRhdGEoJ3Byb3BNZXRhZGF0YScsIG1ldGEsIHRhcmdldC5jb25zdHJ1Y3Rvcik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJlbnRDbGFzcykge1xuICAgICAgICAgICAgUHJvcERlY29yYXRvckZhY3RvcnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShwYXJlbnRDbGFzcy5wcm90b3R5cGUpO1xuICAgICAgICB9XG4gICAgICAgIFByb3BEZWNvcmF0b3JGYWN0b3J5LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIChcIkBcIiArIG5hbWUpOyB9O1xuICAgICAgICBQcm9wRGVjb3JhdG9yRmFjdG9yeS5hbm5vdGF0aW9uQ2xzID0gUHJvcERlY29yYXRvckZhY3Rvcnk7XG4gICAgICAgIHJldHVybiBQcm9wRGVjb3JhdG9yRmFjdG9yeTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbmplY3QgZGVjb3JhdG9yIGFuZCBtZXRhZGF0YS5cbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKiBAQW5ub3RhdGlvblxuICAgICAqL1xuICAgIHZhciBJbmplY3QgPSBtYWtlUGFyYW1EZWNvcmF0b3IoJ0luamVjdCcsIFtbJ3Rva2VuJywgdW5kZWZpbmVkXV0pO1xuICAgIC8qKlxuICAgICAqIE9wdGlvbmFsIGRlY29yYXRvciBhbmQgbWV0YWRhdGEuXG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICogQEFubm90YXRpb25cbiAgICAgKi9cbiAgICB2YXIgT3B0aW9uYWwgPSBtYWtlUGFyYW1EZWNvcmF0b3IoJ09wdGlvbmFsJywgW10pO1xuICAgIC8qKlxuICAgICAqIEluamVjdGFibGUgZGVjb3JhdG9yIGFuZCBtZXRhZGF0YS5cbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKiBAQW5ub3RhdGlvblxuICAgICAqL1xuICAgIHZhciBJbmplY3RhYmxlID0gbWFrZVBhcmFtRGVjb3JhdG9yKCdJbmplY3RhYmxlJywgW10pO1xuICAgIC8qKlxuICAgICAqIFNlbGYgZGVjb3JhdG9yIGFuZCBtZXRhZGF0YS5cbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKiBAQW5ub3RhdGlvblxuICAgICAqL1xuICAgIHZhciBTZWxmID0gbWFrZVBhcmFtRGVjb3JhdG9yKCdTZWxmJywgW10pO1xuICAgIC8qKlxuICAgICAqIFNraXBTZWxmIGRlY29yYXRvciBhbmQgbWV0YWRhdGEuXG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICogQEFubm90YXRpb25cbiAgICAgKi9cbiAgICB2YXIgU2tpcFNlbGYgPSBtYWtlUGFyYW1EZWNvcmF0b3IoJ1NraXBTZWxmJywgW10pO1xuICAgIC8qKlxuICAgICAqIEhvc3QgZGVjb3JhdG9yIGFuZCBtZXRhZGF0YS5cbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKiBAQW5ub3RhdGlvblxuICAgICAqL1xuICAgIHZhciBIb3N0ID0gbWFrZVBhcmFtRGVjb3JhdG9yKCdIb3N0JywgW10pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHRva2VuIHRoYXQgY2FuIGJlIHVzZWQgaW4gYSBESSBQcm92aWRlci5cbiAgICAgKlxuICAgICAqICMjIyBFeGFtcGxlIChbbGl2ZSBkZW1vXShodHRwOi8vcGxua3IuY28vZWRpdC9ZczllelhwajJNbm95M1VjOEtCcD9wPXByZXZpZXcpKVxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHZhciB0ID0gbmV3IE9wYXF1ZVRva2VuKFwidmFsdWVcIik7XG4gICAgICpcbiAgICAgKiB2YXIgaW5qZWN0b3IgPSBJbmplY3Rvci5yZXNvbHZlQW5kQ3JlYXRlKFtcbiAgICAgKiAgIHtwcm92aWRlOiB0LCB1c2VWYWx1ZTogXCJiaW5kaW5nVmFsdWVcIn1cbiAgICAgKiBdKTtcbiAgICAgKlxuICAgICAqIGV4cGVjdChpbmplY3Rvci5nZXQodCkpLnRvRXF1YWwoXCJiaW5kaW5nVmFsdWVcIik7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBVc2luZyBhbiBgT3BhcXVlVG9rZW5gIGlzIHByZWZlcmFibGUgdG8gdXNpbmcgc3RyaW5ncyBhcyB0b2tlbnMgYmVjYXVzZSBvZiBwb3NzaWJsZSBjb2xsaXNpb25zXG4gICAgICogY2F1c2VkIGJ5IG11bHRpcGxlIHByb3ZpZGVycyB1c2luZyB0aGUgc2FtZSBzdHJpbmcgYXMgdHdvIGRpZmZlcmVudCB0b2tlbnMuXG4gICAgICpcbiAgICAgKiBVc2luZyBhbiBgT3BhcXVlVG9rZW5gIGlzIHByZWZlcmFibGUgdG8gdXNpbmcgYW4gYE9iamVjdGAgYXMgdG9rZW5zIGJlY2F1c2UgaXQgcHJvdmlkZXMgYmV0dGVyXG4gICAgICogZXJyb3IgbWVzc2FnZXMuXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIC8vIHNvIHRoYXQgbWV0YWRhdGEgaXMgZ2F0aGVyZWQgZm9yIHRoaXMgY2xhc3NcbiAgICB2YXIgT3BhcXVlVG9rZW4gPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBPcGFxdWVUb2tlbihfZGVzYykge1xuICAgICAgICAgICAgdGhpcy5fZGVzYyA9IF9kZXNjO1xuICAgICAgICB9XG4gICAgICAgIE9wYXF1ZVRva2VuLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFwiVG9rZW4gXCIgKyB0aGlzLl9kZXNjOyB9O1xuICAgICAgICBPcGFxdWVUb2tlbi5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBJbmplY3RhYmxlIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBPcGFxdWVUb2tlbi5jdG9yUGFyYW1ldGVycyA9IFtcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiBPcGFxdWVUb2tlbjtcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyB0b2tlbiBjYW4gYmUgdXNlZCB0byBjcmVhdGUgYSB2aXJ0dWFsIHByb3ZpZGVyIHRoYXQgd2lsbCBwb3B1bGF0ZSB0aGVcbiAgICAgKiBgZW50cnlDb21wb25lbnRzYCBmaWVsZHMgb2YgY29tcG9uZW50cyBhbmQgbmcgbW9kdWxlcyBiYXNlZCBvbiBpdHMgYHVzZVZhbHVlYC5cbiAgICAgKiBBbGwgY29tcG9uZW50cyB0aGF0IGFyZSByZWZlcmVuY2VkIGluIHRoZSBgdXNlVmFsdWVgIHZhbHVlIChlaXRoZXIgZGlyZWN0bHlcbiAgICAgKiBvciBpbiBhIG5lc3RlZCBhcnJheSBvciBtYXApIHdpbGwgYmUgYWRkZWQgdG8gdGhlIGBlbnRyeUNvbXBvbmVudHNgIHByb3BlcnR5LlxuICAgICAqXG4gICAgICogIyMjIEV4YW1wbGVcbiAgICAgKiBUaGUgZm9sbG93aW5nIGV4YW1wbGUgc2hvd3MgaG93IHRoZSByb3V0ZXIgY2FuIHBvcHVsYXRlIHRoZSBgZW50cnlDb21wb25lbnRzYFxuICAgICAqIGZpZWxkIG9mIGFuIE5nTW9kdWxlIGJhc2VkIG9uIHRoZSByb3V0ZXIgY29uZmlndXJhdGlvbiB3aGljaCByZWZlcnNcbiAgICAgKiB0byBjb21wb25lbnRzLlxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIC8vIGhlbHBlciBmdW5jdGlvbiBpbnNpZGUgdGhlIHJvdXRlclxuICAgICAqIGZ1bmN0aW9uIHByb3ZpZGVSb3V0ZXMocm91dGVzKSB7XG4gICAgICogICByZXR1cm4gW1xuICAgICAqICAgICB7cHJvdmlkZTogUk9VVEVTLCB1c2VWYWx1ZTogcm91dGVzfSxcbiAgICAgKiAgICAge3Byb3ZpZGU6IEFOQUxZWkVfRk9SX0VOVFJZX0NPTVBPTkVOVFMsIHVzZVZhbHVlOiByb3V0ZXMsIG11bHRpOiB0cnVlfVxuICAgICAqICAgXTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiAvLyB1c2VyIGNvZGVcbiAgICAgKiBsZXQgcm91dGVzID0gW1xuICAgICAqICAge3BhdGg6ICcvcm9vdCcsIGNvbXBvbmVudDogUm9vdENvbXB9LFxuICAgICAqICAge3BhdGg6ICcvdGVhbXMnLCBjb21wb25lbnQ6IFRlYW1zQ29tcH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogQE5nTW9kdWxlKHtcbiAgICAgKiAgIHByb3ZpZGVyczogW3Byb3ZpZGVSb3V0ZXMocm91dGVzKV1cbiAgICAgKiB9KVxuICAgICAqIGNsYXNzIE1vZHVsZVdpdGhSb3V0ZXMge31cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICB2YXIgQU5BTFlaRV9GT1JfRU5UUllfQ09NUE9ORU5UUyA9IG5ldyBPcGFxdWVUb2tlbignQW5hbHl6ZUZvckVudHJ5Q29tcG9uZW50cycpO1xuICAgIC8qKlxuICAgICAqIEF0dHJpYnV0ZSBkZWNvcmF0b3IgYW5kIG1ldGFkYXRhLlxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqIEBBbm5vdGF0aW9uXG4gICAgICovXG4gICAgdmFyIEF0dHJpYnV0ZSA9IG1ha2VQYXJhbURlY29yYXRvcignQXR0cmlidXRlJywgW1snYXR0cmlidXRlTmFtZScsIHVuZGVmaW5lZF1dKTtcbiAgICAvKipcbiAgICAgKiBCYXNlIGNsYXNzIGZvciBxdWVyeSBtZXRhZGF0YS5cbiAgICAgKlxuICAgICAqIFNlZSB7QGxpbmsgQ29udGVudENoaWxkcmVufSwge0BsaW5rIENvbnRlbnRDaGlsZH0sIHtAbGluayBWaWV3Q2hpbGRyZW59LCB7QGxpbmsgVmlld0NoaWxkfSBmb3JcbiAgICAgKiBtb3JlIGluZm9ybWF0aW9uLlxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBRdWVyeSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFF1ZXJ5KCkge1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBRdWVyeTtcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIENvbnRlbnRDaGlsZHJlbiBkZWNvcmF0b3IgYW5kIG1ldGFkYXRhLlxuICAgICAqXG4gICAgICogIEBzdGFibGVcbiAgICAgKiAgQEFubm90YXRpb25cbiAgICAgKi9cbiAgICB2YXIgQ29udGVudENoaWxkcmVuID0gbWFrZVByb3BEZWNvcmF0b3IoJ0NvbnRlbnRDaGlsZHJlbicsIFtcbiAgICAgICAgWydzZWxlY3RvcicsIHVuZGVmaW5lZF0sIHtcbiAgICAgICAgICAgIGZpcnN0OiBmYWxzZSxcbiAgICAgICAgICAgIGlzVmlld1F1ZXJ5OiBmYWxzZSxcbiAgICAgICAgICAgIGRlc2NlbmRhbnRzOiBmYWxzZSxcbiAgICAgICAgICAgIHJlYWQ6IHVuZGVmaW5lZCxcbiAgICAgICAgfVxuICAgIF0sIFF1ZXJ5KTtcbiAgICAvKipcbiAgICAgKiBAd2hhdEl0RG9lcyBDb25maWd1cmVzIGEgY29udGVudCBxdWVyeS5cbiAgICAgKlxuICAgICAqIEBob3dUb1VzZVxuICAgICAqXG4gICAgICoge0BleGFtcGxlIGNvcmUvZGkvdHMvY29udGVudENoaWxkL2NvbnRlbnRfY2hpbGRfaG93dG8udHMgcmVnaW9uPSdIb3dUbyd9XG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKlxuICAgICAqIFlvdSBjYW4gdXNlIENvbnRlbnRDaGlsZCB0byBnZXQgdGhlIGZpcnN0IGVsZW1lbnQgb3IgdGhlIGRpcmVjdGl2ZSBtYXRjaGluZyB0aGUgc2VsZWN0b3IgZnJvbSB0aGVcbiAgICAgKiBjb250ZW50IERPTS4gSWYgdGhlIGNvbnRlbnQgRE9NIGNoYW5nZXMsIGFuZCBhIG5ldyBjaGlsZCBtYXRjaGVzIHRoZSBzZWxlY3RvcixcbiAgICAgKiB0aGUgcHJvcGVydHkgd2lsbCBiZSB1cGRhdGVkLlxuICAgICAqXG4gICAgICogQ29udGVudCBxdWVyaWVzIGFyZSBzZXQgYmVmb3JlIHRoZSBgbmdBZnRlckNvbnRlbnRJbml0YCBjYWxsYmFjayBpcyBjYWxsZWQuXG4gICAgICpcbiAgICAgKiAqKk1ldGFkYXRhIFByb3BlcnRpZXMqKjpcbiAgICAgKlxuICAgICAqICogKipzZWxlY3RvcioqIC0gdGhlIGRpcmVjdGl2ZSB0eXBlIG9yIHRoZSBuYW1lIHVzZWQgZm9yIHF1ZXJ5aW5nLlxuICAgICAqICogKipyZWFkKiogLSByZWFkIGEgZGlmZmVyZW50IHRva2VuIGZyb20gdGhlIHF1ZXJpZWQgZWxlbWVudC5cbiAgICAgKlxuICAgICAqIExldCdzIGxvb2sgYXQgYW4gZXhhbXBsZTpcbiAgICAgKlxuICAgICAqIHtAZXhhbXBsZSBjb3JlL2RpL3RzL2NvbnRlbnRDaGlsZC9jb250ZW50X2NoaWxkX2V4YW1wbGUudHMgcmVnaW9uPSdDb21wb25lbnQnfVxuICAgICAqXG4gICAgICogKipucG0gcGFja2FnZSoqOiBgQGFuZ3VsYXIvY29yZWBcbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKiBAQW5ub3RhdGlvblxuICAgICAqL1xuICAgIHZhciBDb250ZW50Q2hpbGQgPSBtYWtlUHJvcERlY29yYXRvcignQ29udGVudENoaWxkJywgW1xuICAgICAgICBbJ3NlbGVjdG9yJywgdW5kZWZpbmVkXSwge1xuICAgICAgICAgICAgZmlyc3Q6IHRydWUsXG4gICAgICAgICAgICBpc1ZpZXdRdWVyeTogZmFsc2UsXG4gICAgICAgICAgICBkZXNjZW5kYW50czogdHJ1ZSxcbiAgICAgICAgICAgIHJlYWQ6IHVuZGVmaW5lZCxcbiAgICAgICAgfVxuICAgIF0sIFF1ZXJ5KTtcbiAgICAvKipcbiAgICAgKiBAd2hhdEl0RG9lcyBDb25maWd1cmVzIGEgdmlldyBxdWVyeS5cbiAgICAgKlxuICAgICAqIEBob3dUb1VzZVxuICAgICAqXG4gICAgICoge0BleGFtcGxlIGNvcmUvZGkvdHMvdmlld0NoaWxkcmVuL3ZpZXdfY2hpbGRyZW5faG93dG8udHMgcmVnaW9uPSdIb3dUbyd9XG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKlxuICAgICAqIFlvdSBjYW4gdXNlIFZpZXdDaGlsZHJlbiB0byBnZXQgdGhlIHtAbGluayBRdWVyeUxpc3R9IG9mIGVsZW1lbnRzIG9yIGRpcmVjdGl2ZXMgZnJvbSB0aGVcbiAgICAgKiB2aWV3IERPTS4gQW55IHRpbWUgYSBjaGlsZCBlbGVtZW50IGlzIGFkZGVkLCByZW1vdmVkLCBvciBtb3ZlZCwgdGhlIHF1ZXJ5IGxpc3Qgd2lsbCBiZSB1cGRhdGVkLFxuICAgICAqIGFuZCB0aGUgY2hhbmdlcyBvYnNlcnZhYmxlIG9mIHRoZSBxdWVyeSBsaXN0IHdpbGwgZW1pdCBhIG5ldyB2YWx1ZS5cbiAgICAgKlxuICAgICAqIFZpZXcgcXVlcmllcyBhcmUgc2V0IGJlZm9yZSB0aGUgYG5nQWZ0ZXJWaWV3SW5pdGAgY2FsbGJhY2sgaXMgY2FsbGVkLlxuICAgICAqXG4gICAgICogKipNZXRhZGF0YSBQcm9wZXJ0aWVzKio6XG4gICAgICpcbiAgICAgKiAqICoqc2VsZWN0b3IqKiAtIHRoZSBkaXJlY3RpdmUgdHlwZSBvciB0aGUgbmFtZSB1c2VkIGZvciBxdWVyeWluZy5cbiAgICAgKiAqICoqcmVhZCoqIC0gcmVhZCBhIGRpZmZlcmVudCB0b2tlbiBmcm9tIHRoZSBxdWVyaWVkIGVsZW1lbnRzLlxuICAgICAqXG4gICAgICogTGV0J3MgbG9vayBhdCBhbiBleGFtcGxlOlxuICAgICAqXG4gICAgICoge0BleGFtcGxlIGNvcmUvZGkvdHMvdmlld0NoaWxkcmVuL3ZpZXdfY2hpbGRyZW5fZXhhbXBsZS50cyByZWdpb249J0NvbXBvbmVudCd9XG4gICAgICpcbiAgICAgKiAqKm5wbSBwYWNrYWdlKio6IGBAYW5ndWxhci9jb3JlYFxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqIEBBbm5vdGF0aW9uXG4gICAgICovXG4gICAgdmFyIFZpZXdDaGlsZHJlbiA9IG1ha2VQcm9wRGVjb3JhdG9yKCdWaWV3Q2hpbGRyZW4nLCBbXG4gICAgICAgIFsnc2VsZWN0b3InLCB1bmRlZmluZWRdLCB7XG4gICAgICAgICAgICBmaXJzdDogZmFsc2UsXG4gICAgICAgICAgICBpc1ZpZXdRdWVyeTogdHJ1ZSxcbiAgICAgICAgICAgIGRlc2NlbmRhbnRzOiB0cnVlLFxuICAgICAgICAgICAgcmVhZDogdW5kZWZpbmVkLFxuICAgICAgICB9XG4gICAgXSwgUXVlcnkpO1xuICAgIC8qKlxuICAgICAqIFZpZXdDaGlsZCBkZWNvcmF0b3IgYW5kIG1ldGFkYXRhLlxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqIEBBbm5vdGF0aW9uXG4gICAgICovXG4gICAgdmFyIFZpZXdDaGlsZCA9IG1ha2VQcm9wRGVjb3JhdG9yKCdWaWV3Q2hpbGQnLCBbXG4gICAgICAgIFsnc2VsZWN0b3InLCB1bmRlZmluZWRdLCB7XG4gICAgICAgICAgICBmaXJzdDogdHJ1ZSxcbiAgICAgICAgICAgIGlzVmlld1F1ZXJ5OiB0cnVlLFxuICAgICAgICAgICAgZGVzY2VuZGFudHM6IHRydWUsXG4gICAgICAgICAgICByZWFkOiB1bmRlZmluZWQsXG4gICAgICAgIH1cbiAgICBdLCBRdWVyeSk7XG5cbiAgICAvKipcbiAgICAgKiBEZXNjcmliZXMgd2l0aGluIHRoZSBjaGFuZ2UgZGV0ZWN0b3Igd2hpY2ggc3RyYXRlZ3kgd2lsbCBiZSB1c2VkIHRoZSBuZXh0IHRpbWUgY2hhbmdlXG4gICAgICogZGV0ZWN0aW9uIGlzIHRyaWdnZXJlZC5cbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgZXhwb3J0cy5DaGFuZ2VEZXRlY3Rpb25TdHJhdGVneTtcbiAgICAoZnVuY3Rpb24gKENoYW5nZURldGVjdGlvblN0cmF0ZWd5KSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBgT25QdXNoYCBtZWFucyB0aGF0IHRoZSBjaGFuZ2UgZGV0ZWN0b3IncyBtb2RlIHdpbGwgYmUgc2V0IHRvIGBDaGVja09uY2VgIGR1cmluZyBoeWRyYXRpb24uXG4gICAgICAgICAqL1xuICAgICAgICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneVtDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneVtcIk9uUHVzaFwiXSA9IDBdID0gXCJPblB1c2hcIjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGBEZWZhdWx0YCBtZWFucyB0aGF0IHRoZSBjaGFuZ2UgZGV0ZWN0b3IncyBtb2RlIHdpbGwgYmUgc2V0IHRvIGBDaGVja0Fsd2F5c2AgZHVyaW5nIGh5ZHJhdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIENoYW5nZURldGVjdGlvblN0cmF0ZWd5W0NoYW5nZURldGVjdGlvblN0cmF0ZWd5W1wiRGVmYXVsdFwiXSA9IDFdID0gXCJEZWZhdWx0XCI7XG4gICAgfSkoZXhwb3J0cy5DaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSB8fCAoZXhwb3J0cy5DaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSA9IHt9KSk7XG4gICAgLyoqXG4gICAgICogRGVzY3JpYmVzIHRoZSBzdGF0dXMgb2YgdGhlIGRldGVjdG9yLlxuICAgICAqL1xuICAgIHZhciBDaGFuZ2VEZXRlY3RvclN0YXR1cztcbiAgICAoZnVuY3Rpb24gKENoYW5nZURldGVjdG9yU3RhdHVzKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBgQ2hlY2tlZE9uY2VgIG1lYW5zIHRoYXQgYWZ0ZXIgY2FsbGluZyBkZXRlY3RDaGFuZ2VzIHRoZSBtb2RlIG9mIHRoZSBjaGFuZ2UgZGV0ZWN0b3JcbiAgICAgICAgICogd2lsbCBiZWNvbWUgYENoZWNrZWRgLlxuICAgICAgICAgKi9cbiAgICAgICAgQ2hhbmdlRGV0ZWN0b3JTdGF0dXNbQ2hhbmdlRGV0ZWN0b3JTdGF0dXNbXCJDaGVja09uY2VcIl0gPSAwXSA9IFwiQ2hlY2tPbmNlXCI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBgQ2hlY2tlZGAgbWVhbnMgdGhhdCB0aGUgY2hhbmdlIGRldGVjdG9yIHNob3VsZCBiZSBza2lwcGVkIHVudGlsIGl0cyBtb2RlIGNoYW5nZXMgdG9cbiAgICAgICAgICogYENoZWNrT25jZWAuXG4gICAgICAgICAqL1xuICAgICAgICBDaGFuZ2VEZXRlY3RvclN0YXR1c1tDaGFuZ2VEZXRlY3RvclN0YXR1c1tcIkNoZWNrZWRcIl0gPSAxXSA9IFwiQ2hlY2tlZFwiO1xuICAgICAgICAvKipcbiAgICAgICAgICogYENoZWNrQWx3YXlzYCBtZWFucyB0aGF0IGFmdGVyIGNhbGxpbmcgZGV0ZWN0Q2hhbmdlcyB0aGUgbW9kZSBvZiB0aGUgY2hhbmdlIGRldGVjdG9yXG4gICAgICAgICAqIHdpbGwgcmVtYWluIGBDaGVja0Fsd2F5c2AuXG4gICAgICAgICAqL1xuICAgICAgICBDaGFuZ2VEZXRlY3RvclN0YXR1c1tDaGFuZ2VEZXRlY3RvclN0YXR1c1tcIkNoZWNrQWx3YXlzXCJdID0gMl0gPSBcIkNoZWNrQWx3YXlzXCI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBgRGV0YWNoZWRgIG1lYW5zIHRoYXQgdGhlIGNoYW5nZSBkZXRlY3RvciBzdWIgdHJlZSBpcyBub3QgYSBwYXJ0IG9mIHRoZSBtYWluIHRyZWUgYW5kXG4gICAgICAgICAqIHNob3VsZCBiZSBza2lwcGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgQ2hhbmdlRGV0ZWN0b3JTdGF0dXNbQ2hhbmdlRGV0ZWN0b3JTdGF0dXNbXCJEZXRhY2hlZFwiXSA9IDNdID0gXCJEZXRhY2hlZFwiO1xuICAgICAgICAvKipcbiAgICAgICAgICogYEVycm9yZWRgIG1lYW5zIHRoYXQgdGhlIGNoYW5nZSBkZXRlY3RvciBlbmNvdW50ZXJlZCBhbiBlcnJvciBjaGVja2luZyBhIGJpbmRpbmdcbiAgICAgICAgICogb3IgY2FsbGluZyBhIGRpcmVjdGl2ZSBsaWZlY3ljbGUgbWV0aG9kIGFuZCBpcyBub3cgaW4gYW4gaW5jb25zaXN0ZW50IHN0YXRlLiBDaGFuZ2VcbiAgICAgICAgICogZGV0ZWN0b3JzIGluIHRoaXMgc3RhdGUgd2lsbCBubyBsb25nZXIgZGV0ZWN0IGNoYW5nZXMuXG4gICAgICAgICAqL1xuICAgICAgICBDaGFuZ2VEZXRlY3RvclN0YXR1c1tDaGFuZ2VEZXRlY3RvclN0YXR1c1tcIkVycm9yZWRcIl0gPSA0XSA9IFwiRXJyb3JlZFwiO1xuICAgICAgICAvKipcbiAgICAgICAgICogYERlc3Ryb3llZGAgbWVhbnMgdGhhdCB0aGUgY2hhbmdlIGRldGVjdG9yIGlzIGRlc3Ryb3llZC5cbiAgICAgICAgICovXG4gICAgICAgIENoYW5nZURldGVjdG9yU3RhdHVzW0NoYW5nZURldGVjdG9yU3RhdHVzW1wiRGVzdHJveWVkXCJdID0gNV0gPSBcIkRlc3Ryb3llZFwiO1xuICAgIH0pKENoYW5nZURldGVjdG9yU3RhdHVzIHx8IChDaGFuZ2VEZXRlY3RvclN0YXR1cyA9IHt9KSk7XG4gICAgZnVuY3Rpb24gaXNEZWZhdWx0Q2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3koY2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kpIHtcbiAgICAgICAgcmV0dXJuIGlzQmxhbmsoY2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kpIHx8XG4gICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSA9PT0gZXhwb3J0cy5DaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5EZWZhdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERpcmVjdGl2ZSBkZWNvcmF0b3IgYW5kIG1ldGFkYXRhLlxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqIEBBbm5vdGF0aW9uXG4gICAgICovXG4gICAgdmFyIERpcmVjdGl2ZSA9IG1ha2VEZWNvcmF0b3IoJ0RpcmVjdGl2ZScsIHtcbiAgICAgICAgc2VsZWN0b3I6IHVuZGVmaW5lZCxcbiAgICAgICAgaW5wdXRzOiB1bmRlZmluZWQsXG4gICAgICAgIG91dHB1dHM6IHVuZGVmaW5lZCxcbiAgICAgICAgaG9zdDogdW5kZWZpbmVkLFxuICAgICAgICBwcm92aWRlcnM6IHVuZGVmaW5lZCxcbiAgICAgICAgZXhwb3J0QXM6IHVuZGVmaW5lZCxcbiAgICAgICAgcXVlcmllczogdW5kZWZpbmVkXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQ29tcG9uZW50IGRlY29yYXRvciBhbmQgbWV0YWRhdGEuXG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICogQEFubm90YXRpb25cbiAgICAgKi9cbiAgICB2YXIgQ29tcG9uZW50ID0gbWFrZURlY29yYXRvcignQ29tcG9uZW50Jywge1xuICAgICAgICBzZWxlY3RvcjogdW5kZWZpbmVkLFxuICAgICAgICBpbnB1dHM6IHVuZGVmaW5lZCxcbiAgICAgICAgb3V0cHV0czogdW5kZWZpbmVkLFxuICAgICAgICBob3N0OiB1bmRlZmluZWQsXG4gICAgICAgIGV4cG9ydEFzOiB1bmRlZmluZWQsXG4gICAgICAgIG1vZHVsZUlkOiB1bmRlZmluZWQsXG4gICAgICAgIHByb3ZpZGVyczogdW5kZWZpbmVkLFxuICAgICAgICB2aWV3UHJvdmlkZXJzOiB1bmRlZmluZWQsXG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogZXhwb3J0cy5DaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5EZWZhdWx0LFxuICAgICAgICBxdWVyaWVzOiB1bmRlZmluZWQsXG4gICAgICAgIHRlbXBsYXRlVXJsOiB1bmRlZmluZWQsXG4gICAgICAgIHRlbXBsYXRlOiB1bmRlZmluZWQsXG4gICAgICAgIHN0eWxlVXJsczogdW5kZWZpbmVkLFxuICAgICAgICBzdHlsZXM6IHVuZGVmaW5lZCxcbiAgICAgICAgYW5pbWF0aW9uczogdW5kZWZpbmVkLFxuICAgICAgICBlbmNhcHN1bGF0aW9uOiB1bmRlZmluZWQsXG4gICAgICAgIGludGVycG9sYXRpb246IHVuZGVmaW5lZCxcbiAgICAgICAgZW50cnlDb21wb25lbnRzOiB1bmRlZmluZWRcbiAgICB9LCBEaXJlY3RpdmUpO1xuICAgIC8qKlxuICAgICAqIFBpcGUgZGVjb3JhdG9yIGFuZCBtZXRhZGF0YS5cbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKiBAQW5ub3RhdGlvblxuICAgICAqL1xuICAgIHZhciBQaXBlID0gbWFrZURlY29yYXRvcignUGlwZScsIHtcbiAgICAgICAgbmFtZTogdW5kZWZpbmVkLFxuICAgICAgICBwdXJlOiB0cnVlLFxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIElucHV0IGRlY29yYXRvciBhbmQgbWV0YWRhdGEuXG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICogQEFubm90YXRpb25cbiAgICAgKi9cbiAgICB2YXIgSW5wdXQgPSBtYWtlUHJvcERlY29yYXRvcignSW5wdXQnLCBbWydiaW5kaW5nUHJvcGVydHlOYW1lJywgdW5kZWZpbmVkXV0pO1xuICAgIC8qKlxuICAgICAqIE91dHB1dCBkZWNvcmF0b3IgYW5kIG1ldGFkYXRhLlxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqIEBBbm5vdGF0aW9uXG4gICAgICovXG4gICAgdmFyIE91dHB1dCA9IG1ha2VQcm9wRGVjb3JhdG9yKCdPdXRwdXQnLCBbWydiaW5kaW5nUHJvcGVydHlOYW1lJywgdW5kZWZpbmVkXV0pO1xuICAgIC8qKlxuICAgICAqIEhvc3RCaW5kaW5nIGRlY29yYXRvciBhbmQgbWV0YWRhdGEuXG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICogQEFubm90YXRpb25cbiAgICAgKi9cbiAgICB2YXIgSG9zdEJpbmRpbmcgPSBtYWtlUHJvcERlY29yYXRvcignSG9zdEJpbmRpbmcnLCBbWydob3N0UHJvcGVydHlOYW1lJywgdW5kZWZpbmVkXV0pO1xuICAgIC8qKlxuICAgICAqIEhvc3RCaW5kaW5nIGRlY29yYXRvciBhbmQgbWV0YWRhdGEuXG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICogQEFubm90YXRpb25cbiAgICAgKi9cbiAgICB2YXIgSG9zdExpc3RlbmVyID0gbWFrZVByb3BEZWNvcmF0b3IoJ0hvc3RMaXN0ZW5lcicsIFtbJ2V2ZW50TmFtZScsIHVuZGVmaW5lZF0sIFsnYXJncycsIFtdXV0pO1xuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgTGlmZWN5Y2xlSG9va3M7XG4gICAgKGZ1bmN0aW9uIChMaWZlY3ljbGVIb29rcykge1xuICAgICAgICBMaWZlY3ljbGVIb29rc1tMaWZlY3ljbGVIb29rc1tcIk9uSW5pdFwiXSA9IDBdID0gXCJPbkluaXRcIjtcbiAgICAgICAgTGlmZWN5Y2xlSG9va3NbTGlmZWN5Y2xlSG9va3NbXCJPbkRlc3Ryb3lcIl0gPSAxXSA9IFwiT25EZXN0cm95XCI7XG4gICAgICAgIExpZmVjeWNsZUhvb2tzW0xpZmVjeWNsZUhvb2tzW1wiRG9DaGVja1wiXSA9IDJdID0gXCJEb0NoZWNrXCI7XG4gICAgICAgIExpZmVjeWNsZUhvb2tzW0xpZmVjeWNsZUhvb2tzW1wiT25DaGFuZ2VzXCJdID0gM10gPSBcIk9uQ2hhbmdlc1wiO1xuICAgICAgICBMaWZlY3ljbGVIb29rc1tMaWZlY3ljbGVIb29rc1tcIkFmdGVyQ29udGVudEluaXRcIl0gPSA0XSA9IFwiQWZ0ZXJDb250ZW50SW5pdFwiO1xuICAgICAgICBMaWZlY3ljbGVIb29rc1tMaWZlY3ljbGVIb29rc1tcIkFmdGVyQ29udGVudENoZWNrZWRcIl0gPSA1XSA9IFwiQWZ0ZXJDb250ZW50Q2hlY2tlZFwiO1xuICAgICAgICBMaWZlY3ljbGVIb29rc1tMaWZlY3ljbGVIb29rc1tcIkFmdGVyVmlld0luaXRcIl0gPSA2XSA9IFwiQWZ0ZXJWaWV3SW5pdFwiO1xuICAgICAgICBMaWZlY3ljbGVIb29rc1tMaWZlY3ljbGVIb29rc1tcIkFmdGVyVmlld0NoZWNrZWRcIl0gPSA3XSA9IFwiQWZ0ZXJWaWV3Q2hlY2tlZFwiO1xuICAgIH0pKExpZmVjeWNsZUhvb2tzIHx8IChMaWZlY3ljbGVIb29rcyA9IHt9KSk7XG4gICAgdmFyIExJRkVDWUNMRV9IT09LU19WQUxVRVMgPSBbXG4gICAgICAgIExpZmVjeWNsZUhvb2tzLk9uSW5pdCwgTGlmZWN5Y2xlSG9va3MuT25EZXN0cm95LCBMaWZlY3ljbGVIb29rcy5Eb0NoZWNrLCBMaWZlY3ljbGVIb29rcy5PbkNoYW5nZXMsXG4gICAgICAgIExpZmVjeWNsZUhvb2tzLkFmdGVyQ29udGVudEluaXQsIExpZmVjeWNsZUhvb2tzLkFmdGVyQ29udGVudENoZWNrZWQsIExpZmVjeWNsZUhvb2tzLkFmdGVyVmlld0luaXQsXG4gICAgICAgIExpZmVjeWNsZUhvb2tzLkFmdGVyVmlld0NoZWNrZWRcbiAgICBdO1xuICAgIC8qKlxuICAgICAqIEB3aGF0SXREb2VzIExpZmVjeWNsZSBob29rIHRoYXQgaXMgY2FsbGVkIHdoZW4gYW55IGRhdGEtYm91bmQgcHJvcGVydHkgb2YgYSBkaXJlY3RpdmUgY2hhbmdlcy5cbiAgICAgKiBAaG93VG9Vc2VcbiAgICAgKiB7QGV4YW1wbGUgY29yZS90cy9tZXRhZGF0YS9saWZlY3ljbGVfaG9va3Nfc3BlYy50cyByZWdpb249J09uQ2hhbmdlcyd9XG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBgbmdPbkNoYW5nZXNgIGlzIGNhbGxlZCByaWdodCBhZnRlciB0aGUgZGF0YS1ib3VuZCBwcm9wZXJ0aWVzIGhhdmUgYmVlbiBjaGVja2VkIGFuZCBiZWZvcmUgdmlld1xuICAgICAqIGFuZCBjb250ZW50IGNoaWxkcmVuIGFyZSBjaGVja2VkIGlmIGF0IGxlYXN0IG9uZSBvZiB0aGVtIGhhcyBjaGFuZ2VkLlxuICAgICAqIFRoZSBgY2hhbmdlc2AgcGFyYW1ldGVyIGNvbnRhaW5zIHRoZSBjaGFuZ2VkIHByb3BlcnRpZXMuXG4gICAgICpcbiAgICAgKiBTZWUge0BsaW5rRG9jcyBndWlkZS9saWZlY3ljbGUtaG9va3Mjb25jaGFuZ2VzIFwiTGlmZWN5Y2xlIEhvb2tzIEd1aWRlXCJ9LlxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBPbkNoYW5nZXMgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBPbkNoYW5nZXMoKSB7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE9uQ2hhbmdlcztcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIEB3aGF0SXREb2VzIExpZmVjeWNsZSBob29rIHRoYXQgaXMgY2FsbGVkIGFmdGVyIGRhdGEtYm91bmQgcHJvcGVydGllcyBvZiBhIGRpcmVjdGl2ZSBhcmVcbiAgICAgKiBpbml0aWFsaXplZC5cbiAgICAgKiBAaG93VG9Vc2VcbiAgICAgKiB7QGV4YW1wbGUgY29yZS90cy9tZXRhZGF0YS9saWZlY3ljbGVfaG9va3Nfc3BlYy50cyByZWdpb249J09uSW5pdCd9XG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBgbmdPbkluaXRgIGlzIGNhbGxlZCByaWdodCBhZnRlciB0aGUgZGlyZWN0aXZlJ3MgZGF0YS1ib3VuZCBwcm9wZXJ0aWVzIGhhdmUgYmVlbiBjaGVja2VkIGZvciB0aGVcbiAgICAgKiBmaXJzdCB0aW1lLCBhbmQgYmVmb3JlIGFueSBvZiBpdHMgY2hpbGRyZW4gaGF2ZSBiZWVuIGNoZWNrZWQuIEl0IGlzIGludm9rZWQgb25seSBvbmNlIHdoZW4gdGhlXG4gICAgICogZGlyZWN0aXZlIGlzIGluc3RhbnRpYXRlZC5cbiAgICAgKlxuICAgICAqIFNlZSB7QGxpbmtEb2NzIGd1aWRlL2xpZmVjeWNsZS1ob29rcyBcIkxpZmVjeWNsZSBIb29rcyBHdWlkZVwifS5cbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgT25Jbml0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gT25Jbml0KCkge1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPbkluaXQ7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBAd2hhdEl0RG9lcyBMaWZlY3ljbGUgaG9vayB0aGF0IGlzIGNhbGxlZCB3aGVuIEFuZ3VsYXIgZGlydHkgY2hlY2tzIGEgZGlyZWN0aXZlLlxuICAgICAqIEBob3dUb1VzZVxuICAgICAqIHtAZXhhbXBsZSBjb3JlL3RzL21ldGFkYXRhL2xpZmVjeWNsZV9ob29rc19zcGVjLnRzIHJlZ2lvbj0nRG9DaGVjayd9XG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBgbmdEb0NoZWNrYCBnZXRzIGNhbGxlZCB0byBjaGVjayB0aGUgY2hhbmdlcyBpbiB0aGUgZGlyZWN0aXZlcyBpbiBhZGRpdGlvbiB0byB0aGUgZGVmYXVsdFxuICAgICAqIGFsZ29yaXRobS4gVGhlIGRlZmF1bHQgY2hhbmdlIGRldGVjdGlvbiBhbGdvcml0aG0gbG9va3MgZm9yIGRpZmZlcmVuY2VzIGJ5IGNvbXBhcmluZ1xuICAgICAqIGJvdW5kLXByb3BlcnR5IHZhbHVlcyBieSByZWZlcmVuY2UgYWNyb3NzIGNoYW5nZSBkZXRlY3Rpb24gcnVucy5cbiAgICAgKlxuICAgICAqIE5vdGUgdGhhdCBhIGRpcmVjdGl2ZSB0eXBpY2FsbHkgc2hvdWxkIG5vdCB1c2UgYm90aCBgRG9DaGVja2AgYW5kIHtAbGluayBPbkNoYW5nZXN9IHRvIHJlc3BvbmQgdG9cbiAgICAgKiBjaGFuZ2VzIG9uIHRoZSBzYW1lIGlucHV0LCBhcyBgbmdPbkNoYW5nZXNgIHdpbGwgY29udGludWUgdG8gYmUgY2FsbGVkIHdoZW4gdGhlIGRlZmF1bHQgY2hhbmdlXG4gICAgICogZGV0ZWN0b3IgZGV0ZWN0cyBjaGFuZ2VzLlxuICAgICAqXG4gICAgICogU2VlIHtAbGluayBLZXlWYWx1ZURpZmZlcnN9IGFuZCB7QGxpbmsgSXRlcmFibGVEaWZmZXJzfSBmb3IgaW1wbGVtZW50aW5nIGN1c3RvbSBkaXJ0eSBjaGVja2luZ1xuICAgICAqIGZvciBjb2xsZWN0aW9ucy5cbiAgICAgKlxuICAgICAqIFNlZSB7QGxpbmtEb2NzIGd1aWRlL2xpZmVjeWNsZS1ob29rcyNkb2NoZWNrIFwiTGlmZWN5Y2xlIEhvb2tzIEd1aWRlXCJ9LlxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBEb0NoZWNrID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gRG9DaGVjaygpIHtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRG9DaGVjaztcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIEB3aGF0SXREb2VzIExpZmVjeWNsZSBob29rIHRoYXQgaXMgY2FsbGVkIHdoZW4gYSBkaXJlY3RpdmUgb3IgcGlwZSBpcyBkZXN0cm95ZWQuXG4gICAgICogQGhvd1RvVXNlXG4gICAgICoge0BleGFtcGxlIGNvcmUvdHMvbWV0YWRhdGEvbGlmZWN5Y2xlX2hvb2tzX3NwZWMudHMgcmVnaW9uPSdPbkRlc3Ryb3knfVxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogYG5nT25EZXN0cm95YCBjYWxsYmFjayBpcyB0eXBpY2FsbHkgdXNlZCBmb3IgYW55IGN1c3RvbSBjbGVhbnVwIHRoYXQgbmVlZHMgdG8gb2NjdXIgd2hlbiB0aGVcbiAgICAgKiBpbnN0YW5jZSBpcyBkZXN0cm95ZWQuXG4gICAgICpcbiAgICAgKiBTZWUge0BsaW5rRG9jcyBndWlkZS9saWZlY3ljbGUtaG9va3MgXCJMaWZlY3ljbGUgSG9va3MgR3VpZGVcIn0uXG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIE9uRGVzdHJveSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIE9uRGVzdHJveSgpIHtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT25EZXN0cm95O1xuICAgIH0oKSk7XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAd2hhdEl0RG9lcyBMaWZlY3ljbGUgaG9vayB0aGF0IGlzIGNhbGxlZCBhZnRlciBhIGRpcmVjdGl2ZSdzIGNvbnRlbnQgaGFzIGJlZW4gZnVsbHlcbiAgICAgKiBpbml0aWFsaXplZC5cbiAgICAgKiBAaG93VG9Vc2VcbiAgICAgKiB7QGV4YW1wbGUgY29yZS90cy9tZXRhZGF0YS9saWZlY3ljbGVfaG9va3Nfc3BlYy50cyByZWdpb249J0FmdGVyQ29udGVudEluaXQnfVxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogU2VlIHtAbGlua0RvY3MgZ3VpZGUvbGlmZWN5Y2xlLWhvb2tzI2FmdGVyY29udGVudCBcIkxpZmVjeWNsZSBIb29rcyBHdWlkZVwifS5cbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgQWZ0ZXJDb250ZW50SW5pdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEFmdGVyQ29udGVudEluaXQoKSB7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEFmdGVyQ29udGVudEluaXQ7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBAd2hhdEl0RG9lcyBMaWZlY3ljbGUgaG9vayB0aGF0IGlzIGNhbGxlZCBhZnRlciBldmVyeSBjaGVjayBvZiBhIGRpcmVjdGl2ZSdzIGNvbnRlbnQuXG4gICAgICogQGhvd1RvVXNlXG4gICAgICoge0BleGFtcGxlIGNvcmUvdHMvbWV0YWRhdGEvbGlmZWN5Y2xlX2hvb2tzX3NwZWMudHMgcmVnaW9uPSdBZnRlckNvbnRlbnRDaGVja2VkJ31cbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIFNlZSB7QGxpbmtEb2NzIGd1aWRlL2xpZmVjeWNsZS1ob29rcyNhZnRlcmNvbnRlbnQgXCJMaWZlY3ljbGUgSG9va3MgR3VpZGVcIn0uXG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIEFmdGVyQ29udGVudENoZWNrZWQgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBBZnRlckNvbnRlbnRDaGVja2VkKCkge1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBBZnRlckNvbnRlbnRDaGVja2VkO1xuICAgIH0oKSk7XG4gICAgLyoqXG4gICAgICogQHdoYXRJdERvZXMgTGlmZWN5Y2xlIGhvb2sgdGhhdCBpcyBjYWxsZWQgYWZ0ZXIgYSBjb21wb25lbnQncyB2aWV3IGhhcyBiZWVuIGZ1bGx5XG4gICAgICogaW5pdGlhbGl6ZWQuXG4gICAgICogQGhvd1RvVXNlXG4gICAgICoge0BleGFtcGxlIGNvcmUvdHMvbWV0YWRhdGEvbGlmZWN5Y2xlX2hvb2tzX3NwZWMudHMgcmVnaW9uPSdBZnRlclZpZXdJbml0J31cbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIFNlZSB7QGxpbmtEb2NzIGd1aWRlL2xpZmVjeWNsZS1ob29rcyNhZnRlcnZpZXcgXCJMaWZlY3ljbGUgSG9va3MgR3VpZGVcIn0uXG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIEFmdGVyVmlld0luaXQgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBBZnRlclZpZXdJbml0KCkge1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBBZnRlclZpZXdJbml0O1xuICAgIH0oKSk7XG4gICAgLyoqXG4gICAgICogQHdoYXRJdERvZXMgTGlmZWN5Y2xlIGhvb2sgdGhhdCBpcyBjYWxsZWQgYWZ0ZXIgZXZlcnkgY2hlY2sgb2YgYSBjb21wb25lbnQncyB2aWV3LlxuICAgICAqIEBob3dUb1VzZVxuICAgICAqIHtAZXhhbXBsZSBjb3JlL3RzL21ldGFkYXRhL2xpZmVjeWNsZV9ob29rc19zcGVjLnRzIHJlZ2lvbj0nQWZ0ZXJWaWV3Q2hlY2tlZCd9XG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBTZWUge0BsaW5rRG9jcyBndWlkZS9saWZlY3ljbGUtaG9va3MjYWZ0ZXJ2aWV3IFwiTGlmZWN5Y2xlIEhvb2tzIEd1aWRlXCJ9LlxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBBZnRlclZpZXdDaGVja2VkID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gQWZ0ZXJWaWV3Q2hlY2tlZCgpIHtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQWZ0ZXJWaWV3Q2hlY2tlZDtcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogRGVmaW5lcyBhIHNjaGVtYSB0aGF0IHdpbGwgYWxsb3c6XG4gICAgICogLSBhbnkgbm9uLUFuZ3VsYXIgZWxlbWVudHMgd2l0aCBhIGAtYCBpbiB0aGVpciBuYW1lLFxuICAgICAqIC0gYW55IHByb3BlcnRpZXMgb24gZWxlbWVudHMgd2l0aCBhIGAtYCBpbiB0aGVpciBuYW1lIHdoaWNoIGlzIHRoZSBjb21tb24gcnVsZSBmb3IgY3VzdG9tXG4gICAgICogZWxlbWVudHMuXG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIENVU1RPTV9FTEVNRU5UU19TQ0hFTUEgPSB7XG4gICAgICAgIG5hbWU6ICdjdXN0b20tZWxlbWVudHMnXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEZWZpbmVzIGEgc2NoZW1hIHRoYXQgd2lsbCBhbGxvdyBhbnkgcHJvcGVydHkgb24gYW55IGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgdmFyIE5PX0VSUk9SU19TQ0hFTUEgPSB7XG4gICAgICAgIG5hbWU6ICduby1lcnJvcnMtc2NoZW1hJ1xuICAgIH07XG4gICAgLyoqXG4gICAgICogTmdNb2R1bGUgZGVjb3JhdG9yIGFuZCBtZXRhZGF0YS5cbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKiBAQW5ub3RhdGlvblxuICAgICAqL1xuICAgIHZhciBOZ01vZHVsZSA9IG1ha2VEZWNvcmF0b3IoJ05nTW9kdWxlJywge1xuICAgICAgICBwcm92aWRlcnM6IHVuZGVmaW5lZCxcbiAgICAgICAgZGVjbGFyYXRpb25zOiB1bmRlZmluZWQsXG4gICAgICAgIGltcG9ydHM6IHVuZGVmaW5lZCxcbiAgICAgICAgZXhwb3J0czogdW5kZWZpbmVkLFxuICAgICAgICBlbnRyeUNvbXBvbmVudHM6IHVuZGVmaW5lZCxcbiAgICAgICAgYm9vdHN0cmFwOiB1bmRlZmluZWQsXG4gICAgICAgIHNjaGVtYXM6IHVuZGVmaW5lZCxcbiAgICAgICAgaWQ6IHVuZGVmaW5lZCxcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBEZWZpbmVzIHRlbXBsYXRlIGFuZCBzdHlsZSBlbmNhcHN1bGF0aW9uIG9wdGlvbnMgYXZhaWxhYmxlIGZvciBDb21wb25lbnQncyB7QGxpbmsgQ29tcG9uZW50fS5cbiAgICAgKlxuICAgICAqIFNlZSB7QGxpbmsgVmlld01ldGFkYXRhI2VuY2Fwc3VsYXRpb259LlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICBleHBvcnRzLlZpZXdFbmNhcHN1bGF0aW9uO1xuICAgIChmdW5jdGlvbiAoVmlld0VuY2Fwc3VsYXRpb24pIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVtdWxhdGUgYE5hdGl2ZWAgc2NvcGluZyBvZiBzdHlsZXMgYnkgYWRkaW5nIGFuIGF0dHJpYnV0ZSBjb250YWluaW5nIHN1cnJvZ2F0ZSBpZCB0byB0aGUgSG9zdFxuICAgICAgICAgKiBFbGVtZW50IGFuZCBwcmUtcHJvY2Vzc2luZyB0aGUgc3R5bGUgcnVsZXMgcHJvdmlkZWQgdmlhXG4gICAgICAgICAqIHtAbGluayBWaWV3TWV0YWRhdGEjc3R5bGVzfSBvciB7QGxpbmsgVmlld01ldGFkYXRhI3N0eWxlc1VybHN9LCBhbmQgYWRkaW5nIHRoZSBuZXcgSG9zdCBFbGVtZW50XG4gICAgICAgICAqIGF0dHJpYnV0ZSB0byBhbGwgc2VsZWN0b3JzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIGlzIHRoZSBkZWZhdWx0IG9wdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIFZpZXdFbmNhcHN1bGF0aW9uW1ZpZXdFbmNhcHN1bGF0aW9uW1wiRW11bGF0ZWRcIl0gPSAwXSA9IFwiRW11bGF0ZWRcIjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVzZSB0aGUgbmF0aXZlIGVuY2Fwc3VsYXRpb24gbWVjaGFuaXNtIG9mIHRoZSByZW5kZXJlci5cbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIHRoZSBET00gdGhpcyBtZWFucyB1c2luZyBbU2hhZG93IERPTV0oaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmNvbXBvbmVudHMvc3BlYy9zaGFkb3cvKSBhbmRcbiAgICAgICAgICogY3JlYXRpbmcgYSBTaGFkb3dSb290IGZvciBDb21wb25lbnQncyBIb3N0IEVsZW1lbnQuXG4gICAgICAgICAqL1xuICAgICAgICBWaWV3RW5jYXBzdWxhdGlvbltWaWV3RW5jYXBzdWxhdGlvbltcIk5hdGl2ZVwiXSA9IDFdID0gXCJOYXRpdmVcIjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERvbid0IHByb3ZpZGUgYW55IHRlbXBsYXRlIG9yIHN0eWxlIGVuY2Fwc3VsYXRpb24uXG4gICAgICAgICAqL1xuICAgICAgICBWaWV3RW5jYXBzdWxhdGlvbltWaWV3RW5jYXBzdWxhdGlvbltcIk5vbmVcIl0gPSAyXSA9IFwiTm9uZVwiO1xuICAgIH0pKGV4cG9ydHMuVmlld0VuY2Fwc3VsYXRpb24gfHwgKGV4cG9ydHMuVmlld0VuY2Fwc3VsYXRpb24gPSB7fSkpO1xuICAgIC8qKlxuICAgICAqIE1ldGFkYXRhIHByb3BlcnRpZXMgYXZhaWxhYmxlIGZvciBjb25maWd1cmluZyBWaWV3cy5cbiAgICAgKlxuICAgICAqIEZvciBkZXRhaWxzIG9uIHRoZSBgQENvbXBvbmVudGAgYW5ub3RhdGlvbiwgc2VlIHtAbGluayBDb21wb25lbnR9LlxuICAgICAqXG4gICAgICogIyMjIEV4YW1wbGVcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIEBDb21wb25lbnQoe1xuICAgICAqICAgc2VsZWN0b3I6ICdncmVldCcsXG4gICAgICogICB0ZW1wbGF0ZTogJ0hlbGxvIHt7bmFtZX19IScsXG4gICAgICogfSlcbiAgICAgKiBjbGFzcyBHcmVldCB7XG4gICAgICogICBuYW1lOiBzdHJpbmc7XG4gICAgICpcbiAgICAgKiAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAqICAgICB0aGlzLm5hbWUgPSAnV29ybGQnO1xuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBkZXByZWNhdGVkIFVzZSBDb21wb25lbnQgaW5zdGVhZC5cbiAgICAgKlxuICAgICAqIHtAbGluayBDb21wb25lbnR9XG4gICAgICovXG4gICAgdmFyIFZpZXdNZXRhZGF0YSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFZpZXdNZXRhZGF0YShfYSkge1xuICAgICAgICAgICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIHRlbXBsYXRlVXJsID0gX2IudGVtcGxhdGVVcmwsIHRlbXBsYXRlID0gX2IudGVtcGxhdGUsIGVuY2Fwc3VsYXRpb24gPSBfYi5lbmNhcHN1bGF0aW9uLCBzdHlsZXMgPSBfYi5zdHlsZXMsIHN0eWxlVXJscyA9IF9iLnN0eWxlVXJscywgYW5pbWF0aW9ucyA9IF9iLmFuaW1hdGlvbnMsIGludGVycG9sYXRpb24gPSBfYi5pbnRlcnBvbGF0aW9uO1xuICAgICAgICAgICAgdGhpcy50ZW1wbGF0ZVVybCA9IHRlbXBsYXRlVXJsO1xuICAgICAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IHRlbXBsYXRlO1xuICAgICAgICAgICAgdGhpcy5zdHlsZVVybHMgPSBzdHlsZVVybHM7XG4gICAgICAgICAgICB0aGlzLnN0eWxlcyA9IHN0eWxlcztcbiAgICAgICAgICAgIHRoaXMuZW5jYXBzdWxhdGlvbiA9IGVuY2Fwc3VsYXRpb247XG4gICAgICAgICAgICB0aGlzLmFuaW1hdGlvbnMgPSBhbmltYXRpb25zO1xuICAgICAgICAgICAgdGhpcy5pbnRlcnBvbGF0aW9uID0gaW50ZXJwb2xhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gVmlld01ldGFkYXRhO1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBBbGxvd3MgdG8gcmVmZXIgdG8gcmVmZXJlbmNlcyB3aGljaCBhcmUgbm90IHlldCBkZWZpbmVkLlxuICAgICAqXG4gICAgICogRm9yIGluc3RhbmNlLCBgZm9yd2FyZFJlZmAgaXMgdXNlZCB3aGVuIHRoZSBgdG9rZW5gIHdoaWNoIHdlIG5lZWQgdG8gcmVmZXIgdG8gZm9yIHRoZSBwdXJwb3NlcyBvZlxuICAgICAqIERJIGlzIGRlY2xhcmVkLFxuICAgICAqIGJ1dCBub3QgeWV0IGRlZmluZWQuIEl0IGlzIGFsc28gdXNlZCB3aGVuIHRoZSBgdG9rZW5gIHdoaWNoIHdlIHVzZSB3aGVuIGNyZWF0aW5nIGEgcXVlcnkgaXMgbm90XG4gICAgICogeWV0IGRlZmluZWQuXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZVxuICAgICAqIHtAZXhhbXBsZSBjb3JlL2RpL3RzL2ZvcndhcmRfcmVmL2ZvcndhcmRfcmVmX3NwZWMudHMgcmVnaW9uPSdmb3J3YXJkX3JlZid9XG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZvcndhcmRSZWYoZm9yd2FyZFJlZkZuKSB7XG4gICAgICAgIGZvcndhcmRSZWZGbi5fX2ZvcndhcmRfcmVmX18gPSBmb3J3YXJkUmVmO1xuICAgICAgICBmb3J3YXJkUmVmRm4udG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBzdHJpbmdpZnkodGhpcygpKTsgfTtcbiAgICAgICAgcmV0dXJuIGZvcndhcmRSZWZGbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGF6aWx5IHJldHJpZXZlcyB0aGUgcmVmZXJlbmNlIHZhbHVlIGZyb20gYSBmb3J3YXJkUmVmLlxuICAgICAqXG4gICAgICogQWN0cyBhcyB0aGUgaWRlbnRpdHkgZnVuY3Rpb24gd2hlbiBnaXZlbiBhIG5vbi1mb3J3YXJkLXJlZiB2YWx1ZS5cbiAgICAgKlxuICAgICAqICMjIyBFeGFtcGxlIChbbGl2ZSBkZW1vXShodHRwOi8vcGxua3IuY28vZWRpdC9HVTcybUpyazFmaW9kQ2hjbWlEUj9wPXByZXZpZXcpKVxuICAgICAqXG4gICAgICoge0BleGFtcGxlIGNvcmUvZGkvdHMvZm9yd2FyZF9yZWYvZm9yd2FyZF9yZWZfc3BlYy50cyByZWdpb249J3Jlc29sdmVfZm9yd2FyZF9yZWYnfVxuICAgICAqXG4gICAgICogU2VlOiB7QGxpbmsgZm9yd2FyZFJlZn1cbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVzb2x2ZUZvcndhcmRSZWYodHlwZSkge1xuICAgICAgICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgJiYgdHlwZS5oYXNPd25Qcm9wZXJ0eSgnX19mb3J3YXJkX3JlZl9fJykgJiZcbiAgICAgICAgICAgIHR5cGUuX19mb3J3YXJkX3JlZl9fID09PSBmb3J3YXJkUmVmKSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgdmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIHVuaW1wbGVtZW50ZWQoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndW5pbXBsZW1lbnRlZCcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIEJhc2VFcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyhCYXNlRXJyb3IsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIEJhc2VFcnJvcihtZXNzYWdlKSB7XG4gICAgICAgICAgICAvLyBFcnJvcnMgZG9uJ3QgdXNlIGN1cnJlbnQgdGhpcywgaW5zdGVhZCB0aGV5IGNyZWF0ZSBhIG5ldyBpbnN0YW5jZS5cbiAgICAgICAgICAgIC8vIFdlIGhhdmUgdG8gZG8gZm9yd2FyZCBhbGwgb2Ygb3VyIGFwaSB0byB0aGUgbmF0aXZlSW5zdGFuY2UuXG4gICAgICAgICAgICB2YXIgbmF0aXZlRXJyb3IgPSBfc3VwZXIuY2FsbCh0aGlzLCBtZXNzYWdlKTtcbiAgICAgICAgICAgIHRoaXMuX25hdGl2ZUVycm9yID0gbmF0aXZlRXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJhc2VFcnJvci5wcm90b3R5cGUsIFwibWVzc2FnZVwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX25hdGl2ZUVycm9yLm1lc3NhZ2U7IH0sXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIChtZXNzYWdlKSB7IHRoaXMuX25hdGl2ZUVycm9yLm1lc3NhZ2UgPSBtZXNzYWdlOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJhc2VFcnJvci5wcm90b3R5cGUsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX25hdGl2ZUVycm9yLm5hbWU7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQmFzZUVycm9yLnByb3RvdHlwZSwgXCJzdGFja1wiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX25hdGl2ZUVycm9yLnN0YWNrOyB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHsgdGhpcy5fbmF0aXZlRXJyb3Iuc3RhY2sgPSB2YWx1ZTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIEJhc2VFcnJvci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9uYXRpdmVFcnJvci50b1N0cmluZygpOyB9O1xuICAgICAgICByZXR1cm4gQmFzZUVycm9yO1xuICAgIH0oRXJyb3IpKTtcbiAgICAvKipcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIFdyYXBwZWRFcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyhXcmFwcGVkRXJyb3IsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIFdyYXBwZWRFcnJvcihtZXNzYWdlLCBlcnJvcikge1xuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgbWVzc2FnZSArIFwiIGNhdXNlZCBieTogXCIgKyAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBlcnJvcikpO1xuICAgICAgICAgICAgdGhpcy5vcmlnaW5hbEVycm9yID0gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyYXBwZWRFcnJvci5wcm90b3R5cGUsIFwic3RhY2tcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzLm9yaWdpbmFsRXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IHRoaXMub3JpZ2luYWxFcnJvciA6IHRoaXMuX25hdGl2ZUVycm9yKVxuICAgICAgICAgICAgICAgICAgICAuc3RhY2s7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFdyYXBwZWRFcnJvcjtcbiAgICB9KEJhc2VFcnJvcikpO1xuXG4gICAgdmFyIF9USFJPV19JRl9OT1RfRk9VTkQgPSBuZXcgT2JqZWN0KCk7XG4gICAgdmFyIFRIUk9XX0lGX05PVF9GT1VORCA9IF9USFJPV19JRl9OT1RfRk9VTkQ7XG4gICAgdmFyIF9OdWxsSW5qZWN0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBfTnVsbEluamVjdG9yKCkge1xuICAgICAgICB9XG4gICAgICAgIF9OdWxsSW5qZWN0b3IucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICh0b2tlbiwgbm90Rm91bmRWYWx1ZSkge1xuICAgICAgICAgICAgaWYgKG5vdEZvdW5kVmFsdWUgPT09IHZvaWQgMCkgeyBub3RGb3VuZFZhbHVlID0gX1RIUk9XX0lGX05PVF9GT1VORDsgfVxuICAgICAgICAgICAgaWYgKG5vdEZvdW5kVmFsdWUgPT09IF9USFJPV19JRl9OT1RfRk9VTkQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBwcm92aWRlciBmb3IgXCIgKyBzdHJpbmdpZnkodG9rZW4pICsgXCIhXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5vdEZvdW5kVmFsdWU7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfTnVsbEluamVjdG9yO1xuICAgIH0oKSk7XG4gICAgLyoqXG4gICAgICogQHdoYXRJdERvZXMgSW5qZWN0b3IgaW50ZXJmYWNlXG4gICAgICogQGhvd1RvVXNlXG4gICAgICogYGBgXG4gICAgICogY29uc3QgaW5qZWN0b3I6IEluamVjdG9yID0gLi4uO1xuICAgICAqIGluamVjdG9yLmdldCguLi4pO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogRm9yIG1vcmUgZGV0YWlscywgc2VlIHRoZSB7QGxpbmtEb2NzIGd1aWRlL2RlcGVuZGVuY3ktaW5qZWN0aW9uIFwiRGVwZW5kZW5jeSBJbmplY3Rpb24gR3VpZGVcIn0uXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZVxuICAgICAqXG4gICAgICoge0BleGFtcGxlIGNvcmUvZGkvdHMvaW5qZWN0b3Jfc3BlYy50cyByZWdpb249J0luamVjdG9yJ31cbiAgICAgKlxuICAgICAqIGBJbmplY3RvcmAgcmV0dXJucyBpdHNlbGYgd2hlbiBnaXZlbiBgSW5qZWN0b3JgIGFzIGEgdG9rZW46XG4gICAgICoge0BleGFtcGxlIGNvcmUvZGkvdHMvaW5qZWN0b3Jfc3BlYy50cyByZWdpb249J2luamVjdEluamVjdG9yJ31cbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgSW5qZWN0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBJbmplY3RvcigpIHtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0cmlldmVzIGFuIGluc3RhbmNlIGZyb20gdGhlIGluamVjdG9yIGJhc2VkIG9uIHRoZSBwcm92aWRlZCB0b2tlbi5cbiAgICAgICAgICogSWYgbm90IGZvdW5kOlxuICAgICAgICAgKiAtIFRocm93cyB7QGxpbmsgTm9Qcm92aWRlckVycm9yfSBpZiBubyBgbm90Rm91bmRWYWx1ZWAgdGhhdCBpcyBub3QgZXF1YWwgdG9cbiAgICAgICAgICogSW5qZWN0b3IuVEhST1dfSUZfTk9UX0ZPVU5EIGlzIGdpdmVuXG4gICAgICAgICAqIC0gUmV0dXJucyB0aGUgYG5vdEZvdW5kVmFsdWVgIG90aGVyd2lzZVxuICAgICAgICAgKi9cbiAgICAgICAgSW5qZWN0b3IucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICh0b2tlbiwgbm90Rm91bmRWYWx1ZSkgeyByZXR1cm4gdW5pbXBsZW1lbnRlZCgpOyB9O1xuICAgICAgICBJbmplY3Rvci5USFJPV19JRl9OT1RfRk9VTkQgPSBfVEhST1dfSUZfTk9UX0ZPVU5EO1xuICAgICAgICBJbmplY3Rvci5OVUxMID0gbmV3IF9OdWxsSW5qZWN0b3IoKTtcbiAgICAgICAgcmV0dXJuIEluamVjdG9yO1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgdmFyIF9fZXh0ZW5kcyQxID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG4gICAgZnVuY3Rpb24gZmluZEZpcnN0Q2xvc2VkQ3ljbGUoa2V5cykge1xuICAgICAgICB2YXIgcmVzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKHJlcy5pbmRleE9mKGtleXNbaV0pID4gLTEpIHtcbiAgICAgICAgICAgICAgICByZXMucHVzaChrZXlzW2ldKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzLnB1c2goa2V5c1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgZnVuY3Rpb24gY29uc3RydWN0UmVzb2x2aW5nUGF0aChrZXlzKSB7XG4gICAgICAgIGlmIChrZXlzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHZhciByZXZlcnNlZCA9IGZpbmRGaXJzdENsb3NlZEN5Y2xlKGtleXMuc2xpY2UoKS5yZXZlcnNlKCkpO1xuICAgICAgICAgICAgdmFyIHRva2VuU3RycyA9IHJldmVyc2VkLm1hcChmdW5jdGlvbiAoaykgeyByZXR1cm4gc3RyaW5naWZ5KGsudG9rZW4pOyB9KTtcbiAgICAgICAgICAgIHJldHVybiAnICgnICsgdG9rZW5TdHJzLmpvaW4oJyAtPiAnKSArICcpJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJhc2UgY2xhc3MgZm9yIGFsbCBlcnJvcnMgYXJpc2luZyBmcm9tIG1pc2NvbmZpZ3VyZWQgcHJvdmlkZXJzLlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgQWJzdHJhY3RQcm92aWRlckVycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDEoQWJzdHJhY3RQcm92aWRlckVycm9yLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBBYnN0cmFjdFByb3ZpZGVyRXJyb3IoaW5qZWN0b3IsIGtleSwgY29uc3RydWN0UmVzb2x2aW5nTWVzc2FnZSkge1xuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgJ0RJIEVycm9yJyk7XG4gICAgICAgICAgICB0aGlzLmtleXMgPSBba2V5XTtcbiAgICAgICAgICAgIHRoaXMuaW5qZWN0b3JzID0gW2luamVjdG9yXTtcbiAgICAgICAgICAgIHRoaXMuY29uc3RydWN0UmVzb2x2aW5nTWVzc2FnZSA9IGNvbnN0cnVjdFJlc29sdmluZ01lc3NhZ2U7XG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2UgPSB0aGlzLmNvbnN0cnVjdFJlc29sdmluZ01lc3NhZ2UodGhpcy5rZXlzKTtcbiAgICAgICAgfVxuICAgICAgICBBYnN0cmFjdFByb3ZpZGVyRXJyb3IucHJvdG90eXBlLmFkZEtleSA9IGZ1bmN0aW9uIChpbmplY3Rvciwga2V5KSB7XG4gICAgICAgICAgICB0aGlzLmluamVjdG9ycy5wdXNoKGluamVjdG9yKTtcbiAgICAgICAgICAgIHRoaXMua2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2UgPSB0aGlzLmNvbnN0cnVjdFJlc29sdmluZ01lc3NhZ2UodGhpcy5rZXlzKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIEFic3RyYWN0UHJvdmlkZXJFcnJvcjtcbiAgICB9KEJhc2VFcnJvcikpO1xuICAgIC8qKlxuICAgICAqIFRocm93biB3aGVuIHRyeWluZyB0byByZXRyaWV2ZSBhIGRlcGVuZGVuY3kgYnkga2V5IGZyb20ge0BsaW5rIEluamVjdG9yfSwgYnV0IHRoZVxuICAgICAqIHtAbGluayBJbmplY3Rvcn0gZG9lcyBub3QgaGF2ZSBhIHtAbGluayBQcm92aWRlcn0gZm9yIHRoZSBnaXZlbiBrZXkuXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQvdnE4RDNGUkI5YUdibldKcXRFUEU/cD1wcmV2aWV3KSlcbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBjbGFzcyBBIHtcbiAgICAgKiAgIGNvbnN0cnVjdG9yKGI6Qikge31cbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBleHBlY3QoKCkgPT4gSW5qZWN0b3IucmVzb2x2ZUFuZENyZWF0ZShbQV0pKS50b1Rocm93RXJyb3IoKTtcbiAgICAgKiBgYGBcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIE5vUHJvdmlkZXJFcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQxKE5vUHJvdmlkZXJFcnJvciwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gTm9Qcm92aWRlckVycm9yKGluamVjdG9yLCBrZXkpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGluamVjdG9yLCBrZXksIGZ1bmN0aW9uIChrZXlzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZpcnN0ID0gc3RyaW5naWZ5KGtleXNbMF0udG9rZW4pO1xuICAgICAgICAgICAgICAgIHJldHVybiBcIk5vIHByb3ZpZGVyIGZvciBcIiArIGZpcnN0ICsgXCIhXCIgKyBjb25zdHJ1Y3RSZXNvbHZpbmdQYXRoKGtleXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE5vUHJvdmlkZXJFcnJvcjtcbiAgICB9KEFic3RyYWN0UHJvdmlkZXJFcnJvcikpO1xuICAgIC8qKlxuICAgICAqIFRocm93biB3aGVuIGRlcGVuZGVuY2llcyBmb3JtIGEgY3ljbGUuXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQvd1lRZE5vczBUenFsM2VpMUVWOWo/cD1pbmZvKSlcbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiB2YXIgaW5qZWN0b3IgPSBJbmplY3Rvci5yZXNvbHZlQW5kQ3JlYXRlKFtcbiAgICAgKiAgIHtwcm92aWRlOiBcIm9uZVwiLCB1c2VGYWN0b3J5OiAodHdvKSA9PiBcInR3b1wiLCBkZXBzOiBbW25ldyBJbmplY3QoXCJ0d29cIildXX0sXG4gICAgICogICB7cHJvdmlkZTogXCJ0d29cIiwgdXNlRmFjdG9yeTogKG9uZSkgPT4gXCJvbmVcIiwgZGVwczogW1tuZXcgSW5qZWN0KFwib25lXCIpXV19XG4gICAgICogXSk7XG4gICAgICpcbiAgICAgKiBleHBlY3QoKCkgPT4gaW5qZWN0b3IuZ2V0KFwib25lXCIpKS50b1Rocm93RXJyb3IoKTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFJldHJpZXZpbmcgYEFgIG9yIGBCYCB0aHJvd3MgYSBgQ3ljbGljRGVwZW5kZW5jeUVycm9yYCBhcyB0aGUgZ3JhcGggYWJvdmUgY2Fubm90IGJlIGNvbnN0cnVjdGVkLlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgQ3ljbGljRGVwZW5kZW5jeUVycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDEoQ3ljbGljRGVwZW5kZW5jeUVycm9yLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBDeWNsaWNEZXBlbmRlbmN5RXJyb3IoaW5qZWN0b3IsIGtleSkge1xuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgaW5qZWN0b3IsIGtleSwgZnVuY3Rpb24gKGtleXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJDYW5ub3QgaW5zdGFudGlhdGUgY3ljbGljIGRlcGVuZGVuY3khXCIgKyBjb25zdHJ1Y3RSZXNvbHZpbmdQYXRoKGtleXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEN5Y2xpY0RlcGVuZGVuY3lFcnJvcjtcbiAgICB9KEFic3RyYWN0UHJvdmlkZXJFcnJvcikpO1xuICAgIC8qKlxuICAgICAqIFRocm93biB3aGVuIGEgY29uc3RydWN0aW5nIHR5cGUgcmV0dXJucyB3aXRoIGFuIEVycm9yLlxuICAgICAqXG4gICAgICogVGhlIGBJbnN0YW50aWF0aW9uRXJyb3JgIGNsYXNzIGNvbnRhaW5zIHRoZSBvcmlnaW5hbCBlcnJvciBwbHVzIHRoZSBkZXBlbmRlbmN5IGdyYXBoIHdoaWNoIGNhdXNlZFxuICAgICAqIHRoaXMgb2JqZWN0IHRvIGJlIGluc3RhbnRpYXRlZC5cbiAgICAgKlxuICAgICAqICMjIyBFeGFtcGxlIChbbGl2ZSBkZW1vXShodHRwOi8vcGxua3IuY28vZWRpdC83YVdZZGNxVFFzUDBlTnFFZFVBZj9wPXByZXZpZXcpKVxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNsYXNzIEEge1xuICAgICAqICAgY29uc3RydWN0b3IoKSB7XG4gICAgICogICAgIHRocm93IG5ldyBFcnJvcignbWVzc2FnZScpO1xuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBpbmplY3RvciA9IEluamVjdG9yLnJlc29sdmVBbmRDcmVhdGUoW0FdKTtcblxuICAgICAqIHRyeSB7XG4gICAgICogICBpbmplY3Rvci5nZXQoQSk7XG4gICAgICogfSBjYXRjaCAoZSkge1xuICAgICAqICAgZXhwZWN0KGUgaW5zdGFuY2VvZiBJbnN0YW50aWF0aW9uRXJyb3IpLnRvQmUodHJ1ZSk7XG4gICAgICogICBleHBlY3QoZS5vcmlnaW5hbEV4Y2VwdGlvbi5tZXNzYWdlKS50b0VxdWFsKFwibWVzc2FnZVwiKTtcbiAgICAgKiAgIGV4cGVjdChlLm9yaWdpbmFsU3RhY2spLnRvQmVEZWZpbmVkKCk7XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgSW5zdGFudGlhdGlvbkVycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDEoSW5zdGFudGlhdGlvbkVycm9yLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBJbnN0YW50aWF0aW9uRXJyb3IoaW5qZWN0b3IsIG9yaWdpbmFsRXhjZXB0aW9uLCBvcmlnaW5hbFN0YWNrLCBrZXkpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsICdESSBFcnJvcicsIG9yaWdpbmFsRXhjZXB0aW9uKTtcbiAgICAgICAgICAgIHRoaXMua2V5cyA9IFtrZXldO1xuICAgICAgICAgICAgdGhpcy5pbmplY3RvcnMgPSBbaW5qZWN0b3JdO1xuICAgICAgICB9XG4gICAgICAgIEluc3RhbnRpYXRpb25FcnJvci5wcm90b3R5cGUuYWRkS2V5ID0gZnVuY3Rpb24gKGluamVjdG9yLCBrZXkpIHtcbiAgICAgICAgICAgIHRoaXMuaW5qZWN0b3JzLnB1c2goaW5qZWN0b3IpO1xuICAgICAgICAgICAgdGhpcy5rZXlzLnB1c2goa2V5KTtcbiAgICAgICAgfTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEluc3RhbnRpYXRpb25FcnJvci5wcm90b3R5cGUsIFwibWVzc2FnZVwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgZmlyc3QgPSBzdHJpbmdpZnkodGhpcy5rZXlzWzBdLnRva2VuKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vcmlnaW5hbEVycm9yLm1lc3NhZ2UgKyBcIjogRXJyb3IgZHVyaW5nIGluc3RhbnRpYXRpb24gb2YgXCIgKyBmaXJzdCArIFwiIVwiICsgY29uc3RydWN0UmVzb2x2aW5nUGF0aCh0aGlzLmtleXMpICsgXCIuXCI7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEluc3RhbnRpYXRpb25FcnJvci5wcm90b3R5cGUsIFwiY2F1c2VLZXlcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmtleXNbMF07IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gSW5zdGFudGlhdGlvbkVycm9yO1xuICAgIH0oV3JhcHBlZEVycm9yKSk7XG4gICAgLyoqXG4gICAgICogVGhyb3duIHdoZW4gYW4gb2JqZWN0IG90aGVyIHRoZW4ge0BsaW5rIFByb3ZpZGVyfSAob3IgYFR5cGVgKSBpcyBwYXNzZWQgdG8ge0BsaW5rIEluamVjdG9yfVxuICAgICAqIGNyZWF0aW9uLlxuICAgICAqXG4gICAgICogIyMjIEV4YW1wbGUgKFtsaXZlIGRlbW9dKGh0dHA6Ly9wbG5rci5jby9lZGl0L1lhdENGYlBBTUNMMEpTU1E0bXZIP3A9cHJldmlldykpXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogZXhwZWN0KCgpID0+IEluamVjdG9yLnJlc29sdmVBbmRDcmVhdGUoW1wibm90IGEgdHlwZVwiXSkpLnRvVGhyb3dFcnJvcigpO1xuICAgICAqIGBgYFxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgSW52YWxpZFByb3ZpZGVyRXJyb3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMkMShJbnZhbGlkUHJvdmlkZXJFcnJvciwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gSW52YWxpZFByb3ZpZGVyRXJyb3IocHJvdmlkZXIpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIFwiSW52YWxpZCBwcm92aWRlciAtIG9ubHkgaW5zdGFuY2VzIG9mIFByb3ZpZGVyIGFuZCBUeXBlIGFyZSBhbGxvd2VkLCBnb3Q6IFwiICsgcHJvdmlkZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBJbnZhbGlkUHJvdmlkZXJFcnJvcjtcbiAgICB9KEJhc2VFcnJvcikpO1xuICAgIC8qKlxuICAgICAqIFRocm93biB3aGVuIHRoZSBjbGFzcyBoYXMgbm8gYW5ub3RhdGlvbiBpbmZvcm1hdGlvbi5cbiAgICAgKlxuICAgICAqIExhY2sgb2YgYW5ub3RhdGlvbiBpbmZvcm1hdGlvbiBwcmV2ZW50cyB0aGUge0BsaW5rIEluamVjdG9yfSBmcm9tIGRldGVybWluaW5nIHdoaWNoIGRlcGVuZGVuY2llc1xuICAgICAqIG5lZWQgdG8gYmUgaW5qZWN0ZWQgaW50byB0aGUgY29uc3RydWN0b3IuXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQvckhuWnRsTlM3dkpPUFE2cGNWa20/cD1wcmV2aWV3KSlcbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBjbGFzcyBBIHtcbiAgICAgKiAgIGNvbnN0cnVjdG9yKGIpIHt9XG4gICAgICogfVxuICAgICAqXG4gICAgICogZXhwZWN0KCgpID0+IEluamVjdG9yLnJlc29sdmVBbmRDcmVhdGUoW0FdKSkudG9UaHJvd0Vycm9yKCk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBUaGlzIGVycm9yIGlzIGFsc28gdGhyb3duIHdoZW4gdGhlIGNsYXNzIG5vdCBtYXJrZWQgd2l0aCB7QGxpbmsgSW5qZWN0YWJsZX0gaGFzIHBhcmFtZXRlciB0eXBlcy5cbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBjbGFzcyBCIHt9XG4gICAgICpcbiAgICAgKiBjbGFzcyBBIHtcbiAgICAgKiAgIGNvbnN0cnVjdG9yKGI6Qikge30gLy8gbm8gaW5mb3JtYXRpb24gYWJvdXQgdGhlIHBhcmFtZXRlciB0eXBlcyBvZiBBIGlzIGF2YWlsYWJsZSBhdCBydW50aW1lLlxuICAgICAqIH1cbiAgICAgKlxuICAgICAqIGV4cGVjdCgoKSA9PiBJbmplY3Rvci5yZXNvbHZlQW5kQ3JlYXRlKFtBLEJdKSkudG9UaHJvd0Vycm9yKCk7XG4gICAgICogYGBgXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBOb0Fubm90YXRpb25FcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQxKE5vQW5ub3RhdGlvbkVycm9yLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBOb0Fubm90YXRpb25FcnJvcih0eXBlT3JGdW5jLCBwYXJhbXMpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIE5vQW5ub3RhdGlvbkVycm9yLl9nZW5NZXNzYWdlKHR5cGVPckZ1bmMsIHBhcmFtcykpO1xuICAgICAgICB9XG4gICAgICAgIE5vQW5ub3RhdGlvbkVycm9yLl9nZW5NZXNzYWdlID0gZnVuY3Rpb24gKHR5cGVPckZ1bmMsIHBhcmFtcykge1xuICAgICAgICAgICAgdmFyIHNpZ25hdHVyZSA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gcGFyYW1zLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFyYW1ldGVyID0gcGFyYW1zW2ldO1xuICAgICAgICAgICAgICAgIGlmICghcGFyYW1ldGVyIHx8IHBhcmFtZXRlci5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBzaWduYXR1cmUucHVzaCgnPycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlLnB1c2gocGFyYW1ldGVyLm1hcChzdHJpbmdpZnkpLmpvaW4oJyAnKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICdDYW5ub3QgcmVzb2x2ZSBhbGwgcGFyYW1ldGVycyBmb3IgXFwnJyArIHN0cmluZ2lmeSh0eXBlT3JGdW5jKSArICdcXCcoJyArXG4gICAgICAgICAgICAgICAgc2lnbmF0dXJlLmpvaW4oJywgJykgKyAnKS4gJyArXG4gICAgICAgICAgICAgICAgJ01ha2Ugc3VyZSB0aGF0IGFsbCB0aGUgcGFyYW1ldGVycyBhcmUgZGVjb3JhdGVkIHdpdGggSW5qZWN0IG9yIGhhdmUgdmFsaWQgdHlwZSBhbm5vdGF0aW9ucyBhbmQgdGhhdCBcXCcnICtcbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkodHlwZU9yRnVuYykgKyAnXFwnIGlzIGRlY29yYXRlZCB3aXRoIEluamVjdGFibGUuJztcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIE5vQW5ub3RhdGlvbkVycm9yO1xuICAgIH0oQmFzZUVycm9yKSk7XG4gICAgLyoqXG4gICAgICogVGhyb3duIHdoZW4gZ2V0dGluZyBhbiBvYmplY3QgYnkgaW5kZXguXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQvYlJzMFNYMk9UUWlKenF2amdsOFA/cD1wcmV2aWV3KSlcbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBjbGFzcyBBIHt9XG4gICAgICpcbiAgICAgKiB2YXIgaW5qZWN0b3IgPSBJbmplY3Rvci5yZXNvbHZlQW5kQ3JlYXRlKFtBXSk7XG4gICAgICpcbiAgICAgKiBleHBlY3QoKCkgPT4gaW5qZWN0b3IuZ2V0QXQoMTAwKSkudG9UaHJvd0Vycm9yKCk7XG4gICAgICogYGBgXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBPdXRPZkJvdW5kc0Vycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDEoT3V0T2ZCb3VuZHNFcnJvciwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gT3V0T2ZCb3VuZHNFcnJvcihpbmRleCkge1xuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgXCJJbmRleCBcIiArIGluZGV4ICsgXCIgaXMgb3V0LW9mLWJvdW5kcy5cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE91dE9mQm91bmRzRXJyb3I7XG4gICAgfShCYXNlRXJyb3IpKTtcbiAgICAvLyBUT0RPOiBhZGQgYSB3b3JraW5nIGV4YW1wbGUgYWZ0ZXIgYWxwaGEzOCBpcyByZWxlYXNlZFxuICAgIC8qKlxuICAgICAqIFRocm93biB3aGVuIGEgbXVsdGkgcHJvdmlkZXIgYW5kIGEgcmVndWxhciBwcm92aWRlciBhcmUgYm91bmQgdG8gdGhlIHNhbWUgdG9rZW4uXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZVxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGV4cGVjdCgoKSA9PiBJbmplY3Rvci5yZXNvbHZlQW5kQ3JlYXRlKFtcbiAgICAgKiAgIHsgcHJvdmlkZTogXCJTdHJpbmdzXCIsIHVzZVZhbHVlOiBcInN0cmluZzFcIiwgbXVsdGk6IHRydWV9LFxuICAgICAqICAgeyBwcm92aWRlOiBcIlN0cmluZ3NcIiwgdXNlVmFsdWU6IFwic3RyaW5nMlwiLCBtdWx0aTogZmFsc2V9XG4gICAgICogXSkpLnRvVGhyb3dFcnJvcigpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHZhciBNaXhpbmdNdWx0aVByb3ZpZGVyc1dpdGhSZWd1bGFyUHJvdmlkZXJzRXJyb3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMkMShNaXhpbmdNdWx0aVByb3ZpZGVyc1dpdGhSZWd1bGFyUHJvdmlkZXJzRXJyb3IsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIE1peGluZ011bHRpUHJvdmlkZXJzV2l0aFJlZ3VsYXJQcm92aWRlcnNFcnJvcihwcm92aWRlcjEsIHByb3ZpZGVyMikge1xuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgJ0Nhbm5vdCBtaXggbXVsdGkgcHJvdmlkZXJzIGFuZCByZWd1bGFyIHByb3ZpZGVycywgZ290OiAnICsgcHJvdmlkZXIxLnRvU3RyaW5nKCkgKyAnICcgK1xuICAgICAgICAgICAgICAgIHByb3ZpZGVyMi50b1N0cmluZygpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTWl4aW5nTXVsdGlQcm92aWRlcnNXaXRoUmVndWxhclByb3ZpZGVyc0Vycm9yO1xuICAgIH0oQmFzZUVycm9yKSk7XG5cbiAgICAvKipcbiAgICAgKiBBIHVuaXF1ZSBvYmplY3QgdXNlZCBmb3IgcmV0cmlldmluZyBpdGVtcyBmcm9tIHRoZSB7QGxpbmsgUmVmbGVjdGl2ZUluamVjdG9yfS5cbiAgICAgKlxuICAgICAqIEtleXMgaGF2ZTpcbiAgICAgKiAtIGEgc3lzdGVtLXdpZGUgdW5pcXVlIGBpZGAuXG4gICAgICogLSBhIGB0b2tlbmAuXG4gICAgICpcbiAgICAgKiBgS2V5YCBpcyB1c2VkIGludGVybmFsbHkgYnkge0BsaW5rIFJlZmxlY3RpdmVJbmplY3Rvcn0gYmVjYXVzZSBpdHMgc3lzdGVtLXdpZGUgdW5pcXVlIGBpZGAgYWxsb3dzXG4gICAgICogdGhlXG4gICAgICogaW5qZWN0b3IgdG8gc3RvcmUgY3JlYXRlZCBvYmplY3RzIGluIGEgbW9yZSBlZmZpY2llbnQgd2F5LlxuICAgICAqXG4gICAgICogYEtleWAgc2hvdWxkIG5vdCBiZSBjcmVhdGVkIGRpcmVjdGx5LiB7QGxpbmsgUmVmbGVjdGl2ZUluamVjdG9yfSBjcmVhdGVzIGtleXMgYXV0b21hdGljYWxseSB3aGVuXG4gICAgICogcmVzb2x2aW5nXG4gICAgICogcHJvdmlkZXJzLlxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICB2YXIgUmVmbGVjdGl2ZUtleSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBSZWZsZWN0aXZlS2V5KHRva2VuLCBpZCkge1xuICAgICAgICAgICAgdGhpcy50b2tlbiA9IHRva2VuO1xuICAgICAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICAgICAgaWYgKCF0b2tlbikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVG9rZW4gbXVzdCBiZSBkZWZpbmVkIScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWZsZWN0aXZlS2V5LnByb3RvdHlwZSwgXCJkaXNwbGF5TmFtZVwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJldHVybnMgYSBzdHJpbmdpZmllZCB0b2tlbi5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzdHJpbmdpZnkodGhpcy50b2tlbik7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0cmlldmVzIGEgYEtleWAgZm9yIGEgdG9rZW4uXG4gICAgICAgICAqL1xuICAgICAgICBSZWZsZWN0aXZlS2V5LmdldCA9IGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgICAgICAgcmV0dXJuIF9nbG9iYWxLZXlSZWdpc3RyeS5nZXQocmVzb2x2ZUZvcndhcmRSZWYodG9rZW4pKTtcbiAgICAgICAgfTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlZmxlY3RpdmVLZXksIFwibnVtYmVyT2ZLZXlzXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHJldHVybnMgdGhlIG51bWJlciBvZiBrZXlzIHJlZ2lzdGVyZWQgaW4gdGhlIHN5c3RlbS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBfZ2xvYmFsS2V5UmVnaXN0cnkubnVtYmVyT2ZLZXlzOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFJlZmxlY3RpdmVLZXk7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB2YXIgS2V5UmVnaXN0cnkgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBLZXlSZWdpc3RyeSgpIHtcbiAgICAgICAgICAgIHRoaXMuX2FsbEtleXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIH1cbiAgICAgICAgS2V5UmVnaXN0cnkucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgICAgICAgaWYgKHRva2VuIGluc3RhbmNlb2YgUmVmbGVjdGl2ZUtleSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgICAgICBpZiAodGhpcy5fYWxsS2V5cy5oYXModG9rZW4pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FsbEtleXMuZ2V0KHRva2VuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBuZXdLZXkgPSBuZXcgUmVmbGVjdGl2ZUtleSh0b2tlbiwgUmVmbGVjdGl2ZUtleS5udW1iZXJPZktleXMpO1xuICAgICAgICAgICAgdGhpcy5fYWxsS2V5cy5zZXQodG9rZW4sIG5ld0tleSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3S2V5O1xuICAgICAgICB9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoS2V5UmVnaXN0cnkucHJvdG90eXBlLCBcIm51bWJlck9mS2V5c1wiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2FsbEtleXMuc2l6ZTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBLZXlSZWdpc3RyeTtcbiAgICB9KCkpO1xuICAgIHZhciBfZ2xvYmFsS2V5UmVnaXN0cnkgPSBuZXcgS2V5UmVnaXN0cnkoKTtcblxuICAgIC8vIFNhZmFyaSBkb2Vzbid0IGltcGxlbWVudCBNYXBJdGVyYXRvci5uZXh0KCksIHdoaWNoIGlzIHVzZWQgaXMgVHJhY2V1cidzIHBvbHlmaWxsIG9mIEFycmF5LmZyb21cbiAgICAvLyBUT0RPKG1sYXZhbCk6IHJlbW92ZSB0aGUgd29yayBhcm91bmQgb25jZSB3ZSBoYXZlIGEgd29ya2luZyBwb2x5ZmlsbCBvZiBBcnJheS5mcm9tXG4gICAgdmFyIF9hcnJheUZyb21NYXAgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKChuZXcgTWFwKCkpLnZhbHVlcygpLm5leHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlQXJyYXlGcm9tTWFwKG0sIGdldFZhbHVlcykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0VmFsdWVzID8gQXJyYXkuZnJvbShtLnZhbHVlcygpKSA6IEFycmF5LmZyb20obS5rZXlzKCkpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlQXJyYXlGcm9tTWFwV2l0aEZvcmVhY2gobSwgZ2V0VmFsdWVzKSB7XG4gICAgICAgICAgICB2YXIgcmVzID0gbmV3IEFycmF5KG0uc2l6ZSksIGkgPSAwO1xuICAgICAgICAgICAgbS5mb3JFYWNoKGZ1bmN0aW9uICh2LCBrKSB7XG4gICAgICAgICAgICAgICAgcmVzW2ldID0gZ2V0VmFsdWVzID8gdiA6IGs7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9O1xuICAgIH0pKCk7XG4gICAgdmFyIE1hcFdyYXBwZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBNYXBXcmFwcGVyKCkge1xuICAgICAgICB9XG4gICAgICAgIE1hcFdyYXBwZXIuY3JlYXRlRnJvbVN0cmluZ01hcCA9IGZ1bmN0aW9uIChzdHJpbmdNYXApIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICBmb3IgKHZhciBwcm9wIGluIHN0cmluZ01hcCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5zZXQocHJvcCwgc3RyaW5nTWFwW3Byb3BdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgICAgIE1hcFdyYXBwZXIua2V5cyA9IGZ1bmN0aW9uIChtKSB7IHJldHVybiBfYXJyYXlGcm9tTWFwKG0sIGZhbHNlKTsgfTtcbiAgICAgICAgTWFwV3JhcHBlci52YWx1ZXMgPSBmdW5jdGlvbiAobSkgeyByZXR1cm4gX2FycmF5RnJvbU1hcChtLCB0cnVlKTsgfTtcbiAgICAgICAgcmV0dXJuIE1hcFdyYXBwZXI7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBXcmFwcyBKYXZhc2NyaXB0IE9iamVjdHNcbiAgICAgKi9cbiAgICB2YXIgU3RyaW5nTWFwV3JhcHBlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFN0cmluZ01hcFdyYXBwZXIoKSB7XG4gICAgICAgIH1cbiAgICAgICAgU3RyaW5nTWFwV3JhcHBlci5tZXJnZSA9IGZ1bmN0aW9uIChtMSwgbTIpIHtcbiAgICAgICAgICAgIHZhciBtID0ge307XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gT2JqZWN0LmtleXMobTEpOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBrID0gX2FbX2ldO1xuICAgICAgICAgICAgICAgIG1ba10gPSBtMVtrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIF9iID0gMCwgX2MgPSBPYmplY3Qua2V5cyhtMik7IF9iIDwgX2MubGVuZ3RoOyBfYisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGsgPSBfY1tfYl07XG4gICAgICAgICAgICAgICAgbVtrXSA9IG0yW2tdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG07XG4gICAgICAgIH07XG4gICAgICAgIFN0cmluZ01hcFdyYXBwZXIuZXF1YWxzID0gZnVuY3Rpb24gKG0xLCBtMikge1xuICAgICAgICAgICAgdmFyIGsxID0gT2JqZWN0LmtleXMobTEpO1xuICAgICAgICAgICAgdmFyIGsyID0gT2JqZWN0LmtleXMobTIpO1xuICAgICAgICAgICAgaWYgKGsxLmxlbmd0aCAhPSBrMi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGsxLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IGsxW2ldO1xuICAgICAgICAgICAgICAgIGlmIChtMVtrZXldICE9PSBtMltrZXldKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFN0cmluZ01hcFdyYXBwZXI7XG4gICAgfSgpKTtcbiAgICB2YXIgTGlzdFdyYXBwZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBMaXN0V3JhcHBlcigpIHtcbiAgICAgICAgfVxuICAgICAgICBMaXN0V3JhcHBlci5yZW1vdmVBbGwgPSBmdW5jdGlvbiAobGlzdCwgaXRlbXMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBsaXN0LmluZGV4T2YoaXRlbXNbaV0pO1xuICAgICAgICAgICAgICAgIGxpc3Quc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgTGlzdFdyYXBwZXIucmVtb3ZlID0gZnVuY3Rpb24gKGxpc3QsIGVsKSB7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSBsaXN0LmluZGV4T2YoZWwpO1xuICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICBsaXN0LnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG4gICAgICAgIExpc3RXcmFwcGVyLmVxdWFscyA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICBpZiAoYS5sZW5ndGggIT0gYi5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFbaV0gIT09IGJbaV0pXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICBMaXN0V3JhcHBlci5tYXhpbXVtID0gZnVuY3Rpb24gKGxpc3QsIHByZWRpY2F0ZSkge1xuICAgICAgICAgICAgaWYgKGxpc3QubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBzb2x1dGlvbiA9IG51bGw7XG4gICAgICAgICAgICB2YXIgbWF4VmFsdWUgPSAtSW5maW5pdHk7XG4gICAgICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGlzdC5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY2FuZGlkYXRlID0gbGlzdFtpbmRleF07XG4gICAgICAgICAgICAgICAgaWYgKGNhbmRpZGF0ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgY2FuZGlkYXRlVmFsdWUgPSBwcmVkaWNhdGUoY2FuZGlkYXRlKTtcbiAgICAgICAgICAgICAgICBpZiAoY2FuZGlkYXRlVmFsdWUgPiBtYXhWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBzb2x1dGlvbiA9IGNhbmRpZGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgbWF4VmFsdWUgPSBjYW5kaWRhdGVWYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc29sdXRpb247XG4gICAgICAgIH07XG4gICAgICAgIExpc3RXcmFwcGVyLmZsYXR0ZW4gPSBmdW5jdGlvbiAobGlzdCkge1xuICAgICAgICAgICAgdmFyIHRhcmdldCA9IFtdO1xuICAgICAgICAgICAgX2ZsYXR0ZW5BcnJheShsaXN0LCB0YXJnZXQpO1xuICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIExpc3RXcmFwcGVyO1xuICAgIH0oKSk7XG4gICAgZnVuY3Rpb24gX2ZsYXR0ZW5BcnJheShzb3VyY2UsIHRhcmdldCkge1xuICAgICAgICBpZiAoaXNQcmVzZW50KHNvdXJjZSkpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc291cmNlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSBzb3VyY2VbaV07XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgX2ZsYXR0ZW5BcnJheShpdGVtLCB0YXJnZXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzTGlzdExpa2VJdGVyYWJsZShvYmopIHtcbiAgICAgICAgaWYgKCFpc0pzT2JqZWN0KG9iaikpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KG9iaikgfHxcbiAgICAgICAgICAgICghKG9iaiBpbnN0YW5jZW9mIE1hcCkgJiZcbiAgICAgICAgICAgICAgICBnZXRTeW1ib2xJdGVyYXRvcigpIGluIG9iaik7IC8vIEpTIEl0ZXJhYmxlIGhhdmUgYSBTeW1ib2wuaXRlcmF0b3IgcHJvcFxuICAgIH1cbiAgICBmdW5jdGlvbiBhcmVJdGVyYWJsZXNFcXVhbChhLCBiLCBjb21wYXJhdG9yKSB7XG4gICAgICAgIHZhciBpdGVyYXRvcjEgPSBhW2dldFN5bWJvbEl0ZXJhdG9yKCldKCk7XG4gICAgICAgIHZhciBpdGVyYXRvcjIgPSBiW2dldFN5bWJvbEl0ZXJhdG9yKCldKCk7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICB2YXIgaXRlbTEgPSBpdGVyYXRvcjEubmV4dCgpO1xuICAgICAgICAgICAgdmFyIGl0ZW0yID0gaXRlcmF0b3IyLm5leHQoKTtcbiAgICAgICAgICAgIGlmIChpdGVtMS5kb25lICYmIGl0ZW0yLmRvbmUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBpZiAoaXRlbTEuZG9uZSB8fCBpdGVtMi5kb25lKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGlmICghY29tcGFyYXRvcihpdGVtMS52YWx1ZSwgaXRlbTIudmFsdWUpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBpdGVyYXRlTGlzdExpa2Uob2JqLCBmbikge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iai5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGZuKG9ialtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgaXRlcmF0b3IgPSBvYmpbZ2V0U3ltYm9sSXRlcmF0b3IoKV0oKTtcbiAgICAgICAgICAgIHZhciBpdGVtID0gdm9pZCAwO1xuICAgICAgICAgICAgd2hpbGUgKCEoKGl0ZW0gPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpKSB7XG4gICAgICAgICAgICAgICAgZm4oaXRlbS52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQHdoYXRJdERvZXMgUmVwcmVzZW50cyBhIHR5cGUgdGhhdCBhIENvbXBvbmVudCBvciBvdGhlciBvYmplY3QgaXMgaW5zdGFuY2VzIG9mLlxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICpcbiAgICAgKiBBbiBleGFtcGxlIG9mIGEgYFR5cGVgIGlzIGBNeUN1c3RvbUNvbXBvbmVudGAgY2xhc3MsIHdoaWNoIGluIEphdmFTY3JpcHQgaXMgYmUgcmVwcmVzZW50ZWQgYnlcbiAgICAgKiB0aGUgYE15Q3VzdG9tQ29tcG9uZW50YCBjb25zdHJ1Y3RvciBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgVHlwZSA9IEZ1bmN0aW9uO1xuXG4gICAgdmFyIFJlZmxlY3Rpb25DYXBhYmlsaXRpZXMgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBSZWZsZWN0aW9uQ2FwYWJpbGl0aWVzKHJlZmxlY3QpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlZmxlY3QgPSByZWZsZWN0IHx8IGdsb2JhbCQxLlJlZmxlY3Q7XG4gICAgICAgIH1cbiAgICAgICAgUmVmbGVjdGlvbkNhcGFiaWxpdGllcy5wcm90b3R5cGUuaXNSZWZsZWN0aW9uRW5hYmxlZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRydWU7IH07XG4gICAgICAgIFJlZmxlY3Rpb25DYXBhYmlsaXRpZXMucHJvdG90eXBlLmZhY3RvcnkgPSBmdW5jdGlvbiAodCkgeyByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgYXJnc1tfaSAtIDBdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgKHQuYmluZC5hcHBseSh0LCBbdm9pZCAwXS5jb25jYXQoYXJncykpKSgpO1xuICAgICAgICB9OyB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIFJlZmxlY3Rpb25DYXBhYmlsaXRpZXMucHJvdG90eXBlLl96aXBUeXBlc0FuZEFubm90YXRpb25zID0gZnVuY3Rpb24gKHBhcmFtVHlwZXMsIHBhcmFtQW5ub3RhdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHBhcmFtVHlwZXMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IEFycmF5KHBhcmFtQW5ub3RhdGlvbnMubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBBcnJheShwYXJhbVR5cGVzLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc3VsdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIC8vIFRTIG91dHB1dHMgT2JqZWN0IGZvciBwYXJhbWV0ZXJzIHdpdGhvdXQgdHlwZXMsIHdoaWxlIFRyYWNldXIgb21pdHNcbiAgICAgICAgICAgICAgICAvLyB0aGUgYW5ub3RhdGlvbnMuIEZvciBub3cgd2UgcHJlc2VydmUgdGhlIFRyYWNldXIgYmVoYXZpb3IgdG8gYWlkXG4gICAgICAgICAgICAgICAgLy8gbWlncmF0aW9uLCBidXQgdGhpcyBjYW4gYmUgcmV2aXNpdGVkLlxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcGFyYW1UeXBlcyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2ldID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhcmFtVHlwZXNbaV0gIT0gT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtpXSA9IFtwYXJhbVR5cGVzW2ldXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtpXSA9IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocGFyYW1Bbm5vdGF0aW9ucyAmJiBpc1ByZXNlbnQocGFyYW1Bbm5vdGF0aW9uc1tpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2ldID0gcmVzdWx0W2ldLmNvbmNhdChwYXJhbUFubm90YXRpb25zW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgICAgICBSZWZsZWN0aW9uQ2FwYWJpbGl0aWVzLnByb3RvdHlwZS5wYXJhbWV0ZXJzID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgICAgIC8vIFByZWZlciB0aGUgZGlyZWN0IEFQSS5cbiAgICAgICAgICAgIGlmICh0eXBlLnBhcmFtZXRlcnMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZS5wYXJhbWV0ZXJzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQVBJIG9mIHRzaWNrbGUgZm9yIGxvd2VyaW5nIGRlY29yYXRvcnMgdG8gcHJvcGVydGllcyBvbiB0aGUgY2xhc3MuXG4gICAgICAgICAgICBpZiAodHlwZS5jdG9yUGFyYW1ldGVycykge1xuICAgICAgICAgICAgICAgIHZhciBjdG9yUGFyYW1ldGVycyA9IHR5cGUuY3RvclBhcmFtZXRlcnM7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmFtVHlwZXMgPSBjdG9yUGFyYW1ldGVycy5tYXAoZnVuY3Rpb24gKGN0b3JQYXJhbSkgeyByZXR1cm4gY3RvclBhcmFtICYmIGN0b3JQYXJhbS50eXBlOyB9KTtcbiAgICAgICAgICAgICAgICB2YXIgcGFyYW1Bbm5vdGF0aW9ucyA9IGN0b3JQYXJhbWV0ZXJzLm1hcChmdW5jdGlvbiAoY3RvclBhcmFtKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjdG9yUGFyYW0gJiYgY29udmVydFRzaWNrbGVEZWNvcmF0b3JJbnRvTWV0YWRhdGEoY3RvclBhcmFtLmRlY29yYXRvcnMpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl96aXBUeXBlc0FuZEFubm90YXRpb25zKHBhcmFtVHlwZXMsIHBhcmFtQW5ub3RhdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQVBJIGZvciBtZXRhZGF0YSBjcmVhdGVkIGJ5IGludm9raW5nIHRoZSBkZWNvcmF0b3JzLlxuICAgICAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLl9yZWZsZWN0KSAmJiBpc1ByZXNlbnQodGhpcy5fcmVmbGVjdC5nZXRNZXRhZGF0YSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFyYW1Bbm5vdGF0aW9ucyA9IHRoaXMuX3JlZmxlY3QuZ2V0TWV0YWRhdGEoJ3BhcmFtZXRlcnMnLCB0eXBlKTtcbiAgICAgICAgICAgICAgICB2YXIgcGFyYW1UeXBlcyA9IHRoaXMuX3JlZmxlY3QuZ2V0TWV0YWRhdGEoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgdHlwZSk7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtVHlwZXMgfHwgcGFyYW1Bbm5vdGF0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5femlwVHlwZXNBbmRBbm5vdGF0aW9ucyhwYXJhbVR5cGVzLCBwYXJhbUFubm90YXRpb25zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUaGUgYXJyYXkgaGFzIHRvIGJlIGZpbGxlZCB3aXRoIGB1bmRlZmluZWRgIGJlY2F1c2UgaG9sZXMgd291bGQgYmUgc2tpcHBlZCBieSBgc29tZWBcbiAgICAgICAgICAgIHJldHVybiBuZXcgQXJyYXkodHlwZS5sZW5ndGgpLmZpbGwodW5kZWZpbmVkKTtcbiAgICAgICAgfTtcbiAgICAgICAgUmVmbGVjdGlvbkNhcGFiaWxpdGllcy5wcm90b3R5cGUuYW5ub3RhdGlvbnMgPSBmdW5jdGlvbiAodHlwZU9yRnVuYykge1xuICAgICAgICAgICAgLy8gUHJlZmVyIHRoZSBkaXJlY3QgQVBJLlxuICAgICAgICAgICAgaWYgKHR5cGVPckZ1bmMuYW5ub3RhdGlvbnMpIHtcbiAgICAgICAgICAgICAgICB2YXIgYW5ub3RhdGlvbnMgPSB0eXBlT3JGdW5jLmFubm90YXRpb25zO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYW5ub3RhdGlvbnMgPT09ICdmdW5jdGlvbicgJiYgYW5ub3RhdGlvbnMuYW5ub3RhdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgYW5ub3RhdGlvbnMgPSBhbm5vdGF0aW9ucy5hbm5vdGF0aW9ucztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFubm90YXRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQVBJIG9mIHRzaWNrbGUgZm9yIGxvd2VyaW5nIGRlY29yYXRvcnMgdG8gcHJvcGVydGllcyBvbiB0aGUgY2xhc3MuXG4gICAgICAgICAgICBpZiAodHlwZU9yRnVuYy5kZWNvcmF0b3JzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnZlcnRUc2lja2xlRGVjb3JhdG9ySW50b01ldGFkYXRhKHR5cGVPckZ1bmMuZGVjb3JhdG9ycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBUEkgZm9yIG1ldGFkYXRhIGNyZWF0ZWQgYnkgaW52b2tpbmcgdGhlIGRlY29yYXRvcnMuXG4gICAgICAgICAgICBpZiAodGhpcy5fcmVmbGVjdCAmJiB0aGlzLl9yZWZsZWN0LmdldE1ldGFkYXRhKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFubm90YXRpb25zID0gdGhpcy5fcmVmbGVjdC5nZXRNZXRhZGF0YSgnYW5ub3RhdGlvbnMnLCB0eXBlT3JGdW5jKTtcbiAgICAgICAgICAgICAgICBpZiAoYW5ub3RhdGlvbnMpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhbm5vdGF0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfTtcbiAgICAgICAgUmVmbGVjdGlvbkNhcGFiaWxpdGllcy5wcm90b3R5cGUucHJvcE1ldGFkYXRhID0gZnVuY3Rpb24gKHR5cGVPckZ1bmMpIHtcbiAgICAgICAgICAgIC8vIFByZWZlciB0aGUgZGlyZWN0IEFQSS5cbiAgICAgICAgICAgIGlmICh0eXBlT3JGdW5jLnByb3BNZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgIHZhciBwcm9wTWV0YWRhdGEgPSB0eXBlT3JGdW5jLnByb3BNZXRhZGF0YTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHByb3BNZXRhZGF0YSA9PT0gJ2Z1bmN0aW9uJyAmJiBwcm9wTWV0YWRhdGEucHJvcE1ldGFkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3BNZXRhZGF0YSA9IHByb3BNZXRhZGF0YS5wcm9wTWV0YWRhdGE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBwcm9wTWV0YWRhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBUEkgb2YgdHNpY2tsZSBmb3IgbG93ZXJpbmcgZGVjb3JhdG9ycyB0byBwcm9wZXJ0aWVzIG9uIHRoZSBjbGFzcy5cbiAgICAgICAgICAgIGlmICh0eXBlT3JGdW5jLnByb3BEZWNvcmF0b3JzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByb3BEZWNvcmF0b3JzXzEgPSB0eXBlT3JGdW5jLnByb3BEZWNvcmF0b3JzO1xuICAgICAgICAgICAgICAgIHZhciBwcm9wTWV0YWRhdGFfMSA9IHt9O1xuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHByb3BEZWNvcmF0b3JzXzEpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvcE1ldGFkYXRhXzFbcHJvcF0gPSBjb252ZXJ0VHNpY2tsZURlY29yYXRvckludG9NZXRhZGF0YShwcm9wRGVjb3JhdG9yc18xW3Byb3BdKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvcE1ldGFkYXRhXzE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBUEkgZm9yIG1ldGFkYXRhIGNyZWF0ZWQgYnkgaW52b2tpbmcgdGhlIGRlY29yYXRvcnMuXG4gICAgICAgICAgICBpZiAodGhpcy5fcmVmbGVjdCAmJiB0aGlzLl9yZWZsZWN0LmdldE1ldGFkYXRhKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByb3BNZXRhZGF0YSA9IHRoaXMuX3JlZmxlY3QuZ2V0TWV0YWRhdGEoJ3Byb3BNZXRhZGF0YScsIHR5cGVPckZ1bmMpO1xuICAgICAgICAgICAgICAgIGlmIChwcm9wTWV0YWRhdGEpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9wTWV0YWRhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgIH07XG4gICAgICAgIFJlZmxlY3Rpb25DYXBhYmlsaXRpZXMucHJvdG90eXBlLmhhc0xpZmVjeWNsZUhvb2sgPSBmdW5jdGlvbiAodHlwZSwgbGNQcm9wZXJ0eSkge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGUgaW5zdGFuY2VvZiBUeXBlICYmIGxjUHJvcGVydHkgaW4gdHlwZS5wcm90b3R5cGU7XG4gICAgICAgIH07XG4gICAgICAgIFJlZmxlY3Rpb25DYXBhYmlsaXRpZXMucHJvdG90eXBlLmdldHRlciA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBuZXcgRnVuY3Rpb24oJ28nLCAncmV0dXJuIG8uJyArIG5hbWUgKyAnOycpOyB9O1xuICAgICAgICBSZWZsZWN0aW9uQ2FwYWJpbGl0aWVzLnByb3RvdHlwZS5zZXR0ZXIgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbignbycsICd2JywgJ3JldHVybiBvLicgKyBuYW1lICsgJyA9IHY7Jyk7XG4gICAgICAgIH07XG4gICAgICAgIFJlZmxlY3Rpb25DYXBhYmlsaXRpZXMucHJvdG90eXBlLm1ldGhvZCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICB2YXIgZnVuY3Rpb25Cb2R5ID0gXCJpZiAoIW8uXCIgKyBuYW1lICsgXCIpIHRocm93IG5ldyBFcnJvcignXFxcIlwiICsgbmFtZSArIFwiXFxcIiBpcyB1bmRlZmluZWQnKTtcXG4gICAgICAgIHJldHVybiBvLlwiICsgbmFtZSArIFwiLmFwcGx5KG8sIGFyZ3MpO1wiO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbignbycsICdhcmdzJywgZnVuY3Rpb25Cb2R5KTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gVGhlcmUgaXMgbm90IGEgY29uY2VwdCBvZiBpbXBvcnQgdXJpIGluIEpzLCBidXQgdGhpcyBpcyB1c2VmdWwgaW4gZGV2ZWxvcGluZyBEYXJ0IGFwcGxpY2F0aW9ucy5cbiAgICAgICAgUmVmbGVjdGlvbkNhcGFiaWxpdGllcy5wcm90b3R5cGUuaW1wb3J0VXJpID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgICAgIC8vIFN0YXRpY1N5bWJvbFxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlWydmaWxlUGF0aCddKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVbJ2ZpbGVQYXRoJ107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSdW50aW1lIHR5cGVcbiAgICAgICAgICAgIHJldHVybiBcIi4vXCIgKyBzdHJpbmdpZnkodHlwZSk7XG4gICAgICAgIH07XG4gICAgICAgIFJlZmxlY3Rpb25DYXBhYmlsaXRpZXMucHJvdG90eXBlLnJlc29sdmVJZGVudGlmaWVyID0gZnVuY3Rpb24gKG5hbWUsIG1vZHVsZVVybCwgcnVudGltZSkgeyByZXR1cm4gcnVudGltZTsgfTtcbiAgICAgICAgUmVmbGVjdGlvbkNhcGFiaWxpdGllcy5wcm90b3R5cGUucmVzb2x2ZUVudW0gPSBmdW5jdGlvbiAoZW51bUlkZW50aWZpZXIsIG5hbWUpIHsgcmV0dXJuIGVudW1JZGVudGlmaWVyW25hbWVdOyB9O1xuICAgICAgICByZXR1cm4gUmVmbGVjdGlvbkNhcGFiaWxpdGllcztcbiAgICB9KCkpO1xuICAgIGZ1bmN0aW9uIGNvbnZlcnRUc2lja2xlRGVjb3JhdG9ySW50b01ldGFkYXRhKGRlY29yYXRvckludm9jYXRpb25zKSB7XG4gICAgICAgIGlmICghZGVjb3JhdG9ySW52b2NhdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVjb3JhdG9ySW52b2NhdGlvbnMubWFwKGZ1bmN0aW9uIChkZWNvcmF0b3JJbnZvY2F0aW9uKSB7XG4gICAgICAgICAgICB2YXIgZGVjb3JhdG9yVHlwZSA9IGRlY29yYXRvckludm9jYXRpb24udHlwZTtcbiAgICAgICAgICAgIHZhciBhbm5vdGF0aW9uQ2xzID0gZGVjb3JhdG9yVHlwZS5hbm5vdGF0aW9uQ2xzO1xuICAgICAgICAgICAgdmFyIGFubm90YXRpb25BcmdzID0gZGVjb3JhdG9ySW52b2NhdGlvbi5hcmdzID8gZGVjb3JhdG9ySW52b2NhdGlvbi5hcmdzIDogW107XG4gICAgICAgICAgICByZXR1cm4gbmV3IChhbm5vdGF0aW9uQ2xzLmJpbmQuYXBwbHkoYW5ub3RhdGlvbkNscywgW3ZvaWQgMF0uY29uY2F0KGFubm90YXRpb25BcmdzKSkpKCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBQcm92aWRlcyByZWFkLW9ubHkgYWNjZXNzIHRvIHJlZmxlY3Rpb24gZGF0YSBhYm91dCBzeW1ib2xzLiBVc2VkIGludGVybmFsbHkgYnkgQW5ndWxhclxuICAgICAqIHRvIHBvd2VyIGRlcGVuZGVuY3kgaW5qZWN0aW9uIGFuZCBjb21waWxhdGlvbi5cbiAgICAgKi9cbiAgICB2YXIgUmVmbGVjdG9yUmVhZGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gUmVmbGVjdG9yUmVhZGVyKCkge1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBSZWZsZWN0b3JSZWFkZXI7XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICB2YXIgX19leHRlbmRzJDIgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQcm92aWRlcyBhY2Nlc3MgdG8gcmVmbGVjdGlvbiBkYXRhIGFib3V0IHN5bWJvbHMuIFVzZWQgaW50ZXJuYWxseSBieSBBbmd1bGFyXG4gICAgICogdG8gcG93ZXIgZGVwZW5kZW5jeSBpbmplY3Rpb24gYW5kIGNvbXBpbGF0aW9uLlxuICAgICAqL1xuICAgIHZhciBSZWZsZWN0b3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMkMihSZWZsZWN0b3IsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIFJlZmxlY3RvcihyZWZsZWN0aW9uQ2FwYWJpbGl0aWVzKSB7XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMucmVmbGVjdGlvbkNhcGFiaWxpdGllcyA9IHJlZmxlY3Rpb25DYXBhYmlsaXRpZXM7XG4gICAgICAgIH1cbiAgICAgICAgUmVmbGVjdG9yLnByb3RvdHlwZS51cGRhdGVDYXBhYmlsaXRpZXMgPSBmdW5jdGlvbiAoY2FwcykgeyB0aGlzLnJlZmxlY3Rpb25DYXBhYmlsaXRpZXMgPSBjYXBzOyB9O1xuICAgICAgICBSZWZsZWN0b3IucHJvdG90eXBlLmZhY3RvcnkgPSBmdW5jdGlvbiAodHlwZSkgeyByZXR1cm4gdGhpcy5yZWZsZWN0aW9uQ2FwYWJpbGl0aWVzLmZhY3RvcnkodHlwZSk7IH07XG4gICAgICAgIFJlZmxlY3Rvci5wcm90b3R5cGUucGFyYW1ldGVycyA9IGZ1bmN0aW9uICh0eXBlT3JGdW5jKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZWZsZWN0aW9uQ2FwYWJpbGl0aWVzLnBhcmFtZXRlcnModHlwZU9yRnVuYyk7XG4gICAgICAgIH07XG4gICAgICAgIFJlZmxlY3Rvci5wcm90b3R5cGUuYW5ub3RhdGlvbnMgPSBmdW5jdGlvbiAodHlwZU9yRnVuYykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVmbGVjdGlvbkNhcGFiaWxpdGllcy5hbm5vdGF0aW9ucyh0eXBlT3JGdW5jKTtcbiAgICAgICAgfTtcbiAgICAgICAgUmVmbGVjdG9yLnByb3RvdHlwZS5wcm9wTWV0YWRhdGEgPSBmdW5jdGlvbiAodHlwZU9yRnVuYykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVmbGVjdGlvbkNhcGFiaWxpdGllcy5wcm9wTWV0YWRhdGEodHlwZU9yRnVuYyk7XG4gICAgICAgIH07XG4gICAgICAgIFJlZmxlY3Rvci5wcm90b3R5cGUuaGFzTGlmZWN5Y2xlSG9vayA9IGZ1bmN0aW9uICh0eXBlLCBsY1Byb3BlcnR5KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZWZsZWN0aW9uQ2FwYWJpbGl0aWVzLmhhc0xpZmVjeWNsZUhvb2sodHlwZSwgbGNQcm9wZXJ0eSk7XG4gICAgICAgIH07XG4gICAgICAgIFJlZmxlY3Rvci5wcm90b3R5cGUuZ2V0dGVyID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIHRoaXMucmVmbGVjdGlvbkNhcGFiaWxpdGllcy5nZXR0ZXIobmFtZSk7IH07XG4gICAgICAgIFJlZmxlY3Rvci5wcm90b3R5cGUuc2V0dGVyID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIHRoaXMucmVmbGVjdGlvbkNhcGFiaWxpdGllcy5zZXR0ZXIobmFtZSk7IH07XG4gICAgICAgIFJlZmxlY3Rvci5wcm90b3R5cGUubWV0aG9kID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIHRoaXMucmVmbGVjdGlvbkNhcGFiaWxpdGllcy5tZXRob2QobmFtZSk7IH07XG4gICAgICAgIFJlZmxlY3Rvci5wcm90b3R5cGUuaW1wb3J0VXJpID0gZnVuY3Rpb24gKHR5cGUpIHsgcmV0dXJuIHRoaXMucmVmbGVjdGlvbkNhcGFiaWxpdGllcy5pbXBvcnRVcmkodHlwZSk7IH07XG4gICAgICAgIFJlZmxlY3Rvci5wcm90b3R5cGUucmVzb2x2ZUlkZW50aWZpZXIgPSBmdW5jdGlvbiAobmFtZSwgbW9kdWxlVXJsLCBydW50aW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZWZsZWN0aW9uQ2FwYWJpbGl0aWVzLnJlc29sdmVJZGVudGlmaWVyKG5hbWUsIG1vZHVsZVVybCwgcnVudGltZSk7XG4gICAgICAgIH07XG4gICAgICAgIFJlZmxlY3Rvci5wcm90b3R5cGUucmVzb2x2ZUVudW0gPSBmdW5jdGlvbiAoaWRlbnRpZmllciwgbmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVmbGVjdGlvbkNhcGFiaWxpdGllcy5yZXNvbHZlRW51bShpZGVudGlmaWVyLCBuYW1lKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFJlZmxlY3RvcjtcbiAgICB9KFJlZmxlY3RvclJlYWRlcikpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHtAbGluayBSZWZsZWN0b3J9IHVzZWQgaW50ZXJuYWxseSBpbiBBbmd1bGFyIHRvIGFjY2VzcyBtZXRhZGF0YVxuICAgICAqIGFib3V0IHN5bWJvbHMuXG4gICAgICovXG4gICAgdmFyIHJlZmxlY3RvciA9IG5ldyBSZWZsZWN0b3IobmV3IFJlZmxlY3Rpb25DYXBhYmlsaXRpZXMoKSk7XG5cbiAgICAvKipcbiAgICAgKiBgRGVwZW5kZW5jeWAgaXMgdXNlZCBieSB0aGUgZnJhbWV3b3JrIHRvIGV4dGVuZCBESS5cbiAgICAgKiBUaGlzIGlzIGludGVybmFsIHRvIEFuZ3VsYXIgYW5kIHNob3VsZCBub3QgYmUgdXNlZCBkaXJlY3RseS5cbiAgICAgKi9cbiAgICB2YXIgUmVmbGVjdGl2ZURlcGVuZGVuY3kgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBSZWZsZWN0aXZlRGVwZW5kZW5jeShrZXksIG9wdGlvbmFsLCBsb3dlckJvdW5kVmlzaWJpbGl0eSwgdXBwZXJCb3VuZFZpc2liaWxpdHksIHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgICAgICAgICAgdGhpcy5vcHRpb25hbCA9IG9wdGlvbmFsO1xuICAgICAgICAgICAgdGhpcy5sb3dlckJvdW5kVmlzaWJpbGl0eSA9IGxvd2VyQm91bmRWaXNpYmlsaXR5O1xuICAgICAgICAgICAgdGhpcy51cHBlckJvdW5kVmlzaWJpbGl0eSA9IHVwcGVyQm91bmRWaXNpYmlsaXR5O1xuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0gcHJvcGVydGllcztcbiAgICAgICAgfVxuICAgICAgICBSZWZsZWN0aXZlRGVwZW5kZW5jeS5mcm9tS2V5ID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWZsZWN0aXZlRGVwZW5kZW5jeShrZXksIGZhbHNlLCBudWxsLCBudWxsLCBbXSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBSZWZsZWN0aXZlRGVwZW5kZW5jeTtcbiAgICB9KCkpO1xuICAgIHZhciBfRU1QVFlfTElTVCA9IFtdO1xuICAgIHZhciBSZXNvbHZlZFJlZmxlY3RpdmVQcm92aWRlcl8gPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBSZXNvbHZlZFJlZmxlY3RpdmVQcm92aWRlcl8oa2V5LCByZXNvbHZlZEZhY3RvcmllcywgbXVsdGlQcm92aWRlcikge1xuICAgICAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICAgICAgICB0aGlzLnJlc29sdmVkRmFjdG9yaWVzID0gcmVzb2x2ZWRGYWN0b3JpZXM7XG4gICAgICAgICAgICB0aGlzLm11bHRpUHJvdmlkZXIgPSBtdWx0aVByb3ZpZGVyO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZXNvbHZlZFJlZmxlY3RpdmVQcm92aWRlcl8ucHJvdG90eXBlLCBcInJlc29sdmVkRmFjdG9yeVwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMucmVzb2x2ZWRGYWN0b3JpZXNbMF07IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gUmVzb2x2ZWRSZWZsZWN0aXZlUHJvdmlkZXJfO1xuICAgIH0oKSk7XG4gICAgLyoqXG4gICAgICogQW4gaW50ZXJuYWwgcmVzb2x2ZWQgcmVwcmVzZW50YXRpb24gb2YgYSBmYWN0b3J5IGZ1bmN0aW9uIGNyZWF0ZWQgYnkgcmVzb2x2aW5nIHtAbGlua1xuICAgICAqIFByb3ZpZGVyfS5cbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgdmFyIFJlc29sdmVkUmVmbGVjdGl2ZUZhY3RvcnkgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBSZXNvbHZlZFJlZmxlY3RpdmVGYWN0b3J5KFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBGYWN0b3J5IGZ1bmN0aW9uIHdoaWNoIGNhbiByZXR1cm4gYW4gaW5zdGFuY2Ugb2YgYW4gb2JqZWN0IHJlcHJlc2VudGVkIGJ5IGEga2V5LlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmYWN0b3J5LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBBcmd1bWVudHMgKGRlcGVuZGVuY2llcykgdG8gdGhlIGBmYWN0b3J5YCBmdW5jdGlvbi5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZGVwZW5kZW5jaWVzKSB7XG4gICAgICAgICAgICB0aGlzLmZhY3RvcnkgPSBmYWN0b3J5O1xuICAgICAgICAgICAgdGhpcy5kZXBlbmRlbmNpZXMgPSBkZXBlbmRlbmNpZXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFJlc29sdmVkUmVmbGVjdGl2ZUZhY3Rvcnk7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBSZXNvbHZlIGEgc2luZ2xlIHByb3ZpZGVyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlc29sdmVSZWZsZWN0aXZlRmFjdG9yeShwcm92aWRlcikge1xuICAgICAgICB2YXIgZmFjdG9yeUZuO1xuICAgICAgICB2YXIgcmVzb2x2ZWREZXBzO1xuICAgICAgICBpZiAoaXNQcmVzZW50KHByb3ZpZGVyLnVzZUNsYXNzKSkge1xuICAgICAgICAgICAgdmFyIHVzZUNsYXNzID0gcmVzb2x2ZUZvcndhcmRSZWYocHJvdmlkZXIudXNlQ2xhc3MpO1xuICAgICAgICAgICAgZmFjdG9yeUZuID0gcmVmbGVjdG9yLmZhY3RvcnkodXNlQ2xhc3MpO1xuICAgICAgICAgICAgcmVzb2x2ZWREZXBzID0gX2RlcGVuZGVuY2llc0Zvcih1c2VDbGFzcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNQcmVzZW50KHByb3ZpZGVyLnVzZUV4aXN0aW5nKSkge1xuICAgICAgICAgICAgZmFjdG9yeUZuID0gZnVuY3Rpb24gKGFsaWFzSW5zdGFuY2UpIHsgcmV0dXJuIGFsaWFzSW5zdGFuY2U7IH07XG4gICAgICAgICAgICByZXNvbHZlZERlcHMgPSBbUmVmbGVjdGl2ZURlcGVuZGVuY3kuZnJvbUtleShSZWZsZWN0aXZlS2V5LmdldChwcm92aWRlci51c2VFeGlzdGluZykpXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1ByZXNlbnQocHJvdmlkZXIudXNlRmFjdG9yeSkpIHtcbiAgICAgICAgICAgIGZhY3RvcnlGbiA9IHByb3ZpZGVyLnVzZUZhY3Rvcnk7XG4gICAgICAgICAgICByZXNvbHZlZERlcHMgPSBjb25zdHJ1Y3REZXBlbmRlbmNpZXMocHJvdmlkZXIudXNlRmFjdG9yeSwgcHJvdmlkZXIuZGVwcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmYWN0b3J5Rm4gPSBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm92aWRlci51c2VWYWx1ZTsgfTtcbiAgICAgICAgICAgIHJlc29sdmVkRGVwcyA9IF9FTVBUWV9MSVNUO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUmVzb2x2ZWRSZWZsZWN0aXZlRmFjdG9yeShmYWN0b3J5Rm4sIHJlc29sdmVkRGVwcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoZSB7QGxpbmsgUHJvdmlkZXJ9IGludG8ge0BsaW5rIFJlc29sdmVkUHJvdmlkZXJ9LlxuICAgICAqXG4gICAgICoge0BsaW5rIEluamVjdG9yfSBpbnRlcm5hbGx5IG9ubHkgdXNlcyB7QGxpbmsgUmVzb2x2ZWRQcm92aWRlcn0sIHtAbGluayBQcm92aWRlcn0gY29udGFpbnNcbiAgICAgKiBjb252ZW5pZW5jZSBwcm92aWRlciBzeW50YXguXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVzb2x2ZVJlZmxlY3RpdmVQcm92aWRlcihwcm92aWRlcikge1xuICAgICAgICByZXR1cm4gbmV3IFJlc29sdmVkUmVmbGVjdGl2ZVByb3ZpZGVyXyhSZWZsZWN0aXZlS2V5LmdldChwcm92aWRlci5wcm92aWRlKSwgW3Jlc29sdmVSZWZsZWN0aXZlRmFjdG9yeShwcm92aWRlcildLCBwcm92aWRlci5tdWx0aSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc29sdmUgYSBsaXN0IG9mIFByb3ZpZGVycy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXNvbHZlUmVmbGVjdGl2ZVByb3ZpZGVycyhwcm92aWRlcnMpIHtcbiAgICAgICAgdmFyIG5vcm1hbGl6ZWQgPSBfbm9ybWFsaXplUHJvdmlkZXJzKHByb3ZpZGVycywgW10pO1xuICAgICAgICB2YXIgcmVzb2x2ZWQgPSBub3JtYWxpemVkLm1hcChyZXNvbHZlUmVmbGVjdGl2ZVByb3ZpZGVyKTtcbiAgICAgICAgcmV0dXJuIE1hcFdyYXBwZXIudmFsdWVzKG1lcmdlUmVzb2x2ZWRSZWZsZWN0aXZlUHJvdmlkZXJzKHJlc29sdmVkLCBuZXcgTWFwKCkpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWVyZ2VzIGEgbGlzdCBvZiBSZXNvbHZlZFByb3ZpZGVycyBpbnRvIGEgbGlzdCB3aGVyZVxuICAgICAqIGVhY2gga2V5IGlzIGNvbnRhaW5lZCBleGFjdGx5IG9uY2UgYW5kIG11bHRpIHByb3ZpZGVyc1xuICAgICAqIGhhdmUgYmVlbiBtZXJnZWQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWVyZ2VSZXNvbHZlZFJlZmxlY3RpdmVQcm92aWRlcnMocHJvdmlkZXJzLCBub3JtYWxpemVkUHJvdmlkZXJzTWFwKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvdmlkZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcHJvdmlkZXIgPSBwcm92aWRlcnNbaV07XG4gICAgICAgICAgICB2YXIgZXhpc3RpbmcgPSBub3JtYWxpemVkUHJvdmlkZXJzTWFwLmdldChwcm92aWRlci5rZXkuaWQpO1xuICAgICAgICAgICAgaWYgKGlzUHJlc2VudChleGlzdGluZykpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvdmlkZXIubXVsdGlQcm92aWRlciAhPT0gZXhpc3RpbmcubXVsdGlQcm92aWRlcikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTWl4aW5nTXVsdGlQcm92aWRlcnNXaXRoUmVndWxhclByb3ZpZGVyc0Vycm9yKGV4aXN0aW5nLCBwcm92aWRlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwcm92aWRlci5tdWx0aVByb3ZpZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcHJvdmlkZXIucmVzb2x2ZWRGYWN0b3JpZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nLnJlc29sdmVkRmFjdG9yaWVzLnB1c2gocHJvdmlkZXIucmVzb2x2ZWRGYWN0b3JpZXNbal0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBub3JtYWxpemVkUHJvdmlkZXJzTWFwLnNldChwcm92aWRlci5rZXkuaWQsIHByb3ZpZGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzb2x2ZWRQcm92aWRlcjtcbiAgICAgICAgICAgICAgICBpZiAocHJvdmlkZXIubXVsdGlQcm92aWRlcikge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlZFByb3ZpZGVyID0gbmV3IFJlc29sdmVkUmVmbGVjdGl2ZVByb3ZpZGVyXyhwcm92aWRlci5rZXksIHByb3ZpZGVyLnJlc29sdmVkRmFjdG9yaWVzLnNsaWNlKCksIHByb3ZpZGVyLm11bHRpUHJvdmlkZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZWRQcm92aWRlciA9IHByb3ZpZGVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBub3JtYWxpemVkUHJvdmlkZXJzTWFwLnNldChwcm92aWRlci5rZXkuaWQsIHJlc29sdmVkUHJvdmlkZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub3JtYWxpemVkUHJvdmlkZXJzTWFwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBfbm9ybWFsaXplUHJvdmlkZXJzKHByb3ZpZGVycywgcmVzKSB7XG4gICAgICAgIHByb3ZpZGVycy5mb3JFYWNoKGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgICBpZiAoYiBpbnN0YW5jZW9mIFR5cGUpIHtcbiAgICAgICAgICAgICAgICByZXMucHVzaCh7IHByb3ZpZGU6IGIsIHVzZUNsYXNzOiBiIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYiAmJiB0eXBlb2YgYiA9PSAnb2JqZWN0JyAmJiBiLnByb3ZpZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJlcy5wdXNoKGIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYiBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgICAgX25vcm1hbGl6ZVByb3ZpZGVycyhiLCByZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRQcm92aWRlckVycm9yKGIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgZnVuY3Rpb24gY29uc3RydWN0RGVwZW5kZW5jaWVzKHR5cGVPckZ1bmMsIGRlcGVuZGVuY2llcykge1xuICAgICAgICBpZiAoIWRlcGVuZGVuY2llcykge1xuICAgICAgICAgICAgcmV0dXJuIF9kZXBlbmRlbmNpZXNGb3IodHlwZU9yRnVuYyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgcGFyYW1zID0gZGVwZW5kZW5jaWVzLm1hcChmdW5jdGlvbiAodCkgeyByZXR1cm4gW3RdOyB9KTtcbiAgICAgICAgICAgIHJldHVybiBkZXBlbmRlbmNpZXMubWFwKGZ1bmN0aW9uICh0KSB7IHJldHVybiBfZXh0cmFjdFRva2VuKHR5cGVPckZ1bmMsIHQsIHBhcmFtcyk7IH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIF9kZXBlbmRlbmNpZXNGb3IodHlwZU9yRnVuYykge1xuICAgICAgICB2YXIgcGFyYW1zID0gcmVmbGVjdG9yLnBhcmFtZXRlcnModHlwZU9yRnVuYyk7XG4gICAgICAgIGlmICghcGFyYW1zKVxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICBpZiAocGFyYW1zLnNvbWUoaXNCbGFuaykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBOb0Fubm90YXRpb25FcnJvcih0eXBlT3JGdW5jLCBwYXJhbXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJhbXMubWFwKGZ1bmN0aW9uIChwKSB7IHJldHVybiBfZXh0cmFjdFRva2VuKHR5cGVPckZ1bmMsIHAsIHBhcmFtcyk7IH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBfZXh0cmFjdFRva2VuKHR5cGVPckZ1bmMgLyoqIFRPRE8gIzkxMDAgKi8sIG1ldGFkYXRhIC8qKiBUT0RPICM5MTAwICovIC8qYW55W10gfCBhbnkqLywgcGFyYW1zKSB7XG4gICAgICAgIHZhciBkZXBQcm9wcyA9IFtdO1xuICAgICAgICB2YXIgdG9rZW4gPSBudWxsO1xuICAgICAgICB2YXIgb3B0aW9uYWwgPSBmYWxzZTtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG1ldGFkYXRhKSkge1xuICAgICAgICAgICAgaWYgKG1ldGFkYXRhIGluc3RhbmNlb2YgSW5qZWN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jcmVhdGVEZXBlbmRlbmN5KG1ldGFkYXRhLnRva2VuLCBvcHRpb25hbCwgbnVsbCwgbnVsbCwgZGVwUHJvcHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jcmVhdGVEZXBlbmRlbmN5KG1ldGFkYXRhLCBvcHRpb25hbCwgbnVsbCwgbnVsbCwgZGVwUHJvcHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBsb3dlckJvdW5kVmlzaWJpbGl0eSA9IG51bGw7XG4gICAgICAgIHZhciB1cHBlckJvdW5kVmlzaWJpbGl0eSA9IG51bGw7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWV0YWRhdGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBwYXJhbU1ldGFkYXRhID0gbWV0YWRhdGFbaV07XG4gICAgICAgICAgICBpZiAocGFyYW1NZXRhZGF0YSBpbnN0YW5jZW9mIFR5cGUpIHtcbiAgICAgICAgICAgICAgICB0b2tlbiA9IHBhcmFtTWV0YWRhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwYXJhbU1ldGFkYXRhIGluc3RhbmNlb2YgSW5qZWN0KSB7XG4gICAgICAgICAgICAgICAgdG9rZW4gPSBwYXJhbU1ldGFkYXRhLnRva2VuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocGFyYW1NZXRhZGF0YSBpbnN0YW5jZW9mIE9wdGlvbmFsKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9uYWwgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocGFyYW1NZXRhZGF0YSBpbnN0YW5jZW9mIFNlbGYpIHtcbiAgICAgICAgICAgICAgICB1cHBlckJvdW5kVmlzaWJpbGl0eSA9IHBhcmFtTWV0YWRhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwYXJhbU1ldGFkYXRhIGluc3RhbmNlb2YgSG9zdCkge1xuICAgICAgICAgICAgICAgIHVwcGVyQm91bmRWaXNpYmlsaXR5ID0gcGFyYW1NZXRhZGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBhcmFtTWV0YWRhdGEgaW5zdGFuY2VvZiBTa2lwU2VsZikge1xuICAgICAgICAgICAgICAgIGxvd2VyQm91bmRWaXNpYmlsaXR5ID0gcGFyYW1NZXRhZGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0b2tlbiA9IHJlc29sdmVGb3J3YXJkUmVmKHRva2VuKTtcbiAgICAgICAgaWYgKGlzUHJlc2VudCh0b2tlbikpIHtcbiAgICAgICAgICAgIHJldHVybiBfY3JlYXRlRGVwZW5kZW5jeSh0b2tlbiwgb3B0aW9uYWwsIGxvd2VyQm91bmRWaXNpYmlsaXR5LCB1cHBlckJvdW5kVmlzaWJpbGl0eSwgZGVwUHJvcHMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE5vQW5ub3RhdGlvbkVycm9yKHR5cGVPckZ1bmMsIHBhcmFtcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gX2NyZWF0ZURlcGVuZGVuY3kodG9rZW4gLyoqIFRPRE8gIzkxMDAgKi8sIG9wdGlvbmFsIC8qKiBUT0RPICM5MTAwICovLCBsb3dlckJvdW5kVmlzaWJpbGl0eSAvKiogVE9ETyAjOTEwMCAqLywgdXBwZXJCb3VuZFZpc2liaWxpdHkgLyoqIFRPRE8gIzkxMDAgKi8sIGRlcFByb3BzIC8qKiBUT0RPICM5MTAwICovKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVmbGVjdGl2ZURlcGVuZGVuY3koUmVmbGVjdGl2ZUtleS5nZXQodG9rZW4pLCBvcHRpb25hbCwgbG93ZXJCb3VuZFZpc2liaWxpdHksIHVwcGVyQm91bmRWaXNpYmlsaXR5LCBkZXBQcm9wcyk7XG4gICAgfVxuXG4gICAgLy8gVGhyZXNob2xkIGZvciB0aGUgZHluYW1pYyB2ZXJzaW9uXG4gICAgdmFyIF9NQVhfQ09OU1RSVUNUSU9OX0NPVU5URVIgPSAxMDtcbiAgICB2YXIgVU5ERUZJTkVEID0gbmV3IE9iamVjdCgpO1xuICAgIHZhciBSZWZsZWN0aXZlUHJvdG9JbmplY3RvcklubGluZVN0cmF0ZWd5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gUmVmbGVjdGl2ZVByb3RvSW5qZWN0b3JJbmxpbmVTdHJhdGVneShwcm90b0VJLCBwcm92aWRlcnMpIHtcbiAgICAgICAgICAgIHRoaXMucHJvdmlkZXIwID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMucHJvdmlkZXIxID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMucHJvdmlkZXIyID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMucHJvdmlkZXIzID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMucHJvdmlkZXI0ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMucHJvdmlkZXI1ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMucHJvdmlkZXI2ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMucHJvdmlkZXI3ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMucHJvdmlkZXI4ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMucHJvdmlkZXI5ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMua2V5SWQwID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMua2V5SWQxID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMua2V5SWQyID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMua2V5SWQzID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMua2V5SWQ0ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMua2V5SWQ1ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMua2V5SWQ2ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMua2V5SWQ3ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMua2V5SWQ4ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMua2V5SWQ5ID0gbnVsbDtcbiAgICAgICAgICAgIHZhciBsZW5ndGggPSBwcm92aWRlcnMubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb3ZpZGVyMCA9IHByb3ZpZGVyc1swXTtcbiAgICAgICAgICAgICAgICB0aGlzLmtleUlkMCA9IHByb3ZpZGVyc1swXS5rZXkuaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvdmlkZXIxID0gcHJvdmlkZXJzWzFdO1xuICAgICAgICAgICAgICAgIHRoaXMua2V5SWQxID0gcHJvdmlkZXJzWzFdLmtleS5pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsZW5ndGggPiAyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm92aWRlcjIgPSBwcm92aWRlcnNbMl07XG4gICAgICAgICAgICAgICAgdGhpcy5rZXlJZDIgPSBwcm92aWRlcnNbMl0ua2V5LmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxlbmd0aCA+IDMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb3ZpZGVyMyA9IHByb3ZpZGVyc1szXTtcbiAgICAgICAgICAgICAgICB0aGlzLmtleUlkMyA9IHByb3ZpZGVyc1szXS5rZXkuaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGVuZ3RoID4gNCkge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvdmlkZXI0ID0gcHJvdmlkZXJzWzRdO1xuICAgICAgICAgICAgICAgIHRoaXMua2V5SWQ0ID0gcHJvdmlkZXJzWzRdLmtleS5pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsZW5ndGggPiA1KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm92aWRlcjUgPSBwcm92aWRlcnNbNV07XG4gICAgICAgICAgICAgICAgdGhpcy5rZXlJZDUgPSBwcm92aWRlcnNbNV0ua2V5LmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxlbmd0aCA+IDYpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb3ZpZGVyNiA9IHByb3ZpZGVyc1s2XTtcbiAgICAgICAgICAgICAgICB0aGlzLmtleUlkNiA9IHByb3ZpZGVyc1s2XS5rZXkuaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGVuZ3RoID4gNykge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvdmlkZXI3ID0gcHJvdmlkZXJzWzddO1xuICAgICAgICAgICAgICAgIHRoaXMua2V5SWQ3ID0gcHJvdmlkZXJzWzddLmtleS5pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsZW5ndGggPiA4KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm92aWRlcjggPSBwcm92aWRlcnNbOF07XG4gICAgICAgICAgICAgICAgdGhpcy5rZXlJZDggPSBwcm92aWRlcnNbOF0ua2V5LmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxlbmd0aCA+IDkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb3ZpZGVyOSA9IHByb3ZpZGVyc1s5XTtcbiAgICAgICAgICAgICAgICB0aGlzLmtleUlkOSA9IHByb3ZpZGVyc1s5XS5rZXkuaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgUmVmbGVjdGl2ZVByb3RvSW5qZWN0b3JJbmxpbmVTdHJhdGVneS5wcm90b3R5cGUuZ2V0UHJvdmlkZXJBdEluZGV4ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgICAgICBpZiAoaW5kZXggPT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wcm92aWRlcjA7XG4gICAgICAgICAgICBpZiAoaW5kZXggPT0gMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wcm92aWRlcjE7XG4gICAgICAgICAgICBpZiAoaW5kZXggPT0gMilcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wcm92aWRlcjI7XG4gICAgICAgICAgICBpZiAoaW5kZXggPT0gMylcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wcm92aWRlcjM7XG4gICAgICAgICAgICBpZiAoaW5kZXggPT0gNClcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wcm92aWRlcjQ7XG4gICAgICAgICAgICBpZiAoaW5kZXggPT0gNSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wcm92aWRlcjU7XG4gICAgICAgICAgICBpZiAoaW5kZXggPT0gNilcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wcm92aWRlcjY7XG4gICAgICAgICAgICBpZiAoaW5kZXggPT0gNylcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wcm92aWRlcjc7XG4gICAgICAgICAgICBpZiAoaW5kZXggPT0gOClcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wcm92aWRlcjg7XG4gICAgICAgICAgICBpZiAoaW5kZXggPT0gOSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wcm92aWRlcjk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgT3V0T2ZCb3VuZHNFcnJvcihpbmRleCk7XG4gICAgICAgIH07XG4gICAgICAgIFJlZmxlY3RpdmVQcm90b0luamVjdG9ySW5saW5lU3RyYXRlZ3kucHJvdG90eXBlLmNyZWF0ZUluamVjdG9yU3RyYXRlZ3kgPSBmdW5jdGlvbiAoaW5qZWN0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVmbGVjdGl2ZUluamVjdG9ySW5saW5lU3RyYXRlZ3koaW5qZWN0b3IsIHRoaXMpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gUmVmbGVjdGl2ZVByb3RvSW5qZWN0b3JJbmxpbmVTdHJhdGVneTtcbiAgICB9KCkpO1xuICAgIHZhciBSZWZsZWN0aXZlUHJvdG9JbmplY3RvckR5bmFtaWNTdHJhdGVneSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFJlZmxlY3RpdmVQcm90b0luamVjdG9yRHluYW1pY1N0cmF0ZWd5KHByb3RvSW5qLCBwcm92aWRlcnMpIHtcbiAgICAgICAgICAgIHRoaXMucHJvdmlkZXJzID0gcHJvdmlkZXJzO1xuICAgICAgICAgICAgdmFyIGxlbiA9IHByb3ZpZGVycy5sZW5ndGg7XG4gICAgICAgICAgICB0aGlzLmtleUlkcyA9IG5ldyBBcnJheShsZW4pO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMua2V5SWRzW2ldID0gcHJvdmlkZXJzW2ldLmtleS5pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBSZWZsZWN0aXZlUHJvdG9JbmplY3RvckR5bmFtaWNTdHJhdGVneS5wcm90b3R5cGUuZ2V0UHJvdmlkZXJBdEluZGV4ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgICAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IHRoaXMucHJvdmlkZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBPdXRPZkJvdW5kc0Vycm9yKGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3ZpZGVyc1tpbmRleF07XG4gICAgICAgIH07XG4gICAgICAgIFJlZmxlY3RpdmVQcm90b0luamVjdG9yRHluYW1pY1N0cmF0ZWd5LnByb3RvdHlwZS5jcmVhdGVJbmplY3RvclN0cmF0ZWd5ID0gZnVuY3Rpb24gKGVpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlZmxlY3RpdmVJbmplY3RvckR5bmFtaWNTdHJhdGVneSh0aGlzLCBlaSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBSZWZsZWN0aXZlUHJvdG9JbmplY3RvckR5bmFtaWNTdHJhdGVneTtcbiAgICB9KCkpO1xuICAgIHZhciBSZWZsZWN0aXZlUHJvdG9JbmplY3RvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFJlZmxlY3RpdmVQcm90b0luamVjdG9yKHByb3ZpZGVycykge1xuICAgICAgICAgICAgdGhpcy5udW1iZXJPZlByb3ZpZGVycyA9IHByb3ZpZGVycy5sZW5ndGg7XG4gICAgICAgICAgICB0aGlzLl9zdHJhdGVneSA9IHByb3ZpZGVycy5sZW5ndGggPiBfTUFYX0NPTlNUUlVDVElPTl9DT1VOVEVSID9cbiAgICAgICAgICAgICAgICBuZXcgUmVmbGVjdGl2ZVByb3RvSW5qZWN0b3JEeW5hbWljU3RyYXRlZ3kodGhpcywgcHJvdmlkZXJzKSA6XG4gICAgICAgICAgICAgICAgbmV3IFJlZmxlY3RpdmVQcm90b0luamVjdG9ySW5saW5lU3RyYXRlZ3kodGhpcywgcHJvdmlkZXJzKTtcbiAgICAgICAgfVxuICAgICAgICBSZWZsZWN0aXZlUHJvdG9JbmplY3Rvci5mcm9tUmVzb2x2ZWRQcm92aWRlcnMgPSBmdW5jdGlvbiAocHJvdmlkZXJzKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlZmxlY3RpdmVQcm90b0luamVjdG9yKHByb3ZpZGVycyk7XG4gICAgICAgIH07XG4gICAgICAgIFJlZmxlY3RpdmVQcm90b0luamVjdG9yLnByb3RvdHlwZS5nZXRQcm92aWRlckF0SW5kZXggPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdHJhdGVneS5nZXRQcm92aWRlckF0SW5kZXgoaW5kZXgpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gUmVmbGVjdGl2ZVByb3RvSW5qZWN0b3I7XG4gICAgfSgpKTtcbiAgICB2YXIgUmVmbGVjdGl2ZUluamVjdG9ySW5saW5lU3RyYXRlZ3kgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBSZWZsZWN0aXZlSW5qZWN0b3JJbmxpbmVTdHJhdGVneShpbmplY3RvciwgcHJvdG9TdHJhdGVneSkge1xuICAgICAgICAgICAgdGhpcy5pbmplY3RvciA9IGluamVjdG9yO1xuICAgICAgICAgICAgdGhpcy5wcm90b1N0cmF0ZWd5ID0gcHJvdG9TdHJhdGVneTtcbiAgICAgICAgICAgIHRoaXMub2JqMCA9IFVOREVGSU5FRDtcbiAgICAgICAgICAgIHRoaXMub2JqMSA9IFVOREVGSU5FRDtcbiAgICAgICAgICAgIHRoaXMub2JqMiA9IFVOREVGSU5FRDtcbiAgICAgICAgICAgIHRoaXMub2JqMyA9IFVOREVGSU5FRDtcbiAgICAgICAgICAgIHRoaXMub2JqNCA9IFVOREVGSU5FRDtcbiAgICAgICAgICAgIHRoaXMub2JqNSA9IFVOREVGSU5FRDtcbiAgICAgICAgICAgIHRoaXMub2JqNiA9IFVOREVGSU5FRDtcbiAgICAgICAgICAgIHRoaXMub2JqNyA9IFVOREVGSU5FRDtcbiAgICAgICAgICAgIHRoaXMub2JqOCA9IFVOREVGSU5FRDtcbiAgICAgICAgICAgIHRoaXMub2JqOSA9IFVOREVGSU5FRDtcbiAgICAgICAgfVxuICAgICAgICBSZWZsZWN0aXZlSW5qZWN0b3JJbmxpbmVTdHJhdGVneS5wcm90b3R5cGUucmVzZXRDb25zdHJ1Y3Rpb25Db3VudGVyID0gZnVuY3Rpb24gKCkgeyB0aGlzLmluamVjdG9yLl9jb25zdHJ1Y3Rpb25Db3VudGVyID0gMDsgfTtcbiAgICAgICAgUmVmbGVjdGl2ZUluamVjdG9ySW5saW5lU3RyYXRlZ3kucHJvdG90eXBlLmluc3RhbnRpYXRlUHJvdmlkZXIgPSBmdW5jdGlvbiAocHJvdmlkZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmluamVjdG9yLl9uZXcocHJvdmlkZXIpO1xuICAgICAgICB9O1xuICAgICAgICBSZWZsZWN0aXZlSW5qZWN0b3JJbmxpbmVTdHJhdGVneS5wcm90b3R5cGUuZ2V0T2JqQnlLZXlJZCA9IGZ1bmN0aW9uIChrZXlJZCkge1xuICAgICAgICAgICAgdmFyIHAgPSB0aGlzLnByb3RvU3RyYXRlZ3k7XG4gICAgICAgICAgICB2YXIgaW5qID0gdGhpcy5pbmplY3RvcjtcbiAgICAgICAgICAgIGlmIChwLmtleUlkMCA9PT0ga2V5SWQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vYmowID09PSBVTkRFRklORUQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vYmowID0gaW5qLl9uZXcocC5wcm92aWRlcjApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vYmowO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHAua2V5SWQxID09PSBrZXlJZCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9iajEgPT09IFVOREVGSU5FRCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9iajEgPSBpbmouX25ldyhwLnByb3ZpZGVyMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9iajE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocC5rZXlJZDIgPT09IGtleUlkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub2JqMiA9PT0gVU5ERUZJTkVEKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub2JqMiA9IGluai5fbmV3KHAucHJvdmlkZXIyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub2JqMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwLmtleUlkMyA9PT0ga2V5SWQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vYmozID09PSBVTkRFRklORUQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vYmozID0gaW5qLl9uZXcocC5wcm92aWRlcjMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vYmozO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHAua2V5SWQ0ID09PSBrZXlJZCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9iajQgPT09IFVOREVGSU5FRCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9iajQgPSBpbmouX25ldyhwLnByb3ZpZGVyNCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9iajQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocC5rZXlJZDUgPT09IGtleUlkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub2JqNSA9PT0gVU5ERUZJTkVEKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub2JqNSA9IGluai5fbmV3KHAucHJvdmlkZXI1KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub2JqNTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwLmtleUlkNiA9PT0ga2V5SWQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vYmo2ID09PSBVTkRFRklORUQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vYmo2ID0gaW5qLl9uZXcocC5wcm92aWRlcjYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vYmo2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHAua2V5SWQ3ID09PSBrZXlJZCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9iajcgPT09IFVOREVGSU5FRCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9iajcgPSBpbmouX25ldyhwLnByb3ZpZGVyNyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9iajc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocC5rZXlJZDggPT09IGtleUlkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub2JqOCA9PT0gVU5ERUZJTkVEKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub2JqOCA9IGluai5fbmV3KHAucHJvdmlkZXI4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub2JqODtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwLmtleUlkOSA9PT0ga2V5SWQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vYmo5ID09PSBVTkRFRklORUQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vYmo5ID0gaW5qLl9uZXcocC5wcm92aWRlcjkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vYmo5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFVOREVGSU5FRDtcbiAgICAgICAgfTtcbiAgICAgICAgUmVmbGVjdGl2ZUluamVjdG9ySW5saW5lU3RyYXRlZ3kucHJvdG90eXBlLmdldE9iakF0SW5kZXggPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgICAgIGlmIChpbmRleCA9PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9iajA7XG4gICAgICAgICAgICBpZiAoaW5kZXggPT0gMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vYmoxO1xuICAgICAgICAgICAgaWYgKGluZGV4ID09IDIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub2JqMjtcbiAgICAgICAgICAgIGlmIChpbmRleCA9PSAzKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9iajM7XG4gICAgICAgICAgICBpZiAoaW5kZXggPT0gNClcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vYmo0O1xuICAgICAgICAgICAgaWYgKGluZGV4ID09IDUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub2JqNTtcbiAgICAgICAgICAgIGlmIChpbmRleCA9PSA2KVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9iajY7XG4gICAgICAgICAgICBpZiAoaW5kZXggPT0gNylcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vYmo3O1xuICAgICAgICAgICAgaWYgKGluZGV4ID09IDgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub2JqODtcbiAgICAgICAgICAgIGlmIChpbmRleCA9PSA5KVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9iajk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgT3V0T2ZCb3VuZHNFcnJvcihpbmRleCk7XG4gICAgICAgIH07XG4gICAgICAgIFJlZmxlY3RpdmVJbmplY3RvcklubGluZVN0cmF0ZWd5LnByb3RvdHlwZS5nZXRNYXhOdW1iZXJPZk9iamVjdHMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBfTUFYX0NPTlNUUlVDVElPTl9DT1VOVEVSOyB9O1xuICAgICAgICByZXR1cm4gUmVmbGVjdGl2ZUluamVjdG9ySW5saW5lU3RyYXRlZ3k7XG4gICAgfSgpKTtcbiAgICB2YXIgUmVmbGVjdGl2ZUluamVjdG9yRHluYW1pY1N0cmF0ZWd5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gUmVmbGVjdGl2ZUluamVjdG9yRHluYW1pY1N0cmF0ZWd5KHByb3RvU3RyYXRlZ3ksIGluamVjdG9yKSB7XG4gICAgICAgICAgICB0aGlzLnByb3RvU3RyYXRlZ3kgPSBwcm90b1N0cmF0ZWd5O1xuICAgICAgICAgICAgdGhpcy5pbmplY3RvciA9IGluamVjdG9yO1xuICAgICAgICAgICAgdGhpcy5vYmpzID0gbmV3IEFycmF5KHByb3RvU3RyYXRlZ3kucHJvdmlkZXJzLmxlbmd0aCkuZmlsbChVTkRFRklORUQpO1xuICAgICAgICB9XG4gICAgICAgIFJlZmxlY3RpdmVJbmplY3RvckR5bmFtaWNTdHJhdGVneS5wcm90b3R5cGUucmVzZXRDb25zdHJ1Y3Rpb25Db3VudGVyID0gZnVuY3Rpb24gKCkgeyB0aGlzLmluamVjdG9yLl9jb25zdHJ1Y3Rpb25Db3VudGVyID0gMDsgfTtcbiAgICAgICAgUmVmbGVjdGl2ZUluamVjdG9yRHluYW1pY1N0cmF0ZWd5LnByb3RvdHlwZS5pbnN0YW50aWF0ZVByb3ZpZGVyID0gZnVuY3Rpb24gKHByb3ZpZGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbmplY3Rvci5fbmV3KHByb3ZpZGVyKTtcbiAgICAgICAgfTtcbiAgICAgICAgUmVmbGVjdGl2ZUluamVjdG9yRHluYW1pY1N0cmF0ZWd5LnByb3RvdHlwZS5nZXRPYmpCeUtleUlkID0gZnVuY3Rpb24gKGtleUlkKSB7XG4gICAgICAgICAgICB2YXIgcCA9IHRoaXMucHJvdG9TdHJhdGVneTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcC5rZXlJZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAocC5rZXlJZHNbaV0gPT09IGtleUlkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm9ianNbaV0gPT09IFVOREVGSU5FRCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vYmpzW2ldID0gdGhpcy5pbmplY3Rvci5fbmV3KHAucHJvdmlkZXJzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vYmpzW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBVTkRFRklORUQ7XG4gICAgICAgIH07XG4gICAgICAgIFJlZmxlY3RpdmVJbmplY3RvckR5bmFtaWNTdHJhdGVneS5wcm90b3R5cGUuZ2V0T2JqQXRJbmRleCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSB0aGlzLm9ianMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE91dE9mQm91bmRzRXJyb3IoaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMub2Jqc1tpbmRleF07XG4gICAgICAgIH07XG4gICAgICAgIFJlZmxlY3RpdmVJbmplY3RvckR5bmFtaWNTdHJhdGVneS5wcm90b3R5cGUuZ2V0TWF4TnVtYmVyT2ZPYmplY3RzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5vYmpzLmxlbmd0aDsgfTtcbiAgICAgICAgcmV0dXJuIFJlZmxlY3RpdmVJbmplY3RvckR5bmFtaWNTdHJhdGVneTtcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIEEgUmVmbGVjdGl2ZURlcGVuZGVuY3kgaW5qZWN0aW9uIGNvbnRhaW5lciB1c2VkIGZvciBpbnN0YW50aWF0aW5nIG9iamVjdHMgYW5kIHJlc29sdmluZ1xuICAgICAqIGRlcGVuZGVuY2llcy5cbiAgICAgKlxuICAgICAqIEFuIGBJbmplY3RvcmAgaXMgYSByZXBsYWNlbWVudCBmb3IgYSBgbmV3YCBvcGVyYXRvciwgd2hpY2ggY2FuIGF1dG9tYXRpY2FsbHkgcmVzb2x2ZSB0aGVcbiAgICAgKiBjb25zdHJ1Y3RvciBkZXBlbmRlbmNpZXMuXG4gICAgICpcbiAgICAgKiBJbiB0eXBpY2FsIHVzZSwgYXBwbGljYXRpb24gY29kZSBhc2tzIGZvciB0aGUgZGVwZW5kZW5jaWVzIGluIHRoZSBjb25zdHJ1Y3RvciBhbmQgdGhleSBhcmVcbiAgICAgKiByZXNvbHZlZCBieSB0aGUgYEluamVjdG9yYC5cbiAgICAgKlxuICAgICAqICMjIyBFeGFtcGxlIChbbGl2ZSBkZW1vXShodHRwOi8vcGxua3IuY28vZWRpdC9qemplYzA/cD1wcmV2aWV3KSlcbiAgICAgKlxuICAgICAqIFRoZSBmb2xsb3dpbmcgZXhhbXBsZSBjcmVhdGVzIGFuIGBJbmplY3RvcmAgY29uZmlndXJlZCB0byBjcmVhdGUgYEVuZ2luZWAgYW5kIGBDYXJgLlxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIEBJbmplY3RhYmxlKClcbiAgICAgKiBjbGFzcyBFbmdpbmUge1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEBJbmplY3RhYmxlKClcbiAgICAgKiBjbGFzcyBDYXIge1xuICAgICAqICAgY29uc3RydWN0b3IocHVibGljIGVuZ2luZTpFbmdpbmUpIHt9XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIGluamVjdG9yID0gUmVmbGVjdGl2ZUluamVjdG9yLnJlc29sdmVBbmRDcmVhdGUoW0NhciwgRW5naW5lXSk7XG4gICAgICogdmFyIGNhciA9IGluamVjdG9yLmdldChDYXIpO1xuICAgICAqIGV4cGVjdChjYXIgaW5zdGFuY2VvZiBDYXIpLnRvQmUodHJ1ZSk7XG4gICAgICogZXhwZWN0KGNhci5lbmdpbmUgaW5zdGFuY2VvZiBFbmdpbmUpLnRvQmUodHJ1ZSk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBOb3RpY2UsIHdlIGRvbid0IHVzZSB0aGUgYG5ld2Agb3BlcmF0b3IgYmVjYXVzZSB3ZSBleHBsaWNpdGx5IHdhbnQgdG8gaGF2ZSB0aGUgYEluamVjdG9yYFxuICAgICAqIHJlc29sdmUgYWxsIG9mIHRoZSBvYmplY3QncyBkZXBlbmRlbmNpZXMgYXV0b21hdGljYWxseS5cbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgUmVmbGVjdGl2ZUluamVjdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gUmVmbGVjdGl2ZUluamVjdG9yKCkge1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUdXJucyBhbiBhcnJheSBvZiBwcm92aWRlciBkZWZpbml0aW9ucyBpbnRvIGFuIGFycmF5IG9mIHJlc29sdmVkIHByb3ZpZGVycy5cbiAgICAgICAgICpcbiAgICAgICAgICogQSByZXNvbHV0aW9uIGlzIGEgcHJvY2VzcyBvZiBmbGF0dGVuaW5nIG11bHRpcGxlIG5lc3RlZCBhcnJheXMgYW5kIGNvbnZlcnRpbmcgaW5kaXZpZHVhbFxuICAgICAgICAgKiBwcm92aWRlcnMgaW50byBhbiBhcnJheSBvZiB7QGxpbmsgUmVzb2x2ZWRSZWZsZWN0aXZlUHJvdmlkZXJ9cy5cbiAgICAgICAgICpcbiAgICAgICAgICogIyMjIEV4YW1wbGUgKFtsaXZlIGRlbW9dKGh0dHA6Ly9wbG5rci5jby9lZGl0L0FpWFRIaT9wPXByZXZpZXcpKVxuICAgICAgICAgKlxuICAgICAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICAgICAqIEBJbmplY3RhYmxlKClcbiAgICAgICAgICogY2xhc3MgRW5naW5lIHtcbiAgICAgICAgICogfVxuICAgICAgICAgKlxuICAgICAgICAgKiBASW5qZWN0YWJsZSgpXG4gICAgICAgICAqIGNsYXNzIENhciB7XG4gICAgICAgICAqICAgY29uc3RydWN0b3IocHVibGljIGVuZ2luZTpFbmdpbmUpIHt9XG4gICAgICAgICAqIH1cbiAgICAgICAgICpcbiAgICAgICAgICogdmFyIHByb3ZpZGVycyA9IFJlZmxlY3RpdmVJbmplY3Rvci5yZXNvbHZlKFtDYXIsIFtbRW5naW5lXV1dKTtcbiAgICAgICAgICpcbiAgICAgICAgICogZXhwZWN0KHByb3ZpZGVycy5sZW5ndGgpLnRvRXF1YWwoMik7XG4gICAgICAgICAqXG4gICAgICAgICAqIGV4cGVjdChwcm92aWRlcnNbMF0gaW5zdGFuY2VvZiBSZXNvbHZlZFJlZmxlY3RpdmVQcm92aWRlcikudG9CZSh0cnVlKTtcbiAgICAgICAgICogZXhwZWN0KHByb3ZpZGVyc1swXS5rZXkuZGlzcGxheU5hbWUpLnRvQmUoXCJDYXJcIik7XG4gICAgICAgICAqIGV4cGVjdChwcm92aWRlcnNbMF0uZGVwZW5kZW5jaWVzLmxlbmd0aCkudG9FcXVhbCgxKTtcbiAgICAgICAgICogZXhwZWN0KHByb3ZpZGVyc1swXS5mYWN0b3J5KS50b0JlRGVmaW5lZCgpO1xuICAgICAgICAgKlxuICAgICAgICAgKiBleHBlY3QocHJvdmlkZXJzWzFdLmtleS5kaXNwbGF5TmFtZSkudG9CZShcIkVuZ2luZVwiKTtcbiAgICAgICAgICogfSk7XG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKlxuICAgICAgICAgKiBTZWUge0BsaW5rIFJlZmxlY3RpdmVJbmplY3RvciNmcm9tUmVzb2x2ZWRQcm92aWRlcnN9IGZvciBtb3JlIGluZm8uXG4gICAgICAgICAqL1xuICAgICAgICBSZWZsZWN0aXZlSW5qZWN0b3IucmVzb2x2ZSA9IGZ1bmN0aW9uIChwcm92aWRlcnMpIHtcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlUmVmbGVjdGl2ZVByb3ZpZGVycyhwcm92aWRlcnMpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVzb2x2ZXMgYW4gYXJyYXkgb2YgcHJvdmlkZXJzIGFuZCBjcmVhdGVzIGFuIGluamVjdG9yIGZyb20gdGhvc2UgcHJvdmlkZXJzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgcGFzc2VkLWluIHByb3ZpZGVycyBjYW4gYmUgYW4gYXJyYXkgb2YgYFR5cGVgLCB7QGxpbmsgUHJvdmlkZXJ9LFxuICAgICAgICAgKiBvciBhIHJlY3Vyc2l2ZSBhcnJheSBvZiBtb3JlIHByb3ZpZGVycy5cbiAgICAgICAgICpcbiAgICAgICAgICogIyMjIEV4YW1wbGUgKFtsaXZlIGRlbW9dKGh0dHA6Ly9wbG5rci5jby9lZGl0L2VQT2NjQT9wPXByZXZpZXcpKVxuICAgICAgICAgKlxuICAgICAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICAgICAqIEBJbmplY3RhYmxlKClcbiAgICAgICAgICogY2xhc3MgRW5naW5lIHtcbiAgICAgICAgICogfVxuICAgICAgICAgKlxuICAgICAgICAgKiBASW5qZWN0YWJsZSgpXG4gICAgICAgICAqIGNsYXNzIENhciB7XG4gICAgICAgICAqICAgY29uc3RydWN0b3IocHVibGljIGVuZ2luZTpFbmdpbmUpIHt9XG4gICAgICAgICAqIH1cbiAgICAgICAgICpcbiAgICAgICAgICogdmFyIGluamVjdG9yID0gUmVmbGVjdGl2ZUluamVjdG9yLnJlc29sdmVBbmRDcmVhdGUoW0NhciwgRW5naW5lXSk7XG4gICAgICAgICAqIGV4cGVjdChpbmplY3Rvci5nZXQoQ2FyKSBpbnN0YW5jZW9mIENhcikudG9CZSh0cnVlKTtcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgc2xvd2VyIHRoYW4gdGhlIGNvcnJlc3BvbmRpbmcgYGZyb21SZXNvbHZlZFByb3ZpZGVyc2BcbiAgICAgICAgICogYmVjYXVzZSBpdCBuZWVkcyB0byByZXNvbHZlIHRoZSBwYXNzZWQtaW4gcHJvdmlkZXJzIGZpcnN0LlxuICAgICAgICAgKiBTZWUge0BsaW5rIEluamVjdG9yI3Jlc29sdmV9IGFuZCB7QGxpbmsgSW5qZWN0b3IjZnJvbVJlc29sdmVkUHJvdmlkZXJzfS5cbiAgICAgICAgICovXG4gICAgICAgIFJlZmxlY3RpdmVJbmplY3Rvci5yZXNvbHZlQW5kQ3JlYXRlID0gZnVuY3Rpb24gKHByb3ZpZGVycywgcGFyZW50KSB7XG4gICAgICAgICAgICBpZiAocGFyZW50ID09PSB2b2lkIDApIHsgcGFyZW50ID0gbnVsbDsgfVxuICAgICAgICAgICAgdmFyIFJlc29sdmVkUmVmbGVjdGl2ZVByb3ZpZGVycyA9IFJlZmxlY3RpdmVJbmplY3Rvci5yZXNvbHZlKHByb3ZpZGVycyk7XG4gICAgICAgICAgICByZXR1cm4gUmVmbGVjdGl2ZUluamVjdG9yLmZyb21SZXNvbHZlZFByb3ZpZGVycyhSZXNvbHZlZFJlZmxlY3RpdmVQcm92aWRlcnMsIHBhcmVudCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGFuIGluamVjdG9yIGZyb20gcHJldmlvdXNseSByZXNvbHZlZCBwcm92aWRlcnMuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgQVBJIGlzIHRoZSByZWNvbW1lbmRlZCB3YXkgdG8gY29uc3RydWN0IGluamVjdG9ycyBpbiBwZXJmb3JtYW5jZS1zZW5zaXRpdmUgcGFydHMuXG4gICAgICAgICAqXG4gICAgICAgICAqICMjIyBFeGFtcGxlIChbbGl2ZSBkZW1vXShodHRwOi8vcGxua3IuY28vZWRpdC9LclNNY2k/cD1wcmV2aWV3KSlcbiAgICAgICAgICpcbiAgICAgICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAgICAgKiBASW5qZWN0YWJsZSgpXG4gICAgICAgICAqIGNsYXNzIEVuZ2luZSB7XG4gICAgICAgICAqIH1cbiAgICAgICAgICpcbiAgICAgICAgICogQEluamVjdGFibGUoKVxuICAgICAgICAgKiBjbGFzcyBDYXIge1xuICAgICAgICAgKiAgIGNvbnN0cnVjdG9yKHB1YmxpYyBlbmdpbmU6RW5naW5lKSB7fVxuICAgICAgICAgKiB9XG4gICAgICAgICAqXG4gICAgICAgICAqIHZhciBwcm92aWRlcnMgPSBSZWZsZWN0aXZlSW5qZWN0b3IucmVzb2x2ZShbQ2FyLCBFbmdpbmVdKTtcbiAgICAgICAgICogdmFyIGluamVjdG9yID0gUmVmbGVjdGl2ZUluamVjdG9yLmZyb21SZXNvbHZlZFByb3ZpZGVycyhwcm92aWRlcnMpO1xuICAgICAgICAgKiBleHBlY3QoaW5qZWN0b3IuZ2V0KENhcikgaW5zdGFuY2VvZiBDYXIpLnRvQmUodHJ1ZSk7XG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICAgICAqL1xuICAgICAgICBSZWZsZWN0aXZlSW5qZWN0b3IuZnJvbVJlc29sdmVkUHJvdmlkZXJzID0gZnVuY3Rpb24gKHByb3ZpZGVycywgcGFyZW50KSB7XG4gICAgICAgICAgICBpZiAocGFyZW50ID09PSB2b2lkIDApIHsgcGFyZW50ID0gbnVsbDsgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWZsZWN0aXZlSW5qZWN0b3JfKFJlZmxlY3RpdmVQcm90b0luamVjdG9yLmZyb21SZXNvbHZlZFByb3ZpZGVycyhwcm92aWRlcnMpLCBwYXJlbnQpO1xuICAgICAgICB9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVmbGVjdGl2ZUluamVjdG9yLnByb3RvdHlwZSwgXCJwYXJlbnRcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBQYXJlbnQgb2YgdGhpcyBpbmplY3Rvci5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiA8IS0tIFRPRE86IEFkZCBhIGxpbmsgdG8gdGhlIHNlY3Rpb24gb2YgdGhlIHVzZXIgZ3VpZGUgdGFsa2luZyBhYm91dCBoaWVyYXJjaGljYWwgaW5qZWN0aW9uLlxuICAgICAgICAgICAgICogLS0+XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogIyMjIEV4YW1wbGUgKFtsaXZlIGRlbW9dKGh0dHA6Ly9wbG5rci5jby9lZGl0L2Vvc01Hbz9wPXByZXZpZXcpKVxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgICAgICAgICAqIHZhciBwYXJlbnQgPSBSZWZsZWN0aXZlSW5qZWN0b3IucmVzb2x2ZUFuZENyZWF0ZShbXSk7XG4gICAgICAgICAgICAgKiB2YXIgY2hpbGQgPSBwYXJlbnQucmVzb2x2ZUFuZENyZWF0ZUNoaWxkKFtdKTtcbiAgICAgICAgICAgICAqIGV4cGVjdChjaGlsZC5wYXJlbnQpLnRvQmUocGFyZW50KTtcbiAgICAgICAgICAgICAqIGBgYFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVuaW1wbGVtZW50ZWQoKTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXNvbHZlcyBhbiBhcnJheSBvZiBwcm92aWRlcnMgYW5kIGNyZWF0ZXMgYSBjaGlsZCBpbmplY3RvciBmcm9tIHRob3NlIHByb3ZpZGVycy5cbiAgICAgICAgICpcbiAgICAgICAgICogPCEtLSBUT0RPOiBBZGQgYSBsaW5rIHRvIHRoZSBzZWN0aW9uIG9mIHRoZSB1c2VyIGd1aWRlIHRhbGtpbmcgYWJvdXQgaGllcmFyY2hpY2FsIGluamVjdGlvbi5cbiAgICAgICAgICogLS0+XG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBwYXNzZWQtaW4gcHJvdmlkZXJzIGNhbiBiZSBhbiBhcnJheSBvZiBgVHlwZWAsIHtAbGluayBQcm92aWRlcn0sXG4gICAgICAgICAqIG9yIGEgcmVjdXJzaXZlIGFycmF5IG9mIG1vcmUgcHJvdmlkZXJzLlxuICAgICAgICAgKlxuICAgICAgICAgKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQvb3BCM1Q0P3A9cHJldmlldykpXG4gICAgICAgICAqXG4gICAgICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgICAgICogY2xhc3MgUGFyZW50UHJvdmlkZXIge31cbiAgICAgICAgICogY2xhc3MgQ2hpbGRQcm92aWRlciB7fVxuICAgICAgICAgKlxuICAgICAgICAgKiB2YXIgcGFyZW50ID0gUmVmbGVjdGl2ZUluamVjdG9yLnJlc29sdmVBbmRDcmVhdGUoW1BhcmVudFByb3ZpZGVyXSk7XG4gICAgICAgICAqIHZhciBjaGlsZCA9IHBhcmVudC5yZXNvbHZlQW5kQ3JlYXRlQ2hpbGQoW0NoaWxkUHJvdmlkZXJdKTtcbiAgICAgICAgICpcbiAgICAgICAgICogZXhwZWN0KGNoaWxkLmdldChQYXJlbnRQcm92aWRlcikgaW5zdGFuY2VvZiBQYXJlbnRQcm92aWRlcikudG9CZSh0cnVlKTtcbiAgICAgICAgICogZXhwZWN0KGNoaWxkLmdldChDaGlsZFByb3ZpZGVyKSBpbnN0YW5jZW9mIENoaWxkUHJvdmlkZXIpLnRvQmUodHJ1ZSk7XG4gICAgICAgICAqIGV4cGVjdChjaGlsZC5nZXQoUGFyZW50UHJvdmlkZXIpKS50b0JlKHBhcmVudC5nZXQoUGFyZW50UHJvdmlkZXIpKTtcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgc2xvd2VyIHRoYW4gdGhlIGNvcnJlc3BvbmRpbmcgYGNyZWF0ZUNoaWxkRnJvbVJlc29sdmVkYFxuICAgICAgICAgKiBiZWNhdXNlIGl0IG5lZWRzIHRvIHJlc29sdmUgdGhlIHBhc3NlZC1pbiBwcm92aWRlcnMgZmlyc3QuXG4gICAgICAgICAqIFNlZSB7QGxpbmsgSW5qZWN0b3IjcmVzb2x2ZX0gYW5kIHtAbGluayBJbmplY3RvciNjcmVhdGVDaGlsZEZyb21SZXNvbHZlZH0uXG4gICAgICAgICAqL1xuICAgICAgICBSZWZsZWN0aXZlSW5qZWN0b3IucHJvdG90eXBlLnJlc29sdmVBbmRDcmVhdGVDaGlsZCA9IGZ1bmN0aW9uIChwcm92aWRlcnMpIHsgcmV0dXJuIHVuaW1wbGVtZW50ZWQoKTsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBjaGlsZCBpbmplY3RvciBmcm9tIHByZXZpb3VzbHkgcmVzb2x2ZWQgcHJvdmlkZXJzLlxuICAgICAgICAgKlxuICAgICAgICAgKiA8IS0tIFRPRE86IEFkZCBhIGxpbmsgdG8gdGhlIHNlY3Rpb24gb2YgdGhlIHVzZXIgZ3VpZGUgdGFsa2luZyBhYm91dCBoaWVyYXJjaGljYWwgaW5qZWN0aW9uLlxuICAgICAgICAgKiAtLT5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBBUEkgaXMgdGhlIHJlY29tbWVuZGVkIHdheSB0byBjb25zdHJ1Y3QgaW5qZWN0b3JzIGluIHBlcmZvcm1hbmNlLXNlbnNpdGl2ZSBwYXJ0cy5cbiAgICAgICAgICpcbiAgICAgICAgICogIyMjIEV4YW1wbGUgKFtsaXZlIGRlbW9dKGh0dHA6Ly9wbG5rci5jby9lZGl0L1ZoeWZqTj9wPXByZXZpZXcpKVxuICAgICAgICAgKlxuICAgICAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICAgICAqIGNsYXNzIFBhcmVudFByb3ZpZGVyIHt9XG4gICAgICAgICAqIGNsYXNzIENoaWxkUHJvdmlkZXIge31cbiAgICAgICAgICpcbiAgICAgICAgICogdmFyIHBhcmVudFByb3ZpZGVycyA9IFJlZmxlY3RpdmVJbmplY3Rvci5yZXNvbHZlKFtQYXJlbnRQcm92aWRlcl0pO1xuICAgICAgICAgKiB2YXIgY2hpbGRQcm92aWRlcnMgPSBSZWZsZWN0aXZlSW5qZWN0b3IucmVzb2x2ZShbQ2hpbGRQcm92aWRlcl0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiB2YXIgcGFyZW50ID0gUmVmbGVjdGl2ZUluamVjdG9yLmZyb21SZXNvbHZlZFByb3ZpZGVycyhwYXJlbnRQcm92aWRlcnMpO1xuICAgICAgICAgKiB2YXIgY2hpbGQgPSBwYXJlbnQuY3JlYXRlQ2hpbGRGcm9tUmVzb2x2ZWQoY2hpbGRQcm92aWRlcnMpO1xuICAgICAgICAgKlxuICAgICAgICAgKiBleHBlY3QoY2hpbGQuZ2V0KFBhcmVudFByb3ZpZGVyKSBpbnN0YW5jZW9mIFBhcmVudFByb3ZpZGVyKS50b0JlKHRydWUpO1xuICAgICAgICAgKiBleHBlY3QoY2hpbGQuZ2V0KENoaWxkUHJvdmlkZXIpIGluc3RhbmNlb2YgQ2hpbGRQcm92aWRlcikudG9CZSh0cnVlKTtcbiAgICAgICAgICogZXhwZWN0KGNoaWxkLmdldChQYXJlbnRQcm92aWRlcikpLnRvQmUocGFyZW50LmdldChQYXJlbnRQcm92aWRlcikpO1xuICAgICAgICAgKiBgYGBcbiAgICAgICAgICovXG4gICAgICAgIFJlZmxlY3RpdmVJbmplY3Rvci5wcm90b3R5cGUuY3JlYXRlQ2hpbGRGcm9tUmVzb2x2ZWQgPSBmdW5jdGlvbiAocHJvdmlkZXJzKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5pbXBsZW1lbnRlZCgpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVzb2x2ZXMgYSBwcm92aWRlciBhbmQgaW5zdGFudGlhdGVzIGFuIG9iamVjdCBpbiB0aGUgY29udGV4dCBvZiB0aGUgaW5qZWN0b3IuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBjcmVhdGVkIG9iamVjdCBkb2VzIG5vdCBnZXQgY2FjaGVkIGJ5IHRoZSBpbmplY3Rvci5cbiAgICAgICAgICpcbiAgICAgICAgICogIyMjIEV4YW1wbGUgKFtsaXZlIGRlbW9dKGh0dHA6Ly9wbG5rci5jby9lZGl0L3l2VlhvQj9wPXByZXZpZXcpKVxuICAgICAgICAgKlxuICAgICAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICAgICAqIEBJbmplY3RhYmxlKClcbiAgICAgICAgICogY2xhc3MgRW5naW5lIHtcbiAgICAgICAgICogfVxuICAgICAgICAgKlxuICAgICAgICAgKiBASW5qZWN0YWJsZSgpXG4gICAgICAgICAqIGNsYXNzIENhciB7XG4gICAgICAgICAqICAgY29uc3RydWN0b3IocHVibGljIGVuZ2luZTpFbmdpbmUpIHt9XG4gICAgICAgICAqIH1cbiAgICAgICAgICpcbiAgICAgICAgICogdmFyIGluamVjdG9yID0gUmVmbGVjdGl2ZUluamVjdG9yLnJlc29sdmVBbmRDcmVhdGUoW0VuZ2luZV0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiB2YXIgY2FyID0gaW5qZWN0b3IucmVzb2x2ZUFuZEluc3RhbnRpYXRlKENhcik7XG4gICAgICAgICAqIGV4cGVjdChjYXIuZW5naW5lKS50b0JlKGluamVjdG9yLmdldChFbmdpbmUpKTtcbiAgICAgICAgICogZXhwZWN0KGNhcikubm90LnRvQmUoaW5qZWN0b3IucmVzb2x2ZUFuZEluc3RhbnRpYXRlKENhcikpO1xuICAgICAgICAgKiBgYGBcbiAgICAgICAgICovXG4gICAgICAgIFJlZmxlY3RpdmVJbmplY3Rvci5wcm90b3R5cGUucmVzb2x2ZUFuZEluc3RhbnRpYXRlID0gZnVuY3Rpb24gKHByb3ZpZGVyKSB7IHJldHVybiB1bmltcGxlbWVudGVkKCk7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnN0YW50aWF0ZXMgYW4gb2JqZWN0IHVzaW5nIGEgcmVzb2x2ZWQgcHJvdmlkZXIgaW4gdGhlIGNvbnRleHQgb2YgdGhlIGluamVjdG9yLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgY3JlYXRlZCBvYmplY3QgZG9lcyBub3QgZ2V0IGNhY2hlZCBieSB0aGUgaW5qZWN0b3IuXG4gICAgICAgICAqXG4gICAgICAgICAqICMjIyBFeGFtcGxlIChbbGl2ZSBkZW1vXShodHRwOi8vcGxua3IuY28vZWRpdC9wdENJbVE/cD1wcmV2aWV3KSlcbiAgICAgICAgICpcbiAgICAgICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAgICAgKiBASW5qZWN0YWJsZSgpXG4gICAgICAgICAqIGNsYXNzIEVuZ2luZSB7XG4gICAgICAgICAqIH1cbiAgICAgICAgICpcbiAgICAgICAgICogQEluamVjdGFibGUoKVxuICAgICAgICAgKiBjbGFzcyBDYXIge1xuICAgICAgICAgKiAgIGNvbnN0cnVjdG9yKHB1YmxpYyBlbmdpbmU6RW5naW5lKSB7fVxuICAgICAgICAgKiB9XG4gICAgICAgICAqXG4gICAgICAgICAqIHZhciBpbmplY3RvciA9IFJlZmxlY3RpdmVJbmplY3Rvci5yZXNvbHZlQW5kQ3JlYXRlKFtFbmdpbmVdKTtcbiAgICAgICAgICogdmFyIGNhclByb3ZpZGVyID0gUmVmbGVjdGl2ZUluamVjdG9yLnJlc29sdmUoW0Nhcl0pWzBdO1xuICAgICAgICAgKiB2YXIgY2FyID0gaW5qZWN0b3IuaW5zdGFudGlhdGVSZXNvbHZlZChjYXJQcm92aWRlcik7XG4gICAgICAgICAqIGV4cGVjdChjYXIuZW5naW5lKS50b0JlKGluamVjdG9yLmdldChFbmdpbmUpKTtcbiAgICAgICAgICogZXhwZWN0KGNhcikubm90LnRvQmUoaW5qZWN0b3IuaW5zdGFudGlhdGVSZXNvbHZlZChjYXJQcm92aWRlcikpO1xuICAgICAgICAgKiBgYGBcbiAgICAgICAgICovXG4gICAgICAgIFJlZmxlY3RpdmVJbmplY3Rvci5wcm90b3R5cGUuaW5zdGFudGlhdGVSZXNvbHZlZCA9IGZ1bmN0aW9uIChwcm92aWRlcikgeyByZXR1cm4gdW5pbXBsZW1lbnRlZCgpOyB9O1xuICAgICAgICByZXR1cm4gUmVmbGVjdGl2ZUluamVjdG9yO1xuICAgIH0oKSk7XG4gICAgdmFyIFJlZmxlY3RpdmVJbmplY3Rvcl8gPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogUHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gUmVmbGVjdGl2ZUluamVjdG9yXyhfcHJvdG8gLyogUHJvdG9JbmplY3RvciAqLywgX3BhcmVudCkge1xuICAgICAgICAgICAgaWYgKF9wYXJlbnQgPT09IHZvaWQgMCkgeyBfcGFyZW50ID0gbnVsbDsgfVxuICAgICAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICAgICAgdGhpcy5fY29uc3RydWN0aW9uQ291bnRlciA9IDA7XG4gICAgICAgICAgICB0aGlzLl9wcm90byA9IF9wcm90bztcbiAgICAgICAgICAgIHRoaXMuX3BhcmVudCA9IF9wYXJlbnQ7XG4gICAgICAgICAgICB0aGlzLl9zdHJhdGVneSA9IF9wcm90by5fc3RyYXRlZ3kuY3JlYXRlSW5qZWN0b3JTdHJhdGVneSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBSZWZsZWN0aXZlSW5qZWN0b3JfLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAodG9rZW4sIG5vdEZvdW5kVmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChub3RGb3VuZFZhbHVlID09PSB2b2lkIDApIHsgbm90Rm91bmRWYWx1ZSA9IFRIUk9XX0lGX05PVF9GT1VORDsgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldEJ5S2V5KFJlZmxlY3RpdmVLZXkuZ2V0KHRva2VuKSwgbnVsbCwgbnVsbCwgbm90Rm91bmRWYWx1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIFJlZmxlY3RpdmVJbmplY3Rvcl8ucHJvdG90eXBlLmdldEF0ID0gZnVuY3Rpb24gKGluZGV4KSB7IHJldHVybiB0aGlzLl9zdHJhdGVneS5nZXRPYmpBdEluZGV4KGluZGV4KTsgfTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlZmxlY3RpdmVJbmplY3Rvcl8ucHJvdG90eXBlLCBcInBhcmVudFwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3BhcmVudDsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWZsZWN0aXZlSW5qZWN0b3JfLnByb3RvdHlwZSwgXCJpbnRlcm5hbFN0cmF0ZWd5XCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAgICAgKiBJbnRlcm5hbC4gRG8gbm90IHVzZS5cbiAgICAgICAgICAgICAqIFdlIHJldHVybiBgYW55YCBub3QgdG8gZXhwb3J0IHRoZSBJbmplY3RvclN0cmF0ZWd5IHR5cGUuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fc3RyYXRlZ3k7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBSZWZsZWN0aXZlSW5qZWN0b3JfLnByb3RvdHlwZS5yZXNvbHZlQW5kQ3JlYXRlQ2hpbGQgPSBmdW5jdGlvbiAocHJvdmlkZXJzKSB7XG4gICAgICAgICAgICB2YXIgUmVzb2x2ZWRSZWZsZWN0aXZlUHJvdmlkZXJzID0gUmVmbGVjdGl2ZUluamVjdG9yLnJlc29sdmUocHJvdmlkZXJzKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUNoaWxkRnJvbVJlc29sdmVkKFJlc29sdmVkUmVmbGVjdGl2ZVByb3ZpZGVycyk7XG4gICAgICAgIH07XG4gICAgICAgIFJlZmxlY3RpdmVJbmplY3Rvcl8ucHJvdG90eXBlLmNyZWF0ZUNoaWxkRnJvbVJlc29sdmVkID0gZnVuY3Rpb24gKHByb3ZpZGVycykge1xuICAgICAgICAgICAgdmFyIHByb3RvID0gbmV3IFJlZmxlY3RpdmVQcm90b0luamVjdG9yKHByb3ZpZGVycyk7XG4gICAgICAgICAgICB2YXIgaW5qID0gbmV3IFJlZmxlY3RpdmVJbmplY3Rvcl8ocHJvdG8pO1xuICAgICAgICAgICAgaW5qLl9wYXJlbnQgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIGluajtcbiAgICAgICAgfTtcbiAgICAgICAgUmVmbGVjdGl2ZUluamVjdG9yXy5wcm90b3R5cGUucmVzb2x2ZUFuZEluc3RhbnRpYXRlID0gZnVuY3Rpb24gKHByb3ZpZGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbnN0YW50aWF0ZVJlc29sdmVkKFJlZmxlY3RpdmVJbmplY3Rvci5yZXNvbHZlKFtwcm92aWRlcl0pWzBdKTtcbiAgICAgICAgfTtcbiAgICAgICAgUmVmbGVjdGl2ZUluamVjdG9yXy5wcm90b3R5cGUuaW5zdGFudGlhdGVSZXNvbHZlZCA9IGZ1bmN0aW9uIChwcm92aWRlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2luc3RhbnRpYXRlUHJvdmlkZXIocHJvdmlkZXIpO1xuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIFJlZmxlY3RpdmVJbmplY3Rvcl8ucHJvdG90eXBlLl9uZXcgPSBmdW5jdGlvbiAocHJvdmlkZXIpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jb25zdHJ1Y3Rpb25Db3VudGVyKysgPiB0aGlzLl9zdHJhdGVneS5nZXRNYXhOdW1iZXJPZk9iamVjdHMoKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBDeWNsaWNEZXBlbmRlbmN5RXJyb3IodGhpcywgcHJvdmlkZXIua2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbnN0YW50aWF0ZVByb3ZpZGVyKHByb3ZpZGVyKTtcbiAgICAgICAgfTtcbiAgICAgICAgUmVmbGVjdGl2ZUluamVjdG9yXy5wcm90b3R5cGUuX2luc3RhbnRpYXRlUHJvdmlkZXIgPSBmdW5jdGlvbiAocHJvdmlkZXIpIHtcbiAgICAgICAgICAgIGlmIChwcm92aWRlci5tdWx0aVByb3ZpZGVyKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlcyA9IG5ldyBBcnJheShwcm92aWRlci5yZXNvbHZlZEZhY3Rvcmllcy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvdmlkZXIucmVzb2x2ZWRGYWN0b3JpZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzW2ldID0gdGhpcy5faW5zdGFudGlhdGUocHJvdmlkZXIsIHByb3ZpZGVyLnJlc29sdmVkRmFjdG9yaWVzW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbnN0YW50aWF0ZShwcm92aWRlciwgcHJvdmlkZXIucmVzb2x2ZWRGYWN0b3JpZXNbMF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBSZWZsZWN0aXZlSW5qZWN0b3JfLnByb3RvdHlwZS5faW5zdGFudGlhdGUgPSBmdW5jdGlvbiAocHJvdmlkZXIsIFJlc29sdmVkUmVmbGVjdGl2ZUZhY3RvcnkpIHtcbiAgICAgICAgICAgIHZhciBmYWN0b3J5ID0gUmVzb2x2ZWRSZWZsZWN0aXZlRmFjdG9yeS5mYWN0b3J5O1xuICAgICAgICAgICAgdmFyIGRlcHMgPSBSZXNvbHZlZFJlZmxlY3RpdmVGYWN0b3J5LmRlcGVuZGVuY2llcztcbiAgICAgICAgICAgIHZhciBsZW5ndGggPSBkZXBzLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBkMDtcbiAgICAgICAgICAgIHZhciBkMTtcbiAgICAgICAgICAgIHZhciBkMjtcbiAgICAgICAgICAgIHZhciBkMztcbiAgICAgICAgICAgIHZhciBkNDtcbiAgICAgICAgICAgIHZhciBkNTtcbiAgICAgICAgICAgIHZhciBkNjtcbiAgICAgICAgICAgIHZhciBkNztcbiAgICAgICAgICAgIHZhciBkODtcbiAgICAgICAgICAgIHZhciBkOTtcbiAgICAgICAgICAgIHZhciBkMTA7XG4gICAgICAgICAgICB2YXIgZDExO1xuICAgICAgICAgICAgdmFyIGQxMjtcbiAgICAgICAgICAgIHZhciBkMTM7XG4gICAgICAgICAgICB2YXIgZDE0O1xuICAgICAgICAgICAgdmFyIGQxNTtcbiAgICAgICAgICAgIHZhciBkMTY7XG4gICAgICAgICAgICB2YXIgZDE3O1xuICAgICAgICAgICAgdmFyIGQxODtcbiAgICAgICAgICAgIHZhciBkMTk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGQwID0gbGVuZ3RoID4gMCA/IHRoaXMuX2dldEJ5UmVmbGVjdGl2ZURlcGVuZGVuY3kocHJvdmlkZXIsIGRlcHNbMF0pIDogbnVsbDtcbiAgICAgICAgICAgICAgICBkMSA9IGxlbmd0aCA+IDEgPyB0aGlzLl9nZXRCeVJlZmxlY3RpdmVEZXBlbmRlbmN5KHByb3ZpZGVyLCBkZXBzWzFdKSA6IG51bGw7XG4gICAgICAgICAgICAgICAgZDIgPSBsZW5ndGggPiAyID8gdGhpcy5fZ2V0QnlSZWZsZWN0aXZlRGVwZW5kZW5jeShwcm92aWRlciwgZGVwc1syXSkgOiBudWxsO1xuICAgICAgICAgICAgICAgIGQzID0gbGVuZ3RoID4gMyA/IHRoaXMuX2dldEJ5UmVmbGVjdGl2ZURlcGVuZGVuY3kocHJvdmlkZXIsIGRlcHNbM10pIDogbnVsbDtcbiAgICAgICAgICAgICAgICBkNCA9IGxlbmd0aCA+IDQgPyB0aGlzLl9nZXRCeVJlZmxlY3RpdmVEZXBlbmRlbmN5KHByb3ZpZGVyLCBkZXBzWzRdKSA6IG51bGw7XG4gICAgICAgICAgICAgICAgZDUgPSBsZW5ndGggPiA1ID8gdGhpcy5fZ2V0QnlSZWZsZWN0aXZlRGVwZW5kZW5jeShwcm92aWRlciwgZGVwc1s1XSkgOiBudWxsO1xuICAgICAgICAgICAgICAgIGQ2ID0gbGVuZ3RoID4gNiA/IHRoaXMuX2dldEJ5UmVmbGVjdGl2ZURlcGVuZGVuY3kocHJvdmlkZXIsIGRlcHNbNl0pIDogbnVsbDtcbiAgICAgICAgICAgICAgICBkNyA9IGxlbmd0aCA+IDcgPyB0aGlzLl9nZXRCeVJlZmxlY3RpdmVEZXBlbmRlbmN5KHByb3ZpZGVyLCBkZXBzWzddKSA6IG51bGw7XG4gICAgICAgICAgICAgICAgZDggPSBsZW5ndGggPiA4ID8gdGhpcy5fZ2V0QnlSZWZsZWN0aXZlRGVwZW5kZW5jeShwcm92aWRlciwgZGVwc1s4XSkgOiBudWxsO1xuICAgICAgICAgICAgICAgIGQ5ID0gbGVuZ3RoID4gOSA/IHRoaXMuX2dldEJ5UmVmbGVjdGl2ZURlcGVuZGVuY3kocHJvdmlkZXIsIGRlcHNbOV0pIDogbnVsbDtcbiAgICAgICAgICAgICAgICBkMTAgPSBsZW5ndGggPiAxMCA/IHRoaXMuX2dldEJ5UmVmbGVjdGl2ZURlcGVuZGVuY3kocHJvdmlkZXIsIGRlcHNbMTBdKSA6IG51bGw7XG4gICAgICAgICAgICAgICAgZDExID0gbGVuZ3RoID4gMTEgPyB0aGlzLl9nZXRCeVJlZmxlY3RpdmVEZXBlbmRlbmN5KHByb3ZpZGVyLCBkZXBzWzExXSkgOiBudWxsO1xuICAgICAgICAgICAgICAgIGQxMiA9IGxlbmd0aCA+IDEyID8gdGhpcy5fZ2V0QnlSZWZsZWN0aXZlRGVwZW5kZW5jeShwcm92aWRlciwgZGVwc1sxMl0pIDogbnVsbDtcbiAgICAgICAgICAgICAgICBkMTMgPSBsZW5ndGggPiAxMyA/IHRoaXMuX2dldEJ5UmVmbGVjdGl2ZURlcGVuZGVuY3kocHJvdmlkZXIsIGRlcHNbMTNdKSA6IG51bGw7XG4gICAgICAgICAgICAgICAgZDE0ID0gbGVuZ3RoID4gMTQgPyB0aGlzLl9nZXRCeVJlZmxlY3RpdmVEZXBlbmRlbmN5KHByb3ZpZGVyLCBkZXBzWzE0XSkgOiBudWxsO1xuICAgICAgICAgICAgICAgIGQxNSA9IGxlbmd0aCA+IDE1ID8gdGhpcy5fZ2V0QnlSZWZsZWN0aXZlRGVwZW5kZW5jeShwcm92aWRlciwgZGVwc1sxNV0pIDogbnVsbDtcbiAgICAgICAgICAgICAgICBkMTYgPSBsZW5ndGggPiAxNiA/IHRoaXMuX2dldEJ5UmVmbGVjdGl2ZURlcGVuZGVuY3kocHJvdmlkZXIsIGRlcHNbMTZdKSA6IG51bGw7XG4gICAgICAgICAgICAgICAgZDE3ID0gbGVuZ3RoID4gMTcgPyB0aGlzLl9nZXRCeVJlZmxlY3RpdmVEZXBlbmRlbmN5KHByb3ZpZGVyLCBkZXBzWzE3XSkgOiBudWxsO1xuICAgICAgICAgICAgICAgIGQxOCA9IGxlbmd0aCA+IDE4ID8gdGhpcy5fZ2V0QnlSZWZsZWN0aXZlRGVwZW5kZW5jeShwcm92aWRlciwgZGVwc1sxOF0pIDogbnVsbDtcbiAgICAgICAgICAgICAgICBkMTkgPSBsZW5ndGggPiAxOSA/IHRoaXMuX2dldEJ5UmVmbGVjdGl2ZURlcGVuZGVuY3kocHJvdmlkZXIsIGRlcHNbMTldKSA6IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgQWJzdHJhY3RQcm92aWRlckVycm9yIHx8IGUgaW5zdGFuY2VvZiBJbnN0YW50aWF0aW9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5hZGRLZXkodGhpcywgcHJvdmlkZXIua2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBvYmo7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAobGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iaiA9IGZhY3RvcnkoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmogPSBmYWN0b3J5KGQwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmogPSBmYWN0b3J5KGQwLCBkMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqID0gZmFjdG9yeShkMCwgZDEsIGQyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmogPSBmYWN0b3J5KGQwLCBkMSwgZDIsIGQzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmogPSBmYWN0b3J5KGQwLCBkMSwgZDIsIGQzLCBkNCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqID0gZmFjdG9yeShkMCwgZDEsIGQyLCBkMywgZDQsIGQ1KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmogPSBmYWN0b3J5KGQwLCBkMSwgZDIsIGQzLCBkNCwgZDUsIGQ2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmogPSBmYWN0b3J5KGQwLCBkMSwgZDIsIGQzLCBkNCwgZDUsIGQ2LCBkNyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqID0gZmFjdG9yeShkMCwgZDEsIGQyLCBkMywgZDQsIGQ1LCBkNiwgZDcsIGQ4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqID0gZmFjdG9yeShkMCwgZDEsIGQyLCBkMywgZDQsIGQ1LCBkNiwgZDcsIGQ4LCBkOSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iaiA9IGZhY3RvcnkoZDAsIGQxLCBkMiwgZDMsIGQ0LCBkNSwgZDYsIGQ3LCBkOCwgZDksIGQxMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iaiA9IGZhY3RvcnkoZDAsIGQxLCBkMiwgZDMsIGQ0LCBkNSwgZDYsIGQ3LCBkOCwgZDksIGQxMCwgZDExKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqID0gZmFjdG9yeShkMCwgZDEsIGQyLCBkMywgZDQsIGQ1LCBkNiwgZDcsIGQ4LCBkOSwgZDEwLCBkMTEsIGQxMik7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iaiA9IGZhY3RvcnkoZDAsIGQxLCBkMiwgZDMsIGQ0LCBkNSwgZDYsIGQ3LCBkOCwgZDksIGQxMCwgZDExLCBkMTIsIGQxMyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iaiA9IGZhY3RvcnkoZDAsIGQxLCBkMiwgZDMsIGQ0LCBkNSwgZDYsIGQ3LCBkOCwgZDksIGQxMCwgZDExLCBkMTIsIGQxMywgZDE0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqID0gZmFjdG9yeShkMCwgZDEsIGQyLCBkMywgZDQsIGQ1LCBkNiwgZDcsIGQ4LCBkOSwgZDEwLCBkMTEsIGQxMiwgZDEzLCBkMTQsIGQxNSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxNzpcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iaiA9IGZhY3RvcnkoZDAsIGQxLCBkMiwgZDMsIGQ0LCBkNSwgZDYsIGQ3LCBkOCwgZDksIGQxMCwgZDExLCBkMTIsIGQxMywgZDE0LCBkMTUsIGQxNik7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxODpcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iaiA9IGZhY3RvcnkoZDAsIGQxLCBkMiwgZDMsIGQ0LCBkNSwgZDYsIGQ3LCBkOCwgZDksIGQxMCwgZDExLCBkMTIsIGQxMywgZDE0LCBkMTUsIGQxNiwgZDE3KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE5OlxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqID0gZmFjdG9yeShkMCwgZDEsIGQyLCBkMywgZDQsIGQ1LCBkNiwgZDcsIGQ4LCBkOSwgZDEwLCBkMTEsIGQxMiwgZDEzLCBkMTQsIGQxNSwgZDE2LCBkMTcsIGQxOCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iaiA9IGZhY3RvcnkoZDAsIGQxLCBkMiwgZDMsIGQ0LCBkNSwgZDYsIGQ3LCBkOCwgZDksIGQxMCwgZDExLCBkMTIsIGQxMywgZDE0LCBkMTUsIGQxNiwgZDE3LCBkMTgsIGQxOSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBpbnN0YW50aWF0ZSAnXCIgKyBwcm92aWRlci5rZXkuZGlzcGxheU5hbWUgKyBcIicgYmVjYXVzZSBpdCBoYXMgbW9yZSB0aGFuIDIwIGRlcGVuZGVuY2llc1wiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbnN0YW50aWF0aW9uRXJyb3IodGhpcywgZSwgZS5zdGFjaywgcHJvdmlkZXIua2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH07XG4gICAgICAgIFJlZmxlY3RpdmVJbmplY3Rvcl8ucHJvdG90eXBlLl9nZXRCeVJlZmxlY3RpdmVEZXBlbmRlbmN5ID0gZnVuY3Rpb24gKHByb3ZpZGVyLCBkZXApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRCeUtleShkZXAua2V5LCBkZXAubG93ZXJCb3VuZFZpc2liaWxpdHksIGRlcC51cHBlckJvdW5kVmlzaWJpbGl0eSwgZGVwLm9wdGlvbmFsID8gbnVsbCA6IFRIUk9XX0lGX05PVF9GT1VORCk7XG4gICAgICAgIH07XG4gICAgICAgIFJlZmxlY3RpdmVJbmplY3Rvcl8ucHJvdG90eXBlLl9nZXRCeUtleSA9IGZ1bmN0aW9uIChrZXksIGxvd2VyQm91bmRWaXNpYmlsaXR5LCB1cHBlckJvdW5kVmlzaWJpbGl0eSwgbm90Rm91bmRWYWx1ZSkge1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gSU5KRUNUT1JfS0VZKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodXBwZXJCb3VuZFZpc2liaWxpdHkgaW5zdGFuY2VvZiBTZWxmKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldEJ5S2V5U2VsZihrZXksIG5vdEZvdW5kVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldEJ5S2V5RGVmYXVsdChrZXksIG5vdEZvdW5kVmFsdWUsIGxvd2VyQm91bmRWaXNpYmlsaXR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBSZWZsZWN0aXZlSW5qZWN0b3JfLnByb3RvdHlwZS5fdGhyb3dPck51bGwgPSBmdW5jdGlvbiAoa2V5LCBub3RGb3VuZFZhbHVlKSB7XG4gICAgICAgICAgICBpZiAobm90Rm91bmRWYWx1ZSAhPT0gVEhST1dfSUZfTk9UX0ZPVU5EKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vdEZvdW5kVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm9Qcm92aWRlckVycm9yKHRoaXMsIGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgUmVmbGVjdGl2ZUluamVjdG9yXy5wcm90b3R5cGUuX2dldEJ5S2V5U2VsZiA9IGZ1bmN0aW9uIChrZXksIG5vdEZvdW5kVmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBvYmogPSB0aGlzLl9zdHJhdGVneS5nZXRPYmpCeUtleUlkKGtleS5pZCk7XG4gICAgICAgICAgICByZXR1cm4gKG9iaiAhPT0gVU5ERUZJTkVEKSA/IG9iaiA6IHRoaXMuX3Rocm93T3JOdWxsKGtleSwgbm90Rm91bmRWYWx1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgUmVmbGVjdGl2ZUluamVjdG9yXy5wcm90b3R5cGUuX2dldEJ5S2V5RGVmYXVsdCA9IGZ1bmN0aW9uIChrZXksIG5vdEZvdW5kVmFsdWUsIGxvd2VyQm91bmRWaXNpYmlsaXR5KSB7XG4gICAgICAgICAgICB2YXIgaW5qO1xuICAgICAgICAgICAgaWYgKGxvd2VyQm91bmRWaXNpYmlsaXR5IGluc3RhbmNlb2YgU2tpcFNlbGYpIHtcbiAgICAgICAgICAgICAgICBpbmogPSB0aGlzLl9wYXJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbmogPSB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKGluaiBpbnN0YW5jZW9mIFJlZmxlY3RpdmVJbmplY3Rvcl8pIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5qXyA9IGluajtcbiAgICAgICAgICAgICAgICB2YXIgb2JqID0gaW5qXy5fc3RyYXRlZ3kuZ2V0T2JqQnlLZXlJZChrZXkuaWQpO1xuICAgICAgICAgICAgICAgIGlmIChvYmogIT09IFVOREVGSU5FRClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgICAgICAgICBpbmogPSBpbmpfLl9wYXJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaW5qICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGluai5nZXQoa2V5LnRva2VuLCBub3RGb3VuZFZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl90aHJvd09yTnVsbChrZXksIG5vdEZvdW5kVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVmbGVjdGl2ZUluamVjdG9yXy5wcm90b3R5cGUsIFwiZGlzcGxheU5hbWVcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByb3ZpZGVycyA9IF9tYXBQcm92aWRlcnModGhpcywgZnVuY3Rpb24gKGIpIHsgcmV0dXJuICcgXCInICsgYi5rZXkuZGlzcGxheU5hbWUgKyAnXCIgJzsgfSlcbiAgICAgICAgICAgICAgICAgICAgLmpvaW4oJywgJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiUmVmbGVjdGl2ZUluamVjdG9yKHByb3ZpZGVyczogW1wiICsgcHJvdmlkZXJzICsgXCJdKVwiO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIFJlZmxlY3RpdmVJbmplY3Rvcl8ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5kaXNwbGF5TmFtZTsgfTtcbiAgICAgICAgcmV0dXJuIFJlZmxlY3RpdmVJbmplY3Rvcl87XG4gICAgfSgpKTtcbiAgICB2YXIgSU5KRUNUT1JfS0VZID0gUmVmbGVjdGl2ZUtleS5nZXQoSW5qZWN0b3IpO1xuICAgIGZ1bmN0aW9uIF9tYXBQcm92aWRlcnMoaW5qZWN0b3IsIGZuKSB7XG4gICAgICAgIHZhciByZXMgPSBuZXcgQXJyYXkoaW5qZWN0b3IuX3Byb3RvLm51bWJlck9mUHJvdmlkZXJzKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmplY3Rvci5fcHJvdG8ubnVtYmVyT2ZQcm92aWRlcnM7ICsraSkge1xuICAgICAgICAgICAgcmVzW2ldID0gZm4oaW5qZWN0b3IuX3Byb3RvLmdldFByb3ZpZGVyQXRJbmRleChpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQHdoYXRJdERvZXMgUHJvdmlkZXMgYSBob29rIGZvciBjZW50cmFsaXplZCBleGNlcHRpb24gaGFuZGxpbmcuXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKlxuICAgICAqIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIG9mIGBFcnJvckhhbmRsZXJgIHByaW50cyBlcnJvciBtZXNzYWdlcyB0byB0aGUgYGNvbnNvbGVgLiBUb1xuICAgICAqIGludGVyY2VwdCBlcnJvciBoYW5kbGluZywgd3JpdGUgYSBjdXN0b20gZXhjZXB0aW9uIGhhbmRsZXIgdGhhdCByZXBsYWNlcyB0aGlzIGRlZmF1bHQgYXNcbiAgICAgKiBhcHByb3ByaWF0ZSBmb3IgeW91ciBhcHAuXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZVxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogY2xhc3MgTXlFcnJvckhhbmRsZXIgaW1wbGVtZW50cyBFcnJvckhhbmRsZXIge1xuICAgICAqICAgaGFuZGxlRXJyb3IoZXJyb3IpIHtcbiAgICAgKiAgICAgLy8gZG8gc29tZXRoaW5nIHdpdGggdGhlIGV4Y2VwdGlvblxuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEBOZ01vZHVsZSh7XG4gICAgICogICBwcm92aWRlcnM6IFt7cHJvdmlkZTogRXJyb3JIYW5kbGVyLCB1c2VDbGFzczogTXlFcnJvckhhbmRsZXJ9XVxuICAgICAqIH0pXG4gICAgICogY2xhc3MgTXlNb2R1bGUge31cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgRXJyb3JIYW5kbGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gRXJyb3JIYW5kbGVyKHJldGhyb3dFcnJvcikge1xuICAgICAgICAgICAgaWYgKHJldGhyb3dFcnJvciA9PT0gdm9pZCAwKSB7IHJldGhyb3dFcnJvciA9IHRydWU7IH1cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuX2NvbnNvbGUgPSBjb25zb2xlO1xuICAgICAgICAgICAgdGhpcy5yZXRocm93RXJyb3IgPSByZXRocm93RXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgRXJyb3JIYW5kbGVyLnByb3RvdHlwZS5oYW5kbGVFcnJvciA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgdmFyIG9yaWdpbmFsRXJyb3IgPSB0aGlzLl9maW5kT3JpZ2luYWxFcnJvcihlcnJvcik7XG4gICAgICAgICAgICB2YXIgb3JpZ2luYWxTdGFjayA9IHRoaXMuX2ZpbmRPcmlnaW5hbFN0YWNrKGVycm9yKTtcbiAgICAgICAgICAgIHZhciBjb250ZXh0ID0gdGhpcy5fZmluZENvbnRleHQoZXJyb3IpO1xuICAgICAgICAgICAgdGhpcy5fY29uc29sZS5lcnJvcihcIkVYQ0VQVElPTjogXCIgKyB0aGlzLl9leHRyYWN0TWVzc2FnZShlcnJvcikpO1xuICAgICAgICAgICAgaWYgKG9yaWdpbmFsRXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb25zb2xlLmVycm9yKFwiT1JJR0lOQUwgRVhDRVBUSU9OOiBcIiArIHRoaXMuX2V4dHJhY3RNZXNzYWdlKG9yaWdpbmFsRXJyb3IpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcmlnaW5hbFN0YWNrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29uc29sZS5lcnJvcignT1JJR0lOQUwgU1RBQ0tUUkFDRTonKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb25zb2xlLmVycm9yKG9yaWdpbmFsU3RhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb25zb2xlLmVycm9yKCdFUlJPUiBDT05URVhUOicpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnNvbGUuZXJyb3IoY29udGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBXZSByZXRocm93IGV4Y2VwdGlvbnMsIHNvIG9wZXJhdGlvbnMgbGlrZSAnYm9vdHN0cmFwJyB3aWxsIHJlc3VsdCBpbiBhbiBlcnJvclxuICAgICAgICAgICAgLy8gd2hlbiBhbiBlcnJvciBoYXBwZW5zLiBJZiB3ZSBkbyBub3QgcmV0aHJvdywgYm9vdHN0cmFwIHdpbGwgYWx3YXlzIHN1Y2NlZWQuXG4gICAgICAgICAgICBpZiAodGhpcy5yZXRocm93RXJyb3IpXG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgRXJyb3JIYW5kbGVyLnByb3RvdHlwZS5fZXh0cmFjdE1lc3NhZ2UgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IGVycm9yLnRvU3RyaW5nKCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgRXJyb3JIYW5kbGVyLnByb3RvdHlwZS5fZmluZENvbnRleHQgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBlcnJvci5jb250ZXh0ID8gZXJyb3IuY29udGV4dCA6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2ZpbmRDb250ZXh0KGVycm9yLm9yaWdpbmFsRXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgRXJyb3JIYW5kbGVyLnByb3RvdHlwZS5fZmluZE9yaWdpbmFsRXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIHZhciBlID0gZXJyb3Iub3JpZ2luYWxFcnJvcjtcbiAgICAgICAgICAgIHdoaWxlIChlICYmIGUub3JpZ2luYWxFcnJvcikge1xuICAgICAgICAgICAgICAgIGUgPSBlLm9yaWdpbmFsRXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBFcnJvckhhbmRsZXIucHJvdG90eXBlLl9maW5kT3JpZ2luYWxTdGFjayA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKCEoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB2YXIgZSA9IGVycm9yO1xuICAgICAgICAgICAgdmFyIHN0YWNrID0gZS5zdGFjaztcbiAgICAgICAgICAgIHdoaWxlIChlIGluc3RhbmNlb2YgRXJyb3IgJiYgZS5vcmlnaW5hbEVycm9yKSB7XG4gICAgICAgICAgICAgICAgZSA9IGUub3JpZ2luYWxFcnJvcjtcbiAgICAgICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEVycm9yICYmIGUuc3RhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhY2sgPSBlLnN0YWNrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdGFjaztcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIEVycm9ySGFuZGxlcjtcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzUHJvbWlzZShvYmopIHtcbiAgICAgICAgLy8gYWxsb3cgYW55IFByb21pc2UvQSsgY29tcGxpYW50IHRoZW5hYmxlLlxuICAgICAgICAvLyBJdCdzIHVwIHRvIHRoZSBjYWxsZXIgdG8gZW5zdXJlIHRoYXQgb2JqLnRoZW4gY29uZm9ybXMgdG8gdGhlIHNwZWNcbiAgICAgICAgcmV0dXJuICEhb2JqICYmIHR5cGVvZiBvYmoudGhlbiA9PT0gJ2Z1bmN0aW9uJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBleGVjdXRlZCB3aGVuIGFuIGFwcGxpY2F0aW9uIGlzIGluaXRpYWxpemVkLlxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICB2YXIgQVBQX0lOSVRJQUxJWkVSID0gbmV3IE9wYXF1ZVRva2VuKCdBcHBsaWNhdGlvbiBJbml0aWFsaXplcicpO1xuICAgIC8qKlxuICAgICAqIEEgY2xhc3MgdGhhdCByZWZsZWN0cyB0aGUgc3RhdGUgb2YgcnVubmluZyB7QGxpbmsgQVBQX0lOSVRJQUxJWkVSfXMuXG4gICAgICpcbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgdmFyIEFwcGxpY2F0aW9uSW5pdFN0YXR1cyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEFwcGxpY2F0aW9uSW5pdFN0YXR1cyhhcHBJbml0cykge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuX2RvbmUgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBhc3luY0luaXRQcm9taXNlcyA9IFtdO1xuICAgICAgICAgICAgaWYgKGFwcEluaXRzKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcHBJbml0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5pdFJlc3VsdCA9IGFwcEluaXRzW2ldKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1Byb21pc2UoaW5pdFJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzeW5jSW5pdFByb21pc2VzLnB1c2goaW5pdFJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9kb25lUHJvbWlzZSA9IFByb21pc2UuYWxsKGFzeW5jSW5pdFByb21pc2VzKS50aGVuKGZ1bmN0aW9uICgpIHsgX3RoaXMuX2RvbmUgPSB0cnVlOyB9KTtcbiAgICAgICAgICAgIGlmIChhc3luY0luaXRQcm9taXNlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kb25lID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQXBwbGljYXRpb25Jbml0U3RhdHVzLnByb3RvdHlwZSwgXCJkb25lXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZG9uZTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBcHBsaWNhdGlvbkluaXRTdGF0dXMucHJvdG90eXBlLCBcImRvbmVQcm9taXNlXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZG9uZVByb21pc2U7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBBcHBsaWNhdGlvbkluaXRTdGF0dXMuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogSW5qZWN0YWJsZSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgQXBwbGljYXRpb25Jbml0U3RhdHVzLmN0b3JQYXJhbWV0ZXJzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBBcnJheSwgZGVjb3JhdG9yczogW3sgdHlwZTogSW5qZWN0LCBhcmdzOiBbQVBQX0lOSVRJQUxJWkVSLF0gfSwgeyB0eXBlOiBPcHRpb25hbCB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIEFwcGxpY2F0aW9uSW5pdFN0YXR1cztcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogQSBESSBUb2tlbiByZXByZXNlbnRpbmcgYSB1bmlxdWUgc3RyaW5nIGlkIGFzc2lnbmVkIHRvIHRoZSBhcHBsaWNhdGlvbiBieSBBbmd1bGFyIGFuZCB1c2VkXG4gICAgICogcHJpbWFyaWx5IGZvciBwcmVmaXhpbmcgYXBwbGljYXRpb24gYXR0cmlidXRlcyBhbmQgQ1NTIHN0eWxlcyB3aGVuXG4gICAgICoge0BsaW5rIFZpZXdFbmNhcHN1bGF0aW9uI0VtdWxhdGVkfSBpcyBiZWluZyB1c2VkLlxuICAgICAqXG4gICAgICogSWYgeW91IG5lZWQgdG8gYXZvaWQgcmFuZG9tbHkgZ2VuZXJhdGVkIHZhbHVlIHRvIGJlIHVzZWQgYXMgYW4gYXBwbGljYXRpb24gaWQsIHlvdSBjYW4gcHJvdmlkZVxuICAgICAqIGEgY3VzdG9tIHZhbHVlIHZpYSBhIERJIHByb3ZpZGVyIDwhLS0gVE9ETzogcHJvdmlkZXIgLS0+IGNvbmZpZ3VyaW5nIHRoZSByb290IHtAbGluayBJbmplY3Rvcn1cbiAgICAgKiB1c2luZyB0aGlzIHRva2VuLlxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICB2YXIgQVBQX0lEID0gbmV3IE9wYXF1ZVRva2VuKCdBcHBJZCcpO1xuICAgIGZ1bmN0aW9uIF9hcHBJZFJhbmRvbVByb3ZpZGVyRmFjdG9yeSgpIHtcbiAgICAgICAgcmV0dXJuIFwiXCIgKyBfcmFuZG9tQ2hhcigpICsgX3JhbmRvbUNoYXIoKSArIF9yYW5kb21DaGFyKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByb3ZpZGVycyB0aGF0IHdpbGwgZ2VuZXJhdGUgYSByYW5kb20gQVBQX0lEX1RPS0VOLlxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICB2YXIgQVBQX0lEX1JBTkRPTV9QUk9WSURFUiA9IHtcbiAgICAgICAgcHJvdmlkZTogQVBQX0lELFxuICAgICAgICB1c2VGYWN0b3J5OiBfYXBwSWRSYW5kb21Qcm92aWRlckZhY3RvcnksXG4gICAgICAgIGRlcHM6IFtdLFxuICAgIH07XG4gICAgZnVuY3Rpb24gX3JhbmRvbUNoYXIoKSB7XG4gICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKDk3ICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMjUpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgd2hlbiBhIHBsYXRmb3JtIGlzIGluaXRpYWxpemVkLlxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICB2YXIgUExBVEZPUk1fSU5JVElBTElaRVIgPSBuZXcgT3BhcXVlVG9rZW4oJ1BsYXRmb3JtIEluaXRpYWxpemVyJyk7XG4gICAgLyoqXG4gICAgICogQWxsIGNhbGxiYWNrcyBwcm92aWRlZCB2aWEgdGhpcyB0b2tlbiB3aWxsIGJlIGNhbGxlZCBmb3IgZXZlcnkgY29tcG9uZW50IHRoYXQgaXMgYm9vdHN0cmFwcGVkLlxuICAgICAqIFNpZ25hdHVyZSBvZiB0aGUgY2FsbGJhY2s6XG4gICAgICpcbiAgICAgKiBgKGNvbXBvbmVudFJlZjogQ29tcG9uZW50UmVmKSA9PiB2b2lkYC5cbiAgICAgKlxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICB2YXIgQVBQX0JPT1RTVFJBUF9MSVNURU5FUiA9IG5ldyBPcGFxdWVUb2tlbignYXBwQm9vdHN0cmFwTGlzdGVuZXInKTtcbiAgICAvKipcbiAgICAgKiBBIHRva2VuIHdoaWNoIGluZGljYXRlcyB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhlIGFwcGxpY2F0aW9uXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIHZhciBQQUNLQUdFX1JPT1RfVVJMID0gbmV3IE9wYXF1ZVRva2VuKCdBcHBsaWNhdGlvbiBQYWNrYWdlcyBSb290IFVSTCcpO1xuXG4gICAgdmFyIENvbnNvbGUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBDb25zb2xlKCkge1xuICAgICAgICB9XG4gICAgICAgIENvbnNvbGUucHJvdG90eXBlLmxvZyA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7IHByaW50KG1lc3NhZ2UpOyB9O1xuICAgICAgICAvLyBOb3RlOiBmb3IgcmVwb3J0aW5nIGVycm9ycyB1c2UgYERPTS5sb2dFcnJvcigpYCBhcyBpdCBpcyBwbGF0Zm9ybSBzcGVjaWZpY1xuICAgICAgICBDb25zb2xlLnByb3RvdHlwZS53YXJuID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHsgd2FybihtZXNzYWdlKTsgfTtcbiAgICAgICAgQ29uc29sZS5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBJbmplY3RhYmxlIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBDb25zb2xlLmN0b3JQYXJhbWV0ZXJzID0gW107XG4gICAgICAgIHJldHVybiBDb25zb2xlO1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgdmFyIF9fZXh0ZW5kcyQ0ID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHRoYXQgYSBjb21wb25lbnQgaXMgc3RpbGwgYmVpbmcgbG9hZGVkIGluIGEgc3luY2hyb25vdXMgY29tcGlsZS5cbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgQ29tcG9uZW50U3RpbGxMb2FkaW5nRXJyb3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMkNChDb21wb25lbnRTdGlsbExvYWRpbmdFcnJvciwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gQ29tcG9uZW50U3RpbGxMb2FkaW5nRXJyb3IoY29tcFR5cGUpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIFwiQ2FuJ3QgY29tcGlsZSBzeW5jaHJvbm91c2x5IGFzIFwiICsgc3RyaW5naWZ5KGNvbXBUeXBlKSArIFwiIGlzIHN0aWxsIGJlaW5nIGxvYWRlZCFcIik7XG4gICAgICAgICAgICB0aGlzLmNvbXBUeXBlID0gY29tcFR5cGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIENvbXBvbmVudFN0aWxsTG9hZGluZ0Vycm9yO1xuICAgIH0oQmFzZUVycm9yKSk7XG4gICAgLyoqXG4gICAgICogQ29tYmluYXRpb24gb2YgTmdNb2R1bGVGYWN0b3J5IGFuZCBDb21wb25lbnRGYWN0b3J5cy5cbiAgICAgKlxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICB2YXIgTW9kdWxlV2l0aENvbXBvbmVudEZhY3RvcmllcyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIE1vZHVsZVdpdGhDb21wb25lbnRGYWN0b3JpZXMobmdNb2R1bGVGYWN0b3J5LCBjb21wb25lbnRGYWN0b3JpZXMpIHtcbiAgICAgICAgICAgIHRoaXMubmdNb2R1bGVGYWN0b3J5ID0gbmdNb2R1bGVGYWN0b3J5O1xuICAgICAgICAgICAgdGhpcy5jb21wb25lbnRGYWN0b3JpZXMgPSBjb21wb25lbnRGYWN0b3JpZXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE1vZHVsZVdpdGhDb21wb25lbnRGYWN0b3JpZXM7XG4gICAgfSgpKTtcbiAgICBmdW5jdGlvbiBfdGhyb3dFcnJvcigpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUnVudGltZSBjb21waWxlciBpcyBub3QgbG9hZGVkXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb3ctbGV2ZWwgc2VydmljZSBmb3IgcnVubmluZyB0aGUgYW5ndWxhciBjb21waWxlciBkdXJpbmcgcnVudGltZVxuICAgICAqIHRvIGNyZWF0ZSB7QGxpbmsgQ29tcG9uZW50RmFjdG9yeX1zLCB3aGljaFxuICAgICAqIGNhbiBsYXRlciBiZSB1c2VkIHRvIGNyZWF0ZSBhbmQgcmVuZGVyIGEgQ29tcG9uZW50IGluc3RhbmNlLlxuICAgICAqXG4gICAgICogRWFjaCBgQE5nTW9kdWxlYCBwcm92aWRlcyBhbiBvd24gYENvbXBpbGVyYCB0byBpdHMgaW5qZWN0b3IsXG4gICAgICogdGhhdCB3aWxsIHVzZSB0aGUgZGlyZWN0aXZlcy9waXBlcyBvZiB0aGUgbmcgbW9kdWxlIGZvciBjb21waWxhdGlvblxuICAgICAqIG9mIGNvbXBvbmVudHMuXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBDb21waWxlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIENvbXBpbGVyKCkge1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb21waWxlcyB0aGUgZ2l2ZW4gTmdNb2R1bGUgYW5kIGFsbCBvZiBpdHMgY29tcG9uZW50cy4gQWxsIHRlbXBsYXRlcyBvZiB0aGUgY29tcG9uZW50cyBsaXN0ZWRcbiAgICAgICAgICogaW4gYGVudHJ5Q29tcG9uZW50c2BcbiAgICAgICAgICogaGF2ZSB0byBiZSBpbmxpbmVkLiBPdGhlcndpc2UgdGhyb3dzIGEge0BsaW5rIENvbXBvbmVudFN0aWxsTG9hZGluZ0Vycm9yfS5cbiAgICAgICAgICovXG4gICAgICAgIENvbXBpbGVyLnByb3RvdHlwZS5jb21waWxlTW9kdWxlU3luYyA9IGZ1bmN0aW9uIChtb2R1bGVUeXBlKSB7IHRocm93IF90aHJvd0Vycm9yKCk7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb21waWxlcyB0aGUgZ2l2ZW4gTmdNb2R1bGUgYW5kIGFsbCBvZiBpdHMgY29tcG9uZW50c1xuICAgICAgICAgKi9cbiAgICAgICAgQ29tcGlsZXIucHJvdG90eXBlLmNvbXBpbGVNb2R1bGVBc3luYyA9IGZ1bmN0aW9uIChtb2R1bGVUeXBlKSB7IHRocm93IF90aHJvd0Vycm9yKCk7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTYW1lIGFzIHtAbGluayBjb21waWxlTW9kdWxlU3luY30gYnV0IGFsc28gY3JlYXRlcyBDb21wb25lbnRGYWN0b3JpZXMgZm9yIGFsbCBjb21wb25lbnRzLlxuICAgICAgICAgKi9cbiAgICAgICAgQ29tcGlsZXIucHJvdG90eXBlLmNvbXBpbGVNb2R1bGVBbmRBbGxDb21wb25lbnRzU3luYyA9IGZ1bmN0aW9uIChtb2R1bGVUeXBlKSB7XG4gICAgICAgICAgICB0aHJvdyBfdGhyb3dFcnJvcigpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2FtZSBhcyB7QGxpbmsgY29tcGlsZU1vZHVsZUFzeW5jfSBidXQgYWxzbyBjcmVhdGVzIENvbXBvbmVudEZhY3RvcmllcyBmb3IgYWxsIGNvbXBvbmVudHMuXG4gICAgICAgICAqL1xuICAgICAgICBDb21waWxlci5wcm90b3R5cGUuY29tcGlsZU1vZHVsZUFuZEFsbENvbXBvbmVudHNBc3luYyA9IGZ1bmN0aW9uIChtb2R1bGVUeXBlKSB7XG4gICAgICAgICAgICB0aHJvdyBfdGhyb3dFcnJvcigpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2xlYXJzIGFsbCBjYWNoZXMuXG4gICAgICAgICAqL1xuICAgICAgICBDb21waWxlci5wcm90b3R5cGUuY2xlYXJDYWNoZSA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENsZWFycyB0aGUgY2FjaGUgZm9yIHRoZSBnaXZlbiBjb21wb25lbnQvbmdNb2R1bGUuXG4gICAgICAgICAqL1xuICAgICAgICBDb21waWxlci5wcm90b3R5cGUuY2xlYXJDYWNoZUZvciA9IGZ1bmN0aW9uICh0eXBlKSB7IH07XG4gICAgICAgIHJldHVybiBDb21waWxlcjtcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIFRva2VuIHRvIHByb3ZpZGUgQ29tcGlsZXJPcHRpb25zIGluIHRoZSBwbGF0Zm9ybSBpbmplY3Rvci5cbiAgICAgKlxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICB2YXIgQ09NUElMRVJfT1BUSU9OUyA9IG5ldyBPcGFxdWVUb2tlbignY29tcGlsZXJPcHRpb25zJyk7XG4gICAgLyoqXG4gICAgICogQSBmYWN0b3J5IGZvciBjcmVhdGluZyBhIENvbXBpbGVyXG4gICAgICpcbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgdmFyIENvbXBpbGVyRmFjdG9yeSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIENvbXBpbGVyRmFjdG9yeSgpIHtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQ29tcGlsZXJGYWN0b3J5O1xuICAgIH0oKSk7XG5cbiAgICB2YXIgRGVmYXVsdEl0ZXJhYmxlRGlmZmVyRmFjdG9yeSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIERlZmF1bHRJdGVyYWJsZURpZmZlckZhY3RvcnkoKSB7XG4gICAgICAgIH1cbiAgICAgICAgRGVmYXVsdEl0ZXJhYmxlRGlmZmVyRmFjdG9yeS5wcm90b3R5cGUuc3VwcG9ydHMgPSBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBpc0xpc3RMaWtlSXRlcmFibGUob2JqKTsgfTtcbiAgICAgICAgRGVmYXVsdEl0ZXJhYmxlRGlmZmVyRmFjdG9yeS5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gKGNkUmVmLCB0cmFja0J5Rm4pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGVmYXVsdEl0ZXJhYmxlRGlmZmVyKHRyYWNrQnlGbik7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBEZWZhdWx0SXRlcmFibGVEaWZmZXJGYWN0b3J5O1xuICAgIH0oKSk7XG4gICAgdmFyIHRyYWNrQnlJZGVudGl0eSA9IGZ1bmN0aW9uIChpbmRleCwgaXRlbSkgeyByZXR1cm4gaXRlbTsgfTtcbiAgICAvKipcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIERlZmF1bHRJdGVyYWJsZURpZmZlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIERlZmF1bHRJdGVyYWJsZURpZmZlcihfdHJhY2tCeUZuKSB7XG4gICAgICAgICAgICB0aGlzLl90cmFja0J5Rm4gPSBfdHJhY2tCeUZuO1xuICAgICAgICAgICAgdGhpcy5fbGVuZ3RoID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX2NvbGxlY3Rpb24gPSBudWxsO1xuICAgICAgICAgICAgLy8gS2VlcHMgdHJhY2sgb2YgdGhlIHVzZWQgcmVjb3JkcyBhdCBhbnkgcG9pbnQgaW4gdGltZSAoZHVyaW5nICYgYWNyb3NzIGBfY2hlY2soKWAgY2FsbHMpXG4gICAgICAgICAgICB0aGlzLl9saW5rZWRSZWNvcmRzID0gbnVsbDtcbiAgICAgICAgICAgIC8vIEtlZXBzIHRyYWNrIG9mIHRoZSByZW1vdmVkIHJlY29yZHMgYXQgYW55IHBvaW50IGluIHRpbWUgZHVyaW5nIGBfY2hlY2soKWAgY2FsbHMuXG4gICAgICAgICAgICB0aGlzLl91bmxpbmtlZFJlY29yZHMgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fcHJldmlvdXNJdEhlYWQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5faXRIZWFkID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX2l0VGFpbCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9hZGRpdGlvbnNIZWFkID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX2FkZGl0aW9uc1RhaWwgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fbW92ZXNIZWFkID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX21vdmVzVGFpbCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9yZW1vdmFsc0hlYWQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fcmVtb3ZhbHNUYWlsID0gbnVsbDtcbiAgICAgICAgICAgIC8vIEtlZXBzIHRyYWNrIG9mIHJlY29yZHMgd2hlcmUgY3VzdG9tIHRyYWNrIGJ5IGlzIHRoZSBzYW1lLCBidXQgaXRlbSBpZGVudGl0eSBoYXMgY2hhbmdlZFxuICAgICAgICAgICAgdGhpcy5faWRlbnRpdHlDaGFuZ2VzSGVhZCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9pZGVudGl0eUNoYW5nZXNUYWlsID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX3RyYWNrQnlGbiA9IHRoaXMuX3RyYWNrQnlGbiB8fCB0cmFja0J5SWRlbnRpdHk7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERlZmF1bHRJdGVyYWJsZURpZmZlci5wcm90b3R5cGUsIFwiY29sbGVjdGlvblwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2NvbGxlY3Rpb247IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGVmYXVsdEl0ZXJhYmxlRGlmZmVyLnByb3RvdHlwZSwgXCJsZW5ndGhcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9sZW5ndGg7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBEZWZhdWx0SXRlcmFibGVEaWZmZXIucHJvdG90eXBlLmZvckVhY2hJdGVtID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICB2YXIgcmVjb3JkO1xuICAgICAgICAgICAgZm9yIChyZWNvcmQgPSB0aGlzLl9pdEhlYWQ7IHJlY29yZCAhPT0gbnVsbDsgcmVjb3JkID0gcmVjb3JkLl9uZXh0KSB7XG4gICAgICAgICAgICAgICAgZm4ocmVjb3JkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgRGVmYXVsdEl0ZXJhYmxlRGlmZmVyLnByb3RvdHlwZS5mb3JFYWNoT3BlcmF0aW9uID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICB2YXIgbmV4dEl0ID0gdGhpcy5faXRIZWFkO1xuICAgICAgICAgICAgdmFyIG5leHRSZW1vdmUgPSB0aGlzLl9yZW1vdmFsc0hlYWQ7XG4gICAgICAgICAgICB2YXIgYWRkUmVtb3ZlT2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIHZhciBtb3ZlT2Zmc2V0cyA9IG51bGw7XG4gICAgICAgICAgICB3aGlsZSAobmV4dEl0IHx8IG5leHRSZW1vdmUpIHtcbiAgICAgICAgICAgICAgICAvLyBGaWd1cmUgb3V0IHdoaWNoIGlzIHRoZSBuZXh0IHJlY29yZCB0byBwcm9jZXNzXG4gICAgICAgICAgICAgICAgLy8gT3JkZXI6IHJlbW92ZSwgYWRkLCBtb3ZlXG4gICAgICAgICAgICAgICAgdmFyIHJlY29yZCA9ICFuZXh0UmVtb3ZlIHx8XG4gICAgICAgICAgICAgICAgICAgIG5leHRJdCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dEl0LmN1cnJlbnRJbmRleCA8IGdldFByZXZpb3VzSW5kZXgobmV4dFJlbW92ZSwgYWRkUmVtb3ZlT2Zmc2V0LCBtb3ZlT2Zmc2V0cykgP1xuICAgICAgICAgICAgICAgICAgICBuZXh0SXQgOlxuICAgICAgICAgICAgICAgICAgICBuZXh0UmVtb3ZlO1xuICAgICAgICAgICAgICAgIHZhciBhZGpQcmV2aW91c0luZGV4ID0gZ2V0UHJldmlvdXNJbmRleChyZWNvcmQsIGFkZFJlbW92ZU9mZnNldCwgbW92ZU9mZnNldHMpO1xuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50SW5kZXggPSByZWNvcmQuY3VycmVudEluZGV4O1xuICAgICAgICAgICAgICAgIC8vIGNvbnN1bWUgdGhlIGl0ZW0sIGFuZCBhZGp1c3QgdGhlIGFkZFJlbW92ZU9mZnNldCBhbmQgdXBkYXRlIG1vdmVEaXN0YW5jZSBpZiBuZWNlc3NhcnlcbiAgICAgICAgICAgICAgICBpZiAocmVjb3JkID09PSBuZXh0UmVtb3ZlKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZFJlbW92ZU9mZnNldC0tO1xuICAgICAgICAgICAgICAgICAgICBuZXh0UmVtb3ZlID0gbmV4dFJlbW92ZS5fbmV4dFJlbW92ZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBuZXh0SXQgPSBuZXh0SXQuX25leHQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWNvcmQucHJldmlvdXNJbmRleCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRSZW1vdmVPZmZzZXQrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElOVkFSSUFOVDogIGN1cnJlbnRJbmRleCA8IHByZXZpb3VzSW5kZXhcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbW92ZU9mZnNldHMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW92ZU9mZnNldHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsb2NhbE1vdmVQcmV2aW91c0luZGV4ID0gYWRqUHJldmlvdXNJbmRleCAtIGFkZFJlbW92ZU9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsb2NhbEN1cnJlbnRJbmRleCA9IGN1cnJlbnRJbmRleCAtIGFkZFJlbW92ZU9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsb2NhbE1vdmVQcmV2aW91c0luZGV4ICE9IGxvY2FsQ3VycmVudEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsb2NhbE1vdmVQcmV2aW91c0luZGV4OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9mZnNldCA9IGkgPCBtb3ZlT2Zmc2V0cy5sZW5ndGggPyBtb3ZlT2Zmc2V0c1tpXSA6IChtb3ZlT2Zmc2V0c1tpXSA9IDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBvZmZzZXQgKyBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobG9jYWxDdXJyZW50SW5kZXggPD0gaW5kZXggJiYgaW5kZXggPCBsb2NhbE1vdmVQcmV2aW91c0luZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb3ZlT2Zmc2V0c1tpXSA9IG9mZnNldCArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByZXZpb3VzSW5kZXggPSByZWNvcmQucHJldmlvdXNJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb3ZlT2Zmc2V0c1twcmV2aW91c0luZGV4XSA9IGxvY2FsQ3VycmVudEluZGV4IC0gbG9jYWxNb3ZlUHJldmlvdXNJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYWRqUHJldmlvdXNJbmRleCAhPT0gY3VycmVudEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGZuKHJlY29yZCwgYWRqUHJldmlvdXNJbmRleCwgY3VycmVudEluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIERlZmF1bHRJdGVyYWJsZURpZmZlci5wcm90b3R5cGUuZm9yRWFjaFByZXZpb3VzSXRlbSA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgdmFyIHJlY29yZDtcbiAgICAgICAgICAgIGZvciAocmVjb3JkID0gdGhpcy5fcHJldmlvdXNJdEhlYWQ7IHJlY29yZCAhPT0gbnVsbDsgcmVjb3JkID0gcmVjb3JkLl9uZXh0UHJldmlvdXMpIHtcbiAgICAgICAgICAgICAgICBmbihyZWNvcmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBEZWZhdWx0SXRlcmFibGVEaWZmZXIucHJvdG90eXBlLmZvckVhY2hBZGRlZEl0ZW0gPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgIHZhciByZWNvcmQ7XG4gICAgICAgICAgICBmb3IgKHJlY29yZCA9IHRoaXMuX2FkZGl0aW9uc0hlYWQ7IHJlY29yZCAhPT0gbnVsbDsgcmVjb3JkID0gcmVjb3JkLl9uZXh0QWRkZWQpIHtcbiAgICAgICAgICAgICAgICBmbihyZWNvcmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBEZWZhdWx0SXRlcmFibGVEaWZmZXIucHJvdG90eXBlLmZvckVhY2hNb3ZlZEl0ZW0gPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgIHZhciByZWNvcmQ7XG4gICAgICAgICAgICBmb3IgKHJlY29yZCA9IHRoaXMuX21vdmVzSGVhZDsgcmVjb3JkICE9PSBudWxsOyByZWNvcmQgPSByZWNvcmQuX25leHRNb3ZlZCkge1xuICAgICAgICAgICAgICAgIGZuKHJlY29yZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIERlZmF1bHRJdGVyYWJsZURpZmZlci5wcm90b3R5cGUuZm9yRWFjaFJlbW92ZWRJdGVtID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICB2YXIgcmVjb3JkO1xuICAgICAgICAgICAgZm9yIChyZWNvcmQgPSB0aGlzLl9yZW1vdmFsc0hlYWQ7IHJlY29yZCAhPT0gbnVsbDsgcmVjb3JkID0gcmVjb3JkLl9uZXh0UmVtb3ZlZCkge1xuICAgICAgICAgICAgICAgIGZuKHJlY29yZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIERlZmF1bHRJdGVyYWJsZURpZmZlci5wcm90b3R5cGUuZm9yRWFjaElkZW50aXR5Q2hhbmdlID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICB2YXIgcmVjb3JkO1xuICAgICAgICAgICAgZm9yIChyZWNvcmQgPSB0aGlzLl9pZGVudGl0eUNoYW5nZXNIZWFkOyByZWNvcmQgIT09IG51bGw7IHJlY29yZCA9IHJlY29yZC5fbmV4dElkZW50aXR5Q2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgZm4ocmVjb3JkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgRGVmYXVsdEl0ZXJhYmxlRGlmZmVyLnByb3RvdHlwZS5kaWZmID0gZnVuY3Rpb24gKGNvbGxlY3Rpb24pIHtcbiAgICAgICAgICAgIGlmIChpc0JsYW5rKGNvbGxlY3Rpb24pKVxuICAgICAgICAgICAgICAgIGNvbGxlY3Rpb24gPSBbXTtcbiAgICAgICAgICAgIGlmICghaXNMaXN0TGlrZUl0ZXJhYmxlKGNvbGxlY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgdHJ5aW5nIHRvIGRpZmYgJ1wiICsgY29sbGVjdGlvbiArIFwiJ1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNoZWNrKGNvbGxlY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgRGVmYXVsdEl0ZXJhYmxlRGlmZmVyLnByb3RvdHlwZS5vbkRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgIC8vIHRvZG8odmljYik6IG9wdGltIGZvciBVbm1vZGlmaWFibGVMaXN0VmlldyAoZnJvemVuIGFycmF5cylcbiAgICAgICAgRGVmYXVsdEl0ZXJhYmxlRGlmZmVyLnByb3RvdHlwZS5jaGVjayA9IGZ1bmN0aW9uIChjb2xsZWN0aW9uKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5fcmVzZXQoKTtcbiAgICAgICAgICAgIHZhciByZWNvcmQgPSB0aGlzLl9pdEhlYWQ7XG4gICAgICAgICAgICB2YXIgbWF5QmVEaXJ0eSA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIGluZGV4O1xuICAgICAgICAgICAgdmFyIGl0ZW07XG4gICAgICAgICAgICB2YXIgaXRlbVRyYWNrQnk7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjb2xsZWN0aW9uKSkge1xuICAgICAgICAgICAgICAgIHZhciBsaXN0ID0gY29sbGVjdGlvbjtcbiAgICAgICAgICAgICAgICB0aGlzLl9sZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpbmRleF8xID0gMDsgaW5kZXhfMSA8IHRoaXMuX2xlbmd0aDsgaW5kZXhfMSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0gPSBsaXN0W2luZGV4XzFdO1xuICAgICAgICAgICAgICAgICAgICBpdGVtVHJhY2tCeSA9IHRoaXMuX3RyYWNrQnlGbihpbmRleF8xLCBpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlY29yZCA9PT0gbnVsbCB8fCAhbG9vc2VJZGVudGljYWwocmVjb3JkLnRyYWNrQnlJZCwgaXRlbVRyYWNrQnkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWNvcmQgPSB0aGlzLl9taXNtYXRjaChyZWNvcmQsIGl0ZW0sIGl0ZW1UcmFja0J5LCBpbmRleF8xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heUJlRGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1heUJlRGlydHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPKG1pc2tvKTogY2FuIHdlIGxpbWl0IHRoaXMgdG8gZHVwbGljYXRlcyBvbmx5P1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY29yZCA9IHRoaXMuX3ZlcmlmeVJlaW5zZXJ0aW9uKHJlY29yZCwgaXRlbSwgaXRlbVRyYWNrQnksIGluZGV4XzEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFsb29zZUlkZW50aWNhbChyZWNvcmQuaXRlbSwgaXRlbSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkSWRlbnRpdHlDaGFuZ2UocmVjb3JkLCBpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZWNvcmQgPSByZWNvcmQuX25leHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSAwO1xuICAgICAgICAgICAgICAgIGl0ZXJhdGVMaXN0TGlrZShjb2xsZWN0aW9uLCBmdW5jdGlvbiAoaXRlbSAvKiogVE9ETyAjOTEwMCAqLykge1xuICAgICAgICAgICAgICAgICAgICBpdGVtVHJhY2tCeSA9IF90aGlzLl90cmFja0J5Rm4oaW5kZXgsIGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVjb3JkID09PSBudWxsIHx8ICFsb29zZUlkZW50aWNhbChyZWNvcmQudHJhY2tCeUlkLCBpdGVtVHJhY2tCeSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY29yZCA9IF90aGlzLl9taXNtYXRjaChyZWNvcmQsIGl0ZW0sIGl0ZW1UcmFja0J5LCBpbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXlCZURpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXlCZURpcnR5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyhtaXNrbyk6IGNhbiB3ZSBsaW1pdCB0aGlzIHRvIGR1cGxpY2F0ZXMgb25seT9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWNvcmQgPSBfdGhpcy5fdmVyaWZ5UmVpbnNlcnRpb24ocmVjb3JkLCBpdGVtLCBpdGVtVHJhY2tCeSwgaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFsb29zZUlkZW50aWNhbChyZWNvcmQuaXRlbSwgaXRlbSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2FkZElkZW50aXR5Q2hhbmdlKHJlY29yZCwgaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVjb3JkID0gcmVjb3JkLl9uZXh0O1xuICAgICAgICAgICAgICAgICAgICBpbmRleCsrO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuX2xlbmd0aCA9IGluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fdHJ1bmNhdGUocmVjb3JkKTtcbiAgICAgICAgICAgIHRoaXMuX2NvbGxlY3Rpb24gPSBjb2xsZWN0aW9uO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXNEaXJ0eTtcbiAgICAgICAgfTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERlZmF1bHRJdGVyYWJsZURpZmZlci5wcm90b3R5cGUsIFwiaXNEaXJ0eVwiLCB7XG4gICAgICAgICAgICAvKiBDb2xsZWN0aW9uQ2hhbmdlcyBpcyBjb25zaWRlcmVkIGRpcnR5IGlmIGl0IGhhcyBhbnkgYWRkaXRpb25zLCBtb3ZlcywgcmVtb3ZhbHMsIG9yIGlkZW50aXR5XG4gICAgICAgICAgICAgKiBjaGFuZ2VzLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYWRkaXRpb25zSGVhZCAhPT0gbnVsbCB8fCB0aGlzLl9tb3Zlc0hlYWQgIT09IG51bGwgfHxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVtb3ZhbHNIZWFkICE9PSBudWxsIHx8IHRoaXMuX2lkZW50aXR5Q2hhbmdlc0hlYWQgIT09IG51bGw7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlc2V0IHRoZSBzdGF0ZSBvZiB0aGUgY2hhbmdlIG9iamVjdHMgdG8gc2hvdyBubyBjaGFuZ2VzLiBUaGlzIG1lYW5zIHNldCBwcmV2aW91c0tleSB0b1xuICAgICAgICAgKiBjdXJyZW50S2V5LCBhbmQgY2xlYXIgYWxsIG9mIHRoZSBxdWV1ZXMgKGFkZGl0aW9ucywgbW92ZXMsIHJlbW92YWxzKS5cbiAgICAgICAgICogU2V0IHRoZSBwcmV2aW91c0luZGV4ZXMgb2YgbW92ZWQgYW5kIGFkZGVkIGl0ZW1zIHRvIHRoZWlyIGN1cnJlbnRJbmRleGVzXG4gICAgICAgICAqIFJlc2V0IHRoZSBsaXN0IG9mIGFkZGl0aW9ucywgbW92ZXMgYW5kIHJlbW92YWxzXG4gICAgICAgICAqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKi9cbiAgICAgICAgRGVmYXVsdEl0ZXJhYmxlRGlmZmVyLnByb3RvdHlwZS5fcmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc0RpcnR5KSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlY29yZDtcbiAgICAgICAgICAgICAgICB2YXIgbmV4dFJlY29yZDtcbiAgICAgICAgICAgICAgICBmb3IgKHJlY29yZCA9IHRoaXMuX3ByZXZpb3VzSXRIZWFkID0gdGhpcy5faXRIZWFkOyByZWNvcmQgIT09IG51bGw7IHJlY29yZCA9IHJlY29yZC5fbmV4dCkge1xuICAgICAgICAgICAgICAgICAgICByZWNvcmQuX25leHRQcmV2aW91cyA9IHJlY29yZC5fbmV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChyZWNvcmQgPSB0aGlzLl9hZGRpdGlvbnNIZWFkOyByZWNvcmQgIT09IG51bGw7IHJlY29yZCA9IHJlY29yZC5fbmV4dEFkZGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlY29yZC5wcmV2aW91c0luZGV4ID0gcmVjb3JkLmN1cnJlbnRJbmRleDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkaXRpb25zSGVhZCA9IHRoaXMuX2FkZGl0aW9uc1RhaWwgPSBudWxsO1xuICAgICAgICAgICAgICAgIGZvciAocmVjb3JkID0gdGhpcy5fbW92ZXNIZWFkOyByZWNvcmQgIT09IG51bGw7IHJlY29yZCA9IG5leHRSZWNvcmQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVjb3JkLnByZXZpb3VzSW5kZXggPSByZWNvcmQuY3VycmVudEluZGV4O1xuICAgICAgICAgICAgICAgICAgICBuZXh0UmVjb3JkID0gcmVjb3JkLl9uZXh0TW92ZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX21vdmVzSGVhZCA9IHRoaXMuX21vdmVzVGFpbCA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVtb3ZhbHNIZWFkID0gdGhpcy5fcmVtb3ZhbHNUYWlsID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLl9pZGVudGl0eUNoYW5nZXNIZWFkID0gdGhpcy5faWRlbnRpdHlDaGFuZ2VzVGFpbCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGlzIHRoZSBjb3JlIGZ1bmN0aW9uIHdoaWNoIGhhbmRsZXMgZGlmZmVyZW5jZXMgYmV0d2VlbiBjb2xsZWN0aW9ucy5cbiAgICAgICAgICpcbiAgICAgICAgICogLSBgcmVjb3JkYCBpcyB0aGUgcmVjb3JkIHdoaWNoIHdlIHNhdyBhdCB0aGlzIHBvc2l0aW9uIGxhc3QgdGltZS4gSWYgbnVsbCB0aGVuIGl0IGlzIGEgbmV3XG4gICAgICAgICAqICAgaXRlbS5cbiAgICAgICAgICogLSBgaXRlbWAgaXMgdGhlIGN1cnJlbnQgaXRlbSBpbiB0aGUgY29sbGVjdGlvblxuICAgICAgICAgKiAtIGBpbmRleGAgaXMgdGhlIHBvc2l0aW9uIG9mIHRoZSBpdGVtIGluIHRoZSBjb2xsZWN0aW9uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKi9cbiAgICAgICAgRGVmYXVsdEl0ZXJhYmxlRGlmZmVyLnByb3RvdHlwZS5fbWlzbWF0Y2ggPSBmdW5jdGlvbiAocmVjb3JkLCBpdGVtLCBpdGVtVHJhY2tCeSwgaW5kZXgpIHtcbiAgICAgICAgICAgIC8vIFRoZSBwcmV2aW91cyByZWNvcmQgYWZ0ZXIgd2hpY2ggd2Ugd2lsbCBhcHBlbmQgdGhlIGN1cnJlbnQgb25lLlxuICAgICAgICAgICAgdmFyIHByZXZpb3VzUmVjb3JkO1xuICAgICAgICAgICAgaWYgKHJlY29yZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHByZXZpb3VzUmVjb3JkID0gdGhpcy5faXRUYWlsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJldmlvdXNSZWNvcmQgPSByZWNvcmQuX3ByZXY7XG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSByZWNvcmQgZnJvbSB0aGUgY29sbGVjdGlvbiBzaW5jZSB3ZSBrbm93IGl0IGRvZXMgbm90IG1hdGNoIHRoZSBpdGVtLlxuICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92ZShyZWNvcmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQXR0ZW1wdCB0byBzZWUgaWYgd2UgaGF2ZSBzZWVuIHRoZSBpdGVtIGJlZm9yZS5cbiAgICAgICAgICAgIHJlY29yZCA9IHRoaXMuX2xpbmtlZFJlY29yZHMgPT09IG51bGwgPyBudWxsIDogdGhpcy5fbGlua2VkUmVjb3Jkcy5nZXQoaXRlbVRyYWNrQnksIGluZGV4KTtcbiAgICAgICAgICAgIGlmIChyZWNvcmQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBoYXZlIHNlZW4gdGhpcyBiZWZvcmUsIHdlIG5lZWQgdG8gbW92ZSBpdCBmb3J3YXJkIGluIHRoZSBjb2xsZWN0aW9uLlxuICAgICAgICAgICAgICAgIC8vIEJ1dCBmaXJzdCB3ZSBuZWVkIHRvIGNoZWNrIGlmIGlkZW50aXR5IGNoYW5nZWQsIHNvIHdlIGNhbiB1cGRhdGUgaW4gdmlldyBpZiBuZWNlc3NhcnlcbiAgICAgICAgICAgICAgICBpZiAoIWxvb3NlSWRlbnRpY2FsKHJlY29yZC5pdGVtLCBpdGVtKSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkSWRlbnRpdHlDaGFuZ2UocmVjb3JkLCBpdGVtKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9tb3ZlQWZ0ZXIocmVjb3JkLCBwcmV2aW91c1JlY29yZCwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gTmV2ZXIgc2VlbiBpdCwgY2hlY2sgZXZpY3RlZCBsaXN0LlxuICAgICAgICAgICAgICAgIHJlY29yZCA9IHRoaXMuX3VubGlua2VkUmVjb3JkcyA9PT0gbnVsbCA/IG51bGwgOiB0aGlzLl91bmxpbmtlZFJlY29yZHMuZ2V0KGl0ZW1UcmFja0J5KTtcbiAgICAgICAgICAgICAgICBpZiAocmVjb3JkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEl0IGlzIGFuIGl0ZW0gd2hpY2ggd2UgaGF2ZSBldmljdGVkIGVhcmxpZXI6IHJlaW5zZXJ0IGl0IGJhY2sgaW50byB0aGUgbGlzdC5cbiAgICAgICAgICAgICAgICAgICAgLy8gQnV0IGZpcnN0IHdlIG5lZWQgdG8gY2hlY2sgaWYgaWRlbnRpdHkgY2hhbmdlZCwgc28gd2UgY2FuIHVwZGF0ZSBpbiB2aWV3IGlmIG5lY2Vzc2FyeVxuICAgICAgICAgICAgICAgICAgICBpZiAoIWxvb3NlSWRlbnRpY2FsKHJlY29yZC5pdGVtLCBpdGVtKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZElkZW50aXR5Q2hhbmdlKHJlY29yZCwgaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlaW5zZXJ0QWZ0ZXIocmVjb3JkLCBwcmV2aW91c1JlY29yZCwgaW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSXQgaXMgYSBuZXcgaXRlbTogYWRkIGl0LlxuICAgICAgICAgICAgICAgICAgICByZWNvcmQgPVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkQWZ0ZXIobmV3IENvbGxlY3Rpb25DaGFuZ2VSZWNvcmQoaXRlbSwgaXRlbVRyYWNrQnkpLCBwcmV2aW91c1JlY29yZCwgaW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZWNvcmQ7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGNoZWNrIGlzIG9ubHkgbmVlZGVkIGlmIGFuIGFycmF5IGNvbnRhaW5zIGR1cGxpY2F0ZXMuIChTaG9ydCBjaXJjdWl0IG9mIG5vdGhpbmcgZGlydHkpXG4gICAgICAgICAqXG4gICAgICAgICAqIFVzZSBjYXNlOiBgW2EsIGFdYCA9PiBgW2IsIGEsIGFdYFxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiB3ZSBkaWQgbm90IGhhdmUgdGhpcyBjaGVjayB0aGVuIHRoZSBpbnNlcnRpb24gb2YgYGJgIHdvdWxkOlxuICAgICAgICAgKiAgIDEpIGV2aWN0IGZpcnN0IGBhYFxuICAgICAgICAgKiAgIDIpIGluc2VydCBgYmAgYXQgYDBgIGluZGV4LlxuICAgICAgICAgKiAgIDMpIGxlYXZlIGBhYCBhdCBpbmRleCBgMWAgYXMgaXMuIDwtLSB0aGlzIGlzIHdyb25nIVxuICAgICAgICAgKiAgIDMpIHJlaW5zZXJ0IGBhYCBhdCBpbmRleCAyLiA8LS0gdGhpcyBpcyB3cm9uZyFcbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIGNvcnJlY3QgYmVoYXZpb3IgaXM6XG4gICAgICAgICAqICAgMSkgZXZpY3QgZmlyc3QgYGFgXG4gICAgICAgICAqICAgMikgaW5zZXJ0IGBiYCBhdCBgMGAgaW5kZXguXG4gICAgICAgICAqICAgMykgcmVpbnNlcnQgYGFgIGF0IGluZGV4IDEuXG4gICAgICAgICAqICAgMykgbW92ZSBgYWAgYXQgZnJvbSBgMWAgdG8gYDJgLlxuICAgICAgICAgKlxuICAgICAgICAgKlxuICAgICAgICAgKiBEb3VibGUgY2hlY2sgdGhhdCB3ZSBoYXZlIG5vdCBldmljdGVkIGEgZHVwbGljYXRlIGl0ZW0uIFdlIG5lZWQgdG8gY2hlY2sgaWYgdGhlIGl0ZW0gdHlwZSBtYXlcbiAgICAgICAgICogaGF2ZSBhbHJlYWR5IGJlZW4gcmVtb3ZlZDpcbiAgICAgICAgICogVGhlIGluc2VydGlvbiBvZiBiIHdpbGwgZXZpY3QgdGhlIGZpcnN0ICdhJy4gSWYgd2UgZG9uJ3QgcmVpbnNlcnQgaXQgbm93IGl0IHdpbGwgYmUgcmVpbnNlcnRlZFxuICAgICAgICAgKiBhdCB0aGUgZW5kLiBXaGljaCB3aWxsIHNob3cgdXAgYXMgdGhlIHR3byAnYSdzIHN3aXRjaGluZyBwb3NpdGlvbi4gVGhpcyBpcyBpbmNvcnJlY3QsIHNpbmNlIGFcbiAgICAgICAgICogYmV0dGVyIHdheSB0byB0aGluayBvZiBpdCBpcyBhcyBpbnNlcnQgb2YgJ2InIHJhdGhlciB0aGVuIHN3aXRjaCAnYScgd2l0aCAnYicgYW5kIHRoZW4gYWRkICdhJ1xuICAgICAgICAgKiBhdCB0aGUgZW5kLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAgICovXG4gICAgICAgIERlZmF1bHRJdGVyYWJsZURpZmZlci5wcm90b3R5cGUuX3ZlcmlmeVJlaW5zZXJ0aW9uID0gZnVuY3Rpb24gKHJlY29yZCwgaXRlbSwgaXRlbVRyYWNrQnksIGluZGV4KSB7XG4gICAgICAgICAgICB2YXIgcmVpbnNlcnRSZWNvcmQgPSB0aGlzLl91bmxpbmtlZFJlY29yZHMgPT09IG51bGwgPyBudWxsIDogdGhpcy5fdW5saW5rZWRSZWNvcmRzLmdldChpdGVtVHJhY2tCeSk7XG4gICAgICAgICAgICBpZiAocmVpbnNlcnRSZWNvcmQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZWNvcmQgPSB0aGlzLl9yZWluc2VydEFmdGVyKHJlaW5zZXJ0UmVjb3JkLCByZWNvcmQuX3ByZXYsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJlY29yZC5jdXJyZW50SW5kZXggIT0gaW5kZXgpIHtcbiAgICAgICAgICAgICAgICByZWNvcmQuY3VycmVudEluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkVG9Nb3ZlcyhyZWNvcmQsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZWNvcmQ7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgcmlkIG9mIGFueSBleGNlc3Mge0BsaW5rIENvbGxlY3Rpb25DaGFuZ2VSZWNvcmR9cyBmcm9tIHRoZSBwcmV2aW91cyBjb2xsZWN0aW9uXG4gICAgICAgICAqXG4gICAgICAgICAqIC0gYHJlY29yZGAgVGhlIGZpcnN0IGV4Y2VzcyB7QGxpbmsgQ29sbGVjdGlvbkNoYW5nZVJlY29yZH0uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKi9cbiAgICAgICAgRGVmYXVsdEl0ZXJhYmxlRGlmZmVyLnByb3RvdHlwZS5fdHJ1bmNhdGUgPSBmdW5jdGlvbiAocmVjb3JkKSB7XG4gICAgICAgICAgICAvLyBBbnl0aGluZyBhZnRlciB0aGF0IG5lZWRzIHRvIGJlIHJlbW92ZWQ7XG4gICAgICAgICAgICB3aGlsZSAocmVjb3JkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5leHRSZWNvcmQgPSByZWNvcmQuX25leHQ7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkVG9SZW1vdmFscyh0aGlzLl91bmxpbmsocmVjb3JkKSk7XG4gICAgICAgICAgICAgICAgcmVjb3JkID0gbmV4dFJlY29yZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl91bmxpbmtlZFJlY29yZHMgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl91bmxpbmtlZFJlY29yZHMuY2xlYXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9hZGRpdGlvbnNUYWlsICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkaXRpb25zVGFpbC5fbmV4dEFkZGVkID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9tb3Zlc1RhaWwgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tb3Zlc1RhaWwuX25leHRNb3ZlZCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5faXRUYWlsICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faXRUYWlsLl9uZXh0ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9yZW1vdmFsc1RhaWwgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmFsc1RhaWwuX25leHRSZW1vdmVkID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9pZGVudGl0eUNoYW5nZXNUYWlsICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faWRlbnRpdHlDaGFuZ2VzVGFpbC5fbmV4dElkZW50aXR5Q2hhbmdlID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBEZWZhdWx0SXRlcmFibGVEaWZmZXIucHJvdG90eXBlLl9yZWluc2VydEFmdGVyID0gZnVuY3Rpb24gKHJlY29yZCwgcHJldlJlY29yZCwgaW5kZXgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl91bmxpbmtlZFJlY29yZHMgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl91bmxpbmtlZFJlY29yZHMucmVtb3ZlKHJlY29yZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcHJldiA9IHJlY29yZC5fcHJldlJlbW92ZWQ7XG4gICAgICAgICAgICB2YXIgbmV4dCA9IHJlY29yZC5fbmV4dFJlbW92ZWQ7XG4gICAgICAgICAgICBpZiAocHJldiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92YWxzSGVhZCA9IG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcmV2Ll9uZXh0UmVtb3ZlZCA9IG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV4dCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92YWxzVGFpbCA9IHByZXY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZXh0Ll9wcmV2UmVtb3ZlZCA9IHByZXY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9pbnNlcnRBZnRlcihyZWNvcmQsIHByZXZSZWNvcmQsIGluZGV4KTtcbiAgICAgICAgICAgIHRoaXMuX2FkZFRvTW92ZXMocmVjb3JkLCBpbmRleCk7XG4gICAgICAgICAgICByZXR1cm4gcmVjb3JkO1xuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIERlZmF1bHRJdGVyYWJsZURpZmZlci5wcm90b3R5cGUuX21vdmVBZnRlciA9IGZ1bmN0aW9uIChyZWNvcmQsIHByZXZSZWNvcmQsIGluZGV4KSB7XG4gICAgICAgICAgICB0aGlzLl91bmxpbmsocmVjb3JkKTtcbiAgICAgICAgICAgIHRoaXMuX2luc2VydEFmdGVyKHJlY29yZCwgcHJldlJlY29yZCwgaW5kZXgpO1xuICAgICAgICAgICAgdGhpcy5fYWRkVG9Nb3ZlcyhyZWNvcmQsIGluZGV4KTtcbiAgICAgICAgICAgIHJldHVybiByZWNvcmQ7XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgRGVmYXVsdEl0ZXJhYmxlRGlmZmVyLnByb3RvdHlwZS5fYWRkQWZ0ZXIgPSBmdW5jdGlvbiAocmVjb3JkLCBwcmV2UmVjb3JkLCBpbmRleCkge1xuICAgICAgICAgICAgdGhpcy5faW5zZXJ0QWZ0ZXIocmVjb3JkLCBwcmV2UmVjb3JkLCBpbmRleCk7XG4gICAgICAgICAgICBpZiAodGhpcy5fYWRkaXRpb25zVGFpbCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIHRvZG8odmljYilcbiAgICAgICAgICAgICAgICAvLyBhc3NlcnQodGhpcy5fYWRkaXRpb25zSGVhZCA9PT0gbnVsbCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkaXRpb25zVGFpbCA9IHRoaXMuX2FkZGl0aW9uc0hlYWQgPSByZWNvcmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyB0b2RvKHZpY2IpXG4gICAgICAgICAgICAgICAgLy8gYXNzZXJ0KF9hZGRpdGlvbnNUYWlsLl9uZXh0QWRkZWQgPT09IG51bGwpO1xuICAgICAgICAgICAgICAgIC8vIGFzc2VydChyZWNvcmQuX25leHRBZGRlZCA9PT0gbnVsbCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkaXRpb25zVGFpbCA9IHRoaXMuX2FkZGl0aW9uc1RhaWwuX25leHRBZGRlZCA9IHJlY29yZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZWNvcmQ7XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgRGVmYXVsdEl0ZXJhYmxlRGlmZmVyLnByb3RvdHlwZS5faW5zZXJ0QWZ0ZXIgPSBmdW5jdGlvbiAocmVjb3JkLCBwcmV2UmVjb3JkLCBpbmRleCkge1xuICAgICAgICAgICAgLy8gdG9kbyh2aWNiKVxuICAgICAgICAgICAgLy8gYXNzZXJ0KHJlY29yZCAhPSBwcmV2UmVjb3JkKTtcbiAgICAgICAgICAgIC8vIGFzc2VydChyZWNvcmQuX25leHQgPT09IG51bGwpO1xuICAgICAgICAgICAgLy8gYXNzZXJ0KHJlY29yZC5fcHJldiA9PT0gbnVsbCk7XG4gICAgICAgICAgICB2YXIgbmV4dCA9IHByZXZSZWNvcmQgPT09IG51bGwgPyB0aGlzLl9pdEhlYWQgOiBwcmV2UmVjb3JkLl9uZXh0O1xuICAgICAgICAgICAgLy8gdG9kbyh2aWNiKVxuICAgICAgICAgICAgLy8gYXNzZXJ0KG5leHQgIT0gcmVjb3JkKTtcbiAgICAgICAgICAgIC8vIGFzc2VydChwcmV2UmVjb3JkICE9IHJlY29yZCk7XG4gICAgICAgICAgICByZWNvcmQuX25leHQgPSBuZXh0O1xuICAgICAgICAgICAgcmVjb3JkLl9wcmV2ID0gcHJldlJlY29yZDtcbiAgICAgICAgICAgIGlmIChuZXh0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faXRUYWlsID0gcmVjb3JkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV4dC5fcHJldiA9IHJlY29yZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcmV2UmVjb3JkID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faXRIZWFkID0gcmVjb3JkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJldlJlY29yZC5fbmV4dCA9IHJlY29yZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9saW5rZWRSZWNvcmRzID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGlua2VkUmVjb3JkcyA9IG5ldyBfRHVwbGljYXRlTWFwKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9saW5rZWRSZWNvcmRzLnB1dChyZWNvcmQpO1xuICAgICAgICAgICAgcmVjb3JkLmN1cnJlbnRJbmRleCA9IGluZGV4O1xuICAgICAgICAgICAgcmV0dXJuIHJlY29yZDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBEZWZhdWx0SXRlcmFibGVEaWZmZXIucHJvdG90eXBlLl9yZW1vdmUgPSBmdW5jdGlvbiAocmVjb3JkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYWRkVG9SZW1vdmFscyh0aGlzLl91bmxpbmsocmVjb3JkKSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgRGVmYXVsdEl0ZXJhYmxlRGlmZmVyLnByb3RvdHlwZS5fdW5saW5rID0gZnVuY3Rpb24gKHJlY29yZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2xpbmtlZFJlY29yZHMgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9saW5rZWRSZWNvcmRzLnJlbW92ZShyZWNvcmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHByZXYgPSByZWNvcmQuX3ByZXY7XG4gICAgICAgICAgICB2YXIgbmV4dCA9IHJlY29yZC5fbmV4dDtcbiAgICAgICAgICAgIC8vIHRvZG8odmljYilcbiAgICAgICAgICAgIC8vIGFzc2VydCgocmVjb3JkLl9wcmV2ID0gbnVsbCkgPT09IG51bGwpO1xuICAgICAgICAgICAgLy8gYXNzZXJ0KChyZWNvcmQuX25leHQgPSBudWxsKSA9PT0gbnVsbCk7XG4gICAgICAgICAgICBpZiAocHJldiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2l0SGVhZCA9IG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcmV2Ll9uZXh0ID0gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXh0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faXRUYWlsID0gcHJldjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5leHQuX3ByZXYgPSBwcmV2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlY29yZDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBEZWZhdWx0SXRlcmFibGVEaWZmZXIucHJvdG90eXBlLl9hZGRUb01vdmVzID0gZnVuY3Rpb24gKHJlY29yZCwgdG9JbmRleCkge1xuICAgICAgICAgICAgLy8gdG9kbyh2aWNiKVxuICAgICAgICAgICAgLy8gYXNzZXJ0KHJlY29yZC5fbmV4dE1vdmVkID09PSBudWxsKTtcbiAgICAgICAgICAgIGlmIChyZWNvcmQucHJldmlvdXNJbmRleCA9PT0gdG9JbmRleCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZWNvcmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fbW92ZXNUYWlsID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gdG9kbyh2aWNiKVxuICAgICAgICAgICAgICAgIC8vIGFzc2VydChfbW92ZXNIZWFkID09PSBudWxsKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9tb3Zlc1RhaWwgPSB0aGlzLl9tb3Zlc0hlYWQgPSByZWNvcmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyB0b2RvKHZpY2IpXG4gICAgICAgICAgICAgICAgLy8gYXNzZXJ0KF9tb3Zlc1RhaWwuX25leHRNb3ZlZCA9PT0gbnVsbCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbW92ZXNUYWlsID0gdGhpcy5fbW92ZXNUYWlsLl9uZXh0TW92ZWQgPSByZWNvcmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVjb3JkO1xuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIERlZmF1bHRJdGVyYWJsZURpZmZlci5wcm90b3R5cGUuX2FkZFRvUmVtb3ZhbHMgPSBmdW5jdGlvbiAocmVjb3JkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fdW5saW5rZWRSZWNvcmRzID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdW5saW5rZWRSZWNvcmRzID0gbmV3IF9EdXBsaWNhdGVNYXAoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3VubGlua2VkUmVjb3Jkcy5wdXQocmVjb3JkKTtcbiAgICAgICAgICAgIHJlY29yZC5jdXJyZW50SW5kZXggPSBudWxsO1xuICAgICAgICAgICAgcmVjb3JkLl9uZXh0UmVtb3ZlZCA9IG51bGw7XG4gICAgICAgICAgICBpZiAodGhpcy5fcmVtb3ZhbHNUYWlsID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gdG9kbyh2aWNiKVxuICAgICAgICAgICAgICAgIC8vIGFzc2VydChfcmVtb3ZhbHNIZWFkID09PSBudWxsKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmFsc1RhaWwgPSB0aGlzLl9yZW1vdmFsc0hlYWQgPSByZWNvcmQ7XG4gICAgICAgICAgICAgICAgcmVjb3JkLl9wcmV2UmVtb3ZlZCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyB0b2RvKHZpY2IpXG4gICAgICAgICAgICAgICAgLy8gYXNzZXJ0KF9yZW1vdmFsc1RhaWwuX25leHRSZW1vdmVkID09PSBudWxsKTtcbiAgICAgICAgICAgICAgICAvLyBhc3NlcnQocmVjb3JkLl9uZXh0UmVtb3ZlZCA9PT0gbnVsbCk7XG4gICAgICAgICAgICAgICAgcmVjb3JkLl9wcmV2UmVtb3ZlZCA9IHRoaXMuX3JlbW92YWxzVGFpbDtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmFsc1RhaWwgPSB0aGlzLl9yZW1vdmFsc1RhaWwuX25leHRSZW1vdmVkID0gcmVjb3JkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlY29yZDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBEZWZhdWx0SXRlcmFibGVEaWZmZXIucHJvdG90eXBlLl9hZGRJZGVudGl0eUNoYW5nZSA9IGZ1bmN0aW9uIChyZWNvcmQsIGl0ZW0pIHtcbiAgICAgICAgICAgIHJlY29yZC5pdGVtID0gaXRlbTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9pZGVudGl0eUNoYW5nZXNUYWlsID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faWRlbnRpdHlDaGFuZ2VzVGFpbCA9IHRoaXMuX2lkZW50aXR5Q2hhbmdlc0hlYWQgPSByZWNvcmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9pZGVudGl0eUNoYW5nZXNUYWlsID0gdGhpcy5faWRlbnRpdHlDaGFuZ2VzVGFpbC5fbmV4dElkZW50aXR5Q2hhbmdlID0gcmVjb3JkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlY29yZDtcbiAgICAgICAgfTtcbiAgICAgICAgRGVmYXVsdEl0ZXJhYmxlRGlmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBsaXN0ID0gW107XG4gICAgICAgICAgICB0aGlzLmZvckVhY2hJdGVtKGZ1bmN0aW9uIChyZWNvcmQgLyoqIFRPRE8gIzkxMDAgKi8pIHsgcmV0dXJuIGxpc3QucHVzaChyZWNvcmQpOyB9KTtcbiAgICAgICAgICAgIHZhciBwcmV2aW91cyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5mb3JFYWNoUHJldmlvdXNJdGVtKGZ1bmN0aW9uIChyZWNvcmQgLyoqIFRPRE8gIzkxMDAgKi8pIHsgcmV0dXJuIHByZXZpb3VzLnB1c2gocmVjb3JkKTsgfSk7XG4gICAgICAgICAgICB2YXIgYWRkaXRpb25zID0gW107XG4gICAgICAgICAgICB0aGlzLmZvckVhY2hBZGRlZEl0ZW0oZnVuY3Rpb24gKHJlY29yZCAvKiogVE9ETyAjOTEwMCAqLykgeyByZXR1cm4gYWRkaXRpb25zLnB1c2gocmVjb3JkKTsgfSk7XG4gICAgICAgICAgICB2YXIgbW92ZXMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuZm9yRWFjaE1vdmVkSXRlbShmdW5jdGlvbiAocmVjb3JkIC8qKiBUT0RPICM5MTAwICovKSB7IHJldHVybiBtb3Zlcy5wdXNoKHJlY29yZCk7IH0pO1xuICAgICAgICAgICAgdmFyIHJlbW92YWxzID0gW107XG4gICAgICAgICAgICB0aGlzLmZvckVhY2hSZW1vdmVkSXRlbShmdW5jdGlvbiAocmVjb3JkIC8qKiBUT0RPICM5MTAwICovKSB7IHJldHVybiByZW1vdmFscy5wdXNoKHJlY29yZCk7IH0pO1xuICAgICAgICAgICAgdmFyIGlkZW50aXR5Q2hhbmdlcyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5mb3JFYWNoSWRlbnRpdHlDaGFuZ2UoZnVuY3Rpb24gKHJlY29yZCAvKiogVE9ETyAjOTEwMCAqLykgeyByZXR1cm4gaWRlbnRpdHlDaGFuZ2VzLnB1c2gocmVjb3JkKTsgfSk7XG4gICAgICAgICAgICByZXR1cm4gJ2NvbGxlY3Rpb246ICcgKyBsaXN0LmpvaW4oJywgJykgKyAnXFxuJyArXG4gICAgICAgICAgICAgICAgJ3ByZXZpb3VzOiAnICsgcHJldmlvdXMuam9pbignLCAnKSArICdcXG4nICtcbiAgICAgICAgICAgICAgICAnYWRkaXRpb25zOiAnICsgYWRkaXRpb25zLmpvaW4oJywgJykgKyAnXFxuJyArXG4gICAgICAgICAgICAgICAgJ21vdmVzOiAnICsgbW92ZXMuam9pbignLCAnKSArICdcXG4nICtcbiAgICAgICAgICAgICAgICAncmVtb3ZhbHM6ICcgKyByZW1vdmFscy5qb2luKCcsICcpICsgJ1xcbicgK1xuICAgICAgICAgICAgICAgICdpZGVudGl0eUNoYW5nZXM6ICcgKyBpZGVudGl0eUNoYW5nZXMuam9pbignLCAnKSArICdcXG4nO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gRGVmYXVsdEl0ZXJhYmxlRGlmZmVyO1xuICAgIH0oKSk7XG4gICAgLyoqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBDb2xsZWN0aW9uQ2hhbmdlUmVjb3JkID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gQ29sbGVjdGlvbkNoYW5nZVJlY29yZChpdGVtLCB0cmFja0J5SWQpIHtcbiAgICAgICAgICAgIHRoaXMuaXRlbSA9IGl0ZW07XG4gICAgICAgICAgICB0aGlzLnRyYWNrQnlJZCA9IHRyYWNrQnlJZDtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudEluZGV4ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMucHJldmlvdXNJbmRleCA9IG51bGw7XG4gICAgICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgICAgICB0aGlzLl9uZXh0UHJldmlvdXMgPSBudWxsO1xuICAgICAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICAgICAgdGhpcy5fcHJldiA9IG51bGw7XG4gICAgICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgICAgICB0aGlzLl9uZXh0ID0gbnVsbDtcbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgICAgIHRoaXMuX3ByZXZEdXAgPSBudWxsO1xuICAgICAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICAgICAgdGhpcy5fbmV4dER1cCA9IG51bGw7XG4gICAgICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgICAgICB0aGlzLl9wcmV2UmVtb3ZlZCA9IG51bGw7XG4gICAgICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgICAgICB0aGlzLl9uZXh0UmVtb3ZlZCA9IG51bGw7XG4gICAgICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgICAgICB0aGlzLl9uZXh0QWRkZWQgPSBudWxsO1xuICAgICAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICAgICAgdGhpcy5fbmV4dE1vdmVkID0gbnVsbDtcbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgICAgIHRoaXMuX25leHRJZGVudGl0eUNoYW5nZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgQ29sbGVjdGlvbkNoYW5nZVJlY29yZC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcmV2aW91c0luZGV4ID09PSB0aGlzLmN1cnJlbnRJbmRleCA/IHN0cmluZ2lmeSh0aGlzLml0ZW0pIDpcbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkodGhpcy5pdGVtKSArICdbJyArXG4gICAgICAgICAgICAgICAgICAgIHN0cmluZ2lmeSh0aGlzLnByZXZpb3VzSW5kZXgpICsgJy0+JyArIHN0cmluZ2lmeSh0aGlzLmN1cnJlbnRJbmRleCkgKyAnXSc7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBDb2xsZWN0aW9uQ2hhbmdlUmVjb3JkO1xuICAgIH0oKSk7XG4gICAgLy8gQSBsaW5rZWQgbGlzdCBvZiBDb2xsZWN0aW9uQ2hhbmdlUmVjb3JkcyB3aXRoIHRoZSBzYW1lIENvbGxlY3Rpb25DaGFuZ2VSZWNvcmQuaXRlbVxuICAgIHZhciBfRHVwbGljYXRlSXRlbVJlY29yZExpc3QgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBfRHVwbGljYXRlSXRlbVJlY29yZExpc3QoKSB7XG4gICAgICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgICAgICB0aGlzLl9oZWFkID0gbnVsbDtcbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgICAgIHRoaXMuX3RhaWwgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBcHBlbmQgdGhlIHJlY29yZCB0byB0aGUgbGlzdCBvZiBkdXBsaWNhdGVzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBOb3RlOiBieSBkZXNpZ24gYWxsIHJlY29yZHMgaW4gdGhlIGxpc3Qgb2YgZHVwbGljYXRlcyBob2xkIHRoZSBzYW1lIHZhbHVlIGluIHJlY29yZC5pdGVtLlxuICAgICAgICAgKi9cbiAgICAgICAgX0R1cGxpY2F0ZUl0ZW1SZWNvcmRMaXN0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAocmVjb3JkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5faGVhZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2hlYWQgPSB0aGlzLl90YWlsID0gcmVjb3JkO1xuICAgICAgICAgICAgICAgIHJlY29yZC5fbmV4dER1cCA9IG51bGw7XG4gICAgICAgICAgICAgICAgcmVjb3JkLl9wcmV2RHVwID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHRvZG8odmljYilcbiAgICAgICAgICAgICAgICAvLyBhc3NlcnQocmVjb3JkLml0ZW0gPT0gIF9oZWFkLml0ZW0gfHxcbiAgICAgICAgICAgICAgICAvLyAgICAgICByZWNvcmQuaXRlbSBpcyBudW0gJiYgcmVjb3JkLml0ZW0uaXNOYU4gJiYgX2hlYWQuaXRlbSBpcyBudW0gJiYgX2hlYWQuaXRlbS5pc05hTik7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGFpbC5fbmV4dER1cCA9IHJlY29yZDtcbiAgICAgICAgICAgICAgICByZWNvcmQuX3ByZXZEdXAgPSB0aGlzLl90YWlsO1xuICAgICAgICAgICAgICAgIHJlY29yZC5fbmV4dER1cCA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGFpbCA9IHJlY29yZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLy8gUmV0dXJucyBhIENvbGxlY3Rpb25DaGFuZ2VSZWNvcmQgaGF2aW5nIENvbGxlY3Rpb25DaGFuZ2VSZWNvcmQudHJhY2tCeUlkID09IHRyYWNrQnlJZCBhbmRcbiAgICAgICAgLy8gQ29sbGVjdGlvbkNoYW5nZVJlY29yZC5jdXJyZW50SW5kZXggPj0gYWZ0ZXJJbmRleFxuICAgICAgICBfRHVwbGljYXRlSXRlbVJlY29yZExpc3QucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICh0cmFja0J5SWQsIGFmdGVySW5kZXgpIHtcbiAgICAgICAgICAgIHZhciByZWNvcmQ7XG4gICAgICAgICAgICBmb3IgKHJlY29yZCA9IHRoaXMuX2hlYWQ7IHJlY29yZCAhPT0gbnVsbDsgcmVjb3JkID0gcmVjb3JkLl9uZXh0RHVwKSB7XG4gICAgICAgICAgICAgICAgaWYgKChhZnRlckluZGV4ID09PSBudWxsIHx8IGFmdGVySW5kZXggPCByZWNvcmQuY3VycmVudEluZGV4KSAmJlxuICAgICAgICAgICAgICAgICAgICBsb29zZUlkZW50aWNhbChyZWNvcmQudHJhY2tCeUlkLCB0cmFja0J5SWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWNvcmQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdmUgb25lIHtAbGluayBDb2xsZWN0aW9uQ2hhbmdlUmVjb3JkfSBmcm9tIHRoZSBsaXN0IG9mIGR1cGxpY2F0ZXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgbGlzdCBvZiBkdXBsaWNhdGVzIGlzIGVtcHR5LlxuICAgICAgICAgKi9cbiAgICAgICAgX0R1cGxpY2F0ZUl0ZW1SZWNvcmRMaXN0LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAocmVjb3JkKSB7XG4gICAgICAgICAgICAvLyB0b2RvKHZpY2IpXG4gICAgICAgICAgICAvLyBhc3NlcnQoKCkge1xuICAgICAgICAgICAgLy8gIC8vIHZlcmlmeSB0aGF0IHRoZSByZWNvcmQgYmVpbmcgcmVtb3ZlZCBpcyBpbiB0aGUgbGlzdC5cbiAgICAgICAgICAgIC8vICBmb3IgKENvbGxlY3Rpb25DaGFuZ2VSZWNvcmQgY3Vyc29yID0gX2hlYWQ7IGN1cnNvciAhPSBudWxsOyBjdXJzb3IgPSBjdXJzb3IuX25leHREdXApIHtcbiAgICAgICAgICAgIC8vICAgIGlmIChpZGVudGljYWwoY3Vyc29yLCByZWNvcmQpKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIC8vICB9XG4gICAgICAgICAgICAvLyAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgLy99KTtcbiAgICAgICAgICAgIHZhciBwcmV2ID0gcmVjb3JkLl9wcmV2RHVwO1xuICAgICAgICAgICAgdmFyIG5leHQgPSByZWNvcmQuX25leHREdXA7XG4gICAgICAgICAgICBpZiAocHJldiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2hlYWQgPSBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJldi5fbmV4dER1cCA9IG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV4dCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3RhaWwgPSBwcmV2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV4dC5fcHJldkR1cCA9IHByZXY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faGVhZCA9PT0gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF9EdXBsaWNhdGVJdGVtUmVjb3JkTGlzdDtcbiAgICB9KCkpO1xuICAgIHZhciBfRHVwbGljYXRlTWFwID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gX0R1cGxpY2F0ZU1hcCgpIHtcbiAgICAgICAgICAgIHRoaXMubWFwID0gbmV3IE1hcCgpO1xuICAgICAgICB9XG4gICAgICAgIF9EdXBsaWNhdGVNYXAucHJvdG90eXBlLnB1dCA9IGZ1bmN0aW9uIChyZWNvcmQpIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSByZWNvcmQudHJhY2tCeUlkO1xuICAgICAgICAgICAgdmFyIGR1cGxpY2F0ZXMgPSB0aGlzLm1hcC5nZXQoa2V5KTtcbiAgICAgICAgICAgIGlmICghZHVwbGljYXRlcykge1xuICAgICAgICAgICAgICAgIGR1cGxpY2F0ZXMgPSBuZXcgX0R1cGxpY2F0ZUl0ZW1SZWNvcmRMaXN0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5tYXAuc2V0KGtleSwgZHVwbGljYXRlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkdXBsaWNhdGVzLmFkZChyZWNvcmQpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0cmlldmUgdGhlIGB2YWx1ZWAgdXNpbmcga2V5LiBCZWNhdXNlIHRoZSBDb2xsZWN0aW9uQ2hhbmdlUmVjb3JkIHZhbHVlIG1heSBiZSBvbmUgd2hpY2ggd2VcbiAgICAgICAgICogaGF2ZSBhbHJlYWR5IGl0ZXJhdGVkIG92ZXIsIHdlIHVzZSB0aGUgYWZ0ZXJJbmRleCB0byBwcmV0ZW5kIGl0IGlzIG5vdCB0aGVyZS5cbiAgICAgICAgICpcbiAgICAgICAgICogVXNlIGNhc2U6IGBbYSwgYiwgYywgYSwgYV1gIGlmIHdlIGFyZSBhdCBpbmRleCBgM2Agd2hpY2ggaXMgdGhlIHNlY29uZCBgYWAgdGhlbiBhc2tpbmcgaWYgd2VcbiAgICAgICAgICogaGF2ZSBhbnkgbW9yZSBgYWBzIG5lZWRzIHRvIHJldHVybiB0aGUgbGFzdCBgYWAgbm90IHRoZSBmaXJzdCBvciBzZWNvbmQuXG4gICAgICAgICAqL1xuICAgICAgICBfRHVwbGljYXRlTWFwLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAodHJhY2tCeUlkLCBhZnRlckluZGV4KSB7XG4gICAgICAgICAgICBpZiAoYWZ0ZXJJbmRleCA9PT0gdm9pZCAwKSB7IGFmdGVySW5kZXggPSBudWxsOyB9XG4gICAgICAgICAgICB2YXIga2V5ID0gdHJhY2tCeUlkO1xuICAgICAgICAgICAgdmFyIHJlY29yZExpc3QgPSB0aGlzLm1hcC5nZXQoa2V5KTtcbiAgICAgICAgICAgIHJldHVybiByZWNvcmRMaXN0ID8gcmVjb3JkTGlzdC5nZXQodHJhY2tCeUlkLCBhZnRlckluZGV4KSA6IG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdmVzIGEge0BsaW5rIENvbGxlY3Rpb25DaGFuZ2VSZWNvcmR9IGZyb20gdGhlIGxpc3Qgb2YgZHVwbGljYXRlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIGxpc3Qgb2YgZHVwbGljYXRlcyBhbHNvIGlzIHJlbW92ZWQgZnJvbSB0aGUgbWFwIGlmIGl0IGdldHMgZW1wdHkuXG4gICAgICAgICAqL1xuICAgICAgICBfRHVwbGljYXRlTWFwLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAocmVjb3JkKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0gcmVjb3JkLnRyYWNrQnlJZDtcbiAgICAgICAgICAgIHZhciByZWNvcmRMaXN0ID0gdGhpcy5tYXAuZ2V0KGtleSk7XG4gICAgICAgICAgICAvLyBSZW1vdmUgdGhlIGxpc3Qgb2YgZHVwbGljYXRlcyB3aGVuIGl0IGdldHMgZW1wdHlcbiAgICAgICAgICAgIGlmIChyZWNvcmRMaXN0LnJlbW92ZShyZWNvcmQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tYXAuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVjb3JkO1xuICAgICAgICB9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX0R1cGxpY2F0ZU1hcC5wcm90b3R5cGUsIFwiaXNFbXB0eVwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMubWFwLnNpemUgPT09IDA7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBfRHVwbGljYXRlTWFwLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHsgdGhpcy5tYXAuY2xlYXIoKTsgfTtcbiAgICAgICAgX0R1cGxpY2F0ZU1hcC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnX0R1cGxpY2F0ZU1hcCgnICsgc3RyaW5naWZ5KHRoaXMubWFwKSArICcpJzsgfTtcbiAgICAgICAgcmV0dXJuIF9EdXBsaWNhdGVNYXA7XG4gICAgfSgpKTtcbiAgICBmdW5jdGlvbiBnZXRQcmV2aW91c0luZGV4KGl0ZW0sIGFkZFJlbW92ZU9mZnNldCwgbW92ZU9mZnNldHMpIHtcbiAgICAgICAgdmFyIHByZXZpb3VzSW5kZXggPSBpdGVtLnByZXZpb3VzSW5kZXg7XG4gICAgICAgIGlmIChwcmV2aW91c0luZGV4ID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIHByZXZpb3VzSW5kZXg7XG4gICAgICAgIHZhciBtb3ZlT2Zmc2V0ID0gMDtcbiAgICAgICAgaWYgKG1vdmVPZmZzZXRzICYmIHByZXZpb3VzSW5kZXggPCBtb3ZlT2Zmc2V0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIG1vdmVPZmZzZXQgPSBtb3ZlT2Zmc2V0c1twcmV2aW91c0luZGV4XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJldmlvdXNJbmRleCArIGFkZFJlbW92ZU9mZnNldCArIG1vdmVPZmZzZXQ7XG4gICAgfVxuXG4gICAgdmFyIERlZmF1bHRLZXlWYWx1ZURpZmZlckZhY3RvcnkgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBEZWZhdWx0S2V5VmFsdWVEaWZmZXJGYWN0b3J5KCkge1xuICAgICAgICB9XG4gICAgICAgIERlZmF1bHRLZXlWYWx1ZURpZmZlckZhY3RvcnkucHJvdG90eXBlLnN1cHBvcnRzID0gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqIGluc3RhbmNlb2YgTWFwIHx8IGlzSnNPYmplY3Qob2JqKTsgfTtcbiAgICAgICAgRGVmYXVsdEtleVZhbHVlRGlmZmVyRmFjdG9yeS5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gKGNkUmVmKSB7IHJldHVybiBuZXcgRGVmYXVsdEtleVZhbHVlRGlmZmVyKCk7IH07XG4gICAgICAgIHJldHVybiBEZWZhdWx0S2V5VmFsdWVEaWZmZXJGYWN0b3J5O1xuICAgIH0oKSk7XG4gICAgdmFyIERlZmF1bHRLZXlWYWx1ZURpZmZlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIERlZmF1bHRLZXlWYWx1ZURpZmZlcigpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlY29yZHMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICB0aGlzLl9tYXBIZWFkID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX3ByZXZpb3VzTWFwSGVhZCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9jaGFuZ2VzSGVhZCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9jaGFuZ2VzVGFpbCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9hZGRpdGlvbnNIZWFkID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX2FkZGl0aW9uc1RhaWwgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fcmVtb3ZhbHNIZWFkID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX3JlbW92YWxzVGFpbCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERlZmF1bHRLZXlWYWx1ZURpZmZlci5wcm90b3R5cGUsIFwiaXNEaXJ0eVwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYWRkaXRpb25zSGVhZCAhPT0gbnVsbCB8fCB0aGlzLl9jaGFuZ2VzSGVhZCAhPT0gbnVsbCB8fFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmFsc0hlYWQgIT09IG51bGw7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgRGVmYXVsdEtleVZhbHVlRGlmZmVyLnByb3RvdHlwZS5mb3JFYWNoSXRlbSA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgdmFyIHJlY29yZDtcbiAgICAgICAgICAgIGZvciAocmVjb3JkID0gdGhpcy5fbWFwSGVhZDsgcmVjb3JkICE9PSBudWxsOyByZWNvcmQgPSByZWNvcmQuX25leHQpIHtcbiAgICAgICAgICAgICAgICBmbihyZWNvcmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBEZWZhdWx0S2V5VmFsdWVEaWZmZXIucHJvdG90eXBlLmZvckVhY2hQcmV2aW91c0l0ZW0gPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgIHZhciByZWNvcmQ7XG4gICAgICAgICAgICBmb3IgKHJlY29yZCA9IHRoaXMuX3ByZXZpb3VzTWFwSGVhZDsgcmVjb3JkICE9PSBudWxsOyByZWNvcmQgPSByZWNvcmQuX25leHRQcmV2aW91cykge1xuICAgICAgICAgICAgICAgIGZuKHJlY29yZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIERlZmF1bHRLZXlWYWx1ZURpZmZlci5wcm90b3R5cGUuZm9yRWFjaENoYW5nZWRJdGVtID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICB2YXIgcmVjb3JkO1xuICAgICAgICAgICAgZm9yIChyZWNvcmQgPSB0aGlzLl9jaGFuZ2VzSGVhZDsgcmVjb3JkICE9PSBudWxsOyByZWNvcmQgPSByZWNvcmQuX25leHRDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgZm4ocmVjb3JkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgRGVmYXVsdEtleVZhbHVlRGlmZmVyLnByb3RvdHlwZS5mb3JFYWNoQWRkZWRJdGVtID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICB2YXIgcmVjb3JkO1xuICAgICAgICAgICAgZm9yIChyZWNvcmQgPSB0aGlzLl9hZGRpdGlvbnNIZWFkOyByZWNvcmQgIT09IG51bGw7IHJlY29yZCA9IHJlY29yZC5fbmV4dEFkZGVkKSB7XG4gICAgICAgICAgICAgICAgZm4ocmVjb3JkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgRGVmYXVsdEtleVZhbHVlRGlmZmVyLnByb3RvdHlwZS5mb3JFYWNoUmVtb3ZlZEl0ZW0gPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgIHZhciByZWNvcmQ7XG4gICAgICAgICAgICBmb3IgKHJlY29yZCA9IHRoaXMuX3JlbW92YWxzSGVhZDsgcmVjb3JkICE9PSBudWxsOyByZWNvcmQgPSByZWNvcmQuX25leHRSZW1vdmVkKSB7XG4gICAgICAgICAgICAgICAgZm4ocmVjb3JkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgRGVmYXVsdEtleVZhbHVlRGlmZmVyLnByb3RvdHlwZS5kaWZmID0gZnVuY3Rpb24gKG1hcCkge1xuICAgICAgICAgICAgaWYgKCFtYXApIHtcbiAgICAgICAgICAgICAgICBtYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghKG1hcCBpbnN0YW5jZW9mIE1hcCB8fCBpc0pzT2JqZWN0KG1hcCkpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgdHJ5aW5nIHRvIGRpZmYgJ1wiICsgbWFwICsgXCInXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hlY2sobWFwKSA/IHRoaXMgOiBudWxsO1xuICAgICAgICB9O1xuICAgICAgICBEZWZhdWx0S2V5VmFsdWVEaWZmZXIucHJvdG90eXBlLm9uRGVzdHJveSA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAgICAgRGVmYXVsdEtleVZhbHVlRGlmZmVyLnByb3RvdHlwZS5jaGVjayA9IGZ1bmN0aW9uIChtYXApIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLl9yZXNldCgpO1xuICAgICAgICAgICAgdmFyIHJlY29yZHMgPSB0aGlzLl9yZWNvcmRzO1xuICAgICAgICAgICAgdmFyIG9sZFNlcVJlY29yZCA9IHRoaXMuX21hcEhlYWQ7XG4gICAgICAgICAgICB2YXIgbGFzdE9sZFNlcVJlY29yZCA9IG51bGw7XG4gICAgICAgICAgICB2YXIgbGFzdE5ld1NlcVJlY29yZCA9IG51bGw7XG4gICAgICAgICAgICB2YXIgc2VxQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5fZm9yRWFjaChtYXAsIGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIG5ld1NlcVJlY29yZDtcbiAgICAgICAgICAgICAgICBpZiAob2xkU2VxUmVjb3JkICYmIGtleSA9PT0gb2xkU2VxUmVjb3JkLmtleSkge1xuICAgICAgICAgICAgICAgICAgICBuZXdTZXFSZWNvcmQgPSBvbGRTZXFSZWNvcmQ7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9tYXliZUFkZFRvQ2hhbmdlcyhuZXdTZXFSZWNvcmQsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNlcUNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAob2xkU2VxUmVjb3JkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcmVtb3ZlRnJvbVNlcShsYXN0T2xkU2VxUmVjb3JkLCBvbGRTZXFSZWNvcmQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2FkZFRvUmVtb3ZhbHMob2xkU2VxUmVjb3JkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocmVjb3Jkcy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3U2VxUmVjb3JkID0gcmVjb3Jkcy5nZXQoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9tYXliZUFkZFRvQ2hhbmdlcyhuZXdTZXFSZWNvcmQsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1NlcVJlY29yZCA9IG5ldyBLZXlWYWx1ZUNoYW5nZVJlY29yZChrZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVjb3Jkcy5zZXQoa2V5LCBuZXdTZXFSZWNvcmQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3U2VxUmVjb3JkLmN1cnJlbnRWYWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2FkZFRvQWRkaXRpb25zKG5ld1NlcVJlY29yZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNlcUNoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLl9pc0luUmVtb3ZhbHMobmV3U2VxUmVjb3JkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3JlbW92ZUZyb21SZW1vdmFscyhuZXdTZXFSZWNvcmQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChsYXN0TmV3U2VxUmVjb3JkID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9tYXBIZWFkID0gbmV3U2VxUmVjb3JkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdE5ld1NlcVJlY29yZC5fbmV4dCA9IG5ld1NlcVJlY29yZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsYXN0T2xkU2VxUmVjb3JkID0gb2xkU2VxUmVjb3JkO1xuICAgICAgICAgICAgICAgIGxhc3ROZXdTZXFSZWNvcmQgPSBuZXdTZXFSZWNvcmQ7XG4gICAgICAgICAgICAgICAgb2xkU2VxUmVjb3JkID0gb2xkU2VxUmVjb3JkICYmIG9sZFNlcVJlY29yZC5fbmV4dDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5fdHJ1bmNhdGUobGFzdE9sZFNlcVJlY29yZCwgb2xkU2VxUmVjb3JkKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlzRGlydHk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgRGVmYXVsdEtleVZhbHVlRGlmZmVyLnByb3RvdHlwZS5fcmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc0RpcnR5KSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlY29yZCA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAvLyBSZWNvcmQgdGhlIHN0YXRlIG9mIHRoZSBtYXBwaW5nXG4gICAgICAgICAgICAgICAgZm9yIChyZWNvcmQgPSB0aGlzLl9wcmV2aW91c01hcEhlYWQgPSB0aGlzLl9tYXBIZWFkOyByZWNvcmQgIT09IG51bGw7IHJlY29yZCA9IHJlY29yZC5fbmV4dCkge1xuICAgICAgICAgICAgICAgICAgICByZWNvcmQuX25leHRQcmV2aW91cyA9IHJlY29yZC5fbmV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChyZWNvcmQgPSB0aGlzLl9jaGFuZ2VzSGVhZDsgcmVjb3JkICE9PSBudWxsOyByZWNvcmQgPSByZWNvcmQuX25leHRDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlY29yZC5wcmV2aW91c1ZhbHVlID0gcmVjb3JkLmN1cnJlbnRWYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChyZWNvcmQgPSB0aGlzLl9hZGRpdGlvbnNIZWFkOyByZWNvcmQgIT0gbnVsbDsgcmVjb3JkID0gcmVjb3JkLl9uZXh0QWRkZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVjb3JkLnByZXZpb3VzVmFsdWUgPSByZWNvcmQuY3VycmVudFZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9jaGFuZ2VzSGVhZCA9IHRoaXMuX2NoYW5nZXNUYWlsID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLl9hZGRpdGlvbnNIZWFkID0gdGhpcy5fYWRkaXRpb25zVGFpbCA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVtb3ZhbHNIZWFkID0gdGhpcy5fcmVtb3ZhbHNUYWlsID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBEZWZhdWx0S2V5VmFsdWVEaWZmZXIucHJvdG90eXBlLl90cnVuY2F0ZSA9IGZ1bmN0aW9uIChsYXN0UmVjb3JkLCByZWNvcmQpIHtcbiAgICAgICAgICAgIHdoaWxlIChyZWNvcmQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAobGFzdFJlY29yZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tYXBIZWFkID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RSZWNvcmQuX25leHQgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgbmV4dFJlY29yZCA9IHJlY29yZC5fbmV4dDtcbiAgICAgICAgICAgICAgICB0aGlzLl9hZGRUb1JlbW92YWxzKHJlY29yZCk7XG4gICAgICAgICAgICAgICAgbGFzdFJlY29yZCA9IHJlY29yZDtcbiAgICAgICAgICAgICAgICByZWNvcmQgPSBuZXh0UmVjb3JkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgcmVjID0gdGhpcy5fcmVtb3ZhbHNIZWFkOyByZWMgIT09IG51bGw7IHJlYyA9IHJlYy5fbmV4dFJlbW92ZWQpIHtcbiAgICAgICAgICAgICAgICByZWMucHJldmlvdXNWYWx1ZSA9IHJlYy5jdXJyZW50VmFsdWU7XG4gICAgICAgICAgICAgICAgcmVjLmN1cnJlbnRWYWx1ZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVjb3Jkcy5kZWxldGUocmVjLmtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIERlZmF1bHRLZXlWYWx1ZURpZmZlci5wcm90b3R5cGUuX21heWJlQWRkVG9DaGFuZ2VzID0gZnVuY3Rpb24gKHJlY29yZCwgbmV3VmFsdWUpIHtcbiAgICAgICAgICAgIGlmICghbG9vc2VJZGVudGljYWwobmV3VmFsdWUsIHJlY29yZC5jdXJyZW50VmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmVjb3JkLnByZXZpb3VzVmFsdWUgPSByZWNvcmQuY3VycmVudFZhbHVlO1xuICAgICAgICAgICAgICAgIHJlY29yZC5jdXJyZW50VmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9hZGRUb0NoYW5nZXMocmVjb3JkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBEZWZhdWx0S2V5VmFsdWVEaWZmZXIucHJvdG90eXBlLl9pc0luUmVtb3ZhbHMgPSBmdW5jdGlvbiAocmVjb3JkKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVjb3JkID09PSB0aGlzLl9yZW1vdmFsc0hlYWQgfHwgcmVjb3JkLl9uZXh0UmVtb3ZlZCAhPT0gbnVsbCB8fFxuICAgICAgICAgICAgICAgIHJlY29yZC5fcHJldlJlbW92ZWQgIT09IG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgRGVmYXVsdEtleVZhbHVlRGlmZmVyLnByb3RvdHlwZS5fYWRkVG9SZW1vdmFscyA9IGZ1bmN0aW9uIChyZWNvcmQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9yZW1vdmFsc0hlYWQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmFsc0hlYWQgPSB0aGlzLl9yZW1vdmFsc1RhaWwgPSByZWNvcmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmFsc1RhaWwuX25leHRSZW1vdmVkID0gcmVjb3JkO1xuICAgICAgICAgICAgICAgIHJlY29yZC5fcHJldlJlbW92ZWQgPSB0aGlzLl9yZW1vdmFsc1RhaWw7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVtb3ZhbHNUYWlsID0gcmVjb3JkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIERlZmF1bHRLZXlWYWx1ZURpZmZlci5wcm90b3R5cGUuX3JlbW92ZUZyb21TZXEgPSBmdW5jdGlvbiAocHJldiwgcmVjb3JkKSB7XG4gICAgICAgICAgICB2YXIgbmV4dCA9IHJlY29yZC5fbmV4dDtcbiAgICAgICAgICAgIGlmIChwcmV2ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWFwSGVhZCA9IG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcmV2Ll9uZXh0ID0gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlY29yZC5fbmV4dCA9IG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgRGVmYXVsdEtleVZhbHVlRGlmZmVyLnByb3RvdHlwZS5fcmVtb3ZlRnJvbVJlbW92YWxzID0gZnVuY3Rpb24gKHJlY29yZCkge1xuICAgICAgICAgICAgdmFyIHByZXYgPSByZWNvcmQuX3ByZXZSZW1vdmVkO1xuICAgICAgICAgICAgdmFyIG5leHQgPSByZWNvcmQuX25leHRSZW1vdmVkO1xuICAgICAgICAgICAgaWYgKHByZXYgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmFsc0hlYWQgPSBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJldi5fbmV4dFJlbW92ZWQgPSBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5leHQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmFsc1RhaWwgPSBwcmV2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV4dC5fcHJldlJlbW92ZWQgPSBwcmV2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVjb3JkLl9wcmV2UmVtb3ZlZCA9IHJlY29yZC5fbmV4dFJlbW92ZWQgPSBudWxsO1xuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIERlZmF1bHRLZXlWYWx1ZURpZmZlci5wcm90b3R5cGUuX2FkZFRvQWRkaXRpb25zID0gZnVuY3Rpb24gKHJlY29yZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2FkZGl0aW9uc0hlYWQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hZGRpdGlvbnNIZWFkID0gdGhpcy5fYWRkaXRpb25zVGFpbCA9IHJlY29yZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FkZGl0aW9uc1RhaWwuX25leHRBZGRlZCA9IHJlY29yZDtcbiAgICAgICAgICAgICAgICB0aGlzLl9hZGRpdGlvbnNUYWlsID0gcmVjb3JkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIERlZmF1bHRLZXlWYWx1ZURpZmZlci5wcm90b3R5cGUuX2FkZFRvQ2hhbmdlcyA9IGZ1bmN0aW9uIChyZWNvcmQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jaGFuZ2VzSGVhZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NoYW5nZXNIZWFkID0gdGhpcy5fY2hhbmdlc1RhaWwgPSByZWNvcmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jaGFuZ2VzVGFpbC5fbmV4dENoYW5nZWQgPSByZWNvcmQ7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2hhbmdlc1RhaWwgPSByZWNvcmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIERlZmF1bHRLZXlWYWx1ZURpZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgaXRlbXMgPSBbXTtcbiAgICAgICAgICAgIHZhciBwcmV2aW91cyA9IFtdO1xuICAgICAgICAgICAgdmFyIGNoYW5nZXMgPSBbXTtcbiAgICAgICAgICAgIHZhciBhZGRpdGlvbnMgPSBbXTtcbiAgICAgICAgICAgIHZhciByZW1vdmFscyA9IFtdO1xuICAgICAgICAgICAgdmFyIHJlY29yZDtcbiAgICAgICAgICAgIGZvciAocmVjb3JkID0gdGhpcy5fbWFwSGVhZDsgcmVjb3JkICE9PSBudWxsOyByZWNvcmQgPSByZWNvcmQuX25leHQpIHtcbiAgICAgICAgICAgICAgICBpdGVtcy5wdXNoKHN0cmluZ2lmeShyZWNvcmQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAocmVjb3JkID0gdGhpcy5fcHJldmlvdXNNYXBIZWFkOyByZWNvcmQgIT09IG51bGw7IHJlY29yZCA9IHJlY29yZC5fbmV4dFByZXZpb3VzKSB7XG4gICAgICAgICAgICAgICAgcHJldmlvdXMucHVzaChzdHJpbmdpZnkocmVjb3JkKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHJlY29yZCA9IHRoaXMuX2NoYW5nZXNIZWFkOyByZWNvcmQgIT09IG51bGw7IHJlY29yZCA9IHJlY29yZC5fbmV4dENoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICBjaGFuZ2VzLnB1c2goc3RyaW5naWZ5KHJlY29yZCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChyZWNvcmQgPSB0aGlzLl9hZGRpdGlvbnNIZWFkOyByZWNvcmQgIT09IG51bGw7IHJlY29yZCA9IHJlY29yZC5fbmV4dEFkZGVkKSB7XG4gICAgICAgICAgICAgICAgYWRkaXRpb25zLnB1c2goc3RyaW5naWZ5KHJlY29yZCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChyZWNvcmQgPSB0aGlzLl9yZW1vdmFsc0hlYWQ7IHJlY29yZCAhPT0gbnVsbDsgcmVjb3JkID0gcmVjb3JkLl9uZXh0UmVtb3ZlZCkge1xuICAgICAgICAgICAgICAgIHJlbW92YWxzLnB1c2goc3RyaW5naWZ5KHJlY29yZCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICdtYXA6ICcgKyBpdGVtcy5qb2luKCcsICcpICsgJ1xcbicgK1xuICAgICAgICAgICAgICAgICdwcmV2aW91czogJyArIHByZXZpb3VzLmpvaW4oJywgJykgKyAnXFxuJyArXG4gICAgICAgICAgICAgICAgJ2FkZGl0aW9uczogJyArIGFkZGl0aW9ucy5qb2luKCcsICcpICsgJ1xcbicgK1xuICAgICAgICAgICAgICAgICdjaGFuZ2VzOiAnICsgY2hhbmdlcy5qb2luKCcsICcpICsgJ1xcbicgK1xuICAgICAgICAgICAgICAgICdyZW1vdmFsczogJyArIHJlbW92YWxzLmpvaW4oJywgJykgKyAnXFxuJztcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBEZWZhdWx0S2V5VmFsdWVEaWZmZXIucHJvdG90eXBlLl9mb3JFYWNoID0gZnVuY3Rpb24gKG9iaiwgZm4pIHtcbiAgICAgICAgICAgIGlmIChvYmogaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgICAgICAgICBvYmouZm9yRWFjaChmbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhvYmopLmZvckVhY2goZnVuY3Rpb24gKGspIHsgcmV0dXJuIGZuKG9ialtrXSwgayk7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gRGVmYXVsdEtleVZhbHVlRGlmZmVyO1xuICAgIH0oKSk7XG4gICAgLyoqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBLZXlWYWx1ZUNoYW5nZVJlY29yZCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEtleVZhbHVlQ2hhbmdlUmVjb3JkKGtleSkge1xuICAgICAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICAgICAgICB0aGlzLnByZXZpb3VzVmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50VmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICAgICAgdGhpcy5fbmV4dFByZXZpb3VzID0gbnVsbDtcbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgICAgIHRoaXMuX25leHQgPSBudWxsO1xuICAgICAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICAgICAgdGhpcy5fbmV4dEFkZGVkID0gbnVsbDtcbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgICAgIHRoaXMuX25leHRSZW1vdmVkID0gbnVsbDtcbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgICAgIHRoaXMuX3ByZXZSZW1vdmVkID0gbnVsbDtcbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgICAgIHRoaXMuX25leHRDaGFuZ2VkID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBLZXlWYWx1ZUNoYW5nZVJlY29yZC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9vc2VJZGVudGljYWwodGhpcy5wcmV2aW91c1ZhbHVlLCB0aGlzLmN1cnJlbnRWYWx1ZSkgP1xuICAgICAgICAgICAgICAgIHN0cmluZ2lmeSh0aGlzLmtleSkgOlxuICAgICAgICAgICAgICAgIChzdHJpbmdpZnkodGhpcy5rZXkpICsgJ1snICsgc3RyaW5naWZ5KHRoaXMucHJldmlvdXNWYWx1ZSkgKyAnLT4nICtcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5naWZ5KHRoaXMuY3VycmVudFZhbHVlKSArICddJyk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBLZXlWYWx1ZUNoYW5nZVJlY29yZDtcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogQSByZXBvc2l0b3J5IG9mIGRpZmZlcmVudCBpdGVyYWJsZSBkaWZmaW5nIHN0cmF0ZWdpZXMgdXNlZCBieSBOZ0ZvciwgTmdDbGFzcywgYW5kIG90aGVycy5cbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIEl0ZXJhYmxlRGlmZmVycyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEl0ZXJhYmxlRGlmZmVycyhmYWN0b3JpZXMpIHtcbiAgICAgICAgICAgIHRoaXMuZmFjdG9yaWVzID0gZmFjdG9yaWVzO1xuICAgICAgICB9XG4gICAgICAgIEl0ZXJhYmxlRGlmZmVycy5jcmVhdGUgPSBmdW5jdGlvbiAoZmFjdG9yaWVzLCBwYXJlbnQpIHtcbiAgICAgICAgICAgIGlmIChpc1ByZXNlbnQocGFyZW50KSkge1xuICAgICAgICAgICAgICAgIHZhciBjb3BpZWQgPSBwYXJlbnQuZmFjdG9yaWVzLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgZmFjdG9yaWVzID0gZmFjdG9yaWVzLmNvbmNhdChjb3BpZWQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgSXRlcmFibGVEaWZmZXJzKGZhY3Rvcmllcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEl0ZXJhYmxlRGlmZmVycyhmYWN0b3JpZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVGFrZXMgYW4gYXJyYXkgb2Yge0BsaW5rIEl0ZXJhYmxlRGlmZmVyRmFjdG9yeX0gYW5kIHJldHVybnMgYSBwcm92aWRlciB1c2VkIHRvIGV4dGVuZCB0aGVcbiAgICAgICAgICogaW5oZXJpdGVkIHtAbGluayBJdGVyYWJsZURpZmZlcnN9IGluc3RhbmNlIHdpdGggdGhlIHByb3ZpZGVkIGZhY3RvcmllcyBhbmQgcmV0dXJuIGEgbmV3XG4gICAgICAgICAqIHtAbGluayBJdGVyYWJsZURpZmZlcnN9IGluc3RhbmNlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgZm9sbG93aW5nIGV4YW1wbGUgc2hvd3MgaG93IHRvIGV4dGVuZCBhbiBleGlzdGluZyBsaXN0IG9mIGZhY3RvcmllcyxcbiAgICAgICAgICAgICAgICogd2hpY2ggd2lsbCBvbmx5IGJlIGFwcGxpZWQgdG8gdGhlIGluamVjdG9yIGZvciB0aGlzIGNvbXBvbmVudCBhbmQgaXRzIGNoaWxkcmVuLlxuICAgICAgICAgICAgICAgKiBUaGlzIHN0ZXAgaXMgYWxsIHRoYXQncyByZXF1aXJlZCB0byBtYWtlIGEgbmV3IHtAbGluayBJdGVyYWJsZURpZmZlcn0gYXZhaWxhYmxlLlxuICAgICAgICAgKlxuICAgICAgICAgKiAjIyMgRXhhbXBsZVxuICAgICAgICAgKlxuICAgICAgICAgKiBgYGBcbiAgICAgICAgICogQENvbXBvbmVudCh7XG4gICAgICAgICAqICAgdmlld1Byb3ZpZGVyczogW1xuICAgICAgICAgKiAgICAgSXRlcmFibGVEaWZmZXJzLmV4dGVuZChbbmV3IEltbXV0YWJsZUxpc3REaWZmZXIoKV0pXG4gICAgICAgICAqICAgXVxuICAgICAgICAgKiB9KVxuICAgICAgICAgKiBgYGBcbiAgICAgICAgICovXG4gICAgICAgIEl0ZXJhYmxlRGlmZmVycy5leHRlbmQgPSBmdW5jdGlvbiAoZmFjdG9yaWVzKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHByb3ZpZGU6IEl0ZXJhYmxlRGlmZmVycyxcbiAgICAgICAgICAgICAgICB1c2VGYWN0b3J5OiBmdW5jdGlvbiAocGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUeXBpY2FsbHkgd291bGQgb2NjdXIgd2hlbiBjYWxsaW5nIEl0ZXJhYmxlRGlmZmVycy5leHRlbmQgaW5zaWRlIG9mIGRlcGVuZGVuY2llcyBwYXNzZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRvXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBib290c3RyYXAoKSwgd2hpY2ggd291bGQgb3ZlcnJpZGUgZGVmYXVsdCBwaXBlcyBpbnN0ZWFkIG9mIGV4dGVuZGluZyB0aGVtLlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZXh0ZW5kIEl0ZXJhYmxlRGlmZmVycyB3aXRob3V0IGEgcGFyZW50IGluamVjdG9yJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEl0ZXJhYmxlRGlmZmVycy5jcmVhdGUoZmFjdG9yaWVzLCBwYXJlbnQpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgLy8gRGVwZW5kZW5jeSB0ZWNobmljYWxseSBpc24ndCBvcHRpb25hbCwgYnV0IHdlIGNhbiBwcm92aWRlIGEgYmV0dGVyIGVycm9yIG1lc3NhZ2UgdGhpcyB3YXkuXG4gICAgICAgICAgICAgICAgZGVwczogW1tJdGVyYWJsZURpZmZlcnMsIG5ldyBTa2lwU2VsZigpLCBuZXcgT3B0aW9uYWwoKV1dXG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICBJdGVyYWJsZURpZmZlcnMucHJvdG90eXBlLmZpbmQgPSBmdW5jdGlvbiAoaXRlcmFibGUpIHtcbiAgICAgICAgICAgIHZhciBmYWN0b3J5ID0gdGhpcy5mYWN0b3JpZXMuZmluZChmdW5jdGlvbiAoZikgeyByZXR1cm4gZi5zdXBwb3J0cyhpdGVyYWJsZSk7IH0pO1xuICAgICAgICAgICAgaWYgKGlzUHJlc2VudChmYWN0b3J5KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWN0b3J5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgYSBkaWZmZXIgc3VwcG9ydGluZyBvYmplY3QgJ1wiICsgaXRlcmFibGUgKyBcIicgb2YgdHlwZSAnXCIgKyBnZXRUeXBlTmFtZUZvckRlYnVnZ2luZyhpdGVyYWJsZSkgKyBcIidcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBJdGVyYWJsZURpZmZlcnM7XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIEEgcmVwb3NpdG9yeSBvZiBkaWZmZXJlbnQgTWFwIGRpZmZpbmcgc3RyYXRlZ2llcyB1c2VkIGJ5IE5nQ2xhc3MsIE5nU3R5bGUsIGFuZCBvdGhlcnMuXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBLZXlWYWx1ZURpZmZlcnMgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBLZXlWYWx1ZURpZmZlcnMoZmFjdG9yaWVzKSB7XG4gICAgICAgICAgICB0aGlzLmZhY3RvcmllcyA9IGZhY3RvcmllcztcbiAgICAgICAgfVxuICAgICAgICBLZXlWYWx1ZURpZmZlcnMuY3JlYXRlID0gZnVuY3Rpb24gKGZhY3RvcmllcywgcGFyZW50KSB7XG4gICAgICAgICAgICBpZiAoaXNQcmVzZW50KHBhcmVudCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29waWVkID0gcGFyZW50LmZhY3Rvcmllcy5zbGljZSgpO1xuICAgICAgICAgICAgICAgIGZhY3RvcmllcyA9IGZhY3Rvcmllcy5jb25jYXQoY29waWVkKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEtleVZhbHVlRGlmZmVycyhmYWN0b3JpZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBLZXlWYWx1ZURpZmZlcnMoZmFjdG9yaWVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRha2VzIGFuIGFycmF5IG9mIHtAbGluayBLZXlWYWx1ZURpZmZlckZhY3Rvcnl9IGFuZCByZXR1cm5zIGEgcHJvdmlkZXIgdXNlZCB0byBleHRlbmQgdGhlXG4gICAgICAgICAqIGluaGVyaXRlZCB7QGxpbmsgS2V5VmFsdWVEaWZmZXJzfSBpbnN0YW5jZSB3aXRoIHRoZSBwcm92aWRlZCBmYWN0b3JpZXMgYW5kIHJldHVybiBhIG5ld1xuICAgICAgICAgKiB7QGxpbmsgS2V5VmFsdWVEaWZmZXJzfSBpbnN0YW5jZS5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIGZvbGxvd2luZyBleGFtcGxlIHNob3dzIGhvdyB0byBleHRlbmQgYW4gZXhpc3RpbmcgbGlzdCBvZiBmYWN0b3JpZXMsXG4gICAgICAgICAgICAgICAqIHdoaWNoIHdpbGwgb25seSBiZSBhcHBsaWVkIHRvIHRoZSBpbmplY3RvciBmb3IgdGhpcyBjb21wb25lbnQgYW5kIGl0cyBjaGlsZHJlbi5cbiAgICAgICAgICAgICAgICogVGhpcyBzdGVwIGlzIGFsbCB0aGF0J3MgcmVxdWlyZWQgdG8gbWFrZSBhIG5ldyB7QGxpbmsgS2V5VmFsdWVEaWZmZXJ9IGF2YWlsYWJsZS5cbiAgICAgICAgICpcbiAgICAgICAgICogIyMjIEV4YW1wbGVcbiAgICAgICAgICpcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqIEBDb21wb25lbnQoe1xuICAgICAgICAgKiAgIHZpZXdQcm92aWRlcnM6IFtcbiAgICAgICAgICogICAgIEtleVZhbHVlRGlmZmVycy5leHRlbmQoW25ldyBJbW11dGFibGVNYXBEaWZmZXIoKV0pXG4gICAgICAgICAqICAgXVxuICAgICAgICAgKiB9KVxuICAgICAgICAgKiBgYGBcbiAgICAgICAgICovXG4gICAgICAgIEtleVZhbHVlRGlmZmVycy5leHRlbmQgPSBmdW5jdGlvbiAoZmFjdG9yaWVzKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHByb3ZpZGU6IEtleVZhbHVlRGlmZmVycyxcbiAgICAgICAgICAgICAgICB1c2VGYWN0b3J5OiBmdW5jdGlvbiAocGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUeXBpY2FsbHkgd291bGQgb2NjdXIgd2hlbiBjYWxsaW5nIEtleVZhbHVlRGlmZmVycy5leHRlbmQgaW5zaWRlIG9mIGRlcGVuZGVuY2llcyBwYXNzZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRvXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBib290c3RyYXAoKSwgd2hpY2ggd291bGQgb3ZlcnJpZGUgZGVmYXVsdCBwaXBlcyBpbnN0ZWFkIG9mIGV4dGVuZGluZyB0aGVtLlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZXh0ZW5kIEtleVZhbHVlRGlmZmVycyB3aXRob3V0IGEgcGFyZW50IGluamVjdG9yJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEtleVZhbHVlRGlmZmVycy5jcmVhdGUoZmFjdG9yaWVzLCBwYXJlbnQpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgLy8gRGVwZW5kZW5jeSB0ZWNobmljYWxseSBpc24ndCBvcHRpb25hbCwgYnV0IHdlIGNhbiBwcm92aWRlIGEgYmV0dGVyIGVycm9yIG1lc3NhZ2UgdGhpcyB3YXkuXG4gICAgICAgICAgICAgICAgZGVwczogW1tLZXlWYWx1ZURpZmZlcnMsIG5ldyBTa2lwU2VsZigpLCBuZXcgT3B0aW9uYWwoKV1dXG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICBLZXlWYWx1ZURpZmZlcnMucHJvdG90eXBlLmZpbmQgPSBmdW5jdGlvbiAoa3YpIHtcbiAgICAgICAgICAgIHZhciBmYWN0b3J5ID0gdGhpcy5mYWN0b3JpZXMuZmluZChmdW5jdGlvbiAoZikgeyByZXR1cm4gZi5zdXBwb3J0cyhrdik7IH0pO1xuICAgICAgICAgICAgaWYgKGlzUHJlc2VudChmYWN0b3J5KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWN0b3J5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgYSBkaWZmZXIgc3VwcG9ydGluZyBvYmplY3QgJ1wiICsga3YgKyBcIidcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBLZXlWYWx1ZURpZmZlcnM7XG4gICAgfSgpKTtcblxuICAgIHZhciBVTklOSVRJQUxJWkVEID0ge1xuICAgICAgICB0b1N0cmluZzogZnVuY3Rpb24gKCkgeyByZXR1cm4gJ0NEX0lOSVRfVkFMVUUnOyB9XG4gICAgfTtcbiAgICBmdW5jdGlvbiBkZXZNb2RlRXF1YWwoYSwgYikge1xuICAgICAgICBpZiAoaXNMaXN0TGlrZUl0ZXJhYmxlKGEpICYmIGlzTGlzdExpa2VJdGVyYWJsZShiKSkge1xuICAgICAgICAgICAgcmV0dXJuIGFyZUl0ZXJhYmxlc0VxdWFsKGEsIGIsIGRldk1vZGVFcXVhbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWlzTGlzdExpa2VJdGVyYWJsZShhKSAmJiAhaXNQcmltaXRpdmUoYSkgJiYgIWlzTGlzdExpa2VJdGVyYWJsZShiKSAmJiAhaXNQcmltaXRpdmUoYikpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGxvb3NlSWRlbnRpY2FsKGEsIGIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB0aGF0IHRoZSByZXN1bHQgb2YgYSB7QGxpbmsgUGlwZX0gdHJhbnNmb3JtYXRpb24gaGFzIGNoYW5nZWQgZXZlbiB0aG91Z2ggdGhlXG4gICAgICogcmVmZXJlbmNlXG4gICAgICogaGFzIG5vdCBjaGFuZ2VkLlxuICAgICAqXG4gICAgICogVGhlIHdyYXBwZWQgdmFsdWUgd2lsbCBiZSB1bndyYXBwZWQgYnkgY2hhbmdlIGRldGVjdGlvbiwgYW5kIHRoZSB1bndyYXBwZWQgdmFsdWUgd2lsbCBiZSBzdG9yZWQuXG4gICAgICpcbiAgICAgKiBFeGFtcGxlOlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogaWYgKHRoaXMuX2xhdGVzdFZhbHVlID09PSB0aGlzLl9sYXRlc3RSZXR1cm5lZFZhbHVlKSB7XG4gICAgICogICAgcmV0dXJuIHRoaXMuX2xhdGVzdFJldHVybmVkVmFsdWU7XG4gICAgICogIH0gZWxzZSB7XG4gICAgICogICAgdGhpcy5fbGF0ZXN0UmV0dXJuZWRWYWx1ZSA9IHRoaXMuX2xhdGVzdFZhbHVlO1xuICAgICAqICAgIHJldHVybiBXcmFwcGVkVmFsdWUud3JhcCh0aGlzLl9sYXRlc3RWYWx1ZSk7IC8vIHRoaXMgd2lsbCBmb3JjZSB1cGRhdGVcbiAgICAgKiAgfVxuICAgICAqIGBgYFxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgV3JhcHBlZFZhbHVlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gV3JhcHBlZFZhbHVlKHdyYXBwZWQpIHtcbiAgICAgICAgICAgIHRoaXMud3JhcHBlZCA9IHdyYXBwZWQ7XG4gICAgICAgIH1cbiAgICAgICAgV3JhcHBlZFZhbHVlLndyYXAgPSBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIG5ldyBXcmFwcGVkVmFsdWUodmFsdWUpOyB9O1xuICAgICAgICByZXR1cm4gV3JhcHBlZFZhbHVlO1xuICAgIH0oKSk7XG4gICAgLyoqXG4gICAgICogSGVscGVyIGNsYXNzIGZvciB1bndyYXBwaW5nIFdyYXBwZWRWYWx1ZSBzXG4gICAgICovXG4gICAgdmFyIFZhbHVlVW53cmFwcGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gVmFsdWVVbndyYXBwZXIoKSB7XG4gICAgICAgICAgICB0aGlzLmhhc1dyYXBwZWRWYWx1ZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIFZhbHVlVW53cmFwcGVyLnByb3RvdHlwZS51bndyYXAgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFdyYXBwZWRWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaGFzV3JhcHBlZFZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUud3JhcHBlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgVmFsdWVVbndyYXBwZXIucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkgeyB0aGlzLmhhc1dyYXBwZWRWYWx1ZSA9IGZhbHNlOyB9O1xuICAgICAgICByZXR1cm4gVmFsdWVVbndyYXBwZXI7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBSZXByZXNlbnRzIGEgYmFzaWMgY2hhbmdlIGZyb20gYSBwcmV2aW91cyB0byBhIG5ldyB2YWx1ZS5cbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIFNpbXBsZUNoYW5nZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFNpbXBsZUNoYW5nZShwcmV2aW91c1ZhbHVlLCBjdXJyZW50VmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMucHJldmlvdXNWYWx1ZSA9IHByZXZpb3VzVmFsdWU7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRWYWx1ZSA9IGN1cnJlbnRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ2hlY2sgd2hldGhlciB0aGUgbmV3IHZhbHVlIGlzIHRoZSBmaXJzdCB2YWx1ZSBhc3NpZ25lZC5cbiAgICAgICAgICovXG4gICAgICAgIFNpbXBsZUNoYW5nZS5wcm90b3R5cGUuaXNGaXJzdENoYW5nZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMucHJldmlvdXNWYWx1ZSA9PT0gVU5JTklUSUFMSVpFRDsgfTtcbiAgICAgICAgcmV0dXJuIFNpbXBsZUNoYW5nZTtcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgQ2hhbmdlRGV0ZWN0b3JSZWYgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBDaGFuZ2VEZXRlY3RvclJlZigpIHtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQ2hhbmdlRGV0ZWN0b3JSZWY7XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIFN0cnVjdHVyYWwgZGlmZmluZyBmb3IgYE9iamVjdGBzIGFuZCBgTWFwYHMuXG4gICAgICovXG4gICAgdmFyIGtleVZhbERpZmYgPSBbbmV3IERlZmF1bHRLZXlWYWx1ZURpZmZlckZhY3RvcnkoKV07XG4gICAgLyoqXG4gICAgICogU3RydWN0dXJhbCBkaWZmaW5nIGZvciBgSXRlcmFibGVgIHR5cGVzIHN1Y2ggYXMgYEFycmF5YHMuXG4gICAgICovXG4gICAgdmFyIGl0ZXJhYmxlRGlmZiA9IFtuZXcgRGVmYXVsdEl0ZXJhYmxlRGlmZmVyRmFjdG9yeSgpXTtcbiAgICB2YXIgZGVmYXVsdEl0ZXJhYmxlRGlmZmVycyA9IG5ldyBJdGVyYWJsZURpZmZlcnMoaXRlcmFibGVEaWZmKTtcbiAgICB2YXIgZGVmYXVsdEtleVZhbHVlRGlmZmVycyA9IG5ldyBLZXlWYWx1ZURpZmZlcnMoa2V5VmFsRGlmZik7XG5cbiAgICAvKipcbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgLy8gVE9ETyAobWF0c2tvKTogYWRkIHR5cGluZyBmb3IgdGhlIGFuaW1hdGlvbiBmdW5jdGlvblxuICAgIHZhciBSZW5kZXJDb21wb25lbnRUeXBlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gUmVuZGVyQ29tcG9uZW50VHlwZShpZCwgdGVtcGxhdGVVcmwsIHNsb3RDb3VudCwgZW5jYXBzdWxhdGlvbiwgc3R5bGVzLCBhbmltYXRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgICAgICB0aGlzLnRlbXBsYXRlVXJsID0gdGVtcGxhdGVVcmw7XG4gICAgICAgICAgICB0aGlzLnNsb3RDb3VudCA9IHNsb3RDb3VudDtcbiAgICAgICAgICAgIHRoaXMuZW5jYXBzdWxhdGlvbiA9IGVuY2Fwc3VsYXRpb247XG4gICAgICAgICAgICB0aGlzLnN0eWxlcyA9IHN0eWxlcztcbiAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9ucyA9IGFuaW1hdGlvbnM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFJlbmRlckNvbXBvbmVudFR5cGU7XG4gICAgfSgpKTtcbiAgICB2YXIgUmVuZGVyRGVidWdJbmZvID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gUmVuZGVyRGVidWdJbmZvKCkge1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZW5kZXJEZWJ1Z0luZm8ucHJvdG90eXBlLCBcImluamVjdG9yXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdW5pbXBsZW1lbnRlZCgpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlbmRlckRlYnVnSW5mby5wcm90b3R5cGUsIFwiY29tcG9uZW50XCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdW5pbXBsZW1lbnRlZCgpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlbmRlckRlYnVnSW5mby5wcm90b3R5cGUsIFwicHJvdmlkZXJUb2tlbnNcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1bmltcGxlbWVudGVkKCk7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVuZGVyRGVidWdJbmZvLnByb3RvdHlwZSwgXCJyZWZlcmVuY2VzXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdW5pbXBsZW1lbnRlZCgpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlbmRlckRlYnVnSW5mby5wcm90b3R5cGUsIFwiY29udGV4dFwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVuaW1wbGVtZW50ZWQoKTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZW5kZXJEZWJ1Z0luZm8ucHJvdG90eXBlLCBcInNvdXJjZVwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVuaW1wbGVtZW50ZWQoKTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBSZW5kZXJEZWJ1Z0luZm87XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgdmFyIFJlbmRlcmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gUmVuZGVyZXIoKSB7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFJlbmRlcmVyO1xuICAgIH0oKSk7XG4gICAgLyoqXG4gICAgICogSW5qZWN0YWJsZSBzZXJ2aWNlIHRoYXQgcHJvdmlkZXMgYSBsb3ctbGV2ZWwgaW50ZXJmYWNlIGZvciBtb2RpZnlpbmcgdGhlIFVJLlxuICAgICAqXG4gICAgICogVXNlIHRoaXMgc2VydmljZSB0byBieXBhc3MgQW5ndWxhcidzIHRlbXBsYXRpbmcgYW5kIG1ha2UgY3VzdG9tIFVJIGNoYW5nZXMgdGhhdCBjYW4ndCBiZVxuICAgICAqIGV4cHJlc3NlZCBkZWNsYXJhdGl2ZWx5LiBGb3IgZXhhbXBsZSBpZiB5b3UgbmVlZCB0byBzZXQgYSBwcm9wZXJ0eSBvciBhbiBhdHRyaWJ1dGUgd2hvc2UgbmFtZSBpc1xuICAgICAqIG5vdCBzdGF0aWNhbGx5IGtub3duLCB1c2Uge0BsaW5rICNzZXRFbGVtZW50UHJvcGVydHl9IG9yIHtAbGluayAjc2V0RWxlbWVudEF0dHJpYnV0ZX1cbiAgICAgKiByZXNwZWN0aXZlbHkuXG4gICAgICpcbiAgICAgKiBJZiB5b3UgYXJlIGltcGxlbWVudGluZyBhIGN1c3RvbSByZW5kZXJlciwgeW91IG11c3QgaW1wbGVtZW50IHRoaXMgaW50ZXJmYWNlLlxuICAgICAqXG4gICAgICogVGhlIGRlZmF1bHQgUmVuZGVyZXIgaW1wbGVtZW50YXRpb24gaXMgYERvbVJlbmRlcmVyYC4gQWxzbyBhdmFpbGFibGUgaXMgYFdlYldvcmtlclJlbmRlcmVyYC5cbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgdmFyIFJvb3RSZW5kZXJlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFJvb3RSZW5kZXJlcigpIHtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUm9vdFJlbmRlcmVyO1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQSBTZWN1cml0eUNvbnRleHQgbWFya3MgYSBsb2NhdGlvbiB0aGF0IGhhcyBkYW5nZXJvdXMgc2VjdXJpdHkgaW1wbGljYXRpb25zLCBlLmcuIGEgRE9NIHByb3BlcnR5XG4gICAgICogbGlrZSBgaW5uZXJIVE1MYCB0aGF0IGNvdWxkIGNhdXNlIENyb3NzIFNpdGUgU2NyaXB0aW5nIChYU1MpIHNlY3VyaXR5IGJ1Z3Mgd2hlbiBpbXByb3Blcmx5XG4gICAgICogaGFuZGxlZC5cbiAgICAgKlxuICAgICAqIFNlZSBEb21TYW5pdGl6ZXIgZm9yIG1vcmUgZGV0YWlscyBvbiBzZWN1cml0eSBpbiBBbmd1bGFyIGFwcGxpY2F0aW9ucy5cbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICBleHBvcnRzLlNlY3VyaXR5Q29udGV4dDtcbiAgICAoZnVuY3Rpb24gKFNlY3VyaXR5Q29udGV4dCkge1xuICAgICAgICBTZWN1cml0eUNvbnRleHRbU2VjdXJpdHlDb250ZXh0W1wiTk9ORVwiXSA9IDBdID0gXCJOT05FXCI7XG4gICAgICAgIFNlY3VyaXR5Q29udGV4dFtTZWN1cml0eUNvbnRleHRbXCJIVE1MXCJdID0gMV0gPSBcIkhUTUxcIjtcbiAgICAgICAgU2VjdXJpdHlDb250ZXh0W1NlY3VyaXR5Q29udGV4dFtcIlNUWUxFXCJdID0gMl0gPSBcIlNUWUxFXCI7XG4gICAgICAgIFNlY3VyaXR5Q29udGV4dFtTZWN1cml0eUNvbnRleHRbXCJTQ1JJUFRcIl0gPSAzXSA9IFwiU0NSSVBUXCI7XG4gICAgICAgIFNlY3VyaXR5Q29udGV4dFtTZWN1cml0eUNvbnRleHRbXCJVUkxcIl0gPSA0XSA9IFwiVVJMXCI7XG4gICAgICAgIFNlY3VyaXR5Q29udGV4dFtTZWN1cml0eUNvbnRleHRbXCJSRVNPVVJDRV9VUkxcIl0gPSA1XSA9IFwiUkVTT1VSQ0VfVVJMXCI7XG4gICAgfSkoZXhwb3J0cy5TZWN1cml0eUNvbnRleHQgfHwgKGV4cG9ydHMuU2VjdXJpdHlDb250ZXh0ID0ge30pKTtcbiAgICAvKipcbiAgICAgKiBTYW5pdGl6ZXIgaXMgdXNlZCBieSB0aGUgdmlld3MgdG8gc2FuaXRpemUgcG90ZW50aWFsbHkgZGFuZ2Vyb3VzIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgU2FuaXRpemVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gU2FuaXRpemVyKCkge1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTYW5pdGl6ZXI7XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBBIHdyYXBwZXIgYXJvdW5kIGEgbmF0aXZlIGVsZW1lbnQgaW5zaWRlIG9mIGEgVmlldy5cbiAgICAgKlxuICAgICAqIEFuIGBFbGVtZW50UmVmYCBpcyBiYWNrZWQgYnkgYSByZW5kZXItc3BlY2lmaWMgZWxlbWVudC4gSW4gdGhlIGJyb3dzZXIsIHRoaXMgaXMgdXN1YWxseSBhIERPTVxuICAgICAqIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAc2VjdXJpdHkgUGVybWl0dGluZyBkaXJlY3QgYWNjZXNzIHRvIHRoZSBET00gY2FuIG1ha2UgeW91ciBhcHBsaWNhdGlvbiBtb3JlIHZ1bG5lcmFibGUgdG9cbiAgICAgKiBYU1MgYXR0YWNrcy4gQ2FyZWZ1bGx5IHJldmlldyBhbnkgdXNlIG9mIGBFbGVtZW50UmVmYCBpbiB5b3VyIGNvZGUuIEZvciBtb3JlIGRldGFpbCwgc2VlIHRoZVxuICAgICAqIFtTZWN1cml0eSBHdWlkZV0oaHR0cDovL2cuY28vbmcvc2VjdXJpdHkpLlxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIC8vIE5vdGU6IFdlIGRvbid0IGV4cG9zZSB0aGluZ3MgbGlrZSBgSW5qZWN0b3JgLCBgVmlld0NvbnRhaW5lcmAsIC4uLiBoZXJlLFxuICAgIC8vIGkuZS4gdXNlcnMgaGF2ZSB0byBhc2sgZm9yIHdoYXQgdGhleSBuZWVkLiBXaXRoIHRoYXQsIHdlIGNhbiBidWlsZCBiZXR0ZXIgYW5hbHlzaXMgdG9vbHNcbiAgICAvLyBhbmQgY291bGQgZG8gYmV0dGVyIGNvZGVnZW4gaW4gdGhlIGZ1dHVyZS5cbiAgICB2YXIgRWxlbWVudFJlZiA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEVsZW1lbnRSZWYobmF0aXZlRWxlbWVudCkge1xuICAgICAgICAgICAgdGhpcy5uYXRpdmVFbGVtZW50ID0gbmF0aXZlRWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRWxlbWVudFJlZjtcbiAgICB9KCkpO1xuXG4gICAgdmFyIHRyYWNlO1xuICAgIHZhciBldmVudHM7XG4gICAgZnVuY3Rpb24gZGV0ZWN0V1RGKCkge1xuICAgICAgICB2YXIgd3RmID0gZ2xvYmFsJDFbJ3d0ZiddO1xuICAgICAgICBpZiAod3RmKSB7XG4gICAgICAgICAgICB0cmFjZSA9IHd0ZlsndHJhY2UnXTtcbiAgICAgICAgICAgIGlmICh0cmFjZSkge1xuICAgICAgICAgICAgICAgIGV2ZW50cyA9IHRyYWNlWydldmVudHMnXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZVNjb3BlKHNpZ25hdHVyZSwgZmxhZ3MpIHtcbiAgICAgICAgaWYgKGZsYWdzID09PSB2b2lkIDApIHsgZmxhZ3MgPSBudWxsOyB9XG4gICAgICAgIHJldHVybiBldmVudHMuY3JlYXRlU2NvcGUoc2lnbmF0dXJlLCBmbGFncyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxlYXZlKHNjb3BlLCByZXR1cm5WYWx1ZSkge1xuICAgICAgICB0cmFjZS5sZWF2ZVNjb3BlKHNjb3BlLCByZXR1cm5WYWx1ZSk7XG4gICAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3RhcnRUaW1lUmFuZ2UocmFuZ2VUeXBlLCBhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIHRyYWNlLmJlZ2luVGltZVJhbmdlKHJhbmdlVHlwZSwgYWN0aW9uKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZW5kVGltZVJhbmdlKHJhbmdlKSB7XG4gICAgICAgIHRyYWNlLmVuZFRpbWVSYW5nZShyYW5nZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJ1ZSBpZiBXVEYgaXMgZW5hYmxlZC5cbiAgICAgKi9cbiAgICB2YXIgd3RmRW5hYmxlZCA9IGRldGVjdFdURigpO1xuICAgIGZ1bmN0aW9uIG5vb3BTY29wZShhcmcwLCBhcmcxKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgdHJhY2Ugc2NvcGUuXG4gICAgICpcbiAgICAgKiBTY29wZXMgbXVzdCBiZSBzdHJpY3RseSBuZXN0ZWQgYW5kIGFyZSBhbmFsb2dvdXMgdG8gc3RhY2sgZnJhbWVzLCBidXRcbiAgICAgKiBkbyBub3QgaGF2ZSB0byBmb2xsb3cgdGhlIHN0YWNrIGZyYW1lcy4gSW5zdGVhZCBpdCBpcyByZWNvbW1lbmRlZCB0aGF0IHRoZXkgZm9sbG93IGxvZ2ljYWxcbiAgICAgKiBuZXN0aW5nLiBZb3UgbWF5IHdhbnQgdG8gdXNlXG4gICAgICogW0V2ZW50XG4gICAgICogU2lnbmF0dXJlc10oaHR0cDovL2dvb2dsZS5naXRodWIuaW8vdHJhY2luZy1mcmFtZXdvcmsvaW5zdHJ1bWVudGluZy1jb2RlLmh0bWwjY3VzdG9tLWV2ZW50cylcbiAgICAgKiBhcyB0aGV5IGFyZSBkZWZpbmVkIGluIFdURi5cbiAgICAgKlxuICAgICAqIFVzZWQgdG8gbWFyayBzY29wZSBlbnRyeS4gVGhlIHJldHVybiB2YWx1ZSBpcyB1c2VkIHRvIGxlYXZlIHRoZSBzY29wZS5cbiAgICAgKlxuICAgICAqICAgICB2YXIgbXlTY29wZSA9IHd0ZkNyZWF0ZVNjb3BlKCdNeUNsYXNzI215TWV0aG9kKGFzY2lpIHNvbWVWYWwpJyk7XG4gICAgICpcbiAgICAgKiAgICAgc29tZU1ldGhvZCgpIHtcbiAgICAgKiAgICAgICAgdmFyIHMgPSBteVNjb3BlKCdGb28nKTsgLy8gJ0ZvbycgZ2V0cyBzdG9yZWQgaW4gdHJhY2luZyBVSVxuICAgICAqICAgICAgICAvLyBETyBTT01FIFdPUksgSEVSRVxuICAgICAqICAgICAgICByZXR1cm4gd3RmTGVhdmUocywgMTIzKTsgLy8gUmV0dXJuIHZhbHVlIDEyM1xuICAgICAqICAgICB9XG4gICAgICpcbiAgICAgKiBOb3RlLCBhZGRpbmcgdHJ5LWZpbmFsbHkgYmxvY2sgYXJvdW5kIHRoZSB3b3JrIHRvIGVuc3VyZSB0aGF0IGB3dGZMZWF2ZWAgZ2V0cyBjYWxsZWQgY2FuXG4gICAgICogbmVnYXRpdmVseSBpbXBhY3QgdGhlIHBlcmZvcm1hbmNlIG9mIHlvdXIgYXBwbGljYXRpb24uIEZvciB0aGlzIHJlYXNvbiB3ZSByZWNvbW1lbmQgdGhhdFxuICAgICAqIHlvdSBkb24ndCBhZGQgdGhlbSB0byBlbnN1cmUgdGhhdCBgd3RmTGVhdmVgIGdldHMgY2FsbGVkLiBJbiBwcm9kdWN0aW9uIGB3dGZMZWF2ZWAgaXMgYSBub29wIGFuZFxuICAgICAqIHNvIHRyeS1maW5hbGx5IGJsb2NrIGhhcyBubyB2YWx1ZS4gV2hlbiBkZWJ1Z2dpbmcgcGVyZiBpc3N1ZXMsIHNraXBwaW5nIGB3dGZMZWF2ZWAsIGRvIHRvXG4gICAgICogZXhjZXB0aW9uLCB3aWxsIHByb2R1Y2UgaW5jb3JyZWN0IHRyYWNlLCBidXQgcHJlc2VuY2Ugb2YgZXhjZXB0aW9uIHNpZ25pZmllcyBsb2dpYyBlcnJvciB3aGljaFxuICAgICAqIG5lZWRzIHRvIGJlIGZpeGVkIGJlZm9yZSB0aGUgYXBwIHNob3VsZCBiZSBwcm9maWxlZC4gQWRkIHRyeS1maW5hbGx5IG9ubHkgd2hlbiB5b3UgZXhwZWN0IHRoYXRcbiAgICAgKiBhbiBleGNlcHRpb24gaXMgZXhwZWN0ZWQgZHVyaW5nIG5vcm1hbCBleGVjdXRpb24gd2hpbGUgcHJvZmlsaW5nLlxuICAgICAqXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIHZhciB3dGZDcmVhdGVTY29wZSA9IHd0ZkVuYWJsZWQgPyBjcmVhdGVTY29wZSA6IGZ1bmN0aW9uIChzaWduYXR1cmUsIGZsYWdzKSB7IHJldHVybiBub29wU2NvcGU7IH07XG4gICAgLyoqXG4gICAgICogVXNlZCB0byBtYXJrIGVuZCBvZiBTY29wZS5cbiAgICAgKlxuICAgICAqIC0gYHNjb3BlYCB0byBlbmQuXG4gICAgICogLSBgcmV0dXJuVmFsdWVgIChvcHRpb25hbCkgdG8gYmUgcGFzc2VkIHRvIHRoZSBXVEYuXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIHRoZSBgcmV0dXJuVmFsdWUgZm9yIGVhc3kgY2hhaW5pbmcuXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIHZhciB3dGZMZWF2ZSA9IHd0ZkVuYWJsZWQgPyBsZWF2ZSA6IGZ1bmN0aW9uIChzLCByKSB7IHJldHVybiByOyB9O1xuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gbWFyayBBc3luYyBzdGFydC4gQXN5bmMgYXJlIHNpbWlsYXIgdG8gc2NvcGUgYnV0IHRoZXkgZG9uJ3QgaGF2ZSB0byBiZSBzdHJpY3RseSBuZXN0ZWQuXG4gICAgICogVGhlIHJldHVybiB2YWx1ZSBpcyB1c2VkIGluIHRoZSBjYWxsIHRvIFtlbmRBc3luY10uIEFzeW5jIHJhbmdlcyBvbmx5IHdvcmsgaWYgV1RGIGhhcyBiZWVuXG4gICAgICogZW5hYmxlZC5cbiAgICAgKlxuICAgICAqICAgICBzb21lTWV0aG9kKCkge1xuICAgICAqICAgICAgICB2YXIgcyA9IHd0ZlN0YXJ0VGltZVJhbmdlKCdIVFRQOkdFVCcsICdzb21lLnVybCcpO1xuICAgICAqICAgICAgICB2YXIgZnV0dXJlID0gbmV3IEZ1dHVyZS5kZWxheSg1KS50aGVuKChfKSB7XG4gICAgICogICAgICAgICAgd3RmRW5kVGltZVJhbmdlKHMpO1xuICAgICAqICAgICAgICB9KTtcbiAgICAgKiAgICAgfVxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICB2YXIgd3RmU3RhcnRUaW1lUmFuZ2UgPSB3dGZFbmFibGVkID8gc3RhcnRUaW1lUmFuZ2UgOiBmdW5jdGlvbiAocmFuZ2VUeXBlLCBhY3Rpb24pIHsgcmV0dXJuIG51bGw7IH07XG4gICAgLyoqXG4gICAgICogRW5kcyBhIGFzeW5jIHRpbWUgcmFuZ2Ugb3BlcmF0aW9uLlxuICAgICAqIFtyYW5nZV0gaXMgdGhlIHJldHVybiB2YWx1ZSBmcm9tIFt3dGZTdGFydFRpbWVSYW5nZV0gQXN5bmMgcmFuZ2VzIG9ubHkgd29yayBpZiBXVEYgaGFzIGJlZW5cbiAgICAgKiBlbmFibGVkLlxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICB2YXIgd3RmRW5kVGltZVJhbmdlID0gd3RmRW5hYmxlZCA/IGVuZFRpbWVSYW5nZSA6IGZ1bmN0aW9uIChyKSB7IHJldHVybiBudWxsOyB9O1xuXG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBhIGNvbnRhaW5lciB3aGVyZSBvbmUgb3IgbW9yZSBWaWV3cyBjYW4gYmUgYXR0YWNoZWQuXG4gICAgICpcbiAgICAgKiBUaGUgY29udGFpbmVyIGNhbiBjb250YWluIHR3byBraW5kcyBvZiBWaWV3cy4gSG9zdCBWaWV3cywgY3JlYXRlZCBieSBpbnN0YW50aWF0aW5nIGFcbiAgICAgKiB7QGxpbmsgQ29tcG9uZW50fSB2aWEge0BsaW5rICNjcmVhdGVDb21wb25lbnR9LCBhbmQgRW1iZWRkZWQgVmlld3MsIGNyZWF0ZWQgYnkgaW5zdGFudGlhdGluZyBhblxuICAgICAqIHtAbGluayBUZW1wbGF0ZVJlZiBFbWJlZGRlZCBUZW1wbGF0ZX0gdmlhIHtAbGluayAjY3JlYXRlRW1iZWRkZWRWaWV3fS5cbiAgICAgKlxuICAgICAqIFRoZSBsb2NhdGlvbiBvZiB0aGUgVmlldyBDb250YWluZXIgd2l0aGluIHRoZSBjb250YWluaW5nIFZpZXcgaXMgc3BlY2lmaWVkIGJ5IHRoZSBBbmNob3JcbiAgICAgKiBgZWxlbWVudGAuIEVhY2ggVmlldyBDb250YWluZXIgY2FuIGhhdmUgb25seSBvbmUgQW5jaG9yIEVsZW1lbnQgYW5kIGVhY2ggQW5jaG9yIEVsZW1lbnQgY2FuIG9ubHlcbiAgICAgKiBoYXZlIGEgc2luZ2xlIFZpZXcgQ29udGFpbmVyLlxuICAgICAqXG4gICAgICogUm9vdCBlbGVtZW50cyBvZiBWaWV3cyBhdHRhY2hlZCB0byB0aGlzIGNvbnRhaW5lciBiZWNvbWUgc2libGluZ3Mgb2YgdGhlIEFuY2hvciBFbGVtZW50IGluXG4gICAgICogdGhlIFJlbmRlcmVkIFZpZXcuXG4gICAgICpcbiAgICAgKiBUbyBhY2Nlc3MgYSBgVmlld0NvbnRhaW5lclJlZmAgb2YgYW4gRWxlbWVudCwgeW91IGNhbiBlaXRoZXIgcGxhY2UgYSB7QGxpbmsgRGlyZWN0aXZlfSBpbmplY3RlZFxuICAgICAqIHdpdGggYFZpZXdDb250YWluZXJSZWZgIG9uIHRoZSBFbGVtZW50LCBvciB5b3Ugb2J0YWluIGl0IHZpYSBhIHtAbGluayBWaWV3Q2hpbGR9IHF1ZXJ5LlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgVmlld0NvbnRhaW5lclJlZiA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFZpZXdDb250YWluZXJSZWYoKSB7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZpZXdDb250YWluZXJSZWYucHJvdG90eXBlLCBcImVsZW1lbnRcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBBbmNob3IgZWxlbWVudCB0aGF0IHNwZWNpZmllcyB0aGUgbG9jYXRpb24gb2YgdGhpcyBjb250YWluZXIgaW4gdGhlIGNvbnRhaW5pbmcgVmlldy5cbiAgICAgICAgICAgICAqIDwhLS0gVE9ETzogcmVuYW1lIHRvIGFuY2hvckVsZW1lbnQgLS0+XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdW5pbXBsZW1lbnRlZCgpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZpZXdDb250YWluZXJSZWYucHJvdG90eXBlLCBcImluamVjdG9yXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdW5pbXBsZW1lbnRlZCgpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZpZXdDb250YWluZXJSZWYucHJvdG90eXBlLCBcInBhcmVudEluamVjdG9yXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdW5pbXBsZW1lbnRlZCgpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZpZXdDb250YWluZXJSZWYucHJvdG90eXBlLCBcImxlbmd0aFwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJldHVybnMgdGhlIG51bWJlciBvZiBWaWV3cyBjdXJyZW50bHkgYXR0YWNoZWQgdG8gdGhpcyBjb250YWluZXIuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdW5pbXBsZW1lbnRlZCgpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgO1xuICAgICAgICByZXR1cm4gVmlld0NvbnRhaW5lclJlZjtcbiAgICB9KCkpO1xuICAgIHZhciBWaWV3Q29udGFpbmVyUmVmXyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFZpZXdDb250YWluZXJSZWZfKF9lbGVtZW50KSB7XG4gICAgICAgICAgICB0aGlzLl9lbGVtZW50ID0gX2VsZW1lbnQ7XG4gICAgICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgICAgICB0aGlzLl9jcmVhdGVDb21wb25lbnRJbkNvbnRhaW5lclNjb3BlID0gd3RmQ3JlYXRlU2NvcGUoJ1ZpZXdDb250YWluZXJSZWYjY3JlYXRlQ29tcG9uZW50KCknKTtcbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgICAgIHRoaXMuX2luc2VydFNjb3BlID0gd3RmQ3JlYXRlU2NvcGUoJ1ZpZXdDb250YWluZXJSZWYjaW5zZXJ0KCknKTtcbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgICAgIHRoaXMuX3JlbW92ZVNjb3BlID0gd3RmQ3JlYXRlU2NvcGUoJ1ZpZXdDb250YWluZXJSZWYjcmVtb3ZlKCknKTtcbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgICAgIHRoaXMuX2RldGFjaFNjb3BlID0gd3RmQ3JlYXRlU2NvcGUoJ1ZpZXdDb250YWluZXJSZWYjZGV0YWNoKCknKTtcbiAgICAgICAgfVxuICAgICAgICBWaWV3Q29udGFpbmVyUmVmXy5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGluZGV4KSB7IHJldHVybiB0aGlzLl9lbGVtZW50Lm5lc3RlZFZpZXdzW2luZGV4XS5yZWY7IH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWaWV3Q29udGFpbmVyUmVmXy5wcm90b3R5cGUsIFwibGVuZ3RoXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciB2aWV3cyA9IHRoaXMuX2VsZW1lbnQubmVzdGVkVmlld3M7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzUHJlc2VudCh2aWV3cykgPyB2aWV3cy5sZW5ndGggOiAwO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWaWV3Q29udGFpbmVyUmVmXy5wcm90b3R5cGUsIFwiZWxlbWVudFwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2VsZW1lbnQuZWxlbWVudFJlZjsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWaWV3Q29udGFpbmVyUmVmXy5wcm90b3R5cGUsIFwiaW5qZWN0b3JcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9lbGVtZW50LmluamVjdG9yOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZpZXdDb250YWluZXJSZWZfLnByb3RvdHlwZSwgXCJwYXJlbnRJbmplY3RvclwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2VsZW1lbnQucGFyZW50SW5qZWN0b3I7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBUT0RPKHJhZG8pOiBwcm9maWxlIGFuZCBkZWNpZGUgd2hldGhlciBib3VuZHMgY2hlY2tzIHNob3VsZCBiZSBhZGRlZFxuICAgICAgICAvLyB0byB0aGUgbWV0aG9kcyBiZWxvdy5cbiAgICAgICAgVmlld0NvbnRhaW5lclJlZl8ucHJvdG90eXBlLmNyZWF0ZUVtYmVkZGVkVmlldyA9IGZ1bmN0aW9uICh0ZW1wbGF0ZVJlZiwgY29udGV4dCwgaW5kZXgpIHtcbiAgICAgICAgICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHsgY29udGV4dCA9IG51bGw7IH1cbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gdm9pZCAwKSB7IGluZGV4ID0gLTE7IH1cbiAgICAgICAgICAgIHZhciB2aWV3UmVmID0gdGVtcGxhdGVSZWYuY3JlYXRlRW1iZWRkZWRWaWV3KGNvbnRleHQpO1xuICAgICAgICAgICAgdGhpcy5pbnNlcnQodmlld1JlZiwgaW5kZXgpO1xuICAgICAgICAgICAgcmV0dXJuIHZpZXdSZWY7XG4gICAgICAgIH07XG4gICAgICAgIFZpZXdDb250YWluZXJSZWZfLnByb3RvdHlwZS5jcmVhdGVDb21wb25lbnQgPSBmdW5jdGlvbiAoY29tcG9uZW50RmFjdG9yeSwgaW5kZXgsIGluamVjdG9yLCBwcm9qZWN0YWJsZU5vZGVzKSB7XG4gICAgICAgICAgICBpZiAoaW5kZXggPT09IHZvaWQgMCkgeyBpbmRleCA9IC0xOyB9XG4gICAgICAgICAgICBpZiAoaW5qZWN0b3IgPT09IHZvaWQgMCkgeyBpbmplY3RvciA9IG51bGw7IH1cbiAgICAgICAgICAgIGlmIChwcm9qZWN0YWJsZU5vZGVzID09PSB2b2lkIDApIHsgcHJvamVjdGFibGVOb2RlcyA9IG51bGw7IH1cbiAgICAgICAgICAgIHZhciBzID0gdGhpcy5fY3JlYXRlQ29tcG9uZW50SW5Db250YWluZXJTY29wZSgpO1xuICAgICAgICAgICAgdmFyIGNvbnRleHRJbmplY3RvciA9IGluamVjdG9yIHx8IHRoaXMuX2VsZW1lbnQucGFyZW50SW5qZWN0b3I7XG4gICAgICAgICAgICB2YXIgY29tcG9uZW50UmVmID0gY29tcG9uZW50RmFjdG9yeS5jcmVhdGUoY29udGV4dEluamVjdG9yLCBwcm9qZWN0YWJsZU5vZGVzKTtcbiAgICAgICAgICAgIHRoaXMuaW5zZXJ0KGNvbXBvbmVudFJlZi5ob3N0VmlldywgaW5kZXgpO1xuICAgICAgICAgICAgcmV0dXJuIHd0ZkxlYXZlKHMsIGNvbXBvbmVudFJlZik7XG4gICAgICAgIH07XG4gICAgICAgIC8vIFRPRE8oaSk6IHJlZmFjdG9yIGluc2VydCtyZW1vdmUgaW50byBtb3ZlXG4gICAgICAgIFZpZXdDb250YWluZXJSZWZfLnByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbiAodmlld1JlZiwgaW5kZXgpIHtcbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gdm9pZCAwKSB7IGluZGV4ID0gLTE7IH1cbiAgICAgICAgICAgIHZhciBzID0gdGhpcy5faW5zZXJ0U2NvcGUoKTtcbiAgICAgICAgICAgIGlmIChpbmRleCA9PSAtMSlcbiAgICAgICAgICAgICAgICBpbmRleCA9IHRoaXMubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIHZpZXdSZWZfID0gdmlld1JlZjtcbiAgICAgICAgICAgIHRoaXMuX2VsZW1lbnQuYXR0YWNoVmlldyh2aWV3UmVmXy5pbnRlcm5hbFZpZXcsIGluZGV4KTtcbiAgICAgICAgICAgIHJldHVybiB3dGZMZWF2ZShzLCB2aWV3UmVmXyk7XG4gICAgICAgIH07XG4gICAgICAgIFZpZXdDb250YWluZXJSZWZfLnByb3RvdHlwZS5tb3ZlID0gZnVuY3Rpb24gKHZpZXdSZWYsIGN1cnJlbnRJbmRleCkge1xuICAgICAgICAgICAgdmFyIHMgPSB0aGlzLl9pbnNlcnRTY29wZSgpO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRJbmRleCA9PSAtMSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB2YXIgdmlld1JlZl8gPSB2aWV3UmVmO1xuICAgICAgICAgICAgdGhpcy5fZWxlbWVudC5tb3ZlVmlldyh2aWV3UmVmXy5pbnRlcm5hbFZpZXcsIGN1cnJlbnRJbmRleCk7XG4gICAgICAgICAgICByZXR1cm4gd3RmTGVhdmUocywgdmlld1JlZl8pO1xuICAgICAgICB9O1xuICAgICAgICBWaWV3Q29udGFpbmVyUmVmXy5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uICh2aWV3UmVmKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZWxlbWVudC5uZXN0ZWRWaWV3cy5pbmRleE9mKHZpZXdSZWYuaW50ZXJuYWxWaWV3KTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gVE9ETyhpKTogcmVuYW1lIHRvIGRlc3Ryb3lcbiAgICAgICAgVmlld0NvbnRhaW5lclJlZl8ucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgICAgaWYgKGluZGV4ID09PSB2b2lkIDApIHsgaW5kZXggPSAtMTsgfVxuICAgICAgICAgICAgdmFyIHMgPSB0aGlzLl9yZW1vdmVTY29wZSgpO1xuICAgICAgICAgICAgaWYgKGluZGV4ID09IC0xKVxuICAgICAgICAgICAgICAgIGluZGV4ID0gdGhpcy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgdmFyIHZpZXcgPSB0aGlzLl9lbGVtZW50LmRldGFjaFZpZXcoaW5kZXgpO1xuICAgICAgICAgICAgdmlldy5kZXN0cm95KCk7XG4gICAgICAgICAgICAvLyB2aWV3IGlzIGludGVudGlvbmFsbHkgbm90IHJldHVybmVkIHRvIHRoZSBjbGllbnQuXG4gICAgICAgICAgICB3dGZMZWF2ZShzKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gVE9ETyhpKTogcmVmYWN0b3IgaW5zZXJ0K3JlbW92ZSBpbnRvIG1vdmVcbiAgICAgICAgVmlld0NvbnRhaW5lclJlZl8ucHJvdG90eXBlLmRldGFjaCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgICAgaWYgKGluZGV4ID09PSB2b2lkIDApIHsgaW5kZXggPSAtMTsgfVxuICAgICAgICAgICAgdmFyIHMgPSB0aGlzLl9kZXRhY2hTY29wZSgpO1xuICAgICAgICAgICAgaWYgKGluZGV4ID09IC0xKVxuICAgICAgICAgICAgICAgIGluZGV4ID0gdGhpcy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgdmFyIHZpZXcgPSB0aGlzLl9lbGVtZW50LmRldGFjaFZpZXcoaW5kZXgpO1xuICAgICAgICAgICAgcmV0dXJuIHd0ZkxlYXZlKHMsIHZpZXcucmVmKTtcbiAgICAgICAgfTtcbiAgICAgICAgVmlld0NvbnRhaW5lclJlZl8ucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZShpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFZpZXdDb250YWluZXJSZWZfO1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgdmFyIFZpZXdUeXBlO1xuICAgIChmdW5jdGlvbiAoVmlld1R5cGUpIHtcbiAgICAgICAgLy8gQSB2aWV3IHRoYXQgY29udGFpbnMgdGhlIGhvc3QgZWxlbWVudCB3aXRoIGJvdW5kIGNvbXBvbmVudCBkaXJlY3RpdmUuXG4gICAgICAgIC8vIENvbnRhaW5zIGEgQ09NUE9ORU5UIHZpZXdcbiAgICAgICAgVmlld1R5cGVbVmlld1R5cGVbXCJIT1NUXCJdID0gMF0gPSBcIkhPU1RcIjtcbiAgICAgICAgLy8gVGhlIHZpZXcgb2YgdGhlIGNvbXBvbmVudFxuICAgICAgICAvLyBDYW4gY29udGFpbiAwIHRvIG4gRU1CRURERUQgdmlld3NcbiAgICAgICAgVmlld1R5cGVbVmlld1R5cGVbXCJDT01QT05FTlRcIl0gPSAxXSA9IFwiQ09NUE9ORU5UXCI7XG4gICAgICAgIC8vIEEgdmlldyB0aGF0IGlzIGVtYmVkZGVkIGludG8gYW5vdGhlciBWaWV3IHZpYSBhIDx0ZW1wbGF0ZT4gZWxlbWVudFxuICAgICAgICAvLyBpbnNpZGUgb2YgYSBDT01QT05FTlQgdmlld1xuICAgICAgICBWaWV3VHlwZVtWaWV3VHlwZVtcIkVNQkVEREVEXCJdID0gMl0gPSBcIkVNQkVEREVEXCI7XG4gICAgfSkoVmlld1R5cGUgfHwgKFZpZXdUeXBlID0ge30pKTtcblxuICAgIC8qKlxuICAgICAqIEFuIEFwcEVsZW1lbnQgaXMgY3JlYXRlZCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIGEgVmlld0NvbnRhaW5lclJlZixcbiAgICAgKiBhIG5lc3RlZCBjb21wb25lbnQgb3IgYSA8dGVtcGxhdGU+IGVsZW1lbnQgdG8ga2VlcCBkYXRhIGFyb3VuZFxuICAgICAqIHRoYXQgaXMgbmVlZGVkIGZvciBsYXRlciBpbnN0YW50aWF0aW9ucy5cbiAgICAgKi9cbiAgICB2YXIgQXBwRWxlbWVudCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEFwcEVsZW1lbnQoaW5kZXgsIHBhcmVudEluZGV4LCBwYXJlbnRWaWV3LCBuYXRpdmVFbGVtZW50KSB7XG4gICAgICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICB0aGlzLnBhcmVudEluZGV4ID0gcGFyZW50SW5kZXg7XG4gICAgICAgICAgICB0aGlzLnBhcmVudFZpZXcgPSBwYXJlbnRWaWV3O1xuICAgICAgICAgICAgdGhpcy5uYXRpdmVFbGVtZW50ID0gbmF0aXZlRWxlbWVudDtcbiAgICAgICAgICAgIHRoaXMubmVzdGVkVmlld3MgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5jb21wb25lbnRWaWV3ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQXBwRWxlbWVudC5wcm90b3R5cGUsIFwiZWxlbWVudFJlZlwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBFbGVtZW50UmVmKHRoaXMubmF0aXZlRWxlbWVudCk7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQXBwRWxlbWVudC5wcm90b3R5cGUsIFwidmNSZWZcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgVmlld0NvbnRhaW5lclJlZl8odGhpcyk7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBBcHBFbGVtZW50LnByb3RvdHlwZS5pbml0Q29tcG9uZW50ID0gZnVuY3Rpb24gKGNvbXBvbmVudCwgY29tcG9uZW50Q29uc3RydWN0b3JWaWV3UXVlcmllcywgdmlldykge1xuICAgICAgICAgICAgdGhpcy5jb21wb25lbnQgPSBjb21wb25lbnQ7XG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudENvbnN0cnVjdG9yVmlld1F1ZXJpZXMgPSBjb21wb25lbnRDb25zdHJ1Y3RvclZpZXdRdWVyaWVzO1xuICAgICAgICAgICAgdGhpcy5jb21wb25lbnRWaWV3ID0gdmlldztcbiAgICAgICAgfTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFwcEVsZW1lbnQucHJvdG90eXBlLCBcInBhcmVudEluamVjdG9yXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5wYXJlbnRWaWV3LmluamVjdG9yKHRoaXMucGFyZW50SW5kZXgpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFwcEVsZW1lbnQucHJvdG90eXBlLCBcImluamVjdG9yXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5wYXJlbnRWaWV3LmluamVjdG9yKHRoaXMuaW5kZXgpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgQXBwRWxlbWVudC5wcm90b3R5cGUubWFwTmVzdGVkVmlld3MgPSBmdW5jdGlvbiAobmVzdGVkVmlld0NsYXNzLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLm5lc3RlZFZpZXdzKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubmVzdGVkVmlld3MuZm9yRWFjaChmdW5jdGlvbiAobmVzdGVkVmlldykge1xuICAgICAgICAgICAgICAgICAgICBpZiAobmVzdGVkVmlldy5jbGF6eiA9PT0gbmVzdGVkVmlld0NsYXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChjYWxsYmFjayhuZXN0ZWRWaWV3KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgICAgIEFwcEVsZW1lbnQucHJvdG90eXBlLm1vdmVWaWV3ID0gZnVuY3Rpb24gKHZpZXcsIGN1cnJlbnRJbmRleCkge1xuICAgICAgICAgICAgdmFyIHByZXZpb3VzSW5kZXggPSB0aGlzLm5lc3RlZFZpZXdzLmluZGV4T2Yodmlldyk7XG4gICAgICAgICAgICBpZiAodmlldy50eXBlID09PSBWaWV3VHlwZS5DT01QT05FTlQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb21wb25lbnQgdmlld3MgY2FuJ3QgYmUgbW92ZWQhXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG5lc3RlZFZpZXdzID0gdGhpcy5uZXN0ZWRWaWV3cztcbiAgICAgICAgICAgIGlmIChuZXN0ZWRWaWV3cyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbmVzdGVkVmlld3MgPSBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLm5lc3RlZFZpZXdzID0gbmVzdGVkVmlld3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXN0ZWRWaWV3cy5zcGxpY2UocHJldmlvdXNJbmRleCwgMSk7XG4gICAgICAgICAgICBuZXN0ZWRWaWV3cy5zcGxpY2UoY3VycmVudEluZGV4LCAwLCB2aWV3KTtcbiAgICAgICAgICAgIHZhciByZWZSZW5kZXJOb2RlO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRJbmRleCA+IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJldlZpZXcgPSBuZXN0ZWRWaWV3c1tjdXJyZW50SW5kZXggLSAxXTtcbiAgICAgICAgICAgICAgICByZWZSZW5kZXJOb2RlID0gcHJldlZpZXcubGFzdFJvb3ROb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVmUmVuZGVyTm9kZSA9IHRoaXMubmF0aXZlRWxlbWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1ByZXNlbnQocmVmUmVuZGVyTm9kZSkpIHtcbiAgICAgICAgICAgICAgICB2aWV3LnJlbmRlcmVyLmF0dGFjaFZpZXdBZnRlcihyZWZSZW5kZXJOb2RlLCB2aWV3LmZsYXRSb290Tm9kZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmlldy5tYXJrQ29udGVudENoaWxkQXNNb3ZlZCh0aGlzKTtcbiAgICAgICAgfTtcbiAgICAgICAgQXBwRWxlbWVudC5wcm90b3R5cGUuYXR0YWNoVmlldyA9IGZ1bmN0aW9uICh2aWV3LCB2aWV3SW5kZXgpIHtcbiAgICAgICAgICAgIGlmICh2aWV3LnR5cGUgPT09IFZpZXdUeXBlLkNPTVBPTkVOVCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvbXBvbmVudCB2aWV3cyBjYW4ndCBiZSBtb3ZlZCFcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbmVzdGVkVmlld3MgPSB0aGlzLm5lc3RlZFZpZXdzO1xuICAgICAgICAgICAgaWYgKG5lc3RlZFZpZXdzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBuZXN0ZWRWaWV3cyA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMubmVzdGVkVmlld3MgPSBuZXN0ZWRWaWV3cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5lc3RlZFZpZXdzLnNwbGljZSh2aWV3SW5kZXgsIDAsIHZpZXcpO1xuICAgICAgICAgICAgdmFyIHJlZlJlbmRlck5vZGU7XG4gICAgICAgICAgICBpZiAodmlld0luZGV4ID4gMCkge1xuICAgICAgICAgICAgICAgIHZhciBwcmV2VmlldyA9IG5lc3RlZFZpZXdzW3ZpZXdJbmRleCAtIDFdO1xuICAgICAgICAgICAgICAgIHJlZlJlbmRlck5vZGUgPSBwcmV2Vmlldy5sYXN0Um9vdE5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZWZSZW5kZXJOb2RlID0gdGhpcy5uYXRpdmVFbGVtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzUHJlc2VudChyZWZSZW5kZXJOb2RlKSkge1xuICAgICAgICAgICAgICAgIHZpZXcucmVuZGVyZXIuYXR0YWNoVmlld0FmdGVyKHJlZlJlbmRlck5vZGUsIHZpZXcuZmxhdFJvb3ROb2Rlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2aWV3LmFkZFRvQ29udGVudENoaWxkcmVuKHRoaXMpO1xuICAgICAgICB9O1xuICAgICAgICBBcHBFbGVtZW50LnByb3RvdHlwZS5kZXRhY2hWaWV3ID0gZnVuY3Rpb24gKHZpZXdJbmRleCkge1xuICAgICAgICAgICAgdmFyIHZpZXcgPSB0aGlzLm5lc3RlZFZpZXdzLnNwbGljZSh2aWV3SW5kZXgsIDEpWzBdO1xuICAgICAgICAgICAgaWYgKHZpZXcudHlwZSA9PT0gVmlld1R5cGUuQ09NUE9ORU5UKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29tcG9uZW50IHZpZXdzIGNhbid0IGJlIG1vdmVkIVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZpZXcuZGV0YWNoKCk7XG4gICAgICAgICAgICB2aWV3LnJlbW92ZUZyb21Db250ZW50Q2hpbGRyZW4odGhpcyk7XG4gICAgICAgICAgICByZXR1cm4gdmlldztcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIEFwcEVsZW1lbnQ7XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICB2YXIgX19leHRlbmRzJDYgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBbiBlcnJvciB0aHJvd24gaWYgYXBwbGljYXRpb24gY2hhbmdlcyBtb2RlbCBicmVha2luZyB0aGUgdG9wLWRvd24gZGF0YSBmbG93LlxuICAgICAqXG4gICAgICogVGhpcyBleGNlcHRpb24gaXMgb25seSB0aHJvd24gaW4gZGV2IG1vZGUuXG4gICAgICpcbiAgICAgKiA8IS0tIFRPRE86IEFkZCBhIGxpbmsgb25jZSB0aGUgZGV2IG1vZGUgb3B0aW9uIGlzIGNvbmZpZ3VyYWJsZSAtLT5cbiAgICAgKlxuICAgICAqICMjIyBFeGFtcGxlXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogQENvbXBvbmVudCh7XG4gICAgICogICBzZWxlY3RvcjogJ3BhcmVudCcsXG4gICAgICogICB0ZW1wbGF0ZTogJzxjaGlsZCBbcHJvcF09XCJwYXJlbnRQcm9wXCI+PC9jaGlsZD4nLFxuICAgICAqIH0pXG4gICAgICogY2xhc3MgUGFyZW50IHtcbiAgICAgKiAgIHBhcmVudFByb3AgPSAnaW5pdCc7XG4gICAgICogfVxuICAgICAqXG4gICAgICogQERpcmVjdGl2ZSh7c2VsZWN0b3I6ICdjaGlsZCcsIGlucHV0czogWydwcm9wJ119KVxuICAgICAqIGNsYXNzIENoaWxkIHtcbiAgICAgKiAgIGNvbnN0cnVjdG9yKHB1YmxpYyBwYXJlbnQ6IFBhcmVudCkge31cbiAgICAgKlxuICAgICAqICAgc2V0IHByb3Aodikge1xuICAgICAqICAgICAvLyB0aGlzIHVwZGF0ZXMgdGhlIHBhcmVudCBwcm9wZXJ0eSwgd2hpY2ggaXMgZGlzYWxsb3dlZCBkdXJpbmcgY2hhbmdlIGRldGVjdGlvblxuICAgICAqICAgICAvLyB0aGlzIHdpbGwgcmVzdWx0IGluIEV4cHJlc3Npb25DaGFuZ2VkQWZ0ZXJJdEhhc0JlZW5DaGVja2VkRXJyb3JcbiAgICAgKiAgICAgdGhpcy5wYXJlbnQucGFyZW50UHJvcCA9ICd1cGRhdGVkJztcbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBFeHByZXNzaW9uQ2hhbmdlZEFmdGVySXRIYXNCZWVuQ2hlY2tlZEVycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDYoRXhwcmVzc2lvbkNoYW5nZWRBZnRlckl0SGFzQmVlbkNoZWNrZWRFcnJvciwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gRXhwcmVzc2lvbkNoYW5nZWRBZnRlckl0SGFzQmVlbkNoZWNrZWRFcnJvcihvbGRWYWx1ZSwgY3VyclZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgbXNnID0gXCJFeHByZXNzaW9uIGhhcyBjaGFuZ2VkIGFmdGVyIGl0IHdhcyBjaGVja2VkLiBQcmV2aW91cyB2YWx1ZTogJ1wiICsgb2xkVmFsdWUgKyBcIicuIEN1cnJlbnQgdmFsdWU6ICdcIiArIGN1cnJWYWx1ZSArIFwiJy5cIjtcbiAgICAgICAgICAgIGlmIChvbGRWYWx1ZSA9PT0gVU5JTklUSUFMSVpFRCkge1xuICAgICAgICAgICAgICAgIG1zZyArPVxuICAgICAgICAgICAgICAgICAgICBcIiBJdCBzZWVtcyBsaWtlIHRoZSB2aWV3IGhhcyBiZWVuIGNyZWF0ZWQgYWZ0ZXIgaXRzIHBhcmVudCBhbmQgaXRzIGNoaWxkcmVuIGhhdmUgYmVlbiBkaXJ0eSBjaGVja2VkLlwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiIEhhcyBpdCBiZWVuIGNyZWF0ZWQgaW4gYSBjaGFuZ2UgZGV0ZWN0aW9uIGhvb2sgP1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgbXNnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRXhwcmVzc2lvbkNoYW5nZWRBZnRlckl0SGFzQmVlbkNoZWNrZWRFcnJvcjtcbiAgICB9KEJhc2VFcnJvcikpO1xuICAgIC8qKlxuICAgICAqIFRocm93biB3aGVuIGFuIGV4Y2VwdGlvbiB3YXMgcmFpc2VkIGR1cmluZyB2aWV3IGNyZWF0aW9uLCBjaGFuZ2UgZGV0ZWN0aW9uIG9yIGRlc3RydWN0aW9uLlxuICAgICAqXG4gICAgICogVGhpcyBlcnJvciB3cmFwcyB0aGUgb3JpZ2luYWwgZXhjZXB0aW9uIHRvIGF0dGFjaCBhZGRpdGlvbmFsIGNvbnRleHR1YWwgaW5mb3JtYXRpb24gdGhhdCBjYW5cbiAgICAgKiBiZSB1c2VmdWwgZm9yIGRlYnVnZ2luZy5cbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIFZpZXdXcmFwcGVkRXJyb3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMkNihWaWV3V3JhcHBlZEVycm9yLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBWaWV3V3JhcHBlZEVycm9yKG9yaWdpbmFsRXJyb3IsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIFwiRXJyb3IgaW4gXCIgKyBjb250ZXh0LnNvdXJjZSwgb3JpZ2luYWxFcnJvcik7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBWaWV3V3JhcHBlZEVycm9yO1xuICAgIH0oV3JhcHBlZEVycm9yKSk7XG4gICAgLyoqXG4gICAgICogVGhyb3duIHdoZW4gYSBkZXN0cm95ZWQgdmlldyBpcyB1c2VkLlxuICAgICAqXG4gICAgICogVGhpcyBlcnJvciBpbmRpY2F0ZXMgYSBidWcgaW4gdGhlIGZyYW1ld29yay5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgYW4gaW50ZXJuYWwgQW5ndWxhciBlcnJvci5cbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIFZpZXdEZXN0cm95ZWRFcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQ2KFZpZXdEZXN0cm95ZWRFcnJvciwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gVmlld0Rlc3Ryb3llZEVycm9yKGRldGFpbHMpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIFwiQXR0ZW1wdCB0byB1c2UgYSBkZXN0cm95ZWQgdmlldzogXCIgKyBkZXRhaWxzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gVmlld0Rlc3Ryb3llZEVycm9yO1xuICAgIH0oQmFzZUVycm9yKSk7XG5cbiAgICB2YXIgVmlld1V0aWxzID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gVmlld1V0aWxzKF9yZW5kZXJlciwgX2FwcElkLCBzYW5pdGl6ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyID0gX3JlbmRlcmVyO1xuICAgICAgICAgICAgdGhpcy5fYXBwSWQgPSBfYXBwSWQ7XG4gICAgICAgICAgICB0aGlzLl9uZXh0Q29tcFR5cGVJZCA9IDA7XG4gICAgICAgICAgICB0aGlzLnNhbml0aXplciA9IHNhbml0aXplcjtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogVXNlZCBieSB0aGUgZ2VuZXJhdGVkIGNvZGVcbiAgICAgICAgICovXG4gICAgICAgIC8vIFRPRE8gKG1hdHNrbyk6IGFkZCB0eXBpbmcgZm9yIHRoZSBhbmltYXRpb24gZnVuY3Rpb25cbiAgICAgICAgVmlld1V0aWxzLnByb3RvdHlwZS5jcmVhdGVSZW5kZXJDb21wb25lbnRUeXBlID0gZnVuY3Rpb24gKHRlbXBsYXRlVXJsLCBzbG90Q291bnQsIGVuY2Fwc3VsYXRpb24sIHN0eWxlcywgYW5pbWF0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZW5kZXJDb21wb25lbnRUeXBlKHRoaXMuX2FwcElkICsgXCItXCIgKyB0aGlzLl9uZXh0Q29tcFR5cGVJZCsrLCB0ZW1wbGF0ZVVybCwgc2xvdENvdW50LCBlbmNhcHN1bGF0aW9uLCBzdHlsZXMsIGFuaW1hdGlvbnMpO1xuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIFZpZXdVdGlscy5wcm90b3R5cGUucmVuZGVyQ29tcG9uZW50ID0gZnVuY3Rpb24gKHJlbmRlckNvbXBvbmVudFR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZW5kZXJlci5yZW5kZXJDb21wb25lbnQocmVuZGVyQ29tcG9uZW50VHlwZSk7XG4gICAgICAgIH07XG4gICAgICAgIFZpZXdVdGlscy5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBJbmplY3RhYmxlIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBWaWV3VXRpbHMuY3RvclBhcmFtZXRlcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IFJvb3RSZW5kZXJlciwgfSxcbiAgICAgICAgICAgIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBJbmplY3QsIGFyZ3M6IFtBUFBfSUQsXSB9LF0gfSxcbiAgICAgICAgICAgIHsgdHlwZTogU2FuaXRpemVyLCB9LFxuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gVmlld1V0aWxzO1xuICAgIH0oKSk7XG4gICAgZnVuY3Rpb24gZmxhdHRlbk5lc3RlZFZpZXdSZW5kZXJOb2Rlcyhub2Rlcykge1xuICAgICAgICByZXR1cm4gX2ZsYXR0ZW5OZXN0ZWRWaWV3UmVuZGVyTm9kZXMobm9kZXMsIFtdKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gX2ZsYXR0ZW5OZXN0ZWRWaWV3UmVuZGVyTm9kZXMobm9kZXMsIHJlbmRlck5vZGVzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gbm9kZXNbaV07XG4gICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFwcEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXBwRWwgPSBub2RlO1xuICAgICAgICAgICAgICAgIHJlbmRlck5vZGVzLnB1c2goYXBwRWwubmF0aXZlRWxlbWVudCk7XG4gICAgICAgICAgICAgICAgaWYgKGlzUHJlc2VudChhcHBFbC5uZXN0ZWRWaWV3cykpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBhcHBFbC5uZXN0ZWRWaWV3cy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2ZsYXR0ZW5OZXN0ZWRWaWV3UmVuZGVyTm9kZXMoYXBwRWwubmVzdGVkVmlld3Nba10ucm9vdE5vZGVzT3JBcHBFbGVtZW50cywgcmVuZGVyTm9kZXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVuZGVyTm9kZXMucHVzaChub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVuZGVyTm9kZXM7XG4gICAgfVxuICAgIHZhciBFTVBUWV9BUlIgPSBbXTtcbiAgICBmdW5jdGlvbiBlbnN1cmVTbG90Q291bnQocHJvamVjdGFibGVOb2RlcywgZXhwZWN0ZWRTbG90Q291bnQpIHtcbiAgICAgICAgdmFyIHJlcztcbiAgICAgICAgaWYgKCFwcm9qZWN0YWJsZU5vZGVzKSB7XG4gICAgICAgICAgICByZXMgPSBFTVBUWV9BUlI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJvamVjdGFibGVOb2Rlcy5sZW5ndGggPCBleHBlY3RlZFNsb3RDb3VudCkge1xuICAgICAgICAgICAgdmFyIGdpdmVuU2xvdENvdW50ID0gcHJvamVjdGFibGVOb2Rlcy5sZW5ndGg7XG4gICAgICAgICAgICByZXMgPSBuZXcgQXJyYXkoZXhwZWN0ZWRTbG90Q291bnQpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHBlY3RlZFNsb3RDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcmVzW2ldID0gKGkgPCBnaXZlblNsb3RDb3VudCkgPyBwcm9qZWN0YWJsZU5vZGVzW2ldIDogRU1QVFlfQVJSO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzID0gcHJvamVjdGFibGVOb2RlcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICB2YXIgTUFYX0lOVEVSUE9MQVRJT05fVkFMVUVTID0gOTtcbiAgICBmdW5jdGlvbiBpbnRlcnBvbGF0ZSh2YWx1ZUNvdW50LCBjMCwgYTEsIGMxLCBhMiwgYzIsIGEzLCBjMywgYTQsIGM0LCBhNSwgYzUsIGE2LCBjNiwgYTcsIGM3LCBhOCwgYzgsIGE5LCBjOSkge1xuICAgICAgICBzd2l0Y2ggKHZhbHVlQ291bnQpIHtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICByZXR1cm4gYzAgKyBfdG9TdHJpbmdXaXRoTnVsbChhMSkgKyBjMTtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICByZXR1cm4gYzAgKyBfdG9TdHJpbmdXaXRoTnVsbChhMSkgKyBjMSArIF90b1N0cmluZ1dpdGhOdWxsKGEyKSArIGMyO1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIHJldHVybiBjMCArIF90b1N0cmluZ1dpdGhOdWxsKGExKSArIGMxICsgX3RvU3RyaW5nV2l0aE51bGwoYTIpICsgYzIgKyBfdG9TdHJpbmdXaXRoTnVsbChhMykgK1xuICAgICAgICAgICAgICAgICAgICBjMztcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICByZXR1cm4gYzAgKyBfdG9TdHJpbmdXaXRoTnVsbChhMSkgKyBjMSArIF90b1N0cmluZ1dpdGhOdWxsKGEyKSArIGMyICsgX3RvU3RyaW5nV2l0aE51bGwoYTMpICtcbiAgICAgICAgICAgICAgICAgICAgYzMgKyBfdG9TdHJpbmdXaXRoTnVsbChhNCkgKyBjNDtcbiAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICByZXR1cm4gYzAgKyBfdG9TdHJpbmdXaXRoTnVsbChhMSkgKyBjMSArIF90b1N0cmluZ1dpdGhOdWxsKGEyKSArIGMyICsgX3RvU3RyaW5nV2l0aE51bGwoYTMpICtcbiAgICAgICAgICAgICAgICAgICAgYzMgKyBfdG9TdHJpbmdXaXRoTnVsbChhNCkgKyBjNCArIF90b1N0cmluZ1dpdGhOdWxsKGE1KSArIGM1O1xuICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgIHJldHVybiBjMCArIF90b1N0cmluZ1dpdGhOdWxsKGExKSArIGMxICsgX3RvU3RyaW5nV2l0aE51bGwoYTIpICsgYzIgKyBfdG9TdHJpbmdXaXRoTnVsbChhMykgK1xuICAgICAgICAgICAgICAgICAgICBjMyArIF90b1N0cmluZ1dpdGhOdWxsKGE0KSArIGM0ICsgX3RvU3RyaW5nV2l0aE51bGwoYTUpICsgYzUgKyBfdG9TdHJpbmdXaXRoTnVsbChhNikgKyBjNjtcbiAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICByZXR1cm4gYzAgKyBfdG9TdHJpbmdXaXRoTnVsbChhMSkgKyBjMSArIF90b1N0cmluZ1dpdGhOdWxsKGEyKSArIGMyICsgX3RvU3RyaW5nV2l0aE51bGwoYTMpICtcbiAgICAgICAgICAgICAgICAgICAgYzMgKyBfdG9TdHJpbmdXaXRoTnVsbChhNCkgKyBjNCArIF90b1N0cmluZ1dpdGhOdWxsKGE1KSArIGM1ICsgX3RvU3RyaW5nV2l0aE51bGwoYTYpICtcbiAgICAgICAgICAgICAgICAgICAgYzYgKyBfdG9TdHJpbmdXaXRoTnVsbChhNykgKyBjNztcbiAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICByZXR1cm4gYzAgKyBfdG9TdHJpbmdXaXRoTnVsbChhMSkgKyBjMSArIF90b1N0cmluZ1dpdGhOdWxsKGEyKSArIGMyICsgX3RvU3RyaW5nV2l0aE51bGwoYTMpICtcbiAgICAgICAgICAgICAgICAgICAgYzMgKyBfdG9TdHJpbmdXaXRoTnVsbChhNCkgKyBjNCArIF90b1N0cmluZ1dpdGhOdWxsKGE1KSArIGM1ICsgX3RvU3RyaW5nV2l0aE51bGwoYTYpICtcbiAgICAgICAgICAgICAgICAgICAgYzYgKyBfdG9TdHJpbmdXaXRoTnVsbChhNykgKyBjNyArIF90b1N0cmluZ1dpdGhOdWxsKGE4KSArIGM4O1xuICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgIHJldHVybiBjMCArIF90b1N0cmluZ1dpdGhOdWxsKGExKSArIGMxICsgX3RvU3RyaW5nV2l0aE51bGwoYTIpICsgYzIgKyBfdG9TdHJpbmdXaXRoTnVsbChhMykgK1xuICAgICAgICAgICAgICAgICAgICBjMyArIF90b1N0cmluZ1dpdGhOdWxsKGE0KSArIGM0ICsgX3RvU3RyaW5nV2l0aE51bGwoYTUpICsgYzUgKyBfdG9TdHJpbmdXaXRoTnVsbChhNikgK1xuICAgICAgICAgICAgICAgICAgICBjNiArIF90b1N0cmluZ1dpdGhOdWxsKGE3KSArIGM3ICsgX3RvU3RyaW5nV2l0aE51bGwoYTgpICsgYzggKyBfdG9TdHJpbmdXaXRoTnVsbChhOSkgKyBjOTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRG9lcyBub3Qgc3VwcG9ydCBtb3JlIHRoYW4gOSBleHByZXNzaW9uc1wiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBfdG9TdHJpbmdXaXRoTnVsbCh2KSB7XG4gICAgICAgIHJldHVybiB2ICE9IG51bGwgPyB2LnRvU3RyaW5nKCkgOiAnJztcbiAgICB9XG4gICAgZnVuY3Rpb24gY2hlY2tCaW5kaW5nKHRocm93T25DaGFuZ2UsIG9sZFZhbHVlLCBuZXdWYWx1ZSkge1xuICAgICAgICBpZiAodGhyb3dPbkNoYW5nZSkge1xuICAgICAgICAgICAgaWYgKCFkZXZNb2RlRXF1YWwob2xkVmFsdWUsIG5ld1ZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFeHByZXNzaW9uQ2hhbmdlZEFmdGVySXRIYXNCZWVuQ2hlY2tlZEVycm9yKG9sZFZhbHVlLCBuZXdWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gIWxvb3NlSWRlbnRpY2FsKG9sZFZhbHVlLCBuZXdWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY2FzdEJ5VmFsdWUoaW5wdXQsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBpbnB1dDtcbiAgICB9XG4gICAgdmFyIEVNUFRZX0FSUkFZID0gW107XG4gICAgdmFyIEVNUFRZX01BUCA9IHt9O1xuICAgIGZ1bmN0aW9uIHB1cmVQcm94eTEoZm4pIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdmFyIHYwID0gVU5JTklUSUFMSVpFRDtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChwMCkge1xuICAgICAgICAgICAgaWYgKCFsb29zZUlkZW50aWNhbCh2MCwgcDApKSB7XG4gICAgICAgICAgICAgICAgdjAgPSBwMDtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBmbihwMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdXJlUHJveHkyKGZuKSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIHZhciB2MCA9IFVOSU5JVElBTElaRUQ7XG4gICAgICAgIHZhciB2MSA9IFVOSU5JVElBTElaRUQ7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAocDAsIHAxKSB7XG4gICAgICAgICAgICBpZiAoIWxvb3NlSWRlbnRpY2FsKHYwLCBwMCkgfHwgIWxvb3NlSWRlbnRpY2FsKHYxLCBwMSkpIHtcbiAgICAgICAgICAgICAgICB2MCA9IHAwO1xuICAgICAgICAgICAgICAgIHYxID0gcDE7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZm4ocDAsIHAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1cmVQcm94eTMoZm4pIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdmFyIHYwID0gVU5JTklUSUFMSVpFRDtcbiAgICAgICAgdmFyIHYxID0gVU5JTklUSUFMSVpFRDtcbiAgICAgICAgdmFyIHYyID0gVU5JTklUSUFMSVpFRDtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChwMCwgcDEsIHAyKSB7XG4gICAgICAgICAgICBpZiAoIWxvb3NlSWRlbnRpY2FsKHYwLCBwMCkgfHwgIWxvb3NlSWRlbnRpY2FsKHYxLCBwMSkgfHwgIWxvb3NlSWRlbnRpY2FsKHYyLCBwMikpIHtcbiAgICAgICAgICAgICAgICB2MCA9IHAwO1xuICAgICAgICAgICAgICAgIHYxID0gcDE7XG4gICAgICAgICAgICAgICAgdjIgPSBwMjtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBmbihwMCwgcDEsIHAyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1cmVQcm94eTQoZm4pIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdmFyIHYwLCB2MSwgdjIsIHYzO1xuICAgICAgICB2MCA9IHYxID0gdjIgPSB2MyA9IFVOSU5JVElBTElaRUQ7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAocDAsIHAxLCBwMiwgcDMpIHtcbiAgICAgICAgICAgIGlmICghbG9vc2VJZGVudGljYWwodjAsIHAwKSB8fCAhbG9vc2VJZGVudGljYWwodjEsIHAxKSB8fCAhbG9vc2VJZGVudGljYWwodjIsIHAyKSB8fFxuICAgICAgICAgICAgICAgICFsb29zZUlkZW50aWNhbCh2MywgcDMpKSB7XG4gICAgICAgICAgICAgICAgdjAgPSBwMDtcbiAgICAgICAgICAgICAgICB2MSA9IHAxO1xuICAgICAgICAgICAgICAgIHYyID0gcDI7XG4gICAgICAgICAgICAgICAgdjMgPSBwMztcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBmbihwMCwgcDEsIHAyLCBwMyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdXJlUHJveHk1KGZuKSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIHZhciB2MCwgdjEsIHYyLCB2MywgdjQ7XG4gICAgICAgIHYwID0gdjEgPSB2MiA9IHYzID0gdjQgPSBVTklOSVRJQUxJWkVEO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHAwLCBwMSwgcDIsIHAzLCBwNCkge1xuICAgICAgICAgICAgaWYgKCFsb29zZUlkZW50aWNhbCh2MCwgcDApIHx8ICFsb29zZUlkZW50aWNhbCh2MSwgcDEpIHx8ICFsb29zZUlkZW50aWNhbCh2MiwgcDIpIHx8XG4gICAgICAgICAgICAgICAgIWxvb3NlSWRlbnRpY2FsKHYzLCBwMykgfHwgIWxvb3NlSWRlbnRpY2FsKHY0LCBwNCkpIHtcbiAgICAgICAgICAgICAgICB2MCA9IHAwO1xuICAgICAgICAgICAgICAgIHYxID0gcDE7XG4gICAgICAgICAgICAgICAgdjIgPSBwMjtcbiAgICAgICAgICAgICAgICB2MyA9IHAzO1xuICAgICAgICAgICAgICAgIHY0ID0gcDQ7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZm4ocDAsIHAxLCBwMiwgcDMsIHA0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1cmVQcm94eTYoZm4pIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdmFyIHYwLCB2MSwgdjIsIHYzLCB2NCwgdjU7XG4gICAgICAgIHYwID0gdjEgPSB2MiA9IHYzID0gdjQgPSB2NSA9IFVOSU5JVElBTElaRUQ7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAocDAsIHAxLCBwMiwgcDMsIHA0LCBwNSkge1xuICAgICAgICAgICAgaWYgKCFsb29zZUlkZW50aWNhbCh2MCwgcDApIHx8ICFsb29zZUlkZW50aWNhbCh2MSwgcDEpIHx8ICFsb29zZUlkZW50aWNhbCh2MiwgcDIpIHx8XG4gICAgICAgICAgICAgICAgIWxvb3NlSWRlbnRpY2FsKHYzLCBwMykgfHwgIWxvb3NlSWRlbnRpY2FsKHY0LCBwNCkgfHwgIWxvb3NlSWRlbnRpY2FsKHY1LCBwNSkpIHtcbiAgICAgICAgICAgICAgICB2MCA9IHAwO1xuICAgICAgICAgICAgICAgIHYxID0gcDE7XG4gICAgICAgICAgICAgICAgdjIgPSBwMjtcbiAgICAgICAgICAgICAgICB2MyA9IHAzO1xuICAgICAgICAgICAgICAgIHY0ID0gcDQ7XG4gICAgICAgICAgICAgICAgdjUgPSBwNTtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBmbihwMCwgcDEsIHAyLCBwMywgcDQsIHA1KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1cmVQcm94eTcoZm4pIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdmFyIHYwLCB2MSwgdjIsIHYzLCB2NCwgdjUsIHY2O1xuICAgICAgICB2MCA9IHYxID0gdjIgPSB2MyA9IHY0ID0gdjUgPSB2NiA9IFVOSU5JVElBTElaRUQ7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAocDAsIHAxLCBwMiwgcDMsIHA0LCBwNSwgcDYpIHtcbiAgICAgICAgICAgIGlmICghbG9vc2VJZGVudGljYWwodjAsIHAwKSB8fCAhbG9vc2VJZGVudGljYWwodjEsIHAxKSB8fCAhbG9vc2VJZGVudGljYWwodjIsIHAyKSB8fFxuICAgICAgICAgICAgICAgICFsb29zZUlkZW50aWNhbCh2MywgcDMpIHx8ICFsb29zZUlkZW50aWNhbCh2NCwgcDQpIHx8ICFsb29zZUlkZW50aWNhbCh2NSwgcDUpIHx8XG4gICAgICAgICAgICAgICAgIWxvb3NlSWRlbnRpY2FsKHY2LCBwNikpIHtcbiAgICAgICAgICAgICAgICB2MCA9IHAwO1xuICAgICAgICAgICAgICAgIHYxID0gcDE7XG4gICAgICAgICAgICAgICAgdjIgPSBwMjtcbiAgICAgICAgICAgICAgICB2MyA9IHAzO1xuICAgICAgICAgICAgICAgIHY0ID0gcDQ7XG4gICAgICAgICAgICAgICAgdjUgPSBwNTtcbiAgICAgICAgICAgICAgICB2NiA9IHA2O1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZuKHAwLCBwMSwgcDIsIHAzLCBwNCwgcDUsIHA2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1cmVQcm94eTgoZm4pIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdmFyIHYwLCB2MSwgdjIsIHYzLCB2NCwgdjUsIHY2LCB2NztcbiAgICAgICAgdjAgPSB2MSA9IHYyID0gdjMgPSB2NCA9IHY1ID0gdjYgPSB2NyA9IFVOSU5JVElBTElaRUQ7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAocDAsIHAxLCBwMiwgcDMsIHA0LCBwNSwgcDYsIHA3KSB7XG4gICAgICAgICAgICBpZiAoIWxvb3NlSWRlbnRpY2FsKHYwLCBwMCkgfHwgIWxvb3NlSWRlbnRpY2FsKHYxLCBwMSkgfHwgIWxvb3NlSWRlbnRpY2FsKHYyLCBwMikgfHxcbiAgICAgICAgICAgICAgICAhbG9vc2VJZGVudGljYWwodjMsIHAzKSB8fCAhbG9vc2VJZGVudGljYWwodjQsIHA0KSB8fCAhbG9vc2VJZGVudGljYWwodjUsIHA1KSB8fFxuICAgICAgICAgICAgICAgICFsb29zZUlkZW50aWNhbCh2NiwgcDYpIHx8ICFsb29zZUlkZW50aWNhbCh2NywgcDcpKSB7XG4gICAgICAgICAgICAgICAgdjAgPSBwMDtcbiAgICAgICAgICAgICAgICB2MSA9IHAxO1xuICAgICAgICAgICAgICAgIHYyID0gcDI7XG4gICAgICAgICAgICAgICAgdjMgPSBwMztcbiAgICAgICAgICAgICAgICB2NCA9IHA0O1xuICAgICAgICAgICAgICAgIHY1ID0gcDU7XG4gICAgICAgICAgICAgICAgdjYgPSBwNjtcbiAgICAgICAgICAgICAgICB2NyA9IHA3O1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZuKHAwLCBwMSwgcDIsIHAzLCBwNCwgcDUsIHA2LCBwNyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdXJlUHJveHk5KGZuKSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIHZhciB2MCwgdjEsIHYyLCB2MywgdjQsIHY1LCB2NiwgdjcsIHY4O1xuICAgICAgICB2MCA9IHYxID0gdjIgPSB2MyA9IHY0ID0gdjUgPSB2NiA9IHY3ID0gdjggPSBVTklOSVRJQUxJWkVEO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHAwLCBwMSwgcDIsIHAzLCBwNCwgcDUsIHA2LCBwNywgcDgpIHtcbiAgICAgICAgICAgIGlmICghbG9vc2VJZGVudGljYWwodjAsIHAwKSB8fCAhbG9vc2VJZGVudGljYWwodjEsIHAxKSB8fCAhbG9vc2VJZGVudGljYWwodjIsIHAyKSB8fFxuICAgICAgICAgICAgICAgICFsb29zZUlkZW50aWNhbCh2MywgcDMpIHx8ICFsb29zZUlkZW50aWNhbCh2NCwgcDQpIHx8ICFsb29zZUlkZW50aWNhbCh2NSwgcDUpIHx8XG4gICAgICAgICAgICAgICAgIWxvb3NlSWRlbnRpY2FsKHY2LCBwNikgfHwgIWxvb3NlSWRlbnRpY2FsKHY3LCBwNykgfHwgIWxvb3NlSWRlbnRpY2FsKHY4LCBwOCkpIHtcbiAgICAgICAgICAgICAgICB2MCA9IHAwO1xuICAgICAgICAgICAgICAgIHYxID0gcDE7XG4gICAgICAgICAgICAgICAgdjIgPSBwMjtcbiAgICAgICAgICAgICAgICB2MyA9IHAzO1xuICAgICAgICAgICAgICAgIHY0ID0gcDQ7XG4gICAgICAgICAgICAgICAgdjUgPSBwNTtcbiAgICAgICAgICAgICAgICB2NiA9IHA2O1xuICAgICAgICAgICAgICAgIHY3ID0gcDc7XG4gICAgICAgICAgICAgICAgdjggPSBwODtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBmbihwMCwgcDEsIHAyLCBwMywgcDQsIHA1LCBwNiwgcDcsIHA4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1cmVQcm94eTEwKGZuKSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIHZhciB2MCwgdjEsIHYyLCB2MywgdjQsIHY1LCB2NiwgdjcsIHY4LCB2OTtcbiAgICAgICAgdjAgPSB2MSA9IHYyID0gdjMgPSB2NCA9IHY1ID0gdjYgPSB2NyA9IHY4ID0gdjkgPSBVTklOSVRJQUxJWkVEO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHAwLCBwMSwgcDIsIHAzLCBwNCwgcDUsIHA2LCBwNywgcDgsIHA5KSB7XG4gICAgICAgICAgICBpZiAoIWxvb3NlSWRlbnRpY2FsKHYwLCBwMCkgfHwgIWxvb3NlSWRlbnRpY2FsKHYxLCBwMSkgfHwgIWxvb3NlSWRlbnRpY2FsKHYyLCBwMikgfHxcbiAgICAgICAgICAgICAgICAhbG9vc2VJZGVudGljYWwodjMsIHAzKSB8fCAhbG9vc2VJZGVudGljYWwodjQsIHA0KSB8fCAhbG9vc2VJZGVudGljYWwodjUsIHA1KSB8fFxuICAgICAgICAgICAgICAgICFsb29zZUlkZW50aWNhbCh2NiwgcDYpIHx8ICFsb29zZUlkZW50aWNhbCh2NywgcDcpIHx8ICFsb29zZUlkZW50aWNhbCh2OCwgcDgpIHx8XG4gICAgICAgICAgICAgICAgIWxvb3NlSWRlbnRpY2FsKHY5LCBwOSkpIHtcbiAgICAgICAgICAgICAgICB2MCA9IHAwO1xuICAgICAgICAgICAgICAgIHYxID0gcDE7XG4gICAgICAgICAgICAgICAgdjIgPSBwMjtcbiAgICAgICAgICAgICAgICB2MyA9IHAzO1xuICAgICAgICAgICAgICAgIHY0ID0gcDQ7XG4gICAgICAgICAgICAgICAgdjUgPSBwNTtcbiAgICAgICAgICAgICAgICB2NiA9IHA2O1xuICAgICAgICAgICAgICAgIHY3ID0gcDc7XG4gICAgICAgICAgICAgICAgdjggPSBwODtcbiAgICAgICAgICAgICAgICB2OSA9IHA5O1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZuKHAwLCBwMSwgcDIsIHAzLCBwNCwgcDUsIHA2LCBwNywgcDgsIHA5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNldEJpbmRpbmdEZWJ1Z0luZm9Gb3JDaGFuZ2VzKHJlbmRlcmVyLCBlbCwgY2hhbmdlcykge1xuICAgICAgICBPYmplY3Qua2V5cyhjaGFuZ2VzKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wTmFtZSkge1xuICAgICAgICAgICAgc2V0QmluZGluZ0RlYnVnSW5mbyhyZW5kZXJlciwgZWwsIHByb3BOYW1lLCBjaGFuZ2VzW3Byb3BOYW1lXS5jdXJyZW50VmFsdWUpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2V0QmluZGluZ0RlYnVnSW5mbyhyZW5kZXJlciwgZWwsIHByb3BOYW1lLCB2YWx1ZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVuZGVyZXIuc2V0QmluZGluZ0RlYnVnSW5mbyhlbCwgXCJuZy1yZWZsZWN0LVwiICsgY2FtZWxDYXNlVG9EYXNoQ2FzZShwcm9wTmFtZSksIHZhbHVlID8gdmFsdWUudG9TdHJpbmcoKSA6IG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZW5kZXJlci5zZXRCaW5kaW5nRGVidWdJbmZvKGVsLCBcIm5nLXJlZmxlY3QtXCIgKyBjYW1lbENhc2VUb0Rhc2hDYXNlKHByb3BOYW1lKSwgJ1tFUlJPUl0gRXhjZXB0aW9uIHdoaWxlIHRyeWluZyB0byBzZXJpYWxpemUgdGhlIHZhbHVlJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIENBTUVMX0NBU0VfUkVHRVhQID0gLyhbQS1aXSkvZztcbiAgICBmdW5jdGlvbiBjYW1lbENhc2VUb0Rhc2hDYXNlKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBpbnB1dC5yZXBsYWNlKENBTUVMX0NBU0VfUkVHRVhQLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbSA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICBtW19pIC0gMF0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICctJyArIG1bMV0udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZVJlbmRlckVsZW1lbnQocmVuZGVyZXIsIHBhcmVudEVsZW1lbnQsIG5hbWUsIGF0dHJzLCBkZWJ1Z0luZm8pIHtcbiAgICAgICAgdmFyIGVsID0gcmVuZGVyZXIuY3JlYXRlRWxlbWVudChwYXJlbnRFbGVtZW50LCBuYW1lLCBkZWJ1Z0luZm8pO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGF0dHJzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICByZW5kZXJlci5zZXRFbGVtZW50QXR0cmlidXRlKGVsLCBhdHRycy5nZXQoaSksIGF0dHJzLmdldChpICsgMSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2VsZWN0T3JDcmVhdGVSZW5kZXJIb3N0RWxlbWVudChyZW5kZXJlciwgZWxlbWVudE5hbWUsIGF0dHJzLCByb290U2VsZWN0b3JPck5vZGUsIGRlYnVnSW5mbykge1xuICAgICAgICB2YXIgaG9zdEVsZW1lbnQ7XG4gICAgICAgIGlmIChpc1ByZXNlbnQocm9vdFNlbGVjdG9yT3JOb2RlKSkge1xuICAgICAgICAgICAgaG9zdEVsZW1lbnQgPSByZW5kZXJlci5zZWxlY3RSb290RWxlbWVudChyb290U2VsZWN0b3JPck5vZGUsIGRlYnVnSW5mbyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBob3N0RWxlbWVudCA9IGNyZWF0ZVJlbmRlckVsZW1lbnQocmVuZGVyZXIsIG51bGwsIGVsZW1lbnROYW1lLCBhdHRycywgZGVidWdJbmZvKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaG9zdEVsZW1lbnQ7XG4gICAgfVxuICAgIHZhciBJbmxpbmVBcnJheTAgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBJbmxpbmVBcnJheTAoKSB7XG4gICAgICAgICAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgSW5saW5lQXJyYXkwLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoaW5kZXgpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfTtcbiAgICAgICAgcmV0dXJuIElubGluZUFycmF5MDtcbiAgICB9KCkpO1xuICAgIHZhciBJbmxpbmVBcnJheTIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBJbmxpbmVBcnJheTIobGVuZ3RoLCBfdjAsIF92MSkge1xuICAgICAgICAgICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgICAgICB0aGlzLl92MCA9IF92MDtcbiAgICAgICAgICAgIHRoaXMuX3YxID0gX3YxO1xuICAgICAgICB9XG4gICAgICAgIElubGluZUFycmF5Mi5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGluZGV4KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdjA7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdjE7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIElubGluZUFycmF5MjtcbiAgICB9KCkpO1xuICAgIHZhciBJbmxpbmVBcnJheTQgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBJbmxpbmVBcnJheTQobGVuZ3RoLCBfdjAsIF92MSwgX3YyLCBfdjMpIHtcbiAgICAgICAgICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5fdjAgPSBfdjA7XG4gICAgICAgICAgICB0aGlzLl92MSA9IF92MTtcbiAgICAgICAgICAgIHRoaXMuX3YyID0gX3YyO1xuICAgICAgICAgICAgdGhpcy5fdjMgPSBfdjM7XG4gICAgICAgIH1cbiAgICAgICAgSW5saW5lQXJyYXk0LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoaW5kZXgpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl92MDtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl92MTtcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl92MjtcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl92MztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gSW5saW5lQXJyYXk0O1xuICAgIH0oKSk7XG4gICAgdmFyIElubGluZUFycmF5OCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIElubGluZUFycmF5OChsZW5ndGgsIF92MCwgX3YxLCBfdjIsIF92MywgX3Y0LCBfdjUsIF92NiwgX3Y3KSB7XG4gICAgICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgICAgIHRoaXMuX3YwID0gX3YwO1xuICAgICAgICAgICAgdGhpcy5fdjEgPSBfdjE7XG4gICAgICAgICAgICB0aGlzLl92MiA9IF92MjtcbiAgICAgICAgICAgIHRoaXMuX3YzID0gX3YzO1xuICAgICAgICAgICAgdGhpcy5fdjQgPSBfdjQ7XG4gICAgICAgICAgICB0aGlzLl92NSA9IF92NTtcbiAgICAgICAgICAgIHRoaXMuX3Y2ID0gX3Y2O1xuICAgICAgICAgICAgdGhpcy5fdjcgPSBfdjc7XG4gICAgICAgIH1cbiAgICAgICAgSW5saW5lQXJyYXk4LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoaW5kZXgpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl92MDtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl92MTtcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl92MjtcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl92MztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl92NDtcbiAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl92NTtcbiAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl92NjtcbiAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl92NztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gSW5saW5lQXJyYXk4O1xuICAgIH0oKSk7XG4gICAgdmFyIElubGluZUFycmF5MTYgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBJbmxpbmVBcnJheTE2KGxlbmd0aCwgX3YwLCBfdjEsIF92MiwgX3YzLCBfdjQsIF92NSwgX3Y2LCBfdjcsIF92OCwgX3Y5LCBfdjEwLCBfdjExLCBfdjEyLCBfdjEzLCBfdjE0LCBfdjE1KSB7XG4gICAgICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgICAgIHRoaXMuX3YwID0gX3YwO1xuICAgICAgICAgICAgdGhpcy5fdjEgPSBfdjE7XG4gICAgICAgICAgICB0aGlzLl92MiA9IF92MjtcbiAgICAgICAgICAgIHRoaXMuX3YzID0gX3YzO1xuICAgICAgICAgICAgdGhpcy5fdjQgPSBfdjQ7XG4gICAgICAgICAgICB0aGlzLl92NSA9IF92NTtcbiAgICAgICAgICAgIHRoaXMuX3Y2ID0gX3Y2O1xuICAgICAgICAgICAgdGhpcy5fdjcgPSBfdjc7XG4gICAgICAgICAgICB0aGlzLl92OCA9IF92ODtcbiAgICAgICAgICAgIHRoaXMuX3Y5ID0gX3Y5O1xuICAgICAgICAgICAgdGhpcy5fdjEwID0gX3YxMDtcbiAgICAgICAgICAgIHRoaXMuX3YxMSA9IF92MTE7XG4gICAgICAgICAgICB0aGlzLl92MTIgPSBfdjEyO1xuICAgICAgICAgICAgdGhpcy5fdjEzID0gX3YxMztcbiAgICAgICAgICAgIHRoaXMuX3YxNCA9IF92MTQ7XG4gICAgICAgICAgICB0aGlzLl92MTUgPSBfdjE1O1xuICAgICAgICB9XG4gICAgICAgIElubGluZUFycmF5MTYucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgICAgc3dpdGNoIChpbmRleCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3YwO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3YxO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3YyO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3YzO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Y0O1xuICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Y1O1xuICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Y2O1xuICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Y3O1xuICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Y4O1xuICAgICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Y5O1xuICAgICAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl92MTA7XG4gICAgICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3YxMTtcbiAgICAgICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdjEyO1xuICAgICAgICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl92MTM7XG4gICAgICAgICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3YxNDtcbiAgICAgICAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdjE1O1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBJbmxpbmVBcnJheTE2O1xuICAgIH0oKSk7XG4gICAgdmFyIElubGluZUFycmF5RHluYW1pYyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIE5vdGU6IFdlIHN0aWxsIHRha2UgdGhlIGxlbmd0aCBhcmd1bWVudCBzbyB0aGlzIGNsYXNzIGNhbiBiZSBjcmVhdGVkXG4gICAgICAgIC8vIGluIHRoZSBzYW1lIHdheXMgYXMgdGhlIG90aGVyIGNsYXNzZXMhXG4gICAgICAgIGZ1bmN0aW9uIElubGluZUFycmF5RHluYW1pYyhsZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFsdWVzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgICAgICB0aGlzLl92YWx1ZXMgPSB2YWx1ZXM7XG4gICAgICAgIH1cbiAgICAgICAgSW5saW5lQXJyYXlEeW5hbWljLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoaW5kZXgpIHsgcmV0dXJuIHRoaXMuX3ZhbHVlc1tpbmRleF07IH07XG4gICAgICAgIHJldHVybiBJbmxpbmVBcnJheUR5bmFtaWM7XG4gICAgfSgpKTtcbiAgICB2YXIgRU1QVFlfSU5MSU5FX0FSUkFZID0gbmV3IElubGluZUFycmF5MCgpO1xuXG5cbiAgICB2YXIgdmlld191dGlscyA9IE9iamVjdC5mcmVlemUoe1xuICAgICAgICBWaWV3VXRpbHM6IFZpZXdVdGlscyxcbiAgICAgICAgZmxhdHRlbk5lc3RlZFZpZXdSZW5kZXJOb2RlczogZmxhdHRlbk5lc3RlZFZpZXdSZW5kZXJOb2RlcyxcbiAgICAgICAgZW5zdXJlU2xvdENvdW50OiBlbnN1cmVTbG90Q291bnQsXG4gICAgICAgIE1BWF9JTlRFUlBPTEFUSU9OX1ZBTFVFUzogTUFYX0lOVEVSUE9MQVRJT05fVkFMVUVTLFxuICAgICAgICBpbnRlcnBvbGF0ZTogaW50ZXJwb2xhdGUsXG4gICAgICAgIGNoZWNrQmluZGluZzogY2hlY2tCaW5kaW5nLFxuICAgICAgICBjYXN0QnlWYWx1ZTogY2FzdEJ5VmFsdWUsXG4gICAgICAgIEVNUFRZX0FSUkFZOiBFTVBUWV9BUlJBWSxcbiAgICAgICAgRU1QVFlfTUFQOiBFTVBUWV9NQVAsXG4gICAgICAgIHB1cmVQcm94eTE6IHB1cmVQcm94eTEsXG4gICAgICAgIHB1cmVQcm94eTI6IHB1cmVQcm94eTIsXG4gICAgICAgIHB1cmVQcm94eTM6IHB1cmVQcm94eTMsXG4gICAgICAgIHB1cmVQcm94eTQ6IHB1cmVQcm94eTQsXG4gICAgICAgIHB1cmVQcm94eTU6IHB1cmVQcm94eTUsXG4gICAgICAgIHB1cmVQcm94eTY6IHB1cmVQcm94eTYsXG4gICAgICAgIHB1cmVQcm94eTc6IHB1cmVQcm94eTcsXG4gICAgICAgIHB1cmVQcm94eTg6IHB1cmVQcm94eTgsXG4gICAgICAgIHB1cmVQcm94eTk6IHB1cmVQcm94eTksXG4gICAgICAgIHB1cmVQcm94eTEwOiBwdXJlUHJveHkxMCxcbiAgICAgICAgc2V0QmluZGluZ0RlYnVnSW5mb0ZvckNoYW5nZXM6IHNldEJpbmRpbmdEZWJ1Z0luZm9Gb3JDaGFuZ2VzLFxuICAgICAgICBzZXRCaW5kaW5nRGVidWdJbmZvOiBzZXRCaW5kaW5nRGVidWdJbmZvLFxuICAgICAgICBjcmVhdGVSZW5kZXJFbGVtZW50OiBjcmVhdGVSZW5kZXJFbGVtZW50LFxuICAgICAgICBzZWxlY3RPckNyZWF0ZVJlbmRlckhvc3RFbGVtZW50OiBzZWxlY3RPckNyZWF0ZVJlbmRlckhvc3RFbGVtZW50LFxuICAgICAgICBJbmxpbmVBcnJheTI6IElubGluZUFycmF5MixcbiAgICAgICAgSW5saW5lQXJyYXk0OiBJbmxpbmVBcnJheTQsXG4gICAgICAgIElubGluZUFycmF5ODogSW5saW5lQXJyYXk4LFxuICAgICAgICBJbmxpbmVBcnJheTE2OiBJbmxpbmVBcnJheTE2LFxuICAgICAgICBJbmxpbmVBcnJheUR5bmFtaWM6IElubGluZUFycmF5RHluYW1pYyxcbiAgICAgICAgRU1QVFlfSU5MSU5FX0FSUkFZOiBFTVBUWV9JTkxJTkVfQVJSQVlcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICB2YXIgX19leHRlbmRzJDUgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXByZXNlbnRzIGFuIGluc3RhbmNlIG9mIGEgQ29tcG9uZW50IGNyZWF0ZWQgdmlhIGEge0BsaW5rIENvbXBvbmVudEZhY3Rvcnl9LlxuICAgICAqXG4gICAgICogYENvbXBvbmVudFJlZmAgcHJvdmlkZXMgYWNjZXNzIHRvIHRoZSBDb21wb25lbnQgSW5zdGFuY2UgYXMgd2VsbCBvdGhlciBvYmplY3RzIHJlbGF0ZWQgdG8gdGhpc1xuICAgICAqIENvbXBvbmVudCBJbnN0YW5jZSBhbmQgYWxsb3dzIHlvdSB0byBkZXN0cm95IHRoZSBDb21wb25lbnQgSW5zdGFuY2UgdmlhIHRoZSB7QGxpbmsgI2Rlc3Ryb3l9XG4gICAgICogbWV0aG9kLlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgQ29tcG9uZW50UmVmID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gQ29tcG9uZW50UmVmKCkge1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21wb25lbnRSZWYucHJvdG90eXBlLCBcImxvY2F0aW9uXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogTG9jYXRpb24gb2YgdGhlIEhvc3QgRWxlbWVudCBvZiB0aGlzIENvbXBvbmVudCBJbnN0YW5jZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1bmltcGxlbWVudGVkKCk7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tcG9uZW50UmVmLnByb3RvdHlwZSwgXCJpbmplY3RvclwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRoZSBpbmplY3RvciBvbiB3aGljaCB0aGUgY29tcG9uZW50IGluc3RhbmNlIGV4aXN0cy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1bmltcGxlbWVudGVkKCk7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tcG9uZW50UmVmLnByb3RvdHlwZSwgXCJpbnN0YW5jZVwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRoZSBpbnN0YW5jZSBvZiB0aGUgQ29tcG9uZW50LlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVuaW1wbGVtZW50ZWQoKTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIDtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbXBvbmVudFJlZi5wcm90b3R5cGUsIFwiaG9zdFZpZXdcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGUge0BsaW5rIFZpZXdSZWZ9IG9mIHRoZSBIb3N0IFZpZXcgb2YgdGhpcyBDb21wb25lbnQgaW5zdGFuY2UuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdW5pbXBsZW1lbnRlZCgpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tcG9uZW50UmVmLnByb3RvdHlwZSwgXCJjaGFuZ2VEZXRlY3RvclJlZlwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRoZSB7QGxpbmsgQ2hhbmdlRGV0ZWN0b3JSZWZ9IG9mIHRoZSBDb21wb25lbnQgaW5zdGFuY2UuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdW5pbXBsZW1lbnRlZCgpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbXBvbmVudFJlZi5wcm90b3R5cGUsIFwiY29tcG9uZW50VHlwZVwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRoZSBjb21wb25lbnQgdHlwZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1bmltcGxlbWVudGVkKCk7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gQ29tcG9uZW50UmVmO1xuICAgIH0oKSk7XG4gICAgdmFyIENvbXBvbmVudFJlZl8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMkNShDb21wb25lbnRSZWZfLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBDb21wb25lbnRSZWZfKF9ob3N0RWxlbWVudCwgX2NvbXBvbmVudFR5cGUpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5faG9zdEVsZW1lbnQgPSBfaG9zdEVsZW1lbnQ7XG4gICAgICAgICAgICB0aGlzLl9jb21wb25lbnRUeXBlID0gX2NvbXBvbmVudFR5cGU7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbXBvbmVudFJlZl8ucHJvdG90eXBlLCBcImxvY2F0aW9uXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5faG9zdEVsZW1lbnQuZWxlbWVudFJlZjsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21wb25lbnRSZWZfLnByb3RvdHlwZSwgXCJpbmplY3RvclwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2hvc3RFbGVtZW50LmluamVjdG9yOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbXBvbmVudFJlZl8ucHJvdG90eXBlLCBcImluc3RhbmNlXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5faG9zdEVsZW1lbnQuY29tcG9uZW50OyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tcG9uZW50UmVmXy5wcm90b3R5cGUsIFwiaG9zdFZpZXdcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9ob3N0RWxlbWVudC5wYXJlbnRWaWV3LnJlZjsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIDtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbXBvbmVudFJlZl8ucHJvdG90eXBlLCBcImNoYW5nZURldGVjdG9yUmVmXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5faG9zdEVsZW1lbnQucGFyZW50Vmlldy5yZWY7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICA7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21wb25lbnRSZWZfLnByb3RvdHlwZSwgXCJjb21wb25lbnRUeXBlXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fY29tcG9uZW50VHlwZTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIENvbXBvbmVudFJlZl8ucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX2hvc3RFbGVtZW50LnBhcmVudFZpZXcuZGVzdHJveSgpOyB9O1xuICAgICAgICBDb21wb25lbnRSZWZfLnByb3RvdHlwZS5vbkRlc3Ryb3kgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHsgdGhpcy5ob3N0Vmlldy5vbkRlc3Ryb3koY2FsbGJhY2spOyB9O1xuICAgICAgICByZXR1cm4gQ29tcG9uZW50UmVmXztcbiAgICB9KENvbXBvbmVudFJlZikpO1xuICAgIC8qKlxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICB2YXIgRU1QVFlfQ09OVEVYVCA9IG5ldyBPYmplY3QoKTtcbiAgICAvKipcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIENvbXBvbmVudEZhY3RvcnkgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBDb21wb25lbnRGYWN0b3J5KHNlbGVjdG9yLCBfdmlld0ZhY3RvcnksIF9jb21wb25lbnRUeXBlKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdG9yID0gc2VsZWN0b3I7XG4gICAgICAgICAgICB0aGlzLl92aWV3RmFjdG9yeSA9IF92aWV3RmFjdG9yeTtcbiAgICAgICAgICAgIHRoaXMuX2NvbXBvbmVudFR5cGUgPSBfY29tcG9uZW50VHlwZTtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tcG9uZW50RmFjdG9yeS5wcm90b3R5cGUsIFwiY29tcG9uZW50VHlwZVwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2NvbXBvbmVudFR5cGU7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIG5ldyBjb21wb25lbnQuXG4gICAgICAgICAqL1xuICAgICAgICBDb21wb25lbnRGYWN0b3J5LnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbiAoaW5qZWN0b3IsIHByb2plY3RhYmxlTm9kZXMsIHJvb3RTZWxlY3Rvck9yTm9kZSkge1xuICAgICAgICAgICAgaWYgKHByb2plY3RhYmxlTm9kZXMgPT09IHZvaWQgMCkgeyBwcm9qZWN0YWJsZU5vZGVzID0gbnVsbDsgfVxuICAgICAgICAgICAgaWYgKHJvb3RTZWxlY3Rvck9yTm9kZSA9PT0gdm9pZCAwKSB7IHJvb3RTZWxlY3Rvck9yTm9kZSA9IG51bGw7IH1cbiAgICAgICAgICAgIHZhciB2dSA9IGluamVjdG9yLmdldChWaWV3VXRpbHMpO1xuICAgICAgICAgICAgaWYgKCFwcm9qZWN0YWJsZU5vZGVzKSB7XG4gICAgICAgICAgICAgICAgcHJvamVjdGFibGVOb2RlcyA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTm90ZTogSG9zdCB2aWV3cyBkb24ndCBuZWVkIGEgZGVjbGFyYXRpb25BcHBFbGVtZW50IVxuICAgICAgICAgICAgdmFyIGhvc3RWaWV3ID0gdGhpcy5fdmlld0ZhY3RvcnkodnUsIGluamVjdG9yLCBudWxsKTtcbiAgICAgICAgICAgIHZhciBob3N0RWxlbWVudCA9IGhvc3RWaWV3LmNyZWF0ZShFTVBUWV9DT05URVhULCBwcm9qZWN0YWJsZU5vZGVzLCByb290U2VsZWN0b3JPck5vZGUpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb21wb25lbnRSZWZfKGhvc3RFbGVtZW50LCB0aGlzLl9jb21wb25lbnRUeXBlKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIENvbXBvbmVudEZhY3Rvcnk7XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICB2YXIgX19leHRlbmRzJDcgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIE5vQ29tcG9uZW50RmFjdG9yeUVycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDcoTm9Db21wb25lbnRGYWN0b3J5RXJyb3IsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIE5vQ29tcG9uZW50RmFjdG9yeUVycm9yKGNvbXBvbmVudCkge1xuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgXCJObyBjb21wb25lbnQgZmFjdG9yeSBmb3VuZCBmb3IgXCIgKyBzdHJpbmdpZnkoY29tcG9uZW50KSk7XG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudCA9IGNvbXBvbmVudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTm9Db21wb25lbnRGYWN0b3J5RXJyb3I7XG4gICAgfShCYXNlRXJyb3IpKTtcbiAgICB2YXIgX051bGxDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBfTnVsbENvbXBvbmVudEZhY3RvcnlSZXNvbHZlcigpIHtcbiAgICAgICAgfVxuICAgICAgICBfTnVsbENvbXBvbmVudEZhY3RvcnlSZXNvbHZlci5wcm90b3R5cGUucmVzb2x2ZUNvbXBvbmVudEZhY3RvcnkgPSBmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgTm9Db21wb25lbnRGYWN0b3J5RXJyb3IoY29tcG9uZW50KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF9OdWxsQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyO1xuICAgIH0oKSk7XG4gICAgLyoqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIoKSB7XG4gICAgICAgIH1cbiAgICAgICAgQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyLk5VTEwgPSBuZXcgX051bGxDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIoKTtcbiAgICAgICAgcmV0dXJuIENvbXBvbmVudEZhY3RvcnlSZXNvbHZlcjtcbiAgICB9KCkpO1xuICAgIHZhciBDb2RlZ2VuQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gQ29kZWdlbkNvbXBvbmVudEZhY3RvcnlSZXNvbHZlcihmYWN0b3JpZXMsIF9wYXJlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX3BhcmVudCA9IF9wYXJlbnQ7XG4gICAgICAgICAgICB0aGlzLl9mYWN0b3JpZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZhY3Rvcmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBmYWN0b3J5ID0gZmFjdG9yaWVzW2ldO1xuICAgICAgICAgICAgICAgIHRoaXMuX2ZhY3Rvcmllcy5zZXQoZmFjdG9yeS5jb21wb25lbnRUeXBlLCBmYWN0b3J5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBDb2RlZ2VuQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyLnByb3RvdHlwZS5yZXNvbHZlQ29tcG9uZW50RmFjdG9yeSA9IGZ1bmN0aW9uIChjb21wb25lbnQpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLl9mYWN0b3JpZXMuZ2V0KGNvbXBvbmVudCk7XG4gICAgICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuX3BhcmVudC5yZXNvbHZlQ29tcG9uZW50RmFjdG9yeShjb21wb25lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIENvZGVnZW5Db21wb25lbnRGYWN0b3J5UmVzb2x2ZXI7XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICB2YXIgX19leHRlbmRzJDggPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBVc2UgYnkgZGlyZWN0aXZlcyBhbmQgY29tcG9uZW50cyB0byBlbWl0IGN1c3RvbSBFdmVudHMuXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZXNcbiAgICAgKlxuICAgICAqIEluIHRoZSBmb2xsb3dpbmcgZXhhbXBsZSwgYFppcHB5YCBhbHRlcm5hdGl2ZWx5IGVtaXRzIGBvcGVuYCBhbmQgYGNsb3NlYCBldmVudHMgd2hlbiBpdHNcbiAgICAgKiB0aXRsZSBnZXRzIGNsaWNrZWQ6XG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiBAQ29tcG9uZW50KHtcbiAgICAgKiAgIHNlbGVjdG9yOiAnemlwcHknLFxuICAgICAqICAgdGVtcGxhdGU6IGBcbiAgICAgKiAgIDxkaXYgY2xhc3M9XCJ6aXBweVwiPlxuICAgICAqICAgICA8ZGl2IChjbGljayk9XCJ0b2dnbGUoKVwiPlRvZ2dsZTwvZGl2PlxuICAgICAqICAgICA8ZGl2IFtoaWRkZW5dPVwiIXZpc2libGVcIj5cbiAgICAgKiAgICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG4gICAgICogICAgIDwvZGl2PlxuICAgICAqICA8L2Rpdj5gfSlcbiAgICAgKiBleHBvcnQgY2xhc3MgWmlwcHkge1xuICAgICAqICAgdmlzaWJsZTogYm9vbGVhbiA9IHRydWU7XG4gICAgICogICBAT3V0cHV0KCkgb3BlbjogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICogICBAT3V0cHV0KCkgY2xvc2U6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAqXG4gICAgICogICB0b2dnbGUoKSB7XG4gICAgICogICAgIHRoaXMudmlzaWJsZSA9ICF0aGlzLnZpc2libGU7XG4gICAgICogICAgIGlmICh0aGlzLnZpc2libGUpIHtcbiAgICAgKiAgICAgICB0aGlzLm9wZW4uZW1pdChudWxsKTtcbiAgICAgKiAgICAgfSBlbHNlIHtcbiAgICAgKiAgICAgICB0aGlzLmNsb3NlLmVtaXQobnVsbCk7XG4gICAgICogICAgIH1cbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBUaGUgZXZlbnRzIHBheWxvYWQgY2FuIGJlIGFjY2Vzc2VkIGJ5IHRoZSBwYXJhbWV0ZXIgYCRldmVudGAgb24gdGhlIGNvbXBvbmVudHMgb3V0cHV0IGV2ZW50XG4gICAgICogaGFuZGxlcjpcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIDx6aXBweSAob3Blbik9XCJvbk9wZW4oJGV2ZW50KVwiIChjbG9zZSk9XCJvbkNsb3NlKCRldmVudClcIj48L3ppcHB5PlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogVXNlcyBSeC5PYnNlcnZhYmxlIGJ1dCBwcm92aWRlcyBhbiBhZGFwdGVyIHRvIG1ha2UgaXQgd29yayBhcyBzcGVjaWZpZWQgaGVyZTpcbiAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vamh1c2Fpbi9vYnNlcnZhYmxlLXNwZWNcbiAgICAgKlxuICAgICAqIE9uY2UgYSByZWZlcmVuY2UgaW1wbGVtZW50YXRpb24gb2YgdGhlIHNwZWMgaXMgYXZhaWxhYmxlLCBzd2l0Y2ggdG8gaXQuXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBFdmVudEVtaXR0ZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMkOChFdmVudEVtaXR0ZXIsIF9zdXBlcik7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIFtFdmVudEVtaXR0ZXJdLCB3aGljaCBkZXBlbmRpbmcgb24gW2lzQXN5bmNdLFxuICAgICAgICAgKiBkZWxpdmVycyBldmVudHMgc3luY2hyb25vdXNseSBvciBhc3luY2hyb25vdXNseS5cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIEV2ZW50RW1pdHRlcihpc0FzeW5jKSB7XG4gICAgICAgICAgICBpZiAoaXNBc3luYyA9PT0gdm9pZCAwKSB7IGlzQXN5bmMgPSBmYWxzZTsgfVxuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB0aGlzLl9faXNBc3luYyA9IGlzQXN5bmM7XG4gICAgICAgIH1cbiAgICAgICAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gKHZhbHVlKSB7IF9zdXBlci5wcm90b3R5cGUubmV4dC5jYWxsKHRoaXMsIHZhbHVlKTsgfTtcbiAgICAgICAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoZ2VuZXJhdG9yT3JOZXh0LCBlcnJvciwgY29tcGxldGUpIHtcbiAgICAgICAgICAgIHZhciBzY2hlZHVsZXJGbjtcbiAgICAgICAgICAgIHZhciBlcnJvckZuID0gZnVuY3Rpb24gKGVycikgeyByZXR1cm4gbnVsbDsgfTtcbiAgICAgICAgICAgIHZhciBjb21wbGV0ZUZuID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbnVsbDsgfTtcbiAgICAgICAgICAgIGlmIChnZW5lcmF0b3JPck5leHQgJiYgdHlwZW9mIGdlbmVyYXRvck9yTmV4dCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICBzY2hlZHVsZXJGbiA9IHRoaXMuX19pc0FzeW5jID8gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2VuZXJhdG9yT3JOZXh0Lm5leHQodmFsdWUpOyB9KTtcbiAgICAgICAgICAgICAgICB9IDogZnVuY3Rpb24gKHZhbHVlKSB7IGdlbmVyYXRvck9yTmV4dC5uZXh0KHZhbHVlKTsgfTtcbiAgICAgICAgICAgICAgICBpZiAoZ2VuZXJhdG9yT3JOZXh0LmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yRm4gPSB0aGlzLl9faXNBc3luYyA/IGZ1bmN0aW9uIChlcnIpIHsgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBnZW5lcmF0b3JPck5leHQuZXJyb3IoZXJyKTsgfSk7IH0gOlxuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGVycikgeyBnZW5lcmF0b3JPck5leHQuZXJyb3IoZXJyKTsgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGdlbmVyYXRvck9yTmV4dC5jb21wbGV0ZSkge1xuICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZUZuID0gdGhpcy5fX2lzQXN5bmMgPyBmdW5jdGlvbiAoKSB7IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2VuZXJhdG9yT3JOZXh0LmNvbXBsZXRlKCk7IH0pOyB9IDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHsgZ2VuZXJhdG9yT3JOZXh0LmNvbXBsZXRlKCk7IH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2NoZWR1bGVyRm4gPSB0aGlzLl9faXNBc3luYyA/IGZ1bmN0aW9uICh2YWx1ZSkgeyBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdlbmVyYXRvck9yTmV4dCh2YWx1ZSk7IH0pOyB9IDpcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKHZhbHVlKSB7IGdlbmVyYXRvck9yTmV4dCh2YWx1ZSk7IH07XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yRm4gPVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fX2lzQXN5bmMgPyBmdW5jdGlvbiAoZXJyKSB7IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gZXJyb3IoZXJyKTsgfSk7IH0gOiBmdW5jdGlvbiAoZXJyKSB7IGVycm9yKGVycik7IH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjb21wbGV0ZSkge1xuICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZUZuID1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX19pc0FzeW5jID8gZnVuY3Rpb24gKCkgeyBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbXBsZXRlKCk7IH0pOyB9IDogZnVuY3Rpb24gKCkgeyBjb21wbGV0ZSgpOyB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLnN1YnNjcmliZS5jYWxsKHRoaXMsIHNjaGVkdWxlckZuLCBlcnJvckZuLCBjb21wbGV0ZUZuKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIEV2ZW50RW1pdHRlcjtcbiAgICB9KHJ4anNfU3ViamVjdC5TdWJqZWN0KSk7XG5cbiAgICAvKipcbiAgICAgKiBBbiBpbmplY3RhYmxlIHNlcnZpY2UgZm9yIGV4ZWN1dGluZyB3b3JrIGluc2lkZSBvciBvdXRzaWRlIG9mIHRoZSBBbmd1bGFyIHpvbmUuXG4gICAgICpcbiAgICAgKiBUaGUgbW9zdCBjb21tb24gdXNlIG9mIHRoaXMgc2VydmljZSBpcyB0byBvcHRpbWl6ZSBwZXJmb3JtYW5jZSB3aGVuIHN0YXJ0aW5nIGEgd29yayBjb25zaXN0aW5nIG9mXG4gICAgICogb25lIG9yIG1vcmUgYXN5bmNocm9ub3VzIHRhc2tzIHRoYXQgZG9uJ3QgcmVxdWlyZSBVSSB1cGRhdGVzIG9yIGVycm9yIGhhbmRsaW5nIHRvIGJlIGhhbmRsZWQgYnlcbiAgICAgKiBBbmd1bGFyLiBTdWNoIHRhc2tzIGNhbiBiZSBraWNrZWQgb2ZmIHZpYSB7QGxpbmsgcnVuT3V0c2lkZUFuZ3VsYXJ9IGFuZCBpZiBuZWVkZWQsIHRoZXNlIHRhc2tzXG4gICAgICogY2FuIHJlZW50ZXIgdGhlIEFuZ3VsYXIgem9uZSB2aWEge0BsaW5rIHJ1bn0uXG4gICAgICpcbiAgICAgKiA8IS0tIFRPRE86IGFkZC9maXggbGlua3MgdG86XG4gICAgICogICAtIGRvY3MgZXhwbGFpbmluZyB6b25lcyBhbmQgdGhlIHVzZSBvZiB6b25lcyBpbiBBbmd1bGFyIGFuZCBjaGFuZ2UtZGV0ZWN0aW9uXG4gICAgICogICAtIGxpbmsgdG8gcnVuT3V0c2lkZUFuZ3VsYXIvcnVuICh0aHJvdWdob3V0IHRoaXMgZmlsZSEpXG4gICAgICogICAtLT5cbiAgICAgKlxuICAgICAqICMjIyBFeGFtcGxlXG4gICAgICogYGBgXG4gICAgICogaW1wb3J0IHtDb21wb25lbnQsIE5nWm9uZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG4gICAgICogaW1wb3J0IHtOZ0lmfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuICAgICAqXG4gICAgICogQENvbXBvbmVudCh7XG4gICAgICogICBzZWxlY3RvcjogJ25nLXpvbmUtZGVtbycuXG4gICAgICogICB0ZW1wbGF0ZTogYFxuICAgICAqICAgICA8aDI+RGVtbzogTmdab25lPC9oMj5cbiAgICAgKlxuICAgICAqICAgICA8cD5Qcm9ncmVzczoge3twcm9ncmVzc319JTwvcD5cbiAgICAgKiAgICAgPHAgKm5nSWY9XCJwcm9ncmVzcyA+PSAxMDBcIj5Eb25lIHByb2Nlc3Npbmcge3tsYWJlbH19IG9mIEFuZ3VsYXIgem9uZSE8L3A+XG4gICAgICpcbiAgICAgKiAgICAgPGJ1dHRvbiAoY2xpY2spPVwicHJvY2Vzc1dpdGhpbkFuZ3VsYXJab25lKClcIj5Qcm9jZXNzIHdpdGhpbiBBbmd1bGFyIHpvbmU8L2J1dHRvbj5cbiAgICAgKiAgICAgPGJ1dHRvbiAoY2xpY2spPVwicHJvY2Vzc091dHNpZGVPZkFuZ3VsYXJab25lKClcIj5Qcm9jZXNzIG91dHNpZGUgb2YgQW5ndWxhciB6b25lPC9idXR0b24+XG4gICAgICogICBgLFxuICAgICAqIH0pXG4gICAgICogZXhwb3J0IGNsYXNzIE5nWm9uZURlbW8ge1xuICAgICAqICAgcHJvZ3Jlc3M6IG51bWJlciA9IDA7XG4gICAgICogICBsYWJlbDogc3RyaW5nO1xuICAgICAqXG4gICAgICogICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9uZ1pvbmU6IE5nWm9uZSkge31cbiAgICAgKlxuICAgICAqICAgLy8gTG9vcCBpbnNpZGUgdGhlIEFuZ3VsYXIgem9uZVxuICAgICAqICAgLy8gc28gdGhlIFVJIERPRVMgcmVmcmVzaCBhZnRlciBlYWNoIHNldFRpbWVvdXQgY3ljbGVcbiAgICAgKiAgIHByb2Nlc3NXaXRoaW5Bbmd1bGFyWm9uZSgpIHtcbiAgICAgKiAgICAgdGhpcy5sYWJlbCA9ICdpbnNpZGUnO1xuICAgICAqICAgICB0aGlzLnByb2dyZXNzID0gMDtcbiAgICAgKiAgICAgdGhpcy5faW5jcmVhc2VQcm9ncmVzcygoKSA9PiBjb25zb2xlLmxvZygnSW5zaWRlIERvbmUhJykpO1xuICAgICAqICAgfVxuICAgICAqXG4gICAgICogICAvLyBMb29wIG91dHNpZGUgb2YgdGhlIEFuZ3VsYXIgem9uZVxuICAgICAqICAgLy8gc28gdGhlIFVJIERPRVMgTk9UIHJlZnJlc2ggYWZ0ZXIgZWFjaCBzZXRUaW1lb3V0IGN5Y2xlXG4gICAgICogICBwcm9jZXNzT3V0c2lkZU9mQW5ndWxhclpvbmUoKSB7XG4gICAgICogICAgIHRoaXMubGFiZWwgPSAnb3V0c2lkZSc7XG4gICAgICogICAgIHRoaXMucHJvZ3Jlc3MgPSAwO1xuICAgICAqICAgICB0aGlzLl9uZ1pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgICAqICAgICAgIHRoaXMuX2luY3JlYXNlUHJvZ3Jlc3MoKCkgPT4ge1xuICAgICAqICAgICAgIC8vIHJlZW50ZXIgdGhlIEFuZ3VsYXIgem9uZSBhbmQgZGlzcGxheSBkb25lXG4gICAgICogICAgICAgdGhpcy5fbmdab25lLnJ1bigoKSA9PiB7Y29uc29sZS5sb2coJ091dHNpZGUgRG9uZSEnKSB9KTtcbiAgICAgKiAgICAgfX0pKTtcbiAgICAgKiAgIH1cbiAgICAgKlxuICAgICAqICAgX2luY3JlYXNlUHJvZ3Jlc3MoZG9uZUNhbGxiYWNrOiAoKSA9PiB2b2lkKSB7XG4gICAgICogICAgIHRoaXMucHJvZ3Jlc3MgKz0gMTtcbiAgICAgKiAgICAgY29uc29sZS5sb2coYEN1cnJlbnQgcHJvZ3Jlc3M6ICR7dGhpcy5wcm9ncmVzc30lYCk7XG4gICAgICpcbiAgICAgKiAgICAgaWYgKHRoaXMucHJvZ3Jlc3MgPCAxMDApIHtcbiAgICAgKiAgICAgICB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB0aGlzLl9pbmNyZWFzZVByb2dyZXNzKGRvbmVDYWxsYmFjaykpLCAxMClcbiAgICAgKiAgICAgfSBlbHNlIHtcbiAgICAgKiAgICAgICBkb25lQ2FsbGJhY2soKTtcbiAgICAgKiAgICAgfVxuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgdmFyIE5nWm9uZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIE5nWm9uZShfYSkge1xuICAgICAgICAgICAgdmFyIF9iID0gX2EuZW5hYmxlTG9uZ1N0YWNrVHJhY2UsIGVuYWJsZUxvbmdTdGFja1RyYWNlID0gX2IgPT09IHZvaWQgMCA/IGZhbHNlIDogX2I7XG4gICAgICAgICAgICB0aGlzLl9oYXNQZW5kaW5nTWljcm90YXNrcyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5faGFzUGVuZGluZ01hY3JvdGFza3MgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2lzU3RhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX25lc3RpbmcgPSAwO1xuICAgICAgICAgICAgdGhpcy5fb25VbnN0YWJsZSA9IG5ldyBFdmVudEVtaXR0ZXIoZmFsc2UpO1xuICAgICAgICAgICAgdGhpcy5fb25NaWNyb3Rhc2tFbXB0eSA9IG5ldyBFdmVudEVtaXR0ZXIoZmFsc2UpO1xuICAgICAgICAgICAgdGhpcy5fb25TdGFibGUgPSBuZXcgRXZlbnRFbWl0dGVyKGZhbHNlKTtcbiAgICAgICAgICAgIHRoaXMuX29uRXJyb3JFdmVudHMgPSBuZXcgRXZlbnRFbWl0dGVyKGZhbHNlKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgWm9uZSA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQW5ndWxhciByZXF1aXJlcyBab25lLmpzIHByb2x5ZmlsbC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFpvbmUuYXNzZXJ0Wm9uZVBhdGNoZWQoKTtcbiAgICAgICAgICAgIHRoaXMub3V0ZXIgPSB0aGlzLmlubmVyID0gWm9uZS5jdXJyZW50O1xuICAgICAgICAgICAgaWYgKFpvbmVbJ3d0ZlpvbmVTcGVjJ10pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlubmVyID0gdGhpcy5pbm5lci5mb3JrKFpvbmVbJ3d0ZlpvbmVTcGVjJ10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVuYWJsZUxvbmdTdGFja1RyYWNlICYmIFpvbmVbJ2xvbmdTdGFja1RyYWNlWm9uZVNwZWMnXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5uZXIgPSB0aGlzLmlubmVyLmZvcmsoWm9uZVsnbG9uZ1N0YWNrVHJhY2Vab25lU3BlYyddKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZm9ya0lubmVyWm9uZVdpdGhBbmd1bGFyQmVoYXZpb3IoKTtcbiAgICAgICAgfVxuICAgICAgICBOZ1pvbmUuaXNJbkFuZ3VsYXJab25lID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gWm9uZS5jdXJyZW50LmdldCgnaXNBbmd1bGFyWm9uZScpID09PSB0cnVlOyB9O1xuICAgICAgICBOZ1pvbmUuYXNzZXJ0SW5Bbmd1bGFyWm9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghTmdab25lLmlzSW5Bbmd1bGFyWm9uZSgpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0byBiZSBpbiBBbmd1bGFyIFpvbmUsIGJ1dCBpdCBpcyBub3QhJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIE5nWm9uZS5hc3NlcnROb3RJbkFuZ3VsYXJab25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKE5nWm9uZS5pc0luQW5ndWxhclpvbmUoKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdG8gbm90IGJlIGluIEFuZ3VsYXIgWm9uZSwgYnV0IGl0IGlzIScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogRXhlY3V0ZXMgdGhlIGBmbmAgZnVuY3Rpb24gc3luY2hyb25vdXNseSB3aXRoaW4gdGhlIEFuZ3VsYXIgem9uZSBhbmQgcmV0dXJucyB2YWx1ZSByZXR1cm5lZCBieVxuICAgICAgICAgKiB0aGUgZnVuY3Rpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIFJ1bm5pbmcgZnVuY3Rpb25zIHZpYSBgcnVuYCBhbGxvd3MgeW91IHRvIHJlZW50ZXIgQW5ndWxhciB6b25lIGZyb20gYSB0YXNrIHRoYXQgd2FzIGV4ZWN1dGVkXG4gICAgICAgICAqIG91dHNpZGUgb2YgdGhlIEFuZ3VsYXIgem9uZSAodHlwaWNhbGx5IHN0YXJ0ZWQgdmlhIHtAbGluayBydW5PdXRzaWRlQW5ndWxhcn0pLlxuICAgICAgICAgKlxuICAgICAgICAgKiBBbnkgZnV0dXJlIHRhc2tzIG9yIG1pY3JvdGFza3Mgc2NoZWR1bGVkIGZyb20gd2l0aGluIHRoaXMgZnVuY3Rpb24gd2lsbCBjb250aW51ZSBleGVjdXRpbmcgZnJvbVxuICAgICAgICAgKiB3aXRoaW4gdGhlIEFuZ3VsYXIgem9uZS5cbiAgICAgICAgICpcbiAgICAgICAgICogSWYgYSBzeW5jaHJvbm91cyBlcnJvciBoYXBwZW5zIGl0IHdpbGwgYmUgcmV0aHJvd24gYW5kIG5vdCByZXBvcnRlZCB2aWEgYG9uRXJyb3JgLlxuICAgICAgICAgKi9cbiAgICAgICAgTmdab25lLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoZm4pIHsgcmV0dXJuIHRoaXMuaW5uZXIucnVuKGZuKTsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNhbWUgYXMgYHJ1bmAsIGV4Y2VwdCB0aGF0IHN5bmNocm9ub3VzIGVycm9ycyBhcmUgY2F1Z2h0IGFuZCBmb3J3YXJkZWQgdmlhIGBvbkVycm9yYCBhbmQgbm90XG4gICAgICAgICAqIHJldGhyb3duLlxuICAgICAgICAgKi9cbiAgICAgICAgTmdab25lLnByb3RvdHlwZS5ydW5HdWFyZGVkID0gZnVuY3Rpb24gKGZuKSB7IHJldHVybiB0aGlzLmlubmVyLnJ1bkd1YXJkZWQoZm4pOyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogRXhlY3V0ZXMgdGhlIGBmbmAgZnVuY3Rpb24gc3luY2hyb25vdXNseSBpbiBBbmd1bGFyJ3MgcGFyZW50IHpvbmUgYW5kIHJldHVybnMgdmFsdWUgcmV0dXJuZWQgYnlcbiAgICAgICAgICogdGhlIGZ1bmN0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBSdW5uaW5nIGZ1bmN0aW9ucyB2aWEgYHJ1bk91dHNpZGVBbmd1bGFyYCBhbGxvd3MgeW91IHRvIGVzY2FwZSBBbmd1bGFyJ3Mgem9uZSBhbmQgZG8gd29yayB0aGF0XG4gICAgICAgICAqIGRvZXNuJ3QgdHJpZ2dlciBBbmd1bGFyIGNoYW5nZS1kZXRlY3Rpb24gb3IgaXMgc3ViamVjdCB0byBBbmd1bGFyJ3MgZXJyb3IgaGFuZGxpbmcuXG4gICAgICAgICAqXG4gICAgICAgICAqIEFueSBmdXR1cmUgdGFza3Mgb3IgbWljcm90YXNrcyBzY2hlZHVsZWQgZnJvbSB3aXRoaW4gdGhpcyBmdW5jdGlvbiB3aWxsIGNvbnRpbnVlIGV4ZWN1dGluZyBmcm9tXG4gICAgICAgICAqIG91dHNpZGUgb2YgdGhlIEFuZ3VsYXIgem9uZS5cbiAgICAgICAgICpcbiAgICAgICAgICogVXNlIHtAbGluayBydW59IHRvIHJlZW50ZXIgdGhlIEFuZ3VsYXIgem9uZSBhbmQgZG8gd29yayB0aGF0IHVwZGF0ZXMgdGhlIGFwcGxpY2F0aW9uIG1vZGVsLlxuICAgICAgICAgKi9cbiAgICAgICAgTmdab25lLnByb3RvdHlwZS5ydW5PdXRzaWRlQW5ndWxhciA9IGZ1bmN0aW9uIChmbikgeyByZXR1cm4gdGhpcy5vdXRlci5ydW4oZm4pOyB9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdab25lLnByb3RvdHlwZSwgXCJvblVuc3RhYmxlXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogTm90aWZpZXMgd2hlbiBjb2RlIGVudGVycyBBbmd1bGFyIFpvbmUuIFRoaXMgZ2V0cyBmaXJlZCBmaXJzdCBvbiBWTSBUdXJuLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX29uVW5zdGFibGU7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdab25lLnByb3RvdHlwZSwgXCJvbk1pY3JvdGFza0VtcHR5XCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogTm90aWZpZXMgd2hlbiB0aGVyZSBpcyBubyBtb3JlIG1pY3JvdGFza3MgZW5xdWV1ZSBpbiB0aGUgY3VycmVudCBWTSBUdXJuLlxuICAgICAgICAgICAgICogVGhpcyBpcyBhIGhpbnQgZm9yIEFuZ3VsYXIgdG8gZG8gY2hhbmdlIGRldGVjdGlvbiwgd2hpY2ggbWF5IGVucXVldWUgbW9yZSBtaWNyb3Rhc2tzLlxuICAgICAgICAgICAgICogRm9yIHRoaXMgcmVhc29uIHRoaXMgZXZlbnQgY2FuIGZpcmUgbXVsdGlwbGUgdGltZXMgcGVyIFZNIFR1cm4uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fb25NaWNyb3Rhc2tFbXB0eTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ1pvbmUucHJvdG90eXBlLCBcIm9uU3RhYmxlXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogTm90aWZpZXMgd2hlbiB0aGUgbGFzdCBgb25NaWNyb3Rhc2tFbXB0eWAgaGFzIHJ1biBhbmQgdGhlcmUgYXJlIG5vIG1vcmUgbWljcm90YXNrcywgd2hpY2hcbiAgICAgICAgICAgICAqIGltcGxpZXMgd2UgYXJlIGFib3V0IHRvIHJlbGlucXVpc2ggVk0gdHVybi5cbiAgICAgICAgICAgICAqIFRoaXMgZXZlbnQgZ2V0cyBjYWxsZWQganVzdCBvbmNlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX29uU3RhYmxlOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nWm9uZS5wcm90b3R5cGUsIFwib25FcnJvclwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIE5vdGlmeSB0aGF0IGFuIGVycm9yIGhhcyBiZWVuIGRlbGl2ZXJlZC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9vbkVycm9yRXZlbnRzOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nWm9uZS5wcm90b3R5cGUsIFwiaXNTdGFibGVcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBXaGV0aGVyIHRoZXJlIGFyZSBubyBvdXRzdGFuZGluZyBtaWNyb3Rhc2tzIG9yIG1hY3JvdGFza3MuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5faXNTdGFibGU7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdab25lLnByb3RvdHlwZSwgXCJoYXNQZW5kaW5nTWljcm90YXNrc1wiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2hhc1BlbmRpbmdNaWNyb3Rhc2tzOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nWm9uZS5wcm90b3R5cGUsIFwiaGFzUGVuZGluZ01hY3JvdGFza3NcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9oYXNQZW5kaW5nTWFjcm90YXNrczsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE5nWm9uZS5wcm90b3R5cGUuY2hlY2tTdGFibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgaWYgKHRoaXMuX25lc3RpbmcgPT0gMCAmJiAhdGhpcy5faGFzUGVuZGluZ01pY3JvdGFza3MgJiYgIXRoaXMuX2lzU3RhYmxlKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbmVzdGluZysrO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9vbk1pY3JvdGFza0VtcHR5LmVtaXQobnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9uZXN0aW5nLS07XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5faGFzUGVuZGluZ01pY3JvdGFza3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ydW5PdXRzaWRlQW5ndWxhcihmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fb25TdGFibGUuZW1pdChudWxsKTsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9pc1N0YWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIE5nWm9uZS5wcm90b3R5cGUuZm9ya0lubmVyWm9uZVdpdGhBbmd1bGFyQmVoYXZpb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5pbm5lciA9IHRoaXMuaW5uZXIuZm9yayh7XG4gICAgICAgICAgICAgICAgbmFtZTogJ2FuZ3VsYXInLFxuICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IHsgJ2lzQW5ndWxhclpvbmUnOiB0cnVlIH0sXG4gICAgICAgICAgICAgICAgb25JbnZva2VUYXNrOiBmdW5jdGlvbiAoZGVsZWdhdGUsIGN1cnJlbnQsIHRhcmdldCwgdGFzaywgYXBwbHlUaGlzLCBhcHBseUFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLm9uRW50ZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkZWxlZ2F0ZS5pbnZva2VUYXNrKHRhcmdldCwgdGFzaywgYXBwbHlUaGlzLCBhcHBseUFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMub25MZWF2ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvbkludm9rZTogZnVuY3Rpb24gKGRlbGVnYXRlLCBjdXJyZW50LCB0YXJnZXQsIGNhbGxiYWNrLCBhcHBseVRoaXMsIGFwcGx5QXJncywgc291cmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5vbkVudGVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVsZWdhdGUuaW52b2tlKHRhcmdldCwgY2FsbGJhY2ssIGFwcGx5VGhpcywgYXBwbHlBcmdzLCBzb3VyY2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMub25MZWF2ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvbkhhc1Rhc2s6IGZ1bmN0aW9uIChkZWxlZ2F0ZSwgY3VycmVudCwgdGFyZ2V0LCBoYXNUYXNrU3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZWdhdGUuaGFzVGFzayh0YXJnZXQsIGhhc1Rhc2tTdGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50ID09PSB0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGFyZSBvbmx5IGludGVyZXN0ZWQgaW4gaGFzVGFzayBldmVudHMgd2hpY2ggb3JpZ2luYXRlIGZyb20gb3VyIHpvbmVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIChBIGNoaWxkIGhhc1Rhc2sgZXZlbnQgaXMgbm90IGludGVyZXN0aW5nIHRvIHVzKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhc1Rhc2tTdGF0ZS5jaGFuZ2UgPT0gJ21pY3JvVGFzaycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5zZXRIYXNNaWNyb3Rhc2soaGFzVGFza1N0YXRlLm1pY3JvVGFzayk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChoYXNUYXNrU3RhdGUuY2hhbmdlID09ICdtYWNyb1Rhc2snKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2V0SGFzTWFjcm90YXNrKGhhc1Rhc2tTdGF0ZS5tYWNyb1Rhc2spO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvbkhhbmRsZUVycm9yOiBmdW5jdGlvbiAoZGVsZWdhdGUsIGN1cnJlbnQsIHRhcmdldCwgZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZWdhdGUuaGFuZGxlRXJyb3IodGFyZ2V0LCBlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnRyaWdnZXJFcnJvcihlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgTmdab25lLnByb3RvdHlwZS5vbkVudGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fbmVzdGluZysrO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2lzU3RhYmxlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faXNTdGFibGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9vblVuc3RhYmxlLmVtaXQobnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIE5nWm9uZS5wcm90b3R5cGUub25MZWF2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX25lc3RpbmctLTtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tTdGFibGUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgTmdab25lLnByb3RvdHlwZS5zZXRIYXNNaWNyb3Rhc2sgPSBmdW5jdGlvbiAoaGFzTWljcm90YXNrcykge1xuICAgICAgICAgICAgdGhpcy5faGFzUGVuZGluZ01pY3JvdGFza3MgPSBoYXNNaWNyb3Rhc2tzO1xuICAgICAgICAgICAgdGhpcy5jaGVja1N0YWJsZSgpO1xuICAgICAgICB9O1xuICAgICAgICBOZ1pvbmUucHJvdG90eXBlLnNldEhhc01hY3JvdGFzayA9IGZ1bmN0aW9uIChoYXNNYWNyb3Rhc2tzKSB7IHRoaXMuX2hhc1BlbmRpbmdNYWNyb3Rhc2tzID0gaGFzTWFjcm90YXNrczsgfTtcbiAgICAgICAgTmdab25lLnByb3RvdHlwZS50cmlnZ2VyRXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHsgdGhpcy5fb25FcnJvckV2ZW50cy5lbWl0KGVycm9yKTsgfTtcbiAgICAgICAgcmV0dXJuIE5nWm9uZTtcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIFRlc3RhYmlsaXR5IHNlcnZpY2UgcHJvdmlkZXMgdGVzdGluZyBob29rcyB0aGF0IGNhbiBiZSBhY2Nlc3NlZCBmcm9tXG4gICAgICogdGhlIGJyb3dzZXIgYW5kIGJ5IHNlcnZpY2VzIHN1Y2ggYXMgUHJvdHJhY3Rvci4gRWFjaCBib290c3RyYXBwZWQgQW5ndWxhclxuICAgICAqIGFwcGxpY2F0aW9uIG9uIHRoZSBwYWdlIHdpbGwgaGF2ZSBhbiBpbnN0YW5jZSBvZiBUZXN0YWJpbGl0eS5cbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgdmFyIFRlc3RhYmlsaXR5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gVGVzdGFiaWxpdHkoX25nWm9uZSkge1xuICAgICAgICAgICAgdGhpcy5fbmdab25lID0gX25nWm9uZTtcbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgICAgIHRoaXMuX3BlbmRpbmdDb3VudCA9IDA7XG4gICAgICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgICAgICB0aGlzLl9pc1pvbmVTdGFibGUgPSB0cnVlO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBXaGV0aGVyIGFueSB3b3JrIHdhcyBkb25lIHNpbmNlIHRoZSBsYXN0ICd3aGVuU3RhYmxlJyBjYWxsYmFjay4gVGhpcyBpc1xuICAgICAgICAgICAgICogdXNlZnVsIHRvIGRldGVjdCBpZiB0aGlzIGNvdWxkIGhhdmUgcG90ZW50aWFsbHkgZGVzdGFiaWxpemVkIGFub3RoZXJcbiAgICAgICAgICAgICAqIGNvbXBvbmVudCB3aGlsZSBpdCBpcyBzdGFiaWxpemluZy5cbiAgICAgICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLl9kaWRXb3JrID0gZmFsc2U7XG4gICAgICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgICAgICB0aGlzLl9jYWxsYmFja3MgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX3dhdGNoQW5ndWxhckV2ZW50cygpO1xuICAgICAgICB9XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgVGVzdGFiaWxpdHkucHJvdG90eXBlLl93YXRjaEFuZ3VsYXJFdmVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5fbmdab25lLm9uVW5zdGFibGUuc3Vic2NyaWJlKHtcbiAgICAgICAgICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9kaWRXb3JrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2lzWm9uZVN0YWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5fbmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fbmdab25lLm9uU3RhYmxlLnN1YnNjcmliZSh7XG4gICAgICAgICAgICAgICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIE5nWm9uZS5hc3NlcnROb3RJbkFuZ3VsYXJab25lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY2hlZHVsZU1pY3JvVGFzayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2lzWm9uZVN0YWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3J1bkNhbGxiYWNrc0lmUmVhZHkoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgVGVzdGFiaWxpdHkucHJvdG90eXBlLmluY3JlYXNlUGVuZGluZ1JlcXVlc3RDb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX3BlbmRpbmdDb3VudCArPSAxO1xuICAgICAgICAgICAgdGhpcy5fZGlkV29yayA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcGVuZGluZ0NvdW50O1xuICAgICAgICB9O1xuICAgICAgICBUZXN0YWJpbGl0eS5wcm90b3R5cGUuZGVjcmVhc2VQZW5kaW5nUmVxdWVzdENvdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fcGVuZGluZ0NvdW50IC09IDE7XG4gICAgICAgICAgICBpZiAodGhpcy5fcGVuZGluZ0NvdW50IDwgMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncGVuZGluZyBhc3luYyByZXF1ZXN0cyBiZWxvdyB6ZXJvJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9ydW5DYWxsYmFja3NJZlJlYWR5KCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcGVuZGluZ0NvdW50O1xuICAgICAgICB9O1xuICAgICAgICBUZXN0YWJpbGl0eS5wcm90b3R5cGUuaXNTdGFibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faXNab25lU3RhYmxlICYmIHRoaXMuX3BlbmRpbmdDb3VudCA9PSAwICYmICF0aGlzLl9uZ1pvbmUuaGFzUGVuZGluZ01hY3JvdGFza3M7XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgVGVzdGFiaWxpdHkucHJvdG90eXBlLl9ydW5DYWxsYmFja3NJZlJlYWR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIGlmICh0aGlzLmlzU3RhYmxlKCkpIHtcbiAgICAgICAgICAgICAgICAvLyBTY2hlZHVsZXMgdGhlIGNhbGwgYmFja3MgaW4gYSBuZXcgZnJhbWUgc28gdGhhdCBpdCBpcyBhbHdheXMgYXN5bmMuXG4gICAgICAgICAgICAgICAgc2NoZWR1bGVNaWNyb1Rhc2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoX3RoaXMuX2NhbGxiYWNrcy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIChfdGhpcy5fY2FsbGJhY2tzLnBvcCgpKShfdGhpcy5fZGlkV29yayk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2RpZFdvcmsgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIE5vdCBSZWFkeVxuICAgICAgICAgICAgICAgIHRoaXMuX2RpZFdvcmsgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBUZXN0YWJpbGl0eS5wcm90b3R5cGUud2hlblN0YWJsZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICAgICAgdGhpcy5fY2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICAgICAgICAgICAgdGhpcy5fcnVuQ2FsbGJhY2tzSWZSZWFkeSgpO1xuICAgICAgICB9O1xuICAgICAgICBUZXN0YWJpbGl0eS5wcm90b3R5cGUuZ2V0UGVuZGluZ1JlcXVlc3RDb3VudCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3BlbmRpbmdDb3VudDsgfTtcbiAgICAgICAgLyoqIEBkZXByZWNhdGVkIHVzZSBmaW5kUHJvdmlkZXJzICovXG4gICAgICAgIFRlc3RhYmlsaXR5LnByb3RvdHlwZS5maW5kQmluZGluZ3MgPSBmdW5jdGlvbiAodXNpbmcsIHByb3ZpZGVyLCBleGFjdE1hdGNoKSB7XG4gICAgICAgICAgICAvLyBUT0RPKGp1bGllbXIpOiBpbXBsZW1lbnQuXG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH07XG4gICAgICAgIFRlc3RhYmlsaXR5LnByb3RvdHlwZS5maW5kUHJvdmlkZXJzID0gZnVuY3Rpb24gKHVzaW5nLCBwcm92aWRlciwgZXhhY3RNYXRjaCkge1xuICAgICAgICAgICAgLy8gVE9ETyhqdWxpZW1yKTogaW1wbGVtZW50LlxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9O1xuICAgICAgICBUZXN0YWJpbGl0eS5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBJbmplY3RhYmxlIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBUZXN0YWJpbGl0eS5jdG9yUGFyYW1ldGVycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogTmdab25lLCB9LFxuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gVGVzdGFiaWxpdHk7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBBIGdsb2JhbCByZWdpc3RyeSBvZiB7QGxpbmsgVGVzdGFiaWxpdHl9IGluc3RhbmNlcyBmb3Igc3BlY2lmaWMgZWxlbWVudHMuXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIHZhciBUZXN0YWJpbGl0eVJlZ2lzdHJ5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gVGVzdGFiaWxpdHlSZWdpc3RyeSgpIHtcbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgICAgIHRoaXMuX2FwcGxpY2F0aW9ucyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIF90ZXN0YWJpbGl0eUdldHRlci5hZGRUb1dpbmRvdyh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBUZXN0YWJpbGl0eVJlZ2lzdHJ5LnByb3RvdHlwZS5yZWdpc3RlckFwcGxpY2F0aW9uID0gZnVuY3Rpb24gKHRva2VuLCB0ZXN0YWJpbGl0eSkge1xuICAgICAgICAgICAgdGhpcy5fYXBwbGljYXRpb25zLnNldCh0b2tlbiwgdGVzdGFiaWxpdHkpO1xuICAgICAgICB9O1xuICAgICAgICBUZXN0YWJpbGl0eVJlZ2lzdHJ5LnByb3RvdHlwZS5nZXRUZXN0YWJpbGl0eSA9IGZ1bmN0aW9uIChlbGVtKSB7IHJldHVybiB0aGlzLl9hcHBsaWNhdGlvbnMuZ2V0KGVsZW0pOyB9O1xuICAgICAgICBUZXN0YWJpbGl0eVJlZ2lzdHJ5LnByb3RvdHlwZS5nZXRBbGxUZXN0YWJpbGl0aWVzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gTWFwV3JhcHBlci52YWx1ZXModGhpcy5fYXBwbGljYXRpb25zKTsgfTtcbiAgICAgICAgVGVzdGFiaWxpdHlSZWdpc3RyeS5wcm90b3R5cGUuZ2V0QWxsUm9vdEVsZW1lbnRzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gTWFwV3JhcHBlci5rZXlzKHRoaXMuX2FwcGxpY2F0aW9ucyk7IH07XG4gICAgICAgIFRlc3RhYmlsaXR5UmVnaXN0cnkucHJvdG90eXBlLmZpbmRUZXN0YWJpbGl0eUluVHJlZSA9IGZ1bmN0aW9uIChlbGVtLCBmaW5kSW5BbmNlc3RvcnMpIHtcbiAgICAgICAgICAgIGlmIChmaW5kSW5BbmNlc3RvcnMgPT09IHZvaWQgMCkgeyBmaW5kSW5BbmNlc3RvcnMgPSB0cnVlOyB9XG4gICAgICAgICAgICByZXR1cm4gX3Rlc3RhYmlsaXR5R2V0dGVyLmZpbmRUZXN0YWJpbGl0eUluVHJlZSh0aGlzLCBlbGVtLCBmaW5kSW5BbmNlc3RvcnMpO1xuICAgICAgICB9O1xuICAgICAgICBUZXN0YWJpbGl0eVJlZ2lzdHJ5LmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IEluamVjdGFibGUgfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIFRlc3RhYmlsaXR5UmVnaXN0cnkuY3RvclBhcmFtZXRlcnMgPSBbXTtcbiAgICAgICAgcmV0dXJuIFRlc3RhYmlsaXR5UmVnaXN0cnk7XG4gICAgfSgpKTtcbiAgICB2YXIgX05vb3BHZXRUZXN0YWJpbGl0eSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIF9Ob29wR2V0VGVzdGFiaWxpdHkoKSB7XG4gICAgICAgIH1cbiAgICAgICAgX05vb3BHZXRUZXN0YWJpbGl0eS5wcm90b3R5cGUuYWRkVG9XaW5kb3cgPSBmdW5jdGlvbiAocmVnaXN0cnkpIHsgfTtcbiAgICAgICAgX05vb3BHZXRUZXN0YWJpbGl0eS5wcm90b3R5cGUuZmluZFRlc3RhYmlsaXR5SW5UcmVlID0gZnVuY3Rpb24gKHJlZ2lzdHJ5LCBlbGVtLCBmaW5kSW5BbmNlc3RvcnMpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX05vb3BHZXRUZXN0YWJpbGl0eTtcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIFNldCB0aGUge0BsaW5rIEdldFRlc3RhYmlsaXR5fSBpbXBsZW1lbnRhdGlvbiB1c2VkIGJ5IHRoZSBBbmd1bGFyIHRlc3RpbmcgZnJhbWV3b3JrLlxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXRUZXN0YWJpbGl0eUdldHRlcihnZXR0ZXIpIHtcbiAgICAgICAgX3Rlc3RhYmlsaXR5R2V0dGVyID0gZ2V0dGVyO1xuICAgIH1cbiAgICB2YXIgX3Rlc3RhYmlsaXR5R2V0dGVyID0gbmV3IF9Ob29wR2V0VGVzdGFiaWxpdHkoKTtcblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICB2YXIgX19leHRlbmRzJDMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbiAgICB2YXIgX2Rldk1vZGUgPSB0cnVlO1xuICAgIHZhciBfcnVuTW9kZUxvY2tlZCA9IGZhbHNlO1xuICAgIHZhciBfcGxhdGZvcm07XG4gICAgLyoqXG4gICAgICogRGlzYWJsZSBBbmd1bGFyJ3MgZGV2ZWxvcG1lbnQgbW9kZSwgd2hpY2ggdHVybnMgb2ZmIGFzc2VydGlvbnMgYW5kIG90aGVyXG4gICAgICogY2hlY2tzIHdpdGhpbiB0aGUgZnJhbWV3b3JrLlxuICAgICAqXG4gICAgICogT25lIGltcG9ydGFudCBhc3NlcnRpb24gdGhpcyBkaXNhYmxlcyB2ZXJpZmllcyB0aGF0IGEgY2hhbmdlIGRldGVjdGlvbiBwYXNzXG4gICAgICogZG9lcyBub3QgcmVzdWx0IGluIGFkZGl0aW9uYWwgY2hhbmdlcyB0byBhbnkgYmluZGluZ3MgKGFsc28ga25vd24gYXNcbiAgICAgKiB1bmlkaXJlY3Rpb25hbCBkYXRhIGZsb3cpLlxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVuYWJsZVByb2RNb2RlKCkge1xuICAgICAgICBpZiAoX3J1bk1vZGVMb2NrZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGVuYWJsZSBwcm9kIG1vZGUgYWZ0ZXIgcGxhdGZvcm0gc2V0dXAuJyk7XG4gICAgICAgIH1cbiAgICAgICAgX2Rldk1vZGUgPSBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIEFuZ3VsYXIgaXMgaW4gZGV2ZWxvcG1lbnQgbW9kZS4gQWZ0ZXIgY2FsbGVkIG9uY2UsXG4gICAgICogdGhlIHZhbHVlIGlzIGxvY2tlZCBhbmQgd29uJ3QgY2hhbmdlIGFueSBtb3JlLlxuICAgICAqXG4gICAgICogQnkgZGVmYXVsdCwgdGhpcyBpcyB0cnVlLCB1bmxlc3MgYSB1c2VyIGNhbGxzIGBlbmFibGVQcm9kTW9kZWAgYmVmb3JlIGNhbGxpbmcgdGhpcy5cbiAgICAgKlxuICAgICAqIEBleHBlcmltZW50YWwgQVBJcyByZWxhdGVkIHRvIGFwcGxpY2F0aW9uIGJvb3RzdHJhcCBhcmUgY3VycmVudGx5IHVuZGVyIHJldmlldy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0Rldk1vZGUoKSB7XG4gICAgICAgIF9ydW5Nb2RlTG9ja2VkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIF9kZXZNb2RlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgcGxhdGZvcm0uXG4gICAgICogUGxhdGZvcm1zIGhhdmUgdG8gYmUgZWFnZXJseSBjcmVhdGVkIHZpYSB0aGlzIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQGV4cGVyaW1lbnRhbCBBUElzIHJlbGF0ZWQgdG8gYXBwbGljYXRpb24gYm9vdHN0cmFwIGFyZSBjdXJyZW50bHkgdW5kZXIgcmV2aWV3LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVBsYXRmb3JtKGluamVjdG9yKSB7XG4gICAgICAgIGlmIChfcGxhdGZvcm0gJiYgIV9wbGF0Zm9ybS5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlcmUgY2FuIGJlIG9ubHkgb25lIHBsYXRmb3JtLiBEZXN0cm95IHRoZSBwcmV2aW91cyBvbmUgdG8gY3JlYXRlIGEgbmV3IG9uZS4nKTtcbiAgICAgICAgfVxuICAgICAgICBfcGxhdGZvcm0gPSBpbmplY3Rvci5nZXQoUGxhdGZvcm1SZWYpO1xuICAgICAgICB2YXIgaW5pdHMgPSBpbmplY3Rvci5nZXQoUExBVEZPUk1fSU5JVElBTElaRVIsIG51bGwpO1xuICAgICAgICBpZiAoaW5pdHMpXG4gICAgICAgICAgICBpbml0cy5mb3JFYWNoKGZ1bmN0aW9uIChpbml0KSB7IHJldHVybiBpbml0KCk7IH0pO1xuICAgICAgICByZXR1cm4gX3BsYXRmb3JtO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZmFjdG9yeSBmb3IgYSBwbGF0Zm9ybVxuICAgICAqXG4gICAgICogQGV4cGVyaW1lbnRhbCBBUElzIHJlbGF0ZWQgdG8gYXBwbGljYXRpb24gYm9vdHN0cmFwIGFyZSBjdXJyZW50bHkgdW5kZXIgcmV2aWV3LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVBsYXRmb3JtRmFjdG9yeShwYXJlbnRQbGFmb3JtRmFjdG9yeSwgbmFtZSwgcHJvdmlkZXJzKSB7XG4gICAgICAgIGlmIChwcm92aWRlcnMgPT09IHZvaWQgMCkgeyBwcm92aWRlcnMgPSBbXTsgfVxuICAgICAgICB2YXIgbWFya2VyID0gbmV3IE9wYXF1ZVRva2VuKFwiUGxhdGZvcm06IFwiICsgbmFtZSk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZXh0cmFQcm92aWRlcnMpIHtcbiAgICAgICAgICAgIGlmIChleHRyYVByb3ZpZGVycyA9PT0gdm9pZCAwKSB7IGV4dHJhUHJvdmlkZXJzID0gW107IH1cbiAgICAgICAgICAgIGlmICghZ2V0UGxhdGZvcm0oKSkge1xuICAgICAgICAgICAgICAgIGlmIChwYXJlbnRQbGFmb3JtRmFjdG9yeSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnRQbGFmb3JtRmFjdG9yeShwcm92aWRlcnMuY29uY2F0KGV4dHJhUHJvdmlkZXJzKS5jb25jYXQoeyBwcm92aWRlOiBtYXJrZXIsIHVzZVZhbHVlOiB0cnVlIH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZVBsYXRmb3JtKFJlZmxlY3RpdmVJbmplY3Rvci5yZXNvbHZlQW5kQ3JlYXRlKHByb3ZpZGVycy5jb25jYXQoZXh0cmFQcm92aWRlcnMpLmNvbmNhdCh7IHByb3ZpZGU6IG1hcmtlciwgdXNlVmFsdWU6IHRydWUgfSkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYXNzZXJ0UGxhdGZvcm0obWFya2VyKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHRoYXQgdGhlcmUgY3VycmVudGx5IGlzIGEgcGxhdGZvcm1cbiAgICAgKiB3aGljaCBjb250YWlucyB0aGUgZ2l2ZW4gdG9rZW4gYXMgYSBwcm92aWRlci5cbiAgICAgKlxuICAgICAqIEBleHBlcmltZW50YWwgQVBJcyByZWxhdGVkIHRvIGFwcGxpY2F0aW9uIGJvb3RzdHJhcCBhcmUgY3VycmVudGx5IHVuZGVyIHJldmlldy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhc3NlcnRQbGF0Zm9ybShyZXF1aXJlZFRva2VuKSB7XG4gICAgICAgIHZhciBwbGF0Zm9ybSA9IGdldFBsYXRmb3JtKCk7XG4gICAgICAgIGlmICghcGxhdGZvcm0pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gcGxhdGZvcm0gZXhpc3RzIScpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcGxhdGZvcm0uaW5qZWN0b3IuZ2V0KHJlcXVpcmVkVG9rZW4sIG51bGwpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0EgcGxhdGZvcm0gd2l0aCBhIGRpZmZlcmVudCBjb25maWd1cmF0aW9uIGhhcyBiZWVuIGNyZWF0ZWQuIFBsZWFzZSBkZXN0cm95IGl0IGZpcnN0LicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwbGF0Zm9ybTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVzdHJveSB0aGUgZXhpc3RpbmcgcGxhdGZvcm0uXG4gICAgICpcbiAgICAgKiBAZXhwZXJpbWVudGFsIEFQSXMgcmVsYXRlZCB0byBhcHBsaWNhdGlvbiBib290c3RyYXAgYXJlIGN1cnJlbnRseSB1bmRlciByZXZpZXcuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGVzdHJveVBsYXRmb3JtKCkge1xuICAgICAgICBpZiAoX3BsYXRmb3JtICYmICFfcGxhdGZvcm0uZGVzdHJveWVkKSB7XG4gICAgICAgICAgICBfcGxhdGZvcm0uZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnQgcGxhdGZvcm0uXG4gICAgICpcbiAgICAgKiBAZXhwZXJpbWVudGFsIEFQSXMgcmVsYXRlZCB0byBhcHBsaWNhdGlvbiBib290c3RyYXAgYXJlIGN1cnJlbnRseSB1bmRlciByZXZpZXcuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0UGxhdGZvcm0oKSB7XG4gICAgICAgIHJldHVybiBfcGxhdGZvcm0gJiYgIV9wbGF0Zm9ybS5kZXN0cm95ZWQgPyBfcGxhdGZvcm0gOiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgQW5ndWxhciBwbGF0Zm9ybSBpcyB0aGUgZW50cnkgcG9pbnQgZm9yIEFuZ3VsYXIgb24gYSB3ZWIgcGFnZS4gRWFjaCBwYWdlXG4gICAgICogaGFzIGV4YWN0bHkgb25lIHBsYXRmb3JtLCBhbmQgc2VydmljZXMgKHN1Y2ggYXMgcmVmbGVjdGlvbikgd2hpY2ggYXJlIGNvbW1vblxuICAgICAqIHRvIGV2ZXJ5IEFuZ3VsYXIgYXBwbGljYXRpb24gcnVubmluZyBvbiB0aGUgcGFnZSBhcmUgYm91bmQgaW4gaXRzIHNjb3BlLlxuICAgICAqXG4gICAgICogQSBwYWdlJ3MgcGxhdGZvcm0gaXMgaW5pdGlhbGl6ZWQgaW1wbGljaXRseSB3aGVuIHtAbGluayBib290c3RyYXB9KCkgaXMgY2FsbGVkLCBvclxuICAgICAqIGV4cGxpY2l0bHkgYnkgY2FsbGluZyB7QGxpbmsgY3JlYXRlUGxhdGZvcm19KCkuXG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIFBsYXRmb3JtUmVmID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gUGxhdGZvcm1SZWYoKSB7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgYW4gYEBOZ01vZHVsZWAgZm9yIHRoZSBnaXZlbiBwbGF0Zm9ybVxuICAgICAgICAgKiBmb3Igb2ZmbGluZSBjb21waWxhdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogIyMgU2ltcGxlIEV4YW1wbGVcbiAgICAgICAgICpcbiAgICAgICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAgICAgKiBteV9tb2R1bGUudHM6XG4gICAgICAgICAqXG4gICAgICAgICAqIEBOZ01vZHVsZSh7XG4gICAgICAgICAqICAgaW1wb3J0czogW0Jyb3dzZXJNb2R1bGVdXG4gICAgICAgICAqIH0pXG4gICAgICAgICAqIGNsYXNzIE15TW9kdWxlIHt9XG4gICAgICAgICAqXG4gICAgICAgICAqIG1haW4udHM6XG4gICAgICAgICAqIGltcG9ydCB7TXlNb2R1bGVOZ0ZhY3Rvcnl9IGZyb20gJy4vbXlfbW9kdWxlLm5nZmFjdG9yeSc7XG4gICAgICAgICAqIGltcG9ydCB7cGxhdGZvcm1Ccm93c2VyfSBmcm9tICdAYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyJztcbiAgICAgICAgICpcbiAgICAgICAgICogbGV0IG1vZHVsZVJlZiA9IHBsYXRmb3JtQnJvd3NlcigpLmJvb3RzdHJhcE1vZHVsZUZhY3RvcnkoTXlNb2R1bGVOZ0ZhY3RvcnkpO1xuICAgICAgICAgKiBgYGBcbiAgICAgICAgICpcbiAgICAgICAgICogQGV4cGVyaW1lbnRhbCBBUElzIHJlbGF0ZWQgdG8gYXBwbGljYXRpb24gYm9vdHN0cmFwIGFyZSBjdXJyZW50bHkgdW5kZXIgcmV2aWV3LlxuICAgICAgICAgKi9cbiAgICAgICAgUGxhdGZvcm1SZWYucHJvdG90eXBlLmJvb3RzdHJhcE1vZHVsZUZhY3RvcnkgPSBmdW5jdGlvbiAobW9kdWxlRmFjdG9yeSkge1xuICAgICAgICAgICAgdGhyb3cgdW5pbXBsZW1lbnRlZCgpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBhbiBgQE5nTW9kdWxlYCBmb3IgYSBnaXZlbiBwbGF0Zm9ybSB1c2luZyB0aGUgZ2l2ZW4gcnVudGltZSBjb21waWxlci5cbiAgICAgICAgICpcbiAgICAgICAgICogIyMgU2ltcGxlIEV4YW1wbGVcbiAgICAgICAgICpcbiAgICAgICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAgICAgKiBATmdNb2R1bGUoe1xuICAgICAgICAgKiAgIGltcG9ydHM6IFtCcm93c2VyTW9kdWxlXVxuICAgICAgICAgKiB9KVxuICAgICAgICAgKiBjbGFzcyBNeU1vZHVsZSB7fVxuICAgICAgICAgKlxuICAgICAgICAgKiBsZXQgbW9kdWxlUmVmID0gcGxhdGZvcm1Ccm93c2VyKCkuYm9vdHN0cmFwTW9kdWxlKE15TW9kdWxlKTtcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqIEBzdGFibGVcbiAgICAgICAgICovXG4gICAgICAgIFBsYXRmb3JtUmVmLnByb3RvdHlwZS5ib290c3RyYXBNb2R1bGUgPSBmdW5jdGlvbiAobW9kdWxlVHlwZSwgY29tcGlsZXJPcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAoY29tcGlsZXJPcHRpb25zID09PSB2b2lkIDApIHsgY29tcGlsZXJPcHRpb25zID0gW107IH1cbiAgICAgICAgICAgIHRocm93IHVuaW1wbGVtZW50ZWQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFBsYXRmb3JtUmVmLnByb3RvdHlwZSwgXCJpbmplY3RvclwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJldHJpZXZlIHRoZSBwbGF0Zm9ybSB7QGxpbmsgSW5qZWN0b3J9LCB3aGljaCBpcyB0aGUgcGFyZW50IGluamVjdG9yIGZvclxuICAgICAgICAgICAgICogZXZlcnkgQW5ndWxhciBhcHBsaWNhdGlvbiBvbiB0aGUgcGFnZSBhbmQgcHJvdmlkZXMgc2luZ2xldG9uIHByb3ZpZGVycy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHRocm93IHVuaW1wbGVtZW50ZWQoKTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIDtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFBsYXRmb3JtUmVmLnByb3RvdHlwZSwgXCJkZXN0cm95ZWRcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHRocm93IHVuaW1wbGVtZW50ZWQoKTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBQbGF0Zm9ybVJlZjtcbiAgICB9KCkpO1xuICAgIGZ1bmN0aW9uIF9jYWxsQW5kUmVwb3J0VG9FcnJvckhhbmRsZXIoZXJyb3JIYW5kbGVyLCBjYWxsYmFjaykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGNhbGxiYWNrKCk7XG4gICAgICAgICAgICBpZiAoaXNQcm9taXNlKHJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0LmNhdGNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9ySGFuZGxlci5oYW5kbGVFcnJvcihlKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gcmV0aHJvdyBhcyB0aGUgZXhjZXB0aW9uIGhhbmRsZXIgbWlnaHQgbm90IGRvIGl0XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBlcnJvckhhbmRsZXIuaGFuZGxlRXJyb3IoZSk7XG4gICAgICAgICAgICAvLyByZXRocm93IGFzIHRoZSBleGNlcHRpb24gaGFuZGxlciBtaWdodCBub3QgZG8gaXRcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIFBsYXRmb3JtUmVmXyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQzKFBsYXRmb3JtUmVmXywgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gUGxhdGZvcm1SZWZfKF9pbmplY3Rvcikge1xuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB0aGlzLl9pbmplY3RvciA9IF9pbmplY3RvcjtcbiAgICAgICAgICAgIHRoaXMuX21vZHVsZXMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX2Rlc3Ryb3lMaXN0ZW5lcnMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX2Rlc3Ryb3llZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIFBsYXRmb3JtUmVmXy5wcm90b3R5cGUub25EZXN0cm95ID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7IHRoaXMuX2Rlc3Ryb3lMaXN0ZW5lcnMucHVzaChjYWxsYmFjayk7IH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQbGF0Zm9ybVJlZl8ucHJvdG90eXBlLCBcImluamVjdG9yXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5faW5qZWN0b3I7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUGxhdGZvcm1SZWZfLnByb3RvdHlwZSwgXCJkZXN0cm95ZWRcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kZXN0cm95ZWQ7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBQbGF0Zm9ybVJlZl8ucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fZGVzdHJveWVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgcGxhdGZvcm0gaGFzIGFscmVhZHkgYmVlbiBkZXN0cm95ZWQhJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9tb2R1bGVzLnNsaWNlKCkuZm9yRWFjaChmdW5jdGlvbiAobW9kdWxlKSB7IHJldHVybiBtb2R1bGUuZGVzdHJveSgpOyB9KTtcbiAgICAgICAgICAgIHRoaXMuX2Rlc3Ryb3lMaXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbiAobGlzdGVuZXIpIHsgcmV0dXJuIGxpc3RlbmVyKCk7IH0pO1xuICAgICAgICAgICAgdGhpcy5fZGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgUGxhdGZvcm1SZWZfLnByb3RvdHlwZS5ib290c3RyYXBNb2R1bGVGYWN0b3J5ID0gZnVuY3Rpb24gKG1vZHVsZUZhY3RvcnkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9ib290c3RyYXBNb2R1bGVGYWN0b3J5V2l0aFpvbmUobW9kdWxlRmFjdG9yeSwgbnVsbCk7XG4gICAgICAgIH07XG4gICAgICAgIFBsYXRmb3JtUmVmXy5wcm90b3R5cGUuX2Jvb3RzdHJhcE1vZHVsZUZhY3RvcnlXaXRoWm9uZSA9IGZ1bmN0aW9uIChtb2R1bGVGYWN0b3J5LCBuZ1pvbmUpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICAvLyBOb3RlOiBXZSBuZWVkIHRvIGNyZWF0ZSB0aGUgTmdab25lIF9iZWZvcmVfIHdlIGluc3RhbnRpYXRlIHRoZSBtb2R1bGUsXG4gICAgICAgICAgICAvLyBhcyBpbnN0YW50aWF0aW5nIHRoZSBtb2R1bGUgY3JlYXRlcyBzb21lIHByb3ZpZGVycyBlYWdlcmx5LlxuICAgICAgICAgICAgLy8gU28gd2UgY3JlYXRlIGEgbWluaSBwYXJlbnQgaW5qZWN0b3IgdGhhdCBqdXN0IGNvbnRhaW5zIHRoZSBuZXcgTmdab25lIGFuZFxuICAgICAgICAgICAgLy8gcGFzcyB0aGF0IGFzIHBhcmVudCB0byB0aGUgTmdNb2R1bGVGYWN0b3J5LlxuICAgICAgICAgICAgaWYgKCFuZ1pvbmUpXG4gICAgICAgICAgICAgICAgbmdab25lID0gbmV3IE5nWm9uZSh7IGVuYWJsZUxvbmdTdGFja1RyYWNlOiBpc0Rldk1vZGUoKSB9KTtcbiAgICAgICAgICAgIC8vIEF0dGVudGlvbjogRG9uJ3QgdXNlIEFwcGxpY2F0aW9uUmVmLnJ1biBoZXJlLFxuICAgICAgICAgICAgLy8gYXMgd2Ugd2FudCB0byBiZSBzdXJlIHRoYXQgYWxsIHBvc3NpYmxlIGNvbnN0cnVjdG9yIGNhbGxzIGFyZSBpbnNpZGUgYG5nWm9uZS5ydW5gIVxuICAgICAgICAgICAgcmV0dXJuIG5nWm9uZS5ydW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBuZ1pvbmVJbmplY3RvciA9IFJlZmxlY3RpdmVJbmplY3Rvci5yZXNvbHZlQW5kQ3JlYXRlKFt7IHByb3ZpZGU6IE5nWm9uZSwgdXNlVmFsdWU6IG5nWm9uZSB9XSwgX3RoaXMuaW5qZWN0b3IpO1xuICAgICAgICAgICAgICAgIHZhciBtb2R1bGVSZWYgPSBtb2R1bGVGYWN0b3J5LmNyZWF0ZShuZ1pvbmVJbmplY3Rvcik7XG4gICAgICAgICAgICAgICAgdmFyIGV4Y2VwdGlvbkhhbmRsZXIgPSBtb2R1bGVSZWYuaW5qZWN0b3IuZ2V0KEVycm9ySGFuZGxlciwgbnVsbCk7XG4gICAgICAgICAgICAgICAgaWYgKCFleGNlcHRpb25IYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gRXJyb3JIYW5kbGVyLiBJcyBwbGF0Zm9ybSBtb2R1bGUgKEJyb3dzZXJNb2R1bGUpIGluY2x1ZGVkPycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtb2R1bGVSZWYub25EZXN0cm95KGZ1bmN0aW9uICgpIHsgcmV0dXJuIExpc3RXcmFwcGVyLnJlbW92ZShfdGhpcy5fbW9kdWxlcywgbW9kdWxlUmVmKTsgfSk7XG4gICAgICAgICAgICAgICAgbmdab25lLm9uRXJyb3Iuc3Vic2NyaWJlKHsgbmV4dDogZnVuY3Rpb24gKGVycm9yKSB7IGV4Y2VwdGlvbkhhbmRsZXIuaGFuZGxlRXJyb3IoZXJyb3IpOyB9IH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBfY2FsbEFuZFJlcG9ydFRvRXJyb3JIYW5kbGVyKGV4Y2VwdGlvbkhhbmRsZXIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluaXRTdGF0dXMgPSBtb2R1bGVSZWYuaW5qZWN0b3IuZ2V0KEFwcGxpY2F0aW9uSW5pdFN0YXR1cyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpbml0U3RhdHVzLmRvbmVQcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX21vZHVsZURvQm9vdHN0cmFwKG1vZHVsZVJlZik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbW9kdWxlUmVmO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBQbGF0Zm9ybVJlZl8ucHJvdG90eXBlLmJvb3RzdHJhcE1vZHVsZSA9IGZ1bmN0aW9uIChtb2R1bGVUeXBlLCBjb21waWxlck9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmIChjb21waWxlck9wdGlvbnMgPT09IHZvaWQgMCkgeyBjb21waWxlck9wdGlvbnMgPSBbXTsgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Jvb3RzdHJhcE1vZHVsZVdpdGhab25lKG1vZHVsZVR5cGUsIGNvbXBpbGVyT3B0aW9ucywgbnVsbCk7XG4gICAgICAgIH07XG4gICAgICAgIFBsYXRmb3JtUmVmXy5wcm90b3R5cGUuX2Jvb3RzdHJhcE1vZHVsZVdpdGhab25lID0gZnVuY3Rpb24gKG1vZHVsZVR5cGUsIGNvbXBpbGVyT3B0aW9ucywgbmdab25lLCBjb21wb25lbnRGYWN0b3J5Q2FsbGJhY2spIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICBpZiAoY29tcGlsZXJPcHRpb25zID09PSB2b2lkIDApIHsgY29tcGlsZXJPcHRpb25zID0gW107IH1cbiAgICAgICAgICAgIHZhciBjb21waWxlckZhY3RvcnkgPSB0aGlzLmluamVjdG9yLmdldChDb21waWxlckZhY3RvcnkpO1xuICAgICAgICAgICAgdmFyIGNvbXBpbGVyID0gY29tcGlsZXJGYWN0b3J5LmNyZWF0ZUNvbXBpbGVyKEFycmF5LmlzQXJyYXkoY29tcGlsZXJPcHRpb25zKSA/IGNvbXBpbGVyT3B0aW9ucyA6IFtjb21waWxlck9wdGlvbnNdKTtcbiAgICAgICAgICAgIC8vIHVnbHkgaW50ZXJuYWwgYXBpIGhhY2s6IGdlbmVyYXRlIGhvc3QgY29tcG9uZW50IGZhY3RvcmllcyBmb3IgYWxsIGRlY2xhcmVkIGNvbXBvbmVudHMgYW5kXG4gICAgICAgICAgICAvLyBwYXNzIHRoZSBmYWN0b3JpZXMgaW50byB0aGUgY2FsbGJhY2sgLSB0aGlzIGlzIHVzZWQgYnkgVXBkYXRlQWRhcHRlciB0byBnZXQgaG9sZCBvZiBhbGxcbiAgICAgICAgICAgIC8vIGZhY3Rvcmllcy5cbiAgICAgICAgICAgIGlmIChjb21wb25lbnRGYWN0b3J5Q2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tcGlsZXIuY29tcGlsZU1vZHVsZUFuZEFsbENvbXBvbmVudHNBc3luYyhtb2R1bGVUeXBlKVxuICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5nTW9kdWxlRmFjdG9yeSA9IF9hLm5nTW9kdWxlRmFjdG9yeSwgY29tcG9uZW50RmFjdG9yaWVzID0gX2EuY29tcG9uZW50RmFjdG9yaWVzO1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRGYWN0b3J5Q2FsbGJhY2soY29tcG9uZW50RmFjdG9yaWVzKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9ib290c3RyYXBNb2R1bGVGYWN0b3J5V2l0aFpvbmUobmdNb2R1bGVGYWN0b3J5LCBuZ1pvbmUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvbXBpbGVyLmNvbXBpbGVNb2R1bGVBc3luYyhtb2R1bGVUeXBlKVxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChtb2R1bGVGYWN0b3J5KSB7IHJldHVybiBfdGhpcy5fYm9vdHN0cmFwTW9kdWxlRmFjdG9yeVdpdGhab25lKG1vZHVsZUZhY3RvcnksIG5nWm9uZSk7IH0pO1xuICAgICAgICB9O1xuICAgICAgICBQbGF0Zm9ybVJlZl8ucHJvdG90eXBlLl9tb2R1bGVEb0Jvb3RzdHJhcCA9IGZ1bmN0aW9uIChtb2R1bGVSZWYpIHtcbiAgICAgICAgICAgIHZhciBhcHBSZWYgPSBtb2R1bGVSZWYuaW5qZWN0b3IuZ2V0KEFwcGxpY2F0aW9uUmVmKTtcbiAgICAgICAgICAgIGlmIChtb2R1bGVSZWYuYm9vdHN0cmFwRmFjdG9yaWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBtb2R1bGVSZWYuYm9vdHN0cmFwRmFjdG9yaWVzLmZvckVhY2goZnVuY3Rpb24gKGNvbXBGYWN0b3J5KSB7IHJldHVybiBhcHBSZWYuYm9vdHN0cmFwKGNvbXBGYWN0b3J5KTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChtb2R1bGVSZWYuaW5zdGFuY2UubmdEb0Jvb3RzdHJhcCkge1xuICAgICAgICAgICAgICAgIG1vZHVsZVJlZi5pbnN0YW5jZS5uZ0RvQm9vdHN0cmFwKGFwcFJlZik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKFwiVGhlIG1vZHVsZSBcIiArIHN0cmluZ2lmeShtb2R1bGVSZWYuaW5zdGFuY2UuY29uc3RydWN0b3IpICsgXCIgd2FzIGJvb3RzdHJhcHBlZCwgYnV0IGl0IGRvZXMgbm90IGRlY2xhcmUgXFxcIkBOZ01vZHVsZS5ib290c3RyYXBcXFwiIGNvbXBvbmVudHMgbm9yIGEgXFxcIm5nRG9Cb290c3RyYXBcXFwiIG1ldGhvZC4gXCIpICtcbiAgICAgICAgICAgICAgICAgICAgXCJQbGVhc2UgZGVmaW5lIG9uZSBvZiB0aGVzZS5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIFBsYXRmb3JtUmVmXy5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBJbmplY3RhYmxlIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBQbGF0Zm9ybVJlZl8uY3RvclBhcmFtZXRlcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IEluamVjdG9yLCB9LFxuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gUGxhdGZvcm1SZWZfO1xuICAgIH0oUGxhdGZvcm1SZWYpKTtcbiAgICAvKipcbiAgICAgKiBBIHJlZmVyZW5jZSB0byBhbiBBbmd1bGFyIGFwcGxpY2F0aW9uIHJ1bm5pbmcgb24gYSBwYWdlLlxuICAgICAqXG4gICAgICogRm9yIG1vcmUgYWJvdXQgQW5ndWxhciBhcHBsaWNhdGlvbnMsIHNlZSB0aGUgZG9jdW1lbnRhdGlvbiBmb3Ige0BsaW5rIGJvb3RzdHJhcH0uXG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIEFwcGxpY2F0aW9uUmVmID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gQXBwbGljYXRpb25SZWYoKSB7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFwcGxpY2F0aW9uUmVmLnByb3RvdHlwZSwgXCJjb21wb25lbnRUeXBlc1wiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEdldCBhIGxpc3Qgb2YgY29tcG9uZW50IHR5cGVzIHJlZ2lzdGVyZWQgdG8gdGhpcyBhcHBsaWNhdGlvbi5cbiAgICAgICAgICAgICAqIFRoaXMgbGlzdCBpcyBwb3B1bGF0ZWQgZXZlbiBiZWZvcmUgdGhlIGNvbXBvbmVudCBpcyBjcmVhdGVkLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVuaW1wbGVtZW50ZWQoKTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIDtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFwcGxpY2F0aW9uUmVmLnByb3RvdHlwZSwgXCJjb21wb25lbnRzXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogR2V0IGEgbGlzdCBvZiBjb21wb25lbnRzIHJlZ2lzdGVyZWQgdG8gdGhpcyBhcHBsaWNhdGlvbi5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1bmltcGxlbWVudGVkKCk7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICA7XG4gICAgICAgIHJldHVybiBBcHBsaWNhdGlvblJlZjtcbiAgICB9KCkpO1xuICAgIHZhciBBcHBsaWNhdGlvblJlZl8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMkMyhBcHBsaWNhdGlvblJlZl8sIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIEFwcGxpY2F0aW9uUmVmXyhfem9uZSwgX2NvbnNvbGUsIF9pbmplY3RvciwgX2V4Y2VwdGlvbkhhbmRsZXIsIF9jb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIsIF9pbml0U3RhdHVzLCBfdGVzdGFiaWxpdHlSZWdpc3RyeSwgX3Rlc3RhYmlsaXR5KSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB0aGlzLl96b25lID0gX3pvbmU7XG4gICAgICAgICAgICB0aGlzLl9jb25zb2xlID0gX2NvbnNvbGU7XG4gICAgICAgICAgICB0aGlzLl9pbmplY3RvciA9IF9pbmplY3RvcjtcbiAgICAgICAgICAgIHRoaXMuX2V4Y2VwdGlvbkhhbmRsZXIgPSBfZXhjZXB0aW9uSGFuZGxlcjtcbiAgICAgICAgICAgIHRoaXMuX2NvbXBvbmVudEZhY3RvcnlSZXNvbHZlciA9IF9jb21wb25lbnRGYWN0b3J5UmVzb2x2ZXI7XG4gICAgICAgICAgICB0aGlzLl9pbml0U3RhdHVzID0gX2luaXRTdGF0dXM7XG4gICAgICAgICAgICB0aGlzLl90ZXN0YWJpbGl0eVJlZ2lzdHJ5ID0gX3Rlc3RhYmlsaXR5UmVnaXN0cnk7XG4gICAgICAgICAgICB0aGlzLl90ZXN0YWJpbGl0eSA9IF90ZXN0YWJpbGl0eTtcbiAgICAgICAgICAgIHRoaXMuX2Jvb3RzdHJhcExpc3RlbmVycyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fcm9vdENvbXBvbmVudHMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX3Jvb3RDb21wb25lbnRUeXBlcyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fY2hhbmdlRGV0ZWN0b3JSZWZzID0gW107XG4gICAgICAgICAgICB0aGlzLl9ydW5uaW5nVGljayA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5fZW5mb3JjZU5vTmV3Q2hhbmdlcyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5fZW5mb3JjZU5vTmV3Q2hhbmdlcyA9IGlzRGV2TW9kZSgpO1xuICAgICAgICAgICAgdGhpcy5fem9uZS5vbk1pY3JvdGFza0VtcHR5LnN1YnNjcmliZSh7IG5leHQ6IGZ1bmN0aW9uICgpIHsgX3RoaXMuX3pvbmUucnVuKGZ1bmN0aW9uICgpIHsgX3RoaXMudGljaygpOyB9KTsgfSB9KTtcbiAgICAgICAgfVxuICAgICAgICBBcHBsaWNhdGlvblJlZl8ucHJvdG90eXBlLnJlZ2lzdGVyQ2hhbmdlRGV0ZWN0b3IgPSBmdW5jdGlvbiAoY2hhbmdlRGV0ZWN0b3IpIHtcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZURldGVjdG9yUmVmcy5wdXNoKGNoYW5nZURldGVjdG9yKTtcbiAgICAgICAgfTtcbiAgICAgICAgQXBwbGljYXRpb25SZWZfLnByb3RvdHlwZS51bnJlZ2lzdGVyQ2hhbmdlRGV0ZWN0b3IgPSBmdW5jdGlvbiAoY2hhbmdlRGV0ZWN0b3IpIHtcbiAgICAgICAgICAgIExpc3RXcmFwcGVyLnJlbW92ZSh0aGlzLl9jaGFuZ2VEZXRlY3RvclJlZnMsIGNoYW5nZURldGVjdG9yKTtcbiAgICAgICAgfTtcbiAgICAgICAgQXBwbGljYXRpb25SZWZfLnByb3RvdHlwZS5ib290c3RyYXAgPSBmdW5jdGlvbiAoY29tcG9uZW50T3JGYWN0b3J5KSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9pbml0U3RhdHVzLmRvbmUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBib290c3RyYXAgYXMgdGhlcmUgYXJlIHN0aWxsIGFzeW5jaHJvbm91cyBpbml0aWFsaXplcnMgcnVubmluZy4gQm9vdHN0cmFwIGNvbXBvbmVudHMgaW4gdGhlIGBuZ0RvQm9vdHN0cmFwYCBtZXRob2Qgb2YgdGhlIHJvb3QgbW9kdWxlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGNvbXBvbmVudEZhY3Rvcnk7XG4gICAgICAgICAgICBpZiAoY29tcG9uZW50T3JGYWN0b3J5IGluc3RhbmNlb2YgQ29tcG9uZW50RmFjdG9yeSkge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudEZhY3RvcnkgPSBjb21wb25lbnRPckZhY3Rvcnk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb21wb25lbnRGYWN0b3J5ID0gdGhpcy5fY29tcG9uZW50RmFjdG9yeVJlc29sdmVyLnJlc29sdmVDb21wb25lbnRGYWN0b3J5KGNvbXBvbmVudE9yRmFjdG9yeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9yb290Q29tcG9uZW50VHlwZXMucHVzaChjb21wb25lbnRGYWN0b3J5LmNvbXBvbmVudFR5cGUpO1xuICAgICAgICAgICAgdmFyIGNvbXBSZWYgPSBjb21wb25lbnRGYWN0b3J5LmNyZWF0ZSh0aGlzLl9pbmplY3RvciwgW10sIGNvbXBvbmVudEZhY3Rvcnkuc2VsZWN0b3IpO1xuICAgICAgICAgICAgY29tcFJlZi5vbkRlc3Ryb3koZnVuY3Rpb24gKCkgeyBfdGhpcy5fdW5sb2FkQ29tcG9uZW50KGNvbXBSZWYpOyB9KTtcbiAgICAgICAgICAgIHZhciB0ZXN0YWJpbGl0eSA9IGNvbXBSZWYuaW5qZWN0b3IuZ2V0KFRlc3RhYmlsaXR5LCBudWxsKTtcbiAgICAgICAgICAgIGlmICh0ZXN0YWJpbGl0eSkge1xuICAgICAgICAgICAgICAgIGNvbXBSZWYuaW5qZWN0b3IuZ2V0KFRlc3RhYmlsaXR5UmVnaXN0cnkpXG4gICAgICAgICAgICAgICAgICAgIC5yZWdpc3RlckFwcGxpY2F0aW9uKGNvbXBSZWYubG9jYXRpb24ubmF0aXZlRWxlbWVudCwgdGVzdGFiaWxpdHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fbG9hZENvbXBvbmVudChjb21wUmVmKTtcbiAgICAgICAgICAgIGlmIChpc0Rldk1vZGUoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnNvbGUubG9nKFwiQW5ndWxhciAyIGlzIHJ1bm5pbmcgaW4gdGhlIGRldmVsb3BtZW50IG1vZGUuIENhbGwgZW5hYmxlUHJvZE1vZGUoKSB0byBlbmFibGUgdGhlIHByb2R1Y3Rpb24gbW9kZS5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY29tcFJlZjtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBBcHBsaWNhdGlvblJlZl8ucHJvdG90eXBlLl9sb2FkQ29tcG9uZW50ID0gZnVuY3Rpb24gKGNvbXBvbmVudFJlZikge1xuICAgICAgICAgICAgdGhpcy5fY2hhbmdlRGV0ZWN0b3JSZWZzLnB1c2goY29tcG9uZW50UmVmLmNoYW5nZURldGVjdG9yUmVmKTtcbiAgICAgICAgICAgIHRoaXMudGljaygpO1xuICAgICAgICAgICAgdGhpcy5fcm9vdENvbXBvbmVudHMucHVzaChjb21wb25lbnRSZWYpO1xuICAgICAgICAgICAgLy8gR2V0IHRoZSBsaXN0ZW5lcnMgbGF6aWx5IHRvIHByZXZlbnQgREkgY3ljbGVzLlxuICAgICAgICAgICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2luamVjdG9yLmdldChBUFBfQk9PVFNUUkFQX0xJU1RFTkVSLCBbXSlcbiAgICAgICAgICAgICAgICAuY29uY2F0KHRoaXMuX2Jvb3RzdHJhcExpc3RlbmVycyk7XG4gICAgICAgICAgICBsaXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbiAobGlzdGVuZXIpIHsgcmV0dXJuIGxpc3RlbmVyKGNvbXBvbmVudFJlZik7IH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIEFwcGxpY2F0aW9uUmVmXy5wcm90b3R5cGUuX3VubG9hZENvbXBvbmVudCA9IGZ1bmN0aW9uIChjb21wb25lbnRSZWYpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9yb290Q29tcG9uZW50cy5pbmRleE9mKGNvbXBvbmVudFJlZikgPT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnVucmVnaXN0ZXJDaGFuZ2VEZXRlY3Rvcihjb21wb25lbnRSZWYuY2hhbmdlRGV0ZWN0b3JSZWYpO1xuICAgICAgICAgICAgTGlzdFdyYXBwZXIucmVtb3ZlKHRoaXMuX3Jvb3RDb21wb25lbnRzLCBjb21wb25lbnRSZWYpO1xuICAgICAgICB9O1xuICAgICAgICBBcHBsaWNhdGlvblJlZl8ucHJvdG90eXBlLnRpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcnVubmluZ1RpY2spIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FwcGxpY2F0aW9uUmVmLnRpY2sgaXMgY2FsbGVkIHJlY3Vyc2l2ZWx5Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc2NvcGUgPSBBcHBsaWNhdGlvblJlZl8uX3RpY2tTY29wZSgpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9ydW5uaW5nVGljayA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2hhbmdlRGV0ZWN0b3JSZWZzLmZvckVhY2goZnVuY3Rpb24gKGRldGVjdG9yKSB7IHJldHVybiBkZXRlY3Rvci5kZXRlY3RDaGFuZ2VzKCk7IH0pO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9lbmZvcmNlTm9OZXdDaGFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NoYW5nZURldGVjdG9yUmVmcy5mb3JFYWNoKGZ1bmN0aW9uIChkZXRlY3RvcikgeyByZXR1cm4gZGV0ZWN0b3IuY2hlY2tOb0NoYW5nZXMoKTsgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcnVubmluZ1RpY2sgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB3dGZMZWF2ZShzY29wZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIEFwcGxpY2F0aW9uUmVmXy5wcm90b3R5cGUubmdPbkRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBUT0RPKGFseGh1Yik6IERpc3Bvc2Ugb2YgdGhlIE5nWm9uZS5cbiAgICAgICAgICAgIHRoaXMuX3Jvb3RDb21wb25lbnRzLnNsaWNlKCkuZm9yRWFjaChmdW5jdGlvbiAoY29tcG9uZW50KSB7IHJldHVybiBjb21wb25lbnQuZGVzdHJveSgpOyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFwcGxpY2F0aW9uUmVmXy5wcm90b3R5cGUsIFwiY29tcG9uZW50VHlwZXNcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9yb290Q29tcG9uZW50VHlwZXM7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQXBwbGljYXRpb25SZWZfLnByb3RvdHlwZSwgXCJjb21wb25lbnRzXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcm9vdENvbXBvbmVudHM7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIEFwcGxpY2F0aW9uUmVmXy5fdGlja1Njb3BlID0gd3RmQ3JlYXRlU2NvcGUoJ0FwcGxpY2F0aW9uUmVmI3RpY2soKScpO1xuICAgICAgICBBcHBsaWNhdGlvblJlZl8uZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogSW5qZWN0YWJsZSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgQXBwbGljYXRpb25SZWZfLmN0b3JQYXJhbWV0ZXJzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBOZ1pvbmUsIH0sXG4gICAgICAgICAgICB7IHR5cGU6IENvbnNvbGUsIH0sXG4gICAgICAgICAgICB7IHR5cGU6IEluamVjdG9yLCB9LFxuICAgICAgICAgICAgeyB0eXBlOiBFcnJvckhhbmRsZXIsIH0sXG4gICAgICAgICAgICB7IHR5cGU6IENvbXBvbmVudEZhY3RvcnlSZXNvbHZlciwgfSxcbiAgICAgICAgICAgIHsgdHlwZTogQXBwbGljYXRpb25Jbml0U3RhdHVzLCB9LFxuICAgICAgICAgICAgeyB0eXBlOiBUZXN0YWJpbGl0eVJlZ2lzdHJ5LCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LF0gfSxcbiAgICAgICAgICAgIHsgdHlwZTogVGVzdGFiaWxpdHksIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gQXBwbGljYXRpb25SZWZfO1xuICAgIH0oQXBwbGljYXRpb25SZWYpKTtcblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICB2YXIgX19leHRlbmRzJDkgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXByZXNlbnRzIGFuIGluc3RhbmNlIG9mIGFuIE5nTW9kdWxlIGNyZWF0ZWQgdmlhIGEge0BsaW5rIE5nTW9kdWxlRmFjdG9yeX0uXG4gICAgICpcbiAgICAgKiBgTmdNb2R1bGVSZWZgIHByb3ZpZGVzIGFjY2VzcyB0byB0aGUgTmdNb2R1bGUgSW5zdGFuY2UgYXMgd2VsbCBvdGhlciBvYmplY3RzIHJlbGF0ZWQgdG8gdGhpc1xuICAgICAqIE5nTW9kdWxlIEluc3RhbmNlLlxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBOZ01vZHVsZVJlZiA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIE5nTW9kdWxlUmVmKCkge1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ01vZHVsZVJlZi5wcm90b3R5cGUsIFwiaW5qZWN0b3JcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGUgaW5qZWN0b3IgdGhhdCBjb250YWlucyBhbGwgb2YgdGhlIHByb3ZpZGVycyBvZiB0aGUgTmdNb2R1bGUuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdW5pbXBsZW1lbnRlZCgpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nTW9kdWxlUmVmLnByb3RvdHlwZSwgXCJjb21wb25lbnRGYWN0b3J5UmVzb2x2ZXJcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGUgQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyIHRvIGdldCBob2xkIG9mIHRoZSBDb21wb25lbnRGYWN0b3JpZXNcbiAgICAgICAgICAgICAqIGRlY2xhcmVkIGluIHRoZSBgZW50cnlDb21wb25lbnRzYCBwcm9wZXJ0eSBvZiB0aGUgbW9kdWxlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVuaW1wbGVtZW50ZWQoKTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ01vZHVsZVJlZi5wcm90b3R5cGUsIFwiaW5zdGFuY2VcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGUgTmdNb2R1bGUgaW5zdGFuY2UuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdW5pbXBsZW1lbnRlZCgpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIE5nTW9kdWxlUmVmO1xuICAgIH0oKSk7XG4gICAgLyoqXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIHZhciBOZ01vZHVsZUZhY3RvcnkgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBOZ01vZHVsZUZhY3RvcnkoX2luamVjdG9yQ2xhc3MsIF9tb2R1bGVUeXBlKSB7XG4gICAgICAgICAgICB0aGlzLl9pbmplY3RvckNsYXNzID0gX2luamVjdG9yQ2xhc3M7XG4gICAgICAgICAgICB0aGlzLl9tb2R1bGVUeXBlID0gX21vZHVsZVR5cGU7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nTW9kdWxlRmFjdG9yeS5wcm90b3R5cGUsIFwibW9kdWxlVHlwZVwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX21vZHVsZVR5cGU7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBOZ01vZHVsZUZhY3RvcnkucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uIChwYXJlbnRJbmplY3Rvcikge1xuICAgICAgICAgICAgaWYgKCFwYXJlbnRJbmplY3Rvcikge1xuICAgICAgICAgICAgICAgIHBhcmVudEluamVjdG9yID0gSW5qZWN0b3IuTlVMTDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IG5ldyB0aGlzLl9pbmplY3RvckNsYXNzKHBhcmVudEluamVjdG9yKTtcbiAgICAgICAgICAgIGluc3RhbmNlLmNyZWF0ZSgpO1xuICAgICAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gTmdNb2R1bGVGYWN0b3J5O1xuICAgIH0oKSk7XG4gICAgdmFyIF9VTkRFRklORUQgPSBuZXcgT2JqZWN0KCk7XG4gICAgdmFyIE5nTW9kdWxlSW5qZWN0b3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMkOShOZ01vZHVsZUluamVjdG9yLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBOZ01vZHVsZUluamVjdG9yKHBhcmVudCwgZmFjdG9yaWVzLCBib290c3RyYXBGYWN0b3JpZXMpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGZhY3RvcmllcywgcGFyZW50LmdldChDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIsIENvbXBvbmVudEZhY3RvcnlSZXNvbHZlci5OVUxMKSk7XG4gICAgICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgICAgIHRoaXMuYm9vdHN0cmFwRmFjdG9yaWVzID0gYm9vdHN0cmFwRmFjdG9yaWVzO1xuICAgICAgICAgICAgdGhpcy5fZGVzdHJveUxpc3RlbmVycyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fZGVzdHJveWVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgTmdNb2R1bGVJbmplY3Rvci5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gKCkgeyB0aGlzLmluc3RhbmNlID0gdGhpcy5jcmVhdGVJbnRlcm5hbCgpOyB9O1xuICAgICAgICBOZ01vZHVsZUluamVjdG9yLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAodG9rZW4sIG5vdEZvdW5kVmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChub3RGb3VuZFZhbHVlID09PSB2b2lkIDApIHsgbm90Rm91bmRWYWx1ZSA9IFRIUk9XX0lGX05PVF9GT1VORDsgfVxuICAgICAgICAgICAgaWYgKHRva2VuID09PSBJbmplY3RvciB8fCB0b2tlbiA9PT0gQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5nZXRJbnRlcm5hbCh0b2tlbiwgX1VOREVGSU5FRCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0ID09PSBfVU5ERUZJTkVEID8gdGhpcy5wYXJlbnQuZ2V0KHRva2VuLCBub3RGb3VuZFZhbHVlKSA6IHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nTW9kdWxlSW5qZWN0b3IucHJvdG90eXBlLCBcImluamVjdG9yXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ01vZHVsZUluamVjdG9yLnByb3RvdHlwZSwgXCJjb21wb25lbnRGYWN0b3J5UmVzb2x2ZXJcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgTmdNb2R1bGVJbmplY3Rvci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgbmcgbW9kdWxlIFwiICsgc3RyaW5naWZ5KHRoaXMuaW5zdGFuY2UuY29uc3RydWN0b3IpICsgXCIgaGFzIGFscmVhZHkgYmVlbiBkZXN0cm95ZWQuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fZGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZGVzdHJveUludGVybmFsKCk7XG4gICAgICAgICAgICB0aGlzLl9kZXN0cm95TGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24gKGxpc3RlbmVyKSB7IHJldHVybiBsaXN0ZW5lcigpOyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgTmdNb2R1bGVJbmplY3Rvci5wcm90b3R5cGUub25EZXN0cm95ID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7IHRoaXMuX2Rlc3Ryb3lMaXN0ZW5lcnMucHVzaChjYWxsYmFjayk7IH07XG4gICAgICAgIHJldHVybiBOZ01vZHVsZUluamVjdG9yO1xuICAgIH0oQ29kZWdlbkNvbXBvbmVudEZhY3RvcnlSZXNvbHZlcikpO1xuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gbG9hZCBuZyBtb2R1bGUgZmFjdG9yaWVzLlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgTmdNb2R1bGVGYWN0b3J5TG9hZGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gTmdNb2R1bGVGYWN0b3J5TG9hZGVyKCkge1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBOZ01vZHVsZUZhY3RvcnlMb2FkZXI7XG4gICAgfSgpKTtcbiAgICB2YXIgbW9kdWxlRmFjdG9yaWVzID0gbmV3IE1hcCgpO1xuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBhIGxvYWRlZCBtb2R1bGUuIFNob3VsZCBvbmx5IGJlIGNhbGxlZCBmcm9tIGdlbmVyYXRlZCBOZ01vZHVsZUZhY3RvcnkgY29kZS5cbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVnaXN0ZXJNb2R1bGVGYWN0b3J5KGlkLCBmYWN0b3J5KSB7XG4gICAgICAgIHZhciBleGlzdGluZyA9IG1vZHVsZUZhY3Rvcmllcy5nZXQoaWQpO1xuICAgICAgICBpZiAoZXhpc3RpbmcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkR1cGxpY2F0ZSBtb2R1bGUgcmVnaXN0ZXJlZCBmb3IgXCIgKyBpZCArIFwiIC0gXCIgKyBleGlzdGluZy5tb2R1bGVUeXBlLm5hbWUgKyBcIiB2cyBcIiArIGZhY3RvcnkubW9kdWxlVHlwZS5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBtb2R1bGVGYWN0b3JpZXMuc2V0KGlkLCBmYWN0b3J5KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgTmdNb2R1bGVGYWN0b3J5IHdpdGggdGhlIGdpdmVuIGlkLCBpZiBpdCBleGlzdHMgYW5kIGhhcyBiZWVuIGxvYWRlZC5cbiAgICAgKiBGYWN0b3JpZXMgZm9yIG1vZHVsZXMgdGhhdCBkbyBub3Qgc3BlY2lmeSBhbiBgaWRgIGNhbm5vdCBiZSByZXRyaWV2ZWQuIFRocm93cyBpZiB0aGUgbW9kdWxlXG4gICAgICogY2Fubm90IGJlIGZvdW5kLlxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRNb2R1bGVGYWN0b3J5KGlkKSB7XG4gICAgICAgIHZhciBmYWN0b3J5ID0gbW9kdWxlRmFjdG9yaWVzLmdldChpZCk7XG4gICAgICAgIGlmICghZmFjdG9yeSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIG1vZHVsZSB3aXRoIElEIFwiICsgaWQgKyBcIiBsb2FkZWRcIik7XG4gICAgICAgIHJldHVybiBmYWN0b3J5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFuIHVubW9kaWZpYWJsZSBsaXN0IG9mIGl0ZW1zIHRoYXQgQW5ndWxhciBrZWVwcyB1cCB0byBkYXRlIHdoZW4gdGhlIHN0YXRlXG4gICAgICogb2YgdGhlIGFwcGxpY2F0aW9uIGNoYW5nZXMuXG4gICAgICpcbiAgICAgKiBUaGUgdHlwZSBvZiBvYmplY3QgdGhhdCB7QGxpbmsgUXVlcnl9IGFuZCB7QGxpbmsgVmlld1F1ZXJ5TWV0YWRhdGF9IHByb3ZpZGUuXG4gICAgICpcbiAgICAgKiBJbXBsZW1lbnRzIGFuIGl0ZXJhYmxlIGludGVyZmFjZSwgdGhlcmVmb3JlIGl0IGNhbiBiZSB1c2VkIGluIGJvdGggRVM2XG4gICAgICogamF2YXNjcmlwdCBgZm9yICh2YXIgaSBvZiBpdGVtcylgIGxvb3BzIGFzIHdlbGwgYXMgaW4gQW5ndWxhciB0ZW1wbGF0ZXMgd2l0aFxuICAgICAqIGAqbmdGb3I9XCJsZXQgaSBvZiBteUxpc3RcImAuXG4gICAgICpcbiAgICAgKiBDaGFuZ2VzIGNhbiBiZSBvYnNlcnZlZCBieSBzdWJzY3JpYmluZyB0byB0aGUgY2hhbmdlcyBgT2JzZXJ2YWJsZWAuXG4gICAgICpcbiAgICAgKiBOT1RFOiBJbiB0aGUgZnV0dXJlIHRoaXMgY2xhc3Mgd2lsbCBpbXBsZW1lbnQgYW4gYE9ic2VydmFibGVgIGludGVyZmFjZS5cbiAgICAgKlxuICAgICAqICMjIyBFeGFtcGxlIChbbGl2ZSBkZW1vXShodHRwOi8vcGxua3IuY28vZWRpdC9SWDhzSm5RWWw5Rld1U0NXbWU1ej9wPXByZXZpZXcpKVxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBAQ29tcG9uZW50KHsuLi59KVxuICAgICAqIGNsYXNzIENvbnRhaW5lciB7XG4gICAgICogICBAVmlld0NoaWxkcmVuKEl0ZW0pIGl0ZW1zOlF1ZXJ5TGlzdDxJdGVtPjtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBRdWVyeUxpc3QgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBRdWVyeUxpc3QoKSB7XG4gICAgICAgICAgICB0aGlzLl9kaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9yZXN1bHRzID0gW107XG4gICAgICAgICAgICB0aGlzLl9lbWl0dGVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShRdWVyeUxpc3QucHJvdG90eXBlLCBcImNoYW5nZXNcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9lbWl0dGVyOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFF1ZXJ5TGlzdC5wcm90b3R5cGUsIFwibGVuZ3RoXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcmVzdWx0cy5sZW5ndGg7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUXVlcnlMaXN0LnByb3RvdHlwZSwgXCJmaXJzdFwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3Jlc3VsdHNbMF07IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUXVlcnlMaXN0LnByb3RvdHlwZSwgXCJsYXN0XCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcmVzdWx0c1t0aGlzLmxlbmd0aCAtIDFdOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNlZVxuICAgICAgICAgKiBbQXJyYXkubWFwXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9tYXApXG4gICAgICAgICAqL1xuICAgICAgICBRdWVyeUxpc3QucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uIChmbikgeyByZXR1cm4gdGhpcy5fcmVzdWx0cy5tYXAoZm4pOyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2VlXG4gICAgICAgICAqIFtBcnJheS5maWx0ZXJdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2ZpbHRlcilcbiAgICAgICAgICovXG4gICAgICAgIFF1ZXJ5TGlzdC5wcm90b3R5cGUuZmlsdGVyID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVzdWx0cy5maWx0ZXIoZm4pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2VlXG4gICAgICAgICAqIFtBcnJheS5yZWR1Y2VdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L3JlZHVjZSlcbiAgICAgICAgICovXG4gICAgICAgIFF1ZXJ5TGlzdC5wcm90b3R5cGUucmVkdWNlID0gZnVuY3Rpb24gKGZuLCBpbml0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVzdWx0cy5yZWR1Y2UoZm4sIGluaXQpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2VlXG4gICAgICAgICAqIFtBcnJheS5mb3JFYWNoXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9mb3JFYWNoKVxuICAgICAgICAgKi9cbiAgICAgICAgUXVlcnlMaXN0LnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKGZuKSB7IHRoaXMuX3Jlc3VsdHMuZm9yRWFjaChmbik7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZWVcbiAgICAgICAgICogW0FycmF5LnNvbWVdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L3NvbWUpXG4gICAgICAgICAqL1xuICAgICAgICBRdWVyeUxpc3QucHJvdG90eXBlLnNvbWUgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXN1bHRzLnNvbWUoZm4pO1xuICAgICAgICB9O1xuICAgICAgICBRdWVyeUxpc3QucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9yZXN1bHRzLnNsaWNlKCk7IH07XG4gICAgICAgIFF1ZXJ5TGlzdC5wcm90b3R5cGVbZ2V0U3ltYm9sSXRlcmF0b3IoKV0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9yZXN1bHRzW2dldFN5bWJvbEl0ZXJhdG9yKCldKCk7IH07XG4gICAgICAgIFF1ZXJ5TGlzdC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9yZXN1bHRzLnRvU3RyaW5nKCk7IH07XG4gICAgICAgIFF1ZXJ5TGlzdC5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAocmVzKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXN1bHRzID0gTGlzdFdyYXBwZXIuZmxhdHRlbihyZXMpO1xuICAgICAgICAgICAgdGhpcy5fZGlydHkgPSBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgICAgUXVlcnlMaXN0LnByb3RvdHlwZS5ub3RpZnlPbkNoYW5nZXMgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX2VtaXR0ZXIuZW1pdCh0aGlzKTsgfTtcbiAgICAgICAgLyoqIGludGVybmFsICovXG4gICAgICAgIFF1ZXJ5TGlzdC5wcm90b3R5cGUuc2V0RGlydHkgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX2RpcnR5ID0gdHJ1ZTsgfTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFF1ZXJ5TGlzdC5wcm90b3R5cGUsIFwiZGlydHlcIiwge1xuICAgICAgICAgICAgLyoqIGludGVybmFsICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2RpcnR5OyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFF1ZXJ5TGlzdDtcbiAgICB9KCkpO1xuXG4gICAgdmFyIF9TRVBBUkFUT1IgPSAnIyc7XG4gICAgdmFyIEZBQ1RPUllfQ0xBU1NfU1VGRklYID0gJ05nRmFjdG9yeSc7XG4gICAgLyoqXG4gICAgICogQ29uZmlndXJhdGlvbiBmb3IgU3lzdGVtSnNOZ01vZHVsZUxvYWRlci5cbiAgICAgKiB0b2tlbi5cbiAgICAgKlxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICB2YXIgU3lzdGVtSnNOZ01vZHVsZUxvYWRlckNvbmZpZyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFN5c3RlbUpzTmdNb2R1bGVMb2FkZXJDb25maWcoKSB7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFN5c3RlbUpzTmdNb2R1bGVMb2FkZXJDb25maWc7XG4gICAgfSgpKTtcbiAgICB2YXIgREVGQVVMVF9DT05GSUcgPSB7XG4gICAgICAgIGZhY3RvcnlQYXRoUHJlZml4OiAnJyxcbiAgICAgICAgZmFjdG9yeVBhdGhTdWZmaXg6ICcubmdmYWN0b3J5JyxcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE5nTW9kdWxlRmFjdG9yeUxvYWRlciB0aGF0IHVzZXMgU3lzdGVtSlMgdG8gbG9hZCBOZ01vZHVsZUZhY3RvcnlcbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgdmFyIFN5c3RlbUpzTmdNb2R1bGVMb2FkZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBTeXN0ZW1Kc05nTW9kdWxlTG9hZGVyKF9jb21waWxlciwgY29uZmlnKSB7XG4gICAgICAgICAgICB0aGlzLl9jb21waWxlciA9IF9jb21waWxlcjtcbiAgICAgICAgICAgIHRoaXMuX2NvbmZpZyA9IGNvbmZpZyB8fCBERUZBVUxUX0NPTkZJRztcbiAgICAgICAgfVxuICAgICAgICBTeXN0ZW1Kc05nTW9kdWxlTG9hZGVyLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgICAgICAgIHZhciBvZmZsaW5lTW9kZSA9IHRoaXMuX2NvbXBpbGVyIGluc3RhbmNlb2YgQ29tcGlsZXI7XG4gICAgICAgICAgICByZXR1cm4gb2ZmbGluZU1vZGUgPyB0aGlzLmxvYWRGYWN0b3J5KHBhdGgpIDogdGhpcy5sb2FkQW5kQ29tcGlsZShwYXRoKTtcbiAgICAgICAgfTtcbiAgICAgICAgU3lzdGVtSnNOZ01vZHVsZUxvYWRlci5wcm90b3R5cGUubG9hZEFuZENvbXBpbGUgPSBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHZhciBfYSA9IHBhdGguc3BsaXQoX1NFUEFSQVRPUiksIG1vZHVsZSA9IF9hWzBdLCBleHBvcnROYW1lID0gX2FbMV07XG4gICAgICAgICAgICBpZiAoZXhwb3J0TmFtZSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIGV4cG9ydE5hbWUgPSAnZGVmYXVsdCc7XG4gICAgICAgICAgICByZXR1cm4gU3lzdGVtLmltcG9ydChtb2R1bGUpXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKG1vZHVsZSkgeyByZXR1cm4gbW9kdWxlW2V4cG9ydE5hbWVdOyB9KVxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICh0eXBlKSB7IHJldHVybiBjaGVja05vdEVtcHR5KHR5cGUsIG1vZHVsZSwgZXhwb3J0TmFtZSk7IH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHR5cGUpIHsgcmV0dXJuIF90aGlzLl9jb21waWxlci5jb21waWxlTW9kdWxlQXN5bmModHlwZSk7IH0pO1xuICAgICAgICB9O1xuICAgICAgICBTeXN0ZW1Kc05nTW9kdWxlTG9hZGVyLnByb3RvdHlwZS5sb2FkRmFjdG9yeSA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSBwYXRoLnNwbGl0KF9TRVBBUkFUT1IpLCBtb2R1bGUgPSBfYVswXSwgZXhwb3J0TmFtZSA9IF9hWzFdO1xuICAgICAgICAgICAgdmFyIGZhY3RvcnlDbGFzc1N1ZmZpeCA9IEZBQ1RPUllfQ0xBU1NfU1VGRklYO1xuICAgICAgICAgICAgaWYgKGV4cG9ydE5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGV4cG9ydE5hbWUgPSAnZGVmYXVsdCc7XG4gICAgICAgICAgICAgICAgZmFjdG9yeUNsYXNzU3VmZml4ID0gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gU3lzdGVtLmltcG9ydCh0aGlzLl9jb25maWcuZmFjdG9yeVBhdGhQcmVmaXggKyBtb2R1bGUgKyB0aGlzLl9jb25maWcuZmFjdG9yeVBhdGhTdWZmaXgpXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKG1vZHVsZSkgeyByZXR1cm4gbW9kdWxlW2V4cG9ydE5hbWUgKyBmYWN0b3J5Q2xhc3NTdWZmaXhdOyB9KVxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChmYWN0b3J5KSB7IHJldHVybiBjaGVja05vdEVtcHR5KGZhY3RvcnksIG1vZHVsZSwgZXhwb3J0TmFtZSk7IH0pO1xuICAgICAgICB9O1xuICAgICAgICBTeXN0ZW1Kc05nTW9kdWxlTG9hZGVyLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IEluamVjdGFibGUgfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIFN5c3RlbUpzTmdNb2R1bGVMb2FkZXIuY3RvclBhcmFtZXRlcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IENvbXBpbGVyLCB9LFxuICAgICAgICAgICAgeyB0eXBlOiBTeXN0ZW1Kc05nTW9kdWxlTG9hZGVyQ29uZmlnLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIFN5c3RlbUpzTmdNb2R1bGVMb2FkZXI7XG4gICAgfSgpKTtcbiAgICBmdW5jdGlvbiBjaGVja05vdEVtcHR5KHZhbHVlLCBtb2R1bGVQYXRoLCBleHBvcnROYW1lKSB7XG4gICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kICdcIiArIGV4cG9ydE5hbWUgKyBcIicgaW4gJ1wiICsgbW9kdWxlUGF0aCArIFwiJ1wiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIHZhciBfX2V4dGVuZHMkMTAgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXByZXNlbnRzIGFuIEVtYmVkZGVkIFRlbXBsYXRlIHRoYXQgY2FuIGJlIHVzZWQgdG8gaW5zdGFudGlhdGUgRW1iZWRkZWQgVmlld3MuXG4gICAgICpcbiAgICAgKiBZb3UgY2FuIGFjY2VzcyBhIGBUZW1wbGF0ZVJlZmAsIGluIHR3byB3YXlzLiBWaWEgYSBkaXJlY3RpdmUgcGxhY2VkIG9uIGEgYDx0ZW1wbGF0ZT5gIGVsZW1lbnQgKG9yXG4gICAgICogZGlyZWN0aXZlIHByZWZpeGVkIHdpdGggYCpgKSBhbmQgaGF2ZSB0aGUgYFRlbXBsYXRlUmVmYCBmb3IgdGhpcyBFbWJlZGRlZCBWaWV3IGluamVjdGVkIGludG8gdGhlXG4gICAgICogY29uc3RydWN0b3Igb2YgdGhlIGRpcmVjdGl2ZSB1c2luZyB0aGUgYFRlbXBsYXRlUmVmYCBUb2tlbi4gQWx0ZXJuYXRpdmVseSB5b3UgY2FuIHF1ZXJ5IGZvciB0aGVcbiAgICAgKiBgVGVtcGxhdGVSZWZgIGZyb20gYSBDb21wb25lbnQgb3IgYSBEaXJlY3RpdmUgdmlhIHtAbGluayBRdWVyeX0uXG4gICAgICpcbiAgICAgKiBUbyBpbnN0YW50aWF0ZSBFbWJlZGRlZCBWaWV3cyBiYXNlZCBvbiBhIFRlbXBsYXRlLCB1c2VcbiAgICAgKiB7QGxpbmsgVmlld0NvbnRhaW5lclJlZiNjcmVhdGVFbWJlZGRlZFZpZXd9LCB3aGljaCB3aWxsIGNyZWF0ZSB0aGUgVmlldyBhbmQgYXR0YWNoIGl0IHRvIHRoZVxuICAgICAqIFZpZXcgQ29udGFpbmVyLlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgVGVtcGxhdGVSZWYgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBUZW1wbGF0ZVJlZigpIHtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGVtcGxhdGVSZWYucHJvdG90eXBlLCBcImVsZW1lbnRSZWZcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGUgbG9jYXRpb24gaW4gdGhlIFZpZXcgd2hlcmUgdGhlIEVtYmVkZGVkIFZpZXcgbG9naWNhbGx5IGJlbG9uZ3MgdG8uXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogVGhlIGRhdGEtYmluZGluZyBhbmQgaW5qZWN0aW9uIGNvbnRleHRzIG9mIEVtYmVkZGVkIFZpZXdzIGNyZWF0ZWQgZnJvbSB0aGlzIGBUZW1wbGF0ZVJlZmBcbiAgICAgICAgICAgICAqIGluaGVyaXQgZnJvbSB0aGUgY29udGV4dHMgb2YgdGhpcyBsb2NhdGlvbi5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBUeXBpY2FsbHkgbmV3IEVtYmVkZGVkIFZpZXdzIGFyZSBhdHRhY2hlZCB0byB0aGUgVmlldyBDb250YWluZXIgb2YgdGhpcyBsb2NhdGlvbiwgYnV0IGluXG4gICAgICAgICAgICAgKiBhZHZhbmNlZCB1c2UtY2FzZXMsIHRoZSBWaWV3IGNhbiBiZSBhdHRhY2hlZCB0byBhIGRpZmZlcmVudCBjb250YWluZXIgd2hpbGUga2VlcGluZyB0aGVcbiAgICAgICAgICAgICAqIGRhdGEtYmluZGluZyBhbmQgaW5qZWN0aW9uIGNvbnRleHQgZnJvbSB0aGUgb3JpZ2luYWwgbG9jYXRpb24uXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAvLyBUT0RPKGkpOiByZW5hbWUgdG8gYW5jaG9yIG9yIGxvY2F0aW9uXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gVGVtcGxhdGVSZWY7XG4gICAgfSgpKTtcbiAgICB2YXIgVGVtcGxhdGVSZWZfID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDEwKFRlbXBsYXRlUmVmXywgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gVGVtcGxhdGVSZWZfKF9hcHBFbGVtZW50LCBfdmlld0ZhY3RvcnkpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5fYXBwRWxlbWVudCA9IF9hcHBFbGVtZW50O1xuICAgICAgICAgICAgdGhpcy5fdmlld0ZhY3RvcnkgPSBfdmlld0ZhY3Rvcnk7XG4gICAgICAgIH1cbiAgICAgICAgVGVtcGxhdGVSZWZfLnByb3RvdHlwZS5jcmVhdGVFbWJlZGRlZFZpZXcgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICAgICAgdmFyIHZpZXcgPSB0aGlzLl92aWV3RmFjdG9yeSh0aGlzLl9hcHBFbGVtZW50LnBhcmVudFZpZXcudmlld1V0aWxzLCB0aGlzLl9hcHBFbGVtZW50LnBhcmVudEluamVjdG9yLCB0aGlzLl9hcHBFbGVtZW50KTtcbiAgICAgICAgICAgIHZpZXcuY3JlYXRlKGNvbnRleHQgfHwge30sIG51bGwsIG51bGwpO1xuICAgICAgICAgICAgcmV0dXJuIHZpZXcucmVmO1xuICAgICAgICB9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGVtcGxhdGVSZWZfLnByb3RvdHlwZSwgXCJlbGVtZW50UmVmXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fYXBwRWxlbWVudC5lbGVtZW50UmVmOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFRlbXBsYXRlUmVmXztcbiAgICB9KFRlbXBsYXRlUmVmKSk7XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgdmFyIF9xdWV1ZWRBbmltYXRpb25zID0gW107XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIGZ1bmN0aW9uIHF1ZXVlQW5pbWF0aW9uR2xvYmFsbHkocGxheWVyKSB7XG4gICAgICAgIF9xdWV1ZWRBbmltYXRpb25zLnB1c2gocGxheWVyKTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIGZ1bmN0aW9uIHRyaWdnZXJRdWV1ZWRBbmltYXRpb25zKCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IF9xdWV1ZWRBbmltYXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcGxheWVyID0gX3F1ZXVlZEFuaW1hdGlvbnNbaV07XG4gICAgICAgICAgICBwbGF5ZXIucGxheSgpO1xuICAgICAgICB9XG4gICAgICAgIF9xdWV1ZWRBbmltYXRpb25zID0gW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIHZhciBfX2V4dGVuZHMkMTEgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIFZpZXdSZWYgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBWaWV3UmVmKCkge1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWaWV3UmVmLnByb3RvdHlwZSwgXCJkZXN0cm95ZWRcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1bmltcGxlbWVudGVkKCk7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gVmlld1JlZjtcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgYW4gQW5ndWxhciBWaWV3LlxuICAgICAqXG4gICAgICogPCEtLSBUT0RPOiBtb3ZlIHRoZSBuZXh0IHR3byBwYXJhZ3JhcGhzIHRvIHRoZSBkZXYgZ3VpZGUgLS0+XG4gICAgICogQSBWaWV3IGlzIGEgZnVuZGFtZW50YWwgYnVpbGRpbmcgYmxvY2sgb2YgdGhlIGFwcGxpY2F0aW9uIFVJLiBJdCBpcyB0aGUgc21hbGxlc3QgZ3JvdXBpbmcgb2ZcbiAgICAgKiBFbGVtZW50cyB3aGljaCBhcmUgY3JlYXRlZCBhbmQgZGVzdHJveWVkIHRvZ2V0aGVyLlxuICAgICAqXG4gICAgICogUHJvcGVydGllcyBvZiBlbGVtZW50cyBpbiBhIFZpZXcgY2FuIGNoYW5nZSwgYnV0IHRoZSBzdHJ1Y3R1cmUgKG51bWJlciBhbmQgb3JkZXIpIG9mIGVsZW1lbnRzIGluXG4gICAgICogYSBWaWV3IGNhbm5vdC4gQ2hhbmdpbmcgdGhlIHN0cnVjdHVyZSBvZiBFbGVtZW50cyBjYW4gb25seSBiZSBkb25lIGJ5IGluc2VydGluZywgbW92aW5nIG9yXG4gICAgICogcmVtb3ZpbmcgbmVzdGVkIFZpZXdzIHZpYSBhIHtAbGluayBWaWV3Q29udGFpbmVyUmVmfS4gRWFjaCBWaWV3IGNhbiBjb250YWluIG1hbnkgVmlldyBDb250YWluZXJzLlxuICAgICAqIDwhLS0gL1RPRE8gLS0+XG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZVxuICAgICAqXG4gICAgICogR2l2ZW4gdGhpcyB0ZW1wbGF0ZS4uLlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogQ291bnQ6IHt7aXRlbXMubGVuZ3RofX1cbiAgICAgKiA8dWw+XG4gICAgICogICA8bGkgKm5nRm9yPVwibGV0ICBpdGVtIG9mIGl0ZW1zXCI+e3tpdGVtfX08L2xpPlxuICAgICAqIDwvdWw+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBXZSBoYXZlIHR3byB7QGxpbmsgVGVtcGxhdGVSZWZ9czpcbiAgICAgKlxuICAgICAqIE91dGVyIHtAbGluayBUZW1wbGF0ZVJlZn06XG4gICAgICogYGBgXG4gICAgICogQ291bnQ6IHt7aXRlbXMubGVuZ3RofX1cbiAgICAgKiA8dWw+XG4gICAgICogICA8dGVtcGxhdGUgbmdGb3IgbGV0LWl0ZW0gW25nRm9yT2ZdPVwiaXRlbXNcIj48L3RlbXBsYXRlPlxuICAgICAqIDwvdWw+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBJbm5lciB7QGxpbmsgVGVtcGxhdGVSZWZ9OlxuICAgICAqIGBgYFxuICAgICAqICAgPGxpPnt7aXRlbX19PC9saT5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIE5vdGljZSB0aGF0IHRoZSBvcmlnaW5hbCB0ZW1wbGF0ZSBpcyBicm9rZW4gZG93biBpbnRvIHR3byBzZXBhcmF0ZSB7QGxpbmsgVGVtcGxhdGVSZWZ9cy5cbiAgICAgKlxuICAgICAqIFRoZSBvdXRlci9pbm5lciB7QGxpbmsgVGVtcGxhdGVSZWZ9cyBhcmUgdGhlbiBhc3NlbWJsZWQgaW50byB2aWV3cyBsaWtlIHNvOlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogPCEtLSBWaWV3UmVmOiBvdXRlci0wIC0tPlxuICAgICAqIENvdW50OiAyXG4gICAgICogPHVsPlxuICAgICAqICAgPHRlbXBsYXRlIHZpZXctY29udGFpbmVyLXJlZj48L3RlbXBsYXRlPlxuICAgICAqICAgPCEtLSBWaWV3UmVmOiBpbm5lci0xIC0tPjxsaT5maXJzdDwvbGk+PCEtLSAvVmlld1JlZjogaW5uZXItMSAtLT5cbiAgICAgKiAgIDwhLS0gVmlld1JlZjogaW5uZXItMiAtLT48bGk+c2Vjb25kPC9saT48IS0tIC9WaWV3UmVmOiBpbm5lci0yIC0tPlxuICAgICAqIDwvdWw+XG4gICAgICogPCEtLSAvVmlld1JlZjogb3V0ZXItMCAtLT5cbiAgICAgKiBgYGBcbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgdmFyIEVtYmVkZGVkVmlld1JlZiA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQxMShFbWJlZGRlZFZpZXdSZWYsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIEVtYmVkZGVkVmlld1JlZigpIHtcbiAgICAgICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFbWJlZGRlZFZpZXdSZWYucHJvdG90eXBlLCBcImNvbnRleHRcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1bmltcGxlbWVudGVkKCk7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRW1iZWRkZWRWaWV3UmVmLnByb3RvdHlwZSwgXCJyb290Tm9kZXNcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1bmltcGxlbWVudGVkKCk7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICA7XG4gICAgICAgIHJldHVybiBFbWJlZGRlZFZpZXdSZWY7XG4gICAgfShWaWV3UmVmKSk7XG4gICAgdmFyIFZpZXdSZWZfID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gVmlld1JlZl8oX3ZpZXcpIHtcbiAgICAgICAgICAgIHRoaXMuX3ZpZXcgPSBfdmlldztcbiAgICAgICAgICAgIHRoaXMuX3ZpZXcgPSBfdmlldztcbiAgICAgICAgICAgIHRoaXMuX29yaWdpbmFsTW9kZSA9IHRoaXMuX3ZpZXcuY2RNb2RlO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWaWV3UmVmXy5wcm90b3R5cGUsIFwiaW50ZXJuYWxWaWV3XCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fdmlldzsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWaWV3UmVmXy5wcm90b3R5cGUsIFwicm9vdE5vZGVzXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fdmlldy5mbGF0Um9vdE5vZGVzOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZpZXdSZWZfLnByb3RvdHlwZSwgXCJjb250ZXh0XCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fdmlldy5jb250ZXh0OyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZpZXdSZWZfLnByb3RvdHlwZSwgXCJkZXN0cm95ZWRcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl92aWV3LmRlc3Ryb3llZDsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIFZpZXdSZWZfLnByb3RvdHlwZS5tYXJrRm9yQ2hlY2sgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX3ZpZXcubWFya1BhdGhUb1Jvb3RBc0NoZWNrT25jZSgpOyB9O1xuICAgICAgICBWaWV3UmVmXy5wcm90b3R5cGUuZGV0YWNoID0gZnVuY3Rpb24gKCkgeyB0aGlzLl92aWV3LmNkTW9kZSA9IENoYW5nZURldGVjdG9yU3RhdHVzLkRldGFjaGVkOyB9O1xuICAgICAgICBWaWV3UmVmXy5wcm90b3R5cGUuZGV0ZWN0Q2hhbmdlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX3ZpZXcuZGV0ZWN0Q2hhbmdlcyhmYWxzZSk7XG4gICAgICAgICAgICB0cmlnZ2VyUXVldWVkQW5pbWF0aW9ucygpO1xuICAgICAgICB9O1xuICAgICAgICBWaWV3UmVmXy5wcm90b3R5cGUuY2hlY2tOb0NoYW5nZXMgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX3ZpZXcuZGV0ZWN0Q2hhbmdlcyh0cnVlKTsgfTtcbiAgICAgICAgVmlld1JlZl8ucHJvdG90eXBlLnJlYXR0YWNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fdmlldy5jZE1vZGUgPSB0aGlzLl9vcmlnaW5hbE1vZGU7XG4gICAgICAgICAgICB0aGlzLm1hcmtGb3JDaGVjaygpO1xuICAgICAgICB9O1xuICAgICAgICBWaWV3UmVmXy5wcm90b3R5cGUub25EZXN0cm95ID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7IHRoaXMuX3ZpZXcuZGlzcG9zYWJsZXMucHVzaChjYWxsYmFjayk7IH07XG4gICAgICAgIFZpZXdSZWZfLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkgeyB0aGlzLl92aWV3LmRlc3Ryb3koKTsgfTtcbiAgICAgICAgcmV0dXJuIFZpZXdSZWZfO1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgdmFyIF9fZXh0ZW5kcyQxMiA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xuICAgIHZhciBFdmVudExpc3RlbmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gRXZlbnRMaXN0ZW5lcihuYW1lLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgICAgfVxuICAgICAgICA7XG4gICAgICAgIHJldHVybiBFdmVudExpc3RlbmVyO1xuICAgIH0oKSk7XG4gICAgLyoqXG4gICAgICogQGV4cGVyaW1lbnRhbCBBbGwgZGVidWdnaW5nIGFwaXMgYXJlIGN1cnJlbnRseSBleHBlcmltZW50YWwuXG4gICAgICovXG4gICAgdmFyIERlYnVnTm9kZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIERlYnVnTm9kZShuYXRpdmVOb2RlLCBwYXJlbnQsIF9kZWJ1Z0luZm8pIHtcbiAgICAgICAgICAgIHRoaXMuX2RlYnVnSW5mbyA9IF9kZWJ1Z0luZm87XG4gICAgICAgICAgICB0aGlzLm5hdGl2ZU5vZGUgPSBuYXRpdmVOb2RlO1xuICAgICAgICAgICAgaWYgKGlzUHJlc2VudChwYXJlbnQpICYmIHBhcmVudCBpbnN0YW5jZW9mIERlYnVnRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHBhcmVudC5hZGRDaGlsZCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubGlzdGVuZXJzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERlYnVnTm9kZS5wcm90b3R5cGUsIFwiaW5qZWN0b3JcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpc1ByZXNlbnQodGhpcy5fZGVidWdJbmZvKSA/IHRoaXMuX2RlYnVnSW5mby5pbmplY3RvciA6IG51bGw7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGVidWdOb2RlLnByb3RvdHlwZSwgXCJjb21wb25lbnRJbnN0YW5jZVwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNQcmVzZW50KHRoaXMuX2RlYnVnSW5mbykgPyB0aGlzLl9kZWJ1Z0luZm8uY29tcG9uZW50IDogbnVsbDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGVidWdOb2RlLnByb3RvdHlwZSwgXCJjb250ZXh0XCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaXNQcmVzZW50KHRoaXMuX2RlYnVnSW5mbykgPyB0aGlzLl9kZWJ1Z0luZm8uY29udGV4dCA6IG51bGw7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGVidWdOb2RlLnByb3RvdHlwZSwgXCJyZWZlcmVuY2VzXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc1ByZXNlbnQodGhpcy5fZGVidWdJbmZvKSA/IHRoaXMuX2RlYnVnSW5mby5yZWZlcmVuY2VzIDogbnVsbDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGVidWdOb2RlLnByb3RvdHlwZSwgXCJwcm92aWRlclRva2Vuc1wiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNQcmVzZW50KHRoaXMuX2RlYnVnSW5mbykgPyB0aGlzLl9kZWJ1Z0luZm8ucHJvdmlkZXJUb2tlbnMgOiBudWxsO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEZWJ1Z05vZGUucHJvdG90eXBlLCBcInNvdXJjZVwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGlzUHJlc2VudCh0aGlzLl9kZWJ1Z0luZm8pID8gdGhpcy5fZGVidWdJbmZvLnNvdXJjZSA6IG51bGw7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gRGVidWdOb2RlO1xuICAgIH0oKSk7XG4gICAgLyoqXG4gICAgICogQGV4cGVyaW1lbnRhbCBBbGwgZGVidWdnaW5nIGFwaXMgYXJlIGN1cnJlbnRseSBleHBlcmltZW50YWwuXG4gICAgICovXG4gICAgdmFyIERlYnVnRWxlbWVudCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQxMihEZWJ1Z0VsZW1lbnQsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIERlYnVnRWxlbWVudChuYXRpdmVOb2RlLCBwYXJlbnQsIF9kZWJ1Z0luZm8pIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIG5hdGl2ZU5vZGUsIHBhcmVudCwgX2RlYnVnSW5mbyk7XG4gICAgICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSB7fTtcbiAgICAgICAgICAgIHRoaXMuYXR0cmlidXRlcyA9IHt9O1xuICAgICAgICAgICAgdGhpcy5jbGFzc2VzID0ge307XG4gICAgICAgICAgICB0aGlzLnN0eWxlcyA9IHt9O1xuICAgICAgICAgICAgdGhpcy5jaGlsZE5vZGVzID0gW107XG4gICAgICAgICAgICB0aGlzLm5hdGl2ZUVsZW1lbnQgPSBuYXRpdmVOb2RlO1xuICAgICAgICB9XG4gICAgICAgIERlYnVnRWxlbWVudC5wcm90b3R5cGUuYWRkQ2hpbGQgPSBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgIGlmIChpc1ByZXNlbnQoY2hpbGQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGlsZE5vZGVzLnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgICAgIGNoaWxkLnBhcmVudCA9IHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIERlYnVnRWxlbWVudC5wcm90b3R5cGUucmVtb3ZlQ2hpbGQgPSBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgIHZhciBjaGlsZEluZGV4ID0gdGhpcy5jaGlsZE5vZGVzLmluZGV4T2YoY2hpbGQpO1xuICAgICAgICAgICAgaWYgKGNoaWxkSW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgY2hpbGQucGFyZW50ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLmNoaWxkTm9kZXMuc3BsaWNlKGNoaWxkSW5kZXgsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBEZWJ1Z0VsZW1lbnQucHJvdG90eXBlLmluc2VydENoaWxkcmVuQWZ0ZXIgPSBmdW5jdGlvbiAoY2hpbGQsIG5ld0NoaWxkcmVuKSB7XG4gICAgICAgICAgICB2YXIgc2libGluZ0luZGV4ID0gdGhpcy5jaGlsZE5vZGVzLmluZGV4T2YoY2hpbGQpO1xuICAgICAgICAgICAgaWYgKHNpYmxpbmdJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJldmlvdXNDaGlsZHJlbiA9IHRoaXMuY2hpbGROb2Rlcy5zbGljZSgwLCBzaWJsaW5nSW5kZXggKyAxKTtcbiAgICAgICAgICAgICAgICB2YXIgbmV4dENoaWxkcmVuID0gdGhpcy5jaGlsZE5vZGVzLnNsaWNlKHNpYmxpbmdJbmRleCArIDEpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2hpbGROb2RlcyA9IHByZXZpb3VzQ2hpbGRyZW4uY29uY2F0KG5ld0NoaWxkcmVuLCBuZXh0Q2hpbGRyZW4pO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV3Q2hpbGRyZW4ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld0NoaWxkID0gbmV3Q2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1ByZXNlbnQobmV3Q2hpbGQucGFyZW50KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3Q2hpbGQucGFyZW50LnJlbW92ZUNoaWxkKG5ld0NoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBuZXdDaGlsZC5wYXJlbnQgPSB0aGlzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgRGVidWdFbGVtZW50LnByb3RvdHlwZS5xdWVyeSA9IGZ1bmN0aW9uIChwcmVkaWNhdGUpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHRzID0gdGhpcy5xdWVyeUFsbChwcmVkaWNhdGUpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHMubGVuZ3RoID4gMCA/IHJlc3VsdHNbMF0gOiBudWxsO1xuICAgICAgICB9O1xuICAgICAgICBEZWJ1Z0VsZW1lbnQucHJvdG90eXBlLnF1ZXJ5QWxsID0gZnVuY3Rpb24gKHByZWRpY2F0ZSkge1xuICAgICAgICAgICAgdmFyIG1hdGNoZXMgPSBbXTtcbiAgICAgICAgICAgIF9xdWVyeUVsZW1lbnRDaGlsZHJlbih0aGlzLCBwcmVkaWNhdGUsIG1hdGNoZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG1hdGNoZXM7XG4gICAgICAgIH07XG4gICAgICAgIERlYnVnRWxlbWVudC5wcm90b3R5cGUucXVlcnlBbGxOb2RlcyA9IGZ1bmN0aW9uIChwcmVkaWNhdGUpIHtcbiAgICAgICAgICAgIHZhciBtYXRjaGVzID0gW107XG4gICAgICAgICAgICBfcXVlcnlOb2RlQ2hpbGRyZW4odGhpcywgcHJlZGljYXRlLCBtYXRjaGVzKTtcbiAgICAgICAgICAgIHJldHVybiBtYXRjaGVzO1xuICAgICAgICB9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGVidWdFbGVtZW50LnByb3RvdHlwZSwgXCJjaGlsZHJlblwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLmNoaWxkTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIERlYnVnRWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4ucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZHJlbjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBEZWJ1Z0VsZW1lbnQucHJvdG90eXBlLnRyaWdnZXJFdmVudEhhbmRsZXIgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBldmVudE9iaikge1xuICAgICAgICAgICAgdGhpcy5saXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAobGlzdGVuZXIubmFtZSA9PSBldmVudE5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXIuY2FsbGJhY2soZXZlbnRPYmopO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gRGVidWdFbGVtZW50O1xuICAgIH0oRGVidWdOb2RlKSk7XG4gICAgLyoqXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFzTmF0aXZlRWxlbWVudHMoZGVidWdFbHMpIHtcbiAgICAgICAgcmV0dXJuIGRlYnVnRWxzLm1hcChmdW5jdGlvbiAoZWwpIHsgcmV0dXJuIGVsLm5hdGl2ZUVsZW1lbnQ7IH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBfcXVlcnlFbGVtZW50Q2hpbGRyZW4oZWxlbWVudCwgcHJlZGljYXRlLCBtYXRjaGVzKSB7XG4gICAgICAgIGVsZW1lbnQuY2hpbGROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIERlYnVnRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGlmIChwcmVkaWNhdGUobm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlcy5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfcXVlcnlFbGVtZW50Q2hpbGRyZW4obm9kZSwgcHJlZGljYXRlLCBtYXRjaGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIF9xdWVyeU5vZGVDaGlsZHJlbihwYXJlbnROb2RlLCBwcmVkaWNhdGUsIG1hdGNoZXMpIHtcbiAgICAgICAgaWYgKHBhcmVudE5vZGUgaW5zdGFuY2VvZiBEZWJ1Z0VsZW1lbnQpIHtcbiAgICAgICAgICAgIHBhcmVudE5vZGUuY2hpbGROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByZWRpY2F0ZShub2RlKSkge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaGVzLnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgRGVidWdFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIF9xdWVyeU5vZGVDaGlsZHJlbihub2RlLCBwcmVkaWNhdGUsIG1hdGNoZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIE5lZWQgdG8ga2VlcCB0aGUgbm9kZXMgaW4gYSBnbG9iYWwgTWFwIHNvIHRoYXQgbXVsdGlwbGUgYW5ndWxhciBhcHBzIGFyZSBzdXBwb3J0ZWQuXG4gICAgdmFyIF9uYXRpdmVOb2RlVG9EZWJ1Z05vZGUgPSBuZXcgTWFwKCk7XG4gICAgLyoqXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldERlYnVnTm9kZShuYXRpdmVOb2RlKSB7XG4gICAgICAgIHJldHVybiBfbmF0aXZlTm9kZVRvRGVidWdOb2RlLmdldChuYXRpdmVOb2RlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaW5kZXhEZWJ1Z05vZGUobm9kZSkge1xuICAgICAgICBfbmF0aXZlTm9kZVRvRGVidWdOb2RlLnNldChub2RlLm5hdGl2ZU5vZGUsIG5vZGUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZW1vdmVEZWJ1Z05vZGVGcm9tSW5kZXgobm9kZSkge1xuICAgICAgICBfbmF0aXZlTm9kZVRvRGVidWdOb2RlLmRlbGV0ZShub2RlLm5hdGl2ZU5vZGUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9yZWZsZWN0b3IoKSB7XG4gICAgICAgIHJldHVybiByZWZsZWN0b3I7XG4gICAgfVxuICAgIHZhciBfQ09SRV9QTEFURk9STV9QUk9WSURFUlMgPSBbXG4gICAgICAgIFBsYXRmb3JtUmVmXyxcbiAgICAgICAgeyBwcm92aWRlOiBQbGF0Zm9ybVJlZiwgdXNlRXhpc3Rpbmc6IFBsYXRmb3JtUmVmXyB9LFxuICAgICAgICB7IHByb3ZpZGU6IFJlZmxlY3RvciwgdXNlRmFjdG9yeTogX3JlZmxlY3RvciwgZGVwczogW10gfSxcbiAgICAgICAgeyBwcm92aWRlOiBSZWZsZWN0b3JSZWFkZXIsIHVzZUV4aXN0aW5nOiBSZWZsZWN0b3IgfSxcbiAgICAgICAgVGVzdGFiaWxpdHlSZWdpc3RyeSxcbiAgICAgICAgQ29uc29sZSxcbiAgICBdO1xuICAgIC8qKlxuICAgICAqIFRoaXMgcGxhdGZvcm0gaGFzIHRvIGJlIGluY2x1ZGVkIGluIGFueSBvdGhlciBwbGF0Zm9ybVxuICAgICAqXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIHZhciBwbGF0Zm9ybUNvcmUgPSBjcmVhdGVQbGF0Zm9ybUZhY3RvcnkobnVsbCwgJ2NvcmUnLCBfQ09SRV9QTEFURk9STV9QUk9WSURFUlMpO1xuXG4gICAgLyoqXG4gICAgICogQGV4cGVyaW1lbnRhbCBpMThuIHN1cHBvcnQgaXMgZXhwZXJpbWVudGFsLlxuICAgICAqL1xuICAgIHZhciBMT0NBTEVfSUQgPSBuZXcgT3BhcXVlVG9rZW4oJ0xvY2FsZUlkJyk7XG4gICAgLyoqXG4gICAgICogQGV4cGVyaW1lbnRhbCBpMThuIHN1cHBvcnQgaXMgZXhwZXJpbWVudGFsLlxuICAgICAqL1xuICAgIHZhciBUUkFOU0xBVElPTlMgPSBuZXcgT3BhcXVlVG9rZW4oJ1RyYW5zbGF0aW9ucycpO1xuICAgIC8qKlxuICAgICAqIEBleHBlcmltZW50YWwgaTE4biBzdXBwb3J0IGlzIGV4cGVyaW1lbnRhbC5cbiAgICAgKi9cbiAgICB2YXIgVFJBTlNMQVRJT05TX0ZPUk1BVCA9IG5ldyBPcGFxdWVUb2tlbignVHJhbnNsYXRpb25zRm9ybWF0Jyk7XG5cbiAgICBmdW5jdGlvbiBfaXRlcmFibGVEaWZmZXJzRmFjdG9yeSgpIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRJdGVyYWJsZURpZmZlcnM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIF9rZXlWYWx1ZURpZmZlcnNGYWN0b3J5KCkge1xuICAgICAgICByZXR1cm4gZGVmYXVsdEtleVZhbHVlRGlmZmVycztcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBtb2R1bGUgaW5jbHVkZXMgdGhlIHByb3ZpZGVycyBvZiBAYW5ndWxhci9jb3JlIHRoYXQgYXJlIG5lZWRlZFxuICAgICAqIHRvIGJvb3RzdHJhcCBjb21wb25lbnRzIHZpYSBgQXBwbGljYXRpb25SZWZgLlxuICAgICAqXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIHZhciBBcHBsaWNhdGlvbk1vZHVsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEFwcGxpY2F0aW9uTW9kdWxlKCkge1xuICAgICAgICB9XG4gICAgICAgIEFwcGxpY2F0aW9uTW9kdWxlLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IE5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQXBwbGljYXRpb25SZWZfLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgcHJvdmlkZTogQXBwbGljYXRpb25SZWYsIHVzZUV4aXN0aW5nOiBBcHBsaWNhdGlvblJlZl8gfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBBcHBsaWNhdGlvbkluaXRTdGF0dXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQ29tcGlsZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQVBQX0lEX1JBTkRPTV9QUk9WSURFUixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBWaWV3VXRpbHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBwcm92aWRlOiBJdGVyYWJsZURpZmZlcnMsIHVzZUZhY3Rvcnk6IF9pdGVyYWJsZURpZmZlcnNGYWN0b3J5IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBwcm92aWRlOiBLZXlWYWx1ZURpZmZlcnMsIHVzZUZhY3Rvcnk6IF9rZXlWYWx1ZURpZmZlcnNGYWN0b3J5IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBwcm92aWRlOiBMT0NBTEVfSUQsIHVzZVZhbHVlOiAnZW4tVVMnIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgQXBwbGljYXRpb25Nb2R1bGUuY3RvclBhcmFtZXRlcnMgPSBbXTtcbiAgICAgICAgcmV0dXJuIEFwcGxpY2F0aW9uTW9kdWxlO1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgdmFyIEZJTExfU1RZTEVfRkxBRyA9ICd0cnVlJzsgLy8gVE9ETyAobWF0c2tvKTogY2hhbmdlIHRvIGJvb2xlYW5cbiAgICB2YXIgQU5ZX1NUQVRFID0gJyonO1xuICAgIHZhciBERUZBVUxUX1NUQVRFID0gJyonO1xuICAgIHZhciBFTVBUWV9TVEFURSA9ICd2b2lkJztcblxuICAgIHZhciBBbmltYXRpb25Hcm91cFBsYXllciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEFuaW1hdGlvbkdyb3VwUGxheWVyKF9wbGF5ZXJzKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5fcGxheWVycyA9IF9wbGF5ZXJzO1xuICAgICAgICAgICAgdGhpcy5fb25Eb25lRm5zID0gW107XG4gICAgICAgICAgICB0aGlzLl9vblN0YXJ0Rm5zID0gW107XG4gICAgICAgICAgICB0aGlzLl9maW5pc2hlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5wYXJlbnRQbGF5ZXIgPSBudWxsO1xuICAgICAgICAgICAgdmFyIGNvdW50ID0gMDtcbiAgICAgICAgICAgIHZhciB0b3RhbCA9IHRoaXMuX3BsYXllcnMubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKHRvdGFsID09IDApIHtcbiAgICAgICAgICAgICAgICBzY2hlZHVsZU1pY3JvVGFzayhmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fb25GaW5pc2goKTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wbGF5ZXJzLmZvckVhY2goZnVuY3Rpb24gKHBsYXllcikge1xuICAgICAgICAgICAgICAgICAgICBwbGF5ZXIucGFyZW50UGxheWVyID0gX3RoaXM7XG4gICAgICAgICAgICAgICAgICAgIHBsYXllci5vbkRvbmUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCsrY291bnQgPj0gdG90YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fb25GaW5pc2goKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgQW5pbWF0aW9uR3JvdXBQbGF5ZXIucHJvdG90eXBlLl9vbkZpbmlzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fZmluaXNoZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9maW5pc2hlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1ByZXNlbnQodGhpcy5wYXJlbnRQbGF5ZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9vbkRvbmVGbnMuZm9yRWFjaChmdW5jdGlvbiAoZm4pIHsgcmV0dXJuIGZuKCk7IH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuX29uRG9uZUZucyA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBBbmltYXRpb25Hcm91cFBsYXllci5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fcGxheWVycy5mb3JFYWNoKGZ1bmN0aW9uIChwbGF5ZXIpIHsgcmV0dXJuIHBsYXllci5pbml0KCk7IH0pOyB9O1xuICAgICAgICBBbmltYXRpb25Hcm91cFBsYXllci5wcm90b3R5cGUub25TdGFydCA9IGZ1bmN0aW9uIChmbikgeyB0aGlzLl9vblN0YXJ0Rm5zLnB1c2goZm4pOyB9O1xuICAgICAgICBBbmltYXRpb25Hcm91cFBsYXllci5wcm90b3R5cGUub25Eb25lID0gZnVuY3Rpb24gKGZuKSB7IHRoaXMuX29uRG9uZUZucy5wdXNoKGZuKTsgfTtcbiAgICAgICAgQW5pbWF0aW9uR3JvdXBQbGF5ZXIucHJvdG90eXBlLmhhc1N0YXJ0ZWQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9zdGFydGVkOyB9O1xuICAgICAgICBBbmltYXRpb25Hcm91cFBsYXllci5wcm90b3R5cGUucGxheSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghaXNQcmVzZW50KHRoaXMucGFyZW50UGxheWVyKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5pdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLmhhc1N0YXJ0ZWQoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX29uU3RhcnRGbnMuZm9yRWFjaChmdW5jdGlvbiAoZm4pIHsgcmV0dXJuIGZuKCk7IH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuX29uU3RhcnRGbnMgPSBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3BsYXllcnMuZm9yRWFjaChmdW5jdGlvbiAocGxheWVyKSB7IHJldHVybiBwbGF5ZXIucGxheSgpOyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgQW5pbWF0aW9uR3JvdXBQbGF5ZXIucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKCkgeyB0aGlzLl9wbGF5ZXJzLmZvckVhY2goZnVuY3Rpb24gKHBsYXllcikgeyByZXR1cm4gcGxheWVyLnBhdXNlKCk7IH0pOyB9O1xuICAgICAgICBBbmltYXRpb25Hcm91cFBsYXllci5wcm90b3R5cGUucmVzdGFydCA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fcGxheWVycy5mb3JFYWNoKGZ1bmN0aW9uIChwbGF5ZXIpIHsgcmV0dXJuIHBsYXllci5yZXN0YXJ0KCk7IH0pOyB9O1xuICAgICAgICBBbmltYXRpb25Hcm91cFBsYXllci5wcm90b3R5cGUuZmluaXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fb25GaW5pc2goKTtcbiAgICAgICAgICAgIHRoaXMuX3BsYXllcnMuZm9yRWFjaChmdW5jdGlvbiAocGxheWVyKSB7IHJldHVybiBwbGF5ZXIuZmluaXNoKCk7IH0pO1xuICAgICAgICB9O1xuICAgICAgICBBbmltYXRpb25Hcm91cFBsYXllci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX29uRmluaXNoKCk7XG4gICAgICAgICAgICB0aGlzLl9wbGF5ZXJzLmZvckVhY2goZnVuY3Rpb24gKHBsYXllcikgeyByZXR1cm4gcGxheWVyLmRlc3Ryb3koKTsgfSk7XG4gICAgICAgIH07XG4gICAgICAgIEFuaW1hdGlvbkdyb3VwUGxheWVyLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fcGxheWVycy5mb3JFYWNoKGZ1bmN0aW9uIChwbGF5ZXIpIHsgcmV0dXJuIHBsYXllci5yZXNldCgpOyB9KTsgfTtcbiAgICAgICAgQW5pbWF0aW9uR3JvdXBQbGF5ZXIucHJvdG90eXBlLnNldFBvc2l0aW9uID0gZnVuY3Rpb24gKHAgLyoqIFRPRE8gIzkxMDAgKi8pIHtcbiAgICAgICAgICAgIHRoaXMuX3BsYXllcnMuZm9yRWFjaChmdW5jdGlvbiAocGxheWVyKSB7IHBsYXllci5zZXRQb3NpdGlvbihwKTsgfSk7XG4gICAgICAgIH07XG4gICAgICAgIEFuaW1hdGlvbkdyb3VwUGxheWVyLnByb3RvdHlwZS5nZXRQb3NpdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBtaW4gPSAwO1xuICAgICAgICAgICAgdGhpcy5fcGxheWVycy5mb3JFYWNoKGZ1bmN0aW9uIChwbGF5ZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgcCA9IHBsYXllci5nZXRQb3NpdGlvbigpO1xuICAgICAgICAgICAgICAgIG1pbiA9IE1hdGgubWluKHAsIG1pbik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBtaW47XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBBbmltYXRpb25Hcm91cFBsYXllcjtcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIHZhciBBbmltYXRpb25LZXlmcmFtZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEFuaW1hdGlvbktleWZyYW1lKG9mZnNldCwgc3R5bGVzKSB7XG4gICAgICAgICAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgICAgIHRoaXMuc3R5bGVzID0gc3R5bGVzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBBbmltYXRpb25LZXlmcmFtZTtcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogQGV4cGVyaW1lbnRhbCBBbmltYXRpb24gc3VwcG9ydCBpcyBleHBlcmltZW50YWwuXG4gICAgICovXG4gICAgdmFyIEFuaW1hdGlvblBsYXllciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEFuaW1hdGlvblBsYXllcigpIHtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQW5pbWF0aW9uUGxheWVyLnByb3RvdHlwZSwgXCJwYXJlbnRQbGF5ZXJcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHRocm93IG5ldyBFcnJvcignTk9UIElNUExFTUVOVEVEOiBCYXNlIENsYXNzJyk7IH0sXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIChwbGF5ZXIpIHsgdGhyb3cgbmV3IEVycm9yKCdOT1QgSU1QTEVNRU5URUQ6IEJhc2UgQ2xhc3MnKTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBBbmltYXRpb25QbGF5ZXI7XG4gICAgfSgpKTtcbiAgICB2YXIgTm9PcEFuaW1hdGlvblBsYXllciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIE5vT3BBbmltYXRpb25QbGF5ZXIoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5fb25Eb25lRm5zID0gW107XG4gICAgICAgICAgICB0aGlzLl9vblN0YXJ0Rm5zID0gW107XG4gICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnBhcmVudFBsYXllciA9IG51bGw7XG4gICAgICAgICAgICBzY2hlZHVsZU1pY3JvVGFzayhmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fb25GaW5pc2goKTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBOb09wQW5pbWF0aW9uUGxheWVyLnByb3RvdHlwZS5fb25GaW5pc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9vbkRvbmVGbnMuZm9yRWFjaChmdW5jdGlvbiAoZm4pIHsgcmV0dXJuIGZuKCk7IH0pO1xuICAgICAgICAgICAgdGhpcy5fb25Eb25lRm5zID0gW107XG4gICAgICAgIH07XG4gICAgICAgIE5vT3BBbmltYXRpb25QbGF5ZXIucHJvdG90eXBlLm9uU3RhcnQgPSBmdW5jdGlvbiAoZm4pIHsgdGhpcy5fb25TdGFydEZucy5wdXNoKGZuKTsgfTtcbiAgICAgICAgTm9PcEFuaW1hdGlvblBsYXllci5wcm90b3R5cGUub25Eb25lID0gZnVuY3Rpb24gKGZuKSB7IHRoaXMuX29uRG9uZUZucy5wdXNoKGZuKTsgfTtcbiAgICAgICAgTm9PcEFuaW1hdGlvblBsYXllci5wcm90b3R5cGUuaGFzU3RhcnRlZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3N0YXJ0ZWQ7IH07XG4gICAgICAgIE5vT3BBbmltYXRpb25QbGF5ZXIucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgIE5vT3BBbmltYXRpb25QbGF5ZXIucHJvdG90eXBlLnBsYXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaGFzU3RhcnRlZCgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fb25TdGFydEZucy5mb3JFYWNoKGZ1bmN0aW9uIChmbikgeyByZXR1cm4gZm4oKTsgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fb25TdGFydEZucyA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIE5vT3BBbmltYXRpb25QbGF5ZXIucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgICAgICBOb09wQW5pbWF0aW9uUGxheWVyLnByb3RvdHlwZS5yZXN0YXJ0ID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgICAgICBOb09wQW5pbWF0aW9uUGxheWVyLnByb3RvdHlwZS5maW5pc2ggPSBmdW5jdGlvbiAoKSB7IHRoaXMuX29uRmluaXNoKCk7IH07XG4gICAgICAgIE5vT3BBbmltYXRpb25QbGF5ZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgIE5vT3BBbmltYXRpb25QbGF5ZXIucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgICAgICBOb09wQW5pbWF0aW9uUGxheWVyLnByb3RvdHlwZS5zZXRQb3NpdGlvbiA9IGZ1bmN0aW9uIChwIC8qKiBUT0RPICM5MTAwICovKSB7IH07XG4gICAgICAgIE5vT3BBbmltYXRpb25QbGF5ZXIucHJvdG90eXBlLmdldFBvc2l0aW9uID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gMDsgfTtcbiAgICAgICAgcmV0dXJuIE5vT3BBbmltYXRpb25QbGF5ZXI7XG4gICAgfSgpKTtcblxuICAgIHZhciBBbmltYXRpb25TZXF1ZW5jZVBsYXllciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEFuaW1hdGlvblNlcXVlbmNlUGxheWVyKF9wbGF5ZXJzKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5fcGxheWVycyA9IF9wbGF5ZXJzO1xuICAgICAgICAgICAgdGhpcy5fY3VycmVudEluZGV4ID0gMDtcbiAgICAgICAgICAgIHRoaXMuX29uRG9uZUZucyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fb25TdGFydEZucyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fZmluaXNoZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMucGFyZW50UGxheWVyID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX3BsYXllcnMuZm9yRWFjaChmdW5jdGlvbiAocGxheWVyKSB7IHBsYXllci5wYXJlbnRQbGF5ZXIgPSBfdGhpczsgfSk7XG4gICAgICAgICAgICB0aGlzLl9vbk5leHQoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIEFuaW1hdGlvblNlcXVlbmNlUGxheWVyLnByb3RvdHlwZS5fb25OZXh0ID0gZnVuY3Rpb24gKHN0YXJ0KSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2ZpbmlzaGVkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmICh0aGlzLl9wbGF5ZXJzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0aXZlUGxheWVyID0gbmV3IE5vT3BBbmltYXRpb25QbGF5ZXIoKTtcbiAgICAgICAgICAgICAgICBzY2hlZHVsZU1pY3JvVGFzayhmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fb25GaW5pc2goKTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9jdXJyZW50SW5kZXggPj0gdGhpcy5fcGxheWVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3RpdmVQbGF5ZXIgPSBuZXcgTm9PcEFuaW1hdGlvblBsYXllcigpO1xuICAgICAgICAgICAgICAgIHRoaXMuX29uRmluaXNoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgcGxheWVyID0gdGhpcy5fcGxheWVyc1t0aGlzLl9jdXJyZW50SW5kZXgrK107XG4gICAgICAgICAgICAgICAgcGxheWVyLm9uRG9uZShmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fb25OZXh0KHRydWUpOyB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3RpdmVQbGF5ZXIgPSBwbGF5ZXI7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIHBsYXllci5wbGF5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBBbmltYXRpb25TZXF1ZW5jZVBsYXllci5wcm90b3R5cGUuX29uRmluaXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9maW5pc2hlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2ZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzUHJlc2VudCh0aGlzLnBhcmVudFBsYXllcikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX29uRG9uZUZucy5mb3JFYWNoKGZ1bmN0aW9uIChmbikgeyByZXR1cm4gZm4oKTsgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fb25Eb25lRm5zID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIEFuaW1hdGlvblNlcXVlbmNlUGxheWVyLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkgeyB0aGlzLl9wbGF5ZXJzLmZvckVhY2goZnVuY3Rpb24gKHBsYXllcikgeyByZXR1cm4gcGxheWVyLmluaXQoKTsgfSk7IH07XG4gICAgICAgIEFuaW1hdGlvblNlcXVlbmNlUGxheWVyLnByb3RvdHlwZS5vblN0YXJ0ID0gZnVuY3Rpb24gKGZuKSB7IHRoaXMuX29uU3RhcnRGbnMucHVzaChmbik7IH07XG4gICAgICAgIEFuaW1hdGlvblNlcXVlbmNlUGxheWVyLnByb3RvdHlwZS5vbkRvbmUgPSBmdW5jdGlvbiAoZm4pIHsgdGhpcy5fb25Eb25lRm5zLnB1c2goZm4pOyB9O1xuICAgICAgICBBbmltYXRpb25TZXF1ZW5jZVBsYXllci5wcm90b3R5cGUuaGFzU3RhcnRlZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3N0YXJ0ZWQ7IH07XG4gICAgICAgIEFuaW1hdGlvblNlcXVlbmNlUGxheWVyLnByb3RvdHlwZS5wbGF5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCFpc1ByZXNlbnQodGhpcy5wYXJlbnRQbGF5ZXIpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbml0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuaGFzU3RhcnRlZCgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fb25TdGFydEZucy5mb3JFYWNoKGZ1bmN0aW9uIChmbikgeyByZXR1cm4gZm4oKTsgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fb25TdGFydEZucyA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fYWN0aXZlUGxheWVyLnBsYXkoKTtcbiAgICAgICAgfTtcbiAgICAgICAgQW5pbWF0aW9uU2VxdWVuY2VQbGF5ZXIucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKCkgeyB0aGlzLl9hY3RpdmVQbGF5ZXIucGF1c2UoKTsgfTtcbiAgICAgICAgQW5pbWF0aW9uU2VxdWVuY2VQbGF5ZXIucHJvdG90eXBlLnJlc3RhcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcGxheWVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3BsYXllcnNbMF0ucmVzdGFydCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBBbmltYXRpb25TZXF1ZW5jZVBsYXllci5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX3BsYXllcnMuZm9yRWFjaChmdW5jdGlvbiAocGxheWVyKSB7IHJldHVybiBwbGF5ZXIucmVzZXQoKTsgfSk7IH07XG4gICAgICAgIEFuaW1hdGlvblNlcXVlbmNlUGxheWVyLnByb3RvdHlwZS5maW5pc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9vbkZpbmlzaCgpO1xuICAgICAgICAgICAgdGhpcy5fcGxheWVycy5mb3JFYWNoKGZ1bmN0aW9uIChwbGF5ZXIpIHsgcmV0dXJuIHBsYXllci5maW5pc2goKTsgfSk7XG4gICAgICAgIH07XG4gICAgICAgIEFuaW1hdGlvblNlcXVlbmNlUGxheWVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fb25GaW5pc2goKTtcbiAgICAgICAgICAgIHRoaXMuX3BsYXllcnMuZm9yRWFjaChmdW5jdGlvbiAocGxheWVyKSB7IHJldHVybiBwbGF5ZXIuZGVzdHJveSgpOyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgQW5pbWF0aW9uU2VxdWVuY2VQbGF5ZXIucHJvdG90eXBlLnNldFBvc2l0aW9uID0gZnVuY3Rpb24gKHAgLyoqIFRPRE8gIzkxMDAgKi8pIHsgdGhpcy5fcGxheWVyc1swXS5zZXRQb3NpdGlvbihwKTsgfTtcbiAgICAgICAgQW5pbWF0aW9uU2VxdWVuY2VQbGF5ZXIucHJvdG90eXBlLmdldFBvc2l0aW9uID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcGxheWVyc1swXS5nZXRQb3NpdGlvbigpOyB9O1xuICAgICAgICByZXR1cm4gQW5pbWF0aW9uU2VxdWVuY2VQbGF5ZXI7XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICB2YXIgX19leHRlbmRzJDEzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQGV4cGVyaW1lbnRhbCBBbmltYXRpb24gc3VwcG9ydCBpcyBleHBlcmltZW50YWwuXG4gICAgICovXG4gICAgdmFyIEFVVE9fU1RZTEUgPSAnKic7XG4gICAgLyoqXG4gICAgICogTWV0YWRhdGEgcmVwcmVzZW50aW5nIHRoZSBlbnRyeSBvZiBhbmltYXRpb25zLlxuICAgICAqIEluc3RhbmNlcyBvZiB0aGlzIGNsYXNzIGFyZSBwcm92aWRlZCB2aWEgdGhlIGFuaW1hdGlvbiBEU0wgd2hlbiB0aGUge0BsaW5rIHRyaWdnZXIgdHJpZ2dlclxuICAgICAqIGFuaW1hdGlvbiBmdW5jdGlvbn0gaXMgY2FsbGVkLlxuICAgICAqXG4gICAgICogQGV4cGVyaW1lbnRhbCBBbmltYXRpb24gc3VwcG9ydCBpcyBleHBlcmltZW50YWwuXG4gICAgICovXG4gICAgdmFyIEFuaW1hdGlvbkVudHJ5TWV0YWRhdGEgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBBbmltYXRpb25FbnRyeU1ldGFkYXRhKG5hbWUsIGRlZmluaXRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICAgICAgdGhpcy5kZWZpbml0aW9ucyA9IGRlZmluaXRpb25zO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBBbmltYXRpb25FbnRyeU1ldGFkYXRhO1xuICAgIH0oKSk7XG4gICAgLyoqXG4gICAgICogQGV4cGVyaW1lbnRhbCBBbmltYXRpb24gc3VwcG9ydCBpcyBleHBlcmltZW50YWwuXG4gICAgICovXG4gICAgdmFyIEFuaW1hdGlvblN0YXRlTWV0YWRhdGEgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBBbmltYXRpb25TdGF0ZU1ldGFkYXRhKCkge1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBBbmltYXRpb25TdGF0ZU1ldGFkYXRhO1xuICAgIH0oKSk7XG4gICAgLyoqXG4gICAgICogTWV0YWRhdGEgcmVwcmVzZW50aW5nIHRoZSBlbnRyeSBvZiBhbmltYXRpb25zLlxuICAgICAqIEluc3RhbmNlcyBvZiB0aGlzIGNsYXNzIGFyZSBwcm92aWRlZCB2aWEgdGhlIGFuaW1hdGlvbiBEU0wgd2hlbiB0aGUge0BsaW5rIHN0YXRlIHN0YXRlIGFuaW1hdGlvblxuICAgICAqIGZ1bmN0aW9ufSBpcyBjYWxsZWQuXG4gICAgICpcbiAgICAgKiBAZXhwZXJpbWVudGFsIEFuaW1hdGlvbiBzdXBwb3J0IGlzIGV4cGVyaW1lbnRhbC5cbiAgICAgKi9cbiAgICB2YXIgQW5pbWF0aW9uU3RhdGVEZWNsYXJhdGlvbk1ldGFkYXRhID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDEzKEFuaW1hdGlvblN0YXRlRGVjbGFyYXRpb25NZXRhZGF0YSwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gQW5pbWF0aW9uU3RhdGVEZWNsYXJhdGlvbk1ldGFkYXRhKHN0YXRlTmFtZUV4cHIsIHN0eWxlcykge1xuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlTmFtZUV4cHIgPSBzdGF0ZU5hbWVFeHByO1xuICAgICAgICAgICAgdGhpcy5zdHlsZXMgPSBzdHlsZXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEFuaW1hdGlvblN0YXRlRGVjbGFyYXRpb25NZXRhZGF0YTtcbiAgICB9KEFuaW1hdGlvblN0YXRlTWV0YWRhdGEpKTtcbiAgICAvKipcbiAgICAgKiBNZXRhZGF0YSByZXByZXNlbnRpbmcgdGhlIGVudHJ5IG9mIGFuaW1hdGlvbnMuXG4gICAgICogSW5zdGFuY2VzIG9mIHRoaXMgY2xhc3MgYXJlIHByb3ZpZGVkIHZpYSB0aGUgYW5pbWF0aW9uIERTTCB3aGVuIHRoZVxuICAgICAqIHtAbGluayB0cmFuc2l0aW9uIHRyYW5zaXRpb24gYW5pbWF0aW9uIGZ1bmN0aW9ufSBpcyBjYWxsZWQuXG4gICAgICpcbiAgICAgKiBAZXhwZXJpbWVudGFsIEFuaW1hdGlvbiBzdXBwb3J0IGlzIGV4cGVyaW1lbnRhbC5cbiAgICAgKi9cbiAgICB2YXIgQW5pbWF0aW9uU3RhdGVUcmFuc2l0aW9uTWV0YWRhdGEgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMkMTMoQW5pbWF0aW9uU3RhdGVUcmFuc2l0aW9uTWV0YWRhdGEsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIEFuaW1hdGlvblN0YXRlVHJhbnNpdGlvbk1ldGFkYXRhKHN0YXRlQ2hhbmdlRXhwciwgc3RlcHMpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZUNoYW5nZUV4cHIgPSBzdGF0ZUNoYW5nZUV4cHI7XG4gICAgICAgICAgICB0aGlzLnN0ZXBzID0gc3RlcHM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEFuaW1hdGlvblN0YXRlVHJhbnNpdGlvbk1ldGFkYXRhO1xuICAgIH0oQW5pbWF0aW9uU3RhdGVNZXRhZGF0YSkpO1xuICAgIC8qKlxuICAgICAqIEBleHBlcmltZW50YWwgQW5pbWF0aW9uIHN1cHBvcnQgaXMgZXhwZXJpbWVudGFsLlxuICAgICAqL1xuICAgIHZhciBBbmltYXRpb25NZXRhZGF0YSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEFuaW1hdGlvbk1ldGFkYXRhKCkge1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBBbmltYXRpb25NZXRhZGF0YTtcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIE1ldGFkYXRhIHJlcHJlc2VudGluZyB0aGUgZW50cnkgb2YgYW5pbWF0aW9ucy5cbiAgICAgKiBJbnN0YW5jZXMgb2YgdGhpcyBjbGFzcyBhcmUgcHJvdmlkZWQgdmlhIHRoZSBhbmltYXRpb24gRFNMIHdoZW4gdGhlIHtAbGluayBrZXlmcmFtZXMga2V5ZnJhbWVzXG4gICAgICogYW5pbWF0aW9uIGZ1bmN0aW9ufSBpcyBjYWxsZWQuXG4gICAgICpcbiAgICAgKiBAZXhwZXJpbWVudGFsIEFuaW1hdGlvbiBzdXBwb3J0IGlzIGV4cGVyaW1lbnRhbC5cbiAgICAgKi9cbiAgICB2YXIgQW5pbWF0aW9uS2V5ZnJhbWVzU2VxdWVuY2VNZXRhZGF0YSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQxMyhBbmltYXRpb25LZXlmcmFtZXNTZXF1ZW5jZU1ldGFkYXRhLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBBbmltYXRpb25LZXlmcmFtZXNTZXF1ZW5jZU1ldGFkYXRhKHN0ZXBzKSB7XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuc3RlcHMgPSBzdGVwcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQW5pbWF0aW9uS2V5ZnJhbWVzU2VxdWVuY2VNZXRhZGF0YTtcbiAgICB9KEFuaW1hdGlvbk1ldGFkYXRhKSk7XG4gICAgLyoqXG4gICAgICogTWV0YWRhdGEgcmVwcmVzZW50aW5nIHRoZSBlbnRyeSBvZiBhbmltYXRpb25zLlxuICAgICAqIEluc3RhbmNlcyBvZiB0aGlzIGNsYXNzIGFyZSBwcm92aWRlZCB2aWEgdGhlIGFuaW1hdGlvbiBEU0wgd2hlbiB0aGUge0BsaW5rIHN0eWxlIHN0eWxlIGFuaW1hdGlvblxuICAgICAqIGZ1bmN0aW9ufSBpcyBjYWxsZWQuXG4gICAgICpcbiAgICAgKiBAZXhwZXJpbWVudGFsIEFuaW1hdGlvbiBzdXBwb3J0IGlzIGV4cGVyaW1lbnRhbC5cbiAgICAgKi9cbiAgICB2YXIgQW5pbWF0aW9uU3R5bGVNZXRhZGF0YSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQxMyhBbmltYXRpb25TdHlsZU1ldGFkYXRhLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBBbmltYXRpb25TdHlsZU1ldGFkYXRhKHN0eWxlcywgb2Zmc2V0KSB7XG4gICAgICAgICAgICBpZiAob2Zmc2V0ID09PSB2b2lkIDApIHsgb2Zmc2V0ID0gbnVsbDsgfVxuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB0aGlzLnN0eWxlcyA9IHN0eWxlcztcbiAgICAgICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBBbmltYXRpb25TdHlsZU1ldGFkYXRhO1xuICAgIH0oQW5pbWF0aW9uTWV0YWRhdGEpKTtcbiAgICAvKipcbiAgICAgKiBNZXRhZGF0YSByZXByZXNlbnRpbmcgdGhlIGVudHJ5IG9mIGFuaW1hdGlvbnMuXG4gICAgICogSW5zdGFuY2VzIG9mIHRoaXMgY2xhc3MgYXJlIHByb3ZpZGVkIHZpYSB0aGUgYW5pbWF0aW9uIERTTCB3aGVuIHRoZSB7QGxpbmsgYW5pbWF0ZSBhbmltYXRlXG4gICAgICogYW5pbWF0aW9uIGZ1bmN0aW9ufSBpcyBjYWxsZWQuXG4gICAgICpcbiAgICAgKiBAZXhwZXJpbWVudGFsIEFuaW1hdGlvbiBzdXBwb3J0IGlzIGV4cGVyaW1lbnRhbC5cbiAgICAgKi9cbiAgICB2YXIgQW5pbWF0aW9uQW5pbWF0ZU1ldGFkYXRhID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDEzKEFuaW1hdGlvbkFuaW1hdGVNZXRhZGF0YSwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gQW5pbWF0aW9uQW5pbWF0ZU1ldGFkYXRhKHRpbWluZ3MsIHN0eWxlcykge1xuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB0aGlzLnRpbWluZ3MgPSB0aW1pbmdzO1xuICAgICAgICAgICAgdGhpcy5zdHlsZXMgPSBzdHlsZXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEFuaW1hdGlvbkFuaW1hdGVNZXRhZGF0YTtcbiAgICB9KEFuaW1hdGlvbk1ldGFkYXRhKSk7XG4gICAgLyoqXG4gICAgICogQGV4cGVyaW1lbnRhbCBBbmltYXRpb24gc3VwcG9ydCBpcyBleHBlcmltZW50YWwuXG4gICAgICovXG4gICAgdmFyIEFuaW1hdGlvbldpdGhTdGVwc01ldGFkYXRhID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDEzKEFuaW1hdGlvbldpdGhTdGVwc01ldGFkYXRhLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBBbmltYXRpb25XaXRoU3RlcHNNZXRhZGF0YSgpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBbmltYXRpb25XaXRoU3RlcHNNZXRhZGF0YS5wcm90b3R5cGUsIFwic3RlcHNcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHRocm93IG5ldyBFcnJvcignTk9UIElNUExFTUVOVEVEOiBCYXNlIENsYXNzJyk7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gQW5pbWF0aW9uV2l0aFN0ZXBzTWV0YWRhdGE7XG4gICAgfShBbmltYXRpb25NZXRhZGF0YSkpO1xuICAgIC8qKlxuICAgICAqIE1ldGFkYXRhIHJlcHJlc2VudGluZyB0aGUgZW50cnkgb2YgYW5pbWF0aW9ucy5cbiAgICAgKiBJbnN0YW5jZXMgb2YgdGhpcyBjbGFzcyBhcmUgcHJvdmlkZWQgdmlhIHRoZSBhbmltYXRpb24gRFNMIHdoZW4gdGhlIHtAbGluayBzZXF1ZW5jZSBzZXF1ZW5jZVxuICAgICAqIGFuaW1hdGlvbiBmdW5jdGlvbn0gaXMgY2FsbGVkLlxuICAgICAqXG4gICAgICogQGV4cGVyaW1lbnRhbCBBbmltYXRpb24gc3VwcG9ydCBpcyBleHBlcmltZW50YWwuXG4gICAgICovXG4gICAgdmFyIEFuaW1hdGlvblNlcXVlbmNlTWV0YWRhdGEgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMkMTMoQW5pbWF0aW9uU2VxdWVuY2VNZXRhZGF0YSwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gQW5pbWF0aW9uU2VxdWVuY2VNZXRhZGF0YShfc3RlcHMpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5fc3RlcHMgPSBfc3RlcHM7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFuaW1hdGlvblNlcXVlbmNlTWV0YWRhdGEucHJvdG90eXBlLCBcInN0ZXBzXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fc3RlcHM7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gQW5pbWF0aW9uU2VxdWVuY2VNZXRhZGF0YTtcbiAgICB9KEFuaW1hdGlvbldpdGhTdGVwc01ldGFkYXRhKSk7XG4gICAgLyoqXG4gICAgICogTWV0YWRhdGEgcmVwcmVzZW50aW5nIHRoZSBlbnRyeSBvZiBhbmltYXRpb25zLlxuICAgICAqIEluc3RhbmNlcyBvZiB0aGlzIGNsYXNzIGFyZSBwcm92aWRlZCB2aWEgdGhlIGFuaW1hdGlvbiBEU0wgd2hlbiB0aGUge0BsaW5rIGdyb3VwIGdyb3VwIGFuaW1hdGlvblxuICAgICAqIGZ1bmN0aW9ufSBpcyBjYWxsZWQuXG4gICAgICpcbiAgICAgKiBAZXhwZXJpbWVudGFsIEFuaW1hdGlvbiBzdXBwb3J0IGlzIGV4cGVyaW1lbnRhbC5cbiAgICAgKi9cbiAgICB2YXIgQW5pbWF0aW9uR3JvdXBNZXRhZGF0YSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQxMyhBbmltYXRpb25Hcm91cE1ldGFkYXRhLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBBbmltYXRpb25Hcm91cE1ldGFkYXRhKF9zdGVwcykge1xuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB0aGlzLl9zdGVwcyA9IF9zdGVwcztcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQW5pbWF0aW9uR3JvdXBNZXRhZGF0YS5wcm90b3R5cGUsIFwic3RlcHNcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9zdGVwczsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBBbmltYXRpb25Hcm91cE1ldGFkYXRhO1xuICAgIH0oQW5pbWF0aW9uV2l0aFN0ZXBzTWV0YWRhdGEpKTtcbiAgICAvKipcbiAgICAgKiBgYW5pbWF0ZWAgaXMgYW4gYW5pbWF0aW9uLXNwZWNpZmljIGZ1bmN0aW9uIHRoYXQgaXMgZGVzaWduZWQgdG8gYmUgdXNlZCBpbnNpZGUgb2YgQW5ndWxhcjInc1xuICAgICAqIGFuaW1hdGlvblxuICAgICAqIERTTCBsYW5ndWFnZS4gSWYgdGhpcyBpbmZvcm1hdGlvbiBpcyBuZXcsIHBsZWFzZSBuYXZpZ2F0ZSB0byB0aGVcbiAgICAgKiB7QGxpbmsgQ29tcG9uZW50I2FuaW1hdGlvbnMtYW5jaG9yIGNvbXBvbmVudCBhbmltYXRpb25zIG1ldGFkYXRhXG4gICAgICogcGFnZX0gdG8gZ2FpbiBhIGJldHRlciB1bmRlcnN0YW5kaW5nIG9mIGhvdyBhbmltYXRpb25zIGluIEFuZ3VsYXIyIGFyZSB1c2VkLlxuICAgICAqXG4gICAgICogYGFuaW1hdGVgIHNwZWNpZmllcyBhbiBhbmltYXRpb24gc3RlcCB0aGF0IHdpbGwgYXBwbHkgdGhlIHByb3ZpZGVkIGBzdHlsZXNgIGRhdGEgZm9yIGEgZ2l2ZW5cbiAgICAgKiBhbW91bnQgb2ZcbiAgICAgKiB0aW1lIGJhc2VkIG9uIHRoZSBwcm92aWRlZCBgdGltaW5nYCBleHByZXNzaW9uIHZhbHVlLiBDYWxscyB0byBgYW5pbWF0ZWAgYXJlIGV4cGVjdGVkIHRvIGJlXG4gICAgICogdXNlZCB3aXRoaW4ge0BsaW5rIHNlcXVlbmNlIGFuIGFuaW1hdGlvbiBzZXF1ZW5jZX0sIHtAbGluayBncm91cCBncm91cH0sIG9yIHtAbGluayB0cmFuc2l0aW9uXG4gICAgICogdHJhbnNpdGlvbn0uXG4gICAgICpcbiAgICAgKiAjIyMgVXNhZ2VcbiAgICAgKlxuICAgICAqIFRoZSBgYW5pbWF0ZWAgZnVuY3Rpb24gYWNjZXB0cyB0d28gaW5wdXQgcGFyYW1ldGVyczogYHRpbWluZ2AgYW5kIGBzdHlsZXNgOlxuICAgICAqXG4gICAgICogLSBgdGltaW5nYCBpcyBhIHN0cmluZyBiYXNlZCB2YWx1ZSB0aGF0IGNhbiBiZSBhIGNvbWJpbmF0aW9uIG9mIGEgZHVyYXRpb24gd2l0aCBvcHRpb25hbFxuICAgICAqIGRlbGF5IGFuZCBlYXNpbmcgdmFsdWVzLiBUaGUgZm9ybWF0IGZvciB0aGUgZXhwcmVzc2lvbiBicmVha3MgZG93biB0byBgZHVyYXRpb24gZGVsYXkgZWFzaW5nYFxuICAgICAqICh0aGVyZWZvcmUgYSB2YWx1ZSBzdWNoIGFzIGAxcyAxMDBtcyBlYXNlLW91dGAgd2lsbCBiZSBwYXJzZSBpdHNlbGYgaW50byBgZHVyYXRpb249MTAwMCxcbiAgICAgKiBkZWxheT0xMDAsIGVhc2luZz1lYXNlLW91dGAuXG4gICAgICogSWYgYSBudW1lcmljIHZhbHVlIGlzIHByb3ZpZGVkIHRoZW4gdGhhdCB3aWxsIGJlIHVzZWQgYXMgdGhlIGBkdXJhdGlvbmAgdmFsdWUgaW4gbWlsbGlzZWNvbmRcbiAgICAgKiBmb3JtLlxuICAgICAqIC0gYHN0eWxlc2AgaXMgdGhlIHN0eWxlIGlucHV0IGRhdGEgd2hpY2ggY2FuIGVpdGhlciBiZSBhIGNhbGwgdG8ge0BsaW5rIHN0eWxlIHN0eWxlfSBvciB7QGxpbmtcbiAgICAgKiBrZXlmcmFtZXMga2V5ZnJhbWVzfS5cbiAgICAgKiBJZiBsZWZ0IGVtcHR5IHRoZW4gdGhlIHN0eWxlcyBmcm9tIHRoZSBkZXN0aW5hdGlvbiBzdGF0ZSB3aWxsIGJlIGNvbGxlY3RlZCBhbmQgdXNlZCAodGhpcyBpc1xuICAgICAqIHVzZWZ1bCB3aGVuXG4gICAgICogZGVzY3JpYmluZyBhbiBhbmltYXRpb24gc3RlcCB0aGF0IHdpbGwgY29tcGxldGUgYW4gYW5pbWF0aW9uIGJ5IHtAbGlua1xuICAgICAqIHRyYW5zaXRpb24jdGhlLWZpbmFsLWFuaW1hdGUtY2FsbCBhbmltYXRpbmcgdG8gdGhlIGZpbmFsIHN0YXRlfSkuXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogLy8gdmFyaW91cyBmdW5jdGlvbnMgZm9yIHNwZWNpZnlpbmcgdGltaW5nIGRhdGFcbiAgICAgKiBhbmltYXRlKDUwMCwgc3R5bGUoLi4uKSlcbiAgICAgKiBhbmltYXRlKFwiMXNcIiwgc3R5bGUoLi4uKSlcbiAgICAgKiBhbmltYXRlKFwiMTAwbXMgMC41c1wiLCBzdHlsZSguLi4pKVxuICAgICAqIGFuaW1hdGUoXCI1cyBlYXNlXCIsIHN0eWxlKC4uLikpXG4gICAgICogYW5pbWF0ZShcIjVzIDEwbXMgY3ViaWMtYmV6aWVyKC4xNywuNjcsLjg4LC4xKVwiLCBzdHlsZSguLi4pKVxuICAgICAqXG4gICAgICogLy8gZWl0aGVyIHN0eWxlKCkgb2Yga2V5ZnJhbWVzKCkgY2FuIGJlIHVzZWRcbiAgICAgKiBhbmltYXRlKDUwMCwgc3R5bGUoeyBiYWNrZ3JvdW5kOiBcInJlZFwiIH0pKVxuICAgICAqIGFuaW1hdGUoNTAwLCBrZXlmcmFtZXMoW1xuICAgICAqICAgc3R5bGUoeyBiYWNrZ3JvdW5kOiBcImJsdWVcIiB9KSksXG4gICAgICogICBzdHlsZSh7IGJhY2tncm91bmQ6IFwicmVkXCIgfSkpXG4gICAgICogXSlcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqICMjIyBFeGFtcGxlIChbbGl2ZSBkZW1vXShodHRwOi8vcGxua3IuY28vZWRpdC9LZXo4WEdXQnhXdWU3cVA3bk52Rj9wPXByZXZpZXcpKVxuICAgICAqXG4gICAgICoge0BleGFtcGxlIGNvcmUvYW5pbWF0aW9uL3RzL2RzbC9hbmltYXRpb25fZXhhbXBsZS50cyByZWdpb249J0NvbXBvbmVudCd9XG4gICAgICpcbiAgICAgKiBAZXhwZXJpbWVudGFsIEFuaW1hdGlvbiBzdXBwb3J0IGlzIGV4cGVyaW1lbnRhbC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhbmltYXRlKHRpbWluZywgc3R5bGVzKSB7XG4gICAgICAgIGlmIChzdHlsZXMgPT09IHZvaWQgMCkgeyBzdHlsZXMgPSBudWxsOyB9XG4gICAgICAgIHZhciBzdHlsZXNFbnRyeSA9IHN0eWxlcztcbiAgICAgICAgaWYgKCFpc1ByZXNlbnQoc3R5bGVzRW50cnkpKSB7XG4gICAgICAgICAgICB2YXIgRU1QVFlfU1RZTEUgPSB7fTtcbiAgICAgICAgICAgIHN0eWxlc0VudHJ5ID0gbmV3IEFuaW1hdGlvblN0eWxlTWV0YWRhdGEoW0VNUFRZX1NUWUxFXSwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBBbmltYXRpb25BbmltYXRlTWV0YWRhdGEodGltaW5nLCBzdHlsZXNFbnRyeSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBncm91cGAgaXMgYW4gYW5pbWF0aW9uLXNwZWNpZmljIGZ1bmN0aW9uIHRoYXQgaXMgZGVzaWduZWQgdG8gYmUgdXNlZCBpbnNpZGUgb2YgQW5ndWxhcjInc1xuICAgICAqIGFuaW1hdGlvblxuICAgICAqIERTTCBsYW5ndWFnZS4gSWYgdGhpcyBpbmZvcm1hdGlvbiBpcyBuZXcsIHBsZWFzZSBuYXZpZ2F0ZSB0byB0aGVcbiAgICAgKiB7QGxpbmsgQ29tcG9uZW50I2FuaW1hdGlvbnMtYW5jaG9yIGNvbXBvbmVudCBhbmltYXRpb25zIG1ldGFkYXRhXG4gICAgICogcGFnZX0gdG8gZ2FpbiBhIGJldHRlciB1bmRlcnN0YW5kaW5nIG9mIGhvdyBhbmltYXRpb25zIGluIEFuZ3VsYXIyIGFyZSB1c2VkLlxuICAgICAqXG4gICAgICogYGdyb3VwYCBzcGVjaWZpZXMgYSBsaXN0IG9mIGFuaW1hdGlvbiBzdGVwcyB0aGF0IGFyZSBhbGwgcnVuIGluIHBhcmFsbGVsLiBHcm91cGVkIGFuaW1hdGlvbnNcbiAgICAgKiBhcmUgdXNlZnVsIHdoZW4gYSBzZXJpZXMgb2Ygc3R5bGVzIG11c3QgYmUgYW5pbWF0ZWQvY2xvc2VkIG9mZlxuICAgICAqIGF0IGRpZmZlcmVudCBzdGF0cnRpbmcvZW5kaW5nIHRpbWVzLlxuICAgICAqXG4gICAgICogVGhlIGBncm91cGAgZnVuY3Rpb24gY2FuIGVpdGhlciBiZSB1c2VkIHdpdGhpbiBhIHtAbGluayBzZXF1ZW5jZSBzZXF1ZW5jZX0gb3IgYSB7QGxpbmsgdHJhbnNpdGlvblxuICAgICAqIHRyYW5zaXRpb259XG4gICAgICogYW5kIGl0IHdpbGwgb25seSBjb250aW51ZSB0byB0aGUgbmV4dCBpbnN0cnVjdGlvbiBvbmNlIGFsbCBvZiB0aGUgaW5uZXIgYW5pbWF0aW9uIHN0ZXBzXG4gICAgICogaGF2ZSBjb21wbGV0ZWQuXG4gICAgICpcbiAgICAgKiAjIyMgVXNhZ2VcbiAgICAgKlxuICAgICAqIFRoZSBgc3RlcHNgIGRhdGEgdGhhdCBpcyBwYXNzZWQgaW50byB0aGUgYGdyb3VwYCBhbmltYXRpb24gZnVuY3Rpb24gY2FuIGVpdGhlciBjb25zaXN0XG4gICAgICogb2Yge0BsaW5rIHN0eWxlIHN0eWxlfSBvciB7QGxpbmsgYW5pbWF0ZSBhbmltYXRlfSBmdW5jdGlvbiBjYWxscy4gRWFjaCBjYWxsIHRvIGBzdHlsZSgpYCBvclxuICAgICAqIGBhbmltYXRlKClgXG4gICAgICogd2l0aGluIGEgZ3JvdXAgd2lsbCBiZSBleGVjdXRlZCBpbnN0YW50bHkgKHVzZSB7QGxpbmsga2V5ZnJhbWVzIGtleWZyYW1lc30gb3IgYVxuICAgICAqIHtAbGluayBhbmltYXRlI3VzYWdlIGFuaW1hdGUoKSB3aXRoIGEgZGVsYXkgdmFsdWV9IHRvIG9mZnNldCBzdHlsZXMgdG8gYmUgYXBwbGllZCBhdCBhIGxhdGVyXG4gICAgICogdGltZSkuXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogZ3JvdXAoW1xuICAgICAqICAgYW5pbWF0ZShcIjFzXCIsIHsgYmFja2dyb3VuZDogXCJibGFja1wiIH0pKVxuICAgICAqICAgYW5pbWF0ZShcIjJzXCIsIHsgY29sb3I6IFwid2hpdGVcIiB9KSlcbiAgICAgKiBdKVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogIyMjIEV4YW1wbGUgKFtsaXZlIGRlbW9dKGh0dHA6Ly9wbG5rci5jby9lZGl0L0tlejhYR1dCeFd1ZTdxUDduTnZGP3A9cHJldmlldykpXG4gICAgICpcbiAgICAgKiB7QGV4YW1wbGUgY29yZS9hbmltYXRpb24vdHMvZHNsL2FuaW1hdGlvbl9leGFtcGxlLnRzIHJlZ2lvbj0nQ29tcG9uZW50J31cbiAgICAgKlxuICAgICAqIEBleHBlcmltZW50YWwgQW5pbWF0aW9uIHN1cHBvcnQgaXMgZXhwZXJpbWVudGFsLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdyb3VwKHN0ZXBzKSB7XG4gICAgICAgIHJldHVybiBuZXcgQW5pbWF0aW9uR3JvdXBNZXRhZGF0YShzdGVwcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBzZXF1ZW5jZWAgaXMgYW4gYW5pbWF0aW9uLXNwZWNpZmljIGZ1bmN0aW9uIHRoYXQgaXMgZGVzaWduZWQgdG8gYmUgdXNlZCBpbnNpZGUgb2YgQW5ndWxhcjInc1xuICAgICAqIGFuaW1hdGlvblxuICAgICAqIERTTCBsYW5ndWFnZS4gSWYgdGhpcyBpbmZvcm1hdGlvbiBpcyBuZXcsIHBsZWFzZSBuYXZpZ2F0ZSB0byB0aGVcbiAgICAgKiB7QGxpbmsgQ29tcG9uZW50I2FuaW1hdGlvbnMtYW5jaG9yIGNvbXBvbmVudCBhbmltYXRpb25zIG1ldGFkYXRhXG4gICAgICogcGFnZX0gdG8gZ2FpbiBhIGJldHRlciB1bmRlcnN0YW5kaW5nIG9mIGhvdyBhbmltYXRpb25zIGluIEFuZ3VsYXIyIGFyZSB1c2VkLlxuICAgICAqXG4gICAgICogYHNlcXVlbmNlYCBTcGVjaWZpZXMgYSBsaXN0IG9mIGFuaW1hdGlvbiBzdGVwcyB0aGF0IGFyZSBydW4gb25lIGJ5IG9uZS4gKGBzZXF1ZW5jZWAgaXMgdXNlZFxuICAgICAqIGJ5IGRlZmF1bHQgd2hlbiBhbiBhcnJheSBpcyBwYXNzZWQgYXMgYW5pbWF0aW9uIGRhdGEgaW50byB7QGxpbmsgdHJhbnNpdGlvbiB0cmFuc2l0aW9ufS4pXG4gICAgICpcbiAgICAgKiBUaGUgYHNlcXVlbmNlYCBmdW5jdGlvbiBjYW4gZWl0aGVyIGJlIHVzZWQgd2l0aGluIGEge0BsaW5rIGdyb3VwIGdyb3VwfSBvciBhIHtAbGluayB0cmFuc2l0aW9uXG4gICAgICogdHJhbnNpdGlvbn1cbiAgICAgKiBhbmQgaXQgd2lsbCBvbmx5IGNvbnRpbnVlIHRvIHRoZSBuZXh0IGluc3RydWN0aW9uIG9uY2UgZWFjaCBvZiB0aGUgaW5uZXIgYW5pbWF0aW9uIHN0ZXBzXG4gICAgICogaGF2ZSBjb21wbGV0ZWQuXG4gICAgICpcbiAgICAgKiBUbyBwZXJmb3JtIGFuaW1hdGlvbiBzdHlsaW5nIGluIHBhcmFsbGVsIHdpdGggb3RoZXIgYW5pbWF0aW9uIHN0ZXBzIHRoZW5cbiAgICAgKiBoYXZlIGEgbG9vayBhdCB0aGUge0BsaW5rIGdyb3VwIGdyb3VwfSBhbmltYXRpb24gZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiAjIyMgVXNhZ2VcbiAgICAgKlxuICAgICAqIFRoZSBgc3RlcHNgIGRhdGEgdGhhdCBpcyBwYXNzZWQgaW50byB0aGUgYHNlcXVlbmNlYCBhbmltYXRpb24gZnVuY3Rpb24gY2FuIGVpdGhlciBjb25zaXN0XG4gICAgICogb2Yge0BsaW5rIHN0eWxlIHN0eWxlfSBvciB7QGxpbmsgYW5pbWF0ZSBhbmltYXRlfSBmdW5jdGlvbiBjYWxscy4gQSBjYWxsIHRvIGBzdHlsZSgpYCB3aWxsIGFwcGx5XG4gICAgICogdGhlXG4gICAgICogcHJvdmlkZWQgc3R5bGluZyBkYXRhIGltbWVkaWF0ZWx5IHdoaWxlIGEgY2FsbCB0byBgYW5pbWF0ZSgpYCB3aWxsIGFwcGx5IGl0cyBzdHlsaW5nXG4gICAgICogZGF0YSBvdmVyIGEgZ2l2ZW4gdGltZSBkZXBlbmRpbmcgb24gaXRzIHRpbWluZyBkYXRhLlxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHNlcXVlbmNlKFtcbiAgICAgKiAgIHN0eWxlKHsgb3BhY2l0eTogMCB9KSksXG4gICAgICogICBhbmltYXRlKFwiMXNcIiwgeyBvcGFjaXR5OiAxIH0pKVxuICAgICAqIF0pXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQvS2V6OFhHV0J4V3VlN3FQN25OdkY/cD1wcmV2aWV3KSlcbiAgICAgKlxuICAgICAqIHtAZXhhbXBsZSBjb3JlL2FuaW1hdGlvbi90cy9kc2wvYW5pbWF0aW9uX2V4YW1wbGUudHMgcmVnaW9uPSdDb21wb25lbnQnfVxuICAgICAqXG4gICAgICogQGV4cGVyaW1lbnRhbCBBbmltYXRpb24gc3VwcG9ydCBpcyBleHBlcmltZW50YWwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2VxdWVuY2Uoc3RlcHMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBbmltYXRpb25TZXF1ZW5jZU1ldGFkYXRhKHN0ZXBzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYHN0eWxlYCBpcyBhbiBhbmltYXRpb24tc3BlY2lmaWMgZnVuY3Rpb24gdGhhdCBpcyBkZXNpZ25lZCB0byBiZSB1c2VkIGluc2lkZSBvZiBBbmd1bGFyMidzXG4gICAgICogYW5pbWF0aW9uXG4gICAgICogRFNMIGxhbmd1YWdlLiBJZiB0aGlzIGluZm9ybWF0aW9uIGlzIG5ldywgcGxlYXNlIG5hdmlnYXRlIHRvIHRoZVxuICAgICAqIHtAbGluayBDb21wb25lbnQjYW5pbWF0aW9ucy1hbmNob3IgY29tcG9uZW50IGFuaW1hdGlvbnMgbWV0YWRhdGFcbiAgICAgKiBwYWdlfSB0byBnYWluIGEgYmV0dGVyIHVuZGVyc3RhbmRpbmcgb2YgaG93IGFuaW1hdGlvbnMgaW4gQW5ndWxhcjIgYXJlIHVzZWQuXG4gICAgICpcbiAgICAgKiBgc3R5bGVgIGRlY2xhcmVzIGEga2V5L3ZhbHVlIG9iamVjdCBjb250YWluaW5nIENTUyBwcm9wZXJ0aWVzL3N0eWxlcyB0aGF0IGNhbiB0aGVuXG4gICAgICogYmUgdXNlZCBmb3Ige0BsaW5rIHN0YXRlIGFuaW1hdGlvbiBzdGF0ZXN9LCB3aXRoaW4gYW4ge0BsaW5rIHNlcXVlbmNlIGFuaW1hdGlvbiBzZXF1ZW5jZX0sIG9yIGFzXG4gICAgICogc3R5bGluZyBkYXRhIGZvciBib3RoIHtAbGluayBhbmltYXRlIGFuaW1hdGV9IGFuZCB7QGxpbmsga2V5ZnJhbWVzIGtleWZyYW1lc30uXG4gICAgICpcbiAgICAgKiAjIyMgVXNhZ2VcbiAgICAgKlxuICAgICAqIGBzdHlsZWAgdGFrZXMgaW4gYSBrZXkvdmFsdWUgc3RyaW5nIG1hcCBhcyBkYXRhIGFuZCBleHBlY3RzIG9uZSBvciBtb3JlIENTUyBwcm9wZXJ0eS92YWx1ZVxuICAgICAqIHBhaXJzIHRvIGJlIGRlZmluZWQuXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogLy8gc3RyaW5nIHZhbHVlcyBhcmUgdXNlZCBmb3IgY3NzIHByb3BlcnRpZXNcbiAgICAgKiBzdHlsZSh7IGJhY2tncm91bmQ6IFwicmVkXCIsIGNvbG9yOiBcImJsdWVcIiB9KVxuICAgICAqXG4gICAgICogLy8gbnVtZXJpY2FsIChwaXhlbCkgdmFsdWVzIGFyZSBhbHNvIHN1cHBvcnRlZFxuICAgICAqIHN0eWxlKHsgd2lkdGg6IDEwMCwgaGVpZ2h0OiAwIH0pXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiAjIyMjIEF1dG8tc3R5bGVzICh1c2luZyBgKmApXG4gICAgICpcbiAgICAgKiBXaGVuIGFuIGFzdGVyaXggKGAqYCkgY2hhcmFjdGVyIGlzIHVzZWQgYXMgYSB2YWx1ZSB0aGVuIGl0IHdpbGwgYmUgZGV0ZWN0ZWQgZnJvbSB0aGUgZWxlbWVudFxuICAgICAqIGJlaW5nIGFuaW1hdGVkXG4gICAgICogYW5kIGFwcGxpZWQgYXMgYW5pbWF0aW9uIGRhdGEgd2hlbiB0aGUgYW5pbWF0aW9uIHN0YXJ0cy5cbiAgICAgKlxuICAgICAqIFRoaXMgZmVhdHVyZSBwcm92ZXMgdXNlZnVsIGZvciBhIHN0YXRlIGRlcGVuZGluZyBvbiBsYXlvdXQgYW5kL29yIGVudmlyb25tZW50IGZhY3RvcnM7IGluIHN1Y2hcbiAgICAgKiBjYXNlc1xuICAgICAqIHRoZSBzdHlsZXMgYXJlIGNhbGN1bGF0ZWQganVzdCBiZWZvcmUgdGhlIGFuaW1hdGlvbiBzdGFydHMuXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogLy8gdGhlIHN0ZXBzIGJlbG93IHdpbGwgYW5pbWF0ZSBmcm9tIDAgdG8gdGhlXG4gICAgICogLy8gYWN0dWFsIGhlaWdodCBvZiB0aGUgZWxlbWVudFxuICAgICAqIHN0eWxlKHsgaGVpZ2h0OiAwIH0pLFxuICAgICAqIGFuaW1hdGUoXCIxc1wiLCBzdHlsZSh7IGhlaWdodDogXCIqXCIgfSkpXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQvS2V6OFhHV0J4V3VlN3FQN25OdkY/cD1wcmV2aWV3KSlcbiAgICAgKlxuICAgICAqIHtAZXhhbXBsZSBjb3JlL2FuaW1hdGlvbi90cy9kc2wvYW5pbWF0aW9uX2V4YW1wbGUudHMgcmVnaW9uPSdDb21wb25lbnQnfVxuICAgICAqXG4gICAgICogQGV4cGVyaW1lbnRhbCBBbmltYXRpb24gc3VwcG9ydCBpcyBleHBlcmltZW50YWwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3R5bGUodG9rZW5zKSB7XG4gICAgICAgIHZhciBpbnB1dDtcbiAgICAgICAgdmFyIG9mZnNldCA9IG51bGw7XG4gICAgICAgIGlmICh0eXBlb2YgdG9rZW5zID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaW5wdXQgPSBbdG9rZW5zXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRva2VucykpIHtcbiAgICAgICAgICAgICAgICBpbnB1dCA9IHRva2VucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlucHV0ID0gW3Rva2Vuc107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbnB1dC5mb3JFYWNoKGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICAgICAgICAgIHZhciBlbnRyeU9mZnNldCA9IGVudHJ5WydvZmZzZXQnXTtcbiAgICAgICAgICAgICAgICBpZiAoaXNQcmVzZW50KGVudHJ5T2Zmc2V0KSkge1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPT0gbnVsbCA/IHBhcnNlRmxvYXQoZW50cnlPZmZzZXQpIDogb2Zmc2V0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQW5pbWF0aW9uU3R5bGVNZXRhZGF0YShpbnB1dCwgb2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYHN0YXRlYCBpcyBhbiBhbmltYXRpb24tc3BlY2lmaWMgZnVuY3Rpb24gdGhhdCBpcyBkZXNpZ25lZCB0byBiZSB1c2VkIGluc2lkZSBvZiBBbmd1bGFyMidzXG4gICAgICogYW5pbWF0aW9uXG4gICAgICogRFNMIGxhbmd1YWdlLiBJZiB0aGlzIGluZm9ybWF0aW9uIGlzIG5ldywgcGxlYXNlIG5hdmlnYXRlIHRvIHRoZVxuICAgICAqIHtAbGluayBDb21wb25lbnQjYW5pbWF0aW9ucy1hbmNob3IgY29tcG9uZW50IGFuaW1hdGlvbnMgbWV0YWRhdGFcbiAgICAgKiBwYWdlfSB0byBnYWluIGEgYmV0dGVyIHVuZGVyc3RhbmRpbmcgb2YgaG93IGFuaW1hdGlvbnMgaW4gQW5ndWxhcjIgYXJlIHVzZWQuXG4gICAgICpcbiAgICAgKiBgc3RhdGVgIGRlY2xhcmVzIGFuIGFuaW1hdGlvbiBzdGF0ZSB3aXRoaW4gdGhlIGdpdmVuIHRyaWdnZXIuIFdoZW4gYSBzdGF0ZSBpc1xuICAgICAqIGFjdGl2ZSB3aXRoaW4gYSBjb21wb25lbnQgdGhlbiBpdHMgYXNzb2NpYXRlZCBzdHlsZXMgd2lsbCBwZXJzaXN0IG9uXG4gICAgICogdGhlIGVsZW1lbnQgdGhhdCB0aGUgdHJpZ2dlciBpcyBhdHRhY2hlZCB0byAoZXZlbiB3aGVuIHRoZSBhbmltYXRpb24gZW5kcykuXG4gICAgICpcbiAgICAgKiBUbyBhbmltYXRlIGJldHdlZW4gc3RhdGVzLCBoYXZlIGEgbG9vayBhdCB0aGUgYW5pbWF0aW9uIHtAbGluayB0cmFuc2l0aW9uIHRyYW5zaXRpb259XG4gICAgICogRFNMIGZ1bmN0aW9uLiBUbyByZWdpc3RlciBzdGF0ZXMgdG8gYW4gYW5pbWF0aW9uIHRyaWdnZXIgcGxlYXNlIGhhdmUgYSBsb29rXG4gICAgICogYXQgdGhlIHtAbGluayB0cmlnZ2VyIHRyaWdnZXJ9IGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogIyMjIyBUaGUgYHZvaWRgIHN0YXRlXG4gICAgICpcbiAgICAgKiBUaGUgYHZvaWRgIHN0YXRlIHZhbHVlIGlzIGEgcmVzZXJ2ZWQgd29yZCB0aGF0IGFuZ3VsYXIgdXNlcyB0byBkZXRlcm1pbmUgd2hlbiB0aGUgZWxlbWVudCBpcyBub3RcbiAgICAgKiBhcGFydFxuICAgICAqIG9mIHRoZSBhcHBsaWNhdGlvbiBhbnltb3JlIChlLmcuIHdoZW4gYW4gYG5nSWZgIGV2YWx1YXRlcyB0byBmYWxzZSB0aGVuIHRoZSBzdGF0ZSBvZiB0aGVcbiAgICAgKiBhc3NvY2lhdGVkIGVsZW1lbnRcbiAgICAgKiBpcyB2b2lkKS5cbiAgICAgKlxuICAgICAqICMjIyMgVGhlIGAqYCAoZGVmYXVsdCkgc3RhdGVcbiAgICAgKlxuICAgICAqIFRoZSBgKmAgc3RhdGUgKHdoZW4gc3R5bGVkKSBpcyBhIGZhbGxiYWNrIHN0YXRlIHRoYXQgd2lsbCBiZSB1c2VkIGlmXG4gICAgICogdGhlIHN0YXRlIHRoYXQgaXMgYmVpbmcgYW5pbWF0ZWQgaXMgbm90IGRlY2xhcmVkIHdpdGhpbiB0aGUgdHJpZ2dlci5cbiAgICAgKlxuICAgICAqICMjIyBVc2FnZVxuICAgICAqXG4gICAgICogYHN0YXRlYCB3aWxsIGRlY2xhcmUgYW4gYW5pbWF0aW9uIHN0YXRlIHdpdGggaXRzIGFzc29jaWF0ZWQgc3R5bGVzXG4gICAgICogd2l0aGluIHRoZSBnaXZlbiB0cmlnZ2VyLlxuICAgICAqXG4gICAgICogLSBgc3RhdGVOYW1lRXhwcmAgY2FuIGJlIG9uZSBvciBtb3JlIHN0YXRlIG5hbWVzIHNlcGFyYXRlZCBieSBjb21tYXMuXG4gICAgICogLSBgc3R5bGVzYCByZWZlcnMgdG8gdGhlIHtAbGluayBzdHlsZSBzdHlsaW5nIGRhdGF9IHRoYXQgd2lsbCBiZSBwZXJzaXN0ZWQgb24gdGhlIGVsZW1lbnQgb25jZVxuICAgICAqIHRoZSBzdGF0ZVxuICAgICAqIGhhcyBiZWVuIHJlYWNoZWQuXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogLy8gXCJ2b2lkXCIgaXMgYSByZXNlcnZlZCBuYW1lIGZvciBhIHN0YXRlIGFuZCBpcyB1c2VkIHRvIHJlcHJlc2VudFxuICAgICAqIC8vIHRoZSBzdGF0ZSBpbiB3aGljaCBhbiBlbGVtZW50IGlzIGRldGFjaGVkIGZyb20gZnJvbSB0aGUgYXBwbGljYXRpb24uXG4gICAgICogc3RhdGUoXCJ2b2lkXCIsIHN0eWxlKHsgaGVpZ2h0OiAwIH0pKVxuICAgICAqXG4gICAgICogLy8gdXNlci1kZWZpbmVkIHN0YXRlc1xuICAgICAqIHN0YXRlKFwiY2xvc2VkXCIsIHN0eWxlKHsgaGVpZ2h0OiAwIH0pKVxuICAgICAqIHN0YXRlKFwib3BlbiwgdmlzaWJsZVwiLCBzdHlsZSh7IGhlaWdodDogXCIqXCIgfSkpXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQvS2V6OFhHV0J4V3VlN3FQN25OdkY/cD1wcmV2aWV3KSlcbiAgICAgKlxuICAgICAqIHtAZXhhbXBsZSBjb3JlL2FuaW1hdGlvbi90cy9kc2wvYW5pbWF0aW9uX2V4YW1wbGUudHMgcmVnaW9uPSdDb21wb25lbnQnfVxuICAgICAqXG4gICAgICogQGV4cGVyaW1lbnRhbCBBbmltYXRpb24gc3VwcG9ydCBpcyBleHBlcmltZW50YWwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3RhdGUoc3RhdGVOYW1lRXhwciwgc3R5bGVzKSB7XG4gICAgICAgIHJldHVybiBuZXcgQW5pbWF0aW9uU3RhdGVEZWNsYXJhdGlvbk1ldGFkYXRhKHN0YXRlTmFtZUV4cHIsIHN0eWxlcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBrZXlmcmFtZXNgIGlzIGFuIGFuaW1hdGlvbi1zcGVjaWZpYyBmdW5jdGlvbiB0aGF0IGlzIGRlc2lnbmVkIHRvIGJlIHVzZWQgaW5zaWRlIG9mIEFuZ3VsYXIyJ3NcbiAgICAgKiBhbmltYXRpb25cbiAgICAgKiBEU0wgbGFuZ3VhZ2UuIElmIHRoaXMgaW5mb3JtYXRpb24gaXMgbmV3LCBwbGVhc2UgbmF2aWdhdGUgdG8gdGhlXG4gICAgICoge0BsaW5rIENvbXBvbmVudCNhbmltYXRpb25zLWFuY2hvciBjb21wb25lbnQgYW5pbWF0aW9ucyBtZXRhZGF0YVxuICAgICAqIHBhZ2V9IHRvIGdhaW4gYSBiZXR0ZXIgdW5kZXJzdGFuZGluZyBvZiBob3cgYW5pbWF0aW9ucyBpbiBBbmd1bGFyMiBhcmUgdXNlZC5cbiAgICAgKlxuICAgICAqIGBrZXlmcmFtZXNgIHNwZWNpZmllcyBhIGNvbGxlY3Rpb24gb2Yge0BsaW5rIHN0eWxlIHN0eWxlfSBlbnRyaWVzIGVhY2ggb3B0aW9uYWxseSBjaGFyYWN0ZXJpemVkXG4gICAgICogYnkgYW4gYG9mZnNldGAgdmFsdWUuXG4gICAgICpcbiAgICAgKiAjIyMgVXNhZ2VcbiAgICAgKlxuICAgICAqIFRoZSBga2V5ZnJhbWVzYCBhbmltYXRpb24gZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgdXNlZCBhbG9uZ3NpZGUgdGhlIHtAbGluayBhbmltYXRlIGFuaW1hdGV9XG4gICAgICogYW5pbWF0aW9uIGZ1bmN0aW9uLiBJbnN0ZWFkIG9mIGFwcGx5aW5nIGFuaW1hdGlvbnMgZnJvbSB3aGVyZSB0aGV5IGFyZVxuICAgICAqIGN1cnJlbnRseSB0byB0aGVpciBkZXN0aW5hdGlvbiwga2V5ZnJhbWVzIGNhbiBkZXNjcmliZSBob3cgZWFjaCBzdHlsZSBlbnRyeSBpcyBhcHBsaWVkXG4gICAgICogYW5kIGF0IHdoYXQgcG9pbnQgd2l0aGluIHRoZSBhbmltYXRpb24gYXJjIChtdWNoIGxpa2UgQ1NTIEtleWZyYW1lIEFuaW1hdGlvbnMgZG8pLlxuICAgICAqXG4gICAgICogRm9yIGVhY2ggYHN0eWxlKClgIGVudHJ5IGFuIGBvZmZzZXRgIHZhbHVlIGNhbiBiZSBzZXQuIERvaW5nIHNvIGFsbG93cyB0byBzcGVjaWZpeSBhdFxuICAgICAqIHdoYXQgcGVyY2VudGFnZSBvZiB0aGUgYW5pbWF0ZSB0aW1lIHRoZSBzdHlsZXMgd2lsbCBiZSBhcHBsaWVkLlxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIC8vIHRoZSBwcm92aWRlZCBvZmZzZXQgdmFsdWVzIGRlc2NyaWJlIHdoZW4gZWFjaCBiYWNrZ3JvdW5kQ29sb3IgdmFsdWUgaXMgYXBwbGllZC5cbiAgICAgKiBhbmltYXRlKFwiNXNcIiwga2V5ZnJhbWVzKFtcbiAgICAgKiAgIHN0eWxlKHsgYmFja2dyb3VuZENvbG9yOiBcInJlZFwiLCBvZmZzZXQ6IDAgfSksXG4gICAgICogICBzdHlsZSh7IGJhY2tncm91bmRDb2xvcjogXCJibHVlXCIsIG9mZnNldDogMC4yIH0pLFxuICAgICAqICAgc3R5bGUoeyBiYWNrZ3JvdW5kQ29sb3I6IFwib3JhbmdlXCIsIG9mZnNldDogMC4zIH0pLFxuICAgICAqICAgc3R5bGUoeyBiYWNrZ3JvdW5kQ29sb3I6IFwiYmxhY2tcIiwgb2Zmc2V0OiAxIH0pXG4gICAgICogXSkpXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBBbHRlcm5hdGl2ZWx5LCBpZiB0aGVyZSBhcmUgbm8gYG9mZnNldGAgdmFsdWVzIHVzZWQgd2l0aGluIHRoZSBzdHlsZSBlbnRyaWVzIHRoZW4gdGhlIG9mZnNldHNcbiAgICAgKiB3aWxsXG4gICAgICogYmUgY2FsY3VsYXRlZCBhdXRvbWF0aWNhbGx5LlxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGFuaW1hdGUoXCI1c1wiLCBrZXlmcmFtZXMoW1xuICAgICAqICAgc3R5bGUoeyBiYWNrZ3JvdW5kQ29sb3I6IFwicmVkXCIgfSkgLy8gb2Zmc2V0ID0gMFxuICAgICAqICAgc3R5bGUoeyBiYWNrZ3JvdW5kQ29sb3I6IFwiYmx1ZVwiIH0pIC8vIG9mZnNldCA9IDAuMzNcbiAgICAgKiAgIHN0eWxlKHsgYmFja2dyb3VuZENvbG9yOiBcIm9yYW5nZVwiIH0pIC8vIG9mZnNldCA9IDAuNjZcbiAgICAgKiAgIHN0eWxlKHsgYmFja2dyb3VuZENvbG9yOiBcImJsYWNrXCIgfSkgLy8gb2Zmc2V0ID0gMVxuICAgICAqIF0pKVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogIyMjIEV4YW1wbGUgKFtsaXZlIGRlbW9dKGh0dHA6Ly9wbG5rci5jby9lZGl0L0tlejhYR1dCeFd1ZTdxUDduTnZGP3A9cHJldmlldykpXG4gICAgICpcbiAgICAgKiB7QGV4YW1wbGUgY29yZS9hbmltYXRpb24vdHMvZHNsL2FuaW1hdGlvbl9leGFtcGxlLnRzIHJlZ2lvbj0nQ29tcG9uZW50J31cbiAgICAgKlxuICAgICAqIEBleHBlcmltZW50YWwgQW5pbWF0aW9uIHN1cHBvcnQgaXMgZXhwZXJpbWVudGFsLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGtleWZyYW1lcyhzdGVwcykge1xuICAgICAgICByZXR1cm4gbmV3IEFuaW1hdGlvbktleWZyYW1lc1NlcXVlbmNlTWV0YWRhdGEoc3RlcHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgdHJhbnNpdGlvbmAgaXMgYW4gYW5pbWF0aW9uLXNwZWNpZmljIGZ1bmN0aW9uIHRoYXQgaXMgZGVzaWduZWQgdG8gYmUgdXNlZCBpbnNpZGUgb2YgQW5ndWxhcjInc1xuICAgICAqIGFuaW1hdGlvblxuICAgICAqIERTTCBsYW5ndWFnZS4gSWYgdGhpcyBpbmZvcm1hdGlvbiBpcyBuZXcsIHBsZWFzZSBuYXZpZ2F0ZSB0byB0aGVcbiAgICAgKiB7QGxpbmsgQ29tcG9uZW50I2FuaW1hdGlvbnMtYW5jaG9yIGNvbXBvbmVudCBhbmltYXRpb25zIG1ldGFkYXRhXG4gICAgICogcGFnZX0gdG8gZ2FpbiBhIGJldHRlciB1bmRlcnN0YW5kaW5nIG9mIGhvdyBhbmltYXRpb25zIGluIEFuZ3VsYXIyIGFyZSB1c2VkLlxuICAgICAqXG4gICAgICogYHRyYW5zaXRpb25gIGRlY2xhcmVzIHRoZSB7QGxpbmsgc2VxdWVuY2Ugc2VxdWVuY2Ugb2YgYW5pbWF0aW9uIHN0ZXBzfSB0aGF0IHdpbGwgYmUgcnVuIHdoZW4gdGhlXG4gICAgICogcHJvdmlkZWRcbiAgICAgKiBgc3RhdGVDaGFuZ2VFeHByYCB2YWx1ZSBpcyBzYXRpc2ZpZWQuIFRoZSBgc3RhdGVDaGFuZ2VFeHByYCBjb25zaXN0cyBvZiBhIGBzdGF0ZTEgPT4gc3RhdGUyYFxuICAgICAqIHdoaWNoIGNvbnNpc3RzXG4gICAgICogb2YgdHdvIGtub3duIHN0YXRlcyAodXNlIGFuIGFzdGVyaXggKGAqYCkgdG8gcmVmZXIgdG8gYSBkeW5hbWljIHN0YXJ0aW5nIGFuZC9vciBlbmRpbmcgc3RhdGUpLlxuICAgICAqXG4gICAgICogQW5pbWF0aW9uIHRyYW5zaXRpb25zIGFyZSBwbGFjZWQgd2l0aGluIGFuIHtAbGluayB0cmlnZ2VyIGFuaW1hdGlvbiB0cmlnZ2VyfS4gRm9yIGFuIHRyYW5zaXRpb25cbiAgICAgKiB0byBhbmltYXRlIHRvXG4gICAgICogYSBzdGF0ZSB2YWx1ZSBhbmQgcGVyc2lzdCBpdHMgc3R5bGVzIHRoZW4gb25lIG9yIG1vcmUge0BsaW5rIHN0YXRlIGFuaW1hdGlvbiBzdGF0ZXN9IGlzIGV4cGVjdGVkXG4gICAgICogdG8gYmUgZGVmaW5lZC5cbiAgICAgKlxuICAgICAqICMjIyBVc2FnZVxuICAgICAqXG4gICAgICogQW4gYW5pbWF0aW9uIHRyYW5zaXRpb24gaXMga2lja2VkIG9mZiB0aGUgYHN0YXRlQ2hhbmdlRXhwcmAgcHJlZGljYXRlIGV2YWx1YXRlcyB0byB0cnVlIGJhc2VkIG9uXG4gICAgICogd2hhdCB0aGVcbiAgICAgKiBwcmV2aW91cyBzdGF0ZSBpcyBhbmQgd2hhdCB0aGUgY3VycmVudCBzdGF0ZSBoYXMgYmVjb21lLiBJbiBvdGhlciB3b3JkcywgaWYgYSB0cmFuc2l0aW9uIGlzXG4gICAgICogZGVmaW5lZCB0aGF0XG4gICAgICogbWF0Y2hlcyB0aGUgb2xkL2N1cnJlbnQgc3RhdGUgY3JpdGVyaWEgdGhlbiB0aGUgYXNzb2NpYXRlZCBhbmltYXRpb24gd2lsbCBiZSB0cmlnZ2VyZWQuXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogLy8gYWxsIHRyYW5zaXRpb24vc3RhdGUgY2hhbmdlcyBhcmUgZGVmaW5lZCB3aXRoaW4gYW4gYW5pbWF0aW9uIHRyaWdnZXJcbiAgICAgKiB0cmlnZ2VyKFwibXlBbmltYXRpb25UcmlnZ2VyXCIsIFtcbiAgICAgKiAgIC8vIGlmIGEgc3RhdGUgaXMgZGVmaW5lZCB0aGVuIGl0cyBzdHlsZXMgd2lsbCBiZSBwZXJzaXN0ZWQgd2hlbiB0aGVcbiAgICAgKiAgIC8vIGFuaW1hdGlvbiBoYXMgZnVsbHkgY29tcGxldGVkIGl0c2VsZlxuICAgICAqICAgc3RhdGUoXCJvblwiLCBzdHlsZSh7IGJhY2tncm91bmQ6IFwiZ3JlZW5cIiB9KSksXG4gICAgICogICBzdGF0ZShcIm9mZlwiLCBzdHlsZSh7IGJhY2tncm91bmQ6IFwiZ3JleVwiIH0pKSxcbiAgICAgKlxuICAgICAqICAgLy8gYSB0cmFuc2l0aW9uIGFuaW1hdGlvbiB0aGF0IHdpbGwgYmUga2lja2VkIG9mZiB3aGVuIHRoZSBzdGF0ZSB2YWx1ZVxuICAgICAqICAgLy8gYm91bmQgdG8gXCJteUFuaW1hdGlvblRyaWdnZXJcIiBjaGFuZ2VzIGZyb20gXCJvblwiIHRvIFwib2ZmXCJcbiAgICAgKiAgIHRyYW5zaXRpb24oXCJvbiA9PiBvZmZcIiwgYW5pbWF0ZSg1MDApKSxcbiAgICAgKlxuICAgICAqICAgLy8gaXQgaXMgYWxzbyBwb3NzaWJsZSB0byBkbyBydW4gdGhlIHNhbWUgYW5pbWF0aW9uIGZvciBib3RoIGRpcmVjdGlvbnNcbiAgICAgKiAgIHRyYW5zaXRpb24oXCJvbiA8PT4gb2ZmXCIsIGFuaW1hdGUoNTAwKSksXG4gICAgICpcbiAgICAgKiAgIC8vIG9yIHRvIGRlZmluZSBtdWx0aXBsZSBzdGF0ZXMgcGFpcnMgc2VwYXJhdGVkIGJ5IGNvbW1hc1xuICAgICAqICAgdHJhbnNpdGlvbihcIm9uID0+IG9mZiwgb2ZmID0+IHZvaWRcIiwgYW5pbWF0ZSg1MDApKSxcbiAgICAgKlxuICAgICAqICAgLy8gdGhpcyBpcyBhIGNhdGNoLWFsbCBzdGF0ZSBjaGFuZ2UgZm9yIHdoZW4gYW4gZWxlbWVudCBpcyBpbnNlcnRlZCBpbnRvXG4gICAgICogICAvLyB0aGUgcGFnZSBhbmQgdGhlIGRlc3RpbmF0aW9uIHN0YXRlIGlzIHVua25vd25cbiAgICAgKiAgIHRyYW5zaXRpb24oXCJ2b2lkID0+ICpcIiwgW1xuICAgICAqICAgICBzdHlsZSh7IG9wYWNpdHk6IDAgfSksXG4gICAgICogICAgIGFuaW1hdGUoNTAwKVxuICAgICAqICAgXSksXG4gICAgICpcbiAgICAgKiAgIC8vIHRoaXMgd2lsbCBjYXB0dXJlIGEgc3RhdGUgY2hhbmdlIGJldHdlZW4gYW55IHN0YXRlc1xuICAgICAqICAgdHJhbnNpdGlvbihcIiogPT4gKlwiLCBhbmltYXRlKFwiMXMgMHNcIikpLFxuICAgICAqIF0pXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBUaGUgdGVtcGxhdGUgYXNzb2NpYXRlZCB3aXRoIHRoaXMgY29tcG9uZW50IHdpbGwgbWFrZSB1c2Ugb2YgdGhlIGBteUFuaW1hdGlvblRyaWdnZXJgXG4gICAgICogYW5pbWF0aW9uIHRyaWdnZXIgYnkgYmluZGluZyB0byBhbiBlbGVtZW50IHdpdGhpbiBpdHMgdGVtcGxhdGUgY29kZS5cbiAgICAgKlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8IS0tIHNvbWV3aGVyZSBpbnNpZGUgb2YgbXktY29tcG9uZW50LXRwbC5odG1sIC0tPlxuICAgICAqIDxkaXYgW0BteUFuaW1hdGlvblRyaWdnZXJdPVwibXlTdGF0dXNFeHBcIj4uLi48L2Rpdj5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqICMjIyMgVGhlIGZpbmFsIGBhbmltYXRlYCBjYWxsXG4gICAgICpcbiAgICAgKiBJZiB0aGUgZmluYWwgc3RlcCB3aXRoaW4gdGhlIHRyYW5zaXRpb24gc3RlcHMgaXMgYSBjYWxsIHRvIGBhbmltYXRlKClgIHRoYXQgKipvbmx5KipcbiAgICAgKiB1c2VzIGEgdGltaW5nIHZhbHVlIHdpdGggKipubyBzdHlsZSBkYXRhKiogdGhlbiBpdCB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgdXNlZCBhcyB0aGUgZmluYWxcbiAgICAgKiBhbmltYXRpb25cbiAgICAgKiBhcmMgZm9yIHRoZSBlbGVtZW50IHRvIGFuaW1hdGUgaXRzZWxmIHRvIHRoZSBmaW5hbCBzdGF0ZS4gVGhpcyBpbnZvbHZlcyBhbiBhdXRvbWF0aWMgbWl4IG9mXG4gICAgICogYWRkaW5nL3JlbW92aW5nIENTUyBzdHlsZXMgc28gdGhhdCB0aGUgZWxlbWVudCB3aWxsIGJlIGluIHRoZSBleGFjdCBzdGF0ZSBpdCBzaG91bGQgYmUgZm9yIHRoZVxuICAgICAqIGFwcGxpZWQgc3RhdGUgdG8gYmUgcHJlc2VudGVkIGNvcnJlY3RseS5cbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIC8vIHN0YXJ0IG9mZiBieSBoaWRpbmcgdGhlIGVsZW1lbnQsIGJ1dCBtYWtlIHN1cmUgdGhhdCBpdCBhbmltYXRlcyBwcm9wZXJseSB0byB3aGF0ZXZlciBzdGF0ZVxuICAgICAqIC8vIGlzIGN1cnJlbnRseSBhY3RpdmUgZm9yIFwibXlBbmltYXRpb25UcmlnZ2VyXCJcbiAgICAgKiB0cmFuc2l0aW9uKFwidm9pZCA9PiAqXCIsIFtcbiAgICAgKiAgIHN0eWxlKHsgb3BhY2l0eTogMCB9KSxcbiAgICAgKiAgIGFuaW1hdGUoNTAwKVxuICAgICAqIF0pXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiAjIyMgVHJhbnNpdGlvbiBBbGlhc2VzIChgOmVudGVyYCBhbmQgYDpsZWF2ZWApXG4gICAgICpcbiAgICAgKiBHaXZlbiB0aGF0IGVudGVyIChpbnNlcnRpb24pIGFuZCBsZWF2ZSAocmVtb3ZhbCkgYW5pbWF0aW9ucyBhcmUgc28gY29tbW9uLFxuICAgICAqIHRoZSBgdHJhbnNpdGlvbmAgZnVuY3Rpb24gYWNjZXB0cyBib3RoIGA6ZW50ZXJgIGFuZCBgOmxlYXZlYCB2YWx1ZXMgd2hpY2hcbiAgICAgKiBhcmUgYWxpYXNlcyBmb3IgdGhlIGB2b2lkID0+ICpgIGFuZCBgKiA9PiB2b2lkYCBzdGF0ZSBjaGFuZ2VzLlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogdHJhbnNpdGlvbihcIjplbnRlclwiLCBbXG4gICAgICogICBzdHlsZSh7IG9wYWNpdHk6IDAgfSksXG4gICAgICogICBhbmltYXRlKDUwMCwgc3R5bGUoeyBvcGFjaXR5OiAxIH0pKVxuICAgICAqIF0pXG4gICAgICogdHJhbnNpdGlvbihcIjpsZWF2ZVwiLCBbXG4gICAgICogICBhbmltYXRlKDUwMCwgc3R5bGUoeyBvcGFjaXR5OiAwIH0pKVxuICAgICAqIF0pXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQvS2V6OFhHV0J4V3VlN3FQN25OdkY/cD1wcmV2aWV3KSlcbiAgICAgKlxuICAgICAqIHtAZXhhbXBsZSBjb3JlL2FuaW1hdGlvbi90cy9kc2wvYW5pbWF0aW9uX2V4YW1wbGUudHMgcmVnaW9uPSdDb21wb25lbnQnfVxuICAgICAqXG4gICAgICogQGV4cGVyaW1lbnRhbCBBbmltYXRpb24gc3VwcG9ydCBpcyBleHBlcmltZW50YWwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJhbnNpdGlvbihzdGF0ZUNoYW5nZUV4cHIsIHN0ZXBzKSB7XG4gICAgICAgIHZhciBhbmltYXRpb25EYXRhID0gQXJyYXkuaXNBcnJheShzdGVwcykgPyBuZXcgQW5pbWF0aW9uU2VxdWVuY2VNZXRhZGF0YShzdGVwcykgOiBzdGVwcztcbiAgICAgICAgcmV0dXJuIG5ldyBBbmltYXRpb25TdGF0ZVRyYW5zaXRpb25NZXRhZGF0YShzdGF0ZUNoYW5nZUV4cHIsIGFuaW1hdGlvbkRhdGEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgdHJpZ2dlcmAgaXMgYW4gYW5pbWF0aW9uLXNwZWNpZmljIGZ1bmN0aW9uIHRoYXQgaXMgZGVzaWduZWQgdG8gYmUgdXNlZCBpbnNpZGUgb2YgQW5ndWxhcjInc1xuICAgICAqIGFuaW1hdGlvblxuICAgICAqIERTTCBsYW5ndWFnZS4gSWYgdGhpcyBpbmZvcm1hdGlvbiBpcyBuZXcsIHBsZWFzZSBuYXZpZ2F0ZSB0byB0aGVcbiAgICAgKiB7QGxpbmsgQ29tcG9uZW50I2FuaW1hdGlvbnMtYW5jaG9yIGNvbXBvbmVudCBhbmltYXRpb25zIG1ldGFkYXRhXG4gICAgICogcGFnZX0gdG8gZ2FpbiBhIGJldHRlciB1bmRlcnN0YW5kaW5nIG9mIGhvdyBhbmltYXRpb25zIGluIEFuZ3VsYXIyIGFyZSB1c2VkLlxuICAgICAqXG4gICAgICogYHRyaWdnZXJgIENyZWF0ZXMgYW4gYW5pbWF0aW9uIHRyaWdnZXIgd2hpY2ggd2lsbCBhIGxpc3Qgb2Yge0BsaW5rIHN0YXRlIHN0YXRlfSBhbmQge0BsaW5rXG4gICAgICogdHJhbnNpdGlvbiB0cmFuc2l0aW9ufVxuICAgICAqIGVudHJpZXMgdGhhdCB3aWxsIGJlIGV2YWx1YXRlZCB3aGVuIHRoZSBleHByZXNzaW9uIGJvdW5kIHRvIHRoZSB0cmlnZ2VyIGNoYW5nZXMuXG4gICAgICpcbiAgICAgKiBUcmlnZ2VycyBhcmUgcmVnaXN0ZXJlZCB3aXRoaW4gdGhlIGNvbXBvbmVudCBhbm5vdGF0aW9uIGRhdGEgdW5kZXIgdGhlXG4gICAgICoge0BsaW5rIENvbXBvbmVudCNhbmltYXRpb25zLWFuY2hvciBhbmltYXRpb25zIHNlY3Rpb259LiBBbiBhbmltYXRpb24gdHJpZ2dlciBjYW5cbiAgICAgKiBiZSBwbGFjZWQgb24gYW4gZWxlbWVudCB3aXRoaW4gYSB0ZW1wbGF0ZSBieSByZWZlcmVuY2luZyB0aGUgbmFtZSBvZiB0aGVcbiAgICAgKiB0cmlnZ2VyIGZvbGxvd2VkIGJ5IHRoZSBleHByZXNzaW9uIHZhbHVlIHRoYXQgdGhlIHRyaWdnZXIgaXMgYm91bmQgdG9cbiAgICAgKiAoaW4gdGhlIGZvcm0gb2YgYFtAdHJpZ2dlck5hbWVdPVwiZXhwcmVzc2lvblwiYC5cbiAgICAgKlxuICAgICAqICMjIyBVc2FnZVxuICAgICAqXG4gICAgICogYHRyaWdnZXJgIHdpbGwgY3JlYXRlIGFuIGFuaW1hdGlvbiB0cmlnZ2VyIHJlZmVyZW5jZSBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgYG5hbWVgIHZhbHVlLlxuICAgICAqIFRoZSBwcm92aWRlZCBgYW5pbWF0aW9uYCB2YWx1ZSBpcyBleHBlY3RlZCB0byBiZSBhbiBhcnJheSBjb25zaXN0aW5nIG9mIHtAbGluayBzdGF0ZSBzdGF0ZX0gYW5kXG4gICAgICoge0BsaW5rIHRyYW5zaXRpb24gdHJhbnNpdGlvbn1cbiAgICAgKiBkZWNsYXJhdGlvbnMuXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogQENvbXBvbmVudCh7XG4gICAgICogICBzZWxlY3RvcjogJ215LWNvbXBvbmVudCcsXG4gICAgICogICB0ZW1wbGF0ZVVybDogJ215LWNvbXBvbmVudC10cGwuaHRtbCcsXG4gICAgICogICBhbmltYXRpb25zOiBbXG4gICAgICogICAgIHRyaWdnZXIoXCJteUFuaW1hdGlvblRyaWdnZXJcIiwgW1xuICAgICAqICAgICAgIHN0YXRlKC4uLiksXG4gICAgICogICAgICAgc3RhdGUoLi4uKSxcbiAgICAgKiAgICAgICB0cmFuc2l0aW9uKC4uLiksXG4gICAgICogICAgICAgdHJhbnNpdGlvbiguLi4pXG4gICAgICogICAgIF0pXG4gICAgICogICBdXG4gICAgICogfSlcbiAgICAgKiBjbGFzcyBNeUNvbXBvbmVudCB7XG4gICAgICogICBteVN0YXR1c0V4cCA9IFwic29tZXRoaW5nXCI7XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogVGhlIHRlbXBsYXRlIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGNvbXBvbmVudCB3aWxsIG1ha2UgdXNlIG9mIHRoZSBgbXlBbmltYXRpb25UcmlnZ2VyYFxuICAgICAqIGFuaW1hdGlvbiB0cmlnZ2VyIGJ5IGJpbmRpbmcgdG8gYW4gZWxlbWVudCB3aXRoaW4gaXRzIHRlbXBsYXRlIGNvZGUuXG4gICAgICpcbiAgICAgKiBgYGBodG1sXG4gICAgICogPCEtLSBzb21ld2hlcmUgaW5zaWRlIG9mIG15LWNvbXBvbmVudC10cGwuaHRtbCAtLT5cbiAgICAgKiA8ZGl2IFtAbXlBbmltYXRpb25UcmlnZ2VyXT1cIm15U3RhdHVzRXhwXCI+Li4uPC9kaXY+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQvS2V6OFhHV0J4V3VlN3FQN25OdkY/cD1wcmV2aWV3KSlcbiAgICAgKlxuICAgICAqIHtAZXhhbXBsZSBjb3JlL2FuaW1hdGlvbi90cy9kc2wvYW5pbWF0aW9uX2V4YW1wbGUudHMgcmVnaW9uPSdDb21wb25lbnQnfVxuICAgICAqXG4gICAgICogQGV4cGVyaW1lbnRhbCBBbmltYXRpb24gc3VwcG9ydCBpcyBleHBlcmltZW50YWwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJpZ2dlcihuYW1lLCBhbmltYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBbmltYXRpb25FbnRyeU1ldGFkYXRhKG5hbWUsIGFuaW1hdGlvbik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJlcGFyZUZpbmFsQW5pbWF0aW9uU3R5bGVzKHByZXZpb3VzU3R5bGVzLCBuZXdTdHlsZXMsIG51bGxWYWx1ZSkge1xuICAgICAgICBpZiAobnVsbFZhbHVlID09PSB2b2lkIDApIHsgbnVsbFZhbHVlID0gbnVsbDsgfVxuICAgICAgICB2YXIgZmluYWxTdHlsZXMgPSB7fTtcbiAgICAgICAgT2JqZWN0LmtleXMobmV3U3R5bGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBuZXdTdHlsZXNbcHJvcF07XG4gICAgICAgICAgICBmaW5hbFN0eWxlc1twcm9wXSA9IHZhbHVlID09IEFVVE9fU1RZTEUgPyBudWxsVmFsdWUgOiB2YWx1ZS50b1N0cmluZygpO1xuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmtleXMocHJldmlvdXNTdHlsZXMpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICAgIGlmICghaXNQcmVzZW50KGZpbmFsU3R5bGVzW3Byb3BdKSkge1xuICAgICAgICAgICAgICAgIGZpbmFsU3R5bGVzW3Byb3BdID0gbnVsbFZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZpbmFsU3R5bGVzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBiYWxhbmNlQW5pbWF0aW9uS2V5ZnJhbWVzKGNvbGxlY3RlZFN0eWxlcywgZmluYWxTdGF0ZVN0eWxlcywga2V5ZnJhbWVzKSB7XG4gICAgICAgIHZhciBsaW1pdCA9IGtleWZyYW1lcy5sZW5ndGggLSAxO1xuICAgICAgICB2YXIgZmlyc3RLZXlmcmFtZSA9IGtleWZyYW1lc1swXTtcbiAgICAgICAgLy8gcGhhc2UgMTogY29weSBhbGwgdGhlIHN0eWxlcyBmcm9tIHRoZSBmaXJzdCBrZXlmcmFtZSBpbnRvIHRoZSBsb29rdXAgbWFwXG4gICAgICAgIHZhciBmbGF0ZW5lZEZpcnN0S2V5ZnJhbWVTdHlsZXMgPSBmbGF0dGVuU3R5bGVzKGZpcnN0S2V5ZnJhbWUuc3R5bGVzLnN0eWxlcyk7XG4gICAgICAgIHZhciBleHRyYUZpcnN0S2V5ZnJhbWVTdHlsZXMgPSB7fTtcbiAgICAgICAgdmFyIGhhc0V4dHJhRmlyc3RTdHlsZXMgPSBmYWxzZTtcbiAgICAgICAgT2JqZWN0LmtleXMoY29sbGVjdGVkU3R5bGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBjb2xsZWN0ZWRTdHlsZXNbcHJvcF07XG4gICAgICAgICAgICAvLyBpZiB0aGUgc3R5bGUgaXMgYWxyZWFkeSBkZWZpbmVkIGluIHRoZSBmaXJzdCBrZXlmcmFtZSB0aGVuXG4gICAgICAgICAgICAvLyB3ZSBkbyBub3QgcmVwbGFjZSBpdC5cbiAgICAgICAgICAgIGlmICghZmxhdGVuZWRGaXJzdEtleWZyYW1lU3R5bGVzW3Byb3BdKSB7XG4gICAgICAgICAgICAgICAgZmxhdGVuZWRGaXJzdEtleWZyYW1lU3R5bGVzW3Byb3BdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgZXh0cmFGaXJzdEtleWZyYW1lU3R5bGVzW3Byb3BdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgaGFzRXh0cmFGaXJzdFN0eWxlcyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIga2V5ZnJhbWVDb2xsZWN0ZWRTdHlsZXMgPSBTdHJpbmdNYXBXcmFwcGVyLm1lcmdlKHt9LCBmbGF0ZW5lZEZpcnN0S2V5ZnJhbWVTdHlsZXMpO1xuICAgICAgICAvLyBwaGFzZSAyOiBub3JtYWxpemUgdGhlIGZpbmFsIGtleWZyYW1lXG4gICAgICAgIHZhciBmaW5hbEtleWZyYW1lID0ga2V5ZnJhbWVzW2xpbWl0XTtcbiAgICAgICAgZmluYWxLZXlmcmFtZS5zdHlsZXMuc3R5bGVzLnVuc2hpZnQoZmluYWxTdGF0ZVN0eWxlcyk7XG4gICAgICAgIHZhciBmbGF0ZW5lZEZpbmFsS2V5ZnJhbWVTdHlsZXMgPSBmbGF0dGVuU3R5bGVzKGZpbmFsS2V5ZnJhbWUuc3R5bGVzLnN0eWxlcyk7XG4gICAgICAgIHZhciBleHRyYUZpbmFsS2V5ZnJhbWVTdHlsZXMgPSB7fTtcbiAgICAgICAgdmFyIGhhc0V4dHJhRmluYWxTdHlsZXMgPSBmYWxzZTtcbiAgICAgICAgT2JqZWN0LmtleXMoa2V5ZnJhbWVDb2xsZWN0ZWRTdHlsZXMpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICAgIGlmICghaXNQcmVzZW50KGZsYXRlbmVkRmluYWxLZXlmcmFtZVN0eWxlc1twcm9wXSkpIHtcbiAgICAgICAgICAgICAgICBleHRyYUZpbmFsS2V5ZnJhbWVTdHlsZXNbcHJvcF0gPSBBVVRPX1NUWUxFO1xuICAgICAgICAgICAgICAgIGhhc0V4dHJhRmluYWxTdHlsZXMgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGhhc0V4dHJhRmluYWxTdHlsZXMpIHtcbiAgICAgICAgICAgIGZpbmFsS2V5ZnJhbWUuc3R5bGVzLnN0eWxlcy5wdXNoKGV4dHJhRmluYWxLZXlmcmFtZVN0eWxlcyk7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmtleXMoZmxhdGVuZWRGaW5hbEtleWZyYW1lU3R5bGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgICBpZiAoIWlzUHJlc2VudChmbGF0ZW5lZEZpcnN0S2V5ZnJhbWVTdHlsZXNbcHJvcF0pKSB7XG4gICAgICAgICAgICAgICAgZXh0cmFGaXJzdEtleWZyYW1lU3R5bGVzW3Byb3BdID0gQVVUT19TVFlMRTtcbiAgICAgICAgICAgICAgICBoYXNFeHRyYUZpcnN0U3R5bGVzID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChoYXNFeHRyYUZpcnN0U3R5bGVzKSB7XG4gICAgICAgICAgICBmaXJzdEtleWZyYW1lLnN0eWxlcy5zdHlsZXMucHVzaChleHRyYUZpcnN0S2V5ZnJhbWVTdHlsZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBrZXlmcmFtZXM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNsZWFyU3R5bGVzKHN0eWxlcykge1xuICAgICAgICB2YXIgZmluYWxTdHlsZXMgPSB7fTtcbiAgICAgICAgT2JqZWN0LmtleXMoc3R5bGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgZmluYWxTdHlsZXNba2V5XSA9IG51bGw7IH0pO1xuICAgICAgICByZXR1cm4gZmluYWxTdHlsZXM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbGxlY3RBbmRSZXNvbHZlU3R5bGVzKGNvbGxlY3Rpb24sIHN0eWxlcykge1xuICAgICAgICByZXR1cm4gc3R5bGVzLm1hcChmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgICAgIHZhciBzdHlsZXNPYmogPSB7fTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGVudHJ5KS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gZW50cnlbcHJvcF07XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IEZJTExfU1RZTEVfRkxBRykge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGNvbGxlY3Rpb25bcHJvcF07XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNQcmVzZW50KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBBVVRPX1NUWUxFO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25bcHJvcF0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBzdHlsZXNPYmpbcHJvcF0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHN0eWxlc09iajtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlbmRlclN0eWxlcyhlbGVtZW50LCByZW5kZXJlciwgc3R5bGVzKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKHN0eWxlcykuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkgeyByZW5kZXJlci5zZXRFbGVtZW50U3R5bGUoZWxlbWVudCwgcHJvcCwgc3R5bGVzW3Byb3BdKTsgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZsYXR0ZW5TdHlsZXMoc3R5bGVzKSB7XG4gICAgICAgIHZhciBmaW5hbFN0eWxlcyA9IHt9O1xuICAgICAgICBzdHlsZXMuZm9yRWFjaChmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGVudHJ5KS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7IGZpbmFsU3R5bGVzW3Byb3BdID0gZW50cnlbcHJvcF07IH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZpbmFsU3R5bGVzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICB2YXIgQW5pbWF0aW9uU3R5bGVzID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gQW5pbWF0aW9uU3R5bGVzKHN0eWxlcykge1xuICAgICAgICAgICAgdGhpcy5zdHlsZXMgPSBzdHlsZXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEFuaW1hdGlvblN0eWxlcztcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MgaXMgcmV0dXJuZWQgYXMgYW4gZXZlbnQgcGFyYW1ldGVyIHdoZW4gYW4gYW5pbWF0aW9uXG4gICAgICogY2FsbGJhY2sgaXMgY2FwdHVyZWQgZm9yIGFuIGFuaW1hdGlvbiBlaXRoZXIgZHVyaW5nIHRoZSBzdGFydCBvciBkb25lIHBoYXNlLlxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIEBDb21wb25lbnQoe1xuICAgICAqICAgaG9zdDoge1xuICAgICAqICAgICAnW0BteUFuaW1hdGlvblRyaWdnZXJdJzogJ3NvbWVFeHByZXNzaW9uJyxcbiAgICAgKiAgICAgJyhAbXlBbmltYXRpb25UcmlnZ2VyLnN0YXJ0KSc6ICdjYXB0dXJlU3RhcnRFdmVudCgkZXZlbnQpJyxcbiAgICAgKiAgICAgJyhAbXlBbmltYXRpb25UcmlnZ2VyLmRvbmUpJzogJ2NhcHR1cmVEb25lRXZlbnQoJGV2ZW50KScsXG4gICAgICogICB9LFxuICAgICAqICAgYW5pbWF0aW9uczogW1xuICAgICAqICAgICB0cmlnZ2VyKFwibXlBbmltYXRpb25UcmlnZ2VyXCIsIFtcbiAgICAgKiAgICAgICAgLy8gLi4uXG4gICAgICogICAgIF0pXG4gICAgICogICBdXG4gICAgICogfSlcbiAgICAgKiBjbGFzcyBNeUNvbXBvbmVudCB7XG4gICAgICogICBzb21lRXhwcmVzc2lvbjogYW55ID0gZmFsc2U7XG4gICAgICogICBjYXB0dXJlU3RhcnRFdmVudChldmVudDogQW5pbWF0aW9uVHJhbnNpdGlvbkV2ZW50KSB7XG4gICAgICogICAgIC8vIHRoZSB0b1N0YXRlLCBmcm9tU3RhdGUgYW5kIHRvdGFsVGltZSBkYXRhIGlzIGFjY2Vzc2libGUgZnJvbSB0aGUgZXZlbnQgdmFyaWFibGVcbiAgICAgKiAgIH1cbiAgICAgKlxuICAgICAqICAgY2FwdHVyZURvbmVFdmVudChldmVudDogQW5pbWF0aW9uVHJhbnNpdGlvbkV2ZW50KSB7XG4gICAgICogICAgIC8vIHRoZSB0b1N0YXRlLCBmcm9tU3RhdGUgYW5kIHRvdGFsVGltZSBkYXRhIGlzIGFjY2Vzc2libGUgZnJvbSB0aGUgZXZlbnQgdmFyaWFibGVcbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAZXhwZXJpbWVudGFsIEFuaW1hdGlvbiBzdXBwb3J0IGlzIGV4cGVyaW1lbnRhbC5cbiAgICAgKi9cbiAgICB2YXIgQW5pbWF0aW9uVHJhbnNpdGlvbkV2ZW50ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gQW5pbWF0aW9uVHJhbnNpdGlvbkV2ZW50KF9hKSB7XG4gICAgICAgICAgICB2YXIgZnJvbVN0YXRlID0gX2EuZnJvbVN0YXRlLCB0b1N0YXRlID0gX2EudG9TdGF0ZSwgdG90YWxUaW1lID0gX2EudG90YWxUaW1lLCBwaGFzZU5hbWUgPSBfYS5waGFzZU5hbWU7XG4gICAgICAgICAgICB0aGlzLmZyb21TdGF0ZSA9IGZyb21TdGF0ZTtcbiAgICAgICAgICAgIHRoaXMudG9TdGF0ZSA9IHRvU3RhdGU7XG4gICAgICAgICAgICB0aGlzLnRvdGFsVGltZSA9IHRvdGFsVGltZTtcbiAgICAgICAgICAgIHRoaXMucGhhc2VOYW1lID0gcGhhc2VOYW1lO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBBbmltYXRpb25UcmFuc2l0aW9uRXZlbnQ7XG4gICAgfSgpKTtcblxuICAgIHZhciBBbmltYXRpb25UcmFuc2l0aW9uID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gQW5pbWF0aW9uVHJhbnNpdGlvbihfcGxheWVyLCBfZnJvbVN0YXRlLCBfdG9TdGF0ZSwgX3RvdGFsVGltZSkge1xuICAgICAgICAgICAgdGhpcy5fcGxheWVyID0gX3BsYXllcjtcbiAgICAgICAgICAgIHRoaXMuX2Zyb21TdGF0ZSA9IF9mcm9tU3RhdGU7XG4gICAgICAgICAgICB0aGlzLl90b1N0YXRlID0gX3RvU3RhdGU7XG4gICAgICAgICAgICB0aGlzLl90b3RhbFRpbWUgPSBfdG90YWxUaW1lO1xuICAgICAgICB9XG4gICAgICAgIEFuaW1hdGlvblRyYW5zaXRpb24ucHJvdG90eXBlLl9jcmVhdGVFdmVudCA9IGZ1bmN0aW9uIChwaGFzZU5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQW5pbWF0aW9uVHJhbnNpdGlvbkV2ZW50KHtcbiAgICAgICAgICAgICAgICBmcm9tU3RhdGU6IHRoaXMuX2Zyb21TdGF0ZSxcbiAgICAgICAgICAgICAgICB0b1N0YXRlOiB0aGlzLl90b1N0YXRlLFxuICAgICAgICAgICAgICAgIHRvdGFsVGltZTogdGhpcy5fdG90YWxUaW1lLFxuICAgICAgICAgICAgICAgIHBoYXNlTmFtZTogcGhhc2VOYW1lXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgQW5pbWF0aW9uVHJhbnNpdGlvbi5wcm90b3R5cGUub25TdGFydCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICAgICAgdmFyIGV2ZW50ID0gdGhpcy5fY3JlYXRlRXZlbnQoJ3N0YXJ0Jyk7XG4gICAgICAgICAgICB0aGlzLl9wbGF5ZXIub25TdGFydChmdW5jdGlvbiAoKSB7IHJldHVybiBjYWxsYmFjayhldmVudCk7IH0pO1xuICAgICAgICB9O1xuICAgICAgICBBbmltYXRpb25UcmFuc2l0aW9uLnByb3RvdHlwZS5vbkRvbmUgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHZhciBldmVudCA9IHRoaXMuX2NyZWF0ZUV2ZW50KCdkb25lJyk7XG4gICAgICAgICAgICB0aGlzLl9wbGF5ZXIub25Eb25lKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNhbGxiYWNrKGV2ZW50KTsgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBBbmltYXRpb25UcmFuc2l0aW9uO1xuICAgIH0oKSk7XG5cbiAgICB2YXIgRGVidWdEb21Sb290UmVuZGVyZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBEZWJ1Z0RvbVJvb3RSZW5kZXJlcihfZGVsZWdhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2RlbGVnYXRlID0gX2RlbGVnYXRlO1xuICAgICAgICB9XG4gICAgICAgIERlYnVnRG9tUm9vdFJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJDb21wb25lbnQgPSBmdW5jdGlvbiAoY29tcG9uZW50UHJvdG8pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGVidWdEb21SZW5kZXJlcih0aGlzLl9kZWxlZ2F0ZS5yZW5kZXJDb21wb25lbnQoY29tcG9uZW50UHJvdG8pKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIERlYnVnRG9tUm9vdFJlbmRlcmVyO1xuICAgIH0oKSk7XG4gICAgdmFyIERlYnVnRG9tUmVuZGVyZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBEZWJ1Z0RvbVJlbmRlcmVyKF9kZWxlZ2F0ZSkge1xuICAgICAgICAgICAgdGhpcy5fZGVsZWdhdGUgPSBfZGVsZWdhdGU7XG4gICAgICAgIH1cbiAgICAgICAgRGVidWdEb21SZW5kZXJlci5wcm90b3R5cGUuc2VsZWN0Um9vdEVsZW1lbnQgPSBmdW5jdGlvbiAoc2VsZWN0b3JPck5vZGUsIGRlYnVnSW5mbykge1xuICAgICAgICAgICAgdmFyIG5hdGl2ZUVsID0gdGhpcy5fZGVsZWdhdGUuc2VsZWN0Um9vdEVsZW1lbnQoc2VsZWN0b3JPck5vZGUsIGRlYnVnSW5mbyk7XG4gICAgICAgICAgICB2YXIgZGVidWdFbCA9IG5ldyBEZWJ1Z0VsZW1lbnQobmF0aXZlRWwsIG51bGwsIGRlYnVnSW5mbyk7XG4gICAgICAgICAgICBpbmRleERlYnVnTm9kZShkZWJ1Z0VsKTtcbiAgICAgICAgICAgIHJldHVybiBuYXRpdmVFbDtcbiAgICAgICAgfTtcbiAgICAgICAgRGVidWdEb21SZW5kZXJlci5wcm90b3R5cGUuY3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uIChwYXJlbnRFbGVtZW50LCBuYW1lLCBkZWJ1Z0luZm8pIHtcbiAgICAgICAgICAgIHZhciBuYXRpdmVFbCA9IHRoaXMuX2RlbGVnYXRlLmNyZWF0ZUVsZW1lbnQocGFyZW50RWxlbWVudCwgbmFtZSwgZGVidWdJbmZvKTtcbiAgICAgICAgICAgIHZhciBkZWJ1Z0VsID0gbmV3IERlYnVnRWxlbWVudChuYXRpdmVFbCwgZ2V0RGVidWdOb2RlKHBhcmVudEVsZW1lbnQpLCBkZWJ1Z0luZm8pO1xuICAgICAgICAgICAgZGVidWdFbC5uYW1lID0gbmFtZTtcbiAgICAgICAgICAgIGluZGV4RGVidWdOb2RlKGRlYnVnRWwpO1xuICAgICAgICAgICAgcmV0dXJuIG5hdGl2ZUVsO1xuICAgICAgICB9O1xuICAgICAgICBEZWJ1Z0RvbVJlbmRlcmVyLnByb3RvdHlwZS5jcmVhdGVWaWV3Um9vdCA9IGZ1bmN0aW9uIChob3N0RWxlbWVudCkgeyByZXR1cm4gdGhpcy5fZGVsZWdhdGUuY3JlYXRlVmlld1Jvb3QoaG9zdEVsZW1lbnQpOyB9O1xuICAgICAgICBEZWJ1Z0RvbVJlbmRlcmVyLnByb3RvdHlwZS5jcmVhdGVUZW1wbGF0ZUFuY2hvciA9IGZ1bmN0aW9uIChwYXJlbnRFbGVtZW50LCBkZWJ1Z0luZm8pIHtcbiAgICAgICAgICAgIHZhciBjb21tZW50ID0gdGhpcy5fZGVsZWdhdGUuY3JlYXRlVGVtcGxhdGVBbmNob3IocGFyZW50RWxlbWVudCwgZGVidWdJbmZvKTtcbiAgICAgICAgICAgIHZhciBkZWJ1Z0VsID0gbmV3IERlYnVnTm9kZShjb21tZW50LCBnZXREZWJ1Z05vZGUocGFyZW50RWxlbWVudCksIGRlYnVnSW5mbyk7XG4gICAgICAgICAgICBpbmRleERlYnVnTm9kZShkZWJ1Z0VsKTtcbiAgICAgICAgICAgIHJldHVybiBjb21tZW50O1xuICAgICAgICB9O1xuICAgICAgICBEZWJ1Z0RvbVJlbmRlcmVyLnByb3RvdHlwZS5jcmVhdGVUZXh0ID0gZnVuY3Rpb24gKHBhcmVudEVsZW1lbnQsIHZhbHVlLCBkZWJ1Z0luZm8pIHtcbiAgICAgICAgICAgIHZhciB0ZXh0ID0gdGhpcy5fZGVsZWdhdGUuY3JlYXRlVGV4dChwYXJlbnRFbGVtZW50LCB2YWx1ZSwgZGVidWdJbmZvKTtcbiAgICAgICAgICAgIHZhciBkZWJ1Z0VsID0gbmV3IERlYnVnTm9kZSh0ZXh0LCBnZXREZWJ1Z05vZGUocGFyZW50RWxlbWVudCksIGRlYnVnSW5mbyk7XG4gICAgICAgICAgICBpbmRleERlYnVnTm9kZShkZWJ1Z0VsKTtcbiAgICAgICAgICAgIHJldHVybiB0ZXh0O1xuICAgICAgICB9O1xuICAgICAgICBEZWJ1Z0RvbVJlbmRlcmVyLnByb3RvdHlwZS5wcm9qZWN0Tm9kZXMgPSBmdW5jdGlvbiAocGFyZW50RWxlbWVudCwgbm9kZXMpIHtcbiAgICAgICAgICAgIHZhciBkZWJ1Z1BhcmVudCA9IGdldERlYnVnTm9kZShwYXJlbnRFbGVtZW50KTtcbiAgICAgICAgICAgIGlmIChpc1ByZXNlbnQoZGVidWdQYXJlbnQpICYmIGRlYnVnUGFyZW50IGluc3RhbmNlb2YgRGVidWdFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIGRlYnVnRWxlbWVudF8xID0gZGVidWdQYXJlbnQ7XG4gICAgICAgICAgICAgICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkgeyBkZWJ1Z0VsZW1lbnRfMS5hZGRDaGlsZChnZXREZWJ1Z05vZGUobm9kZSkpOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2RlbGVnYXRlLnByb2plY3ROb2RlcyhwYXJlbnRFbGVtZW50LCBub2Rlcyk7XG4gICAgICAgIH07XG4gICAgICAgIERlYnVnRG9tUmVuZGVyZXIucHJvdG90eXBlLmF0dGFjaFZpZXdBZnRlciA9IGZ1bmN0aW9uIChub2RlLCB2aWV3Um9vdE5vZGVzKSB7XG4gICAgICAgICAgICB2YXIgZGVidWdOb2RlID0gZ2V0RGVidWdOb2RlKG5vZGUpO1xuICAgICAgICAgICAgaWYgKGlzUHJlc2VudChkZWJ1Z05vZGUpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRlYnVnUGFyZW50ID0gZGVidWdOb2RlLnBhcmVudDtcbiAgICAgICAgICAgICAgICBpZiAodmlld1Jvb3ROb2Rlcy5sZW5ndGggPiAwICYmIGlzUHJlc2VudChkZWJ1Z1BhcmVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlYnVnVmlld1Jvb3ROb2RlcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB2aWV3Um9vdE5vZGVzLmZvckVhY2goZnVuY3Rpb24gKHJvb3ROb2RlKSB7IHJldHVybiBkZWJ1Z1ZpZXdSb290Tm9kZXMucHVzaChnZXREZWJ1Z05vZGUocm9vdE5vZGUpKTsgfSk7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnUGFyZW50Lmluc2VydENoaWxkcmVuQWZ0ZXIoZGVidWdOb2RlLCBkZWJ1Z1ZpZXdSb290Tm9kZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2RlbGVnYXRlLmF0dGFjaFZpZXdBZnRlcihub2RlLCB2aWV3Um9vdE5vZGVzKTtcbiAgICAgICAgfTtcbiAgICAgICAgRGVidWdEb21SZW5kZXJlci5wcm90b3R5cGUuZGV0YWNoVmlldyA9IGZ1bmN0aW9uICh2aWV3Um9vdE5vZGVzKSB7XG4gICAgICAgICAgICB2aWV3Um9vdE5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGVidWdOb2RlID0gZ2V0RGVidWdOb2RlKG5vZGUpO1xuICAgICAgICAgICAgICAgIGlmIChpc1ByZXNlbnQoZGVidWdOb2RlKSAmJiBpc1ByZXNlbnQoZGVidWdOb2RlLnBhcmVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVidWdOb2RlLnBhcmVudC5yZW1vdmVDaGlsZChkZWJ1Z05vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5fZGVsZWdhdGUuZGV0YWNoVmlldyh2aWV3Um9vdE5vZGVzKTtcbiAgICAgICAgfTtcbiAgICAgICAgRGVidWdEb21SZW5kZXJlci5wcm90b3R5cGUuZGVzdHJveVZpZXcgPSBmdW5jdGlvbiAoaG9zdEVsZW1lbnQsIHZpZXdBbGxOb2Rlcykge1xuICAgICAgICAgICAgdmlld0FsbE5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHsgcmVtb3ZlRGVidWdOb2RlRnJvbUluZGV4KGdldERlYnVnTm9kZShub2RlKSk7IH0pO1xuICAgICAgICAgICAgdGhpcy5fZGVsZWdhdGUuZGVzdHJveVZpZXcoaG9zdEVsZW1lbnQsIHZpZXdBbGxOb2Rlcyk7XG4gICAgICAgIH07XG4gICAgICAgIERlYnVnRG9tUmVuZGVyZXIucHJvdG90eXBlLmxpc3RlbiA9IGZ1bmN0aW9uIChyZW5kZXJFbGVtZW50LCBuYW1lLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgdmFyIGRlYnVnRWwgPSBnZXREZWJ1Z05vZGUocmVuZGVyRWxlbWVudCk7XG4gICAgICAgICAgICBpZiAoaXNQcmVzZW50KGRlYnVnRWwpKSB7XG4gICAgICAgICAgICAgICAgZGVidWdFbC5saXN0ZW5lcnMucHVzaChuZXcgRXZlbnRMaXN0ZW5lcihuYW1lLCBjYWxsYmFjaykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RlbGVnYXRlLmxpc3RlbihyZW5kZXJFbGVtZW50LCBuYW1lLCBjYWxsYmFjayk7XG4gICAgICAgIH07XG4gICAgICAgIERlYnVnRG9tUmVuZGVyZXIucHJvdG90eXBlLmxpc3Rlbkdsb2JhbCA9IGZ1bmN0aW9uICh0YXJnZXQsIG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVsZWdhdGUubGlzdGVuR2xvYmFsKHRhcmdldCwgbmFtZSwgY2FsbGJhY2spO1xuICAgICAgICB9O1xuICAgICAgICBEZWJ1Z0RvbVJlbmRlcmVyLnByb3RvdHlwZS5zZXRFbGVtZW50UHJvcGVydHkgPSBmdW5jdGlvbiAocmVuZGVyRWxlbWVudCwgcHJvcGVydHlOYW1lLCBwcm9wZXJ0eVZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgZGVidWdFbCA9IGdldERlYnVnTm9kZShyZW5kZXJFbGVtZW50KTtcbiAgICAgICAgICAgIGlmIChpc1ByZXNlbnQoZGVidWdFbCkgJiYgZGVidWdFbCBpbnN0YW5jZW9mIERlYnVnRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGRlYnVnRWwucHJvcGVydGllc1twcm9wZXJ0eU5hbWVdID0gcHJvcGVydHlWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2RlbGVnYXRlLnNldEVsZW1lbnRQcm9wZXJ0eShyZW5kZXJFbGVtZW50LCBwcm9wZXJ0eU5hbWUsIHByb3BlcnR5VmFsdWUpO1xuICAgICAgICB9O1xuICAgICAgICBEZWJ1Z0RvbVJlbmRlcmVyLnByb3RvdHlwZS5zZXRFbGVtZW50QXR0cmlidXRlID0gZnVuY3Rpb24gKHJlbmRlckVsZW1lbnQsIGF0dHJpYnV0ZU5hbWUsIGF0dHJpYnV0ZVZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgZGVidWdFbCA9IGdldERlYnVnTm9kZShyZW5kZXJFbGVtZW50KTtcbiAgICAgICAgICAgIGlmIChpc1ByZXNlbnQoZGVidWdFbCkgJiYgZGVidWdFbCBpbnN0YW5jZW9mIERlYnVnRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGRlYnVnRWwuYXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXSA9IGF0dHJpYnV0ZVZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fZGVsZWdhdGUuc2V0RWxlbWVudEF0dHJpYnV0ZShyZW5kZXJFbGVtZW50LCBhdHRyaWJ1dGVOYW1lLCBhdHRyaWJ1dGVWYWx1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIERlYnVnRG9tUmVuZGVyZXIucHJvdG90eXBlLnNldEJpbmRpbmdEZWJ1Z0luZm8gPSBmdW5jdGlvbiAocmVuZGVyRWxlbWVudCwgcHJvcGVydHlOYW1lLCBwcm9wZXJ0eVZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9kZWxlZ2F0ZS5zZXRCaW5kaW5nRGVidWdJbmZvKHJlbmRlckVsZW1lbnQsIHByb3BlcnR5TmFtZSwgcHJvcGVydHlWYWx1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIERlYnVnRG9tUmVuZGVyZXIucHJvdG90eXBlLnNldEVsZW1lbnRDbGFzcyA9IGZ1bmN0aW9uIChyZW5kZXJFbGVtZW50LCBjbGFzc05hbWUsIGlzQWRkKSB7XG4gICAgICAgICAgICB2YXIgZGVidWdFbCA9IGdldERlYnVnTm9kZShyZW5kZXJFbGVtZW50KTtcbiAgICAgICAgICAgIGlmIChpc1ByZXNlbnQoZGVidWdFbCkgJiYgZGVidWdFbCBpbnN0YW5jZW9mIERlYnVnRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGRlYnVnRWwuY2xhc3Nlc1tjbGFzc05hbWVdID0gaXNBZGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9kZWxlZ2F0ZS5zZXRFbGVtZW50Q2xhc3MocmVuZGVyRWxlbWVudCwgY2xhc3NOYW1lLCBpc0FkZCk7XG4gICAgICAgIH07XG4gICAgICAgIERlYnVnRG9tUmVuZGVyZXIucHJvdG90eXBlLnNldEVsZW1lbnRTdHlsZSA9IGZ1bmN0aW9uIChyZW5kZXJFbGVtZW50LCBzdHlsZU5hbWUsIHN0eWxlVmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBkZWJ1Z0VsID0gZ2V0RGVidWdOb2RlKHJlbmRlckVsZW1lbnQpO1xuICAgICAgICAgICAgaWYgKGlzUHJlc2VudChkZWJ1Z0VsKSAmJiBkZWJ1Z0VsIGluc3RhbmNlb2YgRGVidWdFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgZGVidWdFbC5zdHlsZXNbc3R5bGVOYW1lXSA9IHN0eWxlVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9kZWxlZ2F0ZS5zZXRFbGVtZW50U3R5bGUocmVuZGVyRWxlbWVudCwgc3R5bGVOYW1lLCBzdHlsZVZhbHVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgRGVidWdEb21SZW5kZXJlci5wcm90b3R5cGUuaW52b2tlRWxlbWVudE1ldGhvZCA9IGZ1bmN0aW9uIChyZW5kZXJFbGVtZW50LCBtZXRob2ROYW1lLCBhcmdzKSB7XG4gICAgICAgICAgICB0aGlzLl9kZWxlZ2F0ZS5pbnZva2VFbGVtZW50TWV0aG9kKHJlbmRlckVsZW1lbnQsIG1ldGhvZE5hbWUsIGFyZ3MpO1xuICAgICAgICB9O1xuICAgICAgICBEZWJ1Z0RvbVJlbmRlcmVyLnByb3RvdHlwZS5zZXRUZXh0ID0gZnVuY3Rpb24gKHJlbmRlck5vZGUsIHRleHQpIHsgdGhpcy5fZGVsZWdhdGUuc2V0VGV4dChyZW5kZXJOb2RlLCB0ZXh0KTsgfTtcbiAgICAgICAgRGVidWdEb21SZW5kZXJlci5wcm90b3R5cGUuYW5pbWF0ZSA9IGZ1bmN0aW9uIChlbGVtZW50LCBzdGFydGluZ1N0eWxlcywga2V5ZnJhbWVzLCBkdXJhdGlvbiwgZGVsYXksIGVhc2luZykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RlbGVnYXRlLmFuaW1hdGUoZWxlbWVudCwgc3RhcnRpbmdTdHlsZXMsIGtleWZyYW1lcywgZHVyYXRpb24sIGRlbGF5LCBlYXNpbmcpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gRGVidWdEb21SZW5kZXJlcjtcbiAgICB9KCkpO1xuXG4gICAgdmFyIFN0YXRpY05vZGVEZWJ1Z0luZm8gPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBTdGF0aWNOb2RlRGVidWdJbmZvKHByb3ZpZGVyVG9rZW5zLCBjb21wb25lbnRUb2tlbiwgcmVmVG9rZW5zKSB7XG4gICAgICAgICAgICB0aGlzLnByb3ZpZGVyVG9rZW5zID0gcHJvdmlkZXJUb2tlbnM7XG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudFRva2VuID0gY29tcG9uZW50VG9rZW47XG4gICAgICAgICAgICB0aGlzLnJlZlRva2VucyA9IHJlZlRva2VucztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU3RhdGljTm9kZURlYnVnSW5mbztcbiAgICB9KCkpO1xuICAgIHZhciBEZWJ1Z0NvbnRleHQgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBEZWJ1Z0NvbnRleHQoX3ZpZXcsIF9ub2RlSW5kZXgsIF90cGxSb3csIF90cGxDb2wpIHtcbiAgICAgICAgICAgIHRoaXMuX3ZpZXcgPSBfdmlldztcbiAgICAgICAgICAgIHRoaXMuX25vZGVJbmRleCA9IF9ub2RlSW5kZXg7XG4gICAgICAgICAgICB0aGlzLl90cGxSb3cgPSBfdHBsUm93O1xuICAgICAgICAgICAgdGhpcy5fdHBsQ29sID0gX3RwbENvbDtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGVidWdDb250ZXh0LnByb3RvdHlwZSwgXCJfc3RhdGljTm9kZUluZm9cIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzUHJlc2VudCh0aGlzLl9ub2RlSW5kZXgpID8gdGhpcy5fdmlldy5zdGF0aWNOb2RlRGVidWdJbmZvc1t0aGlzLl9ub2RlSW5kZXhdIDogbnVsbDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGVidWdDb250ZXh0LnByb3RvdHlwZSwgXCJjb250ZXh0XCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fdmlldy5jb250ZXh0OyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERlYnVnQ29udGV4dC5wcm90b3R5cGUsIFwiY29tcG9uZW50XCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBzdGF0aWNOb2RlSW5mbyA9IHRoaXMuX3N0YXRpY05vZGVJbmZvO1xuICAgICAgICAgICAgICAgIGlmIChpc1ByZXNlbnQoc3RhdGljTm9kZUluZm8pICYmIGlzUHJlc2VudChzdGF0aWNOb2RlSW5mby5jb21wb25lbnRUb2tlbikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5qZWN0b3IuZ2V0KHN0YXRpY05vZGVJbmZvLmNvbXBvbmVudFRva2VuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERlYnVnQ29udGV4dC5wcm90b3R5cGUsIFwiY29tcG9uZW50UmVuZGVyRWxlbWVudFwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29tcG9uZW50VmlldyA9IHRoaXMuX3ZpZXc7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGlzUHJlc2VudChjb21wb25lbnRWaWV3LmRlY2xhcmF0aW9uQXBwRWxlbWVudCkgJiZcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50Vmlldy50eXBlICE9PSBWaWV3VHlwZS5DT01QT05FTlQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50VmlldyA9IGNvbXBvbmVudFZpZXcuZGVjbGFyYXRpb25BcHBFbGVtZW50LnBhcmVudFZpZXc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBpc1ByZXNlbnQoY29tcG9uZW50Vmlldy5kZWNsYXJhdGlvbkFwcEVsZW1lbnQpID9cbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50Vmlldy5kZWNsYXJhdGlvbkFwcEVsZW1lbnQubmF0aXZlRWxlbWVudCA6XG4gICAgICAgICAgICAgICAgICAgIG51bGw7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERlYnVnQ29udGV4dC5wcm90b3R5cGUsIFwiaW5qZWN0b3JcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl92aWV3LmluamVjdG9yKHRoaXMuX25vZGVJbmRleCk7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGVidWdDb250ZXh0LnByb3RvdHlwZSwgXCJyZW5kZXJOb2RlXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5fbm9kZUluZGV4KSAmJiB0aGlzLl92aWV3LmFsbE5vZGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl92aWV3LmFsbE5vZGVzW3RoaXMuX25vZGVJbmRleF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERlYnVnQ29udGV4dC5wcm90b3R5cGUsIFwicHJvdmlkZXJUb2tlbnNcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXRpY05vZGVJbmZvID0gdGhpcy5fc3RhdGljTm9kZUluZm87XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzUHJlc2VudChzdGF0aWNOb2RlSW5mbykgPyBzdGF0aWNOb2RlSW5mby5wcm92aWRlclRva2VucyA6IG51bGw7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERlYnVnQ29udGV4dC5wcm90b3R5cGUsIFwic291cmNlXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl92aWV3LmNvbXBvbmVudFR5cGUudGVtcGxhdGVVcmwgKyBcIjpcIiArIHRoaXMuX3RwbFJvdyArIFwiOlwiICsgdGhpcy5fdHBsQ29sO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEZWJ1Z0NvbnRleHQucHJvdG90eXBlLCBcInJlZmVyZW5jZXNcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgICAgICB2YXIgdmFyVmFsdWVzID0ge307XG4gICAgICAgICAgICAgICAgdmFyIHN0YXRpY05vZGVJbmZvID0gdGhpcy5fc3RhdGljTm9kZUluZm87XG4gICAgICAgICAgICAgICAgaWYgKGlzUHJlc2VudChzdGF0aWNOb2RlSW5mbykpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlZnMgPSBzdGF0aWNOb2RlSW5mby5yZWZUb2tlbnM7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHJlZnMpLmZvckVhY2goZnVuY3Rpb24gKHJlZk5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZWZUb2tlbiA9IHJlZnNbcmVmTmFtZV07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFyVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNCbGFuayhyZWZUb2tlbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXJWYWx1ZSA9IF90aGlzLl92aWV3LmFsbE5vZGVzID8gX3RoaXMuX3ZpZXcuYWxsTm9kZXNbX3RoaXMuX25vZGVJbmRleF0gOiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyVmFsdWUgPSBfdGhpcy5fdmlldy5pbmplY3RvckdldChyZWZUb2tlbiwgX3RoaXMuX25vZGVJbmRleCwgbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXJWYWx1ZXNbcmVmTmFtZV0gPSB2YXJWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB2YXJWYWx1ZXM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIERlYnVnQ29udGV4dDtcbiAgICB9KCkpO1xuXG4gICAgdmFyIFZpZXdBbmltYXRpb25NYXAgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBWaWV3QW5pbWF0aW9uTWFwKCkge1xuICAgICAgICAgICAgdGhpcy5fbWFwID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgdGhpcy5fYWxsUGxheWVycyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIFZpZXdBbmltYXRpb25NYXAucHJvdG90eXBlLmZpbmQgPSBmdW5jdGlvbiAoZWxlbWVudCwgYW5pbWF0aW9uTmFtZSkge1xuICAgICAgICAgICAgdmFyIHBsYXllcnNCeUFuaW1hdGlvbiA9IHRoaXMuX21hcC5nZXQoZWxlbWVudCk7XG4gICAgICAgICAgICBpZiAoaXNQcmVzZW50KHBsYXllcnNCeUFuaW1hdGlvbikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGxheWVyc0J5QW5pbWF0aW9uW2FuaW1hdGlvbk5hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBWaWV3QW5pbWF0aW9uTWFwLnByb3RvdHlwZS5maW5kQWxsUGxheWVyc0J5RWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgICAgICB2YXIgZWwgPSB0aGlzLl9tYXAuZ2V0KGVsZW1lbnQpO1xuICAgICAgICAgICAgcmV0dXJuIGVsID8gT2JqZWN0LmtleXMoZWwpLm1hcChmdW5jdGlvbiAoaykgeyByZXR1cm4gZWxba107IH0pIDogW107XG4gICAgICAgIH07XG4gICAgICAgIFZpZXdBbmltYXRpb25NYXAucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChlbGVtZW50LCBhbmltYXRpb25OYW1lLCBwbGF5ZXIpIHtcbiAgICAgICAgICAgIHZhciBwbGF5ZXJzQnlBbmltYXRpb24gPSB0aGlzLl9tYXAuZ2V0KGVsZW1lbnQpO1xuICAgICAgICAgICAgaWYgKCFpc1ByZXNlbnQocGxheWVyc0J5QW5pbWF0aW9uKSkge1xuICAgICAgICAgICAgICAgIHBsYXllcnNCeUFuaW1hdGlvbiA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGV4aXN0aW5nRW50cnkgPSBwbGF5ZXJzQnlBbmltYXRpb25bYW5pbWF0aW9uTmFtZV07XG4gICAgICAgICAgICBpZiAoaXNQcmVzZW50KGV4aXN0aW5nRW50cnkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmUoZWxlbWVudCwgYW5pbWF0aW9uTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwbGF5ZXJzQnlBbmltYXRpb25bYW5pbWF0aW9uTmFtZV0gPSBwbGF5ZXI7XG4gICAgICAgICAgICB0aGlzLl9hbGxQbGF5ZXJzLnB1c2gocGxheWVyKTtcbiAgICAgICAgICAgIHRoaXMuX21hcC5zZXQoZWxlbWVudCwgcGxheWVyc0J5QW5pbWF0aW9uKTtcbiAgICAgICAgfTtcbiAgICAgICAgVmlld0FuaW1hdGlvbk1hcC5wcm90b3R5cGUuZ2V0QWxsUGxheWVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2FsbFBsYXllcnM7IH07XG4gICAgICAgIFZpZXdBbmltYXRpb25NYXAucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChlbGVtZW50LCBhbmltYXRpb25OYW1lKSB7XG4gICAgICAgICAgICB2YXIgcGxheWVyc0J5QW5pbWF0aW9uID0gdGhpcy5fbWFwLmdldChlbGVtZW50KTtcbiAgICAgICAgICAgIGlmIChwbGF5ZXJzQnlBbmltYXRpb24pIHtcbiAgICAgICAgICAgICAgICB2YXIgcGxheWVyID0gcGxheWVyc0J5QW5pbWF0aW9uW2FuaW1hdGlvbk5hbWVdO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBwbGF5ZXJzQnlBbmltYXRpb25bYW5pbWF0aW9uTmFtZV07XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5fYWxsUGxheWVycy5pbmRleE9mKHBsYXllcik7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWxsUGxheWVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhwbGF5ZXJzQnlBbmltYXRpb24pLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tYXAuZGVsZXRlKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFZpZXdBbmltYXRpb25NYXA7XG4gICAgfSgpKTtcblxuICAgIHZhciBBbmltYXRpb25WaWV3Q29udGV4dCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEFuaW1hdGlvblZpZXdDb250ZXh0KCkge1xuICAgICAgICAgICAgdGhpcy5fcGxheWVycyA9IG5ldyBWaWV3QW5pbWF0aW9uTWFwKCk7XG4gICAgICAgIH1cbiAgICAgICAgQW5pbWF0aW9uVmlld0NvbnRleHQucHJvdG90eXBlLm9uQWxsQWN0aXZlQW5pbWF0aW9uc0RvbmUgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHZhciBhY3RpdmVBbmltYXRpb25QbGF5ZXJzID0gdGhpcy5fcGxheWVycy5nZXRBbGxQbGF5ZXJzKCk7XG4gICAgICAgICAgICAvLyB3ZSBjaGVjayBmb3IgdGhlIGxlbmd0aCB0byBhdm9pZCBoYXZpbmcgR3JvdXBBbmltYXRpb25QbGF5ZXJcbiAgICAgICAgICAgIC8vIGlzc3VlIGFuIHVubmVjZXNzYXJ5IG1pY3JvdGFzayB3aGVuIHplcm8gcGxheWVycyBhcmUgcGFzc2VkIGluXG4gICAgICAgICAgICBpZiAoYWN0aXZlQW5pbWF0aW9uUGxheWVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBuZXcgQW5pbWF0aW9uR3JvdXBQbGF5ZXIoYWN0aXZlQW5pbWF0aW9uUGxheWVycykub25Eb25lKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNhbGxiYWNrKCk7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgQW5pbWF0aW9uVmlld0NvbnRleHQucHJvdG90eXBlLnF1ZXVlQW5pbWF0aW9uID0gZnVuY3Rpb24gKGVsZW1lbnQsIGFuaW1hdGlvbk5hbWUsIHBsYXllcikge1xuICAgICAgICAgICAgcXVldWVBbmltYXRpb25HbG9iYWxseShwbGF5ZXIpO1xuICAgICAgICAgICAgdGhpcy5fcGxheWVycy5zZXQoZWxlbWVudCwgYW5pbWF0aW9uTmFtZSwgcGxheWVyKTtcbiAgICAgICAgfTtcbiAgICAgICAgQW5pbWF0aW9uVmlld0NvbnRleHQucHJvdG90eXBlLmNhbmNlbEFjdGl2ZUFuaW1hdGlvbiA9IGZ1bmN0aW9uIChlbGVtZW50LCBhbmltYXRpb25OYW1lLCByZW1vdmVBbGxBbmltYXRpb25zKSB7XG4gICAgICAgICAgICBpZiAocmVtb3ZlQWxsQW5pbWF0aW9ucyA9PT0gdm9pZCAwKSB7IHJlbW92ZUFsbEFuaW1hdGlvbnMgPSBmYWxzZTsgfVxuICAgICAgICAgICAgaWYgKHJlbW92ZUFsbEFuaW1hdGlvbnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wbGF5ZXJzLmZpbmRBbGxQbGF5ZXJzQnlFbGVtZW50KGVsZW1lbnQpLmZvckVhY2goZnVuY3Rpb24gKHBsYXllcikgeyByZXR1cm4gcGxheWVyLmRlc3Ryb3koKTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgcGxheWVyID0gdGhpcy5fcGxheWVycy5maW5kKGVsZW1lbnQsIGFuaW1hdGlvbk5hbWUpO1xuICAgICAgICAgICAgICAgIGlmIChwbGF5ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcGxheWVyLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBBbmltYXRpb25WaWV3Q29udGV4dDtcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIHZhciBfX2V4dGVuZHMkMTUgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbiAgICB2YXIgX1VOREVGSU5FRCQxID0gbmV3IE9iamVjdCgpO1xuICAgIHZhciBFbGVtZW50SW5qZWN0b3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMkMTUoRWxlbWVudEluamVjdG9yLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBFbGVtZW50SW5qZWN0b3IoX3ZpZXcsIF9ub2RlSW5kZXgpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5fdmlldyA9IF92aWV3O1xuICAgICAgICAgICAgdGhpcy5fbm9kZUluZGV4ID0gX25vZGVJbmRleDtcbiAgICAgICAgfVxuICAgICAgICBFbGVtZW50SW5qZWN0b3IucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICh0b2tlbiwgbm90Rm91bmRWYWx1ZSkge1xuICAgICAgICAgICAgaWYgKG5vdEZvdW5kVmFsdWUgPT09IHZvaWQgMCkgeyBub3RGb3VuZFZhbHVlID0gVEhST1dfSUZfTk9UX0ZPVU5EOyB9XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gX1VOREVGSU5FRCQxO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gX1VOREVGSU5FRCQxKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5fdmlldy5pbmplY3RvckdldCh0b2tlbiwgdGhpcy5fbm9kZUluZGV4LCBfVU5ERUZJTkVEJDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gX1VOREVGSU5FRCQxKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5fdmlldy5wYXJlbnRJbmplY3Rvci5nZXQodG9rZW4sIG5vdEZvdW5kVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIEVsZW1lbnRJbmplY3RvcjtcbiAgICB9KEluamVjdG9yKSk7XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgdmFyIF9fZXh0ZW5kcyQxNCA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xuICAgIHZhciBfc2NvcGVfY2hlY2sgPSB3dGZDcmVhdGVTY29wZShcIkFwcFZpZXcjY2hlY2soYXNjaWkgaWQpXCIpO1xuICAgIC8qKlxuICAgICAqIENvc3Qgb2YgbWFraW5nIG9iamVjdHM6IGh0dHA6Ly9qc3BlcmYuY29tL2luc3RhbnRpYXRlLXNpemUtb2Ytb2JqZWN0XG4gICAgICpcbiAgICAgKi9cbiAgICB2YXIgQXBwVmlldyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEFwcFZpZXcoY2xhenosIGNvbXBvbmVudFR5cGUsIHR5cGUsIHZpZXdVdGlscywgcGFyZW50SW5qZWN0b3IsIGRlY2xhcmF0aW9uQXBwRWxlbWVudCwgY2RNb2RlKSB7XG4gICAgICAgICAgICB0aGlzLmNsYXp6ID0gY2xheno7XG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudFR5cGUgPSBjb21wb25lbnRUeXBlO1xuICAgICAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgICAgIHRoaXMudmlld1V0aWxzID0gdmlld1V0aWxzO1xuICAgICAgICAgICAgdGhpcy5wYXJlbnRJbmplY3RvciA9IHBhcmVudEluamVjdG9yO1xuICAgICAgICAgICAgdGhpcy5kZWNsYXJhdGlvbkFwcEVsZW1lbnQgPSBkZWNsYXJhdGlvbkFwcEVsZW1lbnQ7XG4gICAgICAgICAgICB0aGlzLmNkTW9kZSA9IGNkTW9kZTtcbiAgICAgICAgICAgIHRoaXMuY29udGVudENoaWxkcmVuID0gW107XG4gICAgICAgICAgICB0aGlzLnZpZXdDaGlsZHJlbiA9IFtdO1xuICAgICAgICAgICAgdGhpcy52aWV3Q29udGFpbmVyRWxlbWVudCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLm51bWJlck9mQ2hlY2tzID0gMDtcbiAgICAgICAgICAgIHRoaXMucmVmID0gbmV3IFZpZXdSZWZfKHRoaXMpO1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09IFZpZXdUeXBlLkNPTVBPTkVOVCB8fCB0eXBlID09PSBWaWV3VHlwZS5IT1NUKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlciA9IHZpZXdVdGlscy5yZW5kZXJDb21wb25lbnQoY29tcG9uZW50VHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyID0gZGVjbGFyYXRpb25BcHBFbGVtZW50LnBhcmVudFZpZXcucmVuZGVyZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFwcFZpZXcucHJvdG90eXBlLCBcImFuaW1hdGlvbkNvbnRleHRcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9hbmltYXRpb25Db250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FuaW1hdGlvbkNvbnRleHQgPSBuZXcgQW5pbWF0aW9uVmlld0NvbnRleHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FuaW1hdGlvbkNvbnRleHQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFwcFZpZXcucHJvdG90eXBlLCBcImRlc3Ryb3llZFwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuY2RNb2RlID09PSBDaGFuZ2VEZXRlY3RvclN0YXR1cy5EZXN0cm95ZWQ7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBBcHBWaWV3LnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbiAoY29udGV4dCwgZ2l2ZW5Qcm9qZWN0YWJsZU5vZGVzLCByb290U2VsZWN0b3JPck5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgICAgICB2YXIgcHJvamVjdGFibGVOb2RlcztcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBWaWV3VHlwZS5DT01QT05FTlQ6XG4gICAgICAgICAgICAgICAgICAgIHByb2plY3RhYmxlTm9kZXMgPSBlbnN1cmVTbG90Q291bnQoZ2l2ZW5Qcm9qZWN0YWJsZU5vZGVzLCB0aGlzLmNvbXBvbmVudFR5cGUuc2xvdENvdW50KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBWaWV3VHlwZS5FTUJFRERFRDpcbiAgICAgICAgICAgICAgICAgICAgcHJvamVjdGFibGVOb2RlcyA9IHRoaXMuZGVjbGFyYXRpb25BcHBFbGVtZW50LnBhcmVudFZpZXcucHJvamVjdGFibGVOb2RlcztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBWaWV3VHlwZS5IT1NUOlxuICAgICAgICAgICAgICAgICAgICAvLyBOb3RlOiBEb24ndCBlbnN1cmUgdGhlIHNsb3QgY291bnQgZm9yIHRoZSBwcm9qZWN0YWJsZU5vZGVzIGFzIHdlIHN0b3JlXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZW0gb25seSBmb3IgdGhlIGNvbnRhaW5lZCBjb21wb25lbnQgdmlldyAod2hpY2ggd2lsbCBsYXRlciBjaGVjayB0aGUgc2xvdCBjb3VudC4uLilcbiAgICAgICAgICAgICAgICAgICAgcHJvamVjdGFibGVOb2RlcyA9IGdpdmVuUHJvamVjdGFibGVOb2RlcztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9oYXNFeHRlcm5hbEhvc3RFbGVtZW50ID0gaXNQcmVzZW50KHJvb3RTZWxlY3Rvck9yTm9kZSk7XG4gICAgICAgICAgICB0aGlzLnByb2plY3RhYmxlTm9kZXMgPSBwcm9qZWN0YWJsZU5vZGVzO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlSW50ZXJuYWwocm9vdFNlbGVjdG9yT3JOb2RlKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE92ZXJ3cml0dGVuIGJ5IGltcGxlbWVudGF0aW9ucy5cbiAgICAgICAgICogUmV0dXJucyB0aGUgQXBwRWxlbWVudCBmb3IgdGhlIGhvc3QgZWxlbWVudCBmb3IgVmlld1R5cGUuSE9TVC5cbiAgICAgICAgICovXG4gICAgICAgIEFwcFZpZXcucHJvdG90eXBlLmNyZWF0ZUludGVybmFsID0gZnVuY3Rpb24gKHJvb3RTZWxlY3Rvck9yTm9kZSkgeyByZXR1cm4gbnVsbDsgfTtcbiAgICAgICAgQXBwVmlldy5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uIChyb290Tm9kZXNPckFwcEVsZW1lbnRzLCBhbGxOb2RlcywgZGlzcG9zYWJsZXMsIHN1YnNjcmlwdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMucm9vdE5vZGVzT3JBcHBFbGVtZW50cyA9IHJvb3ROb2Rlc09yQXBwRWxlbWVudHM7XG4gICAgICAgICAgICB0aGlzLmFsbE5vZGVzID0gYWxsTm9kZXM7XG4gICAgICAgICAgICB0aGlzLmRpc3Bvc2FibGVzID0gZGlzcG9zYWJsZXM7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMgPSBzdWJzY3JpcHRpb25zO1xuICAgICAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gVmlld1R5cGUuQ09NUE9ORU5UKSB7XG4gICAgICAgICAgICAgICAgLy8gTm90ZTogdGhlIHJlbmRlciBub2RlcyBoYXZlIGJlZW4gYXR0YWNoZWQgdG8gdGhlaXIgaG9zdCBlbGVtZW50XG4gICAgICAgICAgICAgICAgLy8gaW4gdGhlIFZpZXdGYWN0b3J5IGFscmVhZHkuXG4gICAgICAgICAgICAgICAgdGhpcy5kZWNsYXJhdGlvbkFwcEVsZW1lbnQucGFyZW50Vmlldy52aWV3Q2hpbGRyZW4ucHVzaCh0aGlzKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRpcnR5UGFyZW50UXVlcmllc0ludGVybmFsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIEFwcFZpZXcucHJvdG90eXBlLmluamVjdG9yR2V0ID0gZnVuY3Rpb24gKHRva2VuLCBub2RlSW5kZXgsIG5vdEZvdW5kUmVzdWx0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbmplY3RvckdldEludGVybmFsKHRva2VuLCBub2RlSW5kZXgsIG5vdEZvdW5kUmVzdWx0KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE92ZXJ3cml0dGVuIGJ5IGltcGxlbWVudGF0aW9uc1xuICAgICAgICAgKi9cbiAgICAgICAgQXBwVmlldy5wcm90b3R5cGUuaW5qZWN0b3JHZXRJbnRlcm5hbCA9IGZ1bmN0aW9uICh0b2tlbiwgbm9kZUluZGV4LCBub3RGb3VuZFJlc3VsdCkge1xuICAgICAgICAgICAgcmV0dXJuIG5vdEZvdW5kUmVzdWx0O1xuICAgICAgICB9O1xuICAgICAgICBBcHBWaWV3LnByb3RvdHlwZS5pbmplY3RvciA9IGZ1bmN0aW9uIChub2RlSW5kZXgpIHtcbiAgICAgICAgICAgIGlmIChpc1ByZXNlbnQobm9kZUluZGV4KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRWxlbWVudEluamVjdG9yKHRoaXMsIG5vZGVJbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnRJbmplY3RvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgQXBwVmlldy5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9oYXNFeHRlcm5hbEhvc3RFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5kZXRhY2hWaWV3KHRoaXMuZmxhdFJvb3ROb2Rlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc1ByZXNlbnQodGhpcy52aWV3Q29udGFpbmVyRWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdDb250YWluZXJFbGVtZW50LmRldGFjaFZpZXcodGhpcy52aWV3Q29udGFpbmVyRWxlbWVudC5uZXN0ZWRWaWV3cy5pbmRleE9mKHRoaXMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2Rlc3Ryb3lSZWN1cnNlKCk7XG4gICAgICAgIH07XG4gICAgICAgIEFwcFZpZXcucHJvdG90eXBlLl9kZXN0cm95UmVjdXJzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNkTW9kZSA9PT0gQ2hhbmdlRGV0ZWN0b3JTdGF0dXMuRGVzdHJveWVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5jb250ZW50Q2hpbGRyZW47XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW5baV0uX2Rlc3Ryb3lSZWN1cnNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGlsZHJlbiA9IHRoaXMudmlld0NoaWxkcmVuO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuW2ldLl9kZXN0cm95UmVjdXJzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5kZXN0cm95TG9jYWwoKTtcbiAgICAgICAgICAgIHRoaXMuY2RNb2RlID0gQ2hhbmdlRGV0ZWN0b3JTdGF0dXMuRGVzdHJveWVkO1xuICAgICAgICB9O1xuICAgICAgICBBcHBWaWV3LnByb3RvdHlwZS5kZXN0cm95TG9jYWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGhvc3RFbGVtZW50ID0gdGhpcy50eXBlID09PSBWaWV3VHlwZS5DT01QT05FTlQgPyB0aGlzLmRlY2xhcmF0aW9uQXBwRWxlbWVudC5uYXRpdmVFbGVtZW50IDogbnVsbDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5kaXNwb3NhYmxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcG9zYWJsZXNbaV0oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5zdWJzY3JpcHRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zW2ldLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmRlc3Ryb3lJbnRlcm5hbCgpO1xuICAgICAgICAgICAgdGhpcy5kaXJ0eVBhcmVudFF1ZXJpZXNJbnRlcm5hbCgpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2FuaW1hdGlvbkNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hbmltYXRpb25Db250ZXh0Lm9uQWxsQWN0aXZlQW5pbWF0aW9uc0RvbmUoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMucmVuZGVyZXIuZGVzdHJveVZpZXcoaG9zdEVsZW1lbnQsIF90aGlzLmFsbE5vZGVzKTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLmRlc3Ryb3lWaWV3KGhvc3RFbGVtZW50LCB0aGlzLmFsbE5vZGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE92ZXJ3cml0dGVuIGJ5IGltcGxlbWVudGF0aW9uc1xuICAgICAgICAgKi9cbiAgICAgICAgQXBwVmlldy5wcm90b3R5cGUuZGVzdHJveUludGVybmFsID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogT3ZlcndyaXR0ZW4gYnkgaW1wbGVtZW50YXRpb25zXG4gICAgICAgICAqL1xuICAgICAgICBBcHBWaWV3LnByb3RvdHlwZS5kZXRhY2hJbnRlcm5hbCA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAgICAgQXBwVmlldy5wcm90b3R5cGUuZGV0YWNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuZGV0YWNoSW50ZXJuYWwoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9hbmltYXRpb25Db250ZXh0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYW5pbWF0aW9uQ29udGV4dC5vbkFsbEFjdGl2ZUFuaW1hdGlvbnNEb25lKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnJlbmRlcmVyLmRldGFjaFZpZXcoX3RoaXMuZmxhdFJvb3ROb2Rlcyk7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5kZXRhY2hWaWV3KHRoaXMuZmxhdFJvb3ROb2Rlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBcHBWaWV3LnByb3RvdHlwZSwgXCJjaGFuZ2VEZXRlY3RvclJlZlwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMucmVmOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFwcFZpZXcucHJvdG90eXBlLCBcInBhcmVudFwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNQcmVzZW50KHRoaXMuZGVjbGFyYXRpb25BcHBFbGVtZW50KSA/IHRoaXMuZGVjbGFyYXRpb25BcHBFbGVtZW50LnBhcmVudFZpZXcgOiBudWxsO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBcHBWaWV3LnByb3RvdHlwZSwgXCJmbGF0Um9vdE5vZGVzXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZmxhdHRlbk5lc3RlZFZpZXdSZW5kZXJOb2Rlcyh0aGlzLnJvb3ROb2Rlc09yQXBwRWxlbWVudHMpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFwcFZpZXcucHJvdG90eXBlLCBcImxhc3RSb290Tm9kZVwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGFzdE5vZGUgPSB0aGlzLnJvb3ROb2Rlc09yQXBwRWxlbWVudHMubGVuZ3RoID4gMCA/XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucm9vdE5vZGVzT3JBcHBFbGVtZW50c1t0aGlzLnJvb3ROb2Rlc09yQXBwRWxlbWVudHMubGVuZ3RoIC0gMV0gOlxuICAgICAgICAgICAgICAgICAgICBudWxsO1xuICAgICAgICAgICAgICAgIHJldHVybiBfZmluZExhc3RSZW5kZXJOb2RlKGxhc3ROb2RlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICAvKipcbiAgICAgICAgICogT3ZlcndyaXR0ZW4gYnkgaW1wbGVtZW50YXRpb25zXG4gICAgICAgICAqL1xuICAgICAgICBBcHBWaWV3LnByb3RvdHlwZS5kaXJ0eVBhcmVudFF1ZXJpZXNJbnRlcm5hbCA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAgICAgQXBwVmlldy5wcm90b3R5cGUuZGV0ZWN0Q2hhbmdlcyA9IGZ1bmN0aW9uICh0aHJvd09uQ2hhbmdlKSB7XG4gICAgICAgICAgICB2YXIgcyA9IF9zY29wZV9jaGVjayh0aGlzLmNsYXp6KTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNkTW9kZSA9PT0gQ2hhbmdlRGV0ZWN0b3JTdGF0dXMuQ2hlY2tlZCB8fFxuICAgICAgICAgICAgICAgIHRoaXMuY2RNb2RlID09PSBDaGFuZ2VEZXRlY3RvclN0YXR1cy5FcnJvcmVkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmICh0aGlzLmNkTW9kZSA9PT0gQ2hhbmdlRGV0ZWN0b3JTdGF0dXMuRGVzdHJveWVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50aHJvd0Rlc3Ryb3llZEVycm9yKCdkZXRlY3RDaGFuZ2VzJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmRldGVjdENoYW5nZXNJbnRlcm5hbCh0aHJvd09uQ2hhbmdlKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNkTW9kZSA9PT0gQ2hhbmdlRGV0ZWN0b3JTdGF0dXMuQ2hlY2tPbmNlKVxuICAgICAgICAgICAgICAgIHRoaXMuY2RNb2RlID0gQ2hhbmdlRGV0ZWN0b3JTdGF0dXMuQ2hlY2tlZDtcbiAgICAgICAgICAgIHRoaXMubnVtYmVyT2ZDaGVja3MrKztcbiAgICAgICAgICAgIHd0ZkxlYXZlKHMpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogT3ZlcndyaXR0ZW4gYnkgaW1wbGVtZW50YXRpb25zXG4gICAgICAgICAqL1xuICAgICAgICBBcHBWaWV3LnByb3RvdHlwZS5kZXRlY3RDaGFuZ2VzSW50ZXJuYWwgPSBmdW5jdGlvbiAodGhyb3dPbkNoYW5nZSkge1xuICAgICAgICAgICAgdGhpcy5kZXRlY3RDb250ZW50Q2hpbGRyZW5DaGFuZ2VzKHRocm93T25DaGFuZ2UpO1xuICAgICAgICAgICAgdGhpcy5kZXRlY3RWaWV3Q2hpbGRyZW5DaGFuZ2VzKHRocm93T25DaGFuZ2UpO1xuICAgICAgICB9O1xuICAgICAgICBBcHBWaWV3LnByb3RvdHlwZS5kZXRlY3RDb250ZW50Q2hpbGRyZW5DaGFuZ2VzID0gZnVuY3Rpb24gKHRocm93T25DaGFuZ2UpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jb250ZW50Q2hpbGRyZW4ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLmNvbnRlbnRDaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQuY2RNb2RlID09PSBDaGFuZ2VEZXRlY3RvclN0YXR1cy5EZXRhY2hlZClcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2hpbGQuZGV0ZWN0Q2hhbmdlcyh0aHJvd09uQ2hhbmdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgQXBwVmlldy5wcm90b3R5cGUuZGV0ZWN0Vmlld0NoaWxkcmVuQ2hhbmdlcyA9IGZ1bmN0aW9uICh0aHJvd09uQ2hhbmdlKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudmlld0NoaWxkcmVuLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gdGhpcy52aWV3Q2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLmNkTW9kZSA9PT0gQ2hhbmdlRGV0ZWN0b3JTdGF0dXMuRGV0YWNoZWQpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNoaWxkLmRldGVjdENoYW5nZXModGhyb3dPbkNoYW5nZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIEFwcFZpZXcucHJvdG90eXBlLm1hcmtDb250ZW50Q2hpbGRBc01vdmVkID0gZnVuY3Rpb24gKHJlbmRlckFwcEVsZW1lbnQpIHsgdGhpcy5kaXJ0eVBhcmVudFF1ZXJpZXNJbnRlcm5hbCgpOyB9O1xuICAgICAgICBBcHBWaWV3LnByb3RvdHlwZS5hZGRUb0NvbnRlbnRDaGlsZHJlbiA9IGZ1bmN0aW9uIChyZW5kZXJBcHBFbGVtZW50KSB7XG4gICAgICAgICAgICByZW5kZXJBcHBFbGVtZW50LnBhcmVudFZpZXcuY29udGVudENoaWxkcmVuLnB1c2godGhpcyk7XG4gICAgICAgICAgICB0aGlzLnZpZXdDb250YWluZXJFbGVtZW50ID0gcmVuZGVyQXBwRWxlbWVudDtcbiAgICAgICAgICAgIHRoaXMuZGlydHlQYXJlbnRRdWVyaWVzSW50ZXJuYWwoKTtcbiAgICAgICAgfTtcbiAgICAgICAgQXBwVmlldy5wcm90b3R5cGUucmVtb3ZlRnJvbUNvbnRlbnRDaGlsZHJlbiA9IGZ1bmN0aW9uIChyZW5kZXJBcHBFbGVtZW50KSB7XG4gICAgICAgICAgICBMaXN0V3JhcHBlci5yZW1vdmUocmVuZGVyQXBwRWxlbWVudC5wYXJlbnRWaWV3LmNvbnRlbnRDaGlsZHJlbiwgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLmRpcnR5UGFyZW50UXVlcmllc0ludGVybmFsKCk7XG4gICAgICAgICAgICB0aGlzLnZpZXdDb250YWluZXJFbGVtZW50ID0gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgQXBwVmlldy5wcm90b3R5cGUubWFya0FzQ2hlY2tPbmNlID0gZnVuY3Rpb24gKCkgeyB0aGlzLmNkTW9kZSA9IENoYW5nZURldGVjdG9yU3RhdHVzLkNoZWNrT25jZTsgfTtcbiAgICAgICAgQXBwVmlldy5wcm90b3R5cGUubWFya1BhdGhUb1Jvb3RBc0NoZWNrT25jZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjID0gdGhpcztcbiAgICAgICAgICAgIHdoaWxlIChpc1ByZXNlbnQoYykgJiYgYy5jZE1vZGUgIT09IENoYW5nZURldGVjdG9yU3RhdHVzLkRldGFjaGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGMuY2RNb2RlID09PSBDaGFuZ2VEZXRlY3RvclN0YXR1cy5DaGVja2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIGMuY2RNb2RlID0gQ2hhbmdlRGV0ZWN0b3JTdGF0dXMuQ2hlY2tPbmNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50RWwgPSBjLnR5cGUgPT09IFZpZXdUeXBlLkNPTVBPTkVOVCA/IGMuZGVjbGFyYXRpb25BcHBFbGVtZW50IDogYy52aWV3Q29udGFpbmVyRWxlbWVudDtcbiAgICAgICAgICAgICAgICBjID0gaXNQcmVzZW50KHBhcmVudEVsKSA/IHBhcmVudEVsLnBhcmVudFZpZXcgOiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBBcHBWaWV3LnByb3RvdHlwZS5ldmVudEhhbmRsZXIgPSBmdW5jdGlvbiAoY2IpIHsgcmV0dXJuIGNiOyB9O1xuICAgICAgICBBcHBWaWV3LnByb3RvdHlwZS50aHJvd0Rlc3Ryb3llZEVycm9yID0gZnVuY3Rpb24gKGRldGFpbHMpIHsgdGhyb3cgbmV3IFZpZXdEZXN0cm95ZWRFcnJvcihkZXRhaWxzKTsgfTtcbiAgICAgICAgcmV0dXJuIEFwcFZpZXc7XG4gICAgfSgpKTtcbiAgICB2YXIgRGVidWdBcHBWaWV3ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDE0KERlYnVnQXBwVmlldywgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gRGVidWdBcHBWaWV3KGNsYXp6LCBjb21wb25lbnRUeXBlLCB0eXBlLCB2aWV3VXRpbHMsIHBhcmVudEluamVjdG9yLCBkZWNsYXJhdGlvbkFwcEVsZW1lbnQsIGNkTW9kZSwgc3RhdGljTm9kZURlYnVnSW5mb3MpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGNsYXp6LCBjb21wb25lbnRUeXBlLCB0eXBlLCB2aWV3VXRpbHMsIHBhcmVudEluamVjdG9yLCBkZWNsYXJhdGlvbkFwcEVsZW1lbnQsIGNkTW9kZSk7XG4gICAgICAgICAgICB0aGlzLnN0YXRpY05vZGVEZWJ1Z0luZm9zID0gc3RhdGljTm9kZURlYnVnSW5mb3M7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50RGVidWdDb250ZXh0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBEZWJ1Z0FwcFZpZXcucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uIChjb250ZXh0LCBnaXZlblByb2plY3RhYmxlTm9kZXMsIHJvb3RTZWxlY3Rvck9yTm9kZSkge1xuICAgICAgICAgICAgdGhpcy5fcmVzZXREZWJ1ZygpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5jcmVhdGUuY2FsbCh0aGlzLCBjb250ZXh0LCBnaXZlblByb2plY3RhYmxlTm9kZXMsIHJvb3RTZWxlY3Rvck9yTm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JldGhyb3dXaXRoQ29udGV4dChlKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBEZWJ1Z0FwcFZpZXcucHJvdG90eXBlLmluamVjdG9yR2V0ID0gZnVuY3Rpb24gKHRva2VuLCBub2RlSW5kZXgsIG5vdEZvdW5kUmVzdWx0KSB7XG4gICAgICAgICAgICB0aGlzLl9yZXNldERlYnVnKCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLmluamVjdG9yR2V0LmNhbGwodGhpcywgdG9rZW4sIG5vZGVJbmRleCwgbm90Rm91bmRSZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXRocm93V2l0aENvbnRleHQoZSk7XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgRGVidWdBcHBWaWV3LnByb3RvdHlwZS5kZXRhY2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXNldERlYnVnKCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUuZGV0YWNoLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JldGhyb3dXaXRoQ29udGV4dChlKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBEZWJ1Z0FwcFZpZXcucHJvdG90eXBlLmRlc3Ryb3lMb2NhbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc2V0RGVidWcoKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5kZXN0cm95TG9jYWwuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmV0aHJvd1dpdGhDb250ZXh0KGUpO1xuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIERlYnVnQXBwVmlldy5wcm90b3R5cGUuZGV0ZWN0Q2hhbmdlcyA9IGZ1bmN0aW9uICh0aHJvd09uQ2hhbmdlKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXNldERlYnVnKCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUuZGV0ZWN0Q2hhbmdlcy5jYWxsKHRoaXMsIHRocm93T25DaGFuZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXRocm93V2l0aENvbnRleHQoZSk7XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgRGVidWdBcHBWaWV3LnByb3RvdHlwZS5fcmVzZXREZWJ1ZyA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fY3VycmVudERlYnVnQ29udGV4dCA9IG51bGw7IH07XG4gICAgICAgIERlYnVnQXBwVmlldy5wcm90b3R5cGUuZGVidWcgPSBmdW5jdGlvbiAobm9kZUluZGV4LCByb3dOdW0sIGNvbE51bSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnREZWJ1Z0NvbnRleHQgPSBuZXcgRGVidWdDb250ZXh0KHRoaXMsIG5vZGVJbmRleCwgcm93TnVtLCBjb2xOdW0pO1xuICAgICAgICB9O1xuICAgICAgICBEZWJ1Z0FwcFZpZXcucHJvdG90eXBlLl9yZXRocm93V2l0aENvbnRleHQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgaWYgKCEoZSBpbnN0YW5jZW9mIFZpZXdXcmFwcGVkRXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEoZSBpbnN0YW5jZW9mIEV4cHJlc3Npb25DaGFuZ2VkQWZ0ZXJJdEhhc0JlZW5DaGVja2VkRXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2RNb2RlID0gQ2hhbmdlRGV0ZWN0b3JTdGF0dXMuRXJyb3JlZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLl9jdXJyZW50RGVidWdDb250ZXh0KSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVmlld1dyYXBwZWRFcnJvcihlLCB0aGlzLl9jdXJyZW50RGVidWdDb250ZXh0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIERlYnVnQXBwVmlldy5wcm90b3R5cGUuZXZlbnRIYW5kbGVyID0gZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIHN1cGVySGFuZGxlciA9IF9zdXBlci5wcm90b3R5cGUuZXZlbnRIYW5kbGVyLmNhbGwodGhpcywgY2IpO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgIF90aGlzLl9yZXNldERlYnVnKCk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN1cGVySGFuZGxlcihldmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9yZXRocm93V2l0aENvbnRleHQoZSk7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIERlYnVnQXBwVmlldztcbiAgICB9KEFwcFZpZXcpKTtcbiAgICBmdW5jdGlvbiBfZmluZExhc3RSZW5kZXJOb2RlKG5vZGUpIHtcbiAgICAgICAgdmFyIGxhc3ROb2RlO1xuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFwcEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHZhciBhcHBFbCA9IG5vZGU7XG4gICAgICAgICAgICBsYXN0Tm9kZSA9IGFwcEVsLm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgICAgICBpZiAoaXNQcmVzZW50KGFwcEVsLm5lc3RlZFZpZXdzKSkge1xuICAgICAgICAgICAgICAgIC8vIE5vdGU6IFZpZXdzIG1pZ2h0IGhhdmUgbm8gcm9vdCBub2RlcyBhdCBhbGwhXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IGFwcEVsLm5lc3RlZFZpZXdzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXN0ZWRWaWV3ID0gYXBwRWwubmVzdGVkVmlld3NbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXN0ZWRWaWV3LnJvb3ROb2Rlc09yQXBwRWxlbWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdE5vZGUgPSBfZmluZExhc3RSZW5kZXJOb2RlKG5lc3RlZFZpZXcucm9vdE5vZGVzT3JBcHBFbGVtZW50c1tuZXN0ZWRWaWV3LnJvb3ROb2Rlc09yQXBwRWxlbWVudHMubGVuZ3RoIC0gMV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGFzdE5vZGUgPSBub2RlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsYXN0Tm9kZTtcbiAgICB9XG5cbiAgICB2YXIgX19jb3JlX3ByaXZhdGVfXyA9IHtcbiAgICAgICAgaXNEZWZhdWx0Q2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3k6IGlzRGVmYXVsdENoYW5nZURldGVjdGlvblN0cmF0ZWd5LFxuICAgICAgICBDaGFuZ2VEZXRlY3RvclN0YXR1czogQ2hhbmdlRGV0ZWN0b3JTdGF0dXMsXG4gICAgICAgIGNvbnN0cnVjdERlcGVuZGVuY2llczogY29uc3RydWN0RGVwZW5kZW5jaWVzLFxuICAgICAgICBMaWZlY3ljbGVIb29rczogTGlmZWN5Y2xlSG9va3MsXG4gICAgICAgIExJRkVDWUNMRV9IT09LU19WQUxVRVM6IExJRkVDWUNMRV9IT09LU19WQUxVRVMsXG4gICAgICAgIFJlZmxlY3RvclJlYWRlcjogUmVmbGVjdG9yUmVhZGVyLFxuICAgICAgICBDb2RlZ2VuQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyOiBDb2RlZ2VuQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyLFxuICAgICAgICBBcHBFbGVtZW50OiBBcHBFbGVtZW50LFxuICAgICAgICBBcHBWaWV3OiBBcHBWaWV3LFxuICAgICAgICBEZWJ1Z0FwcFZpZXc6IERlYnVnQXBwVmlldyxcbiAgICAgICAgTmdNb2R1bGVJbmplY3RvcjogTmdNb2R1bGVJbmplY3RvcixcbiAgICAgICAgcmVnaXN0ZXJNb2R1bGVGYWN0b3J5OiByZWdpc3Rlck1vZHVsZUZhY3RvcnksXG4gICAgICAgIFZpZXdUeXBlOiBWaWV3VHlwZSxcbiAgICAgICAgdmlld191dGlsczogdmlld191dGlscyxcbiAgICAgICAgVmlld01ldGFkYXRhOiBWaWV3TWV0YWRhdGEsXG4gICAgICAgIERlYnVnQ29udGV4dDogRGVidWdDb250ZXh0LFxuICAgICAgICBTdGF0aWNOb2RlRGVidWdJbmZvOiBTdGF0aWNOb2RlRGVidWdJbmZvLFxuICAgICAgICBkZXZNb2RlRXF1YWw6IGRldk1vZGVFcXVhbCxcbiAgICAgICAgVU5JTklUSUFMSVpFRDogVU5JTklUSUFMSVpFRCxcbiAgICAgICAgVmFsdWVVbndyYXBwZXI6IFZhbHVlVW53cmFwcGVyLFxuICAgICAgICBSZW5kZXJEZWJ1Z0luZm86IFJlbmRlckRlYnVnSW5mbyxcbiAgICAgICAgVGVtcGxhdGVSZWZfOiBUZW1wbGF0ZVJlZl8sXG4gICAgICAgIFJlZmxlY3Rpb25DYXBhYmlsaXRpZXM6IFJlZmxlY3Rpb25DYXBhYmlsaXRpZXMsXG4gICAgICAgIG1ha2VEZWNvcmF0b3I6IG1ha2VEZWNvcmF0b3IsXG4gICAgICAgIERlYnVnRG9tUm9vdFJlbmRlcmVyOiBEZWJ1Z0RvbVJvb3RSZW5kZXJlcixcbiAgICAgICAgQ29uc29sZTogQ29uc29sZSxcbiAgICAgICAgcmVmbGVjdG9yOiByZWZsZWN0b3IsXG4gICAgICAgIFJlZmxlY3RvcjogUmVmbGVjdG9yLFxuICAgICAgICBOb09wQW5pbWF0aW9uUGxheWVyOiBOb09wQW5pbWF0aW9uUGxheWVyLFxuICAgICAgICBBbmltYXRpb25QbGF5ZXI6IEFuaW1hdGlvblBsYXllcixcbiAgICAgICAgQW5pbWF0aW9uU2VxdWVuY2VQbGF5ZXI6IEFuaW1hdGlvblNlcXVlbmNlUGxheWVyLFxuICAgICAgICBBbmltYXRpb25Hcm91cFBsYXllcjogQW5pbWF0aW9uR3JvdXBQbGF5ZXIsXG4gICAgICAgIEFuaW1hdGlvbktleWZyYW1lOiBBbmltYXRpb25LZXlmcmFtZSxcbiAgICAgICAgcHJlcGFyZUZpbmFsQW5pbWF0aW9uU3R5bGVzOiBwcmVwYXJlRmluYWxBbmltYXRpb25TdHlsZXMsXG4gICAgICAgIGJhbGFuY2VBbmltYXRpb25LZXlmcmFtZXM6IGJhbGFuY2VBbmltYXRpb25LZXlmcmFtZXMsXG4gICAgICAgIGZsYXR0ZW5TdHlsZXM6IGZsYXR0ZW5TdHlsZXMsXG4gICAgICAgIGNsZWFyU3R5bGVzOiBjbGVhclN0eWxlcyxcbiAgICAgICAgcmVuZGVyU3R5bGVzOiByZW5kZXJTdHlsZXMsXG4gICAgICAgIGNvbGxlY3RBbmRSZXNvbHZlU3R5bGVzOiBjb2xsZWN0QW5kUmVzb2x2ZVN0eWxlcyxcbiAgICAgICAgQW5pbWF0aW9uU3R5bGVzOiBBbmltYXRpb25TdHlsZXMsXG4gICAgICAgIEFOWV9TVEFURTogQU5ZX1NUQVRFLFxuICAgICAgICBERUZBVUxUX1NUQVRFOiBERUZBVUxUX1NUQVRFLFxuICAgICAgICBFTVBUWV9TVEFURTogRU1QVFlfU1RBVEUsXG4gICAgICAgIEZJTExfU1RZTEVfRkxBRzogRklMTF9TVFlMRV9GTEFHLFxuICAgICAgICBDb21wb25lbnRTdGlsbExvYWRpbmdFcnJvcjogQ29tcG9uZW50U3RpbGxMb2FkaW5nRXJyb3IsXG4gICAgICAgIGlzUHJvbWlzZTogaXNQcm9taXNlLFxuICAgICAgICBBbmltYXRpb25UcmFuc2l0aW9uOiBBbmltYXRpb25UcmFuc2l0aW9uXG4gICAgfTtcblxuICAgIGV4cG9ydHMuY3JlYXRlUGxhdGZvcm0gPSBjcmVhdGVQbGF0Zm9ybTtcbiAgICBleHBvcnRzLmFzc2VydFBsYXRmb3JtID0gYXNzZXJ0UGxhdGZvcm07XG4gICAgZXhwb3J0cy5kZXN0cm95UGxhdGZvcm0gPSBkZXN0cm95UGxhdGZvcm07XG4gICAgZXhwb3J0cy5nZXRQbGF0Zm9ybSA9IGdldFBsYXRmb3JtO1xuICAgIGV4cG9ydHMuUGxhdGZvcm1SZWYgPSBQbGF0Zm9ybVJlZjtcbiAgICBleHBvcnRzLkFwcGxpY2F0aW9uUmVmID0gQXBwbGljYXRpb25SZWY7XG4gICAgZXhwb3J0cy5lbmFibGVQcm9kTW9kZSA9IGVuYWJsZVByb2RNb2RlO1xuICAgIGV4cG9ydHMuaXNEZXZNb2RlID0gaXNEZXZNb2RlO1xuICAgIGV4cG9ydHMuY3JlYXRlUGxhdGZvcm1GYWN0b3J5ID0gY3JlYXRlUGxhdGZvcm1GYWN0b3J5O1xuICAgIGV4cG9ydHMuQVBQX0lEID0gQVBQX0lEO1xuICAgIGV4cG9ydHMuUEFDS0FHRV9ST09UX1VSTCA9IFBBQ0tBR0VfUk9PVF9VUkw7XG4gICAgZXhwb3J0cy5QTEFURk9STV9JTklUSUFMSVpFUiA9IFBMQVRGT1JNX0lOSVRJQUxJWkVSO1xuICAgIGV4cG9ydHMuQVBQX0JPT1RTVFJBUF9MSVNURU5FUiA9IEFQUF9CT09UU1RSQVBfTElTVEVORVI7XG4gICAgZXhwb3J0cy5BUFBfSU5JVElBTElaRVIgPSBBUFBfSU5JVElBTElaRVI7XG4gICAgZXhwb3J0cy5BcHBsaWNhdGlvbkluaXRTdGF0dXMgPSBBcHBsaWNhdGlvbkluaXRTdGF0dXM7XG4gICAgZXhwb3J0cy5EZWJ1Z0VsZW1lbnQgPSBEZWJ1Z0VsZW1lbnQ7XG4gICAgZXhwb3J0cy5EZWJ1Z05vZGUgPSBEZWJ1Z05vZGU7XG4gICAgZXhwb3J0cy5hc05hdGl2ZUVsZW1lbnRzID0gYXNOYXRpdmVFbGVtZW50cztcbiAgICBleHBvcnRzLmdldERlYnVnTm9kZSA9IGdldERlYnVnTm9kZTtcbiAgICBleHBvcnRzLlRlc3RhYmlsaXR5ID0gVGVzdGFiaWxpdHk7XG4gICAgZXhwb3J0cy5UZXN0YWJpbGl0eVJlZ2lzdHJ5ID0gVGVzdGFiaWxpdHlSZWdpc3RyeTtcbiAgICBleHBvcnRzLnNldFRlc3RhYmlsaXR5R2V0dGVyID0gc2V0VGVzdGFiaWxpdHlHZXR0ZXI7XG4gICAgZXhwb3J0cy5UUkFOU0xBVElPTlMgPSBUUkFOU0xBVElPTlM7XG4gICAgZXhwb3J0cy5UUkFOU0xBVElPTlNfRk9STUFUID0gVFJBTlNMQVRJT05TX0ZPUk1BVDtcbiAgICBleHBvcnRzLkxPQ0FMRV9JRCA9IExPQ0FMRV9JRDtcbiAgICBleHBvcnRzLkFwcGxpY2F0aW9uTW9kdWxlID0gQXBwbGljYXRpb25Nb2R1bGU7XG4gICAgZXhwb3J0cy53dGZDcmVhdGVTY29wZSA9IHd0ZkNyZWF0ZVNjb3BlO1xuICAgIGV4cG9ydHMud3RmTGVhdmUgPSB3dGZMZWF2ZTtcbiAgICBleHBvcnRzLnd0ZlN0YXJ0VGltZVJhbmdlID0gd3RmU3RhcnRUaW1lUmFuZ2U7XG4gICAgZXhwb3J0cy53dGZFbmRUaW1lUmFuZ2UgPSB3dGZFbmRUaW1lUmFuZ2U7XG4gICAgZXhwb3J0cy5UeXBlID0gVHlwZTtcbiAgICBleHBvcnRzLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcbiAgICBleHBvcnRzLkVycm9ySGFuZGxlciA9IEVycm9ySGFuZGxlcjtcbiAgICBleHBvcnRzLkFuaW1hdGlvblRyYW5zaXRpb25FdmVudCA9IEFuaW1hdGlvblRyYW5zaXRpb25FdmVudDtcbiAgICBleHBvcnRzLkFuaW1hdGlvblBsYXllciA9IEFuaW1hdGlvblBsYXllcjtcbiAgICBleHBvcnRzLlNhbml0aXplciA9IFNhbml0aXplcjtcbiAgICBleHBvcnRzLkFOQUxZWkVfRk9SX0VOVFJZX0NPTVBPTkVOVFMgPSBBTkFMWVpFX0ZPUl9FTlRSWV9DT01QT05FTlRTO1xuICAgIGV4cG9ydHMuQXR0cmlidXRlID0gQXR0cmlidXRlO1xuICAgIGV4cG9ydHMuQ29udGVudENoaWxkID0gQ29udGVudENoaWxkO1xuICAgIGV4cG9ydHMuQ29udGVudENoaWxkcmVuID0gQ29udGVudENoaWxkcmVuO1xuICAgIGV4cG9ydHMuUXVlcnkgPSBRdWVyeTtcbiAgICBleHBvcnRzLlZpZXdDaGlsZCA9IFZpZXdDaGlsZDtcbiAgICBleHBvcnRzLlZpZXdDaGlsZHJlbiA9IFZpZXdDaGlsZHJlbjtcbiAgICBleHBvcnRzLkNvbXBvbmVudCA9IENvbXBvbmVudDtcbiAgICBleHBvcnRzLkRpcmVjdGl2ZSA9IERpcmVjdGl2ZTtcbiAgICBleHBvcnRzLkhvc3RCaW5kaW5nID0gSG9zdEJpbmRpbmc7XG4gICAgZXhwb3J0cy5Ib3N0TGlzdGVuZXIgPSBIb3N0TGlzdGVuZXI7XG4gICAgZXhwb3J0cy5JbnB1dCA9IElucHV0O1xuICAgIGV4cG9ydHMuT3V0cHV0ID0gT3V0cHV0O1xuICAgIGV4cG9ydHMuUGlwZSA9IFBpcGU7XG4gICAgZXhwb3J0cy5BZnRlckNvbnRlbnRDaGVja2VkID0gQWZ0ZXJDb250ZW50Q2hlY2tlZDtcbiAgICBleHBvcnRzLkFmdGVyQ29udGVudEluaXQgPSBBZnRlckNvbnRlbnRJbml0O1xuICAgIGV4cG9ydHMuQWZ0ZXJWaWV3Q2hlY2tlZCA9IEFmdGVyVmlld0NoZWNrZWQ7XG4gICAgZXhwb3J0cy5BZnRlclZpZXdJbml0ID0gQWZ0ZXJWaWV3SW5pdDtcbiAgICBleHBvcnRzLkRvQ2hlY2sgPSBEb0NoZWNrO1xuICAgIGV4cG9ydHMuT25DaGFuZ2VzID0gT25DaGFuZ2VzO1xuICAgIGV4cG9ydHMuT25EZXN0cm95ID0gT25EZXN0cm95O1xuICAgIGV4cG9ydHMuT25Jbml0ID0gT25Jbml0O1xuICAgIGV4cG9ydHMuQ1VTVE9NX0VMRU1FTlRTX1NDSEVNQSA9IENVU1RPTV9FTEVNRU5UU19TQ0hFTUE7XG4gICAgZXhwb3J0cy5OT19FUlJPUlNfU0NIRU1BID0gTk9fRVJST1JTX1NDSEVNQTtcbiAgICBleHBvcnRzLk5nTW9kdWxlID0gTmdNb2R1bGU7XG4gICAgZXhwb3J0cy5DbGFzcyA9IENsYXNzO1xuICAgIGV4cG9ydHMuZm9yd2FyZFJlZiA9IGZvcndhcmRSZWY7XG4gICAgZXhwb3J0cy5yZXNvbHZlRm9yd2FyZFJlZiA9IHJlc29sdmVGb3J3YXJkUmVmO1xuICAgIGV4cG9ydHMuSW5qZWN0b3IgPSBJbmplY3RvcjtcbiAgICBleHBvcnRzLlJlZmxlY3RpdmVJbmplY3RvciA9IFJlZmxlY3RpdmVJbmplY3RvcjtcbiAgICBleHBvcnRzLlJlc29sdmVkUmVmbGVjdGl2ZUZhY3RvcnkgPSBSZXNvbHZlZFJlZmxlY3RpdmVGYWN0b3J5O1xuICAgIGV4cG9ydHMuUmVmbGVjdGl2ZUtleSA9IFJlZmxlY3RpdmVLZXk7XG4gICAgZXhwb3J0cy5PcGFxdWVUb2tlbiA9IE9wYXF1ZVRva2VuO1xuICAgIGV4cG9ydHMuSW5qZWN0ID0gSW5qZWN0O1xuICAgIGV4cG9ydHMuT3B0aW9uYWwgPSBPcHRpb25hbDtcbiAgICBleHBvcnRzLkluamVjdGFibGUgPSBJbmplY3RhYmxlO1xuICAgIGV4cG9ydHMuU2VsZiA9IFNlbGY7XG4gICAgZXhwb3J0cy5Ta2lwU2VsZiA9IFNraXBTZWxmO1xuICAgIGV4cG9ydHMuSG9zdCA9IEhvc3Q7XG4gICAgZXhwb3J0cy5OZ1pvbmUgPSBOZ1pvbmU7XG4gICAgZXhwb3J0cy5SZW5kZXJDb21wb25lbnRUeXBlID0gUmVuZGVyQ29tcG9uZW50VHlwZTtcbiAgICBleHBvcnRzLlJlbmRlcmVyID0gUmVuZGVyZXI7XG4gICAgZXhwb3J0cy5Sb290UmVuZGVyZXIgPSBSb290UmVuZGVyZXI7XG4gICAgZXhwb3J0cy5DT01QSUxFUl9PUFRJT05TID0gQ09NUElMRVJfT1BUSU9OUztcbiAgICBleHBvcnRzLkNvbXBpbGVyID0gQ29tcGlsZXI7XG4gICAgZXhwb3J0cy5Db21waWxlckZhY3RvcnkgPSBDb21waWxlckZhY3Rvcnk7XG4gICAgZXhwb3J0cy5Nb2R1bGVXaXRoQ29tcG9uZW50RmFjdG9yaWVzID0gTW9kdWxlV2l0aENvbXBvbmVudEZhY3RvcmllcztcbiAgICBleHBvcnRzLkNvbXBvbmVudEZhY3RvcnkgPSBDb21wb25lbnRGYWN0b3J5O1xuICAgIGV4cG9ydHMuQ29tcG9uZW50UmVmID0gQ29tcG9uZW50UmVmO1xuICAgIGV4cG9ydHMuQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyID0gQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyO1xuICAgIGV4cG9ydHMuRWxlbWVudFJlZiA9IEVsZW1lbnRSZWY7XG4gICAgZXhwb3J0cy5OZ01vZHVsZUZhY3RvcnkgPSBOZ01vZHVsZUZhY3Rvcnk7XG4gICAgZXhwb3J0cy5OZ01vZHVsZVJlZiA9IE5nTW9kdWxlUmVmO1xuICAgIGV4cG9ydHMuTmdNb2R1bGVGYWN0b3J5TG9hZGVyID0gTmdNb2R1bGVGYWN0b3J5TG9hZGVyO1xuICAgIGV4cG9ydHMuZ2V0TW9kdWxlRmFjdG9yeSA9IGdldE1vZHVsZUZhY3Rvcnk7XG4gICAgZXhwb3J0cy5RdWVyeUxpc3QgPSBRdWVyeUxpc3Q7XG4gICAgZXhwb3J0cy5TeXN0ZW1Kc05nTW9kdWxlTG9hZGVyID0gU3lzdGVtSnNOZ01vZHVsZUxvYWRlcjtcbiAgICBleHBvcnRzLlN5c3RlbUpzTmdNb2R1bGVMb2FkZXJDb25maWcgPSBTeXN0ZW1Kc05nTW9kdWxlTG9hZGVyQ29uZmlnO1xuICAgIGV4cG9ydHMuVGVtcGxhdGVSZWYgPSBUZW1wbGF0ZVJlZjtcbiAgICBleHBvcnRzLlZpZXdDb250YWluZXJSZWYgPSBWaWV3Q29udGFpbmVyUmVmO1xuICAgIGV4cG9ydHMuRW1iZWRkZWRWaWV3UmVmID0gRW1iZWRkZWRWaWV3UmVmO1xuICAgIGV4cG9ydHMuVmlld1JlZiA9IFZpZXdSZWY7XG4gICAgZXhwb3J0cy5DaGFuZ2VEZXRlY3RvclJlZiA9IENoYW5nZURldGVjdG9yUmVmO1xuICAgIGV4cG9ydHMuQ29sbGVjdGlvbkNoYW5nZVJlY29yZCA9IENvbGxlY3Rpb25DaGFuZ2VSZWNvcmQ7XG4gICAgZXhwb3J0cy5EZWZhdWx0SXRlcmFibGVEaWZmZXIgPSBEZWZhdWx0SXRlcmFibGVEaWZmZXI7XG4gICAgZXhwb3J0cy5JdGVyYWJsZURpZmZlcnMgPSBJdGVyYWJsZURpZmZlcnM7XG4gICAgZXhwb3J0cy5LZXlWYWx1ZUNoYW5nZVJlY29yZCA9IEtleVZhbHVlQ2hhbmdlUmVjb3JkO1xuICAgIGV4cG9ydHMuS2V5VmFsdWVEaWZmZXJzID0gS2V5VmFsdWVEaWZmZXJzO1xuICAgIGV4cG9ydHMuU2ltcGxlQ2hhbmdlID0gU2ltcGxlQ2hhbmdlO1xuICAgIGV4cG9ydHMuV3JhcHBlZFZhbHVlID0gV3JhcHBlZFZhbHVlO1xuICAgIGV4cG9ydHMucGxhdGZvcm1Db3JlID0gcGxhdGZvcm1Db3JlO1xuICAgIGV4cG9ydHMuX19jb3JlX3ByaXZhdGVfXyA9IF9fY29yZV9wcml2YXRlX187XG4gICAgZXhwb3J0cy5BVVRPX1NUWUxFID0gQVVUT19TVFlMRTtcbiAgICBleHBvcnRzLkFuaW1hdGlvbkVudHJ5TWV0YWRhdGEgPSBBbmltYXRpb25FbnRyeU1ldGFkYXRhO1xuICAgIGV4cG9ydHMuQW5pbWF0aW9uU3RhdGVNZXRhZGF0YSA9IEFuaW1hdGlvblN0YXRlTWV0YWRhdGE7XG4gICAgZXhwb3J0cy5BbmltYXRpb25TdGF0ZURlY2xhcmF0aW9uTWV0YWRhdGEgPSBBbmltYXRpb25TdGF0ZURlY2xhcmF0aW9uTWV0YWRhdGE7XG4gICAgZXhwb3J0cy5BbmltYXRpb25TdGF0ZVRyYW5zaXRpb25NZXRhZGF0YSA9IEFuaW1hdGlvblN0YXRlVHJhbnNpdGlvbk1ldGFkYXRhO1xuICAgIGV4cG9ydHMuQW5pbWF0aW9uTWV0YWRhdGEgPSBBbmltYXRpb25NZXRhZGF0YTtcbiAgICBleHBvcnRzLkFuaW1hdGlvbktleWZyYW1lc1NlcXVlbmNlTWV0YWRhdGEgPSBBbmltYXRpb25LZXlmcmFtZXNTZXF1ZW5jZU1ldGFkYXRhO1xuICAgIGV4cG9ydHMuQW5pbWF0aW9uU3R5bGVNZXRhZGF0YSA9IEFuaW1hdGlvblN0eWxlTWV0YWRhdGE7XG4gICAgZXhwb3J0cy5BbmltYXRpb25BbmltYXRlTWV0YWRhdGEgPSBBbmltYXRpb25BbmltYXRlTWV0YWRhdGE7XG4gICAgZXhwb3J0cy5BbmltYXRpb25XaXRoU3RlcHNNZXRhZGF0YSA9IEFuaW1hdGlvbldpdGhTdGVwc01ldGFkYXRhO1xuICAgIGV4cG9ydHMuQW5pbWF0aW9uU2VxdWVuY2VNZXRhZGF0YSA9IEFuaW1hdGlvblNlcXVlbmNlTWV0YWRhdGE7XG4gICAgZXhwb3J0cy5BbmltYXRpb25Hcm91cE1ldGFkYXRhID0gQW5pbWF0aW9uR3JvdXBNZXRhZGF0YTtcbiAgICBleHBvcnRzLmFuaW1hdGUgPSBhbmltYXRlO1xuICAgIGV4cG9ydHMuZ3JvdXAgPSBncm91cDtcbiAgICBleHBvcnRzLnNlcXVlbmNlID0gc2VxdWVuY2U7XG4gICAgZXhwb3J0cy5zdHlsZSA9IHN0eWxlO1xuICAgIGV4cG9ydHMuc3RhdGUgPSBzdGF0ZTtcbiAgICBleHBvcnRzLmtleWZyYW1lcyA9IGtleWZyYW1lcztcbiAgICBleHBvcnRzLnRyYW5zaXRpb24gPSB0cmFuc2l0aW9uO1xuICAgIGV4cG9ydHMudHJpZ2dlciA9IHRyaWdnZXI7XG5cbn0pKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9AYW5ndWxhci9jb3JlL2J1bmRsZXMvY29yZS51bWQuanNcbi8vIG1vZHVsZSBpZCA9IDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuL09ic2VydmFibGUnKTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuL1N1YnNjcmliZXInKTtcbnZhciBTdWJzY3JpcHRpb25fMSA9IHJlcXVpcmUoJy4vU3Vic2NyaXB0aW9uJyk7XG52YXIgT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3JfMSA9IHJlcXVpcmUoJy4vdXRpbC9PYmplY3RVbnN1YnNjcmliZWRFcnJvcicpO1xudmFyIFN1YmplY3RTdWJzY3JpcHRpb25fMSA9IHJlcXVpcmUoJy4vU3ViamVjdFN1YnNjcmlwdGlvbicpO1xudmFyIHJ4U3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi9zeW1ib2wvcnhTdWJzY3JpYmVyJyk7XG4vKipcbiAqIEBjbGFzcyBTdWJqZWN0U3Vic2NyaWJlcjxUPlxuICovXG52YXIgU3ViamVjdFN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTdWJqZWN0U3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTdWJqZWN0U3Vic2NyaWJlcihkZXN0aW5hdGlvbikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24gPSBkZXN0aW5hdGlvbjtcbiAgICB9XG4gICAgcmV0dXJuIFN1YmplY3RTdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcikpO1xuZXhwb3J0cy5TdWJqZWN0U3Vic2NyaWJlciA9IFN1YmplY3RTdWJzY3JpYmVyO1xuLyoqXG4gKiBAY2xhc3MgU3ViamVjdDxUPlxuICovXG52YXIgU3ViamVjdCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFN1YmplY3QsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU3ViamVjdCgpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXJzID0gW107XG4gICAgICAgIHRoaXMuY2xvc2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNTdG9wcGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaGFzRXJyb3IgPSBmYWxzZTtcbiAgICAgICAgdGhpcy50aHJvd25FcnJvciA9IG51bGw7XG4gICAgfVxuICAgIFN1YmplY3QucHJvdG90eXBlW3J4U3Vic2NyaWJlcl8xLiQkcnhTdWJzY3JpYmVyXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdWJqZWN0U3Vic2NyaWJlcih0aGlzKTtcbiAgICB9O1xuICAgIFN1YmplY3QucHJvdG90eXBlLmxpZnQgPSBmdW5jdGlvbiAob3BlcmF0b3IpIHtcbiAgICAgICAgdmFyIHN1YmplY3QgPSBuZXcgQW5vbnltb3VzU3ViamVjdCh0aGlzLCB0aGlzKTtcbiAgICAgICAgc3ViamVjdC5vcGVyYXRvciA9IG9wZXJhdG9yO1xuICAgICAgICByZXR1cm4gc3ViamVjdDtcbiAgICB9O1xuICAgIFN1YmplY3QucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuY2xvc2VkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3JfMS5PYmplY3RVbnN1YnNjcmliZWRFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5pc1N0b3BwZWQpIHtcbiAgICAgICAgICAgIHZhciBvYnNlcnZlcnMgPSB0aGlzLm9ic2VydmVycztcbiAgICAgICAgICAgIHZhciBsZW4gPSBvYnNlcnZlcnMubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIGNvcHkgPSBvYnNlcnZlcnMuc2xpY2UoKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb3B5W2ldLm5leHQodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBTdWJqZWN0LnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgaWYgKHRoaXMuY2xvc2VkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3JfMS5PYmplY3RVbnN1YnNjcmliZWRFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaGFzRXJyb3IgPSB0cnVlO1xuICAgICAgICB0aGlzLnRocm93bkVycm9yID0gZXJyO1xuICAgICAgICB0aGlzLmlzU3RvcHBlZCA9IHRydWU7XG4gICAgICAgIHZhciBvYnNlcnZlcnMgPSB0aGlzLm9ic2VydmVycztcbiAgICAgICAgdmFyIGxlbiA9IG9ic2VydmVycy5sZW5ndGg7XG4gICAgICAgIHZhciBjb3B5ID0gb2JzZXJ2ZXJzLnNsaWNlKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGNvcHlbaV0uZXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9ic2VydmVycy5sZW5ndGggPSAwO1xuICAgIH07XG4gICAgU3ViamVjdC5wcm90b3R5cGUuY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmNsb3NlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE9iamVjdFVuc3Vic2NyaWJlZEVycm9yXzEuT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzU3RvcHBlZCA9IHRydWU7XG4gICAgICAgIHZhciBvYnNlcnZlcnMgPSB0aGlzLm9ic2VydmVycztcbiAgICAgICAgdmFyIGxlbiA9IG9ic2VydmVycy5sZW5ndGg7XG4gICAgICAgIHZhciBjb3B5ID0gb2JzZXJ2ZXJzLnNsaWNlKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGNvcHlbaV0uY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9ic2VydmVycy5sZW5ndGggPSAwO1xuICAgIH07XG4gICAgU3ViamVjdC5wcm90b3R5cGUudW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaXNTdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jbG9zZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLm9ic2VydmVycyA9IG51bGw7XG4gICAgfTtcbiAgICBTdWJqZWN0LnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuY2xvc2VkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3JfMS5PYmplY3RVbnN1YnNjcmliZWRFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuaGFzRXJyb3IpIHtcbiAgICAgICAgICAgIHN1YnNjcmliZXIuZXJyb3IodGhpcy50aHJvd25FcnJvcik7XG4gICAgICAgICAgICByZXR1cm4gU3Vic2NyaXB0aW9uXzEuU3Vic2NyaXB0aW9uLkVNUFRZO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICAgICAgICBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICByZXR1cm4gU3Vic2NyaXB0aW9uXzEuU3Vic2NyaXB0aW9uLkVNUFRZO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5vYnNlcnZlcnMucHVzaChzdWJzY3JpYmVyKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU3ViamVjdFN1YnNjcmlwdGlvbl8xLlN1YmplY3RTdWJzY3JpcHRpb24odGhpcywgc3Vic2NyaWJlcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN1YmplY3QucHJvdG90eXBlLmFzT2JzZXJ2YWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG9ic2VydmFibGUgPSBuZXcgT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUoKTtcbiAgICAgICAgb2JzZXJ2YWJsZS5zb3VyY2UgPSB0aGlzO1xuICAgICAgICByZXR1cm4gb2JzZXJ2YWJsZTtcbiAgICB9O1xuICAgIFN1YmplY3QuY3JlYXRlID0gZnVuY3Rpb24gKGRlc3RpbmF0aW9uLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBbm9ueW1vdXNTdWJqZWN0KGRlc3RpbmF0aW9uLCBzb3VyY2UpO1xuICAgIH07XG4gICAgcmV0dXJuIFN1YmplY3Q7XG59KE9ic2VydmFibGVfMS5PYnNlcnZhYmxlKSk7XG5leHBvcnRzLlN1YmplY3QgPSBTdWJqZWN0O1xuLyoqXG4gKiBAY2xhc3MgQW5vbnltb3VzU3ViamVjdDxUPlxuICovXG52YXIgQW5vbnltb3VzU3ViamVjdCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFub255bW91c1N1YmplY3QsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQW5vbnltb3VzU3ViamVjdChkZXN0aW5hdGlvbiwgc291cmNlKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uID0gZGVzdGluYXRpb247XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgIH1cbiAgICBBbm9ueW1vdXNTdWJqZWN0LnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBkZXN0aW5hdGlvbiA9IHRoaXMuZGVzdGluYXRpb247XG4gICAgICAgIGlmIChkZXN0aW5hdGlvbiAmJiBkZXN0aW5hdGlvbi5uZXh0KSB7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5uZXh0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQW5vbnltb3VzU3ViamVjdC5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHZhciBkZXN0aW5hdGlvbiA9IHRoaXMuZGVzdGluYXRpb247XG4gICAgICAgIGlmIChkZXN0aW5hdGlvbiAmJiBkZXN0aW5hdGlvbi5lcnJvcikge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBBbm9ueW1vdXNTdWJqZWN0LnByb3RvdHlwZS5jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRlc3RpbmF0aW9uID0gdGhpcy5kZXN0aW5hdGlvbjtcbiAgICAgICAgaWYgKGRlc3RpbmF0aW9uICYmIGRlc3RpbmF0aW9uLmNvbXBsZXRlKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEFub255bW91c1N1YmplY3QucHJvdG90eXBlLl9zdWJzY3JpYmUgPSBmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgICAgICB2YXIgc291cmNlID0gdGhpcy5zb3VyY2U7XG4gICAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNvdXJjZS5zdWJzY3JpYmUoc3Vic2NyaWJlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gU3Vic2NyaXB0aW9uXzEuU3Vic2NyaXB0aW9uLkVNUFRZO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQW5vbnltb3VzU3ViamVjdDtcbn0oU3ViamVjdCkpO1xuZXhwb3J0cy5Bbm9ueW1vdXNTdWJqZWN0ID0gQW5vbnltb3VzU3ViamVjdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN1YmplY3QuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvU3ViamVjdC5qc1xuLy8gbW9kdWxlIGlkID0gNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciByb290XzEgPSByZXF1aXJlKCcuL3V0aWwvcm9vdCcpO1xudmFyIHRvU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi91dGlsL3RvU3Vic2NyaWJlcicpO1xudmFyIG9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4vc3ltYm9sL29ic2VydmFibGUnKTtcbi8qKlxuICogQSByZXByZXNlbnRhdGlvbiBvZiBhbnkgc2V0IG9mIHZhbHVlcyBvdmVyIGFueSBhbW91bnQgb2YgdGltZS4gVGhpcyB0aGUgbW9zdCBiYXNpYyBidWlsZGluZyBibG9ja1xuICogb2YgUnhKUy5cbiAqXG4gKiBAY2xhc3MgT2JzZXJ2YWJsZTxUPlxuICovXG52YXIgT2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc3Vic2NyaWJlIHRoZSBmdW5jdGlvbiB0aGF0IGlzICBjYWxsZWQgd2hlbiB0aGUgT2JzZXJ2YWJsZSBpc1xuICAgICAqIGluaXRpYWxseSBzdWJzY3JpYmVkIHRvLiBUaGlzIGZ1bmN0aW9uIGlzIGdpdmVuIGEgU3Vic2NyaWJlciwgdG8gd2hpY2ggbmV3IHZhbHVlc1xuICAgICAqIGNhbiBiZSBgbmV4dGBlZCwgb3IgYW4gYGVycm9yYCBtZXRob2QgY2FuIGJlIGNhbGxlZCB0byByYWlzZSBhbiBlcnJvciwgb3JcbiAgICAgKiBgY29tcGxldGVgIGNhbiBiZSBjYWxsZWQgdG8gbm90aWZ5IG9mIGEgc3VjY2Vzc2Z1bCBjb21wbGV0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIE9ic2VydmFibGUoc3Vic2NyaWJlKSB7XG4gICAgICAgIHRoaXMuX2lzU2NhbGFyID0gZmFsc2U7XG4gICAgICAgIGlmIChzdWJzY3JpYmUpIHtcbiAgICAgICAgICAgIHRoaXMuX3N1YnNjcmliZSA9IHN1YnNjcmliZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IE9ic2VydmFibGUsIHdpdGggdGhpcyBPYnNlcnZhYmxlIGFzIHRoZSBzb3VyY2UsIGFuZCB0aGUgcGFzc2VkXG4gICAgICogb3BlcmF0b3IgZGVmaW5lZCBhcyB0aGUgbmV3IG9ic2VydmFibGUncyBvcGVyYXRvci5cbiAgICAgKiBAbWV0aG9kIGxpZnRcbiAgICAgKiBAcGFyYW0ge09wZXJhdG9yfSBvcGVyYXRvciB0aGUgb3BlcmF0b3IgZGVmaW5pbmcgdGhlIG9wZXJhdGlvbiB0byB0YWtlIG9uIHRoZSBvYnNlcnZhYmxlXG4gICAgICogQHJldHVybiB7T2JzZXJ2YWJsZX0gYSBuZXcgb2JzZXJ2YWJsZSB3aXRoIHRoZSBPcGVyYXRvciBhcHBsaWVkXG4gICAgICovXG4gICAgT2JzZXJ2YWJsZS5wcm90b3R5cGUubGlmdCA9IGZ1bmN0aW9uIChvcGVyYXRvcikge1xuICAgICAgICB2YXIgb2JzZXJ2YWJsZSA9IG5ldyBPYnNlcnZhYmxlKCk7XG4gICAgICAgIG9ic2VydmFibGUuc291cmNlID0gdGhpcztcbiAgICAgICAgb2JzZXJ2YWJsZS5vcGVyYXRvciA9IG9wZXJhdG9yO1xuICAgICAgICByZXR1cm4gb2JzZXJ2YWJsZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBoYW5kbGVycyBmb3IgaGFuZGxpbmcgZW1pdHRlZCB2YWx1ZXMsIGVycm9yIGFuZCBjb21wbGV0aW9ucyBmcm9tIHRoZSBvYnNlcnZhYmxlLCBhbmRcbiAgICAgKiAgZXhlY3V0ZXMgdGhlIG9ic2VydmFibGUncyBzdWJzY3JpYmVyIGZ1bmN0aW9uLCB3aGljaCB3aWxsIHRha2UgYWN0aW9uIHRvIHNldCB1cCB0aGUgdW5kZXJseWluZyBkYXRhIHN0cmVhbVxuICAgICAqIEBtZXRob2Qgc3Vic2NyaWJlXG4gICAgICogQHBhcmFtIHtQYXJ0aWFsT2JzZXJ2ZXJ8RnVuY3Rpb259IG9ic2VydmVyT3JOZXh0IChvcHRpb25hbCkgZWl0aGVyIGFuIG9ic2VydmVyIGRlZmluaW5nIGFsbCBmdW5jdGlvbnMgdG8gYmUgY2FsbGVkLFxuICAgICAqICBvciB0aGUgZmlyc3Qgb2YgdGhyZWUgcG9zc2libGUgaGFuZGxlcnMsIHdoaWNoIGlzIHRoZSBoYW5kbGVyIGZvciBlYWNoIHZhbHVlIGVtaXR0ZWQgZnJvbSB0aGUgb2JzZXJ2YWJsZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcnJvciAob3B0aW9uYWwpIGEgaGFuZGxlciBmb3IgYSB0ZXJtaW5hbCBldmVudCByZXN1bHRpbmcgZnJvbSBhbiBlcnJvci4gSWYgbm8gZXJyb3IgaGFuZGxlciBpcyBwcm92aWRlZCxcbiAgICAgKiAgdGhlIGVycm9yIHdpbGwgYmUgdGhyb3duIGFzIHVuaGFuZGxlZFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbXBsZXRlIChvcHRpb25hbCkgYSBoYW5kbGVyIGZvciBhIHRlcm1pbmFsIGV2ZW50IHJlc3VsdGluZyBmcm9tIHN1Y2Nlc3NmdWwgY29tcGxldGlvbi5cbiAgICAgKiBAcmV0dXJuIHtJU3Vic2NyaXB0aW9ufSBhIHN1YnNjcmlwdGlvbiByZWZlcmVuY2UgdG8gdGhlIHJlZ2lzdGVyZWQgaGFuZGxlcnNcbiAgICAgKi9cbiAgICBPYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmUgPSBmdW5jdGlvbiAob2JzZXJ2ZXJPck5leHQsIGVycm9yLCBjb21wbGV0ZSkge1xuICAgICAgICB2YXIgb3BlcmF0b3IgPSB0aGlzLm9wZXJhdG9yO1xuICAgICAgICB2YXIgc2luayA9IHRvU3Vic2NyaWJlcl8xLnRvU3Vic2NyaWJlcihvYnNlcnZlck9yTmV4dCwgZXJyb3IsIGNvbXBsZXRlKTtcbiAgICAgICAgaWYgKG9wZXJhdG9yKSB7XG4gICAgICAgICAgICBvcGVyYXRvci5jYWxsKHNpbmssIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2luay5hZGQodGhpcy5fc3Vic2NyaWJlKHNpbmspKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2luay5zeW5jRXJyb3JUaHJvd2FibGUpIHtcbiAgICAgICAgICAgIHNpbmsuc3luY0Vycm9yVGhyb3dhYmxlID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoc2luay5zeW5jRXJyb3JUaHJvd24pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBzaW5rLnN5bmNFcnJvclZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzaW5rO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQG1ldGhvZCBmb3JFYWNoXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gbmV4dCBhIGhhbmRsZXIgZm9yIGVhY2ggdmFsdWUgZW1pdHRlZCBieSB0aGUgb2JzZXJ2YWJsZVxuICAgICAqIEBwYXJhbSB7UHJvbWlzZUNvbnN0cnVjdG9yfSBbUHJvbWlzZUN0b3JdIGEgY29uc3RydWN0b3IgZnVuY3Rpb24gdXNlZCB0byBpbnN0YW50aWF0ZSB0aGUgUHJvbWlzZVxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IGEgcHJvbWlzZSB0aGF0IGVpdGhlciByZXNvbHZlcyBvbiBvYnNlcnZhYmxlIGNvbXBsZXRpb24gb3JcbiAgICAgKiAgcmVqZWN0cyB3aXRoIHRoZSBoYW5kbGVkIGVycm9yXG4gICAgICovXG4gICAgT2JzZXJ2YWJsZS5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChuZXh0LCBQcm9taXNlQ3Rvcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIVByb21pc2VDdG9yKSB7XG4gICAgICAgICAgICBpZiAocm9vdF8xLnJvb3QuUnggJiYgcm9vdF8xLnJvb3QuUnguY29uZmlnICYmIHJvb3RfMS5yb290LlJ4LmNvbmZpZy5Qcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgUHJvbWlzZUN0b3IgPSByb290XzEucm9vdC5SeC5jb25maWcuUHJvbWlzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJvb3RfMS5yb290LlByb21pc2UpIHtcbiAgICAgICAgICAgICAgICBQcm9taXNlQ3RvciA9IHJvb3RfMS5yb290LlByb21pc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFQcm9taXNlQ3Rvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdubyBQcm9taXNlIGltcGwgZm91bmQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2VDdG9yKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIHZhciBzdWJzY3JpcHRpb24gPSBfdGhpcy5zdWJzY3JpYmUoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBhIHN1YnNjcmlwdGlvbiwgdGhlbiB3ZSBjYW4gc3VybWlzZVxuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgbmV4dCBoYW5kbGluZyBpcyBhc3luY2hyb25vdXMuIEFueSBlcnJvcnMgdGhyb3duXG4gICAgICAgICAgICAgICAgICAgIC8vIG5lZWQgdG8gYmUgcmVqZWN0ZWQgZXhwbGljaXRseSBhbmQgdW5zdWJzY3JpYmUgbXVzdCBiZVxuICAgICAgICAgICAgICAgICAgICAvLyBjYWxsZWQgbWFudWFsbHlcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIE5PIHN1YnNjcmlwdGlvbiwgdGhlbiB3ZSdyZSBnZXR0aW5nIGEgbmV4dGVkXG4gICAgICAgICAgICAgICAgICAgIC8vIHZhbHVlIHN5bmNocm9ub3VzbHkgZHVyaW5nIHN1YnNjcmlwdGlvbi4gV2UgY2FuIGp1c3QgY2FsbCBpdC5cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgaXQgZXJyb3JzLCBPYnNlcnZhYmxlJ3MgYHN1YnNjcmliZWAgd2lsbCBlbnN1cmUgdGhlXG4gICAgICAgICAgICAgICAgICAgIC8vIHVuc3Vic2NyaXB0aW9uIGxvZ2ljIGlzIGNhbGxlZCwgdGhlbiBzeW5jaHJvbm91c2x5IHJldGhyb3cgdGhlIGVycm9yLlxuICAgICAgICAgICAgICAgICAgICAvLyBBZnRlciB0aGF0LCBQcm9taXNlIHdpbGwgdHJhcCB0aGUgZXJyb3IgYW5kIHNlbmQgaXRcbiAgICAgICAgICAgICAgICAgICAgLy8gZG93biB0aGUgcmVqZWN0aW9uIHBhdGguXG4gICAgICAgICAgICAgICAgICAgIG5leHQodmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHJlamVjdCwgcmVzb2x2ZSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgT2JzZXJ2YWJsZS5wcm90b3R5cGUuX3N1YnNjcmliZSA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNvdXJjZS5zdWJzY3JpYmUoc3Vic2NyaWJlcik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBbiBpbnRlcm9wIHBvaW50IGRlZmluZWQgYnkgdGhlIGVzNy1vYnNlcnZhYmxlIHNwZWMgaHR0cHM6Ly9naXRodWIuY29tL3plbnBhcnNpbmcvZXMtb2JzZXJ2YWJsZVxuICAgICAqIEBtZXRob2QgU3ltYm9sLm9ic2VydmFibGVcbiAgICAgKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSB0aGlzIGluc3RhbmNlIG9mIHRoZSBvYnNlcnZhYmxlXG4gICAgICovXG4gICAgT2JzZXJ2YWJsZS5wcm90b3R5cGVbb2JzZXJ2YWJsZV8xLiQkb2JzZXJ2YWJsZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLy8gSEFDSzogU2luY2UgVHlwZVNjcmlwdCBpbmhlcml0cyBzdGF0aWMgcHJvcGVydGllcyB0b28sIHdlIGhhdmUgdG9cbiAgICAvLyBmaWdodCBhZ2FpbnN0IFR5cGVTY3JpcHQgaGVyZSBzbyBTdWJqZWN0IGNhbiBoYXZlIGEgZGlmZmVyZW50IHN0YXRpYyBjcmVhdGUgc2lnbmF0dXJlXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBjb2xkIE9ic2VydmFibGUgYnkgY2FsbGluZyB0aGUgT2JzZXJ2YWJsZSBjb25zdHJ1Y3RvclxuICAgICAqIEBzdGF0aWMgdHJ1ZVxuICAgICAqIEBvd25lciBPYnNlcnZhYmxlXG4gICAgICogQG1ldGhvZCBjcmVhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdWJzY3JpYmU/IHRoZSBzdWJzY3JpYmVyIGZ1bmN0aW9uIHRvIGJlIHBhc3NlZCB0byB0aGUgT2JzZXJ2YWJsZSBjb25zdHJ1Y3RvclxuICAgICAqIEByZXR1cm4ge09ic2VydmFibGV9IGEgbmV3IGNvbGQgb2JzZXJ2YWJsZVxuICAgICAqL1xuICAgIE9ic2VydmFibGUuY3JlYXRlID0gZnVuY3Rpb24gKHN1YnNjcmliZSkge1xuICAgICAgICByZXR1cm4gbmV3IE9ic2VydmFibGUoc3Vic2NyaWJlKTtcbiAgICB9O1xuICAgIHJldHVybiBPYnNlcnZhYmxlO1xufSgpKTtcbmV4cG9ydHMuT2JzZXJ2YWJsZSA9IE9ic2VydmFibGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1PYnNlcnZhYmxlLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL09ic2VydmFibGUuanNcbi8vIG1vZHVsZSBpZCA9IDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgb2JqZWN0VHlwZXMgPSB7XG4gICAgJ2Jvb2xlYW4nOiBmYWxzZSxcbiAgICAnZnVuY3Rpb24nOiB0cnVlLFxuICAgICdvYmplY3QnOiB0cnVlLFxuICAgICdudW1iZXInOiBmYWxzZSxcbiAgICAnc3RyaW5nJzogZmFsc2UsXG4gICAgJ3VuZGVmaW5lZCc6IGZhbHNlXG59O1xuZXhwb3J0cy5yb290ID0gKG9iamVjdFR5cGVzW3R5cGVvZiBzZWxmXSAmJiBzZWxmKSB8fCAob2JqZWN0VHlwZXNbdHlwZW9mIHdpbmRvd10gJiYgd2luZG93KTtcbnZhciBmcmVlR2xvYmFsID0gb2JqZWN0VHlwZXNbdHlwZW9mIGdsb2JhbF0gJiYgZ2xvYmFsO1xuaWYgKGZyZWVHbG9iYWwgJiYgKGZyZWVHbG9iYWwuZ2xvYmFsID09PSBmcmVlR2xvYmFsIHx8IGZyZWVHbG9iYWwud2luZG93ID09PSBmcmVlR2xvYmFsKSkge1xuICAgIGV4cG9ydHMucm9vdCA9IGZyZWVHbG9iYWw7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yb290LmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL3V0aWwvcm9vdC5qc1xuLy8gbW9kdWxlIGlkID0gNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpYmVyJyk7XG52YXIgcnhTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9zeW1ib2wvcnhTdWJzY3JpYmVyJyk7XG5mdW5jdGlvbiB0b1N1YnNjcmliZXIobmV4dE9yT2JzZXJ2ZXIsIGVycm9yLCBjb21wbGV0ZSkge1xuICAgIGlmIChuZXh0T3JPYnNlcnZlcikge1xuICAgICAgICBpZiAobmV4dE9yT2JzZXJ2ZXIgaW5zdGFuY2VvZiBTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcikge1xuICAgICAgICAgICAgcmV0dXJuIG5leHRPck9ic2VydmVyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXh0T3JPYnNlcnZlcltyeFN1YnNjcmliZXJfMS4kJHJ4U3Vic2NyaWJlcl0pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXh0T3JPYnNlcnZlcltyeFN1YnNjcmliZXJfMS4kJHJ4U3Vic2NyaWJlcl0oKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIW5leHRPck9ic2VydmVyICYmICFlcnJvciAmJiAhY29tcGxldGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcigpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKG5leHRPck9ic2VydmVyLCBlcnJvciwgY29tcGxldGUpO1xufVxuZXhwb3J0cy50b1N1YnNjcmliZXIgPSB0b1N1YnNjcmliZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10b1N1YnNjcmliZXIuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvdXRpbC90b1N1YnNjcmliZXIuanNcbi8vIG1vZHVsZSBpZCA9IDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBpc0Z1bmN0aW9uXzEgPSByZXF1aXJlKCcuL3V0aWwvaXNGdW5jdGlvbicpO1xudmFyIFN1YnNjcmlwdGlvbl8xID0gcmVxdWlyZSgnLi9TdWJzY3JpcHRpb24nKTtcbnZhciBPYnNlcnZlcl8xID0gcmVxdWlyZSgnLi9PYnNlcnZlcicpO1xudmFyIHJ4U3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi9zeW1ib2wvcnhTdWJzY3JpYmVyJyk7XG4vKipcbiAqIEltcGxlbWVudHMgdGhlIHtAbGluayBPYnNlcnZlcn0gaW50ZXJmYWNlIGFuZCBleHRlbmRzIHRoZVxuICoge0BsaW5rIFN1YnNjcmlwdGlvbn0gY2xhc3MuIFdoaWxlIHRoZSB7QGxpbmsgT2JzZXJ2ZXJ9IGlzIHRoZSBwdWJsaWMgQVBJIGZvclxuICogY29uc3VtaW5nIHRoZSB2YWx1ZXMgb2YgYW4ge0BsaW5rIE9ic2VydmFibGV9LCBhbGwgT2JzZXJ2ZXJzIGdldCBjb252ZXJ0ZWQgdG9cbiAqIGEgU3Vic2NyaWJlciwgaW4gb3JkZXIgdG8gcHJvdmlkZSBTdWJzY3JpcHRpb24tbGlrZSBjYXBhYmlsaXRpZXMgc3VjaCBhc1xuICogYHVuc3Vic2NyaWJlYC4gU3Vic2NyaWJlciBpcyBhIGNvbW1vbiB0eXBlIGluIFJ4SlMsIGFuZCBjcnVjaWFsIGZvclxuICogaW1wbGVtZW50aW5nIG9wZXJhdG9ycywgYnV0IGl0IGlzIHJhcmVseSB1c2VkIGFzIGEgcHVibGljIEFQSS5cbiAqXG4gKiBAY2xhc3MgU3Vic2NyaWJlcjxUPlxuICovXG52YXIgU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYnNlcnZlcnxmdW5jdGlvbih2YWx1ZTogVCk6IHZvaWR9IFtkZXN0aW5hdGlvbk9yTmV4dF0gQSBwYXJ0aWFsbHlcbiAgICAgKiBkZWZpbmVkIE9ic2VydmVyIG9yIGEgYG5leHRgIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oZTogP2FueSk6IHZvaWR9IFtlcnJvcl0gVGhlIGBlcnJvcmAgY2FsbGJhY2sgb2YgYW5cbiAgICAgKiBPYnNlcnZlci5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCk6IHZvaWR9IFtjb21wbGV0ZV0gVGhlIGBjb21wbGV0ZWAgY2FsbGJhY2sgb2YgYW5cbiAgICAgKiBPYnNlcnZlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBTdWJzY3JpYmVyKGRlc3RpbmF0aW9uT3JOZXh0LCBlcnJvciwgY29tcGxldGUpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuc3luY0Vycm9yVmFsdWUgPSBudWxsO1xuICAgICAgICB0aGlzLnN5bmNFcnJvclRocm93biA9IGZhbHNlO1xuICAgICAgICB0aGlzLnN5bmNFcnJvclRocm93YWJsZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzU3RvcHBlZCA9IGZhbHNlO1xuICAgICAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uID0gT2JzZXJ2ZXJfMS5lbXB0eTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBpZiAoIWRlc3RpbmF0aW9uT3JOZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24gPSBPYnNlcnZlcl8xLmVtcHR5O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkZXN0aW5hdGlvbk9yTmV4dCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlc3RpbmF0aW9uT3JOZXh0IGluc3RhbmNlb2YgU3Vic2NyaWJlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbiA9IGRlc3RpbmF0aW9uT3JOZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5hZGQodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN5bmNFcnJvclRocm93YWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uID0gbmV3IFNhZmVTdWJzY3JpYmVyKHRoaXMsIGRlc3RpbmF0aW9uT3JOZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRoaXMuc3luY0Vycm9yVGhyb3dhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uID0gbmV3IFNhZmVTdWJzY3JpYmVyKHRoaXMsIGRlc3RpbmF0aW9uT3JOZXh0LCBlcnJvciwgY29tcGxldGUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIFN1YnNjcmliZXIucHJvdG90eXBlW3J4U3Vic2NyaWJlcl8xLiQkcnhTdWJzY3JpYmVyXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07XG4gICAgLyoqXG4gICAgICogQSBzdGF0aWMgZmFjdG9yeSBmb3IgYSBTdWJzY3JpYmVyLCBnaXZlbiBhIChwb3RlbnRpYWxseSBwYXJ0aWFsKSBkZWZpbml0aW9uXG4gICAgICogb2YgYW4gT2JzZXJ2ZXIuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbih4OiA/VCk6IHZvaWR9IFtuZXh0XSBUaGUgYG5leHRgIGNhbGxiYWNrIG9mIGFuIE9ic2VydmVyLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oZTogP2FueSk6IHZvaWR9IFtlcnJvcl0gVGhlIGBlcnJvcmAgY2FsbGJhY2sgb2YgYW5cbiAgICAgKiBPYnNlcnZlci5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCk6IHZvaWR9IFtjb21wbGV0ZV0gVGhlIGBjb21wbGV0ZWAgY2FsbGJhY2sgb2YgYW5cbiAgICAgKiBPYnNlcnZlci5cbiAgICAgKiBAcmV0dXJuIHtTdWJzY3JpYmVyPFQ+fSBBIFN1YnNjcmliZXIgd3JhcHBpbmcgdGhlIChwYXJ0aWFsbHkgZGVmaW5lZClcbiAgICAgKiBPYnNlcnZlciByZXByZXNlbnRlZCBieSB0aGUgZ2l2ZW4gYXJndW1lbnRzLlxuICAgICAqL1xuICAgIFN1YnNjcmliZXIuY3JlYXRlID0gZnVuY3Rpb24gKG5leHQsIGVycm9yLCBjb21wbGV0ZSkge1xuICAgICAgICB2YXIgc3Vic2NyaWJlciA9IG5ldyBTdWJzY3JpYmVyKG5leHQsIGVycm9yLCBjb21wbGV0ZSk7XG4gICAgICAgIHN1YnNjcmliZXIuc3luY0Vycm9yVGhyb3dhYmxlID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBzdWJzY3JpYmVyO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVGhlIHtAbGluayBPYnNlcnZlcn0gY2FsbGJhY2sgdG8gcmVjZWl2ZSBub3RpZmljYXRpb25zIG9mIHR5cGUgYG5leHRgIGZyb21cbiAgICAgKiB0aGUgT2JzZXJ2YWJsZSwgd2l0aCBhIHZhbHVlLiBUaGUgT2JzZXJ2YWJsZSBtYXkgY2FsbCB0aGlzIG1ldGhvZCAwIG9yIG1vcmVcbiAgICAgKiB0aW1lcy5cbiAgICAgKiBAcGFyYW0ge1R9IFt2YWx1ZV0gVGhlIGBuZXh0YCB2YWx1ZS5cbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqL1xuICAgIFN1YnNjcmliZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzU3RvcHBlZCkge1xuICAgICAgICAgICAgdGhpcy5fbmV4dCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoZSB7QGxpbmsgT2JzZXJ2ZXJ9IGNhbGxiYWNrIHRvIHJlY2VpdmUgbm90aWZpY2F0aW9ucyBvZiB0eXBlIGBlcnJvcmAgZnJvbVxuICAgICAqIHRoZSBPYnNlcnZhYmxlLCB3aXRoIGFuIGF0dGFjaGVkIHtAbGluayBFcnJvcn0uIE5vdGlmaWVzIHRoZSBPYnNlcnZlciB0aGF0XG4gICAgICogdGhlIE9ic2VydmFibGUgaGFzIGV4cGVyaWVuY2VkIGFuIGVycm9yIGNvbmRpdGlvbi5cbiAgICAgKiBAcGFyYW0ge2FueX0gW2Vycl0gVGhlIGBlcnJvcmAgZXhjZXB0aW9uLlxuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICovXG4gICAgU3Vic2NyaWJlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1N0b3BwZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaXNTdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2Vycm9yKGVycik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoZSB7QGxpbmsgT2JzZXJ2ZXJ9IGNhbGxiYWNrIHRvIHJlY2VpdmUgYSB2YWx1ZWxlc3Mgbm90aWZpY2F0aW9uIG9mIHR5cGVcbiAgICAgKiBgY29tcGxldGVgIGZyb20gdGhlIE9ic2VydmFibGUuIE5vdGlmaWVzIHRoZSBPYnNlcnZlciB0aGF0IHRoZSBPYnNlcnZhYmxlXG4gICAgICogaGFzIGZpbmlzaGVkIHNlbmRpbmcgcHVzaC1iYXNlZCBub3RpZmljYXRpb25zLlxuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICovXG4gICAgU3Vic2NyaWJlci5wcm90b3R5cGUuY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1N0b3BwZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaXNTdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2NvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN1YnNjcmliZXIucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzU3RvcHBlZCA9IHRydWU7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUudW5zdWJzY3JpYmUuY2FsbCh0aGlzKTtcbiAgICB9O1xuICAgIFN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dCh2YWx1ZSk7XG4gICAgfTtcbiAgICBTdWJzY3JpYmVyLnByb3RvdHlwZS5fZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgIH07XG4gICAgU3Vic2NyaWJlci5wcm90b3R5cGUuX2NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICB9O1xuICAgIHJldHVybiBTdWJzY3JpYmVyO1xufShTdWJzY3JpcHRpb25fMS5TdWJzY3JpcHRpb24pKTtcbmV4cG9ydHMuU3Vic2NyaWJlciA9IFN1YnNjcmliZXI7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIFNhZmVTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU2FmZVN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU2FmZVN1YnNjcmliZXIoX3BhcmVudCwgb2JzZXJ2ZXJPck5leHQsIGVycm9yLCBjb21wbGV0ZSkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5fcGFyZW50ID0gX3BhcmVudDtcbiAgICAgICAgdmFyIG5leHQ7XG4gICAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcbiAgICAgICAgaWYgKGlzRnVuY3Rpb25fMS5pc0Z1bmN0aW9uKG9ic2VydmVyT3JOZXh0KSkge1xuICAgICAgICAgICAgbmV4dCA9IG9ic2VydmVyT3JOZXh0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9ic2VydmVyT3JOZXh0KSB7XG4gICAgICAgICAgICBjb250ZXh0ID0gb2JzZXJ2ZXJPck5leHQ7XG4gICAgICAgICAgICBuZXh0ID0gb2JzZXJ2ZXJPck5leHQubmV4dDtcbiAgICAgICAgICAgIGVycm9yID0gb2JzZXJ2ZXJPck5leHQuZXJyb3I7XG4gICAgICAgICAgICBjb21wbGV0ZSA9IG9ic2VydmVyT3JOZXh0LmNvbXBsZXRlO1xuICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb25fMS5pc0Z1bmN0aW9uKGNvbnRleHQudW5zdWJzY3JpYmUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGQoY29udGV4dC51bnN1YnNjcmliZS5iaW5kKGNvbnRleHQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRleHQudW5zdWJzY3JpYmUgPSB0aGlzLnVuc3Vic2NyaWJlLmJpbmQodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMuX25leHQgPSBuZXh0O1xuICAgICAgICB0aGlzLl9lcnJvciA9IGVycm9yO1xuICAgICAgICB0aGlzLl9jb21wbGV0ZSA9IGNvbXBsZXRlO1xuICAgIH1cbiAgICBTYWZlU3Vic2NyaWJlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAoIXRoaXMuaXNTdG9wcGVkICYmIHRoaXMuX25leHQpIHtcbiAgICAgICAgICAgIHZhciBfcGFyZW50ID0gdGhpcy5fcGFyZW50O1xuICAgICAgICAgICAgaWYgKCFfcGFyZW50LnN5bmNFcnJvclRocm93YWJsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX190cnlPclVuc3ViKHRoaXMuX25leHQsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX190cnlPclNldEVycm9yKF9wYXJlbnQsIHRoaXMuX25leHQsIHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgU2FmZVN1YnNjcmliZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICBpZiAoIXRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICAgICAgICB2YXIgX3BhcmVudCA9IHRoaXMuX3BhcmVudDtcbiAgICAgICAgICAgIGlmICh0aGlzLl9lcnJvcikge1xuICAgICAgICAgICAgICAgIGlmICghX3BhcmVudC5zeW5jRXJyb3JUaHJvd2FibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX3RyeU9yVW5zdWIodGhpcy5fZXJyb3IsIGVycik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX190cnlPclNldEVycm9yKF9wYXJlbnQsIHRoaXMuX2Vycm9yLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIV9wYXJlbnQuc3luY0Vycm9yVGhyb3dhYmxlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIF9wYXJlbnQuc3luY0Vycm9yVmFsdWUgPSBlcnI7XG4gICAgICAgICAgICAgICAgX3BhcmVudC5zeW5jRXJyb3JUaHJvd24gPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgU2FmZVN1YnNjcmliZXIucHJvdG90eXBlLmNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICAgICAgICB2YXIgX3BhcmVudCA9IHRoaXMuX3BhcmVudDtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jb21wbGV0ZSkge1xuICAgICAgICAgICAgICAgIGlmICghX3BhcmVudC5zeW5jRXJyb3JUaHJvd2FibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX3RyeU9yVW5zdWIodGhpcy5fY29tcGxldGUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9fdHJ5T3JTZXRFcnJvcihfcGFyZW50LCB0aGlzLl9jb21wbGV0ZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNhZmVTdWJzY3JpYmVyLnByb3RvdHlwZS5fX3RyeU9yVW5zdWIgPSBmdW5jdGlvbiAoZm4sIHZhbHVlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmbi5jYWxsKHRoaXMuX2NvbnRleHQsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNhZmVTdWJzY3JpYmVyLnByb3RvdHlwZS5fX3RyeU9yU2V0RXJyb3IgPSBmdW5jdGlvbiAocGFyZW50LCBmbiwgdmFsdWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZuLmNhbGwodGhpcy5fY29udGV4dCwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHBhcmVudC5zeW5jRXJyb3JWYWx1ZSA9IGVycjtcbiAgICAgICAgICAgIHBhcmVudC5zeW5jRXJyb3JUaHJvd24gPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgU2FmZVN1YnNjcmliZXIucHJvdG90eXBlLl91bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9wYXJlbnQgPSB0aGlzLl9wYXJlbnQ7XG4gICAgICAgIHRoaXMuX2NvbnRleHQgPSBudWxsO1xuICAgICAgICB0aGlzLl9wYXJlbnQgPSBudWxsO1xuICAgICAgICBfcGFyZW50LnVuc3Vic2NyaWJlKCk7XG4gICAgfTtcbiAgICByZXR1cm4gU2FmZVN1YnNjcmliZXI7XG59KFN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN1YnNjcmliZXIuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvU3Vic2NyaWJlci5qc1xuLy8gbW9kdWxlIGlkID0gOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIGlzRnVuY3Rpb24oeCkge1xuICAgIHJldHVybiB0eXBlb2YgeCA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pc0Z1bmN0aW9uLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL3V0aWwvaXNGdW5jdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBpc0FycmF5XzEgPSByZXF1aXJlKCcuL3V0aWwvaXNBcnJheScpO1xudmFyIGlzT2JqZWN0XzEgPSByZXF1aXJlKCcuL3V0aWwvaXNPYmplY3QnKTtcbnZhciBpc0Z1bmN0aW9uXzEgPSByZXF1aXJlKCcuL3V0aWwvaXNGdW5jdGlvbicpO1xudmFyIHRyeUNhdGNoXzEgPSByZXF1aXJlKCcuL3V0aWwvdHJ5Q2F0Y2gnKTtcbnZhciBlcnJvck9iamVjdF8xID0gcmVxdWlyZSgnLi91dGlsL2Vycm9yT2JqZWN0Jyk7XG52YXIgVW5zdWJzY3JpcHRpb25FcnJvcl8xID0gcmVxdWlyZSgnLi91dGlsL1Vuc3Vic2NyaXB0aW9uRXJyb3InKTtcbi8qKlxuICogUmVwcmVzZW50cyBhIGRpc3Bvc2FibGUgcmVzb3VyY2UsIHN1Y2ggYXMgdGhlIGV4ZWN1dGlvbiBvZiBhbiBPYnNlcnZhYmxlLiBBXG4gKiBTdWJzY3JpcHRpb24gaGFzIG9uZSBpbXBvcnRhbnQgbWV0aG9kLCBgdW5zdWJzY3JpYmVgLCB0aGF0IHRha2VzIG5vIGFyZ3VtZW50XG4gKiBhbmQganVzdCBkaXNwb3NlcyB0aGUgcmVzb3VyY2UgaGVsZCBieSB0aGUgc3Vic2NyaXB0aW9uLlxuICpcbiAqIEFkZGl0aW9uYWxseSwgc3Vic2NyaXB0aW9ucyBtYXkgYmUgZ3JvdXBlZCB0b2dldGhlciB0aHJvdWdoIHRoZSBgYWRkKClgXG4gKiBtZXRob2QsIHdoaWNoIHdpbGwgYXR0YWNoIGEgY2hpbGQgU3Vic2NyaXB0aW9uIHRvIHRoZSBjdXJyZW50IFN1YnNjcmlwdGlvbi5cbiAqIFdoZW4gYSBTdWJzY3JpcHRpb24gaXMgdW5zdWJzY3JpYmVkLCBhbGwgaXRzIGNoaWxkcmVuIChhbmQgaXRzIGdyYW5kY2hpbGRyZW4pXG4gKiB3aWxsIGJlIHVuc3Vic2NyaWJlZCBhcyB3ZWxsLlxuICpcbiAqIEBjbGFzcyBTdWJzY3JpcHRpb25cbiAqL1xudmFyIFN1YnNjcmlwdGlvbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbigpOiB2b2lkfSBbdW5zdWJzY3JpYmVdIEEgZnVuY3Rpb24gZGVzY3JpYmluZyBob3cgdG9cbiAgICAgKiBwZXJmb3JtIHRoZSBkaXNwb3NhbCBvZiByZXNvdXJjZXMgd2hlbiB0aGUgYHVuc3Vic2NyaWJlYCBtZXRob2QgaXMgY2FsbGVkLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFN1YnNjcmlwdGlvbih1bnN1YnNjcmliZSkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBmbGFnIHRvIGluZGljYXRlIHdoZXRoZXIgdGhpcyBTdWJzY3JpcHRpb24gaGFzIGFscmVhZHkgYmVlbiB1bnN1YnNjcmliZWQuXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jbG9zZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHVuc3Vic2NyaWJlKSB7XG4gICAgICAgICAgICB0aGlzLl91bnN1YnNjcmliZSA9IHVuc3Vic2NyaWJlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERpc3Bvc2VzIHRoZSByZXNvdXJjZXMgaGVsZCBieSB0aGUgc3Vic2NyaXB0aW9uLiBNYXksIGZvciBpbnN0YW5jZSwgY2FuY2VsXG4gICAgICogYW4gb25nb2luZyBPYnNlcnZhYmxlIGV4ZWN1dGlvbiBvciBjYW5jZWwgYW55IG90aGVyIHR5cGUgb2Ygd29yayB0aGF0XG4gICAgICogc3RhcnRlZCB3aGVuIHRoZSBTdWJzY3JpcHRpb24gd2FzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgKi9cbiAgICBTdWJzY3JpcHRpb24ucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaGFzRXJyb3JzID0gZmFsc2U7XG4gICAgICAgIHZhciBlcnJvcnM7XG4gICAgICAgIGlmICh0aGlzLmNsb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgX3Vuc3Vic2NyaWJlID0gX2EuX3Vuc3Vic2NyaWJlLCBfc3Vic2NyaXB0aW9ucyA9IF9hLl9zdWJzY3JpcHRpb25zO1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb25zID0gbnVsbDtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb25fMS5pc0Z1bmN0aW9uKF91bnN1YnNjcmliZSkpIHtcbiAgICAgICAgICAgIHZhciB0cmlhbCA9IHRyeUNhdGNoXzEudHJ5Q2F0Y2goX3Vuc3Vic2NyaWJlKS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgaWYgKHRyaWFsID09PSBlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgaGFzRXJyb3JzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAoZXJyb3JzID0gZXJyb3JzIHx8IFtdKS5wdXNoKGVycm9yT2JqZWN0XzEuZXJyb3JPYmplY3QuZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQXJyYXlfMS5pc0FycmF5KF9zdWJzY3JpcHRpb25zKSkge1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gLTE7XG4gICAgICAgICAgICB2YXIgbGVuID0gX3N1YnNjcmlwdGlvbnMubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgICAgICB2YXIgc3ViID0gX3N1YnNjcmlwdGlvbnNbaW5kZXhdO1xuICAgICAgICAgICAgICAgIGlmIChpc09iamVjdF8xLmlzT2JqZWN0KHN1YikpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRyaWFsID0gdHJ5Q2F0Y2hfMS50cnlDYXRjaChzdWIudW5zdWJzY3JpYmUpLmNhbGwoc3ViKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRyaWFsID09PSBlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNFcnJvcnMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzID0gZXJyb3JzIHx8IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVyciA9IGVycm9yT2JqZWN0XzEuZXJyb3JPYmplY3QuZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBVbnN1YnNjcmlwdGlvbkVycm9yXzEuVW5zdWJzY3JpcHRpb25FcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycyA9IGVycm9ycy5jb25jYXQoZXJyLmVycm9ycyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNFcnJvcnMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBVbnN1YnNjcmlwdGlvbkVycm9yXzEuVW5zdWJzY3JpcHRpb25FcnJvcihlcnJvcnMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBZGRzIGEgdGVhciBkb3duIHRvIGJlIGNhbGxlZCBkdXJpbmcgdGhlIHVuc3Vic2NyaWJlKCkgb2YgdGhpc1xuICAgICAqIFN1YnNjcmlwdGlvbi5cbiAgICAgKlxuICAgICAqIElmIHRoZSB0ZWFyIGRvd24gYmVpbmcgYWRkZWQgaXMgYSBzdWJzY3JpcHRpb24gdGhhdCBpcyBhbHJlYWR5XG4gICAgICogdW5zdWJzY3JpYmVkLCBpcyB0aGUgc2FtZSByZWZlcmVuY2UgYGFkZGAgaXMgYmVpbmcgY2FsbGVkIG9uLCBvciBpc1xuICAgICAqIGBTdWJzY3JpcHRpb24uRU1QVFlgLCBpdCB3aWxsIG5vdCBiZSBhZGRlZC5cbiAgICAgKlxuICAgICAqIElmIHRoaXMgc3Vic2NyaXB0aW9uIGlzIGFscmVhZHkgaW4gYW4gYGNsb3NlZGAgc3RhdGUsIHRoZSBwYXNzZWRcbiAgICAgKiB0ZWFyIGRvd24gbG9naWMgd2lsbCBiZSBleGVjdXRlZCBpbW1lZGlhdGVseS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7VGVhcmRvd25Mb2dpY30gdGVhcmRvd24gVGhlIGFkZGl0aW9uYWwgbG9naWMgdG8gZXhlY3V0ZSBvblxuICAgICAqIHRlYXJkb3duLlxuICAgICAqIEByZXR1cm4ge1N1YnNjcmlwdGlvbn0gUmV0dXJucyB0aGUgU3Vic2NyaXB0aW9uIHVzZWQgb3IgY3JlYXRlZCB0byBiZVxuICAgICAqIGFkZGVkIHRvIHRoZSBpbm5lciBzdWJzY3JpcHRpb25zIGxpc3QuIFRoaXMgU3Vic2NyaXB0aW9uIGNhbiBiZSB1c2VkIHdpdGhcbiAgICAgKiBgcmVtb3ZlKClgIHRvIHJlbW92ZSB0aGUgcGFzc2VkIHRlYXJkb3duIGxvZ2ljIGZyb20gdGhlIGlubmVyIHN1YnNjcmlwdGlvbnNcbiAgICAgKiBsaXN0LlxuICAgICAqL1xuICAgIFN1YnNjcmlwdGlvbi5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKHRlYXJkb3duKSB7XG4gICAgICAgIGlmICghdGVhcmRvd24gfHwgKHRlYXJkb3duID09PSBTdWJzY3JpcHRpb24uRU1QVFkpKSB7XG4gICAgICAgICAgICByZXR1cm4gU3Vic2NyaXB0aW9uLkVNUFRZO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0ZWFyZG93biA9PT0gdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN1YiA9IHRlYXJkb3duO1xuICAgICAgICBzd2l0Y2ggKHR5cGVvZiB0ZWFyZG93bikge1xuICAgICAgICAgICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgICAgICAgICAgIHN1YiA9IG5ldyBTdWJzY3JpcHRpb24odGVhcmRvd24pO1xuICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICBpZiAoc3ViLmNsb3NlZCB8fCB0eXBlb2Ygc3ViLnVuc3Vic2NyaWJlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLmNsb3NlZCkge1xuICAgICAgICAgICAgICAgICAgICBzdWIudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICh0aGlzLl9zdWJzY3JpcHRpb25zIHx8ICh0aGlzLl9zdWJzY3JpcHRpb25zID0gW10pKS5wdXNoKHN1Yik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VucmVjb2duaXplZCB0ZWFyZG93biAnICsgdGVhcmRvd24gKyAnIGFkZGVkIHRvIFN1YnNjcmlwdGlvbi4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3ViO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIFN1YnNjcmlwdGlvbiBmcm9tIHRoZSBpbnRlcm5hbCBsaXN0IG9mIHN1YnNjcmlwdGlvbnMgdGhhdCB3aWxsXG4gICAgICogdW5zdWJzY3JpYmUgZHVyaW5nIHRoZSB1bnN1YnNjcmliZSBwcm9jZXNzIG9mIHRoaXMgU3Vic2NyaXB0aW9uLlxuICAgICAqIEBwYXJhbSB7U3Vic2NyaXB0aW9ufSBzdWJzY3JpcHRpb24gVGhlIHN1YnNjcmlwdGlvbiB0byByZW1vdmUuXG4gICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgKi9cbiAgICBTdWJzY3JpcHRpb24ucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChzdWJzY3JpcHRpb24pIHtcbiAgICAgICAgLy8gSEFDSzogVGhpcyBtaWdodCBiZSByZWR1bmRhbnQgYmVjYXVzZSBvZiB0aGUgbG9naWMgaW4gYGFkZCgpYFxuICAgICAgICBpZiAoc3Vic2NyaXB0aW9uID09IG51bGwgfHwgKHN1YnNjcmlwdGlvbiA9PT0gdGhpcykgfHwgKHN1YnNjcmlwdGlvbiA9PT0gU3Vic2NyaXB0aW9uLkVNUFRZKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdWJzY3JpcHRpb25zID0gdGhpcy5fc3Vic2NyaXB0aW9ucztcbiAgICAgICAgaWYgKHN1YnNjcmlwdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBzdWJzY3JpcHRpb25JbmRleCA9IHN1YnNjcmlwdGlvbnMuaW5kZXhPZihzdWJzY3JpcHRpb24pO1xuICAgICAgICAgICAgaWYgKHN1YnNjcmlwdGlvbkluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbnMuc3BsaWNlKHN1YnNjcmlwdGlvbkluZGV4LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgU3Vic2NyaXB0aW9uLkVNUFRZID0gKGZ1bmN0aW9uIChlbXB0eSkge1xuICAgICAgICBlbXB0eS5jbG9zZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gZW1wdHk7XG4gICAgfShuZXcgU3Vic2NyaXB0aW9uKCkpKTtcbiAgICByZXR1cm4gU3Vic2NyaXB0aW9uO1xufSgpKTtcbmV4cG9ydHMuU3Vic2NyaXB0aW9uID0gU3Vic2NyaXB0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3Vic2NyaXB0aW9uLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL1N1YnNjcmlwdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gMTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLmlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IChmdW5jdGlvbiAoeCkgeyByZXR1cm4geCAmJiB0eXBlb2YgeC5sZW5ndGggPT09ICdudW1iZXInOyB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzQXJyYXkuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvdXRpbC9pc0FycmF5LmpzXG4vLyBtb2R1bGUgaWQgPSAxMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIGlzT2JqZWN0KHgpIHtcbiAgICByZXR1cm4geCAhPSBudWxsICYmIHR5cGVvZiB4ID09PSAnb2JqZWN0Jztcbn1cbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzT2JqZWN0LmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL3V0aWwvaXNPYmplY3QuanNcbi8vIG1vZHVsZSBpZCA9IDEyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIGVycm9yT2JqZWN0XzEgPSByZXF1aXJlKCcuL2Vycm9yT2JqZWN0Jyk7XG52YXIgdHJ5Q2F0Y2hUYXJnZXQ7XG5mdW5jdGlvbiB0cnlDYXRjaGVyKCkge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB0cnlDYXRjaFRhcmdldC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0LmUgPSBlO1xuICAgICAgICByZXR1cm4gZXJyb3JPYmplY3RfMS5lcnJvck9iamVjdDtcbiAgICB9XG59XG5mdW5jdGlvbiB0cnlDYXRjaChmbikge1xuICAgIHRyeUNhdGNoVGFyZ2V0ID0gZm47XG4gICAgcmV0dXJuIHRyeUNhdGNoZXI7XG59XG5leHBvcnRzLnRyeUNhdGNoID0gdHJ5Q2F0Y2g7XG47XG4vLyMgc291cmNlTWFwcGluZ1VSTD10cnlDYXRjaC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy91dGlsL3RyeUNhdGNoLmpzXG4vLyBtb2R1bGUgaWQgPSAxM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbi8vIHR5cGVvZiBhbnkgc28gdGhhdCBpdCB3ZSBkb24ndCBoYXZlIHRvIGNhc3Qgd2hlbiBjb21wYXJpbmcgYSByZXN1bHQgdG8gdGhlIGVycm9yIG9iamVjdFxuZXhwb3J0cy5lcnJvck9iamVjdCA9IHsgZToge30gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVycm9yT2JqZWN0LmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL3V0aWwvZXJyb3JPYmplY3QuanNcbi8vIG1vZHVsZSBpZCA9IDE0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG4vKipcbiAqIEFuIGVycm9yIHRocm93biB3aGVuIG9uZSBvciBtb3JlIGVycm9ycyBoYXZlIG9jY3VycmVkIGR1cmluZyB0aGVcbiAqIGB1bnN1YnNjcmliZWAgb2YgYSB7QGxpbmsgU3Vic2NyaXB0aW9ufS5cbiAqL1xudmFyIFVuc3Vic2NyaXB0aW9uRXJyb3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhVbnN1YnNjcmlwdGlvbkVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFVuc3Vic2NyaXB0aW9uRXJyb3IoZXJyb3JzKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLmVycm9ycyA9IGVycm9ycztcbiAgICAgICAgdmFyIGVyciA9IEVycm9yLmNhbGwodGhpcywgZXJyb3JzID9cbiAgICAgICAgICAgIGVycm9ycy5sZW5ndGggKyBcIiBlcnJvcnMgb2NjdXJyZWQgZHVyaW5nIHVuc3Vic2NyaXB0aW9uOlxcbiAgXCIgKyBlcnJvcnMubWFwKGZ1bmN0aW9uIChlcnIsIGkpIHsgcmV0dXJuICgoaSArIDEpICsgXCIpIFwiICsgZXJyLnRvU3RyaW5nKCkpOyB9KS5qb2luKCdcXG4gICcpIDogJycpO1xuICAgICAgICB0aGlzLm5hbWUgPSBlcnIubmFtZSA9ICdVbnN1YnNjcmlwdGlvbkVycm9yJztcbiAgICAgICAgdGhpcy5zdGFjayA9IGVyci5zdGFjaztcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gZXJyLm1lc3NhZ2U7XG4gICAgfVxuICAgIHJldHVybiBVbnN1YnNjcmlwdGlvbkVycm9yO1xufShFcnJvcikpO1xuZXhwb3J0cy5VbnN1YnNjcmlwdGlvbkVycm9yID0gVW5zdWJzY3JpcHRpb25FcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVVuc3Vic2NyaXB0aW9uRXJyb3IuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvdXRpbC9VbnN1YnNjcmlwdGlvbkVycm9yLmpzXG4vLyBtb2R1bGUgaWQgPSAxNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuZW1wdHkgPSB7XG4gICAgY2xvc2VkOiB0cnVlLFxuICAgIG5leHQ6IGZ1bmN0aW9uICh2YWx1ZSkgeyB9LFxuICAgIGVycm9yOiBmdW5jdGlvbiAoZXJyKSB7IHRocm93IGVycjsgfSxcbiAgICBjb21wbGV0ZTogZnVuY3Rpb24gKCkgeyB9XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9T2JzZXJ2ZXIuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvT2JzZXJ2ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDE2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIHJvb3RfMSA9IHJlcXVpcmUoJy4uL3V0aWwvcm9vdCcpO1xudmFyIFN5bWJvbCA9IHJvb3RfMS5yb290LlN5bWJvbDtcbmV4cG9ydHMuJCRyeFN1YnNjcmliZXIgPSAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgU3ltYm9sLmZvciA9PT0gJ2Z1bmN0aW9uJykgP1xuICAgIFN5bWJvbC5mb3IoJ3J4U3Vic2NyaWJlcicpIDogJ0BAcnhTdWJzY3JpYmVyJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJ4U3Vic2NyaWJlci5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9zeW1ib2wvcnhTdWJzY3JpYmVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciByb290XzEgPSByZXF1aXJlKCcuLi91dGlsL3Jvb3QnKTtcbmZ1bmN0aW9uIGdldFN5bWJvbE9ic2VydmFibGUoY29udGV4dCkge1xuICAgIHZhciAkJG9ic2VydmFibGU7XG4gICAgdmFyIFN5bWJvbCA9IGNvbnRleHQuU3ltYm9sO1xuICAgIGlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGlmIChTeW1ib2wub2JzZXJ2YWJsZSkge1xuICAgICAgICAgICAgJCRvYnNlcnZhYmxlID0gU3ltYm9sLm9ic2VydmFibGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAkJG9ic2VydmFibGUgPSBTeW1ib2woJ29ic2VydmFibGUnKTtcbiAgICAgICAgICAgIFN5bWJvbC5vYnNlcnZhYmxlID0gJCRvYnNlcnZhYmxlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAkJG9ic2VydmFibGUgPSAnQEBvYnNlcnZhYmxlJztcbiAgICB9XG4gICAgcmV0dXJuICQkb2JzZXJ2YWJsZTtcbn1cbmV4cG9ydHMuZ2V0U3ltYm9sT2JzZXJ2YWJsZSA9IGdldFN5bWJvbE9ic2VydmFibGU7XG5leHBvcnRzLiQkb2JzZXJ2YWJsZSA9IGdldFN5bWJvbE9ic2VydmFibGUocm9vdF8xLnJvb3QpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b2JzZXJ2YWJsZS5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9zeW1ib2wvb2JzZXJ2YWJsZS5qc1xuLy8gbW9kdWxlIGlkID0gMThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbi8qKlxuICogQW4gZXJyb3IgdGhyb3duIHdoZW4gYW4gYWN0aW9uIGlzIGludmFsaWQgYmVjYXVzZSB0aGUgb2JqZWN0IGhhcyBiZWVuXG4gKiB1bnN1YnNjcmliZWQuXG4gKlxuICogQHNlZSB7QGxpbmsgU3ViamVjdH1cbiAqIEBzZWUge0BsaW5rIEJlaGF2aW9yU3ViamVjdH1cbiAqXG4gKiBAY2xhc3MgT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3JcbiAqL1xudmFyIE9iamVjdFVuc3Vic2NyaWJlZEVycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3IoKSB7XG4gICAgICAgIHZhciBlcnIgPSBfc3VwZXIuY2FsbCh0aGlzLCAnb2JqZWN0IHVuc3Vic2NyaWJlZCcpO1xuICAgICAgICB0aGlzLm5hbWUgPSBlcnIubmFtZSA9ICdPYmplY3RVbnN1YnNjcmliZWRFcnJvcic7XG4gICAgICAgIHRoaXMuc3RhY2sgPSBlcnIuc3RhY2s7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IGVyci5tZXNzYWdlO1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3I7XG59KEVycm9yKSk7XG5leHBvcnRzLk9iamVjdFVuc3Vic2NyaWJlZEVycm9yID0gT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1PYmplY3RVbnN1YnNjcmliZWRFcnJvci5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy91dGlsL09iamVjdFVuc3Vic2NyaWJlZEVycm9yLmpzXG4vLyBtb2R1bGUgaWQgPSAxOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIFN1YnNjcmlwdGlvbl8xID0gcmVxdWlyZSgnLi9TdWJzY3JpcHRpb24nKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgU3ViamVjdFN1YnNjcmlwdGlvbiA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFN1YmplY3RTdWJzY3JpcHRpb24sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU3ViamVjdFN1YnNjcmlwdGlvbihzdWJqZWN0LCBzdWJzY3JpYmVyKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLnN1YmplY3QgPSBzdWJqZWN0O1xuICAgICAgICB0aGlzLnN1YnNjcmliZXIgPSBzdWJzY3JpYmVyO1xuICAgICAgICB0aGlzLmNsb3NlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBTdWJqZWN0U3Vic2NyaXB0aW9uLnByb3RvdHlwZS51bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuY2xvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jbG9zZWQgPSB0cnVlO1xuICAgICAgICB2YXIgc3ViamVjdCA9IHRoaXMuc3ViamVjdDtcbiAgICAgICAgdmFyIG9ic2VydmVycyA9IHN1YmplY3Qub2JzZXJ2ZXJzO1xuICAgICAgICB0aGlzLnN1YmplY3QgPSBudWxsO1xuICAgICAgICBpZiAoIW9ic2VydmVycyB8fCBvYnNlcnZlcnMubGVuZ3RoID09PSAwIHx8IHN1YmplY3QuaXNTdG9wcGVkIHx8IHN1YmplY3QuY2xvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN1YnNjcmliZXJJbmRleCA9IG9ic2VydmVycy5pbmRleE9mKHRoaXMuc3Vic2NyaWJlcik7XG4gICAgICAgIGlmIChzdWJzY3JpYmVySW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICBvYnNlcnZlcnMuc3BsaWNlKHN1YnNjcmliZXJJbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBTdWJqZWN0U3Vic2NyaXB0aW9uO1xufShTdWJzY3JpcHRpb25fMS5TdWJzY3JpcHRpb24pKTtcbmV4cG9ydHMuU3ViamVjdFN1YnNjcmlwdGlvbiA9IFN1YmplY3RTdWJzY3JpcHRpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TdWJqZWN0U3Vic2NyaXB0aW9uLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL1N1YmplY3RTdWJzY3JpcHRpb24uanNcbi8vIG1vZHVsZSBpZCA9IDIwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQGxpY2Vuc2UgQW5ndWxhciB2Mi4xLjJcbiAqIChjKSAyMDEwLTIwMTYgR29vZ2xlLCBJbmMuIGh0dHBzOi8vYW5ndWxhci5pby9cbiAqIExpY2Vuc2U6IE1JVFxuICovXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cywgcmVxdWlyZSgnQGFuZ3VsYXIvY29tbW9uJyksIHJlcXVpcmUoJ0Bhbmd1bGFyL2NvcmUnKSkgOlxuICAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnLCAnQGFuZ3VsYXIvY29tbW9uJywgJ0Bhbmd1bGFyL2NvcmUnXSwgZmFjdG9yeSkgOlxuICAgIChmYWN0b3J5KChnbG9iYWwubmcgPSBnbG9iYWwubmcgfHwge30sIGdsb2JhbC5uZy5wbGF0Zm9ybUJyb3dzZXIgPSBnbG9iYWwubmcucGxhdGZvcm1Ccm93c2VyIHx8IHt9KSxnbG9iYWwubmcuY29tbW9uLGdsb2JhbC5uZy5jb3JlKSk7XG59KHRoaXMsIGZ1bmN0aW9uIChleHBvcnRzLF9hbmd1bGFyX2NvbW1vbixfYW5ndWxhcl9jb3JlKSB7ICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBEZWJ1Z0RvbVJvb3RSZW5kZXJlciA9IF9hbmd1bGFyX2NvcmUuX19jb3JlX3ByaXZhdGVfXy5EZWJ1Z0RvbVJvb3RSZW5kZXJlcjtcbiAgICB2YXIgTm9PcEFuaW1hdGlvblBsYXllciA9IF9hbmd1bGFyX2NvcmUuX19jb3JlX3ByaXZhdGVfXy5Ob09wQW5pbWF0aW9uUGxheWVyO1xuXG4gICAgdmFyIF9Ob09wQW5pbWF0aW9uRHJpdmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gX05vT3BBbmltYXRpb25Ecml2ZXIoKSB7XG4gICAgICAgIH1cbiAgICAgICAgX05vT3BBbmltYXRpb25Ecml2ZXIucHJvdG90eXBlLmFuaW1hdGUgPSBmdW5jdGlvbiAoZWxlbWVudCwgc3RhcnRpbmdTdHlsZXMsIGtleWZyYW1lcywgZHVyYXRpb24sIGRlbGF5LCBlYXNpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTm9PcEFuaW1hdGlvblBsYXllcigpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX05vT3BBbmltYXRpb25Ecml2ZXI7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgdmFyIEFuaW1hdGlvbkRyaXZlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEFuaW1hdGlvbkRyaXZlcigpIHtcbiAgICAgICAgfVxuICAgICAgICBBbmltYXRpb25Ecml2ZXIuTk9PUCA9IG5ldyBfTm9PcEFuaW1hdGlvbkRyaXZlcigpO1xuICAgICAgICByZXR1cm4gQW5pbWF0aW9uRHJpdmVyO1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgdmFyIGdsb2JhbFNjb3BlO1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBpZiAodHlwZW9mIFdvcmtlckdsb2JhbFNjb3BlICE9PSAndW5kZWZpbmVkJyAmJiBzZWxmIGluc3RhbmNlb2YgV29ya2VyR2xvYmFsU2NvcGUpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IFJlcGxhY2UgYW55IHdpdGggV29ya2VyR2xvYmFsU2NvcGUgZnJvbSBsaWIud2Vid29ya2VyLmQudHMgIzM0OTJcbiAgICAgICAgICAgIGdsb2JhbFNjb3BlID0gc2VsZjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGdsb2JhbFNjb3BlID0gZ2xvYmFsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBnbG9iYWxTY29wZSA9IHdpbmRvdztcbiAgICB9XG4gICAgLy8gTmVlZCB0byBkZWNsYXJlIGEgbmV3IHZhcmlhYmxlIGZvciBnbG9iYWwgaGVyZSBzaW5jZSBUeXBlU2NyaXB0XG4gICAgLy8gZXhwb3J0cyB0aGUgb3JpZ2luYWwgdmFsdWUgb2YgdGhlIHN5bWJvbC5cbiAgICB2YXIgZ2xvYmFsJDEgPSBnbG9iYWxTY29wZTtcbiAgICAvLyBUT0RPOiByZW1vdmUgY2FsbHMgdG8gYXNzZXJ0IGluIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRcbiAgICAvLyBOb3RlOiBDYW4ndCBqdXN0IGV4cG9ydCB0aGlzIGFuZCBpbXBvcnQgaW4gaW4gb3RoZXIgZmlsZXNcbiAgICAvLyBhcyBgYXNzZXJ0YCBpcyBhIHJlc2VydmVkIGtleXdvcmQgaW4gRGFydFxuICAgIGdsb2JhbCQxLmFzc2VydCA9IGZ1bmN0aW9uIGFzc2VydChjb25kaXRpb24pIHtcbiAgICAgICAgLy8gVE9ETzogdG8gYmUgZml4ZWQgcHJvcGVybHkgdmlhICMyODMwLCBub29wIGZvciBub3dcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGlzUHJlc2VudChvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iaiAhPSBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc0JsYW5rKG9iaikge1xuICAgICAgICByZXR1cm4gb2JqID09IG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0cmluZ2lmeSh0b2tlbikge1xuICAgICAgICBpZiAodHlwZW9mIHRva2VuID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b2tlbiA9PT0gdW5kZWZpbmVkIHx8IHRva2VuID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gJycgKyB0b2tlbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9rZW4ub3ZlcnJpZGRlbk5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0b2tlbi5vdmVycmlkZGVuTmFtZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9rZW4ubmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRva2VuLm5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlcyA9IHRva2VuLnRvU3RyaW5nKCk7XG4gICAgICAgIHZhciBuZXdMaW5lSW5kZXggPSByZXMuaW5kZXhPZignXFxuJyk7XG4gICAgICAgIHJldHVybiBuZXdMaW5lSW5kZXggPT09IC0xID8gcmVzIDogcmVzLnN1YnN0cmluZygwLCBuZXdMaW5lSW5kZXgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzZXRWYWx1ZU9uUGF0aChnbG9iYWwsIHBhdGgsIHZhbHVlKSB7XG4gICAgICAgIHZhciBwYXJ0cyA9IHBhdGguc3BsaXQoJy4nKTtcbiAgICAgICAgdmFyIG9iaiA9IGdsb2JhbDtcbiAgICAgICAgd2hpbGUgKHBhcnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHZhciBuYW1lID0gcGFydHMuc2hpZnQoKTtcbiAgICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkobmFtZSkgJiYgaXNQcmVzZW50KG9ialtuYW1lXSkpIHtcbiAgICAgICAgICAgICAgICBvYmogPSBvYmpbbmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvYmogPSBvYmpbbmFtZV0gPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqID09PSB1bmRlZmluZWQgfHwgb2JqID09PSBudWxsKSB7XG4gICAgICAgICAgICBvYmogPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBvYmpbcGFydHMuc2hpZnQoKV0gPSB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgdmFyIENBTUVMX0NBU0VfUkVHRVhQID0gLyhbQS1aXSkvZztcbiAgICB2YXIgREFTSF9DQVNFX1JFR0VYUCA9IC8tKFthLXpdKS9nO1xuICAgIGZ1bmN0aW9uIGNhbWVsQ2FzZVRvRGFzaENhc2UoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0LnJlcGxhY2UoQ0FNRUxfQ0FTRV9SRUdFWFAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBtID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIG1bX2kgLSAwXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJy0nICsgbVsxXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGFzaENhc2VUb0NhbWVsQ2FzZShpbnB1dCkge1xuICAgICAgICByZXR1cm4gaW5wdXQucmVwbGFjZShEQVNIX0NBU0VfUkVHRVhQLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbSA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICBtW19pIC0gMF0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1bMV0udG9VcHBlckNhc2UoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIHZhciBfRE9NID0gbnVsbDtcbiAgICBmdW5jdGlvbiBnZXRET00oKSB7XG4gICAgICAgIHJldHVybiBfRE9NO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzZXRSb290RG9tQWRhcHRlcihhZGFwdGVyKSB7XG4gICAgICAgIGlmICghX0RPTSkge1xuICAgICAgICAgICAgX0RPTSA9IGFkYXB0ZXI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyogdHNsaW50OmRpc2FibGU6cmVxdWlyZVBhcmFtZXRlclR5cGUgKi9cbiAgICAvKipcbiAgICAgKiBQcm92aWRlcyBET00gb3BlcmF0aW9ucyBpbiBhbiBlbnZpcm9ubWVudC1hZ25vc3RpYyB3YXkuXG4gICAgICpcbiAgICAgKiBAc2VjdXJpdHkgVHJlYWQgY2FyZWZ1bGx5ISBJbnRlcmFjdGluZyB3aXRoIHRoZSBET00gZGlyZWN0bHkgaXMgZGFuZ2Vyb3VzIGFuZFxuICAgICAqIGNhbiBpbnRyb2R1Y2UgWFNTIHJpc2tzLlxuICAgICAqL1xuICAgIHZhciBEb21BZGFwdGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gRG9tQWRhcHRlcigpIHtcbiAgICAgICAgICAgIHRoaXMucmVzb3VyY2VMb2FkZXJUeXBlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRG9tQWRhcHRlci5wcm90b3R5cGUsIFwiYXR0clRvUHJvcE1hcFwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIE1hcHMgYXR0cmlidXRlIG5hbWVzIHRvIHRoZWlyIGNvcnJlc3BvbmRpbmcgcHJvcGVydHkgbmFtZXMgZm9yIGNhc2VzXG4gICAgICAgICAgICAgKiB3aGVyZSBhdHRyaWJ1dGUgbmFtZSBkb2Vzbid0IG1hdGNoIHByb3BlcnR5IG5hbWUuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fYXR0clRvUHJvcE1hcDsgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7IHRoaXMuX2F0dHJUb1Byb3BNYXAgPSB2YWx1ZTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIDtcbiAgICAgICAgO1xuICAgICAgICByZXR1cm4gRG9tQWRhcHRlcjtcbiAgICB9KCkpO1xuXG4gICAgdmFyIFdlYkFuaW1hdGlvbnNQbGF5ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBXZWJBbmltYXRpb25zUGxheWVyKGVsZW1lbnQsIGtleWZyYW1lcywgb3B0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgICAgIHRoaXMua2V5ZnJhbWVzID0ga2V5ZnJhbWVzO1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgICAgIHRoaXMuX29uRG9uZUZucyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fb25TdGFydEZucyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fZmluaXNoZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2luaXRpYWxpemVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnBhcmVudFBsYXllciA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9kdXJhdGlvbiA9IG9wdGlvbnNbJ2R1cmF0aW9uJ107XG4gICAgICAgIH1cbiAgICAgICAgV2ViQW5pbWF0aW9uc1BsYXllci5wcm90b3R5cGUuX29uRmluaXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9maW5pc2hlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2ZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzUHJlc2VudCh0aGlzLnBhcmVudFBsYXllcikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX29uRG9uZUZucy5mb3JFYWNoKGZ1bmN0aW9uIChmbikgeyByZXR1cm4gZm4oKTsgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fb25Eb25lRm5zID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIFdlYkFuaW1hdGlvbnNQbGF5ZXIucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2luaXRpYWxpemVkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHRoaXMuX2luaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBrZXlmcmFtZXMgPSB0aGlzLmtleWZyYW1lcy5tYXAoZnVuY3Rpb24gKHN0eWxlcykge1xuICAgICAgICAgICAgICAgIHZhciBmb3JtYXR0ZWRLZXlmcmFtZSA9IHt9O1xuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHN0eWxlcykuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBzdHlsZXNbcHJvcF07XG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdHRlZEtleWZyYW1lW3Byb3BdID0gdmFsdWUgPT0gX2FuZ3VsYXJfY29yZS5BVVRPX1NUWUxFID8gX2NvbXB1dGVTdHlsZShfdGhpcy5lbGVtZW50LCBwcm9wKSA6IHZhbHVlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBmb3JtYXR0ZWRLZXlmcmFtZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5fcGxheWVyID0gdGhpcy5fdHJpZ2dlcldlYkFuaW1hdGlvbih0aGlzLmVsZW1lbnQsIGtleWZyYW1lcywgdGhpcy5vcHRpb25zKTtcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgcmVxdWlyZWQgc28gdGhhdCB0aGUgcGxheWVyIGRvZXNuJ3Qgc3RhcnQgdG8gYW5pbWF0ZSByaWdodCBhd2F5XG4gICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgICAgICB0aGlzLl9wbGF5ZXIub25maW5pc2ggPSBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fb25GaW5pc2goKTsgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBXZWJBbmltYXRpb25zUGxheWVyLnByb3RvdHlwZS5fdHJpZ2dlcldlYkFuaW1hdGlvbiA9IGZ1bmN0aW9uIChlbGVtZW50LCBrZXlmcmFtZXMsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50LmFuaW1hdGUoa2V5ZnJhbWVzLCBvcHRpb25zKTtcbiAgICAgICAgfTtcbiAgICAgICAgV2ViQW5pbWF0aW9uc1BsYXllci5wcm90b3R5cGUub25TdGFydCA9IGZ1bmN0aW9uIChmbikgeyB0aGlzLl9vblN0YXJ0Rm5zLnB1c2goZm4pOyB9O1xuICAgICAgICBXZWJBbmltYXRpb25zUGxheWVyLnByb3RvdHlwZS5vbkRvbmUgPSBmdW5jdGlvbiAoZm4pIHsgdGhpcy5fb25Eb25lRm5zLnB1c2goZm4pOyB9O1xuICAgICAgICBXZWJBbmltYXRpb25zUGxheWVyLnByb3RvdHlwZS5wbGF5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5pbml0KCk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaGFzU3RhcnRlZCgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fb25TdGFydEZucy5mb3JFYWNoKGZ1bmN0aW9uIChmbikgeyByZXR1cm4gZm4oKTsgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fb25TdGFydEZucyA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcGxheWVyLnBsYXkoKTtcbiAgICAgICAgfTtcbiAgICAgICAgV2ViQW5pbWF0aW9uc1BsYXllci5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmluaXQoKTtcbiAgICAgICAgICAgIHRoaXMuX3BsYXllci5wYXVzZSgpO1xuICAgICAgICB9O1xuICAgICAgICBXZWJBbmltYXRpb25zUGxheWVyLnByb3RvdHlwZS5maW5pc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmluaXQoKTtcbiAgICAgICAgICAgIHRoaXMuX29uRmluaXNoKCk7XG4gICAgICAgICAgICB0aGlzLl9wbGF5ZXIuZmluaXNoKCk7XG4gICAgICAgIH07XG4gICAgICAgIFdlYkFuaW1hdGlvbnNQbGF5ZXIucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkgeyB0aGlzLl9wbGF5ZXIuY2FuY2VsKCk7IH07XG4gICAgICAgIFdlYkFuaW1hdGlvbnNQbGF5ZXIucHJvdG90eXBlLnJlc3RhcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgICAgICB0aGlzLnBsYXkoKTtcbiAgICAgICAgfTtcbiAgICAgICAgV2ViQW5pbWF0aW9uc1BsYXllci5wcm90b3R5cGUuaGFzU3RhcnRlZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3N0YXJ0ZWQ7IH07XG4gICAgICAgIFdlYkFuaW1hdGlvbnNQbGF5ZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgICAgICB0aGlzLl9vbkZpbmlzaCgpO1xuICAgICAgICB9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViQW5pbWF0aW9uc1BsYXllci5wcm90b3R5cGUsIFwidG90YWxUaW1lXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZHVyYXRpb247IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBXZWJBbmltYXRpb25zUGxheWVyLnByb3RvdHlwZS5zZXRQb3NpdGlvbiA9IGZ1bmN0aW9uIChwKSB7IHRoaXMuX3BsYXllci5jdXJyZW50VGltZSA9IHAgKiB0aGlzLnRvdGFsVGltZTsgfTtcbiAgICAgICAgV2ViQW5pbWF0aW9uc1BsYXllci5wcm90b3R5cGUuZ2V0UG9zaXRpb24gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9wbGF5ZXIuY3VycmVudFRpbWUgLyB0aGlzLnRvdGFsVGltZTsgfTtcbiAgICAgICAgcmV0dXJuIFdlYkFuaW1hdGlvbnNQbGF5ZXI7XG4gICAgfSgpKTtcbiAgICBmdW5jdGlvbiBfY29tcHV0ZVN0eWxlKGVsZW1lbnQsIHByb3ApIHtcbiAgICAgICAgcmV0dXJuIGdldERPTSgpLmdldENvbXB1dGVkU3R5bGUoZWxlbWVudClbcHJvcF07XG4gICAgfVxuXG4gICAgdmFyIFdlYkFuaW1hdGlvbnNEcml2ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBXZWJBbmltYXRpb25zRHJpdmVyKCkge1xuICAgICAgICB9XG4gICAgICAgIFdlYkFuaW1hdGlvbnNEcml2ZXIucHJvdG90eXBlLmFuaW1hdGUgPSBmdW5jdGlvbiAoZWxlbWVudCwgc3RhcnRpbmdTdHlsZXMsIGtleWZyYW1lcywgZHVyYXRpb24sIGRlbGF5LCBlYXNpbmcpIHtcbiAgICAgICAgICAgIHZhciBmb3JtYXR0ZWRTdGVwcyA9IFtdO1xuICAgICAgICAgICAgdmFyIHN0YXJ0aW5nU3R5bGVMb29rdXAgPSB7fTtcbiAgICAgICAgICAgIGlmIChpc1ByZXNlbnQoc3RhcnRpbmdTdHlsZXMpICYmIHN0YXJ0aW5nU3R5bGVzLnN0eWxlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgc3RhcnRpbmdTdHlsZUxvb2t1cCA9IF9wb3B1bGF0ZVN0eWxlcyhlbGVtZW50LCBzdGFydGluZ1N0eWxlcywge30pO1xuICAgICAgICAgICAgICAgIHN0YXJ0aW5nU3R5bGVMb29rdXBbJ29mZnNldCddID0gMDtcbiAgICAgICAgICAgICAgICBmb3JtYXR0ZWRTdGVwcy5wdXNoKHN0YXJ0aW5nU3R5bGVMb29rdXApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAga2V5ZnJhbWVzLmZvckVhY2goZnVuY3Rpb24gKGtleWZyYW1lKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBfcG9wdWxhdGVTdHlsZXMoZWxlbWVudCwga2V5ZnJhbWUuc3R5bGVzLCBzdGFydGluZ1N0eWxlTG9va3VwKTtcbiAgICAgICAgICAgICAgICBkYXRhWydvZmZzZXQnXSA9IGtleWZyYW1lLm9mZnNldDtcbiAgICAgICAgICAgICAgICBmb3JtYXR0ZWRTdGVwcy5wdXNoKGRhdGEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyB0aGlzIGlzIGEgc3BlY2lhbCBjYXNlIHdoZW4gb25seSBzdHlsZXMgYXJlIGFwcGxpZWQgYXMgYW5cbiAgICAgICAgICAgIC8vIGFuaW1hdGlvbi4gV2hlbiB0aGlzIG9jY3VycyB3ZSB3YW50IHRvIGFuaW1hdGUgZnJvbSBzdGFydCB0b1xuICAgICAgICAgICAgLy8gZW5kIHdpdGggdGhlIHNhbWUgdmFsdWVzLiBSZW1vdmluZyB0aGUgb2Zmc2V0IGFuZCBoYXZpbmcgb25seVxuICAgICAgICAgICAgLy8gc3RhcnQvZW5kIHZhbHVlcyBpcyBzdWl0YWJsZSBlbm91Z2ggZm9yIHRoZSB3ZWItYW5pbWF0aW9ucyBBUElcbiAgICAgICAgICAgIGlmIChmb3JtYXR0ZWRTdGVwcy5sZW5ndGggPT0gMSkge1xuICAgICAgICAgICAgICAgIHZhciBzdGFydCA9IGZvcm1hdHRlZFN0ZXBzWzBdO1xuICAgICAgICAgICAgICAgIHN0YXJ0WydvZmZzZXQnXSA9IG51bGw7XG4gICAgICAgICAgICAgICAgZm9ybWF0dGVkU3RlcHMgPSBbc3RhcnQsIHN0YXJ0XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBwbGF5ZXJPcHRpb25zID0ge1xuICAgICAgICAgICAgICAgICdkdXJhdGlvbic6IGR1cmF0aW9uLFxuICAgICAgICAgICAgICAgICdkZWxheSc6IGRlbGF5LFxuICAgICAgICAgICAgICAgICdmaWxsJzogJ2JvdGgnIC8vIHdlIHVzZSBgYm90aGAgYmVjYXVzZSBpdCBhbGxvd3MgZm9yIHN0eWxpbmcgYXQgMCUgdG8gd29yayB3aXRoIGBkZWxheWBcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyB3ZSBjaGVjayBmb3IgdGhpcyB0byBhdm9pZCBoYXZpbmcgYSBudWxsfHVuZGVmaW5lZCB2YWx1ZSBiZSBwcmVzZW50XG4gICAgICAgICAgICAvLyBmb3IgdGhlIGVhc2luZyAod2hpY2ggcmVzdWx0cyBpbiBhbiBlcnJvciBmb3IgY2VydGFpbiBicm93c2VycyAjOTc1MilcbiAgICAgICAgICAgIGlmIChlYXNpbmcpIHtcbiAgICAgICAgICAgICAgICBwbGF5ZXJPcHRpb25zWydlYXNpbmcnXSA9IGVhc2luZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgV2ViQW5pbWF0aW9uc1BsYXllcihlbGVtZW50LCBmb3JtYXR0ZWRTdGVwcywgcGxheWVyT3B0aW9ucyk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBXZWJBbmltYXRpb25zRHJpdmVyO1xuICAgIH0oKSk7XG4gICAgZnVuY3Rpb24gX3BvcHVsYXRlU3R5bGVzKGVsZW1lbnQsIHN0eWxlcywgZGVmYXVsdFN0eWxlcykge1xuICAgICAgICB2YXIgZGF0YSA9IHt9O1xuICAgICAgICBzdHlsZXMuc3R5bGVzLmZvckVhY2goZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhlbnRyeSkuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgICAgICAgIHZhciB2YWwgPSBlbnRyeVtwcm9wXTtcbiAgICAgICAgICAgICAgICB2YXIgZm9ybWF0dGVkUHJvcCA9IGRhc2hDYXNlVG9DYW1lbENhc2UocHJvcCk7XG4gICAgICAgICAgICAgICAgZGF0YVtmb3JtYXR0ZWRQcm9wXSA9XG4gICAgICAgICAgICAgICAgICAgIHZhbCA9PSBfYW5ndWxhcl9jb3JlLkFVVE9fU1RZTEUgPyB2YWwgOiB2YWwudG9TdHJpbmcoKSArIF9yZXNvbHZlU3R5bGVVbml0KHZhbCwgcHJvcCwgZm9ybWF0dGVkUHJvcCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5rZXlzKGRlZmF1bHRTdHlsZXMpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICAgIGlmICghaXNQcmVzZW50KGRhdGFbcHJvcF0pKSB7XG4gICAgICAgICAgICAgICAgZGF0YVtwcm9wXSA9IGRlZmF1bHRTdHlsZXNbcHJvcF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgZnVuY3Rpb24gX3Jlc29sdmVTdHlsZVVuaXQodmFsLCB1c2VyUHJvdmlkZWRQcm9wLCBmb3JtYXR0ZWRQcm9wKSB7XG4gICAgICAgIHZhciB1bml0ID0gJyc7XG4gICAgICAgIGlmIChfaXNQaXhlbERpbWVuc2lvblN0eWxlKGZvcm1hdHRlZFByb3ApICYmIHZhbCAhPSAwICYmIHZhbCAhPSAnMCcpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIHVuaXQgPSAncHgnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoX2ZpbmREaW1lbnNpb25hbFN1ZmZpeCh2YWwudG9TdHJpbmcoKSkubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BsZWFzZSBwcm92aWRlIGEgQ1NTIHVuaXQgdmFsdWUgZm9yICcgKyB1c2VyUHJvdmlkZWRQcm9wICsgJzonICsgdmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5pdDtcbiAgICB9XG4gICAgdmFyIF8kMCA9IDQ4O1xuICAgIHZhciBfJDkgPSA1NztcbiAgICB2YXIgXyRQRVJJT0QgPSA0NjtcbiAgICBmdW5jdGlvbiBfZmluZERpbWVuc2lvbmFsU3VmZml4KHZhbHVlKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjID0gdmFsdWUuY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgIGlmICgoYyA+PSBfJDAgJiYgYyA8PSBfJDkpIHx8IGMgPT0gXyRQRVJJT0QpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUuc3Vic3RyaW5nKGksIHZhbHVlLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICBmdW5jdGlvbiBfaXNQaXhlbERpbWVuc2lvblN0eWxlKHByb3ApIHtcbiAgICAgICAgc3dpdGNoIChwcm9wKSB7XG4gICAgICAgICAgICBjYXNlICd3aWR0aCc6XG4gICAgICAgICAgICBjYXNlICdoZWlnaHQnOlxuICAgICAgICAgICAgY2FzZSAnbWluV2lkdGgnOlxuICAgICAgICAgICAgY2FzZSAnbWluSGVpZ2h0JzpcbiAgICAgICAgICAgIGNhc2UgJ21heFdpZHRoJzpcbiAgICAgICAgICAgIGNhc2UgJ21heEhlaWdodCc6XG4gICAgICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgICAgY2FzZSAnZm9udFNpemUnOlxuICAgICAgICAgICAgY2FzZSAnb3V0bGluZVdpZHRoJzpcbiAgICAgICAgICAgIGNhc2UgJ291dGxpbmVPZmZzZXQnOlxuICAgICAgICAgICAgY2FzZSAncGFkZGluZ1RvcCc6XG4gICAgICAgICAgICBjYXNlICdwYWRkaW5nTGVmdCc6XG4gICAgICAgICAgICBjYXNlICdwYWRkaW5nQm90dG9tJzpcbiAgICAgICAgICAgIGNhc2UgJ3BhZGRpbmdSaWdodCc6XG4gICAgICAgICAgICBjYXNlICdtYXJnaW5Ub3AnOlxuICAgICAgICAgICAgY2FzZSAnbWFyZ2luTGVmdCc6XG4gICAgICAgICAgICBjYXNlICdtYXJnaW5Cb3R0b20nOlxuICAgICAgICAgICAgY2FzZSAnbWFyZ2luUmlnaHQnOlxuICAgICAgICAgICAgY2FzZSAnYm9yZGVyUmFkaXVzJzpcbiAgICAgICAgICAgIGNhc2UgJ2JvcmRlcldpZHRoJzpcbiAgICAgICAgICAgIGNhc2UgJ2JvcmRlclRvcFdpZHRoJzpcbiAgICAgICAgICAgIGNhc2UgJ2JvcmRlckxlZnRXaWR0aCc6XG4gICAgICAgICAgICBjYXNlICdib3JkZXJSaWdodFdpZHRoJzpcbiAgICAgICAgICAgIGNhc2UgJ2JvcmRlckJvdHRvbVdpZHRoJzpcbiAgICAgICAgICAgIGNhc2UgJ3RleHRJbmRlbnQnOlxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgdmFyIF9fZXh0ZW5kcyQxID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUHJvdmlkZXMgRE9NIG9wZXJhdGlvbnMgaW4gYW55IGJyb3dzZXIgZW52aXJvbm1lbnQuXG4gICAgICpcbiAgICAgKiBAc2VjdXJpdHkgVHJlYWQgY2FyZWZ1bGx5ISBJbnRlcmFjdGluZyB3aXRoIHRoZSBET00gZGlyZWN0bHkgaXMgZGFuZ2Vyb3VzIGFuZFxuICAgICAqIGNhbiBpbnRyb2R1Y2UgWFNTIHJpc2tzLlxuICAgICAqL1xuICAgIHZhciBHZW5lcmljQnJvd3NlckRvbUFkYXB0ZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMkMShHZW5lcmljQnJvd3NlckRvbUFkYXB0ZXIsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIEdlbmVyaWNCcm93c2VyRG9tQWRhcHRlcigpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuX2FuaW1hdGlvblByZWZpeCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl90cmFuc2l0aW9uRW5kID0gbnVsbDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsZW1lbnRfMSA9IHRoaXMuY3JlYXRlRWxlbWVudCgnZGl2JywgdGhpcy5kZWZhdWx0RG9jKCkpO1xuICAgICAgICAgICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5nZXRTdHlsZShlbGVtZW50XzEsICdhbmltYXRpb25OYW1lJykpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FuaW1hdGlvblByZWZpeCA9ICcnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRvbVByZWZpeGVzID0gWydXZWJraXQnLCAnTW96JywgJ08nLCAnbXMnXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkb21QcmVmaXhlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLmdldFN0eWxlKGVsZW1lbnRfMSwgZG9tUHJlZml4ZXNbaV0gKyAnQW5pbWF0aW9uTmFtZScpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2FuaW1hdGlvblByZWZpeCA9ICctJyArIGRvbVByZWZpeGVzW2ldLnRvTG93ZXJDYXNlKCkgKyAnLSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHRyYW5zRW5kRXZlbnROYW1lc18xID0ge1xuICAgICAgICAgICAgICAgICAgICBXZWJraXRUcmFuc2l0aW9uOiAnd2Via2l0VHJhbnNpdGlvbkVuZCcsXG4gICAgICAgICAgICAgICAgICAgIE1velRyYW5zaXRpb246ICd0cmFuc2l0aW9uZW5kJyxcbiAgICAgICAgICAgICAgICAgICAgT1RyYW5zaXRpb246ICdvVHJhbnNpdGlvbkVuZCBvdHJhbnNpdGlvbmVuZCcsXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb246ICd0cmFuc2l0aW9uZW5kJ1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXModHJhbnNFbmRFdmVudE5hbWVzXzEpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNQcmVzZW50KF90aGlzLmdldFN0eWxlKGVsZW1lbnRfMSwga2V5KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl90cmFuc2l0aW9uRW5kID0gdHJhbnNFbmRFdmVudE5hbWVzXzFba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hbmltYXRpb25QcmVmaXggPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuX3RyYW5zaXRpb25FbmQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIEdlbmVyaWNCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuZ2V0RGlzdHJpYnV0ZWROb2RlcyA9IGZ1bmN0aW9uIChlbCkgeyByZXR1cm4gZWwuZ2V0RGlzdHJpYnV0ZWROb2RlcygpOyB9O1xuICAgICAgICBHZW5lcmljQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLnJlc29sdmVBbmRTZXRIcmVmID0gZnVuY3Rpb24gKGVsLCBiYXNlVXJsLCBocmVmKSB7XG4gICAgICAgICAgICBlbC5ocmVmID0gaHJlZiA9PSBudWxsID8gYmFzZVVybCA6IGJhc2VVcmwgKyAnLy4uLycgKyBocmVmO1xuICAgICAgICB9O1xuICAgICAgICBHZW5lcmljQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLnN1cHBvcnRzRE9NRXZlbnRzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJ1ZTsgfTtcbiAgICAgICAgR2VuZXJpY0Jyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5zdXBwb3J0c05hdGl2ZVNoYWRvd0RPTSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgdGhpcy5kZWZhdWx0RG9jKCkuYm9keS5jcmVhdGVTaGFkb3dSb290ID09PSAnZnVuY3Rpb24nO1xuICAgICAgICB9O1xuICAgICAgICBHZW5lcmljQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmdldEFuaW1hdGlvblByZWZpeCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2FuaW1hdGlvblByZWZpeCA/IHRoaXMuX2FuaW1hdGlvblByZWZpeCA6ICcnOyB9O1xuICAgICAgICBHZW5lcmljQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmdldFRyYW5zaXRpb25FbmQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl90cmFuc2l0aW9uRW5kID8gdGhpcy5fdHJhbnNpdGlvbkVuZCA6ICcnOyB9O1xuICAgICAgICBHZW5lcmljQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLnN1cHBvcnRzQW5pbWF0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGlzUHJlc2VudCh0aGlzLl9hbmltYXRpb25QcmVmaXgpICYmIGlzUHJlc2VudCh0aGlzLl90cmFuc2l0aW9uRW5kKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIEdlbmVyaWNCcm93c2VyRG9tQWRhcHRlcjtcbiAgICB9KERvbUFkYXB0ZXIpKTtcblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICB2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG4gICAgdmFyIF9hdHRyVG9Qcm9wTWFwID0ge1xuICAgICAgICAnY2xhc3MnOiAnY2xhc3NOYW1lJyxcbiAgICAgICAgJ2lubmVySHRtbCc6ICdpbm5lckhUTUwnLFxuICAgICAgICAncmVhZG9ubHknOiAncmVhZE9ubHknLFxuICAgICAgICAndGFiaW5kZXgnOiAndGFiSW5kZXgnLFxuICAgIH07XG4gICAgdmFyIERPTV9LRVlfTE9DQVRJT05fTlVNUEFEID0gMztcbiAgICAvLyBNYXAgdG8gY29udmVydCBzb21lIGtleSBvciBrZXlJZGVudGlmaWVyIHZhbHVlcyB0byB3aGF0IHdpbGwgYmUgcmV0dXJuZWQgYnkgZ2V0RXZlbnRLZXlcbiAgICB2YXIgX2tleU1hcCA9IHtcbiAgICAgICAgLy8gVGhlIGZvbGxvd2luZyB2YWx1ZXMgYXJlIGhlcmUgZm9yIGNyb3NzLWJyb3dzZXIgY29tcGF0aWJpbGl0eSBhbmQgdG8gbWF0Y2ggdGhlIFczQyBzdGFuZGFyZFxuICAgICAgICAvLyBjZiBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMta2V5L1xuICAgICAgICAnXFxiJzogJ0JhY2tzcGFjZScsXG4gICAgICAgICdcXHQnOiAnVGFiJyxcbiAgICAgICAgJ1xceDdGJzogJ0RlbGV0ZScsXG4gICAgICAgICdcXHgxQic6ICdFc2NhcGUnLFxuICAgICAgICAnRGVsJzogJ0RlbGV0ZScsXG4gICAgICAgICdFc2MnOiAnRXNjYXBlJyxcbiAgICAgICAgJ0xlZnQnOiAnQXJyb3dMZWZ0JyxcbiAgICAgICAgJ1JpZ2h0JzogJ0Fycm93UmlnaHQnLFxuICAgICAgICAnVXAnOiAnQXJyb3dVcCcsXG4gICAgICAgICdEb3duJzogJ0Fycm93RG93bicsXG4gICAgICAgICdNZW51JzogJ0NvbnRleHRNZW51JyxcbiAgICAgICAgJ1Njcm9sbCc6ICdTY3JvbGxMb2NrJyxcbiAgICAgICAgJ1dpbic6ICdPUydcbiAgICB9O1xuICAgIC8vIFRoZXJlIGlzIGEgYnVnIGluIENocm9tZSBmb3IgbnVtZXJpYyBrZXlwYWQga2V5czpcbiAgICAvLyBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MTU1NjU0XG4gICAgLy8gMSwgMiwgMyAuLi4gYXJlIHJlcG9ydGVkIGFzIEEsIEIsIEMgLi4uXG4gICAgdmFyIF9jaHJvbWVOdW1LZXlQYWRNYXAgPSB7XG4gICAgICAgICdBJzogJzEnLFxuICAgICAgICAnQic6ICcyJyxcbiAgICAgICAgJ0MnOiAnMycsXG4gICAgICAgICdEJzogJzQnLFxuICAgICAgICAnRSc6ICc1JyxcbiAgICAgICAgJ0YnOiAnNicsXG4gICAgICAgICdHJzogJzcnLFxuICAgICAgICAnSCc6ICc4JyxcbiAgICAgICAgJ0knOiAnOScsXG4gICAgICAgICdKJzogJyonLFxuICAgICAgICAnSyc6ICcrJyxcbiAgICAgICAgJ00nOiAnLScsXG4gICAgICAgICdOJzogJy4nLFxuICAgICAgICAnTyc6ICcvJyxcbiAgICAgICAgJ1xceDYwJzogJzAnLFxuICAgICAgICAnXFx4OTAnOiAnTnVtTG9jaydcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEEgYERvbUFkYXB0ZXJgIHBvd2VyZWQgYnkgZnVsbCBicm93c2VyIERPTSBBUElzLlxuICAgICAqXG4gICAgICogQHNlY3VyaXR5IFRyZWFkIGNhcmVmdWxseSEgSW50ZXJhY3Rpbmcgd2l0aCB0aGUgRE9NIGRpcmVjdGx5IGlzIGRhbmdlcm91cyBhbmRcbiAgICAgKiBjYW4gaW50cm9kdWNlIFhTUyByaXNrcy5cbiAgICAgKi9cbiAgICAvKiB0c2xpbnQ6ZGlzYWJsZTpyZXF1aXJlUGFyYW1ldGVyVHlwZSAqL1xuICAgIHZhciBCcm93c2VyRG9tQWRhcHRlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyhCcm93c2VyRG9tQWRhcHRlciwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gQnJvd3NlckRvbUFkYXB0ZXIoKSB7XG4gICAgICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAodGVtcGxhdGVIdG1sKSB7IHRocm93IG5ldyBFcnJvcigncGFyc2Ugbm90IGltcGxlbWVudGVkJyk7IH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLm1ha2VDdXJyZW50ID0gZnVuY3Rpb24gKCkgeyBzZXRSb290RG9tQWRhcHRlcihuZXcgQnJvd3NlckRvbUFkYXB0ZXIoKSk7IH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5oYXNQcm9wZXJ0eSA9IGZ1bmN0aW9uIChlbGVtZW50LCBuYW1lKSB7IHJldHVybiBuYW1lIGluIGVsZW1lbnQ7IH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5zZXRQcm9wZXJ0eSA9IGZ1bmN0aW9uIChlbCwgbmFtZSwgdmFsdWUpIHsgZWxbbmFtZV0gPSB2YWx1ZTsgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmdldFByb3BlcnR5ID0gZnVuY3Rpb24gKGVsLCBuYW1lKSB7IHJldHVybiBlbFtuYW1lXTsgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmludm9rZSA9IGZ1bmN0aW9uIChlbCwgbWV0aG9kTmFtZSwgYXJncykgeyAoX2EgPSBlbClbbWV0aG9kTmFtZV0uYXBwbHkoX2EsIGFyZ3MpOyB2YXIgX2E7IH07XG4gICAgICAgIC8vIFRPRE8odGJvc2NoKTogbW92ZSB0aGlzIGludG8gYSBzZXBhcmF0ZSBlbnZpcm9ubWVudCBjbGFzcyBvbmNlIHdlIGhhdmUgaXRcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmxvZ0Vycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7ICh3aW5kb3cuY29uc29sZS5lcnJvciB8fCB3aW5kb3cuY29uc29sZS5sb2cpKGVycm9yKTsgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmxvZyA9IGZ1bmN0aW9uIChlcnJvcikgeyB3aW5kb3cuY29uc29sZS5sb2coZXJyb3IpOyB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUubG9nR3JvdXAgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIHdpbmRvdy5jb25zb2xlLmdyb3VwICYmIHdpbmRvdy5jb25zb2xlLmdyb3VwKGVycm9yKTtcbiAgICAgICAgICAgIHRoaXMubG9nRXJyb3IoZXJyb3IpO1xuICAgICAgICB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUubG9nR3JvdXBFbmQgPSBmdW5jdGlvbiAoKSB7IHdpbmRvdy5jb25zb2xlLmdyb3VwRW5kICYmIHdpbmRvdy5jb25zb2xlLmdyb3VwRW5kKCk7IH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUsIFwiYXR0clRvUHJvcE1hcFwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF9hdHRyVG9Qcm9wTWFwOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLnF1ZXJ5ID0gZnVuY3Rpb24gKHNlbGVjdG9yKSB7IHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTsgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLnF1ZXJ5U2VsZWN0b3IgPSBmdW5jdGlvbiAoZWwsIHNlbGVjdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZWwucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7XG4gICAgICAgIH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5xdWVyeVNlbGVjdG9yQWxsID0gZnVuY3Rpb24gKGVsLCBzZWxlY3RvcikgeyByZXR1cm4gZWwucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7IH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIChlbCwgZXZ0LCBsaXN0ZW5lcikgeyBlbC5hZGRFdmVudExpc3RlbmVyKGV2dCwgbGlzdGVuZXIsIGZhbHNlKTsgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLm9uQW5kQ2FuY2VsID0gZnVuY3Rpb24gKGVsLCBldnQsIGxpc3RlbmVyKSB7XG4gICAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKGV2dCwgbGlzdGVuZXIsIGZhbHNlKTtcbiAgICAgICAgICAgIC8vIE5lZWRlZCB0byBmb2xsb3cgRGFydCdzIHN1YnNjcmlwdGlvbiBzZW1hbnRpYywgdW50aWwgZml4IG9mXG4gICAgICAgICAgICAvLyBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2RhcnQvaXNzdWVzL2RldGFpbD9pZD0xNzQwNlxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldnQsIGxpc3RlbmVyLCBmYWxzZSk7IH07XG4gICAgICAgIH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5kaXNwYXRjaEV2ZW50ID0gZnVuY3Rpb24gKGVsLCBldnQpIHsgZWwuZGlzcGF0Y2hFdmVudChldnQpOyB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuY3JlYXRlTW91c2VFdmVudCA9IGZ1bmN0aW9uIChldmVudFR5cGUpIHtcbiAgICAgICAgICAgIHZhciBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnTW91c2VFdmVudCcpO1xuICAgICAgICAgICAgZXZ0LmluaXRFdmVudChldmVudFR5cGUsIHRydWUsIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuIGV2dDtcbiAgICAgICAgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmNyZWF0ZUV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50VHlwZSkge1xuICAgICAgICAgICAgdmFyIGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpO1xuICAgICAgICAgICAgZXZ0LmluaXRFdmVudChldmVudFR5cGUsIHRydWUsIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuIGV2dDtcbiAgICAgICAgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLnByZXZlbnREZWZhdWx0ID0gZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBldnQucmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmlzUHJldmVudGVkID0gZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICAgICAgcmV0dXJuIGV2dC5kZWZhdWx0UHJldmVudGVkIHx8IGlzUHJlc2VudChldnQucmV0dXJuVmFsdWUpICYmICFldnQucmV0dXJuVmFsdWU7XG4gICAgICAgIH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5nZXRJbm5lckhUTUwgPSBmdW5jdGlvbiAoZWwpIHsgcmV0dXJuIGVsLmlubmVySFRNTDsgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmdldFRlbXBsYXRlQ29udGVudCA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgcmV0dXJuICdjb250ZW50JyBpbiBlbCAmJiBlbCBpbnN0YW5jZW9mIEhUTUxUZW1wbGF0ZUVsZW1lbnQgPyBlbC5jb250ZW50IDogbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmdldE91dGVySFRNTCA9IGZ1bmN0aW9uIChlbCkgeyByZXR1cm4gZWwub3V0ZXJIVE1MOyB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUubm9kZU5hbWUgPSBmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZS5ub2RlTmFtZTsgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLm5vZGVWYWx1ZSA9IGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBub2RlLm5vZGVWYWx1ZTsgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLnR5cGUgPSBmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZS50eXBlOyB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuY29udGVudCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5oYXNQcm9wZXJ0eShub2RlLCAnY29udGVudCcpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUuY29udGVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuZmlyc3RDaGlsZCA9IGZ1bmN0aW9uIChlbCkgeyByZXR1cm4gZWwuZmlyc3RDaGlsZDsgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLm5leHRTaWJsaW5nID0gZnVuY3Rpb24gKGVsKSB7IHJldHVybiBlbC5uZXh0U2libGluZzsgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLnBhcmVudEVsZW1lbnQgPSBmdW5jdGlvbiAoZWwpIHsgcmV0dXJuIGVsLnBhcmVudE5vZGU7IH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5jaGlsZE5vZGVzID0gZnVuY3Rpb24gKGVsKSB7IHJldHVybiBlbC5jaGlsZE5vZGVzOyB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuY2hpbGROb2Rlc0FzTGlzdCA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgdmFyIGNoaWxkTm9kZXMgPSBlbC5jaGlsZE5vZGVzO1xuICAgICAgICAgICAgdmFyIHJlcyA9IG5ldyBBcnJheShjaGlsZE5vZGVzLmxlbmd0aCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICByZXNbaV0gPSBjaGlsZE5vZGVzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmNsZWFyTm9kZXMgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIHdoaWxlIChlbC5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICAgICAgZWwucmVtb3ZlQ2hpbGQoZWwuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5hcHBlbmRDaGlsZCA9IGZ1bmN0aW9uIChlbCwgbm9kZSkgeyBlbC5hcHBlbmRDaGlsZChub2RlKTsgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLnJlbW92ZUNoaWxkID0gZnVuY3Rpb24gKGVsLCBub2RlKSB7IGVsLnJlbW92ZUNoaWxkKG5vZGUpOyB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUucmVwbGFjZUNoaWxkID0gZnVuY3Rpb24gKGVsLCBuZXdDaGlsZCwgb2xkQ2hpbGQpIHsgZWwucmVwbGFjZUNoaWxkKG5ld0NoaWxkLCBvbGRDaGlsZCk7IH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgaWYgKG5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgIG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuaW5zZXJ0QmVmb3JlID0gZnVuY3Rpb24gKGVsLCBub2RlKSB7IGVsLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5vZGUsIGVsKTsgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmluc2VydEFsbEJlZm9yZSA9IGZ1bmN0aW9uIChlbCwgbm9kZXMpIHtcbiAgICAgICAgICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG4pIHsgcmV0dXJuIGVsLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG4sIGVsKTsgfSk7XG4gICAgICAgIH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5pbnNlcnRBZnRlciA9IGZ1bmN0aW9uIChlbCwgbm9kZSkgeyBlbC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShub2RlLCBlbC5uZXh0U2libGluZyk7IH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5zZXRJbm5lckhUTUwgPSBmdW5jdGlvbiAoZWwsIHZhbHVlKSB7IGVsLmlubmVySFRNTCA9IHZhbHVlOyB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuZ2V0VGV4dCA9IGZ1bmN0aW9uIChlbCkgeyByZXR1cm4gZWwudGV4dENvbnRlbnQ7IH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5zZXRUZXh0ID0gZnVuY3Rpb24gKGVsLCB2YWx1ZSkgeyBlbC50ZXh0Q29udGVudCA9IHZhbHVlOyB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuZ2V0VmFsdWUgPSBmdW5jdGlvbiAoZWwpIHsgcmV0dXJuIGVsLnZhbHVlOyB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuc2V0VmFsdWUgPSBmdW5jdGlvbiAoZWwsIHZhbHVlKSB7IGVsLnZhbHVlID0gdmFsdWU7IH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5nZXRDaGVja2VkID0gZnVuY3Rpb24gKGVsKSB7IHJldHVybiBlbC5jaGVja2VkOyB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuc2V0Q2hlY2tlZCA9IGZ1bmN0aW9uIChlbCwgdmFsdWUpIHsgZWwuY2hlY2tlZCA9IHZhbHVlOyB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuY3JlYXRlQ29tbWVudCA9IGZ1bmN0aW9uICh0ZXh0KSB7IHJldHVybiBkb2N1bWVudC5jcmVhdGVDb21tZW50KHRleHQpOyB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuY3JlYXRlVGVtcGxhdGUgPSBmdW5jdGlvbiAoaHRtbCkge1xuICAgICAgICAgICAgdmFyIHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScpO1xuICAgICAgICAgICAgdC5pbm5lckhUTUwgPSBodG1sO1xuICAgICAgICAgICAgcmV0dXJuIHQ7XG4gICAgICAgIH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5jcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24gKHRhZ05hbWUsIGRvYykge1xuICAgICAgICAgICAgaWYgKGRvYyA9PT0gdm9pZCAwKSB7IGRvYyA9IGRvY3VtZW50OyB9XG4gICAgICAgICAgICByZXR1cm4gZG9jLmNyZWF0ZUVsZW1lbnQodGFnTmFtZSk7XG4gICAgICAgIH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5jcmVhdGVFbGVtZW50TlMgPSBmdW5jdGlvbiAobnMsIHRhZ05hbWUsIGRvYykge1xuICAgICAgICAgICAgaWYgKGRvYyA9PT0gdm9pZCAwKSB7IGRvYyA9IGRvY3VtZW50OyB9XG4gICAgICAgICAgICByZXR1cm4gZG9jLmNyZWF0ZUVsZW1lbnROUyhucywgdGFnTmFtZSk7XG4gICAgICAgIH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5jcmVhdGVUZXh0Tm9kZSA9IGZ1bmN0aW9uICh0ZXh0LCBkb2MpIHtcbiAgICAgICAgICAgIGlmIChkb2MgPT09IHZvaWQgMCkgeyBkb2MgPSBkb2N1bWVudDsgfVxuICAgICAgICAgICAgcmV0dXJuIGRvYy5jcmVhdGVUZXh0Tm9kZSh0ZXh0KTtcbiAgICAgICAgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmNyZWF0ZVNjcmlwdFRhZyA9IGZ1bmN0aW9uIChhdHRyTmFtZSwgYXR0clZhbHVlLCBkb2MpIHtcbiAgICAgICAgICAgIGlmIChkb2MgPT09IHZvaWQgMCkgeyBkb2MgPSBkb2N1bWVudDsgfVxuICAgICAgICAgICAgdmFyIGVsID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ1NDUklQVCcpO1xuICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlKGF0dHJOYW1lLCBhdHRyVmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIGVsO1xuICAgICAgICB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuY3JlYXRlU3R5bGVFbGVtZW50ID0gZnVuY3Rpb24gKGNzcywgZG9jKSB7XG4gICAgICAgICAgICBpZiAoZG9jID09PSB2b2lkIDApIHsgZG9jID0gZG9jdW1lbnQ7IH1cbiAgICAgICAgICAgIHZhciBzdHlsZSA9IGRvYy5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgICAgICAgICAgdGhpcy5hcHBlbmRDaGlsZChzdHlsZSwgdGhpcy5jcmVhdGVUZXh0Tm9kZShjc3MpKTtcbiAgICAgICAgICAgIHJldHVybiBzdHlsZTtcbiAgICAgICAgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmNyZWF0ZVNoYWRvd1Jvb3QgPSBmdW5jdGlvbiAoZWwpIHsgcmV0dXJuIGVsLmNyZWF0ZVNoYWRvd1Jvb3QoKTsgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmdldFNoYWRvd1Jvb3QgPSBmdW5jdGlvbiAoZWwpIHsgcmV0dXJuIGVsLnNoYWRvd1Jvb3Q7IH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5nZXRIb3N0ID0gZnVuY3Rpb24gKGVsKSB7IHJldHVybiBlbC5ob3N0OyB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZS5jbG9uZU5vZGUodHJ1ZSk7IH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lID0gZnVuY3Rpb24gKGVsZW1lbnQsIG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUobmFtZSk7XG4gICAgICAgIH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5nZXRFbGVtZW50c0J5VGFnTmFtZSA9IGZ1bmN0aW9uIChlbGVtZW50LCBuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShuYW1lKTtcbiAgICAgICAgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmNsYXNzTGlzdCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7IHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChlbGVtZW50LmNsYXNzTGlzdCwgMCk7IH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5hZGRDbGFzcyA9IGZ1bmN0aW9uIChlbGVtZW50LCBjbGFzc05hbWUpIHsgZWxlbWVudC5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSk7IH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5yZW1vdmVDbGFzcyA9IGZ1bmN0aW9uIChlbGVtZW50LCBjbGFzc05hbWUpIHsgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSk7IH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5oYXNDbGFzcyA9IGZ1bmN0aW9uIChlbGVtZW50LCBjbGFzc05hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhjbGFzc05hbWUpO1xuICAgICAgICB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuc2V0U3R5bGUgPSBmdW5jdGlvbiAoZWxlbWVudCwgc3R5bGVOYW1lLCBzdHlsZVZhbHVlKSB7XG4gICAgICAgICAgICBlbGVtZW50LnN0eWxlW3N0eWxlTmFtZV0gPSBzdHlsZVZhbHVlO1xuICAgICAgICB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUucmVtb3ZlU3R5bGUgPSBmdW5jdGlvbiAoZWxlbWVudCwgc3R5bGVuYW1lKSB7XG4gICAgICAgICAgICAvLyBJRSByZXF1aXJlcyAnJyBpbnN0ZWFkIG9mIG51bGxcbiAgICAgICAgICAgIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyL2lzc3Vlcy83OTE2XG4gICAgICAgICAgICBlbGVtZW50LnN0eWxlW3N0eWxlbmFtZV0gPSAnJztcbiAgICAgICAgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmdldFN0eWxlID0gZnVuY3Rpb24gKGVsZW1lbnQsIHN0eWxlbmFtZSkgeyByZXR1cm4gZWxlbWVudC5zdHlsZVtzdHlsZW5hbWVdOyB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuaGFzU3R5bGUgPSBmdW5jdGlvbiAoZWxlbWVudCwgc3R5bGVOYW1lLCBzdHlsZVZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoc3R5bGVWYWx1ZSA9PT0gdm9pZCAwKSB7IHN0eWxlVmFsdWUgPSBudWxsOyB9XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLmdldFN0eWxlKGVsZW1lbnQsIHN0eWxlTmFtZSkgfHwgJyc7XG4gICAgICAgICAgICByZXR1cm4gc3R5bGVWYWx1ZSA/IHZhbHVlID09IHN0eWxlVmFsdWUgOiB2YWx1ZS5sZW5ndGggPiAwO1xuICAgICAgICB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUudGFnTmFtZSA9IGZ1bmN0aW9uIChlbGVtZW50KSB7IHJldHVybiBlbGVtZW50LnRhZ05hbWU7IH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5hdHRyaWJ1dGVNYXAgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICAgICAgdmFyIHJlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIHZhciBlbEF0dHJzID0gZWxlbWVudC5hdHRyaWJ1dGVzO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbEF0dHJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGF0dHJpYiA9IGVsQXR0cnNbaV07XG4gICAgICAgICAgICAgICAgcmVzLnNldChhdHRyaWIubmFtZSwgYXR0cmliLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5oYXNBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoZWxlbWVudCwgYXR0cmlidXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudC5oYXNBdHRyaWJ1dGUoYXR0cmlidXRlKTtcbiAgICAgICAgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmhhc0F0dHJpYnV0ZU5TID0gZnVuY3Rpb24gKGVsZW1lbnQsIG5zLCBhdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50Lmhhc0F0dHJpYnV0ZU5TKG5zLCBhdHRyaWJ1dGUpO1xuICAgICAgICB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuZ2V0QXR0cmlidXRlID0gZnVuY3Rpb24gKGVsZW1lbnQsIGF0dHJpYnV0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZSk7XG4gICAgICAgIH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5nZXRBdHRyaWJ1dGVOUyA9IGZ1bmN0aW9uIChlbGVtZW50LCBucywgbmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQuZ2V0QXR0cmlidXRlTlMobnMsIG5hbWUpO1xuICAgICAgICB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuc2V0QXR0cmlidXRlID0gZnVuY3Rpb24gKGVsZW1lbnQsIG5hbWUsIHZhbHVlKSB7IGVsZW1lbnQuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKTsgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLnNldEF0dHJpYnV0ZU5TID0gZnVuY3Rpb24gKGVsZW1lbnQsIG5zLCBuYW1lLCB2YWx1ZSkge1xuICAgICAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGVOUyhucywgbmFtZSwgdmFsdWUpO1xuICAgICAgICB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUucmVtb3ZlQXR0cmlidXRlID0gZnVuY3Rpb24gKGVsZW1lbnQsIGF0dHJpYnV0ZSkgeyBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShhdHRyaWJ1dGUpOyB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUucmVtb3ZlQXR0cmlidXRlTlMgPSBmdW5jdGlvbiAoZWxlbWVudCwgbnMsIG5hbWUpIHtcbiAgICAgICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlTlMobnMsIG5hbWUpO1xuICAgICAgICB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUudGVtcGxhdGVBd2FyZVJvb3QgPSBmdW5jdGlvbiAoZWwpIHsgcmV0dXJuIHRoaXMuaXNUZW1wbGF0ZUVsZW1lbnQoZWwpID8gdGhpcy5jb250ZW50KGVsKSA6IGVsOyB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuY3JlYXRlSHRtbERvY3VtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudCgnZmFrZVRpdGxlJyk7XG4gICAgICAgIH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5kZWZhdWx0RG9jID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZG9jdW1lbnQ7IH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB0b3A6IDAsIGJvdHRvbTogMCwgbGVmdDogMCwgcmlnaHQ6IDAsIHdpZHRoOiAwLCBoZWlnaHQ6IDAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmdldFRpdGxlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZG9jdW1lbnQudGl0bGU7IH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5zZXRUaXRsZSA9IGZ1bmN0aW9uIChuZXdUaXRsZSkgeyBkb2N1bWVudC50aXRsZSA9IG5ld1RpdGxlIHx8ICcnOyB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuZWxlbWVudE1hdGNoZXMgPSBmdW5jdGlvbiAobiwgc2VsZWN0b3IpIHtcbiAgICAgICAgICAgIGlmIChuIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbi5tYXRjaGVzICYmIG4ubWF0Y2hlcyhzZWxlY3RvcikgfHxcbiAgICAgICAgICAgICAgICAgICAgbi5tc01hdGNoZXNTZWxlY3RvciAmJiBuLm1zTWF0Y2hlc1NlbGVjdG9yKHNlbGVjdG9yKSB8fFxuICAgICAgICAgICAgICAgICAgICBuLndlYmtpdE1hdGNoZXNTZWxlY3RvciAmJiBuLndlYmtpdE1hdGNoZXNTZWxlY3RvcihzZWxlY3Rvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5pc1RlbXBsYXRlRWxlbWVudCA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgcmV0dXJuIGVsIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgJiYgZWwubm9kZU5hbWUgPT0gJ1RFTVBMQVRFJztcbiAgICAgICAgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmlzVGV4dE5vZGUgPSBmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREU7IH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5pc0NvbW1lbnROb2RlID0gZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGUubm9kZVR5cGUgPT09IE5vZGUuQ09NTUVOVF9OT0RFOyB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuaXNFbGVtZW50Tm9kZSA9IGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBub2RlLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERTsgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmhhc1NoYWRvd1Jvb3QgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIGlzUHJlc2VudChub2RlLnNoYWRvd1Jvb3QpICYmIG5vZGUgaW5zdGFuY2VvZiBIVE1MRWxlbWVudDtcbiAgICAgICAgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmlzU2hhZG93Um9vdCA9IGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBub2RlIGluc3RhbmNlb2YgRG9jdW1lbnRGcmFnbWVudDsgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmltcG9ydEludG9Eb2MgPSBmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gZG9jdW1lbnQuaW1wb3J0Tm9kZSh0aGlzLnRlbXBsYXRlQXdhcmVSb290KG5vZGUpLCB0cnVlKTsgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmFkb3B0Tm9kZSA9IGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBkb2N1bWVudC5hZG9wdE5vZGUobm9kZSk7IH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5nZXRIcmVmID0gZnVuY3Rpb24gKGVsKSB7IHJldHVybiBlbC5ocmVmOyB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuZ2V0RXZlbnRLZXkgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBldmVudC5rZXk7XG4gICAgICAgICAgICBpZiAoaXNCbGFuayhrZXkpKSB7XG4gICAgICAgICAgICAgICAga2V5ID0gZXZlbnQua2V5SWRlbnRpZmllcjtcbiAgICAgICAgICAgICAgICAvLyBrZXlJZGVudGlmaWVyIGlzIGRlZmluZWQgaW4gdGhlIG9sZCBkcmFmdCBvZiBET00gTGV2ZWwgMyBFdmVudHMgaW1wbGVtZW50ZWQgYnkgQ2hyb21lIGFuZFxuICAgICAgICAgICAgICAgIC8vIFNhZmFyaSBjZlxuICAgICAgICAgICAgICAgIC8vIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMDcvV0QtRE9NLUxldmVsLTMtRXZlbnRzLTIwMDcxMjIxL2V2ZW50cy5odG1sI0V2ZW50cy1LZXlib2FyZEV2ZW50cy1JbnRlcmZhY2VzXG4gICAgICAgICAgICAgICAgaWYgKGlzQmxhbmsoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1VuaWRlbnRpZmllZCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChrZXkuc3RhcnRzV2l0aCgnVSsnKSkge1xuICAgICAgICAgICAgICAgICAgICBrZXkgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KGtleS5zdWJzdHJpbmcoMiksIDE2KSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChldmVudC5sb2NhdGlvbiA9PT0gRE9NX0tFWV9MT0NBVElPTl9OVU1QQUQgJiYgX2Nocm9tZU51bUtleVBhZE1hcC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGVyZSBpcyBhIGJ1ZyBpbiBDaHJvbWUgZm9yIG51bWVyaWMga2V5cGFkIGtleXM6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MTU1NjU0XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAxLCAyLCAzIC4uLiBhcmUgcmVwb3J0ZWQgYXMgQSwgQiwgQyAuLi5cbiAgICAgICAgICAgICAgICAgICAgICAgIGtleSA9IF9jaHJvbWVOdW1LZXlQYWRNYXBba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBfa2V5TWFwW2tleV0gfHwga2V5O1xuICAgICAgICB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuZ2V0R2xvYmFsRXZlbnRUYXJnZXQgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICAgICAgICBpZiAodGFyZ2V0ID09PSAnd2luZG93Jykge1xuICAgICAgICAgICAgICAgIHJldHVybiB3aW5kb3c7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGFyZ2V0ID09PSAnZG9jdW1lbnQnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRhcmdldCA9PT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50LmJvZHk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5nZXRIaXN0b3J5ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gd2luZG93Lmhpc3Rvcnk7IH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5nZXRMb2NhdGlvbiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHdpbmRvdy5sb2NhdGlvbjsgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmdldEJhc2VIcmVmID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGhyZWYgPSBnZXRCYXNlRWxlbWVudEhyZWYoKTtcbiAgICAgICAgICAgIHJldHVybiBpc0JsYW5rKGhyZWYpID8gbnVsbCA6IHJlbGF0aXZlUGF0aChocmVmKTtcbiAgICAgICAgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLnJlc2V0QmFzZUVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7IGJhc2VFbGVtZW50ID0gbnVsbDsgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmdldFVzZXJBZ2VudCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50OyB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuc2V0RGF0YSA9IGZ1bmN0aW9uIChlbGVtZW50LCBuYW1lLCB2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoZWxlbWVudCwgJ2RhdGEtJyArIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmdldERhdGEgPSBmdW5jdGlvbiAoZWxlbWVudCwgbmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKGVsZW1lbnQsICdkYXRhLScgKyBuYW1lKTtcbiAgICAgICAgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmdldENvbXB1dGVkU3R5bGUgPSBmdW5jdGlvbiAoZWxlbWVudCkgeyByZXR1cm4gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTsgfTtcbiAgICAgICAgLy8gVE9ETyh0Ym9zY2gpOiBtb3ZlIHRoaXMgaW50byBhIHNlcGFyYXRlIGVudmlyb25tZW50IGNsYXNzIG9uY2Ugd2UgaGF2ZSBpdFxuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuc2V0R2xvYmFsVmFyID0gZnVuY3Rpb24gKHBhdGgsIHZhbHVlKSB7IHNldFZhbHVlT25QYXRoKGdsb2JhbCQxLCBwYXRoLCB2YWx1ZSk7IH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5zdXBwb3J0c1dlYkFuaW1hdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgRWxlbWVudC5wcm90b3R5cGVbJ2FuaW1hdGUnXSA9PT0gJ2Z1bmN0aW9uJztcbiAgICAgICAgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLnBlcmZvcm1hbmNlTm93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gcGVyZm9ybWFuY2Uubm93KCkgaXMgbm90IGF2YWlsYWJsZSBpbiBhbGwgYnJvd3NlcnMsIHNlZVxuICAgICAgICAgICAgLy8gaHR0cDovL2Nhbml1c2UuY29tLyNzZWFyY2g9cGVyZm9ybWFuY2Uubm93XG4gICAgICAgICAgICByZXR1cm4gd2luZG93LnBlcmZvcm1hbmNlICYmIHdpbmRvdy5wZXJmb3JtYW5jZS5ub3cgPyB3aW5kb3cucGVyZm9ybWFuY2Uubm93KCkgOlxuICAgICAgICAgICAgICAgIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuc3VwcG9ydHNDb29raWVzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJ1ZTsgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmdldENvb2tpZSA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBwYXJzZUNvb2tpZVZhbHVlKGRvY3VtZW50LmNvb2tpZSwgbmFtZSk7IH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5zZXRDb29raWUgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgICAgIC8vIGRvY3VtZW50LmNvb2tpZSBpcyBtYWdpY2FsLCBhc3NpZ25pbmcgaW50byBpdCBhc3NpZ25zL292ZXJyaWRlcyBvbmUgY29va2llIHZhbHVlLCBidXQgZG9lc1xuICAgICAgICAgICAgLy8gbm90IGNsZWFyIG90aGVyIGNvb2tpZXMuXG4gICAgICAgICAgICBkb2N1bWVudC5jb29raWUgPSBlbmNvZGVVUklDb21wb25lbnQobmFtZSkgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gQnJvd3NlckRvbUFkYXB0ZXI7XG4gICAgfShHZW5lcmljQnJvd3NlckRvbUFkYXB0ZXIpKTtcbiAgICB2YXIgYmFzZUVsZW1lbnQgPSBudWxsO1xuICAgIGZ1bmN0aW9uIGdldEJhc2VFbGVtZW50SHJlZigpIHtcbiAgICAgICAgaWYgKCFiYXNlRWxlbWVudCkge1xuICAgICAgICAgICAgYmFzZUVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdiYXNlJyk7XG4gICAgICAgICAgICBpZiAoIWJhc2VFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJhc2VFbGVtZW50LmdldEF0dHJpYnV0ZSgnaHJlZicpO1xuICAgIH1cbiAgICAvLyBiYXNlZCBvbiB1cmxVdGlscy5qcyBpbiBBbmd1bGFySlMgMVxuICAgIHZhciB1cmxQYXJzaW5nTm9kZTtcbiAgICBmdW5jdGlvbiByZWxhdGl2ZVBhdGgodXJsKSB7XG4gICAgICAgIGlmICghdXJsUGFyc2luZ05vZGUpIHtcbiAgICAgICAgICAgIHVybFBhcnNpbmdOb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgICAgICB9XG4gICAgICAgIHVybFBhcnNpbmdOb2RlLnNldEF0dHJpYnV0ZSgnaHJlZicsIHVybCk7XG4gICAgICAgIHJldHVybiAodXJsUGFyc2luZ05vZGUucGF0aG5hbWUuY2hhckF0KDApID09PSAnLycpID8gdXJsUGFyc2luZ05vZGUucGF0aG5hbWUgOlxuICAgICAgICAgICAgJy8nICsgdXJsUGFyc2luZ05vZGUucGF0aG5hbWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhcnNlQ29va2llVmFsdWUoY29va2llU3RyLCBuYW1lKSB7XG4gICAgICAgIG5hbWUgPSBlbmNvZGVVUklDb21wb25lbnQobmFtZSk7XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBjb29raWVTdHIuc3BsaXQoJzsnKTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBjb29raWUgPSBfYVtfaV07XG4gICAgICAgICAgICB2YXIgZXFJbmRleCA9IGNvb2tpZS5pbmRleE9mKCc9Jyk7XG4gICAgICAgICAgICB2YXIgX2IgPSBlcUluZGV4ID09IC0xID8gW2Nvb2tpZSwgJyddIDogW2Nvb2tpZS5zbGljZSgwLCBlcUluZGV4KSwgY29va2llLnNsaWNlKGVxSW5kZXggKyAxKV0sIGNvb2tpZU5hbWUgPSBfYlswXSwgY29va2llVmFsdWUgPSBfYlsxXTtcbiAgICAgICAgICAgIGlmIChjb29raWVOYW1lLnRyaW0oKSA9PT0gbmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoY29va2llVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdXBwb3J0c1N0YXRlKCkge1xuICAgICAgICByZXR1cm4gISF3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIHZhciBfX2V4dGVuZHMkMiA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIGBQbGF0Zm9ybUxvY2F0aW9uYCBlbmNhcHN1bGF0ZXMgYWxsIG9mIHRoZSBkaXJlY3QgY2FsbHMgdG8gcGxhdGZvcm0gQVBJcy5cbiAgICAgKiBUaGlzIGNsYXNzIHNob3VsZCBub3QgYmUgdXNlZCBkaXJlY3RseSBieSBhbiBhcHBsaWNhdGlvbiBkZXZlbG9wZXIuIEluc3RlYWQsIHVzZVxuICAgICAqIHtAbGluayBMb2NhdGlvbn0uXG4gICAgICovXG4gICAgdmFyIEJyb3dzZXJQbGF0Zm9ybUxvY2F0aW9uID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDIoQnJvd3NlclBsYXRmb3JtTG9jYXRpb24sIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIEJyb3dzZXJQbGF0Zm9ybUxvY2F0aW9uKCkge1xuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB0aGlzLl9pbml0KCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhpcyBpcyBtb3ZlZCB0byBpdHMgb3duIG1ldGhvZCBzbyB0aGF0IGBNb2NrUGxhdGZvcm1Mb2NhdGlvblN0cmF0ZWd5YCBjYW4gb3ZlcndyaXRlIGl0XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgQnJvd3NlclBsYXRmb3JtTG9jYXRpb24ucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fbG9jYXRpb24gPSBnZXRET00oKS5nZXRMb2NhdGlvbigpO1xuICAgICAgICAgICAgdGhpcy5faGlzdG9yeSA9IGdldERPTSgpLmdldEhpc3RvcnkoKTtcbiAgICAgICAgfTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJyb3dzZXJQbGF0Zm9ybUxvY2F0aW9uLnByb3RvdHlwZSwgXCJsb2NhdGlvblwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2xvY2F0aW9uOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgQnJvd3NlclBsYXRmb3JtTG9jYXRpb24ucHJvdG90eXBlLmdldEJhc2VIcmVmRnJvbURPTSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdldERPTSgpLmdldEJhc2VIcmVmKCk7IH07XG4gICAgICAgIEJyb3dzZXJQbGF0Zm9ybUxvY2F0aW9uLnByb3RvdHlwZS5vblBvcFN0YXRlID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICBnZXRET00oKS5nZXRHbG9iYWxFdmVudFRhcmdldCgnd2luZG93JykuYWRkRXZlbnRMaXN0ZW5lcigncG9wc3RhdGUnLCBmbiwgZmFsc2UpO1xuICAgICAgICB9O1xuICAgICAgICBCcm93c2VyUGxhdGZvcm1Mb2NhdGlvbi5wcm90b3R5cGUub25IYXNoQ2hhbmdlID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICBnZXRET00oKS5nZXRHbG9iYWxFdmVudFRhcmdldCgnd2luZG93JykuYWRkRXZlbnRMaXN0ZW5lcignaGFzaGNoYW5nZScsIGZuLCBmYWxzZSk7XG4gICAgICAgIH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCcm93c2VyUGxhdGZvcm1Mb2NhdGlvbi5wcm90b3R5cGUsIFwicGF0aG5hbWVcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9sb2NhdGlvbi5wYXRobmFtZTsgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKG5ld1BhdGgpIHsgdGhpcy5fbG9jYXRpb24ucGF0aG5hbWUgPSBuZXdQYXRoOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJyb3dzZXJQbGF0Zm9ybUxvY2F0aW9uLnByb3RvdHlwZSwgXCJzZWFyY2hcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9sb2NhdGlvbi5zZWFyY2g7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnJvd3NlclBsYXRmb3JtTG9jYXRpb24ucHJvdG90eXBlLCBcImhhc2hcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9sb2NhdGlvbi5oYXNoOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgQnJvd3NlclBsYXRmb3JtTG9jYXRpb24ucHJvdG90eXBlLnB1c2hTdGF0ZSA9IGZ1bmN0aW9uIChzdGF0ZSwgdGl0bGUsIHVybCkge1xuICAgICAgICAgICAgaWYgKHN1cHBvcnRzU3RhdGUoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2hpc3RvcnkucHVzaFN0YXRlKHN0YXRlLCB0aXRsZSwgdXJsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvY2F0aW9uLmhhc2ggPSB1cmw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIEJyb3dzZXJQbGF0Zm9ybUxvY2F0aW9uLnByb3RvdHlwZS5yZXBsYWNlU3RhdGUgPSBmdW5jdGlvbiAoc3RhdGUsIHRpdGxlLCB1cmwpIHtcbiAgICAgICAgICAgIGlmIChzdXBwb3J0c1N0YXRlKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9oaXN0b3J5LnJlcGxhY2VTdGF0ZShzdGF0ZSwgdGl0bGUsIHVybCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2NhdGlvbi5oYXNoID0gdXJsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBCcm93c2VyUGxhdGZvcm1Mb2NhdGlvbi5wcm90b3R5cGUuZm9yd2FyZCA9IGZ1bmN0aW9uICgpIHsgdGhpcy5faGlzdG9yeS5mb3J3YXJkKCk7IH07XG4gICAgICAgIEJyb3dzZXJQbGF0Zm9ybUxvY2F0aW9uLnByb3RvdHlwZS5iYWNrID0gZnVuY3Rpb24gKCkgeyB0aGlzLl9oaXN0b3J5LmJhY2soKTsgfTtcbiAgICAgICAgQnJvd3NlclBsYXRmb3JtTG9jYXRpb24uZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3RhYmxlIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBCcm93c2VyUGxhdGZvcm1Mb2NhdGlvbi5jdG9yUGFyYW1ldGVycyA9IFtdO1xuICAgICAgICByZXR1cm4gQnJvd3NlclBsYXRmb3JtTG9jYXRpb247XG4gICAgfShfYW5ndWxhcl9jb21tb24uUGxhdGZvcm1Mb2NhdGlvbikpO1xuXG4gICAgdmFyIEJyb3dzZXJHZXRUZXN0YWJpbGl0eSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEJyb3dzZXJHZXRUZXN0YWJpbGl0eSgpIHtcbiAgICAgICAgfVxuICAgICAgICBCcm93c2VyR2V0VGVzdGFiaWxpdHkuaW5pdCA9IGZ1bmN0aW9uICgpIHsgX2FuZ3VsYXJfY29yZS5zZXRUZXN0YWJpbGl0eUdldHRlcihuZXcgQnJvd3NlckdldFRlc3RhYmlsaXR5KCkpOyB9O1xuICAgICAgICBCcm93c2VyR2V0VGVzdGFiaWxpdHkucHJvdG90eXBlLmFkZFRvV2luZG93ID0gZnVuY3Rpb24gKHJlZ2lzdHJ5KSB7XG4gICAgICAgICAgICBnbG9iYWwkMS5nZXRBbmd1bGFyVGVzdGFiaWxpdHkgPSBmdW5jdGlvbiAoZWxlbSwgZmluZEluQW5jZXN0b3JzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZpbmRJbkFuY2VzdG9ycyA9PT0gdm9pZCAwKSB7IGZpbmRJbkFuY2VzdG9ycyA9IHRydWU7IH1cbiAgICAgICAgICAgICAgICB2YXIgdGVzdGFiaWxpdHkgPSByZWdpc3RyeS5maW5kVGVzdGFiaWxpdHlJblRyZWUoZWxlbSwgZmluZEluQW5jZXN0b3JzKTtcbiAgICAgICAgICAgICAgICBpZiAodGVzdGFiaWxpdHkgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBmaW5kIHRlc3RhYmlsaXR5IGZvciBlbGVtZW50LicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGVzdGFiaWxpdHk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZ2xvYmFsJDEuZ2V0QWxsQW5ndWxhclRlc3RhYmlsaXRpZXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiByZWdpc3RyeS5nZXRBbGxUZXN0YWJpbGl0aWVzKCk7IH07XG4gICAgICAgICAgICBnbG9iYWwkMS5nZXRBbGxBbmd1bGFyUm9vdEVsZW1lbnRzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVnaXN0cnkuZ2V0QWxsUm9vdEVsZW1lbnRzKCk7IH07XG4gICAgICAgICAgICB2YXIgd2hlbkFsbFN0YWJsZSA9IGZ1bmN0aW9uIChjYWxsYmFjayAvKiogVE9ETyAjOTEwMCAqLykge1xuICAgICAgICAgICAgICAgIHZhciB0ZXN0YWJpbGl0aWVzID0gZ2xvYmFsJDEuZ2V0QWxsQW5ndWxhclRlc3RhYmlsaXRpZXMoKTtcbiAgICAgICAgICAgICAgICB2YXIgY291bnQgPSB0ZXN0YWJpbGl0aWVzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB2YXIgZGlkV29yayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHZhciBkZWNyZW1lbnQgPSBmdW5jdGlvbiAoZGlkV29ya18gLyoqIFRPRE8gIzkxMDAgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgZGlkV29yayA9IGRpZFdvcmsgfHwgZGlkV29ya187XG4gICAgICAgICAgICAgICAgICAgIGNvdW50LS07XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb3VudCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhkaWRXb3JrKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdGVzdGFiaWxpdGllcy5mb3JFYWNoKGZ1bmN0aW9uICh0ZXN0YWJpbGl0eSAvKiogVE9ETyAjOTEwMCAqLykge1xuICAgICAgICAgICAgICAgICAgICB0ZXN0YWJpbGl0eS53aGVuU3RhYmxlKGRlY3JlbWVudCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKCFnbG9iYWwkMVsnZnJhbWV3b3JrU3RhYmlsaXplcnMnXSkge1xuICAgICAgICAgICAgICAgIGdsb2JhbCQxWydmcmFtZXdvcmtTdGFiaWxpemVycyddID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBnbG9iYWwkMVsnZnJhbWV3b3JrU3RhYmlsaXplcnMnXS5wdXNoKHdoZW5BbGxTdGFibGUpO1xuICAgICAgICB9O1xuICAgICAgICBCcm93c2VyR2V0VGVzdGFiaWxpdHkucHJvdG90eXBlLmZpbmRUZXN0YWJpbGl0eUluVHJlZSA9IGZ1bmN0aW9uIChyZWdpc3RyeSwgZWxlbSwgZmluZEluQW5jZXN0b3JzKSB7XG4gICAgICAgICAgICBpZiAoZWxlbSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdCA9IHJlZ2lzdHJ5LmdldFRlc3RhYmlsaXR5KGVsZW0pO1xuICAgICAgICAgICAgaWYgKGlzUHJlc2VudCh0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIWZpbmRJbkFuY2VzdG9ycykge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdldERPTSgpLmlzU2hhZG93Um9vdChlbGVtKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbmRUZXN0YWJpbGl0eUluVHJlZShyZWdpc3RyeSwgZ2V0RE9NKCkuZ2V0SG9zdChlbGVtKSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maW5kVGVzdGFiaWxpdHlJblRyZWUocmVnaXN0cnksIGdldERPTSgpLnBhcmVudEVsZW1lbnQoZWxlbSksIHRydWUpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gQnJvd3NlckdldFRlc3RhYmlsaXR5O1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBBIHNlcnZpY2UgdGhhdCBjYW4gYmUgdXNlZCB0byBnZXQgYW5kIHNldCB0aGUgdGl0bGUgb2YgYSBjdXJyZW50IEhUTUwgZG9jdW1lbnQuXG4gICAgICpcbiAgICAgKiBTaW5jZSBhbiBBbmd1bGFyIDIgYXBwbGljYXRpb24gY2FuJ3QgYmUgYm9vdHN0cmFwcGVkIG9uIHRoZSBlbnRpcmUgSFRNTCBkb2N1bWVudCAoYDxodG1sPmAgdGFnKVxuICAgICAqIGl0IGlzIG5vdCBwb3NzaWJsZSB0byBiaW5kIHRvIHRoZSBgdGV4dGAgcHJvcGVydHkgb2YgdGhlIGBIVE1MVGl0bGVFbGVtZW50YCBlbGVtZW50c1xuICAgICAqIChyZXByZXNlbnRpbmcgdGhlIGA8dGl0bGU+YCB0YWcpLiBJbnN0ZWFkLCB0aGlzIHNlcnZpY2UgY2FuIGJlIHVzZWQgdG8gc2V0IGFuZCBnZXQgdGhlIGN1cnJlbnRcbiAgICAgKiB0aXRsZSB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICB2YXIgVGl0bGUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBUaXRsZSgpIHtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSB0aXRsZSBvZiB0aGUgY3VycmVudCBIVE1MIGRvY3VtZW50LlxuICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgVGl0bGUucHJvdG90eXBlLmdldFRpdGxlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2V0RE9NKCkuZ2V0VGl0bGUoKTsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCB0aGUgdGl0bGUgb2YgdGhlIGN1cnJlbnQgSFRNTCBkb2N1bWVudC5cbiAgICAgICAgICogQHBhcmFtIG5ld1RpdGxlXG4gICAgICAgICAqL1xuICAgICAgICBUaXRsZS5wcm90b3R5cGUuc2V0VGl0bGUgPSBmdW5jdGlvbiAobmV3VGl0bGUpIHsgZ2V0RE9NKCkuc2V0VGl0bGUobmV3VGl0bGUpOyB9O1xuICAgICAgICByZXR1cm4gVGl0bGU7XG4gICAgfSgpKTtcblxuICAgIC8vIFNhZmFyaSBkb2Vzbid0IGltcGxlbWVudCBNYXBJdGVyYXRvci5uZXh0KCksIHdoaWNoIGlzIHVzZWQgaXMgVHJhY2V1cidzIHBvbHlmaWxsIG9mIEFycmF5LmZyb21cbiAgICAvLyBUT0RPKG1sYXZhbCk6IHJlbW92ZSB0aGUgd29yayBhcm91bmQgb25jZSB3ZSBoYXZlIGEgd29ya2luZyBwb2x5ZmlsbCBvZiBBcnJheS5mcm9tXG4gICAgdmFyIF9hcnJheUZyb21NYXAgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKChuZXcgTWFwKCkpLnZhbHVlcygpLm5leHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlQXJyYXlGcm9tTWFwKG0sIGdldFZhbHVlcykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0VmFsdWVzID8gQXJyYXkuZnJvbShtLnZhbHVlcygpKSA6IEFycmF5LmZyb20obS5rZXlzKCkpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlQXJyYXlGcm9tTWFwV2l0aEZvcmVhY2gobSwgZ2V0VmFsdWVzKSB7XG4gICAgICAgICAgICB2YXIgcmVzID0gbmV3IEFycmF5KG0uc2l6ZSksIGkgPSAwO1xuICAgICAgICAgICAgbS5mb3JFYWNoKGZ1bmN0aW9uICh2LCBrKSB7XG4gICAgICAgICAgICAgICAgcmVzW2ldID0gZ2V0VmFsdWVzID8gdiA6IGs7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9O1xuICAgIH0pKCk7XG4gICAgLyoqXG4gICAgICogV3JhcHMgSmF2YXNjcmlwdCBPYmplY3RzXG4gICAgICovXG4gICAgdmFyIFN0cmluZ01hcFdyYXBwZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBTdHJpbmdNYXBXcmFwcGVyKCkge1xuICAgICAgICB9XG4gICAgICAgIFN0cmluZ01hcFdyYXBwZXIubWVyZ2UgPSBmdW5jdGlvbiAobTEsIG0yKSB7XG4gICAgICAgICAgICB2YXIgbSA9IHt9O1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IE9iamVjdC5rZXlzKG0xKTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgayA9IF9hW19pXTtcbiAgICAgICAgICAgICAgICBtW2tdID0gbTFba107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBfYiA9IDAsIF9jID0gT2JqZWN0LmtleXMobTIpOyBfYiA8IF9jLmxlbmd0aDsgX2IrKykge1xuICAgICAgICAgICAgICAgIHZhciBrID0gX2NbX2JdO1xuICAgICAgICAgICAgICAgIG1ba10gPSBtMltrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtO1xuICAgICAgICB9O1xuICAgICAgICBTdHJpbmdNYXBXcmFwcGVyLmVxdWFscyA9IGZ1bmN0aW9uIChtMSwgbTIpIHtcbiAgICAgICAgICAgIHZhciBrMSA9IE9iamVjdC5rZXlzKG0xKTtcbiAgICAgICAgICAgIHZhciBrMiA9IE9iamVjdC5rZXlzKG0yKTtcbiAgICAgICAgICAgIGlmIChrMS5sZW5ndGggIT0gazIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrMS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBrMVtpXTtcbiAgICAgICAgICAgICAgICBpZiAobTFba2V5XSAhPT0gbTJba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBTdHJpbmdNYXBXcmFwcGVyO1xuICAgIH0oKSk7XG4gICAgdmFyIExpc3RXcmFwcGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gTGlzdFdyYXBwZXIoKSB7XG4gICAgICAgIH1cbiAgICAgICAgTGlzdFdyYXBwZXIucmVtb3ZlQWxsID0gZnVuY3Rpb24gKGxpc3QsIGl0ZW1zKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gbGlzdC5pbmRleE9mKGl0ZW1zW2ldKTtcbiAgICAgICAgICAgICAgICBsaXN0LnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIExpc3RXcmFwcGVyLnJlbW92ZSA9IGZ1bmN0aW9uIChsaXN0LCBlbCkge1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gbGlzdC5pbmRleE9mKGVsKTtcbiAgICAgICAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgbGlzdC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgICBMaXN0V3JhcHBlci5lcXVhbHMgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgaWYgKGEubGVuZ3RoICE9IGIubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGlmIChhW2ldICE9PSBiW2ldKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgTGlzdFdyYXBwZXIubWF4aW11bSA9IGZ1bmN0aW9uIChsaXN0LCBwcmVkaWNhdGUpIHtcbiAgICAgICAgICAgIGlmIChsaXN0Lmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc29sdXRpb24gPSBudWxsO1xuICAgICAgICAgICAgdmFyIG1heFZhbHVlID0gLUluZmluaXR5O1xuICAgICAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxpc3QubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IGxpc3RbaW5kZXhdO1xuICAgICAgICAgICAgICAgIGlmIChjYW5kaWRhdGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGNhbmRpZGF0ZVZhbHVlID0gcHJlZGljYXRlKGNhbmRpZGF0ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGNhbmRpZGF0ZVZhbHVlID4gbWF4VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgc29sdXRpb24gPSBjYW5kaWRhdGU7XG4gICAgICAgICAgICAgICAgICAgIG1heFZhbHVlID0gY2FuZGlkYXRlVmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNvbHV0aW9uO1xuICAgICAgICB9O1xuICAgICAgICBMaXN0V3JhcHBlci5mbGF0dGVuID0gZnVuY3Rpb24gKGxpc3QpIHtcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSBbXTtcbiAgICAgICAgICAgIF9mbGF0dGVuQXJyYXkobGlzdCwgdGFyZ2V0KTtcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBMaXN0V3JhcHBlcjtcbiAgICB9KCkpO1xuICAgIGZ1bmN0aW9uIF9mbGF0dGVuQXJyYXkoc291cmNlLCB0YXJnZXQpIHtcbiAgICAgICAgaWYgKGlzUHJlc2VudChzb3VyY2UpKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNvdXJjZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBpdGVtID0gc291cmNlW2ldO1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgICAgIF9mbGF0dGVuQXJyYXkoaXRlbSwgdGFyZ2V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgREkgVG9rZW4gcmVwcmVzZW50aW5nIHRoZSBtYWluIHJlbmRlcmluZyBjb250ZXh0LiBJbiBhIGJyb3dzZXIgdGhpcyBpcyB0aGUgRE9NIERvY3VtZW50LlxuICAgICAqXG4gICAgICogTm90ZTogRG9jdW1lbnQgbWlnaHQgbm90IGJlIGF2YWlsYWJsZSBpbiB0aGUgQXBwbGljYXRpb24gQ29udGV4dCB3aGVuIEFwcGxpY2F0aW9uIGFuZCBSZW5kZXJpbmdcbiAgICAgKiBDb250ZXh0cyBhcmUgbm90IHRoZSBzYW1lIChlLmcuIHdoZW4gcnVubmluZyB0aGUgYXBwbGljYXRpb24gaW50byBhIFdlYiBXb3JrZXIpLlxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBET0NVTUVOVCA9IG5ldyBfYW5ndWxhcl9jb3JlLk9wYXF1ZVRva2VuKCdEb2N1bWVudFRva2VuJyk7XG5cbiAgICAvKipcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIEVWRU5UX01BTkFHRVJfUExVR0lOUyA9IG5ldyBfYW5ndWxhcl9jb3JlLk9wYXF1ZVRva2VuKCdFdmVudE1hbmFnZXJQbHVnaW5zJyk7XG4gICAgLyoqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBFdmVudE1hbmFnZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBFdmVudE1hbmFnZXIocGx1Z2lucywgX3pvbmUpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLl96b25lID0gX3pvbmU7XG4gICAgICAgICAgICBwbHVnaW5zLmZvckVhY2goZnVuY3Rpb24gKHApIHsgcmV0dXJuIHAubWFuYWdlciA9IF90aGlzOyB9KTtcbiAgICAgICAgICAgIHRoaXMuX3BsdWdpbnMgPSBwbHVnaW5zLnNsaWNlKCkucmV2ZXJzZSgpO1xuICAgICAgICB9XG4gICAgICAgIEV2ZW50TWFuYWdlci5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIChlbGVtZW50LCBldmVudE5hbWUsIGhhbmRsZXIpIHtcbiAgICAgICAgICAgIHZhciBwbHVnaW4gPSB0aGlzLl9maW5kUGx1Z2luRm9yKGV2ZW50TmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gcGx1Z2luLmFkZEV2ZW50TGlzdGVuZXIoZWxlbWVudCwgZXZlbnROYW1lLCBoYW5kbGVyKTtcbiAgICAgICAgfTtcbiAgICAgICAgRXZlbnRNYW5hZ2VyLnByb3RvdHlwZS5hZGRHbG9iYWxFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKHRhcmdldCwgZXZlbnROYW1lLCBoYW5kbGVyKSB7XG4gICAgICAgICAgICB2YXIgcGx1Z2luID0gdGhpcy5fZmluZFBsdWdpbkZvcihldmVudE5hbWUpO1xuICAgICAgICAgICAgcmV0dXJuIHBsdWdpbi5hZGRHbG9iYWxFdmVudExpc3RlbmVyKHRhcmdldCwgZXZlbnROYW1lLCBoYW5kbGVyKTtcbiAgICAgICAgfTtcbiAgICAgICAgRXZlbnRNYW5hZ2VyLnByb3RvdHlwZS5nZXRab25lID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fem9uZTsgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBFdmVudE1hbmFnZXIucHJvdG90eXBlLl9maW5kUGx1Z2luRm9yID0gZnVuY3Rpb24gKGV2ZW50TmFtZSkge1xuICAgICAgICAgICAgdmFyIHBsdWdpbnMgPSB0aGlzLl9wbHVnaW5zO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwbHVnaW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBsdWdpbiA9IHBsdWdpbnNbaV07XG4gICAgICAgICAgICAgICAgaWYgKHBsdWdpbi5zdXBwb3J0cyhldmVudE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwbHVnaW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gZXZlbnQgbWFuYWdlciBwbHVnaW4gZm91bmQgZm9yIGV2ZW50IFwiICsgZXZlbnROYW1lKTtcbiAgICAgICAgfTtcbiAgICAgICAgRXZlbnRNYW5hZ2VyLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0YWJsZSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgRXZlbnRNYW5hZ2VyLmN0b3JQYXJhbWV0ZXJzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBBcnJheSwgZGVjb3JhdG9yczogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3QsIGFyZ3M6IFtFVkVOVF9NQU5BR0VSX1BMVUdJTlMsXSB9LF0gfSxcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5OZ1pvbmUsIH0sXG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiBFdmVudE1hbmFnZXI7XG4gICAgfSgpKTtcbiAgICB2YXIgRXZlbnRNYW5hZ2VyUGx1Z2luID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gRXZlbnRNYW5hZ2VyUGx1Z2luKCkge1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoYXQgaXMgZXF1aXZhbGVudCB0byBoYXZpbmcgc3VwcG9ydGluZyAkZXZlbnQudGFyZ2V0XG4gICAgICAgIEV2ZW50TWFuYWdlclBsdWdpbi5wcm90b3R5cGUuc3VwcG9ydHMgPSBmdW5jdGlvbiAoZXZlbnROYW1lKSB7IHJldHVybiBmYWxzZTsgfTtcbiAgICAgICAgRXZlbnRNYW5hZ2VyUGx1Z2luLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKGVsZW1lbnQsIGV2ZW50TmFtZSwgaGFuZGxlcikge1xuICAgICAgICAgICAgdGhyb3cgJ25vdCBpbXBsZW1lbnRlZCc7XG4gICAgICAgIH07XG4gICAgICAgIEV2ZW50TWFuYWdlclBsdWdpbi5wcm90b3R5cGUuYWRkR2xvYmFsRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIChlbGVtZW50LCBldmVudE5hbWUsIGhhbmRsZXIpIHtcbiAgICAgICAgICAgIHRocm93ICdub3QgaW1wbGVtZW50ZWQnO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gRXZlbnRNYW5hZ2VyUGx1Z2luO1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgdmFyIF9fZXh0ZW5kcyQ0ID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG4gICAgdmFyIFNoYXJlZFN0eWxlc0hvc3QgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBTaGFyZWRTdHlsZXNIb3N0KCkge1xuICAgICAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICAgICAgdGhpcy5fc3R5bGVzID0gW107XG4gICAgICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgICAgICB0aGlzLl9zdHlsZXNTZXQgPSBuZXcgU2V0KCk7XG4gICAgICAgIH1cbiAgICAgICAgU2hhcmVkU3R5bGVzSG9zdC5wcm90b3R5cGUuYWRkU3R5bGVzID0gZnVuY3Rpb24gKHN0eWxlcykge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHZhciBhZGRpdGlvbnMgPSBbXTtcbiAgICAgICAgICAgIHN0eWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChzdHlsZSkge1xuICAgICAgICAgICAgICAgIGlmICghX3RoaXMuX3N0eWxlc1NldC5oYXMoc3R5bGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9zdHlsZXNTZXQuYWRkKHN0eWxlKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3N0eWxlcy5wdXNoKHN0eWxlKTtcbiAgICAgICAgICAgICAgICAgICAgYWRkaXRpb25zLnB1c2goc3R5bGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5vblN0eWxlc0FkZGVkKGFkZGl0aW9ucyk7XG4gICAgICAgIH07XG4gICAgICAgIFNoYXJlZFN0eWxlc0hvc3QucHJvdG90eXBlLm9uU3R5bGVzQWRkZWQgPSBmdW5jdGlvbiAoYWRkaXRpb25zKSB7IH07XG4gICAgICAgIFNoYXJlZFN0eWxlc0hvc3QucHJvdG90eXBlLmdldEFsbFN0eWxlcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3N0eWxlczsgfTtcbiAgICAgICAgU2hhcmVkU3R5bGVzSG9zdC5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdGFibGUgfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIFNoYXJlZFN0eWxlc0hvc3QuY3RvclBhcmFtZXRlcnMgPSBbXTtcbiAgICAgICAgcmV0dXJuIFNoYXJlZFN0eWxlc0hvc3Q7XG4gICAgfSgpKTtcbiAgICB2YXIgRG9tU2hhcmVkU3R5bGVzSG9zdCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQ0KERvbVNoYXJlZFN0eWxlc0hvc3QsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIERvbVNoYXJlZFN0eWxlc0hvc3QoZG9jKSB7XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuX2hvc3ROb2RlcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgIHRoaXMuX2hvc3ROb2Rlcy5hZGQoZG9jLmhlYWQpO1xuICAgICAgICB9XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgRG9tU2hhcmVkU3R5bGVzSG9zdC5wcm90b3R5cGUuX2FkZFN0eWxlc1RvSG9zdCA9IGZ1bmN0aW9uIChzdHlsZXMsIGhvc3QpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0eWxlID0gc3R5bGVzW2ldO1xuICAgICAgICAgICAgICAgIGdldERPTSgpLmFwcGVuZENoaWxkKGhvc3QsIGdldERPTSgpLmNyZWF0ZVN0eWxlRWxlbWVudChzdHlsZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBEb21TaGFyZWRTdHlsZXNIb3N0LnByb3RvdHlwZS5hZGRIb3N0ID0gZnVuY3Rpb24gKGhvc3ROb2RlKSB7XG4gICAgICAgICAgICB0aGlzLl9hZGRTdHlsZXNUb0hvc3QodGhpcy5fc3R5bGVzLCBob3N0Tm9kZSk7XG4gICAgICAgICAgICB0aGlzLl9ob3N0Tm9kZXMuYWRkKGhvc3ROb2RlKTtcbiAgICAgICAgfTtcbiAgICAgICAgRG9tU2hhcmVkU3R5bGVzSG9zdC5wcm90b3R5cGUucmVtb3ZlSG9zdCA9IGZ1bmN0aW9uIChob3N0Tm9kZSkgeyB0aGlzLl9ob3N0Tm9kZXMuZGVsZXRlKGhvc3ROb2RlKTsgfTtcbiAgICAgICAgRG9tU2hhcmVkU3R5bGVzSG9zdC5wcm90b3R5cGUub25TdHlsZXNBZGRlZCA9IGZ1bmN0aW9uIChhZGRpdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLl9ob3N0Tm9kZXMuZm9yRWFjaChmdW5jdGlvbiAoaG9zdE5vZGUpIHsgX3RoaXMuX2FkZFN0eWxlc1RvSG9zdChhZGRpdGlvbnMsIGhvc3ROb2RlKTsgfSk7XG4gICAgICAgIH07XG4gICAgICAgIERvbVNoYXJlZFN0eWxlc0hvc3QuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3RhYmxlIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBEb21TaGFyZWRTdHlsZXNIb3N0LmN0b3JQYXJhbWV0ZXJzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0LCBhcmdzOiBbRE9DVU1FTlQsXSB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIERvbVNoYXJlZFN0eWxlc0hvc3Q7XG4gICAgfShTaGFyZWRTdHlsZXNIb3N0KSk7XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgdmFyIF9fZXh0ZW5kcyQzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG4gICAgdmFyIE5BTUVTUEFDRV9VUklTID0ge1xuICAgICAgICAneGxpbmsnOiAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycsXG4gICAgICAgICdzdmcnOiAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLFxuICAgICAgICAneGh0bWwnOiAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCdcbiAgICB9O1xuICAgIHZhciBURU1QTEFURV9DT01NRU5UX1RFWFQgPSAndGVtcGxhdGUgYmluZGluZ3M9e30nO1xuICAgIHZhciBURU1QTEFURV9CSU5ESU5HU19FWFAgPSAvXnRlbXBsYXRlIGJpbmRpbmdzPSguKikkLztcbiAgICB2YXIgRG9tUm9vdFJlbmRlcmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gRG9tUm9vdFJlbmRlcmVyKGRvY3VtZW50LCBldmVudE1hbmFnZXIsIHNoYXJlZFN0eWxlc0hvc3QsIGFuaW1hdGlvbkRyaXZlcikge1xuICAgICAgICAgICAgdGhpcy5kb2N1bWVudCA9IGRvY3VtZW50O1xuICAgICAgICAgICAgdGhpcy5ldmVudE1hbmFnZXIgPSBldmVudE1hbmFnZXI7XG4gICAgICAgICAgICB0aGlzLnNoYXJlZFN0eWxlc0hvc3QgPSBzaGFyZWRTdHlsZXNIb3N0O1xuICAgICAgICAgICAgdGhpcy5hbmltYXRpb25Ecml2ZXIgPSBhbmltYXRpb25Ecml2ZXI7XG4gICAgICAgICAgICB0aGlzLnJlZ2lzdGVyZWRDb21wb25lbnRzID0gbmV3IE1hcCgpO1xuICAgICAgICB9XG4gICAgICAgIERvbVJvb3RSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyQ29tcG9uZW50ID0gZnVuY3Rpb24gKGNvbXBvbmVudFByb3RvKSB7XG4gICAgICAgICAgICB2YXIgcmVuZGVyZXIgPSB0aGlzLnJlZ2lzdGVyZWRDb21wb25lbnRzLmdldChjb21wb25lbnRQcm90by5pZCk7XG4gICAgICAgICAgICBpZiAoIXJlbmRlcmVyKSB7XG4gICAgICAgICAgICAgICAgcmVuZGVyZXIgPSBuZXcgRG9tUmVuZGVyZXIodGhpcywgY29tcG9uZW50UHJvdG8sIHRoaXMuYW5pbWF0aW9uRHJpdmVyKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlZ2lzdGVyZWRDb21wb25lbnRzLnNldChjb21wb25lbnRQcm90by5pZCwgcmVuZGVyZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlbmRlcmVyO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gRG9tUm9vdFJlbmRlcmVyO1xuICAgIH0oKSk7XG4gICAgdmFyIERvbVJvb3RSZW5kZXJlcl8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMkMyhEb21Sb290UmVuZGVyZXJfLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBEb21Sb290UmVuZGVyZXJfKF9kb2N1bWVudCwgX2V2ZW50TWFuYWdlciwgc2hhcmVkU3R5bGVzSG9zdCwgYW5pbWF0aW9uRHJpdmVyKSB7XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBfZG9jdW1lbnQsIF9ldmVudE1hbmFnZXIsIHNoYXJlZFN0eWxlc0hvc3QsIGFuaW1hdGlvbkRyaXZlcik7XG4gICAgICAgIH1cbiAgICAgICAgRG9tUm9vdFJlbmRlcmVyXy5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdGFibGUgfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIERvbVJvb3RSZW5kZXJlcl8uY3RvclBhcmFtZXRlcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3QsIGFyZ3M6IFtET0NVTUVOVCxdIH0sXSB9LFxuICAgICAgICAgICAgeyB0eXBlOiBFdmVudE1hbmFnZXIsIH0sXG4gICAgICAgICAgICB7IHR5cGU6IERvbVNoYXJlZFN0eWxlc0hvc3QsIH0sXG4gICAgICAgICAgICB7IHR5cGU6IEFuaW1hdGlvbkRyaXZlciwgfSxcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIERvbVJvb3RSZW5kZXJlcl87XG4gICAgfShEb21Sb290UmVuZGVyZXIpKTtcbiAgICB2YXIgRG9tUmVuZGVyZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBEb21SZW5kZXJlcihfcm9vdFJlbmRlcmVyLCBjb21wb25lbnRQcm90bywgX2FuaW1hdGlvbkRyaXZlcikge1xuICAgICAgICAgICAgdGhpcy5fcm9vdFJlbmRlcmVyID0gX3Jvb3RSZW5kZXJlcjtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50UHJvdG8gPSBjb21wb25lbnRQcm90bztcbiAgICAgICAgICAgIHRoaXMuX2FuaW1hdGlvbkRyaXZlciA9IF9hbmltYXRpb25Ecml2ZXI7XG4gICAgICAgICAgICB0aGlzLl9zdHlsZXMgPSBfZmxhdHRlblN0eWxlcyhjb21wb25lbnRQcm90by5pZCwgY29tcG9uZW50UHJvdG8uc3R5bGVzLCBbXSk7XG4gICAgICAgICAgICBpZiAoY29tcG9uZW50UHJvdG8uZW5jYXBzdWxhdGlvbiAhPT0gX2FuZ3VsYXJfY29yZS5WaWV3RW5jYXBzdWxhdGlvbi5OYXRpdmUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yb290UmVuZGVyZXIuc2hhcmVkU3R5bGVzSG9zdC5hZGRTdHlsZXModGhpcy5fc3R5bGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbXBvbmVudFByb3RvLmVuY2Fwc3VsYXRpb24gPT09IF9hbmd1bGFyX2NvcmUuVmlld0VuY2Fwc3VsYXRpb24uRW11bGF0ZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb250ZW50QXR0ciA9IF9zaGltQ29udGVudEF0dHJpYnV0ZShjb21wb25lbnRQcm90by5pZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5faG9zdEF0dHIgPSBfc2hpbUhvc3RBdHRyaWJ1dGUoY29tcG9uZW50UHJvdG8uaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29udGVudEF0dHIgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuX2hvc3RBdHRyID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBEb21SZW5kZXJlci5wcm90b3R5cGUuc2VsZWN0Um9vdEVsZW1lbnQgPSBmdW5jdGlvbiAoc2VsZWN0b3JPck5vZGUsIGRlYnVnSW5mbykge1xuICAgICAgICAgICAgdmFyIGVsO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzZWxlY3Rvck9yTm9kZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBlbCA9IGdldERPTSgpLnF1ZXJ5U2VsZWN0b3IodGhpcy5fcm9vdFJlbmRlcmVyLmRvY3VtZW50LCBzZWxlY3Rvck9yTm9kZSk7XG4gICAgICAgICAgICAgICAgaWYgKGlzQmxhbmsoZWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBzZWxlY3RvciBcXFwiXCIgKyBzZWxlY3Rvck9yTm9kZSArIFwiXFxcIiBkaWQgbm90IG1hdGNoIGFueSBlbGVtZW50c1wiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbCA9IHNlbGVjdG9yT3JOb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ2V0RE9NKCkuY2xlYXJOb2RlcyhlbCk7XG4gICAgICAgICAgICByZXR1cm4gZWw7XG4gICAgICAgIH07XG4gICAgICAgIERvbVJlbmRlcmVyLnByb3RvdHlwZS5jcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24gKHBhcmVudCwgbmFtZSwgZGVidWdJbmZvKSB7XG4gICAgICAgICAgICB2YXIgbnNBbmROYW1lID0gc3BsaXROYW1lc3BhY2UobmFtZSk7XG4gICAgICAgICAgICB2YXIgZWwgPSBpc1ByZXNlbnQobnNBbmROYW1lWzBdKSA/XG4gICAgICAgICAgICAgICAgZ2V0RE9NKCkuY3JlYXRlRWxlbWVudE5TKE5BTUVTUEFDRV9VUklTW25zQW5kTmFtZVswXV0sIG5zQW5kTmFtZVsxXSkgOlxuICAgICAgICAgICAgICAgIGdldERPTSgpLmNyZWF0ZUVsZW1lbnQobnNBbmROYW1lWzFdKTtcbiAgICAgICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5fY29udGVudEF0dHIpKSB7XG4gICAgICAgICAgICAgICAgZ2V0RE9NKCkuc2V0QXR0cmlidXRlKGVsLCB0aGlzLl9jb250ZW50QXR0ciwgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzUHJlc2VudChwYXJlbnQpKSB7XG4gICAgICAgICAgICAgICAgZ2V0RE9NKCkuYXBwZW5kQ2hpbGQocGFyZW50LCBlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZWw7XG4gICAgICAgIH07XG4gICAgICAgIERvbVJlbmRlcmVyLnByb3RvdHlwZS5jcmVhdGVWaWV3Um9vdCA9IGZ1bmN0aW9uIChob3N0RWxlbWVudCkge1xuICAgICAgICAgICAgdmFyIG5vZGVzUGFyZW50O1xuICAgICAgICAgICAgaWYgKHRoaXMuY29tcG9uZW50UHJvdG8uZW5jYXBzdWxhdGlvbiA9PT0gX2FuZ3VsYXJfY29yZS5WaWV3RW5jYXBzdWxhdGlvbi5OYXRpdmUpIHtcbiAgICAgICAgICAgICAgICBub2Rlc1BhcmVudCA9IGdldERPTSgpLmNyZWF0ZVNoYWRvd1Jvb3QoaG9zdEVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Jvb3RSZW5kZXJlci5zaGFyZWRTdHlsZXNIb3N0LmFkZEhvc3Qobm9kZXNQYXJlbnQpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGdldERPTSgpLmFwcGVuZENoaWxkKG5vZGVzUGFyZW50LCBnZXRET00oKS5jcmVhdGVTdHlsZUVsZW1lbnQodGhpcy5fc3R5bGVzW2ldKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLl9ob3N0QXR0cikpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0RE9NKCkuc2V0QXR0cmlidXRlKGhvc3RFbGVtZW50LCB0aGlzLl9ob3N0QXR0ciwgJycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBub2Rlc1BhcmVudCA9IGhvc3RFbGVtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5vZGVzUGFyZW50O1xuICAgICAgICB9O1xuICAgICAgICBEb21SZW5kZXJlci5wcm90b3R5cGUuY3JlYXRlVGVtcGxhdGVBbmNob3IgPSBmdW5jdGlvbiAocGFyZW50RWxlbWVudCwgZGVidWdJbmZvKSB7XG4gICAgICAgICAgICB2YXIgY29tbWVudCA9IGdldERPTSgpLmNyZWF0ZUNvbW1lbnQoVEVNUExBVEVfQ09NTUVOVF9URVhUKTtcbiAgICAgICAgICAgIGlmIChpc1ByZXNlbnQocGFyZW50RWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICBnZXRET00oKS5hcHBlbmRDaGlsZChwYXJlbnRFbGVtZW50LCBjb21tZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb21tZW50O1xuICAgICAgICB9O1xuICAgICAgICBEb21SZW5kZXJlci5wcm90b3R5cGUuY3JlYXRlVGV4dCA9IGZ1bmN0aW9uIChwYXJlbnRFbGVtZW50LCB2YWx1ZSwgZGVidWdJbmZvKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IGdldERPTSgpLmNyZWF0ZVRleHROb2RlKHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChpc1ByZXNlbnQocGFyZW50RWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICBnZXRET00oKS5hcHBlbmRDaGlsZChwYXJlbnRFbGVtZW50LCBub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9O1xuICAgICAgICBEb21SZW5kZXJlci5wcm90b3R5cGUucHJvamVjdE5vZGVzID0gZnVuY3Rpb24gKHBhcmVudEVsZW1lbnQsIG5vZGVzKSB7XG4gICAgICAgICAgICBpZiAoaXNCbGFuayhwYXJlbnRFbGVtZW50KSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBhcHBlbmROb2RlcyhwYXJlbnRFbGVtZW50LCBub2Rlcyk7XG4gICAgICAgIH07XG4gICAgICAgIERvbVJlbmRlcmVyLnByb3RvdHlwZS5hdHRhY2hWaWV3QWZ0ZXIgPSBmdW5jdGlvbiAobm9kZSwgdmlld1Jvb3ROb2RlcykgeyBtb3ZlTm9kZXNBZnRlclNpYmxpbmcobm9kZSwgdmlld1Jvb3ROb2Rlcyk7IH07XG4gICAgICAgIERvbVJlbmRlcmVyLnByb3RvdHlwZS5kZXRhY2hWaWV3ID0gZnVuY3Rpb24gKHZpZXdSb290Tm9kZXMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmlld1Jvb3ROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGdldERPTSgpLnJlbW92ZSh2aWV3Um9vdE5vZGVzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgRG9tUmVuZGVyZXIucHJvdG90eXBlLmRlc3Ryb3lWaWV3ID0gZnVuY3Rpb24gKGhvc3RFbGVtZW50LCB2aWV3QWxsTm9kZXMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbXBvbmVudFByb3RvLmVuY2Fwc3VsYXRpb24gPT09IF9hbmd1bGFyX2NvcmUuVmlld0VuY2Fwc3VsYXRpb24uTmF0aXZlICYmIGlzUHJlc2VudChob3N0RWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yb290UmVuZGVyZXIuc2hhcmVkU3R5bGVzSG9zdC5yZW1vdmVIb3N0KGdldERPTSgpLmdldFNoYWRvd1Jvb3QoaG9zdEVsZW1lbnQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgRG9tUmVuZGVyZXIucHJvdG90eXBlLmxpc3RlbiA9IGZ1bmN0aW9uIChyZW5kZXJFbGVtZW50LCBuYW1lLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Jvb3RSZW5kZXJlci5ldmVudE1hbmFnZXIuYWRkRXZlbnRMaXN0ZW5lcihyZW5kZXJFbGVtZW50LCBuYW1lLCBkZWNvcmF0ZVByZXZlbnREZWZhdWx0KGNhbGxiYWNrKSk7XG4gICAgICAgIH07XG4gICAgICAgIERvbVJlbmRlcmVyLnByb3RvdHlwZS5saXN0ZW5HbG9iYWwgPSBmdW5jdGlvbiAodGFyZ2V0LCBuYW1lLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Jvb3RSZW5kZXJlci5ldmVudE1hbmFnZXIuYWRkR2xvYmFsRXZlbnRMaXN0ZW5lcih0YXJnZXQsIG5hbWUsIGRlY29yYXRlUHJldmVudERlZmF1bHQoY2FsbGJhY2spKTtcbiAgICAgICAgfTtcbiAgICAgICAgRG9tUmVuZGVyZXIucHJvdG90eXBlLnNldEVsZW1lbnRQcm9wZXJ0eSA9IGZ1bmN0aW9uIChyZW5kZXJFbGVtZW50LCBwcm9wZXJ0eU5hbWUsIHByb3BlcnR5VmFsdWUpIHtcbiAgICAgICAgICAgIGdldERPTSgpLnNldFByb3BlcnR5KHJlbmRlckVsZW1lbnQsIHByb3BlcnR5TmFtZSwgcHJvcGVydHlWYWx1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIERvbVJlbmRlcmVyLnByb3RvdHlwZS5zZXRFbGVtZW50QXR0cmlidXRlID0gZnVuY3Rpb24gKHJlbmRlckVsZW1lbnQsIGF0dHJpYnV0ZU5hbWUsIGF0dHJpYnV0ZVZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgYXR0ck5zO1xuICAgICAgICAgICAgdmFyIG5zQW5kTmFtZSA9IHNwbGl0TmFtZXNwYWNlKGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgICAgICAgaWYgKGlzUHJlc2VudChuc0FuZE5hbWVbMF0pKSB7XG4gICAgICAgICAgICAgICAgYXR0cmlidXRlTmFtZSA9IG5zQW5kTmFtZVswXSArICc6JyArIG5zQW5kTmFtZVsxXTtcbiAgICAgICAgICAgICAgICBhdHRyTnMgPSBOQU1FU1BBQ0VfVVJJU1tuc0FuZE5hbWVbMF1dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzUHJlc2VudChhdHRyaWJ1dGVWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNQcmVzZW50KGF0dHJOcykpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0RE9NKCkuc2V0QXR0cmlidXRlTlMocmVuZGVyRWxlbWVudCwgYXR0ck5zLCBhdHRyaWJ1dGVOYW1lLCBhdHRyaWJ1dGVWYWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBnZXRET00oKS5zZXRBdHRyaWJ1dGUocmVuZGVyRWxlbWVudCwgYXR0cmlidXRlTmFtZSwgYXR0cmlidXRlVmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChpc1ByZXNlbnQoYXR0ck5zKSkge1xuICAgICAgICAgICAgICAgICAgICBnZXRET00oKS5yZW1vdmVBdHRyaWJ1dGVOUyhyZW5kZXJFbGVtZW50LCBhdHRyTnMsIG5zQW5kTmFtZVsxXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBnZXRET00oKS5yZW1vdmVBdHRyaWJ1dGUocmVuZGVyRWxlbWVudCwgYXR0cmlidXRlTmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBEb21SZW5kZXJlci5wcm90b3R5cGUuc2V0QmluZGluZ0RlYnVnSW5mbyA9IGZ1bmN0aW9uIChyZW5kZXJFbGVtZW50LCBwcm9wZXJ0eU5hbWUsIHByb3BlcnR5VmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBkYXNoQ2FzZWRQcm9wZXJ0eU5hbWUgPSBjYW1lbENhc2VUb0Rhc2hDYXNlKHByb3BlcnR5TmFtZSk7XG4gICAgICAgICAgICBpZiAoZ2V0RE9NKCkuaXNDb21tZW50Tm9kZShyZW5kZXJFbGVtZW50KSkge1xuICAgICAgICAgICAgICAgIHZhciBleGlzdGluZ0JpbmRpbmdzID0gZ2V0RE9NKCkuZ2V0VGV4dChyZW5kZXJFbGVtZW50KS5yZXBsYWNlKC9cXG4vZywgJycpLm1hdGNoKFRFTVBMQVRFX0JJTkRJTkdTX0VYUCk7XG4gICAgICAgICAgICAgICAgdmFyIHBhcnNlZEJpbmRpbmdzID0gSlNPTi5wYXJzZShleGlzdGluZ0JpbmRpbmdzWzFdKTtcbiAgICAgICAgICAgICAgICBwYXJzZWRCaW5kaW5nc1tkYXNoQ2FzZWRQcm9wZXJ0eU5hbWVdID0gcHJvcGVydHlWYWx1ZTtcbiAgICAgICAgICAgICAgICBnZXRET00oKS5zZXRUZXh0KHJlbmRlckVsZW1lbnQsIFRFTVBMQVRFX0NPTU1FTlRfVEVYVC5yZXBsYWNlKCd7fScsIEpTT04uc3RyaW5naWZ5KHBhcnNlZEJpbmRpbmdzLCBudWxsLCAyKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRFbGVtZW50QXR0cmlidXRlKHJlbmRlckVsZW1lbnQsIHByb3BlcnR5TmFtZSwgcHJvcGVydHlWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIERvbVJlbmRlcmVyLnByb3RvdHlwZS5zZXRFbGVtZW50Q2xhc3MgPSBmdW5jdGlvbiAocmVuZGVyRWxlbWVudCwgY2xhc3NOYW1lLCBpc0FkZCkge1xuICAgICAgICAgICAgaWYgKGlzQWRkKSB7XG4gICAgICAgICAgICAgICAgZ2V0RE9NKCkuYWRkQ2xhc3MocmVuZGVyRWxlbWVudCwgY2xhc3NOYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGdldERPTSgpLnJlbW92ZUNsYXNzKHJlbmRlckVsZW1lbnQsIGNsYXNzTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIERvbVJlbmRlcmVyLnByb3RvdHlwZS5zZXRFbGVtZW50U3R5bGUgPSBmdW5jdGlvbiAocmVuZGVyRWxlbWVudCwgc3R5bGVOYW1lLCBzdHlsZVZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoaXNQcmVzZW50KHN0eWxlVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgZ2V0RE9NKCkuc2V0U3R5bGUocmVuZGVyRWxlbWVudCwgc3R5bGVOYW1lLCBzdHJpbmdpZnkoc3R5bGVWYWx1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZ2V0RE9NKCkucmVtb3ZlU3R5bGUocmVuZGVyRWxlbWVudCwgc3R5bGVOYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgRG9tUmVuZGVyZXIucHJvdG90eXBlLmludm9rZUVsZW1lbnRNZXRob2QgPSBmdW5jdGlvbiAocmVuZGVyRWxlbWVudCwgbWV0aG9kTmFtZSwgYXJncykge1xuICAgICAgICAgICAgZ2V0RE9NKCkuaW52b2tlKHJlbmRlckVsZW1lbnQsIG1ldGhvZE5hbWUsIGFyZ3MpO1xuICAgICAgICB9O1xuICAgICAgICBEb21SZW5kZXJlci5wcm90b3R5cGUuc2V0VGV4dCA9IGZ1bmN0aW9uIChyZW5kZXJOb2RlLCB0ZXh0KSB7IGdldERPTSgpLnNldFRleHQocmVuZGVyTm9kZSwgdGV4dCk7IH07XG4gICAgICAgIERvbVJlbmRlcmVyLnByb3RvdHlwZS5hbmltYXRlID0gZnVuY3Rpb24gKGVsZW1lbnQsIHN0YXJ0aW5nU3R5bGVzLCBrZXlmcmFtZXMsIGR1cmF0aW9uLCBkZWxheSwgZWFzaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYW5pbWF0aW9uRHJpdmVyLmFuaW1hdGUoZWxlbWVudCwgc3RhcnRpbmdTdHlsZXMsIGtleWZyYW1lcywgZHVyYXRpb24sIGRlbGF5LCBlYXNpbmcpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gRG9tUmVuZGVyZXI7XG4gICAgfSgpKTtcbiAgICBmdW5jdGlvbiBtb3ZlTm9kZXNBZnRlclNpYmxpbmcoc2libGluZyAvKiogVE9ETyAjOTEwMCAqLywgbm9kZXMgLyoqIFRPRE8gIzkxMDAgKi8pIHtcbiAgICAgICAgdmFyIHBhcmVudCA9IGdldERPTSgpLnBhcmVudEVsZW1lbnQoc2libGluZyk7XG4gICAgICAgIGlmIChub2Rlcy5sZW5ndGggPiAwICYmIGlzUHJlc2VudChwYXJlbnQpKSB7XG4gICAgICAgICAgICB2YXIgbmV4dFNpYmxpbmcgPSBnZXRET00oKS5uZXh0U2libGluZyhzaWJsaW5nKTtcbiAgICAgICAgICAgIGlmIChpc1ByZXNlbnQobmV4dFNpYmxpbmcpKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBnZXRET00oKS5pbnNlcnRCZWZvcmUobmV4dFNpYmxpbmcsIG5vZGVzW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGdldERPTSgpLmFwcGVuZENoaWxkKHBhcmVudCwgbm9kZXNbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBhcHBlbmROb2RlcyhwYXJlbnQgLyoqIFRPRE8gIzkxMDAgKi8sIG5vZGVzIC8qKiBUT0RPICM5MTAwICovKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGdldERPTSgpLmFwcGVuZENoaWxkKHBhcmVudCwgbm9kZXNbaV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlY29yYXRlUHJldmVudERlZmF1bHQoZXZlbnRIYW5kbGVyKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZXZlbnQgLyoqIFRPRE8gIzkxMDAgKi8pIHtcbiAgICAgICAgICAgIHZhciBhbGxvd0RlZmF1bHRCZWhhdmlvciA9IGV2ZW50SGFuZGxlcihldmVudCk7XG4gICAgICAgICAgICBpZiAoYWxsb3dEZWZhdWx0QmVoYXZpb3IgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETyh0Ym9zY2gpOiBtb3ZlIHByZXZlbnREZWZhdWx0IGludG8gZXZlbnQgcGx1Z2lucy4uLlxuICAgICAgICAgICAgICAgIGdldERPTSgpLnByZXZlbnREZWZhdWx0KGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgdmFyIENPTVBPTkVOVF9SRUdFWCA9IC8lQ09NUCUvZztcbiAgICB2YXIgQ09NUE9ORU5UX1ZBUklBQkxFID0gJyVDT01QJSc7XG4gICAgdmFyIEhPU1RfQVRUUiA9IFwiX25naG9zdC1cIiArIENPTVBPTkVOVF9WQVJJQUJMRTtcbiAgICB2YXIgQ09OVEVOVF9BVFRSID0gXCJfbmdjb250ZW50LVwiICsgQ09NUE9ORU5UX1ZBUklBQkxFO1xuICAgIGZ1bmN0aW9uIF9zaGltQ29udGVudEF0dHJpYnV0ZShjb21wb25lbnRTaG9ydElkKSB7XG4gICAgICAgIHJldHVybiBDT05URU5UX0FUVFIucmVwbGFjZShDT01QT05FTlRfUkVHRVgsIGNvbXBvbmVudFNob3J0SWQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBfc2hpbUhvc3RBdHRyaWJ1dGUoY29tcG9uZW50U2hvcnRJZCkge1xuICAgICAgICByZXR1cm4gSE9TVF9BVFRSLnJlcGxhY2UoQ09NUE9ORU5UX1JFR0VYLCBjb21wb25lbnRTaG9ydElkKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gX2ZsYXR0ZW5TdHlsZXMoY29tcElkLCBzdHlsZXMsIHRhcmdldCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHN0eWxlID0gc3R5bGVzW2ldO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc3R5bGUpKSB7XG4gICAgICAgICAgICAgICAgX2ZsYXR0ZW5TdHlsZXMoY29tcElkLCBzdHlsZSwgdGFyZ2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0eWxlID0gc3R5bGUucmVwbGFjZShDT01QT05FTlRfUkVHRVgsIGNvbXBJZCk7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LnB1c2goc3R5bGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuICAgIHZhciBOU19QUkVGSVhfUkUgPSAvXjooW146XSspOiguKykkLztcbiAgICBmdW5jdGlvbiBzcGxpdE5hbWVzcGFjZShuYW1lKSB7XG4gICAgICAgIGlmIChuYW1lWzBdICE9ICc6Jykge1xuICAgICAgICAgICAgcmV0dXJuIFtudWxsLCBuYW1lXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWF0Y2ggPSBuYW1lLm1hdGNoKE5TX1BSRUZJWF9SRSk7XG4gICAgICAgIHJldHVybiBbbWF0Y2hbMV0sIG1hdGNoWzJdXTtcbiAgICB9XG5cbiAgICB2YXIgQ09SRV9UT0tFTlMgPSB7XG4gICAgICAgICdBcHBsaWNhdGlvblJlZic6IF9hbmd1bGFyX2NvcmUuQXBwbGljYXRpb25SZWYsXG4gICAgICAgICdOZ1pvbmUnOiBfYW5ndWxhcl9jb3JlLk5nWm9uZVxuICAgIH07XG4gICAgdmFyIElOU1BFQ1RfR0xPQkFMX05BTUUgPSAnbmcucHJvYmUnO1xuICAgIHZhciBDT1JFX1RPS0VOU19HTE9CQUxfTkFNRSA9ICduZy5jb3JlVG9rZW5zJztcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEge0BsaW5rIERlYnVnRWxlbWVudH0gZm9yIHRoZSBnaXZlbiBuYXRpdmUgRE9NIGVsZW1lbnQsIG9yXG4gICAgICogbnVsbCBpZiB0aGUgZ2l2ZW4gbmF0aXZlIGVsZW1lbnQgZG9lcyBub3QgaGF2ZSBhbiBBbmd1bGFyIHZpZXcgYXNzb2NpYXRlZFxuICAgICAqIHdpdGggaXQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5zcGVjdE5hdGl2ZUVsZW1lbnQoZWxlbWVudCAvKiogVE9ETyAjOTEwMCAqLykge1xuICAgICAgICByZXR1cm4gX2FuZ3VsYXJfY29yZS5nZXREZWJ1Z05vZGUoZWxlbWVudCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICB2YXIgTmdQcm9iZVRva2VuID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gTmdQcm9iZVRva2VuKG5hbWUsIHRva2VuKSB7XG4gICAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICAgICAgdGhpcy50b2tlbiA9IHRva2VuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBOZ1Byb2JlVG9rZW47XG4gICAgfSgpKTtcbiAgICBmdW5jdGlvbiBfY3JlYXRlQ29uZGl0aW9uYWxSb290UmVuZGVyZXIocm9vdFJlbmRlcmVyIC8qKiBUT0RPICM5MTAwICovLCBleHRyYVRva2Vucykge1xuICAgICAgICBpZiAoX2FuZ3VsYXJfY29yZS5pc0Rldk1vZGUoKSkge1xuICAgICAgICAgICAgcmV0dXJuIF9jcmVhdGVSb290UmVuZGVyZXIocm9vdFJlbmRlcmVyLCBleHRyYVRva2Vucyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJvb3RSZW5kZXJlcjtcbiAgICB9XG4gICAgZnVuY3Rpb24gX2NyZWF0ZVJvb3RSZW5kZXJlcihyb290UmVuZGVyZXIgLyoqIFRPRE8gIzkxMDAgKi8sIGV4dHJhVG9rZW5zKSB7XG4gICAgICAgIGdldERPTSgpLnNldEdsb2JhbFZhcihJTlNQRUNUX0dMT0JBTF9OQU1FLCBpbnNwZWN0TmF0aXZlRWxlbWVudCk7XG4gICAgICAgIGdldERPTSgpLnNldEdsb2JhbFZhcihDT1JFX1RPS0VOU19HTE9CQUxfTkFNRSwgU3RyaW5nTWFwV3JhcHBlci5tZXJnZShDT1JFX1RPS0VOUywgX25nUHJvYmVUb2tlbnNUb01hcChleHRyYVRva2VucyB8fCBbXSkpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBEZWJ1Z0RvbVJvb3RSZW5kZXJlcihyb290UmVuZGVyZXIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBfbmdQcm9iZVRva2Vuc1RvTWFwKHRva2Vucykge1xuICAgICAgICByZXR1cm4gdG9rZW5zLnJlZHVjZShmdW5jdGlvbiAocHJldiwgdCkgeyByZXR1cm4gKHByZXZbdC5uYW1lXSA9IHQudG9rZW4sIHByZXYpOyB9LCB7fSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByb3ZpZGVycyB3aGljaCBzdXBwb3J0IGRlYnVnZ2luZyBBbmd1bGFyIGFwcGxpY2F0aW9ucyAoZS5nLiB2aWEgYG5nLnByb2JlYCkuXG4gICAgICovXG4gICAgdmFyIEVMRU1FTlRfUFJPQkVfUFJPVklERVJTID0gW3tcbiAgICAgICAgICAgIHByb3ZpZGU6IF9hbmd1bGFyX2NvcmUuUm9vdFJlbmRlcmVyLFxuICAgICAgICAgICAgdXNlRmFjdG9yeTogX2NyZWF0ZUNvbmRpdGlvbmFsUm9vdFJlbmRlcmVyLFxuICAgICAgICAgICAgZGVwczogW0RvbVJvb3RSZW5kZXJlciwgW05nUHJvYmVUb2tlbiwgbmV3IF9hbmd1bGFyX2NvcmUuT3B0aW9uYWwoKV1dXG4gICAgICAgIH1dO1xuICAgIHZhciBFTEVNRU5UX1BST0JFX1BST1ZJREVSU19QUk9EX01PREUgPSBbe1xuICAgICAgICAgICAgcHJvdmlkZTogX2FuZ3VsYXJfY29yZS5Sb290UmVuZGVyZXIsXG4gICAgICAgICAgICB1c2VGYWN0b3J5OiBfY3JlYXRlUm9vdFJlbmRlcmVyLFxuICAgICAgICAgICAgZGVwczogW0RvbVJvb3RSZW5kZXJlciwgW05nUHJvYmVUb2tlbiwgbmV3IF9hbmd1bGFyX2NvcmUuT3B0aW9uYWwoKV1dXG4gICAgICAgIH1dO1xuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIHZhciBfX2V4dGVuZHMkNSA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xuICAgIHZhciBEb21FdmVudHNQbHVnaW4gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMkNShEb21FdmVudHNQbHVnaW4sIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIERvbUV2ZW50c1BsdWdpbigpIHtcbiAgICAgICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoaXMgcGx1Z2luIHNob3VsZCBjb21lIGxhc3QgaW4gdGhlIGxpc3Qgb2YgcGx1Z2lucywgYmVjYXVzZSBpdCBhY2NlcHRzIGFsbFxuICAgICAgICAvLyBldmVudHMuXG4gICAgICAgIERvbUV2ZW50c1BsdWdpbi5wcm90b3R5cGUuc3VwcG9ydHMgPSBmdW5jdGlvbiAoZXZlbnROYW1lKSB7IHJldHVybiB0cnVlOyB9O1xuICAgICAgICBEb21FdmVudHNQbHVnaW4ucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAoZWxlbWVudCwgZXZlbnROYW1lLCBoYW5kbGVyKSB7XG4gICAgICAgICAgICB2YXIgem9uZSA9IHRoaXMubWFuYWdlci5nZXRab25lKCk7XG4gICAgICAgICAgICB2YXIgb3V0c2lkZUhhbmRsZXIgPSBmdW5jdGlvbiAoZXZlbnQgLyoqIFRPRE8gIzkxMDAgKi8pIHsgcmV0dXJuIHpvbmUucnVuR3VhcmRlZChmdW5jdGlvbiAoKSB7IHJldHVybiBoYW5kbGVyKGV2ZW50KTsgfSk7IH07XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYW5hZ2VyLmdldFpvbmUoKS5ydW5PdXRzaWRlQW5ndWxhcihmdW5jdGlvbiAoKSB7IHJldHVybiBnZXRET00oKS5vbkFuZENhbmNlbChlbGVtZW50LCBldmVudE5hbWUsIG91dHNpZGVIYW5kbGVyKTsgfSk7XG4gICAgICAgIH07XG4gICAgICAgIERvbUV2ZW50c1BsdWdpbi5wcm90b3R5cGUuYWRkR2xvYmFsRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uICh0YXJnZXQsIGV2ZW50TmFtZSwgaGFuZGxlcikge1xuICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBnZXRET00oKS5nZXRHbG9iYWxFdmVudFRhcmdldCh0YXJnZXQpO1xuICAgICAgICAgICAgdmFyIHpvbmUgPSB0aGlzLm1hbmFnZXIuZ2V0Wm9uZSgpO1xuICAgICAgICAgICAgdmFyIG91dHNpZGVIYW5kbGVyID0gZnVuY3Rpb24gKGV2ZW50IC8qKiBUT0RPICM5MTAwICovKSB7IHJldHVybiB6b25lLnJ1bkd1YXJkZWQoZnVuY3Rpb24gKCkgeyByZXR1cm4gaGFuZGxlcihldmVudCk7IH0pOyB9O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFuYWdlci5nZXRab25lKCkucnVuT3V0c2lkZUFuZ3VsYXIoZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2V0RE9NKCkub25BbmRDYW5jZWwoZWxlbWVudCwgZXZlbnROYW1lLCBvdXRzaWRlSGFuZGxlcik7IH0pO1xuICAgICAgICB9O1xuICAgICAgICBEb21FdmVudHNQbHVnaW4uZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3RhYmxlIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBEb21FdmVudHNQbHVnaW4uY3RvclBhcmFtZXRlcnMgPSBbXTtcbiAgICAgICAgcmV0dXJuIERvbUV2ZW50c1BsdWdpbjtcbiAgICB9KEV2ZW50TWFuYWdlclBsdWdpbikpO1xuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIHZhciBfX2V4dGVuZHMkNyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xuICAgIHZhciBfZXZlbnROYW1lcyA9IHtcbiAgICAgICAgLy8gcGFuXG4gICAgICAgICdwYW4nOiB0cnVlLFxuICAgICAgICAncGFuc3RhcnQnOiB0cnVlLFxuICAgICAgICAncGFubW92ZSc6IHRydWUsXG4gICAgICAgICdwYW5lbmQnOiB0cnVlLFxuICAgICAgICAncGFuY2FuY2VsJzogdHJ1ZSxcbiAgICAgICAgJ3BhbmxlZnQnOiB0cnVlLFxuICAgICAgICAncGFucmlnaHQnOiB0cnVlLFxuICAgICAgICAncGFudXAnOiB0cnVlLFxuICAgICAgICAncGFuZG93bic6IHRydWUsXG4gICAgICAgIC8vIHBpbmNoXG4gICAgICAgICdwaW5jaCc6IHRydWUsXG4gICAgICAgICdwaW5jaHN0YXJ0JzogdHJ1ZSxcbiAgICAgICAgJ3BpbmNobW92ZSc6IHRydWUsXG4gICAgICAgICdwaW5jaGVuZCc6IHRydWUsXG4gICAgICAgICdwaW5jaGNhbmNlbCc6IHRydWUsXG4gICAgICAgICdwaW5jaGluJzogdHJ1ZSxcbiAgICAgICAgJ3BpbmNob3V0JzogdHJ1ZSxcbiAgICAgICAgLy8gcHJlc3NcbiAgICAgICAgJ3ByZXNzJzogdHJ1ZSxcbiAgICAgICAgJ3ByZXNzdXAnOiB0cnVlLFxuICAgICAgICAvLyByb3RhdGVcbiAgICAgICAgJ3JvdGF0ZSc6IHRydWUsXG4gICAgICAgICdyb3RhdGVzdGFydCc6IHRydWUsXG4gICAgICAgICdyb3RhdGVtb3ZlJzogdHJ1ZSxcbiAgICAgICAgJ3JvdGF0ZWVuZCc6IHRydWUsXG4gICAgICAgICdyb3RhdGVjYW5jZWwnOiB0cnVlLFxuICAgICAgICAvLyBzd2lwZVxuICAgICAgICAnc3dpcGUnOiB0cnVlLFxuICAgICAgICAnc3dpcGVsZWZ0JzogdHJ1ZSxcbiAgICAgICAgJ3N3aXBlcmlnaHQnOiB0cnVlLFxuICAgICAgICAnc3dpcGV1cCc6IHRydWUsXG4gICAgICAgICdzd2lwZWRvd24nOiB0cnVlLFxuICAgICAgICAvLyB0YXBcbiAgICAgICAgJ3RhcCc6IHRydWUsXG4gICAgfTtcbiAgICB2YXIgSGFtbWVyR2VzdHVyZXNQbHVnaW5Db21tb24gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMkNyhIYW1tZXJHZXN0dXJlc1BsdWdpbkNvbW1vbiwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gSGFtbWVyR2VzdHVyZXNQbHVnaW5Db21tb24oKSB7XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBIYW1tZXJHZXN0dXJlc1BsdWdpbkNvbW1vbi5wcm90b3R5cGUuc3VwcG9ydHMgPSBmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gX2V2ZW50TmFtZXMuaGFzT3duUHJvcGVydHkoZXZlbnROYW1lLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gSGFtbWVyR2VzdHVyZXNQbHVnaW5Db21tb247XG4gICAgfShFdmVudE1hbmFnZXJQbHVnaW4pKTtcblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICB2YXIgX19leHRlbmRzJDYgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBIERJIHRva2VuIHRoYXQgeW91IGNhbiB1c2UgdG8gcHJvdmlkZXtAbGluayBIYW1tZXJHZXN0dXJlQ29uZmlnfSB0byBBbmd1bGFyLiBVc2UgaXQgdG8gY29uZmlndXJlXG4gICAgICogSGFtbWVyIGdlc3R1cmVzLlxuICAgICAqXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIHZhciBIQU1NRVJfR0VTVFVSRV9DT05GSUcgPSBuZXcgX2FuZ3VsYXJfY29yZS5PcGFxdWVUb2tlbignSGFtbWVyR2VzdHVyZUNvbmZpZycpO1xuICAgIC8qKlxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICB2YXIgSGFtbWVyR2VzdHVyZUNvbmZpZyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEhhbW1lckdlc3R1cmVDb25maWcoKSB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50cyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5vdmVycmlkZXMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBIYW1tZXJHZXN0dXJlQ29uZmlnLnByb3RvdHlwZS5idWlsZEhhbW1lciA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgICAgICB2YXIgbWMgPSBuZXcgSGFtbWVyKGVsZW1lbnQpO1xuICAgICAgICAgICAgbWMuZ2V0KCdwaW5jaCcpLnNldCh7IGVuYWJsZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgIG1jLmdldCgncm90YXRlJykuc2V0KHsgZW5hYmxlOiB0cnVlIH0pO1xuICAgICAgICAgICAgZm9yICh2YXIgZXZlbnROYW1lIGluIHRoaXMub3ZlcnJpZGVzKSB7XG4gICAgICAgICAgICAgICAgbWMuZ2V0KGV2ZW50TmFtZSkuc2V0KHRoaXMub3ZlcnJpZGVzW2V2ZW50TmFtZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1jO1xuICAgICAgICB9O1xuICAgICAgICBIYW1tZXJHZXN0dXJlQ29uZmlnLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0YWJsZSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgSGFtbWVyR2VzdHVyZUNvbmZpZy5jdG9yUGFyYW1ldGVycyA9IFtdO1xuICAgICAgICByZXR1cm4gSGFtbWVyR2VzdHVyZUNvbmZpZztcbiAgICB9KCkpO1xuICAgIHZhciBIYW1tZXJHZXN0dXJlc1BsdWdpbiA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQ2KEhhbW1lckdlc3R1cmVzUGx1Z2luLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBIYW1tZXJHZXN0dXJlc1BsdWdpbihfY29uZmlnKSB7XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuX2NvbmZpZyA9IF9jb25maWc7XG4gICAgICAgIH1cbiAgICAgICAgSGFtbWVyR2VzdHVyZXNQbHVnaW4ucHJvdG90eXBlLnN1cHBvcnRzID0gZnVuY3Rpb24gKGV2ZW50TmFtZSkge1xuICAgICAgICAgICAgaWYgKCFfc3VwZXIucHJvdG90eXBlLnN1cHBvcnRzLmNhbGwodGhpcywgZXZlbnROYW1lKSAmJiAhdGhpcy5pc0N1c3RvbUV2ZW50KGV2ZW50TmFtZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgaWYgKCFpc1ByZXNlbnQod2luZG93WydIYW1tZXInXSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJIYW1tZXIuanMgaXMgbm90IGxvYWRlZCwgY2FuIG5vdCBiaW5kIFwiICsgZXZlbnROYW1lICsgXCIgZXZlbnRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgSGFtbWVyR2VzdHVyZXNQbHVnaW4ucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAoZWxlbWVudCwgZXZlbnROYW1lLCBoYW5kbGVyKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIHpvbmUgPSB0aGlzLm1hbmFnZXIuZ2V0Wm9uZSgpO1xuICAgICAgICAgICAgZXZlbnROYW1lID0gZXZlbnROYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICByZXR1cm4gem9uZS5ydW5PdXRzaWRlQW5ndWxhcihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRpbmcgdGhlIG1hbmFnZXIgYmluZCBldmVudHMsIG11c3QgYmUgZG9uZSBvdXRzaWRlIG9mIGFuZ3VsYXJcbiAgICAgICAgICAgICAgICB2YXIgbWMgPSBfdGhpcy5fY29uZmlnLmJ1aWxkSGFtbWVyKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIHZhciBjYWxsYmFjayA9IGZ1bmN0aW9uIChldmVudE9iaiAvKiogVE9ETyAjPz8/PyAqLykge1xuICAgICAgICAgICAgICAgICAgICB6b25lLnJ1bkd1YXJkZWQoZnVuY3Rpb24gKCkgeyBoYW5kbGVyKGV2ZW50T2JqKTsgfSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBtYy5vbihldmVudE5hbWUsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyBtYy5vZmYoZXZlbnROYW1lLCBjYWxsYmFjayk7IH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgSGFtbWVyR2VzdHVyZXNQbHVnaW4ucHJvdG90eXBlLmlzQ3VzdG9tRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnROYW1lKSB7IHJldHVybiB0aGlzLl9jb25maWcuZXZlbnRzLmluZGV4T2YoZXZlbnROYW1lKSA+IC0xOyB9O1xuICAgICAgICBIYW1tZXJHZXN0dXJlc1BsdWdpbi5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdGFibGUgfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIEhhbW1lckdlc3R1cmVzUGx1Z2luLmN0b3JQYXJhbWV0ZXJzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBIYW1tZXJHZXN0dXJlQ29uZmlnLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdCwgYXJnczogW0hBTU1FUl9HRVNUVVJFX0NPTkZJRyxdIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gSGFtbWVyR2VzdHVyZXNQbHVnaW47XG4gICAgfShIYW1tZXJHZXN0dXJlc1BsdWdpbkNvbW1vbikpO1xuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIHZhciBfX2V4dGVuZHMkOCA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xuICAgIHZhciBtb2RpZmllcktleXMgPSBbJ2FsdCcsICdjb250cm9sJywgJ21ldGEnLCAnc2hpZnQnXTtcbiAgICB2YXIgbW9kaWZpZXJLZXlHZXR0ZXJzID0ge1xuICAgICAgICAnYWx0JzogZnVuY3Rpb24gKGV2ZW50KSB7IHJldHVybiBldmVudC5hbHRLZXk7IH0sXG4gICAgICAgICdjb250cm9sJzogZnVuY3Rpb24gKGV2ZW50KSB7IHJldHVybiBldmVudC5jdHJsS2V5OyB9LFxuICAgICAgICAnbWV0YSc6IGZ1bmN0aW9uIChldmVudCkgeyByZXR1cm4gZXZlbnQubWV0YUtleTsgfSxcbiAgICAgICAgJ3NoaWZ0JzogZnVuY3Rpb24gKGV2ZW50KSB7IHJldHVybiBldmVudC5zaGlmdEtleTsgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIHZhciBLZXlFdmVudHNQbHVnaW4gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMkOChLZXlFdmVudHNQbHVnaW4sIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIEtleUV2ZW50c1BsdWdpbigpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIEtleUV2ZW50c1BsdWdpbi5wcm90b3R5cGUuc3VwcG9ydHMgPSBmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNQcmVzZW50KEtleUV2ZW50c1BsdWdpbi5wYXJzZUV2ZW50TmFtZShldmVudE5hbWUpKTtcbiAgICAgICAgfTtcbiAgICAgICAgS2V5RXZlbnRzUGx1Z2luLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKGVsZW1lbnQsIGV2ZW50TmFtZSwgaGFuZGxlcikge1xuICAgICAgICAgICAgdmFyIHBhcnNlZEV2ZW50ID0gS2V5RXZlbnRzUGx1Z2luLnBhcnNlRXZlbnROYW1lKGV2ZW50TmFtZSk7XG4gICAgICAgICAgICB2YXIgb3V0c2lkZUhhbmRsZXIgPSBLZXlFdmVudHNQbHVnaW4uZXZlbnRDYWxsYmFjayhlbGVtZW50LCBwYXJzZWRFdmVudFsnZnVsbEtleSddLCBoYW5kbGVyLCB0aGlzLm1hbmFnZXIuZ2V0Wm9uZSgpKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1hbmFnZXIuZ2V0Wm9uZSgpLnJ1bk91dHNpZGVBbmd1bGFyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0RE9NKCkub25BbmRDYW5jZWwoZWxlbWVudCwgcGFyc2VkRXZlbnRbJ2RvbUV2ZW50TmFtZSddLCBvdXRzaWRlSGFuZGxlcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgS2V5RXZlbnRzUGx1Z2luLnBhcnNlRXZlbnROYW1lID0gZnVuY3Rpb24gKGV2ZW50TmFtZSkge1xuICAgICAgICAgICAgdmFyIHBhcnRzID0gZXZlbnROYW1lLnRvTG93ZXJDYXNlKCkuc3BsaXQoJy4nKTtcbiAgICAgICAgICAgIHZhciBkb21FdmVudE5hbWUgPSBwYXJ0cy5zaGlmdCgpO1xuICAgICAgICAgICAgaWYgKChwYXJ0cy5sZW5ndGggPT09IDApIHx8ICEoZG9tRXZlbnROYW1lID09PSAna2V5ZG93bicgfHwgZG9tRXZlbnROYW1lID09PSAna2V5dXAnKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGtleSA9IEtleUV2ZW50c1BsdWdpbi5fbm9ybWFsaXplS2V5KHBhcnRzLnBvcCgpKTtcbiAgICAgICAgICAgIHZhciBmdWxsS2V5ID0gJyc7XG4gICAgICAgICAgICBtb2RpZmllcktleXMuZm9yRWFjaChmdW5jdGlvbiAobW9kaWZpZXJOYW1lKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnRzLmluZGV4T2YobW9kaWZpZXJOYW1lKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIExpc3RXcmFwcGVyLnJlbW92ZShwYXJ0cywgbW9kaWZpZXJOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgZnVsbEtleSArPSBtb2RpZmllck5hbWUgKyAnLic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBmdWxsS2V5ICs9IGtleTtcbiAgICAgICAgICAgIGlmIChwYXJ0cy5sZW5ndGggIT0gMCB8fCBrZXkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gcmV0dXJuaW5nIG51bGwgaW5zdGVhZCBvZiB0aHJvd2luZyB0byBsZXQgYW5vdGhlciBwbHVnaW4gcHJvY2VzcyB0aGUgZXZlbnRcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgICAgIHJlc3VsdFsnZG9tRXZlbnROYW1lJ10gPSBkb21FdmVudE5hbWU7XG4gICAgICAgICAgICByZXN1bHRbJ2Z1bGxLZXknXSA9IGZ1bGxLZXk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgICAgICBLZXlFdmVudHNQbHVnaW4uZ2V0RXZlbnRGdWxsS2V5ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgZnVsbEtleSA9ICcnO1xuICAgICAgICAgICAgdmFyIGtleSA9IGdldERPTSgpLmdldEV2ZW50S2V5KGV2ZW50KTtcbiAgICAgICAgICAgIGtleSA9IGtleS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gJyAnKSB7XG4gICAgICAgICAgICAgICAga2V5ID0gJ3NwYWNlJzsgLy8gZm9yIHJlYWRhYmlsaXR5XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgPT09ICcuJykge1xuICAgICAgICAgICAgICAgIGtleSA9ICdkb3QnOyAvLyBiZWNhdXNlICcuJyBpcyB1c2VkIGFzIGEgc2VwYXJhdG9yIGluIGV2ZW50IG5hbWVzXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtb2RpZmllcktleXMuZm9yRWFjaChmdW5jdGlvbiAobW9kaWZpZXJOYW1lKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1vZGlmaWVyTmFtZSAhPSBrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1vZGlmaWVyR2V0dGVyID0gbW9kaWZpZXJLZXlHZXR0ZXJzW21vZGlmaWVyTmFtZV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb2RpZmllckdldHRlcihldmVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bGxLZXkgKz0gbW9kaWZpZXJOYW1lICsgJy4nO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBmdWxsS2V5ICs9IGtleTtcbiAgICAgICAgICAgIHJldHVybiBmdWxsS2V5O1xuICAgICAgICB9O1xuICAgICAgICBLZXlFdmVudHNQbHVnaW4uZXZlbnRDYWxsYmFjayA9IGZ1bmN0aW9uIChlbGVtZW50LCBmdWxsS2V5LCBoYW5kbGVyLCB6b25lKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGV2ZW50IC8qKiBUT0RPICM5MTAwICovKSB7XG4gICAgICAgICAgICAgICAgaWYgKEtleUV2ZW50c1BsdWdpbi5nZXRFdmVudEZ1bGxLZXkoZXZlbnQpID09PSBmdWxsS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIHpvbmUucnVuR3VhcmRlZChmdW5jdGlvbiAoKSB7IHJldHVybiBoYW5kbGVyKGV2ZW50KTsgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBLZXlFdmVudHNQbHVnaW4uX25vcm1hbGl6ZUtleSA9IGZ1bmN0aW9uIChrZXlOYW1lKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBzd2l0Y2ggdG8gYSBTdHJpbmdNYXAgaWYgdGhlIG1hcHBpbmcgZ3Jvd3MgdG9vIG11Y2hcbiAgICAgICAgICAgIHN3aXRjaCAoa2V5TmFtZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2VzYyc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnZXNjYXBlJztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ga2V5TmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgS2V5RXZlbnRzUGx1Z2luLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0YWJsZSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgS2V5RXZlbnRzUGx1Z2luLmN0b3JQYXJhbWV0ZXJzID0gW107XG4gICAgICAgIHJldHVybiBLZXlFdmVudHNQbHVnaW47XG4gICAgfShFdmVudE1hbmFnZXJQbHVnaW4pKTtcblxuICAgIC8qKlxuICAgICAqIEEgcGF0dGVybiB0aGF0IHJlY29nbml6ZXMgYSBjb21tb25seSB1c2VmdWwgc3Vic2V0IG9mIFVSTHMgdGhhdCBhcmUgc2FmZS5cbiAgICAgKlxuICAgICAqIFRoaXMgcmVndWxhciBleHByZXNzaW9uIG1hdGNoZXMgYSBzdWJzZXQgb2YgVVJMcyB0aGF0IHdpbGwgbm90IGNhdXNlIHNjcmlwdFxuICAgICAqIGV4ZWN1dGlvbiBpZiB1c2VkIGluIFVSTCBjb250ZXh0IHdpdGhpbiBhIEhUTUwgZG9jdW1lbnQuIFNwZWNpZmljYWxseSwgdGhpc1xuICAgICAqIHJlZ3VsYXIgZXhwcmVzc2lvbiBtYXRjaGVzIGlmIChjb21tZW50IGZyb20gaGVyZSBvbiBhbmQgcmVnZXggY29waWVkIGZyb21cbiAgICAgKiBTb3kncyBFc2NhcGluZ0NvbnZlbnRpb25zKTpcbiAgICAgKiAoMSkgRWl0aGVyIGEgcHJvdG9jb2wgaW4gYSB3aGl0ZWxpc3QgKGh0dHAsIGh0dHBzLCBtYWlsdG8gb3IgZnRwKS5cbiAgICAgKiAoMikgb3Igbm8gcHJvdG9jb2wuICBBIHByb3RvY29sIG11c3QgYmUgZm9sbG93ZWQgYnkgYSBjb2xvbi4gVGhlIGJlbG93XG4gICAgICogICAgIGFsbG93cyB0aGF0IGJ5IGFsbG93aW5nIGNvbG9ucyBvbmx5IGFmdGVyIG9uZSBvZiB0aGUgY2hhcmFjdGVycyBbLz8jXS5cbiAgICAgKiAgICAgQSBjb2xvbiBhZnRlciBhIGhhc2ggKCMpIG11c3QgYmUgaW4gdGhlIGZyYWdtZW50LlxuICAgICAqICAgICBPdGhlcndpc2UsIGEgY29sb24gYWZ0ZXIgYSAoPykgbXVzdCBiZSBpbiBhIHF1ZXJ5LlxuICAgICAqICAgICBPdGhlcndpc2UsIGEgY29sb24gYWZ0ZXIgYSBzaW5nbGUgc29saWR1cyAoLykgbXVzdCBiZSBpbiBhIHBhdGguXG4gICAgICogICAgIE90aGVyd2lzZSwgYSBjb2xvbiBhZnRlciBhIGRvdWJsZSBzb2xpZHVzICgvLykgbXVzdCBiZSBpbiB0aGUgYXV0aG9yaXR5XG4gICAgICogICAgIChiZWZvcmUgcG9ydCkuXG4gICAgICpcbiAgICAgKiBUaGUgcGF0dGVybiBkaXNhbGxvd3MgJiwgdXNlZCBpbiBIVE1MIGVudGl0eSBkZWNsYXJhdGlvbnMgYmVmb3JlXG4gICAgICogb25lIG9mIHRoZSBjaGFyYWN0ZXJzIGluIFsvPyNdLiBUaGlzIGRpc2FsbG93cyBIVE1MIGVudGl0aWVzIHVzZWQgaW4gdGhlXG4gICAgICogcHJvdG9jb2wgbmFtZSwgd2hpY2ggc2hvdWxkIG5ldmVyIGhhcHBlbiwgZS5nLiBcImgmIzExNjt0cFwiIGZvciBcImh0dHBcIi5cbiAgICAgKiBJdCBhbHNvIGRpc2FsbG93cyBIVE1MIGVudGl0aWVzIGluIHRoZSBmaXJzdCBwYXRoIHBhcnQgb2YgYSByZWxhdGl2ZSBwYXRoLFxuICAgICAqIGUuZy4gXCJmb28mbHQ7YmFyL2JhelwiLiAgT3VyIGV4aXN0aW5nIGVzY2FwaW5nIGZ1bmN0aW9ucyBzaG91bGQgbm90IHByb2R1Y2VcbiAgICAgKiB0aGF0LiBNb3JlIGltcG9ydGFudGx5LCBpdCBkaXNhbGxvd3MgbWFza2luZyBvZiBhIGNvbG9uLFxuICAgICAqIGUuZy4gXCJqYXZhc2NyaXB0JiM1ODsuLi5cIi5cbiAgICAgKlxuICAgICAqIFRoaXMgcmVndWxhciBleHByZXNzaW9uIHdhcyB0YWtlbiBmcm9tIHRoZSBDbG9zdXJlIHNhbml0aXphdGlvbiBsaWJyYXJ5LlxuICAgICAqL1xuICAgIHZhciBTQUZFX1VSTF9QQVRURVJOID0gL14oPzooPzpodHRwcz98bWFpbHRvfGZ0cHx0ZWx8ZmlsZSk6fFteJjovPyNdKig/OlsvPyNdfCQpKS9naTtcbiAgICAvKiogQSBwYXR0ZXJuIHRoYXQgbWF0Y2hlcyBzYWZlIGRhdGEgVVJMcy4gT25seSBtYXRjaGVzIGltYWdlLCB2aWRlbyBhbmQgYXVkaW8gdHlwZXMuICovXG4gICAgdmFyIERBVEFfVVJMX1BBVFRFUk4gPSAvXmRhdGE6KD86aW1hZ2VcXC8oPzpibXB8Z2lmfGpwZWd8anBnfHBuZ3x0aWZmfHdlYnApfHZpZGVvXFwvKD86bXBlZ3xtcDR8b2dnfHdlYm0pfGF1ZGlvXFwvKD86bXAzfG9nYXxvZ2d8b3B1cykpO2Jhc2U2NCxbYS16MC05K1xcL10rPSokL2k7XG4gICAgZnVuY3Rpb24gc2FuaXRpemVVcmwodXJsKSB7XG4gICAgICAgIHVybCA9IFN0cmluZyh1cmwpO1xuICAgICAgICBpZiAodXJsLm1hdGNoKFNBRkVfVVJMX1BBVFRFUk4pIHx8IHVybC5tYXRjaChEQVRBX1VSTF9QQVRURVJOKSlcbiAgICAgICAgICAgIHJldHVybiB1cmw7XG4gICAgICAgIGlmIChfYW5ndWxhcl9jb3JlLmlzRGV2TW9kZSgpKSB7XG4gICAgICAgICAgICBnZXRET00oKS5sb2coXCJXQVJOSU5HOiBzYW5pdGl6aW5nIHVuc2FmZSBVUkwgdmFsdWUgXCIgKyB1cmwgKyBcIiAoc2VlIGh0dHA6Ly9nLmNvL25nL3NlY3VyaXR5I3hzcylcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICd1bnNhZmU6JyArIHVybDtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2FuaXRpemVTcmNzZXQoc3Jjc2V0KSB7XG4gICAgICAgIHNyY3NldCA9IFN0cmluZyhzcmNzZXQpO1xuICAgICAgICByZXR1cm4gc3Jjc2V0LnNwbGl0KCcsJykubWFwKGZ1bmN0aW9uIChzcmNzZXQpIHsgcmV0dXJuIHNhbml0aXplVXJsKHNyY3NldC50cmltKCkpOyB9KS5qb2luKCcsICcpO1xuICAgIH1cblxuICAgIC8qKiBBIDxib2R5PiBlbGVtZW50IHRoYXQgY2FuIGJlIHNhZmVseSB1c2VkIHRvIHBhcnNlIHVudHJ1c3RlZCBIVE1MLiBMYXppbHkgaW5pdGlhbGl6ZWQgYmVsb3cuICovXG4gICAgdmFyIGluZXJ0RWxlbWVudCA9IG51bGw7XG4gICAgLyoqIExhemlseSBpbml0aWFsaXplZCB0byBtYWtlIHN1cmUgdGhlIERPTSBhZGFwdGVyIGdldHMgc2V0IGJlZm9yZSB1c2UuICovXG4gICAgdmFyIERPTSA9IG51bGw7XG4gICAgLyoqIFJldHVybnMgYW4gSFRNTCBlbGVtZW50IHRoYXQgaXMgZ3VhcmFudGVlZCB0byBub3QgZXhlY3V0ZSBjb2RlIHdoZW4gY3JlYXRpbmcgZWxlbWVudHMgaW4gaXQuICovXG4gICAgZnVuY3Rpb24gZ2V0SW5lcnRFbGVtZW50KCkge1xuICAgICAgICBpZiAoaW5lcnRFbGVtZW50KVxuICAgICAgICAgICAgcmV0dXJuIGluZXJ0RWxlbWVudDtcbiAgICAgICAgRE9NID0gZ2V0RE9NKCk7XG4gICAgICAgIC8vIFByZWZlciB1c2luZyA8dGVtcGxhdGU+IGVsZW1lbnQgaWYgc3VwcG9ydGVkLlxuICAgICAgICB2YXIgdGVtcGxhdGVFbCA9IERPTS5jcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScpO1xuICAgICAgICBpZiAoJ2NvbnRlbnQnIGluIHRlbXBsYXRlRWwpXG4gICAgICAgICAgICByZXR1cm4gdGVtcGxhdGVFbDtcbiAgICAgICAgdmFyIGRvYyA9IERPTS5jcmVhdGVIdG1sRG9jdW1lbnQoKTtcbiAgICAgICAgaW5lcnRFbGVtZW50ID0gRE9NLnF1ZXJ5U2VsZWN0b3IoZG9jLCAnYm9keScpO1xuICAgICAgICBpZiAoaW5lcnRFbGVtZW50ID09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIHVzdWFsbHkgdGhlcmUgc2hvdWxkIGJlIG9ubHkgb25lIGJvZHkgZWxlbWVudCBpbiB0aGUgZG9jdW1lbnQsIGJ1dCBJRSBkb2Vzbid0IGhhdmUgYW55LCBzbyB3ZVxuICAgICAgICAgICAgLy8gbmVlZCB0byBjcmVhdGUgb25lLlxuICAgICAgICAgICAgdmFyIGh0bWwgPSBET00uY3JlYXRlRWxlbWVudCgnaHRtbCcsIGRvYyk7XG4gICAgICAgICAgICBpbmVydEVsZW1lbnQgPSBET00uY3JlYXRlRWxlbWVudCgnYm9keScsIGRvYyk7XG4gICAgICAgICAgICBET00uYXBwZW5kQ2hpbGQoaHRtbCwgaW5lcnRFbGVtZW50KTtcbiAgICAgICAgICAgIERPTS5hcHBlbmRDaGlsZChkb2MsIGh0bWwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbmVydEVsZW1lbnQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRhZ1NldCh0YWdzKSB7XG4gICAgICAgIHZhciByZXMgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRhZ3Muc3BsaXQoJywnKTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciB0ID0gX2FbX2ldO1xuICAgICAgICAgICAgcmVzW3RdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtZXJnZSgpIHtcbiAgICAgICAgdmFyIHNldHMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHNldHNbX2kgLSAwXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlcyA9IHt9O1xuICAgICAgICBmb3IgKHZhciBfYSA9IDAsIHNldHNfMSA9IHNldHM7IF9hIDwgc2V0c18xLmxlbmd0aDsgX2ErKykge1xuICAgICAgICAgICAgdmFyIHMgPSBzZXRzXzFbX2FdO1xuICAgICAgICAgICAgZm9yICh2YXIgdiBpbiBzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHMuaGFzT3duUHJvcGVydHkodikpXG4gICAgICAgICAgICAgICAgICAgIHJlc1t2XSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgLy8gR29vZCBzb3VyY2Ugb2YgaW5mbyBhYm91dCBlbGVtZW50cyBhbmQgYXR0cmlidXRlc1xuICAgIC8vIGh0dHA6Ly9kZXYudzMub3JnL2h0bWw1L3NwZWMvT3ZlcnZpZXcuaHRtbCNzZW1hbnRpY3NcbiAgICAvLyBodHRwOi8vc2ltb24uaHRtbDUub3JnL2h0bWwtZWxlbWVudHNcbiAgICAvLyBTYWZlIFZvaWQgRWxlbWVudHMgLSBIVE1MNVxuICAgIC8vIGh0dHA6Ly9kZXYudzMub3JnL2h0bWw1L3NwZWMvT3ZlcnZpZXcuaHRtbCN2b2lkLWVsZW1lbnRzXG4gICAgdmFyIFZPSURfRUxFTUVOVFMgPSB0YWdTZXQoJ2FyZWEsYnIsY29sLGhyLGltZyx3YnInKTtcbiAgICAvLyBFbGVtZW50cyB0aGF0IHlvdSBjYW4sIGludGVudGlvbmFsbHksIGxlYXZlIG9wZW4gKGFuZCB3aGljaCBjbG9zZSB0aGVtc2VsdmVzKVxuICAgIC8vIGh0dHA6Ly9kZXYudzMub3JnL2h0bWw1L3NwZWMvT3ZlcnZpZXcuaHRtbCNvcHRpb25hbC10YWdzXG4gICAgdmFyIE9QVElPTkFMX0VORF9UQUdfQkxPQ0tfRUxFTUVOVFMgPSB0YWdTZXQoJ2NvbGdyb3VwLGRkLGR0LGxpLHAsdGJvZHksdGQsdGZvb3QsdGgsdGhlYWQsdHInKTtcbiAgICB2YXIgT1BUSU9OQUxfRU5EX1RBR19JTkxJTkVfRUxFTUVOVFMgPSB0YWdTZXQoJ3JwLHJ0Jyk7XG4gICAgdmFyIE9QVElPTkFMX0VORF9UQUdfRUxFTUVOVFMgPSBtZXJnZShPUFRJT05BTF9FTkRfVEFHX0lOTElORV9FTEVNRU5UUywgT1BUSU9OQUxfRU5EX1RBR19CTE9DS19FTEVNRU5UUyk7XG4gICAgLy8gU2FmZSBCbG9jayBFbGVtZW50cyAtIEhUTUw1XG4gICAgdmFyIEJMT0NLX0VMRU1FTlRTID0gbWVyZ2UoT1BUSU9OQUxfRU5EX1RBR19CTE9DS19FTEVNRU5UUywgdGFnU2V0KCdhZGRyZXNzLGFydGljbGUsJyArXG4gICAgICAgICdhc2lkZSxibG9ja3F1b3RlLGNhcHRpb24sY2VudGVyLGRlbCxkZXRhaWxzLGRpYWxvZyxkaXIsZGl2LGRsLGZpZ3VyZSxmaWdjYXB0aW9uLGZvb3RlcixoMSxoMixoMyxoNCxoNSwnICtcbiAgICAgICAgJ2g2LGhlYWRlcixoZ3JvdXAsaHIsaW5zLG1haW4sbWFwLG1lbnUsbmF2LG9sLHByZSxzZWN0aW9uLHN1bW1hcnksdGFibGUsdWwnKSk7XG4gICAgLy8gSW5saW5lIEVsZW1lbnRzIC0gSFRNTDVcbiAgICB2YXIgSU5MSU5FX0VMRU1FTlRTID0gbWVyZ2UoT1BUSU9OQUxfRU5EX1RBR19JTkxJTkVfRUxFTUVOVFMsIHRhZ1NldCgnYSxhYmJyLGFjcm9ueW0sYXVkaW8sYiwnICtcbiAgICAgICAgJ2JkaSxiZG8sYmlnLGJyLGNpdGUsY29kZSxkZWwsZGZuLGVtLGZvbnQsaSxpbWcsaW5zLGtiZCxsYWJlbCxtYXAsbWFyayxwaWN0dXJlLHEscnVieSxycCxydCxzLCcgK1xuICAgICAgICAnc2FtcCxzbWFsbCxzb3VyY2Usc3BhbixzdHJpa2Usc3Ryb25nLHN1YixzdXAsdGltZSx0cmFjayx0dCx1LHZhcix2aWRlbycpKTtcbiAgICB2YXIgVkFMSURfRUxFTUVOVFMgPSBtZXJnZShWT0lEX0VMRU1FTlRTLCBCTE9DS19FTEVNRU5UUywgSU5MSU5FX0VMRU1FTlRTLCBPUFRJT05BTF9FTkRfVEFHX0VMRU1FTlRTKTtcbiAgICAvLyBBdHRyaWJ1dGVzIHRoYXQgaGF2ZSBocmVmIGFuZCBoZW5jZSBuZWVkIHRvIGJlIHNhbml0aXplZFxuICAgIHZhciBVUklfQVRUUlMgPSB0YWdTZXQoJ2JhY2tncm91bmQsY2l0ZSxocmVmLGl0ZW10eXBlLGxvbmdkZXNjLHBvc3RlcixzcmMseGxpbms6aHJlZicpO1xuICAgIC8vIEF0dHJpYnV0ZXMgdGhhdCBoYXZlIHNwZWNpYWwgaHJlZiBzZXQgaGVuY2UgbmVlZCB0byBiZSBzYW5pdGl6ZWRcbiAgICB2YXIgU1JDU0VUX0FUVFJTID0gdGFnU2V0KCdzcmNzZXQnKTtcbiAgICB2YXIgSFRNTF9BVFRSUyA9IHRhZ1NldCgnYWJicixhY2Nlc3NrZXksYWxpZ24sYWx0LGF1dG9wbGF5LGF4aXMsYmdjb2xvcixib3JkZXIsY2VsbHBhZGRpbmcsY2VsbHNwYWNpbmcsY2xhc3MsY2xlYXIsY29sb3IsY29scyxjb2xzcGFuLCcgK1xuICAgICAgICAnY29tcGFjdCxjb250cm9scyxjb29yZHMsZGF0ZXRpbWUsZGVmYXVsdCxkaXIsZG93bmxvYWQsZmFjZSxoZWFkZXJzLGhlaWdodCxoaWRkZW4saHJlZmxhbmcsaHNwYWNlLCcgK1xuICAgICAgICAnaXNtYXAsaXRlbXNjb3BlLGl0ZW1wcm9wLGtpbmQsbGFiZWwsbGFuZyxsYW5ndWFnZSxsb29wLG1lZGlhLG11dGVkLG5vaHJlZixub3dyYXAsb3BlbixwcmVsb2FkLHJlbCxyZXYscm9sZSxyb3dzLHJvd3NwYW4scnVsZXMsJyArXG4gICAgICAgICdzY29wZSxzY3JvbGxpbmcsc2hhcGUsc2l6ZSxzaXplcyxzcGFuLHNyY2xhbmcsc3RhcnQsc3VtbWFyeSx0YWJpbmRleCx0YXJnZXQsdGl0bGUsdHJhbnNsYXRlLHR5cGUsdXNlbWFwLCcgK1xuICAgICAgICAndmFsaWduLHZhbHVlLHZzcGFjZSx3aWR0aCcpO1xuICAgIC8vIE5COiBUaGlzIGN1cnJlbnRseSBjb25jaW91c2x5IGRvZXNuJ3Qgc3VwcG9ydCBTVkcuIFNWRyBzYW5pdGl6YXRpb24gaGFzIGhhZCBzZXZlcmFsIHNlY3VyaXR5XG4gICAgLy8gaXNzdWVzIGluIHRoZSBwYXN0LCBzbyBpdCBzZWVtcyBzYWZlciB0byBsZWF2ZSBpdCBvdXQgaWYgcG9zc2libGUuIElmIHN1cHBvcnQgZm9yIGJpbmRpbmcgU1ZHIHZpYVxuICAgIC8vIGlubmVySFRNTCBpcyByZXF1aXJlZCwgU1ZHIGF0dHJpYnV0ZXMgc2hvdWxkIGJlIGFkZGVkIGhlcmUuXG4gICAgLy8gTkI6IFNhbml0aXphdGlvbiBkb2VzIG5vdCBhbGxvdyA8Zm9ybT4gZWxlbWVudHMgb3Igb3RoZXIgYWN0aXZlIGVsZW1lbnRzICg8YnV0dG9uPiBldGMpLiBUaG9zZVxuICAgIC8vIGNhbiBiZSBzYW5pdGl6ZWQsIGJ1dCB0aGV5IGluY3JlYXNlIHNlY3VyaXR5IHN1cmZhY2UgYXJlYSB3aXRob3V0IGEgbGVnaXRpbWF0ZSB1c2UgY2FzZSwgc28gdGhleVxuICAgIC8vIGFyZSBsZWZ0IG91dCBoZXJlLlxuICAgIHZhciBWQUxJRF9BVFRSUyA9IG1lcmdlKFVSSV9BVFRSUywgU1JDU0VUX0FUVFJTLCBIVE1MX0FUVFJTKTtcbiAgICAvKipcbiAgICAgKiBTYW5pdGl6aW5nSHRtbFNlcmlhbGl6ZXIgc2VyaWFsaXplcyBhIERPTSBmcmFnbWVudCwgc3RyaXBwaW5nIG91dCBhbnkgdW5zYWZlIGVsZW1lbnRzIGFuZCB1bnNhZmVcbiAgICAgKiBhdHRyaWJ1dGVzLlxuICAgICAqL1xuICAgIHZhciBTYW5pdGl6aW5nSHRtbFNlcmlhbGl6ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBTYW5pdGl6aW5nSHRtbFNlcmlhbGl6ZXIoKSB7XG4gICAgICAgICAgICAvLyBFeHBsaWNpdGx5IHRyYWNrIGlmIHNvbWV0aGluZyB3YXMgc3RyaXBwZWQsIHRvIGF2b2lkIGFjY2lkZW50YWxseSB3YXJuaW5nIG9mIHNhbml0aXphdGlvbiBqdXN0XG4gICAgICAgICAgICAvLyBiZWNhdXNlIGNoYXJhY3RlcnMgd2VyZSByZS1lbmNvZGVkLlxuICAgICAgICAgICAgdGhpcy5zYW5pdGl6ZWRTb21ldGhpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuYnVmID0gW107XG4gICAgICAgIH1cbiAgICAgICAgU2FuaXRpemluZ0h0bWxTZXJpYWxpemVyLnByb3RvdHlwZS5zYW5pdGl6ZUNoaWxkcmVuID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAvLyBUaGlzIGNhbm5vdCB1c2UgYSBUcmVlV2Fsa2VyLCBhcyBpdCBoYXMgdG8gcnVuIG9uIEFuZ3VsYXIncyB2YXJpb3VzIERPTSBhZGFwdGVycy5cbiAgICAgICAgICAgIC8vIEhvd2V2ZXIgdGhpcyBjb2RlIG5ldmVyIGFjY2Vzc2VzIHByb3BlcnRpZXMgb2ZmIG9mIGBkb2N1bWVudGAgYmVmb3JlIGRlbGV0aW5nIGl0cyBjb250ZW50c1xuICAgICAgICAgICAgLy8gYWdhaW4sIHNvIGl0IHNob3VsZG4ndCBiZSB2dWxuZXJhYmxlIHRvIERPTSBjbG9iYmVyaW5nLlxuICAgICAgICAgICAgdmFyIGN1cnJlbnQgPSBlbC5maXJzdENoaWxkO1xuICAgICAgICAgICAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoRE9NLmlzRWxlbWVudE5vZGUoY3VycmVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFydEVsZW1lbnQoY3VycmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKERPTS5pc1RleHROb2RlKGN1cnJlbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hhcnMoRE9NLm5vZGVWYWx1ZShjdXJyZW50KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBTdHJpcCBub24tZWxlbWVudCwgbm9uLXRleHQgbm9kZXMuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2FuaXRpemVkU29tZXRoaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKERPTS5maXJzdENoaWxkKGN1cnJlbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBET00uZmlyc3RDaGlsZChjdXJyZW50KTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdoaWxlIChjdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIExlYXZpbmcgdGhlIGVsZW1lbnQuIFdhbGsgdXAgYW5kIHRvIHRoZSByaWdodCwgY2xvc2luZyB0YWdzIGFzIHdlIGdvLlxuICAgICAgICAgICAgICAgICAgICBpZiAoRE9NLmlzRWxlbWVudE5vZGUoY3VycmVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW5kRWxlbWVudChjdXJyZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoRE9NLm5leHRTaWJsaW5nKGN1cnJlbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gRE9NLm5leHRTaWJsaW5nKGN1cnJlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IERPTS5wYXJlbnRFbGVtZW50KGN1cnJlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJ1Zi5qb2luKCcnKTtcbiAgICAgICAgfTtcbiAgICAgICAgU2FuaXRpemluZ0h0bWxTZXJpYWxpemVyLnByb3RvdHlwZS5zdGFydEVsZW1lbnQgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHZhciB0YWdOYW1lID0gRE9NLm5vZGVOYW1lKGVsZW1lbnQpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBpZiAoIVZBTElEX0VMRU1FTlRTLmhhc093blByb3BlcnR5KHRhZ05hbWUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zYW5pdGl6ZWRTb21ldGhpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYnVmLnB1c2goJzwnKTtcbiAgICAgICAgICAgIHRoaXMuYnVmLnB1c2godGFnTmFtZSk7XG4gICAgICAgICAgICBET00uYXR0cmlidXRlTWFwKGVsZW1lbnQpLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBhdHRyTmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciBsb3dlciA9IGF0dHJOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgaWYgKCFWQUxJRF9BVFRSUy5oYXNPd25Qcm9wZXJ0eShsb3dlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2FuaXRpemVkU29tZXRoaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBUT0RPKG1hcnRpbnByb2JzdCk6IFNwZWNpYWwgY2FzZSBpbWFnZSBVUklzIGZvciBkYXRhOmltYWdlLy4uLlxuICAgICAgICAgICAgICAgIGlmIChVUklfQVRUUlNbbG93ZXJdKVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHNhbml0aXplVXJsKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAoU1JDU0VUX0FUVFJTW2xvd2VyXSlcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBzYW5pdGl6ZVNyY3NldCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgX3RoaXMuYnVmLnB1c2goJyAnKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5idWYucHVzaChhdHRyTmFtZSk7XG4gICAgICAgICAgICAgICAgX3RoaXMuYnVmLnB1c2goJz1cIicpO1xuICAgICAgICAgICAgICAgIF90aGlzLmJ1Zi5wdXNoKGVuY29kZUVudGl0aWVzKHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgX3RoaXMuYnVmLnB1c2goJ1wiJyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuYnVmLnB1c2goJz4nKTtcbiAgICAgICAgfTtcbiAgICAgICAgU2FuaXRpemluZ0h0bWxTZXJpYWxpemVyLnByb3RvdHlwZS5lbmRFbGVtZW50ID0gZnVuY3Rpb24gKGN1cnJlbnQpIHtcbiAgICAgICAgICAgIHZhciB0YWdOYW1lID0gRE9NLm5vZGVOYW1lKGN1cnJlbnQpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBpZiAoVkFMSURfRUxFTUVOVFMuaGFzT3duUHJvcGVydHkodGFnTmFtZSkgJiYgIVZPSURfRUxFTUVOVFMuaGFzT3duUHJvcGVydHkodGFnTmFtZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJ1Zi5wdXNoKCc8LycpO1xuICAgICAgICAgICAgICAgIHRoaXMuYnVmLnB1c2godGFnTmFtZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5idWYucHVzaCgnPicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBTYW5pdGl6aW5nSHRtbFNlcmlhbGl6ZXIucHJvdG90eXBlLmNoYXJzID0gZnVuY3Rpb24gKGNoYXJzIC8qKiBUT0RPICM5MTAwICovKSB7IHRoaXMuYnVmLnB1c2goZW5jb2RlRW50aXRpZXMoY2hhcnMpKTsgfTtcbiAgICAgICAgcmV0dXJuIFNhbml0aXppbmdIdG1sU2VyaWFsaXplcjtcbiAgICB9KCkpO1xuICAgIC8vIFJlZ3VsYXIgRXhwcmVzc2lvbnMgZm9yIHBhcnNpbmcgdGFncyBhbmQgYXR0cmlidXRlc1xuICAgIHZhciBTVVJST0dBVEVfUEFJUl9SRUdFWFAgPSAvW1xcdUQ4MDAtXFx1REJGRl1bXFx1REMwMC1cXHVERkZGXS9nO1xuICAgIC8vICEgdG8gfiBpcyB0aGUgQVNDSUkgcmFuZ2UuXG4gICAgdmFyIE5PTl9BTFBIQU5VTUVSSUNfUkVHRVhQID0gLyhbXlxcIy1+IHwhXSkvZztcbiAgICAvKipcbiAgICAgKiBFc2NhcGVzIGFsbCBwb3RlbnRpYWxseSBkYW5nZXJvdXMgY2hhcmFjdGVycywgc28gdGhhdCB0aGVcbiAgICAgKiByZXN1bHRpbmcgc3RyaW5nIGNhbiBiZSBzYWZlbHkgaW5zZXJ0ZWQgaW50byBhdHRyaWJ1dGUgb3JcbiAgICAgKiBlbGVtZW50IHRleHQuXG4gICAgICogQHBhcmFtIHZhbHVlXG4gICAgICogQHJldHVybnMge3N0cmluZ30gZXNjYXBlZCB0ZXh0XG4gICAgICovXG4gICAgZnVuY3Rpb24gZW5jb2RlRW50aXRpZXModmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLnJlcGxhY2UoLyYvZywgJyZhbXA7JylcbiAgICAgICAgICAgIC5yZXBsYWNlKFNVUlJPR0FURV9QQUlSX1JFR0VYUCwgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgICAgICAgICB2YXIgaGkgPSBtYXRjaC5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgICAgdmFyIGxvdyA9IG1hdGNoLmNoYXJDb2RlQXQoMSk7XG4gICAgICAgICAgICByZXR1cm4gJyYjJyArICgoKGhpIC0gMHhEODAwKSAqIDB4NDAwKSArIChsb3cgLSAweERDMDApICsgMHgxMDAwMCkgKyAnOyc7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAucmVwbGFjZShOT05fQUxQSEFOVU1FUklDX1JFR0VYUCwgZnVuY3Rpb24gKG1hdGNoKSB7IHJldHVybiAnJiMnICsgbWF0Y2guY2hhckNvZGVBdCgwKSArICc7JzsgfSlcbiAgICAgICAgICAgIC5yZXBsYWNlKC88L2csICcmbHQ7JylcbiAgICAgICAgICAgIC5yZXBsYWNlKC8+L2csICcmZ3Q7Jyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdoZW4gSUU5LTExIGNvbWVzIGFjcm9zcyBhbiB1bmtub3duIG5hbWVzcGFjZWQgYXR0cmlidXRlIGUuZy4gJ3hsaW5rOmZvbycgaXQgYWRkcyAneG1sbnM6bnMxJ1xuICAgICAqIGF0dHJpYnV0ZSB0byBkZWNsYXJlIG5zMSBuYW1lc3BhY2UgYW5kIHByZWZpeGVzIHRoZSBhdHRyaWJ1dGUgd2l0aCAnbnMxJyAoZS5nLiAnbnMxOnhsaW5rOmZvbycpLlxuICAgICAqXG4gICAgICogVGhpcyBpcyB1bmRlc2lyYWJsZSBzaW5jZSB3ZSBkb24ndCB3YW50IHRvIGFsbG93IGFueSBvZiB0aGVzZSBjdXN0b20gYXR0cmlidXRlcy4gVGhpcyBtZXRob2RcbiAgICAgKiBzdHJpcHMgdGhlbSBhbGwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3RyaXBDdXN0b21Oc0F0dHJzKGVsKSB7XG4gICAgICAgIERPTS5hdHRyaWJ1dGVNYXAoZWwpLmZvckVhY2goZnVuY3Rpb24gKF8sIGF0dHJOYW1lKSB7XG4gICAgICAgICAgICBpZiAoYXR0ck5hbWUgPT09ICd4bWxuczpuczEnIHx8IGF0dHJOYW1lLmluZGV4T2YoJ25zMTonKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIERPTS5yZW1vdmVBdHRyaWJ1dGUoZWwsIGF0dHJOYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBET00uY2hpbGROb2Rlc0FzTGlzdChlbCk7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgbiA9IF9hW19pXTtcbiAgICAgICAgICAgIGlmIChET00uaXNFbGVtZW50Tm9kZShuKSlcbiAgICAgICAgICAgICAgICBzdHJpcEN1c3RvbU5zQXR0cnMobik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2FuaXRpemVzIHRoZSBnaXZlbiB1bnNhZmUsIHVudHJ1c3RlZCBIVE1MIGZyYWdtZW50LCBhbmQgcmV0dXJucyBIVE1MIHRleHQgdGhhdCBpcyBzYWZlIHRvIGFkZCB0b1xuICAgICAqIHRoZSBET00gaW4gYSBicm93c2VyIGVudmlyb25tZW50LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNhbml0aXplSHRtbCh1bnNhZmVIdG1sSW5wdXQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBjb250YWluZXJFbCA9IGdldEluZXJ0RWxlbWVudCgpO1xuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHVuc2FmZUh0bWwgaXMgYWN0dWFsbHkgYSBzdHJpbmcgKFR5cGVTY3JpcHQgdHlwZXMgYXJlIG5vdCBlbmZvcmNlZCBhdCBydW50aW1lKS5cbiAgICAgICAgICAgIHZhciB1bnNhZmVIdG1sID0gdW5zYWZlSHRtbElucHV0ID8gU3RyaW5nKHVuc2FmZUh0bWxJbnB1dCkgOiAnJztcbiAgICAgICAgICAgIC8vIG1YU1MgcHJvdGVjdGlvbi4gUmVwZWF0ZWRseSBwYXJzZSB0aGUgZG9jdW1lbnQgdG8gbWFrZSBzdXJlIGl0IHN0YWJpbGl6ZXMsIHNvIHRoYXQgYSBicm93c2VyXG4gICAgICAgICAgICAvLyB0cnlpbmcgdG8gYXV0by1jb3JyZWN0IGluY29ycmVjdCBIVE1MIGNhbm5vdCBjYXVzZSBmb3JtZXJseSBpbmVydCBIVE1MIHRvIGJlY29tZSBkYW5nZXJvdXMuXG4gICAgICAgICAgICB2YXIgbVhTU0F0dGVtcHRzID0gNTtcbiAgICAgICAgICAgIHZhciBwYXJzZWRIdG1sID0gdW5zYWZlSHRtbDtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBpZiAobVhTU0F0dGVtcHRzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIHNhbml0aXplIGh0bWwgYmVjYXVzZSB0aGUgaW5wdXQgaXMgdW5zdGFibGUnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbVhTU0F0dGVtcHRzLS07XG4gICAgICAgICAgICAgICAgdW5zYWZlSHRtbCA9IHBhcnNlZEh0bWw7XG4gICAgICAgICAgICAgICAgRE9NLnNldElubmVySFRNTChjb250YWluZXJFbCwgdW5zYWZlSHRtbCk7XG4gICAgICAgICAgICAgICAgaWYgKERPTS5kZWZhdWx0RG9jKCkuZG9jdW1lbnRNb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHN0cmlwIGN1c3RvbS1uYW1lc3BhY2VkIGF0dHJpYnV0ZXMgb24gSUU8PTExXG4gICAgICAgICAgICAgICAgICAgIHN0cmlwQ3VzdG9tTnNBdHRycyhjb250YWluZXJFbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhcnNlZEh0bWwgPSBET00uZ2V0SW5uZXJIVE1MKGNvbnRhaW5lckVsKTtcbiAgICAgICAgICAgIH0gd2hpbGUgKHVuc2FmZUh0bWwgIT09IHBhcnNlZEh0bWwpO1xuICAgICAgICAgICAgdmFyIHNhbml0aXplciA9IG5ldyBTYW5pdGl6aW5nSHRtbFNlcmlhbGl6ZXIoKTtcbiAgICAgICAgICAgIHZhciBzYWZlSHRtbCA9IHNhbml0aXplci5zYW5pdGl6ZUNoaWxkcmVuKERPTS5nZXRUZW1wbGF0ZUNvbnRlbnQoY29udGFpbmVyRWwpIHx8IGNvbnRhaW5lckVsKTtcbiAgICAgICAgICAgIC8vIENsZWFyIG91dCB0aGUgYm9keSBlbGVtZW50LlxuICAgICAgICAgICAgdmFyIHBhcmVudF8xID0gRE9NLmdldFRlbXBsYXRlQ29udGVudChjb250YWluZXJFbCkgfHwgY29udGFpbmVyRWw7XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gRE9NLmNoaWxkTm9kZXNBc0xpc3QocGFyZW50XzEpOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IF9hW19pXTtcbiAgICAgICAgICAgICAgICBET00ucmVtb3ZlQ2hpbGQocGFyZW50XzEsIGNoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfYW5ndWxhcl9jb3JlLmlzRGV2TW9kZSgpICYmIHNhbml0aXplci5zYW5pdGl6ZWRTb21ldGhpbmcpIHtcbiAgICAgICAgICAgICAgICBET00ubG9nKCdXQVJOSU5HOiBzYW5pdGl6aW5nIEhUTUwgc3RyaXBwZWQgc29tZSBjb250ZW50IChzZWUgaHR0cDovL2cuY28vbmcvc2VjdXJpdHkjeHNzKS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzYWZlSHRtbDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gSW4gY2FzZSBhbnl0aGluZyBnb2VzIHdyb25nLCBjbGVhciBvdXQgaW5lcnRFbGVtZW50IHRvIHJlc2V0IHRoZSBlbnRpcmUgRE9NIHN0cnVjdHVyZS5cbiAgICAgICAgICAgIGluZXJ0RWxlbWVudCA9IG51bGw7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVndWxhciBleHByZXNzaW9uIGZvciBzYWZlIHN0eWxlIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIFF1b3RlcyAoXCIgYW5kICcpIGFyZSBhbGxvd2VkLCBidXQgYSBjaGVjayBtdXN0IGJlIGRvbmUgZWxzZXdoZXJlIHRvIGVuc3VyZSB0aGV5J3JlIGJhbGFuY2VkLlxuICAgICAqXG4gICAgICogJywnIGFsbG93cyBtdWx0aXBsZSB2YWx1ZXMgdG8gYmUgYXNzaWduZWQgdG8gdGhlIHNhbWUgcHJvcGVydHkgKGUuZy4gYmFja2dyb3VuZC1hdHRhY2htZW50IG9yXG4gICAgICogZm9udC1mYW1pbHkpIGFuZCBoZW5jZSBjb3VsZCBhbGxvdyBtdWx0aXBsZSB2YWx1ZXMgdG8gZ2V0IGluamVjdGVkLCBidXQgdGhhdCBzaG91bGQgcG9zZSBubyByaXNrXG4gICAgICogb2YgWFNTLlxuICAgICAqXG4gICAgICogVGhlIGZ1bmN0aW9uIGV4cHJlc3Npb24gY2hlY2tzIG9ubHkgZm9yIFhTUyBzYWZldHksIG5vdCBmb3IgQ1NTIHZhbGlkaXR5LlxuICAgICAqXG4gICAgICogVGhpcyByZWd1bGFyIGV4cHJlc3Npb24gd2FzIHRha2VuIGZyb20gdGhlIENsb3N1cmUgc2FuaXRpemF0aW9uIGxpYnJhcnksIGFuZCBhdWdtZW50ZWQgZm9yXG4gICAgICogdHJhbnNmb3JtYXRpb24gdmFsdWVzLlxuICAgICAqL1xuICAgIHZhciBWQUxVRVMgPSAnWy0sLlwiXFwnJV8hIyBhLXpBLVowLTldKyc7XG4gICAgdmFyIFRSQU5TRk9STUFUSU9OX0ZOUyA9ICcoPzptYXRyaXh8dHJhbnNsYXRlfHNjYWxlfHJvdGF0ZXxza2V3fHBlcnNwZWN0aXZlKSg/Olh8WXwzZCk/JztcbiAgICB2YXIgQ09MT1JfRk5TID0gJyg/OnJnYnxoc2wpYT8nO1xuICAgIHZhciBGTl9BUkdTID0gJ1xcXFwoWy0wLTkuJSwgYS16QS1aXStcXFxcKSc7XG4gICAgdmFyIFNBRkVfU1RZTEVfVkFMVUUgPSBuZXcgUmVnRXhwKFwiXihcIiArIFZBTFVFUyArIFwifCg/OlwiICsgVFJBTlNGT1JNQVRJT05fRk5TICsgXCJ8XCIgKyBDT0xPUl9GTlMgKyBcIilcIiArIEZOX0FSR1MgKyBcIikkXCIsICdnJyk7XG4gICAgLyoqXG4gICAgICogTWF0Y2hlcyBhIGB1cmwoLi4uKWAgdmFsdWUgd2l0aCBhbiBhcmJpdHJhcnkgYXJndW1lbnQgYXMgbG9uZyBhcyBpdCBkb2VzXG4gICAgICogbm90IGNvbnRhaW4gcGFyZW50aGVzZXMuXG4gICAgICpcbiAgICAgKiBUaGUgVVJMIHZhbHVlIHN0aWxsIG5lZWRzIHRvIGJlIHNhbml0aXplZCBzZXBhcmF0ZWx5LlxuICAgICAqXG4gICAgICogYHVybCguLi4pYCB2YWx1ZXMgYXJlIGEgdmVyeSBjb21tb24gdXNlIGNhc2UsIGUuZy4gZm9yIGBiYWNrZ3JvdW5kLWltYWdlYC4gV2l0aCBjYXJlZnVsbHkgY3JhZnRlZFxuICAgICAqIENTUyBzdHlsZSBydWxlcywgaXQgaXMgcG9zc2libGUgdG8gY29uc3RydWN0IGFuIGluZm9ybWF0aW9uIGxlYWsgd2l0aCBgdXJsYCB2YWx1ZXMgaW4gQ1NTLCBlLmcuXG4gICAgICogYnkgb2JzZXJ2aW5nIHdoZXRoZXIgc2Nyb2xsIGJhcnMgYXJlIGRpc3BsYXllZCwgb3IgY2hhcmFjdGVyIHJhbmdlcyB1c2VkIGJ5IGEgZm9udCBmYWNlXG4gICAgICogZGVmaW5pdGlvbi5cbiAgICAgKlxuICAgICAqIEFuZ3VsYXIgb25seSBhbGxvd3MgYmluZGluZyBDU1MgdmFsdWVzIChhcyBvcHBvc2VkIHRvIGVudGlyZSBDU1MgcnVsZXMpLCBzbyBpdCBpcyB1bmxpa2VseSB0aGF0XG4gICAgICogYmluZGluZyBhIFVSTCB2YWx1ZSB3aXRob3V0IGZ1cnRoZXIgY29vcGVyYXRpb24gZnJvbSB0aGUgcGFnZSB3aWxsIGNhdXNlIGFuIGluZm9ybWF0aW9uIGxlYWssIGFuZFxuICAgICAqIGlmIHNvLCBpdCBpcyBqdXN0IGEgbGVhaywgbm90IGEgZnVsbCBibG93biBYU1MgdnVsbmVyYWJpbGl0eS5cbiAgICAgKlxuICAgICAqIEdpdmVuIHRoZSBjb21tb24gdXNlIGNhc2UsIGxvdyBsaWtlbGlob29kIG9mIGF0dGFjayB2ZWN0b3IsIGFuZCBsb3cgaW1wYWN0IG9mIGFuIGF0dGFjaywgdGhpc1xuICAgICAqIGNvZGUgaXMgcGVybWlzc2l2ZSBhbmQgYWxsb3dzIFVSTHMgdGhhdCBzYW5pdGl6ZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgdmFyIFVSTF9SRSA9IC9edXJsXFwoKFteKV0rKVxcKSQvO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB0aGF0IHF1b3RlcyAoXCIgYW5kICcpIGFyZSBwcm9wZXJseSBiYWxhbmNlZCBpbnNpZGUgYSBzdHJpbmcuIEFzc3VtZXNcbiAgICAgKiB0aGF0IG5laXRoZXIgZXNjYXBlIChcXCkgbm9yIGFueSBvdGhlciBjaGFyYWN0ZXIgdGhhdCBjb3VsZCByZXN1bHQgaW5cbiAgICAgKiBicmVha2luZyBvdXQgb2YgYSBzdHJpbmcgcGFyc2luZyBjb250ZXh0IGFyZSBhbGxvd2VkO1xuICAgICAqIHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLXN5bnRheC8jc3RyaW5nLXRva2VuLWRpYWdyYW0uXG4gICAgICpcbiAgICAgKiBUaGlzIGNvZGUgd2FzIHRha2VuIGZyb20gdGhlIENsb3N1cmUgc2FuaXRpemF0aW9uIGxpYnJhcnkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaGFzQmFsYW5jZWRRdW90ZXModmFsdWUpIHtcbiAgICAgICAgdmFyIG91dHNpZGVTaW5nbGUgPSB0cnVlO1xuICAgICAgICB2YXIgb3V0c2lkZURvdWJsZSA9IHRydWU7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjID0gdmFsdWUuY2hhckF0KGkpO1xuICAgICAgICAgICAgaWYgKGMgPT09ICdcXCcnICYmIG91dHNpZGVEb3VibGUpIHtcbiAgICAgICAgICAgICAgICBvdXRzaWRlU2luZ2xlID0gIW91dHNpZGVTaW5nbGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjID09PSAnXCInICYmIG91dHNpZGVTaW5nbGUpIHtcbiAgICAgICAgICAgICAgICBvdXRzaWRlRG91YmxlID0gIW91dHNpZGVEb3VibGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dHNpZGVTaW5nbGUgJiYgb3V0c2lkZURvdWJsZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2FuaXRpemVzIHRoZSBnaXZlbiB1bnRydXN0ZWQgQ1NTIHN0eWxlIHByb3BlcnR5IHZhbHVlIChpLmUuIG5vdCBhbiBlbnRpcmUgb2JqZWN0LCBqdXN0IGEgc2luZ2xlXG4gICAgICogdmFsdWUpIGFuZCByZXR1cm5zIGEgdmFsdWUgdGhhdCBpcyBzYWZlIHRvIHVzZSBpbiBhIGJyb3dzZXIgZW52aXJvbm1lbnQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2FuaXRpemVTdHlsZSh2YWx1ZSkge1xuICAgICAgICB2YWx1ZSA9IFN0cmluZyh2YWx1ZSkudHJpbSgpOyAvLyBNYWtlIHN1cmUgaXQncyBhY3R1YWxseSBhIHN0cmluZy5cbiAgICAgICAgaWYgKCF2YWx1ZSlcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgLy8gU2luZ2xlIHVybCguLi4pIHZhbHVlcyBhcmUgc3VwcG9ydGVkLCBidXQgb25seSBmb3IgVVJMcyB0aGF0IHNhbml0aXplIGNsZWFubHkuIFNlZSBhYm92ZSBmb3JcbiAgICAgICAgLy8gcmVhc29uaW5nIGJlaGluZCB0aGlzLlxuICAgICAgICB2YXIgdXJsTWF0Y2ggPSB2YWx1ZS5tYXRjaChVUkxfUkUpO1xuICAgICAgICBpZiAoKHVybE1hdGNoICYmIHNhbml0aXplVXJsKHVybE1hdGNoWzFdKSA9PT0gdXJsTWF0Y2hbMV0pIHx8XG4gICAgICAgICAgICB2YWx1ZS5tYXRjaChTQUZFX1NUWUxFX1ZBTFVFKSAmJiBoYXNCYWxhbmNlZFF1b3Rlcyh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTsgLy8gU2FmZSBzdHlsZSB2YWx1ZXMuXG4gICAgICAgIH1cbiAgICAgICAgaWYgKF9hbmd1bGFyX2NvcmUuaXNEZXZNb2RlKCkpIHtcbiAgICAgICAgICAgIGdldERPTSgpLmxvZyhcIldBUk5JTkc6IHNhbml0aXppbmcgdW5zYWZlIHN0eWxlIHZhbHVlIFwiICsgdmFsdWUgKyBcIiAoc2VlIGh0dHA6Ly9nLmNvL25nL3NlY3VyaXR5I3hzcykuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAndW5zYWZlJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgdmFyIF9fZXh0ZW5kcyQ5ID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRG9tU2FuaXRpemVyIGhlbHBzIHByZXZlbnRpbmcgQ3Jvc3MgU2l0ZSBTY3JpcHRpbmcgU2VjdXJpdHkgYnVncyAoWFNTKSBieSBzYW5pdGl6aW5nXG4gICAgICogdmFsdWVzIHRvIGJlIHNhZmUgdG8gdXNlIGluIHRoZSBkaWZmZXJlbnQgRE9NIGNvbnRleHRzLlxuICAgICAqXG4gICAgICogRm9yIGV4YW1wbGUsIHdoZW4gYmluZGluZyBhIFVSTCBpbiBhbiBgPGEgW2hyZWZdPVwic29tZVZhbHVlXCI+YCBoeXBlcmxpbmssIGBzb21lVmFsdWVgIHdpbGwgYmVcbiAgICAgKiBzYW5pdGl6ZWQgc28gdGhhdCBhbiBhdHRhY2tlciBjYW5ub3QgaW5qZWN0IGUuZy4gYSBgamF2YXNjcmlwdDpgIFVSTCB0aGF0IHdvdWxkIGV4ZWN1dGUgY29kZSBvblxuICAgICAqIHRoZSB3ZWJzaXRlLlxuICAgICAqXG4gICAgICogSW4gc3BlY2lmaWMgc2l0dWF0aW9ucywgaXQgbWlnaHQgYmUgbmVjZXNzYXJ5IHRvIGRpc2FibGUgc2FuaXRpemF0aW9uLCBmb3IgZXhhbXBsZSBpZiB0aGVcbiAgICAgKiBhcHBsaWNhdGlvbiBnZW51aW5lbHkgbmVlZHMgdG8gcHJvZHVjZSBhIGBqYXZhc2NyaXB0OmAgc3R5bGUgbGluayB3aXRoIGEgZHluYW1pYyB2YWx1ZSBpbiBpdC5cbiAgICAgKiBVc2VycyBjYW4gYnlwYXNzIHNlY3VyaXR5IGJ5IGNvbnN0cnVjdGluZyBhIHZhbHVlIHdpdGggb25lIG9mIHRoZSBgYnlwYXNzU2VjdXJpdHlUcnVzdC4uLmBcbiAgICAgKiBtZXRob2RzLCBhbmQgdGhlbiBiaW5kaW5nIHRvIHRoYXQgdmFsdWUgZnJvbSB0aGUgdGVtcGxhdGUuXG4gICAgICpcbiAgICAgKiBUaGVzZSBzaXR1YXRpb25zIHNob3VsZCBiZSB2ZXJ5IHJhcmUsIGFuZCBleHRyYW9yZGluYXJ5IGNhcmUgbXVzdCBiZSB0YWtlbiB0byBhdm9pZCBjcmVhdGluZyBhXG4gICAgICogQ3Jvc3MgU2l0ZSBTY3JpcHRpbmcgKFhTUykgc2VjdXJpdHkgYnVnIVxuICAgICAqXG4gICAgICogV2hlbiB1c2luZyBgYnlwYXNzU2VjdXJpdHlUcnVzdC4uLmAsIG1ha2Ugc3VyZSB0byBjYWxsIHRoZSBtZXRob2QgYXMgZWFybHkgYXMgcG9zc2libGUgYW5kIGFzXG4gICAgICogY2xvc2UgYXMgcG9zc2libGUgdG8gdGhlIHNvdXJjZSBvZiB0aGUgdmFsdWUsIHRvIG1ha2UgaXQgZWFzeSB0byB2ZXJpZnkgbm8gc2VjdXJpdHkgYnVnIGlzXG4gICAgICogY3JlYXRlZCBieSBpdHMgdXNlLlxuICAgICAqXG4gICAgICogSXQgaXMgbm90IHJlcXVpcmVkIChhbmQgbm90IHJlY29tbWVuZGVkKSB0byBieXBhc3Mgc2VjdXJpdHkgaWYgdGhlIHZhbHVlIGlzIHNhZmUsIGUuZy4gYSBVUkwgdGhhdFxuICAgICAqIGRvZXMgbm90IHN0YXJ0IHdpdGggYSBzdXNwaWNpb3VzIHByb3RvY29sLCBvciBhbiBIVE1MIHNuaXBwZXQgdGhhdCBkb2VzIG5vdCBjb250YWluIGRhbmdlcm91c1xuICAgICAqIGNvZGUuIFRoZSBzYW5pdGl6ZXIgbGVhdmVzIHNhZmUgdmFsdWVzIGludGFjdC5cbiAgICAgKlxuICAgICAqIEBzZWN1cml0eSBDYWxsaW5nIGFueSBvZiB0aGUgYGJ5cGFzc1NlY3VyaXR5VHJ1c3QuLi5gIEFQSXMgZGlzYWJsZXMgQW5ndWxhcidzIGJ1aWx0LWluXG4gICAgICogc2FuaXRpemF0aW9uIGZvciB0aGUgdmFsdWUgcGFzc2VkIGluLiBDYXJlZnVsbHkgY2hlY2sgYW5kIGF1ZGl0IGFsbCB2YWx1ZXMgYW5kIGNvZGUgcGF0aHMgZ29pbmdcbiAgICAgKiBpbnRvIHRoaXMgY2FsbC4gTWFrZSBzdXJlIGFueSB1c2VyIGRhdGEgaXMgYXBwcm9wcmlhdGVseSBlc2NhcGVkIGZvciB0aGlzIHNlY3VyaXR5IGNvbnRleHQuXG4gICAgICogRm9yIG1vcmUgZGV0YWlsLCBzZWUgdGhlIFtTZWN1cml0eSBHdWlkZV0oaHR0cDovL2cuY28vbmcvc2VjdXJpdHkpLlxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBEb21TYW5pdGl6ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBEb21TYW5pdGl6ZXIoKSB7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIERvbVNhbml0aXplcjtcbiAgICB9KCkpO1xuICAgIHZhciBEb21TYW5pdGl6ZXJJbXBsID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDkoRG9tU2FuaXRpemVySW1wbCwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gRG9tU2FuaXRpemVySW1wbCgpIHtcbiAgICAgICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIERvbVNhbml0aXplckltcGwucHJvdG90eXBlLnNhbml0aXplID0gZnVuY3Rpb24gKGN0eCwgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgc3dpdGNoIChjdHgpIHtcbiAgICAgICAgICAgICAgICBjYXNlIF9hbmd1bGFyX2NvcmUuU2VjdXJpdHlDb250ZXh0Lk5PTkU6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICBjYXNlIF9hbmd1bGFyX2NvcmUuU2VjdXJpdHlDb250ZXh0LkhUTUw6XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFNhZmVIdG1sSW1wbClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5jaGFuZ2luZ1RoaXNCcmVha3NBcHBsaWNhdGlvblNlY3VyaXR5O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoZWNrTm90U2FmZVZhbHVlKHZhbHVlLCAnSFRNTCcpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2FuaXRpemVIdG1sKFN0cmluZyh2YWx1ZSkpO1xuICAgICAgICAgICAgICAgIGNhc2UgX2FuZ3VsYXJfY29yZS5TZWN1cml0eUNvbnRleHQuU1RZTEU6XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFNhZmVTdHlsZUltcGwpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUuY2hhbmdpbmdUaGlzQnJlYWtzQXBwbGljYXRpb25TZWN1cml0eTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGVja05vdFNhZmVWYWx1ZSh2YWx1ZSwgJ1N0eWxlJyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzYW5pdGl6ZVN0eWxlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBjYXNlIF9hbmd1bGFyX2NvcmUuU2VjdXJpdHlDb250ZXh0LlNDUklQVDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgU2FmZVNjcmlwdEltcGwpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUuY2hhbmdpbmdUaGlzQnJlYWtzQXBwbGljYXRpb25TZWN1cml0eTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGVja05vdFNhZmVWYWx1ZSh2YWx1ZSwgJ1NjcmlwdCcpO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vuc2FmZSB2YWx1ZSB1c2VkIGluIGEgc2NyaXB0IGNvbnRleHQnKTtcbiAgICAgICAgICAgICAgICBjYXNlIF9hbmd1bGFyX2NvcmUuU2VjdXJpdHlDb250ZXh0LlVSTDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgU2FmZVJlc291cmNlVXJsSW1wbCB8fCB2YWx1ZSBpbnN0YW5jZW9mIFNhZmVVcmxJbXBsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBbGxvdyByZXNvdXJjZSBVUkxzIGluIFVSTCBjb250ZXh0cywgdGhleSBhcmUgc3RyaWN0bHkgbW9yZSB0cnVzdGVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLmNoYW5naW5nVGhpc0JyZWFrc0FwcGxpY2F0aW9uU2VjdXJpdHk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGVja05vdFNhZmVWYWx1ZSh2YWx1ZSwgJ1VSTCcpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2FuaXRpemVVcmwoU3RyaW5nKHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgY2FzZSBfYW5ndWxhcl9jb3JlLlNlY3VyaXR5Q29udGV4dC5SRVNPVVJDRV9VUkw6XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFNhZmVSZXNvdXJjZVVybEltcGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5jaGFuZ2luZ1RoaXNCcmVha3NBcHBsaWNhdGlvblNlY3VyaXR5O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tOb3RTYWZlVmFsdWUodmFsdWUsICdSZXNvdXJjZVVSTCcpO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vuc2FmZSB2YWx1ZSB1c2VkIGluIGEgcmVzb3VyY2UgVVJMIGNvbnRleHQgKHNlZSBodHRwOi8vZy5jby9uZy9zZWN1cml0eSN4c3MpJyk7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBTZWN1cml0eUNvbnRleHQgXCIgKyBjdHggKyBcIiAoc2VlIGh0dHA6Ly9nLmNvL25nL3NlY3VyaXR5I3hzcylcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIERvbVNhbml0aXplckltcGwucHJvdG90eXBlLmNoZWNrTm90U2FmZVZhbHVlID0gZnVuY3Rpb24gKHZhbHVlLCBleHBlY3RlZFR5cGUpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFNhZmVWYWx1ZUltcGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKFwiUmVxdWlyZWQgYSBzYWZlIFwiICsgZXhwZWN0ZWRUeXBlICsgXCIsIGdvdCBhIFwiICsgdmFsdWUuZ2V0VHlwZU5hbWUoKSArIFwiIFwiKSArXG4gICAgICAgICAgICAgICAgICAgIFwiKHNlZSBodHRwOi8vZy5jby9uZy9zZWN1cml0eSN4c3MpXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBEb21TYW5pdGl6ZXJJbXBsLnByb3RvdHlwZS5ieXBhc3NTZWN1cml0eVRydXN0SHRtbCA9IGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gbmV3IFNhZmVIdG1sSW1wbCh2YWx1ZSk7IH07XG4gICAgICAgIERvbVNhbml0aXplckltcGwucHJvdG90eXBlLmJ5cGFzc1NlY3VyaXR5VHJ1c3RTdHlsZSA9IGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gbmV3IFNhZmVTdHlsZUltcGwodmFsdWUpOyB9O1xuICAgICAgICBEb21TYW5pdGl6ZXJJbXBsLnByb3RvdHlwZS5ieXBhc3NTZWN1cml0eVRydXN0U2NyaXB0ID0gZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBuZXcgU2FmZVNjcmlwdEltcGwodmFsdWUpOyB9O1xuICAgICAgICBEb21TYW5pdGl6ZXJJbXBsLnByb3RvdHlwZS5ieXBhc3NTZWN1cml0eVRydXN0VXJsID0gZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBuZXcgU2FmZVVybEltcGwodmFsdWUpOyB9O1xuICAgICAgICBEb21TYW5pdGl6ZXJJbXBsLnByb3RvdHlwZS5ieXBhc3NTZWN1cml0eVRydXN0UmVzb3VyY2VVcmwgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2FmZVJlc291cmNlVXJsSW1wbCh2YWx1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIERvbVNhbml0aXplckltcGwuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3RhYmxlIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBEb21TYW5pdGl6ZXJJbXBsLmN0b3JQYXJhbWV0ZXJzID0gW107XG4gICAgICAgIHJldHVybiBEb21TYW5pdGl6ZXJJbXBsO1xuICAgIH0oRG9tU2FuaXRpemVyKSk7XG4gICAgdmFyIFNhZmVWYWx1ZUltcGwgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBTYWZlVmFsdWVJbXBsKGNoYW5naW5nVGhpc0JyZWFrc0FwcGxpY2F0aW9uU2VjdXJpdHkpIHtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdpbmdUaGlzQnJlYWtzQXBwbGljYXRpb25TZWN1cml0eSA9IGNoYW5naW5nVGhpc0JyZWFrc0FwcGxpY2F0aW9uU2VjdXJpdHk7XG4gICAgICAgICAgICAvLyBlbXB0eVxuICAgICAgICB9XG4gICAgICAgIFNhZmVWYWx1ZUltcGwucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIChcIlNhZmVWYWx1ZSBtdXN0IHVzZSBbcHJvcGVydHldPWJpbmRpbmc6IFwiICsgdGhpcy5jaGFuZ2luZ1RoaXNCcmVha3NBcHBsaWNhdGlvblNlY3VyaXR5KSArXG4gICAgICAgICAgICAgICAgXCIgKHNlZSBodHRwOi8vZy5jby9uZy9zZWN1cml0eSN4c3MpXCI7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBTYWZlVmFsdWVJbXBsO1xuICAgIH0oKSk7XG4gICAgdmFyIFNhZmVIdG1sSW1wbCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQ5KFNhZmVIdG1sSW1wbCwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gU2FmZUh0bWxJbXBsKCkge1xuICAgICAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgU2FmZUh0bWxJbXBsLnByb3RvdHlwZS5nZXRUeXBlTmFtZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICdIVE1MJzsgfTtcbiAgICAgICAgcmV0dXJuIFNhZmVIdG1sSW1wbDtcbiAgICB9KFNhZmVWYWx1ZUltcGwpKTtcbiAgICB2YXIgU2FmZVN0eWxlSW1wbCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQ5KFNhZmVTdHlsZUltcGwsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIFNhZmVTdHlsZUltcGwoKSB7XG4gICAgICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBTYWZlU3R5bGVJbXBsLnByb3RvdHlwZS5nZXRUeXBlTmFtZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICdTdHlsZSc7IH07XG4gICAgICAgIHJldHVybiBTYWZlU3R5bGVJbXBsO1xuICAgIH0oU2FmZVZhbHVlSW1wbCkpO1xuICAgIHZhciBTYWZlU2NyaXB0SW1wbCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQ5KFNhZmVTY3JpcHRJbXBsLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBTYWZlU2NyaXB0SW1wbCgpIHtcbiAgICAgICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIFNhZmVTY3JpcHRJbXBsLnByb3RvdHlwZS5nZXRUeXBlTmFtZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICdTY3JpcHQnOyB9O1xuICAgICAgICByZXR1cm4gU2FmZVNjcmlwdEltcGw7XG4gICAgfShTYWZlVmFsdWVJbXBsKSk7XG4gICAgdmFyIFNhZmVVcmxJbXBsID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDkoU2FmZVVybEltcGwsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIFNhZmVVcmxJbXBsKCkge1xuICAgICAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgU2FmZVVybEltcGwucHJvdG90eXBlLmdldFR5cGVOYW1lID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJ1VSTCc7IH07XG4gICAgICAgIHJldHVybiBTYWZlVXJsSW1wbDtcbiAgICB9KFNhZmVWYWx1ZUltcGwpKTtcbiAgICB2YXIgU2FmZVJlc291cmNlVXJsSW1wbCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQ5KFNhZmVSZXNvdXJjZVVybEltcGwsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIFNhZmVSZXNvdXJjZVVybEltcGwoKSB7XG4gICAgICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBTYWZlUmVzb3VyY2VVcmxJbXBsLnByb3RvdHlwZS5nZXRUeXBlTmFtZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICdSZXNvdXJjZVVSTCc7IH07XG4gICAgICAgIHJldHVybiBTYWZlUmVzb3VyY2VVcmxJbXBsO1xuICAgIH0oU2FmZVZhbHVlSW1wbCkpO1xuXG4gICAgdmFyIElOVEVSTkFMX0JST1dTRVJfUExBVEZPUk1fUFJPVklERVJTID0gW1xuICAgICAgICB7IHByb3ZpZGU6IF9hbmd1bGFyX2NvcmUuUExBVEZPUk1fSU5JVElBTElaRVIsIHVzZVZhbHVlOiBpbml0RG9tQWRhcHRlciwgbXVsdGk6IHRydWUgfSxcbiAgICAgICAgeyBwcm92aWRlOiBfYW5ndWxhcl9jb21tb24uUGxhdGZvcm1Mb2NhdGlvbiwgdXNlQ2xhc3M6IEJyb3dzZXJQbGF0Zm9ybUxvY2F0aW9uIH1cbiAgICBdO1xuICAgIC8qKlxuICAgICAqIEBzZWN1cml0eSBSZXBsYWNpbmcgYnVpbHQtaW4gc2FuaXRpemF0aW9uIHByb3ZpZGVycyBleHBvc2VzIHRoZSBhcHBsaWNhdGlvbiB0byBYU1Mgcmlza3MuXG4gICAgICogQXR0YWNrZXItY29udHJvbGxlZCBkYXRhIGludHJvZHVjZWQgYnkgYW4gdW5zYW5pdGl6ZWQgcHJvdmlkZXIgY291bGQgZXhwb3NlIHlvdXJcbiAgICAgKiBhcHBsaWNhdGlvbiB0byBYU1Mgcmlza3MuIEZvciBtb3JlIGRldGFpbCwgc2VlIHRoZSBbU2VjdXJpdHkgR3VpZGVdKGh0dHA6Ly9nLmNvL25nL3NlY3VyaXR5KS5cbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgdmFyIEJST1dTRVJfU0FOSVRJWkFUSU9OX1BST1ZJREVSUyA9IFtcbiAgICAgICAgeyBwcm92aWRlOiBfYW5ndWxhcl9jb3JlLlNhbml0aXplciwgdXNlRXhpc3Rpbmc6IERvbVNhbml0aXplciB9LFxuICAgICAgICB7IHByb3ZpZGU6IERvbVNhbml0aXplciwgdXNlQ2xhc3M6IERvbVNhbml0aXplckltcGwgfSxcbiAgICBdO1xuICAgIC8qKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgcGxhdGZvcm1Ccm93c2VyID0gX2FuZ3VsYXJfY29yZS5jcmVhdGVQbGF0Zm9ybUZhY3RvcnkoX2FuZ3VsYXJfY29yZS5wbGF0Zm9ybUNvcmUsICdicm93c2VyJywgSU5URVJOQUxfQlJPV1NFUl9QTEFURk9STV9QUk9WSURFUlMpO1xuICAgIGZ1bmN0aW9uIGluaXREb21BZGFwdGVyKCkge1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5tYWtlQ3VycmVudCgpO1xuICAgICAgICBCcm93c2VyR2V0VGVzdGFiaWxpdHkuaW5pdCgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlcnJvckhhbmRsZXIoKSB7XG4gICAgICAgIHJldHVybiBuZXcgX2FuZ3VsYXJfY29yZS5FcnJvckhhbmRsZXIoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gX2RvY3VtZW50KCkge1xuICAgICAgICByZXR1cm4gZ2V0RE9NKCkuZGVmYXVsdERvYygpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBfcmVzb2x2ZURlZmF1bHRBbmltYXRpb25Ecml2ZXIoKSB7XG4gICAgICAgIGlmIChnZXRET00oKS5zdXBwb3J0c1dlYkFuaW1hdGlvbigpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFdlYkFuaW1hdGlvbnNEcml2ZXIoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQW5pbWF0aW9uRHJpdmVyLk5PT1A7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBuZyBtb2R1bGUgZm9yIHRoZSBicm93c2VyLlxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBCcm93c2VyTW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gQnJvd3Nlck1vZHVsZShwYXJlbnRNb2R1bGUpIHtcbiAgICAgICAgICAgIGlmIChwYXJlbnRNb2R1bGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJCcm93c2VyTW9kdWxlIGhhcyBhbHJlYWR5IGJlZW4gbG9hZGVkLiBJZiB5b3UgbmVlZCBhY2Nlc3MgdG8gY29tbW9uIGRpcmVjdGl2ZXMgc3VjaCBhcyBOZ0lmIGFuZCBOZ0ZvciBmcm9tIGEgbGF6eSBsb2FkZWQgbW9kdWxlLCBpbXBvcnQgQ29tbW9uTW9kdWxlIGluc3RlYWQuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIEJyb3dzZXJNb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5OZ01vZHVsZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEJST1dTRVJfU0FOSVRJWkFUSU9OX1BST1ZJREVSUywgeyBwcm92aWRlOiBfYW5ndWxhcl9jb3JlLkVycm9ySGFuZGxlciwgdXNlRmFjdG9yeTogZXJyb3JIYW5kbGVyLCBkZXBzOiBbXSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgcHJvdmlkZTogRE9DVU1FTlQsIHVzZUZhY3Rvcnk6IF9kb2N1bWVudCwgZGVwczogW10gfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IHByb3ZpZGU6IEVWRU5UX01BTkFHRVJfUExVR0lOUywgdXNlQ2xhc3M6IERvbUV2ZW50c1BsdWdpbiwgbXVsdGk6IHRydWUgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IHByb3ZpZGU6IEVWRU5UX01BTkFHRVJfUExVR0lOUywgdXNlQ2xhc3M6IEtleUV2ZW50c1BsdWdpbiwgbXVsdGk6IHRydWUgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IHByb3ZpZGU6IEVWRU5UX01BTkFHRVJfUExVR0lOUywgdXNlQ2xhc3M6IEhhbW1lckdlc3R1cmVzUGx1Z2luLCBtdWx0aTogdHJ1ZSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgcHJvdmlkZTogSEFNTUVSX0dFU1RVUkVfQ09ORklHLCB1c2VDbGFzczogSGFtbWVyR2VzdHVyZUNvbmZpZyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgcHJvdmlkZTogRG9tUm9vdFJlbmRlcmVyLCB1c2VDbGFzczogRG9tUm9vdFJlbmRlcmVyXyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgcHJvdmlkZTogX2FuZ3VsYXJfY29yZS5Sb290UmVuZGVyZXIsIHVzZUV4aXN0aW5nOiBEb21Sb290UmVuZGVyZXIgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IHByb3ZpZGU6IFNoYXJlZFN0eWxlc0hvc3QsIHVzZUV4aXN0aW5nOiBEb21TaGFyZWRTdHlsZXNIb3N0IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBwcm92aWRlOiBBbmltYXRpb25Ecml2ZXIsIHVzZUZhY3Rvcnk6IF9yZXNvbHZlRGVmYXVsdEFuaW1hdGlvbkRyaXZlciB9LCBEb21TaGFyZWRTdHlsZXNIb3N0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9hbmd1bGFyX2NvcmUuVGVzdGFiaWxpdHksIEV2ZW50TWFuYWdlciwgRUxFTUVOVF9QUk9CRV9QUk9WSURFUlMsIFRpdGxlXG4gICAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwb3J0czogW19hbmd1bGFyX2NvbW1vbi5Db21tb25Nb2R1bGUsIF9hbmd1bGFyX2NvcmUuQXBwbGljYXRpb25Nb2R1bGVdXG4gICAgICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgQnJvd3Nlck1vZHVsZS5jdG9yUGFyYW1ldGVycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogQnJvd3Nlck1vZHVsZSwgZGVjb3JhdG9yczogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5PcHRpb25hbCB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuU2tpcFNlbGYgfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiBCcm93c2VyTW9kdWxlO1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgLyoqXG4gICAgICogSlMgdmVyc2lvbiBvZiBicm93c2VyIEFQSXMuIFRoaXMgbGlicmFyeSBjYW4gb25seSBydW4gaW4gdGhlIGJyb3dzZXIuXG4gICAgICovXG4gICAgdmFyIHdpbiA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdyB8fCB7fTtcblxuICAgIHZhciBDaGFuZ2VEZXRlY3Rpb25QZXJmUmVjb3JkID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gQ2hhbmdlRGV0ZWN0aW9uUGVyZlJlY29yZChtc1BlclRpY2ssIG51bVRpY2tzKSB7XG4gICAgICAgICAgICB0aGlzLm1zUGVyVGljayA9IG1zUGVyVGljaztcbiAgICAgICAgICAgIHRoaXMubnVtVGlja3MgPSBudW1UaWNrcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQ2hhbmdlRGV0ZWN0aW9uUGVyZlJlY29yZDtcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIEVudHJ5IHBvaW50IGZvciBhbGwgQW5ndWxhciBkZWJ1ZyB0b29scy4gVGhpcyBvYmplY3QgY29ycmVzcG9uZHMgdG8gdGhlIGBuZ2BcbiAgICAgKiBnbG9iYWwgdmFyaWFibGUgYWNjZXNzaWJsZSBpbiB0aGUgZGV2IGNvbnNvbGUuXG4gICAgICovXG4gICAgdmFyIEFuZ3VsYXJUb29scyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEFuZ3VsYXJUb29scyhyZWYpIHtcbiAgICAgICAgICAgIHRoaXMucHJvZmlsZXIgPSBuZXcgQW5ndWxhclByb2ZpbGVyKHJlZik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEFuZ3VsYXJUb29scztcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIEVudHJ5IHBvaW50IGZvciBhbGwgQW5ndWxhciBwcm9maWxpbmctcmVsYXRlZCBkZWJ1ZyB0b29scy4gVGhpcyBvYmplY3RcbiAgICAgKiBjb3JyZXNwb25kcyB0byB0aGUgYG5nLnByb2ZpbGVyYCBpbiB0aGUgZGV2IGNvbnNvbGUuXG4gICAgICovXG4gICAgdmFyIEFuZ3VsYXJQcm9maWxlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEFuZ3VsYXJQcm9maWxlcihyZWYpIHtcbiAgICAgICAgICAgIHRoaXMuYXBwUmVmID0gcmVmLmluamVjdG9yLmdldChfYW5ndWxhcl9jb3JlLkFwcGxpY2F0aW9uUmVmKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRXhlcmNpc2VzIGNoYW5nZSBkZXRlY3Rpb24gaW4gYSBsb29wIGFuZCB0aGVuIHByaW50cyB0aGUgYXZlcmFnZSBhbW91bnQgb2ZcbiAgICAgICAgICogdGltZSBpbiBtaWxsaXNlY29uZHMgaG93IGxvbmcgYSBzaW5nbGUgcm91bmQgb2YgY2hhbmdlIGRldGVjdGlvbiB0YWtlcyBmb3JcbiAgICAgICAgICogdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIFVJLiBJdCBydW5zIGEgbWluaW11bSBvZiA1IHJvdW5kcyBmb3IgYSBtaW5pbXVtXG4gICAgICAgICAqIG9mIDUwMCBtaWxsaXNlY29uZHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIE9wdGlvbmFsbHksIGEgdXNlciBtYXkgcGFzcyBhIGBjb25maWdgIHBhcmFtZXRlciBjb250YWluaW5nIGEgbWFwIG9mXG4gICAgICAgICAqIG9wdGlvbnMuIFN1cHBvcnRlZCBvcHRpb25zIGFyZTpcbiAgICAgICAgICpcbiAgICAgICAgICogYHJlY29yZGAgKGJvb2xlYW4pIC0gY2F1c2VzIHRoZSBwcm9maWxlciB0byByZWNvcmQgYSBDUFUgcHJvZmlsZSB3aGlsZVxuICAgICAgICAgKiBpdCBleGVyY2lzZXMgdGhlIGNoYW5nZSBkZXRlY3Rvci4gRXhhbXBsZTpcbiAgICAgICAgICpcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqIG5nLnByb2ZpbGVyLnRpbWVDaGFuZ2VEZXRlY3Rpb24oe3JlY29yZDogdHJ1ZX0pXG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKi9cbiAgICAgICAgQW5ndWxhclByb2ZpbGVyLnByb3RvdHlwZS50aW1lQ2hhbmdlRGV0ZWN0aW9uID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICAgICAgdmFyIHJlY29yZCA9IGNvbmZpZyAmJiBjb25maWdbJ3JlY29yZCddO1xuICAgICAgICAgICAgdmFyIHByb2ZpbGVOYW1lID0gJ0NoYW5nZSBEZXRlY3Rpb24nO1xuICAgICAgICAgICAgLy8gUHJvZmlsZXIgaXMgbm90IGF2YWlsYWJsZSBpbiBBbmRyb2lkIGJyb3dzZXJzLCBub3IgaW4gSUUgOSB3aXRob3V0IGRldiB0b29scyBvcGVuZWRcbiAgICAgICAgICAgIHZhciBpc1Byb2ZpbGVyQXZhaWxhYmxlID0gaXNQcmVzZW50KHdpbi5jb25zb2xlLnByb2ZpbGUpO1xuICAgICAgICAgICAgaWYgKHJlY29yZCAmJiBpc1Byb2ZpbGVyQXZhaWxhYmxlKSB7XG4gICAgICAgICAgICAgICAgd2luLmNvbnNvbGUucHJvZmlsZShwcm9maWxlTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc3RhcnQgPSBnZXRET00oKS5wZXJmb3JtYW5jZU5vdygpO1xuICAgICAgICAgICAgdmFyIG51bVRpY2tzID0gMDtcbiAgICAgICAgICAgIHdoaWxlIChudW1UaWNrcyA8IDUgfHwgKGdldERPTSgpLnBlcmZvcm1hbmNlTm93KCkgLSBzdGFydCkgPCA1MDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFwcFJlZi50aWNrKCk7XG4gICAgICAgICAgICAgICAgbnVtVGlja3MrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBlbmQgPSBnZXRET00oKS5wZXJmb3JtYW5jZU5vdygpO1xuICAgICAgICAgICAgaWYgKHJlY29yZCAmJiBpc1Byb2ZpbGVyQXZhaWxhYmxlKSB7XG4gICAgICAgICAgICAgICAgLy8gbmVlZCB0byBjYXN0IHRvIDxhbnk+IGJlY2F1c2UgdHlwZSBjaGVja2VyIHRoaW5rcyB0aGVyZSdzIG5vIGFyZ3VtZW50XG4gICAgICAgICAgICAgICAgLy8gd2hpbGUgaW4gZmFjdCB0aGVyZSBpczpcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Db25zb2xlL3Byb2ZpbGVFbmRcbiAgICAgICAgICAgICAgICB3aW4uY29uc29sZS5wcm9maWxlRW5kKHByb2ZpbGVOYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBtc1BlclRpY2sgPSAoZW5kIC0gc3RhcnQpIC8gbnVtVGlja3M7XG4gICAgICAgICAgICB3aW4uY29uc29sZS5sb2coXCJyYW4gXCIgKyBudW1UaWNrcyArIFwiIGNoYW5nZSBkZXRlY3Rpb24gY3ljbGVzXCIpO1xuICAgICAgICAgICAgd2luLmNvbnNvbGUubG9nKG1zUGVyVGljay50b0ZpeGVkKDIpICsgXCIgbXMgcGVyIGNoZWNrXCIpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBDaGFuZ2VEZXRlY3Rpb25QZXJmUmVjb3JkKG1zUGVyVGljaywgbnVtVGlja3MpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gQW5ndWxhclByb2ZpbGVyO1xuICAgIH0oKSk7XG5cbiAgICB2YXIgY29udGV4dCA9IGdsb2JhbCQxO1xuICAgIC8qKlxuICAgICAqIEVuYWJsZWQgQW5ndWxhciAyIGRlYnVnIHRvb2xzIHRoYXQgYXJlIGFjY2Vzc2libGUgdmlhIHlvdXIgYnJvd3NlcidzXG4gICAgICogZGV2ZWxvcGVyIGNvbnNvbGUuXG4gICAgICpcbiAgICAgKiBVc2FnZTpcbiAgICAgKlxuICAgICAqIDEuIE9wZW4gZGV2ZWxvcGVyIGNvbnNvbGUgKGUuZy4gaW4gQ2hyb21lIEN0cmwgKyBTaGlmdCArIGopXG4gICAgICogMS4gVHlwZSBgbmcuYCAodXN1YWxseSB0aGUgY29uc29sZSB3aWxsIHNob3cgYXV0by1jb21wbGV0ZSBzdWdnZXN0aW9uKVxuICAgICAqIDEuIFRyeSB0aGUgY2hhbmdlIGRldGVjdGlvbiBwcm9maWxlciBgbmcucHJvZmlsZXIudGltZUNoYW5nZURldGVjdGlvbigpYFxuICAgICAqICAgIHRoZW4gaGl0IEVudGVyLlxuICAgICAqXG4gICAgICogQGV4cGVyaW1lbnRhbCBBbGwgZGVidWdnaW5nIGFwaXMgYXJlIGN1cnJlbnRseSBleHBlcmltZW50YWwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZW5hYmxlRGVidWdUb29scyhyZWYpIHtcbiAgICAgICAgY29udGV4dC5uZyA9IG5ldyBBbmd1bGFyVG9vbHMocmVmKTtcbiAgICAgICAgcmV0dXJuIHJlZjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGlzYWJsZXMgQW5ndWxhciAyIHRvb2xzLlxuICAgICAqXG4gICAgICogQGV4cGVyaW1lbnRhbCBBbGwgZGVidWdnaW5nIGFwaXMgYXJlIGN1cnJlbnRseSBleHBlcmltZW50YWwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGlzYWJsZURlYnVnVG9vbHMoKSB7XG4gICAgICAgIGRlbGV0ZSBjb250ZXh0Lm5nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByZWRpY2F0ZXMgZm9yIHVzZSB3aXRoIHtAbGluayBEZWJ1Z0VsZW1lbnR9J3MgcXVlcnkgZnVuY3Rpb25zLlxuICAgICAqXG4gICAgICogQGV4cGVyaW1lbnRhbCBBbGwgZGVidWdnaW5nIGFwaXMgYXJlIGN1cnJlbnRseSBleHBlcmltZW50YWwuXG4gICAgICovXG4gICAgdmFyIEJ5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gQnkoKSB7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1hdGNoIGFsbCBlbGVtZW50cy5cbiAgICAgICAgICpcbiAgICAgICAgICogIyMgRXhhbXBsZVxuICAgICAgICAgKlxuICAgICAgICAgKiB7QGV4YW1wbGUgcGxhdGZvcm0tYnJvd3Nlci9kb20vZGVidWcvdHMvYnkvYnkudHMgcmVnaW9uPSdieV9hbGwnfVxuICAgICAgICAgKi9cbiAgICAgICAgQnkuYWxsID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZnVuY3Rpb24gKGRlYnVnRWxlbWVudCkgeyByZXR1cm4gdHJ1ZTsgfTsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1hdGNoIGVsZW1lbnRzIGJ5IHRoZSBnaXZlbiBDU1Mgc2VsZWN0b3IuXG4gICAgICAgICAqXG4gICAgICAgICAqICMjIEV4YW1wbGVcbiAgICAgICAgICpcbiAgICAgICAgICoge0BleGFtcGxlIHBsYXRmb3JtLWJyb3dzZXIvZG9tL2RlYnVnL3RzL2J5L2J5LnRzIHJlZ2lvbj0nYnlfY3NzJ31cbiAgICAgICAgICovXG4gICAgICAgIEJ5LmNzcyA9IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkZWJ1Z0VsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNQcmVzZW50KGRlYnVnRWxlbWVudC5uYXRpdmVFbGVtZW50KSA/XG4gICAgICAgICAgICAgICAgICAgIGdldERPTSgpLmVsZW1lbnRNYXRjaGVzKGRlYnVnRWxlbWVudC5uYXRpdmVFbGVtZW50LCBzZWxlY3RvcikgOlxuICAgICAgICAgICAgICAgICAgICBmYWxzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYXRjaCBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIGdpdmVuIGRpcmVjdGl2ZSBwcmVzZW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiAjIyBFeGFtcGxlXG4gICAgICAgICAqXG4gICAgICAgICAqIHtAZXhhbXBsZSBwbGF0Zm9ybS1icm93c2VyL2RvbS9kZWJ1Zy90cy9ieS9ieS50cyByZWdpb249J2J5X2RpcmVjdGl2ZSd9XG4gICAgICAgICAqL1xuICAgICAgICBCeS5kaXJlY3RpdmUgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkZWJ1Z0VsZW1lbnQpIHsgcmV0dXJuIGRlYnVnRWxlbWVudC5wcm92aWRlclRva2Vucy5pbmRleE9mKHR5cGUpICE9PSAtMTsgfTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIEJ5O1xuICAgIH0oKSk7XG5cbiAgICB2YXIgX19wbGF0Zm9ybV9icm93c2VyX3ByaXZhdGVfXyA9IHtcbiAgICAgICAgQnJvd3NlclBsYXRmb3JtTG9jYXRpb246IEJyb3dzZXJQbGF0Zm9ybUxvY2F0aW9uLFxuICAgICAgICBEb21BZGFwdGVyOiBEb21BZGFwdGVyLFxuICAgICAgICBCcm93c2VyRG9tQWRhcHRlcjogQnJvd3NlckRvbUFkYXB0ZXIsXG4gICAgICAgIEJyb3dzZXJHZXRUZXN0YWJpbGl0eTogQnJvd3NlckdldFRlc3RhYmlsaXR5LFxuICAgICAgICBnZXRET006IGdldERPTSxcbiAgICAgICAgc2V0Um9vdERvbUFkYXB0ZXI6IHNldFJvb3REb21BZGFwdGVyLFxuICAgICAgICBEb21Sb290UmVuZGVyZXJfOiBEb21Sb290UmVuZGVyZXJfLFxuICAgICAgICBEb21Sb290UmVuZGVyZXI6IERvbVJvb3RSZW5kZXJlcixcbiAgICAgICAgRG9tU2hhcmVkU3R5bGVzSG9zdDogRG9tU2hhcmVkU3R5bGVzSG9zdCxcbiAgICAgICAgU2hhcmVkU3R5bGVzSG9zdDogU2hhcmVkU3R5bGVzSG9zdCxcbiAgICAgICAgRUxFTUVOVF9QUk9CRV9QUk9WSURFUlM6IEVMRU1FTlRfUFJPQkVfUFJPVklERVJTLFxuICAgICAgICBEb21FdmVudHNQbHVnaW46IERvbUV2ZW50c1BsdWdpbixcbiAgICAgICAgS2V5RXZlbnRzUGx1Z2luOiBLZXlFdmVudHNQbHVnaW4sXG4gICAgICAgIEhhbW1lckdlc3R1cmVzUGx1Z2luOiBIYW1tZXJHZXN0dXJlc1BsdWdpbixcbiAgICAgICAgaW5pdERvbUFkYXB0ZXI6IGluaXREb21BZGFwdGVyLFxuICAgICAgICBJTlRFUk5BTF9CUk9XU0VSX1BMQVRGT1JNX1BST1ZJREVSUzogSU5URVJOQUxfQlJPV1NFUl9QTEFURk9STV9QUk9WSURFUlMsXG4gICAgICAgIEJST1dTRVJfU0FOSVRJWkFUSU9OX1BST1ZJREVSUzogQlJPV1NFUl9TQU5JVElaQVRJT05fUFJPVklERVJTXG4gICAgfTtcblxuICAgIGV4cG9ydHMuQnJvd3Nlck1vZHVsZSA9IEJyb3dzZXJNb2R1bGU7XG4gICAgZXhwb3J0cy5wbGF0Zm9ybUJyb3dzZXIgPSBwbGF0Zm9ybUJyb3dzZXI7XG4gICAgZXhwb3J0cy5UaXRsZSA9IFRpdGxlO1xuICAgIGV4cG9ydHMuZGlzYWJsZURlYnVnVG9vbHMgPSBkaXNhYmxlRGVidWdUb29scztcbiAgICBleHBvcnRzLmVuYWJsZURlYnVnVG9vbHMgPSBlbmFibGVEZWJ1Z1Rvb2xzO1xuICAgIGV4cG9ydHMuQW5pbWF0aW9uRHJpdmVyID0gQW5pbWF0aW9uRHJpdmVyO1xuICAgIGV4cG9ydHMuQnkgPSBCeTtcbiAgICBleHBvcnRzLk5nUHJvYmVUb2tlbiA9IE5nUHJvYmVUb2tlbjtcbiAgICBleHBvcnRzLkRPQ1VNRU5UID0gRE9DVU1FTlQ7XG4gICAgZXhwb3J0cy5FVkVOVF9NQU5BR0VSX1BMVUdJTlMgPSBFVkVOVF9NQU5BR0VSX1BMVUdJTlM7XG4gICAgZXhwb3J0cy5FdmVudE1hbmFnZXIgPSBFdmVudE1hbmFnZXI7XG4gICAgZXhwb3J0cy5IQU1NRVJfR0VTVFVSRV9DT05GSUcgPSBIQU1NRVJfR0VTVFVSRV9DT05GSUc7XG4gICAgZXhwb3J0cy5IYW1tZXJHZXN0dXJlQ29uZmlnID0gSGFtbWVyR2VzdHVyZUNvbmZpZztcbiAgICBleHBvcnRzLkRvbVNhbml0aXplciA9IERvbVNhbml0aXplcjtcbiAgICBleHBvcnRzLl9fcGxhdGZvcm1fYnJvd3Nlcl9wcml2YXRlX18gPSBfX3BsYXRmb3JtX2Jyb3dzZXJfcHJpdmF0ZV9fO1xuXG59KSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlci9idW5kbGVzL3BsYXRmb3JtLWJyb3dzZXIudW1kLmpzXG4vLyBtb2R1bGUgaWQgPSAyMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIEBsaWNlbnNlIEFuZ3VsYXIgdjIuMS4yXG4gKiAoYykgMjAxMC0yMDE2IEdvb2dsZSwgSW5jLiBodHRwczovL2FuZ3VsYXIuaW8vXG4gKiBMaWNlbnNlOiBNSVRcbiAqL1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMsIHJlcXVpcmUoJ0Bhbmd1bGFyL2NvcmUnKSkgOlxuICAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnLCAnQGFuZ3VsYXIvY29yZSddLCBmYWN0b3J5KSA6XG4gICAgKGZhY3RvcnkoKGdsb2JhbC5uZyA9IGdsb2JhbC5uZyB8fCB7fSwgZ2xvYmFsLm5nLmNvbW1vbiA9IGdsb2JhbC5uZy5jb21tb24gfHwge30pLGdsb2JhbC5uZy5jb3JlKSk7XG59KHRoaXMsIGZ1bmN0aW9uIChleHBvcnRzLF9hbmd1bGFyX2NvcmUpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIFRoaXMgY2xhc3Mgc2hvdWxkIG5vdCBiZSB1c2VkIGRpcmVjdGx5IGJ5IGFuIGFwcGxpY2F0aW9uIGRldmVsb3Blci4gSW5zdGVhZCwgdXNlXG4gICAgICoge0BsaW5rIExvY2F0aW9ufS5cbiAgICAgKlxuICAgICAqIGBQbGF0Zm9ybUxvY2F0aW9uYCBlbmNhcHN1bGF0ZXMgYWxsIGNhbGxzIHRvIERPTSBhcGlzLCB3aGljaCBhbGxvd3MgdGhlIFJvdXRlciB0byBiZSBwbGF0Zm9ybVxuICAgICAqIGFnbm9zdGljLlxuICAgICAqIFRoaXMgbWVhbnMgdGhhdCB3ZSBjYW4gaGF2ZSBkaWZmZXJlbnQgaW1wbGVtZW50YXRpb24gb2YgYFBsYXRmb3JtTG9jYXRpb25gIGZvciB0aGUgZGlmZmVyZW50XG4gICAgICogcGxhdGZvcm1zXG4gICAgICogdGhhdCBhbmd1bGFyIHN1cHBvcnRzLiBGb3IgZXhhbXBsZSwgdGhlIGRlZmF1bHQgYFBsYXRmb3JtTG9jYXRpb25gIGlzIHtAbGlua1xuICAgICAqIEJyb3dzZXJQbGF0Zm9ybUxvY2F0aW9ufSxcbiAgICAgKiBob3dldmVyIHdoZW4geW91IHJ1biB5b3VyIGFwcCBpbiBhIFdlYldvcmtlciB5b3UgdXNlIHtAbGluayBXZWJXb3JrZXJQbGF0Zm9ybUxvY2F0aW9ufS5cbiAgICAgKlxuICAgICAqIFRoZSBgUGxhdGZvcm1Mb2NhdGlvbmAgY2xhc3MgaXMgdXNlZCBkaXJlY3RseSBieSBhbGwgaW1wbGVtZW50YXRpb25zIG9mIHtAbGluayBMb2NhdGlvblN0cmF0ZWd5fVxuICAgICAqIHdoZW5cbiAgICAgKiB0aGV5IG5lZWQgdG8gaW50ZXJhY3Qgd2l0aCB0aGUgRE9NIGFwaXMgbGlrZSBwdXNoU3RhdGUsIHBvcFN0YXRlLCBldGMuLi5cbiAgICAgKlxuICAgICAqIHtAbGluayBMb2NhdGlvblN0cmF0ZWd5fSBpbiB0dXJuIGlzIHVzZWQgYnkgdGhlIHtAbGluayBMb2NhdGlvbn0gc2VydmljZSB3aGljaCBpcyB1c2VkIGRpcmVjdGx5XG4gICAgICogYnlcbiAgICAgKiB0aGUge0BsaW5rIFJvdXRlcn0gaW4gb3JkZXIgdG8gbmF2aWdhdGUgYmV0d2VlbiByb3V0ZXMuIFNpbmNlIGFsbCBpbnRlcmFjdGlvbnMgYmV0d2VlbiB7QGxpbmtcbiAgICAgKiBSb3V0ZXJ9IC9cbiAgICAgKiB7QGxpbmsgTG9jYXRpb259IC8ge0BsaW5rIExvY2F0aW9uU3RyYXRlZ3l9IGFuZCBET00gYXBpcyBmbG93IHRocm91Z2ggdGhlIGBQbGF0Zm9ybUxvY2F0aW9uYFxuICAgICAqIGNsYXNzXG4gICAgICogdGhleSBhcmUgYWxsIHBsYXRmb3JtIGluZGVwZW5kZW50LlxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBQbGF0Zm9ybUxvY2F0aW9uID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gUGxhdGZvcm1Mb2NhdGlvbigpIHtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUGxhdGZvcm1Mb2NhdGlvbi5wcm90b3R5cGUsIFwicGF0aG5hbWVcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBudWxsOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFBsYXRmb3JtTG9jYXRpb24ucHJvdG90eXBlLCBcInNlYXJjaFwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUGxhdGZvcm1Mb2NhdGlvbi5wcm90b3R5cGUsIFwiaGFzaFwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gUGxhdGZvcm1Mb2NhdGlvbjtcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogYExvY2F0aW9uU3RyYXRlZ3lgIGlzIHJlc3BvbnNpYmxlIGZvciByZXByZXNlbnRpbmcgYW5kIHJlYWRpbmcgcm91dGUgc3RhdGVcbiAgICAgKiBmcm9tIHRoZSBicm93c2VyJ3MgVVJMLiBBbmd1bGFyIHByb3ZpZGVzIHR3byBzdHJhdGVnaWVzOlxuICAgICAqIHtAbGluayBIYXNoTG9jYXRpb25TdHJhdGVneX0gYW5kIHtAbGluayBQYXRoTG9jYXRpb25TdHJhdGVneX0gKGRlZmF1bHQpLlxuICAgICAqXG4gICAgICogVGhpcyBpcyB1c2VkIHVuZGVyIHRoZSBob29kIG9mIHRoZSB7QGxpbmsgTG9jYXRpb259IHNlcnZpY2UuXG4gICAgICpcbiAgICAgKiBBcHBsaWNhdGlvbnMgc2hvdWxkIHVzZSB0aGUge0BsaW5rIFJvdXRlcn0gb3Ige0BsaW5rIExvY2F0aW9ufSBzZXJ2aWNlcyB0b1xuICAgICAqIGludGVyYWN0IHdpdGggYXBwbGljYXRpb24gcm91dGUgc3RhdGUuXG4gICAgICpcbiAgICAgKiBGb3IgaW5zdGFuY2UsIHtAbGluayBIYXNoTG9jYXRpb25TdHJhdGVneX0gcHJvZHVjZXMgVVJMcyBsaWtlXG4gICAgICogYGh0dHA6Ly9leGFtcGxlLmNvbSMvZm9vYCwgYW5kIHtAbGluayBQYXRoTG9jYXRpb25TdHJhdGVneX0gcHJvZHVjZXNcbiAgICAgKiBgaHR0cDovL2V4YW1wbGUuY29tL2Zvb2AgYXMgYW4gZXF1aXZhbGVudCBVUkwuXG4gICAgICpcbiAgICAgKiBTZWUgdGhlc2UgdHdvIGNsYXNzZXMgZm9yIG1vcmUuXG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIExvY2F0aW9uU3RyYXRlZ3kgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBMb2NhdGlvblN0cmF0ZWd5KCkge1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBMb2NhdGlvblN0cmF0ZWd5O1xuICAgIH0oKSk7XG4gICAgLyoqXG4gICAgICogVGhlIGBBUFBfQkFTRV9IUkVGYCB0b2tlbiByZXByZXNlbnRzIHRoZSBiYXNlIGhyZWYgdG8gYmUgdXNlZCB3aXRoIHRoZVxuICAgICAqIHtAbGluayBQYXRoTG9jYXRpb25TdHJhdGVneX0uXG4gICAgICpcbiAgICAgKiBJZiB5b3UncmUgdXNpbmcge0BsaW5rIFBhdGhMb2NhdGlvblN0cmF0ZWd5fSwgeW91IG11c3QgcHJvdmlkZSBhIHByb3ZpZGVyIHRvIGEgc3RyaW5nXG4gICAgICogcmVwcmVzZW50aW5nIHRoZSBVUkwgcHJlZml4IHRoYXQgc2hvdWxkIGJlIHByZXNlcnZlZCB3aGVuIGdlbmVyYXRpbmcgYW5kIHJlY29nbml6aW5nXG4gICAgICogVVJMcy5cbiAgICAgKlxuICAgICAqICMjIyBFeGFtcGxlXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogaW1wb3J0IHtDb21wb25lbnQsIE5nTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbiAgICAgKiBpbXBvcnQge0FQUF9CQVNFX0hSRUZ9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG4gICAgICpcbiAgICAgKiBATmdNb2R1bGUoe1xuICAgICAqICAgcHJvdmlkZXJzOiBbe3Byb3ZpZGU6IEFQUF9CQVNFX0hSRUYsIHVzZVZhbHVlOiAnL215L2FwcCd9XVxuICAgICAqIH0pXG4gICAgICogY2xhc3MgQXBwTW9kdWxlIHt9XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIEFQUF9CQVNFX0hSRUYgPSBuZXcgX2FuZ3VsYXJfY29yZS5PcGFxdWVUb2tlbignYXBwQmFzZUhyZWYnKTtcblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICB2YXIgZ2xvYmFsU2NvcGU7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGlmICh0eXBlb2YgV29ya2VyR2xvYmFsU2NvcGUgIT09ICd1bmRlZmluZWQnICYmIHNlbGYgaW5zdGFuY2VvZiBXb3JrZXJHbG9iYWxTY29wZSkge1xuICAgICAgICAgICAgLy8gVE9ETzogUmVwbGFjZSBhbnkgd2l0aCBXb3JrZXJHbG9iYWxTY29wZSBmcm9tIGxpYi53ZWJ3b3JrZXIuZC50cyAjMzQ5MlxuICAgICAgICAgICAgZ2xvYmFsU2NvcGUgPSBzZWxmO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZ2xvYmFsU2NvcGUgPSBnbG9iYWw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGdsb2JhbFNjb3BlID0gd2luZG93O1xuICAgIH1cbiAgICAvLyBOZWVkIHRvIGRlY2xhcmUgYSBuZXcgdmFyaWFibGUgZm9yIGdsb2JhbCBoZXJlIHNpbmNlIFR5cGVTY3JpcHRcbiAgICAvLyBleHBvcnRzIHRoZSBvcmlnaW5hbCB2YWx1ZSBvZiB0aGUgc3ltYm9sLlxuICAgIHZhciBfZ2xvYmFsID0gZ2xvYmFsU2NvcGU7XG4gICAgZnVuY3Rpb24gZ2V0VHlwZU5hbWVGb3JEZWJ1Z2dpbmcodHlwZSkge1xuICAgICAgICByZXR1cm4gdHlwZVsnbmFtZSddIHx8IHR5cGVvZiB0eXBlO1xuICAgIH1cbiAgICAvLyBUT0RPOiByZW1vdmUgY2FsbHMgdG8gYXNzZXJ0IGluIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRcbiAgICAvLyBOb3RlOiBDYW4ndCBqdXN0IGV4cG9ydCB0aGlzIGFuZCBpbXBvcnQgaW4gaW4gb3RoZXIgZmlsZXNcbiAgICAvLyBhcyBgYXNzZXJ0YCBpcyBhIHJlc2VydmVkIGtleXdvcmQgaW4gRGFydFxuICAgIF9nbG9iYWwuYXNzZXJ0ID0gZnVuY3Rpb24gYXNzZXJ0KGNvbmRpdGlvbikge1xuICAgICAgICAvLyBUT0RPOiB0byBiZSBmaXhlZCBwcm9wZXJseSB2aWEgIzI4MzAsIG5vb3AgZm9yIG5vd1xuICAgIH07XG4gICAgZnVuY3Rpb24gaXNQcmVzZW50KG9iaikge1xuICAgICAgICByZXR1cm4gb2JqICE9IG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzQmxhbmsob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmogPT0gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNEYXRlKG9iaikge1xuICAgICAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgRGF0ZSAmJiAhaXNOYU4ob2JqLnZhbHVlT2YoKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0cmluZ2lmeSh0b2tlbikge1xuICAgICAgICBpZiAodHlwZW9mIHRva2VuID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b2tlbiA9PT0gdW5kZWZpbmVkIHx8IHRva2VuID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gJycgKyB0b2tlbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9rZW4ub3ZlcnJpZGRlbk5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0b2tlbi5vdmVycmlkZGVuTmFtZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9rZW4ubmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRva2VuLm5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlcyA9IHRva2VuLnRvU3RyaW5nKCk7XG4gICAgICAgIHZhciBuZXdMaW5lSW5kZXggPSByZXMuaW5kZXhPZignXFxuJyk7XG4gICAgICAgIHJldHVybiBuZXdMaW5lSW5kZXggPT09IC0xID8gcmVzIDogcmVzLnN1YnN0cmluZygwLCBuZXdMaW5lSW5kZXgpO1xuICAgIH1cbiAgICB2YXIgTnVtYmVyV3JhcHBlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIE51bWJlcldyYXBwZXIoKSB7XG4gICAgICAgIH1cbiAgICAgICAgTnVtYmVyV3JhcHBlci5wYXJzZUludEF1dG9SYWRpeCA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gcGFyc2VJbnQodGV4dCk7XG4gICAgICAgICAgICBpZiAoaXNOYU4ocmVzdWx0KSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbnRlZ2VyIGxpdGVyYWwgd2hlbiBwYXJzaW5nICcgKyB0ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgICAgIE51bWJlcldyYXBwZXIucGFyc2VJbnQgPSBmdW5jdGlvbiAodGV4dCwgcmFkaXgpIHtcbiAgICAgICAgICAgIGlmIChyYWRpeCA9PSAxMCkge1xuICAgICAgICAgICAgICAgIGlmICgvXihcXC18XFwrKT9bMC05XSskLy50ZXN0KHRleHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUludCh0ZXh0LCByYWRpeCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocmFkaXggPT0gMTYpIHtcbiAgICAgICAgICAgICAgICBpZiAoL14oXFwtfFxcKyk/WzAtOUFCQ0RFRmFiY2RlZl0rJC8udGVzdCh0ZXh0KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQodGV4dCwgcmFkaXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBwYXJzZUludCh0ZXh0LCByYWRpeCk7XG4gICAgICAgICAgICAgICAgaWYgKCFpc05hTihyZXN1bHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGludGVnZXIgbGl0ZXJhbCB3aGVuIHBhcnNpbmcgJyArIHRleHQgKyAnIGluIGJhc2UgJyArIHJhZGl4KTtcbiAgICAgICAgfTtcbiAgICAgICAgTnVtYmVyV3JhcHBlci5pc051bWVyaWMgPSBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuICFpc05hTih2YWx1ZSAtIHBhcnNlRmxvYXQodmFsdWUpKTsgfTtcbiAgICAgICAgcmV0dXJuIE51bWJlcldyYXBwZXI7XG4gICAgfSgpKTtcbiAgICBmdW5jdGlvbiBpc0pzT2JqZWN0KG8pIHtcbiAgICAgICAgcmV0dXJuIG8gIT09IG51bGwgJiYgKHR5cGVvZiBvID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBvID09PSAnb2JqZWN0Jyk7XG4gICAgfVxuICAgIHZhciBfc3ltYm9sSXRlcmF0b3IgPSBudWxsO1xuICAgIGZ1bmN0aW9uIGdldFN5bWJvbEl0ZXJhdG9yKCkge1xuICAgICAgICBpZiAoIV9zeW1ib2xJdGVyYXRvcikge1xuICAgICAgICAgICAgaWYgKGdsb2JhbFNjb3BlLlN5bWJvbCAmJiBTeW1ib2wuaXRlcmF0b3IpIHtcbiAgICAgICAgICAgICAgICBfc3ltYm9sSXRlcmF0b3IgPSBTeW1ib2wuaXRlcmF0b3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBlczYtc2hpbSBzcGVjaWZpYyBsb2dpY1xuICAgICAgICAgICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoTWFwLnByb3RvdHlwZSk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5ICE9PSAnZW50cmllcycgJiYga2V5ICE9PSAnc2l6ZScgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIE1hcC5wcm90b3R5cGVba2V5XSA9PT0gTWFwLnByb3RvdHlwZVsnZW50cmllcyddKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfc3ltYm9sSXRlcmF0b3IgPSBrZXk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9zeW1ib2xJdGVyYXRvcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBgTG9jYXRpb25gIGlzIGEgc2VydmljZSB0aGF0IGFwcGxpY2F0aW9ucyBjYW4gdXNlIHRvIGludGVyYWN0IHdpdGggYSBicm93c2VyJ3MgVVJMLlxuICAgICAqIERlcGVuZGluZyBvbiB3aGljaCB7QGxpbmsgTG9jYXRpb25TdHJhdGVneX0gaXMgdXNlZCwgYExvY2F0aW9uYCB3aWxsIGVpdGhlciBwZXJzaXN0XG4gICAgICogdG8gdGhlIFVSTCdzIHBhdGggb3IgdGhlIFVSTCdzIGhhc2ggc2VnbWVudC5cbiAgICAgKlxuICAgICAqIE5vdGU6IGl0J3MgYmV0dGVyIHRvIHVzZSB7QGxpbmsgUm91dGVyI25hdmlnYXRlfSBzZXJ2aWNlIHRvIHRyaWdnZXIgcm91dGUgY2hhbmdlcy4gVXNlXG4gICAgICogYExvY2F0aW9uYCBvbmx5IGlmIHlvdSBuZWVkIHRvIGludGVyYWN0IHdpdGggb3IgY3JlYXRlIG5vcm1hbGl6ZWQgVVJMcyBvdXRzaWRlIG9mXG4gICAgICogcm91dGluZy5cbiAgICAgKlxuICAgICAqIGBMb2NhdGlvbmAgaXMgcmVzcG9uc2libGUgZm9yIG5vcm1hbGl6aW5nIHRoZSBVUkwgYWdhaW5zdCB0aGUgYXBwbGljYXRpb24ncyBiYXNlIGhyZWYuXG4gICAgICogQSBub3JtYWxpemVkIFVSTCBpcyBhYnNvbHV0ZSBmcm9tIHRoZSBVUkwgaG9zdCwgaW5jbHVkZXMgdGhlIGFwcGxpY2F0aW9uJ3MgYmFzZSBocmVmLCBhbmQgaGFzIG5vXG4gICAgICogdHJhaWxpbmcgc2xhc2g6XG4gICAgICogLSBgL215L2FwcC91c2VyLzEyM2AgaXMgbm9ybWFsaXplZFxuICAgICAqIC0gYG15L2FwcC91c2VyLzEyM2AgKippcyBub3QqKiBub3JtYWxpemVkXG4gICAgICogLSBgL215L2FwcC91c2VyLzEyMy9gICoqaXMgbm90Kiogbm9ybWFsaXplZFxuICAgICAqXG4gICAgICogIyMjIEV4YW1wbGVcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIGltcG9ydCB7Q29tcG9uZW50fSBmcm9tICdAYW5ndWxhci9jb3JlJztcbiAgICAgKiBpbXBvcnQge0xvY2F0aW9ufSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuICAgICAqXG4gICAgICogQENvbXBvbmVudCh7c2VsZWN0b3I6ICdhcHAtY29tcG9uZW50J30pXG4gICAgICogY2xhc3MgQXBwQ21wIHtcbiAgICAgKiAgIGNvbnN0cnVjdG9yKGxvY2F0aW9uOiBMb2NhdGlvbikge1xuICAgICAqICAgICBsb2NhdGlvbi5nbygnL2ZvbycpO1xuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgTG9jYXRpb24gPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBMb2NhdGlvbihwbGF0Zm9ybVN0cmF0ZWd5KSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICAgICAgdGhpcy5fc3ViamVjdCA9IG5ldyBfYW5ndWxhcl9jb3JlLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICAgICAgdGhpcy5fcGxhdGZvcm1TdHJhdGVneSA9IHBsYXRmb3JtU3RyYXRlZ3k7XG4gICAgICAgICAgICB2YXIgYnJvd3NlckJhc2VIcmVmID0gdGhpcy5fcGxhdGZvcm1TdHJhdGVneS5nZXRCYXNlSHJlZigpO1xuICAgICAgICAgICAgdGhpcy5fYmFzZUhyZWYgPSBMb2NhdGlvbi5zdHJpcFRyYWlsaW5nU2xhc2goX3N0cmlwSW5kZXhIdG1sKGJyb3dzZXJCYXNlSHJlZikpO1xuICAgICAgICAgICAgdGhpcy5fcGxhdGZvcm1TdHJhdGVneS5vblBvcFN0YXRlKGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgICAgIF90aGlzLl9zdWJqZWN0LmVtaXQoe1xuICAgICAgICAgICAgICAgICAgICAndXJsJzogX3RoaXMucGF0aCh0cnVlKSxcbiAgICAgICAgICAgICAgICAgICAgJ3BvcCc6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICd0eXBlJzogZXYudHlwZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBub3JtYWxpemVkIFVSTCBwYXRoLlxuICAgICAgICAgKi9cbiAgICAgICAgLy8gVE9ETzogdnNhdmtpbi4gUmVtb3ZlIHRoZSBib29sZWFuIGZsYWcgYW5kIGFsd2F5cyBpbmNsdWRlIGhhc2ggb25jZSB0aGUgZGVwcmVjYXRlZCByb3V0ZXIgaXNcbiAgICAgICAgLy8gcmVtb3ZlZC5cbiAgICAgICAgTG9jYXRpb24ucHJvdG90eXBlLnBhdGggPSBmdW5jdGlvbiAoaW5jbHVkZUhhc2gpIHtcbiAgICAgICAgICAgIGlmIChpbmNsdWRlSGFzaCA9PT0gdm9pZCAwKSB7IGluY2x1ZGVIYXNoID0gZmFsc2U7IH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5vcm1hbGl6ZSh0aGlzLl9wbGF0Zm9ybVN0cmF0ZWd5LnBhdGgoaW5jbHVkZUhhc2gpKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5vcm1hbGl6ZXMgdGhlIGdpdmVuIHBhdGggYW5kIGNvbXBhcmVzIHRvIHRoZSBjdXJyZW50IG5vcm1hbGl6ZWQgcGF0aC5cbiAgICAgICAgICovXG4gICAgICAgIExvY2F0aW9uLnByb3RvdHlwZS5pc0N1cnJlbnRQYXRoRXF1YWxUbyA9IGZ1bmN0aW9uIChwYXRoLCBxdWVyeSkge1xuICAgICAgICAgICAgaWYgKHF1ZXJ5ID09PSB2b2lkIDApIHsgcXVlcnkgPSAnJzsgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGF0aCgpID09IHRoaXMubm9ybWFsaXplKHBhdGggKyBMb2NhdGlvbi5ub3JtYWxpemVRdWVyeVBhcmFtcyhxdWVyeSkpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2l2ZW4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgVVJMLCByZXR1cm5zIHRoZSBub3JtYWxpemVkIFVSTCBwYXRoIHdpdGhvdXQgbGVhZGluZyBvclxuICAgICAgICAgKiB0cmFpbGluZyBzbGFzaGVzLlxuICAgICAgICAgKi9cbiAgICAgICAgTG9jYXRpb24ucHJvdG90eXBlLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uICh1cmwpIHtcbiAgICAgICAgICAgIHJldHVybiBMb2NhdGlvbi5zdHJpcFRyYWlsaW5nU2xhc2goX3N0cmlwQmFzZUhyZWYodGhpcy5fYmFzZUhyZWYsIF9zdHJpcEluZGV4SHRtbCh1cmwpKSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHaXZlbiBhIHN0cmluZyByZXByZXNlbnRpbmcgYSBVUkwsIHJldHVybnMgdGhlIHBsYXRmb3JtLXNwZWNpZmljIGV4dGVybmFsIFVSTCBwYXRoLlxuICAgICAgICAgKiBJZiB0aGUgZ2l2ZW4gVVJMIGRvZXNuJ3QgYmVnaW4gd2l0aCBhIGxlYWRpbmcgc2xhc2ggKGAnLydgKSwgdGhpcyBtZXRob2QgYWRkcyBvbmVcbiAgICAgICAgICogYmVmb3JlIG5vcm1hbGl6aW5nLiBUaGlzIG1ldGhvZCB3aWxsIGFsc28gYWRkIGEgaGFzaCBpZiBgSGFzaExvY2F0aW9uU3RyYXRlZ3lgIGlzXG4gICAgICAgICAqIHVzZWQsIG9yIHRoZSBgQVBQX0JBU0VfSFJFRmAgaWYgdGhlIGBQYXRoTG9jYXRpb25TdHJhdGVneWAgaXMgaW4gdXNlLlxuICAgICAgICAgKi9cbiAgICAgICAgTG9jYXRpb24ucHJvdG90eXBlLnByZXBhcmVFeHRlcm5hbFVybCA9IGZ1bmN0aW9uICh1cmwpIHtcbiAgICAgICAgICAgIGlmICh1cmwubGVuZ3RoID4gMCAmJiAhdXJsLnN0YXJ0c1dpdGgoJy8nKSkge1xuICAgICAgICAgICAgICAgIHVybCA9ICcvJyArIHVybDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wbGF0Zm9ybVN0cmF0ZWd5LnByZXBhcmVFeHRlcm5hbFVybCh1cmwpO1xuICAgICAgICB9O1xuICAgICAgICAvLyBUT0RPOiByZW5hbWUgdGhpcyBtZXRob2QgdG8gcHVzaFN0YXRlXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGFuZ2VzIHRoZSBicm93c2VycyBVUkwgdG8gdGhlIG5vcm1hbGl6ZWQgdmVyc2lvbiBvZiB0aGUgZ2l2ZW4gVVJMLCBhbmQgcHVzaGVzIGFcbiAgICAgICAgICogbmV3IGl0ZW0gb250byB0aGUgcGxhdGZvcm0ncyBoaXN0b3J5LlxuICAgICAgICAgKi9cbiAgICAgICAgTG9jYXRpb24ucHJvdG90eXBlLmdvID0gZnVuY3Rpb24gKHBhdGgsIHF1ZXJ5KSB7XG4gICAgICAgICAgICBpZiAocXVlcnkgPT09IHZvaWQgMCkgeyBxdWVyeSA9ICcnOyB9XG4gICAgICAgICAgICB0aGlzLl9wbGF0Zm9ybVN0cmF0ZWd5LnB1c2hTdGF0ZShudWxsLCAnJywgcGF0aCwgcXVlcnkpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2hhbmdlcyB0aGUgYnJvd3NlcnMgVVJMIHRvIHRoZSBub3JtYWxpemVkIHZlcnNpb24gb2YgdGhlIGdpdmVuIFVSTCwgYW5kIHJlcGxhY2VzXG4gICAgICAgICAqIHRoZSB0b3AgaXRlbSBvbiB0aGUgcGxhdGZvcm0ncyBoaXN0b3J5IHN0YWNrLlxuICAgICAgICAgKi9cbiAgICAgICAgTG9jYXRpb24ucHJvdG90eXBlLnJlcGxhY2VTdGF0ZSA9IGZ1bmN0aW9uIChwYXRoLCBxdWVyeSkge1xuICAgICAgICAgICAgaWYgKHF1ZXJ5ID09PSB2b2lkIDApIHsgcXVlcnkgPSAnJzsgfVxuICAgICAgICAgICAgdGhpcy5fcGxhdGZvcm1TdHJhdGVneS5yZXBsYWNlU3RhdGUobnVsbCwgJycsIHBhdGgsIHF1ZXJ5KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5hdmlnYXRlcyBmb3J3YXJkIGluIHRoZSBwbGF0Zm9ybSdzIGhpc3RvcnkuXG4gICAgICAgICAqL1xuICAgICAgICBMb2NhdGlvbi5wcm90b3R5cGUuZm9yd2FyZCA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fcGxhdGZvcm1TdHJhdGVneS5mb3J3YXJkKCk7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOYXZpZ2F0ZXMgYmFjayBpbiB0aGUgcGxhdGZvcm0ncyBoaXN0b3J5LlxuICAgICAgICAgKi9cbiAgICAgICAgTG9jYXRpb24ucHJvdG90eXBlLmJhY2sgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX3BsYXRmb3JtU3RyYXRlZ3kuYmFjaygpOyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU3Vic2NyaWJlIHRvIHRoZSBwbGF0Zm9ybSdzIGBwb3BTdGF0ZWAgZXZlbnRzLlxuICAgICAgICAgKi9cbiAgICAgICAgTG9jYXRpb24ucHJvdG90eXBlLnN1YnNjcmliZSA9IGZ1bmN0aW9uIChvbk5leHQsIG9uVGhyb3csIG9uUmV0dXJuKSB7XG4gICAgICAgICAgICBpZiAob25UaHJvdyA9PT0gdm9pZCAwKSB7IG9uVGhyb3cgPSBudWxsOyB9XG4gICAgICAgICAgICBpZiAob25SZXR1cm4gPT09IHZvaWQgMCkgeyBvblJldHVybiA9IG51bGw7IH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdWJqZWN0LnN1YnNjcmliZSh7IG5leHQ6IG9uTmV4dCwgZXJyb3I6IG9uVGhyb3csIGNvbXBsZXRlOiBvblJldHVybiB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdpdmVuIGEgc3RyaW5nIG9mIHVybCBwYXJhbWV0ZXJzLCBwcmVwZW5kIHdpdGggJz8nIGlmIG5lZWRlZCwgb3RoZXJ3aXNlIHJldHVybiBwYXJhbWV0ZXJzIGFzXG4gICAgICAgICAqIGlzLlxuICAgICAgICAgKi9cbiAgICAgICAgTG9jYXRpb24ubm9ybWFsaXplUXVlcnlQYXJhbXMgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgICAgICByZXR1cm4gKHBhcmFtcy5sZW5ndGggPiAwICYmIHBhcmFtcy5zdWJzdHJpbmcoMCwgMSkgIT0gJz8nKSA/ICgnPycgKyBwYXJhbXMpIDogcGFyYW1zO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2l2ZW4gMiBwYXJ0cyBvZiBhIHVybCwgam9pbiB0aGVtIHdpdGggYSBzbGFzaCBpZiBuZWVkZWQuXG4gICAgICAgICAqL1xuICAgICAgICBMb2NhdGlvbi5qb2luV2l0aFNsYXNoID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgICAgIGlmIChzdGFydC5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZW5kLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXJ0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHNsYXNoZXMgPSAwO1xuICAgICAgICAgICAgaWYgKHN0YXJ0LmVuZHNXaXRoKCcvJykpIHtcbiAgICAgICAgICAgICAgICBzbGFzaGVzKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZW5kLnN0YXJ0c1dpdGgoJy8nKSkge1xuICAgICAgICAgICAgICAgIHNsYXNoZXMrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzbGFzaGVzID09IDIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhcnQgKyBlbmQuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNsYXNoZXMgPT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdGFydCArIGVuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdGFydCArICcvJyArIGVuZDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHVybCBoYXMgYSB0cmFpbGluZyBzbGFzaCwgcmVtb3ZlIGl0LCBvdGhlcndpc2UgcmV0dXJuIHVybCBhcyBpcy5cbiAgICAgICAgICovXG4gICAgICAgIExvY2F0aW9uLnN0cmlwVHJhaWxpbmdTbGFzaCA9IGZ1bmN0aW9uICh1cmwpIHtcbiAgICAgICAgICAgIGlmICgvXFwvJC9nLnRlc3QodXJsKSkge1xuICAgICAgICAgICAgICAgIHVybCA9IHVybC5zdWJzdHJpbmcoMCwgdXJsLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHVybDtcbiAgICAgICAgfTtcbiAgICAgICAgTG9jYXRpb24uZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3RhYmxlIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBMb2NhdGlvbi5jdG9yUGFyYW1ldGVycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogTG9jYXRpb25TdHJhdGVneSwgfSxcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIExvY2F0aW9uO1xuICAgIH0oKSk7XG4gICAgZnVuY3Rpb24gX3N0cmlwQmFzZUhyZWYoYmFzZUhyZWYsIHVybCkge1xuICAgICAgICBpZiAoYmFzZUhyZWYubGVuZ3RoID4gMCAmJiB1cmwuc3RhcnRzV2l0aChiYXNlSHJlZikpIHtcbiAgICAgICAgICAgIHJldHVybiB1cmwuc3Vic3RyaW5nKGJhc2VIcmVmLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVybDtcbiAgICB9XG4gICAgZnVuY3Rpb24gX3N0cmlwSW5kZXhIdG1sKHVybCkge1xuICAgICAgICBpZiAoL1xcL2luZGV4Lmh0bWwkL2cudGVzdCh1cmwpKSB7XG4gICAgICAgICAgICAvLyAnL2luZGV4Lmh0bWwnLmxlbmd0aCA9PSAxMVxuICAgICAgICAgICAgcmV0dXJuIHVybC5zdWJzdHJpbmcoMCwgdXJsLmxlbmd0aCAtIDExKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXJsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICB2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogYEhhc2hMb2NhdGlvblN0cmF0ZWd5YCBpcyBhIHtAbGluayBMb2NhdGlvblN0cmF0ZWd5fSB1c2VkIHRvIGNvbmZpZ3VyZSB0aGVcbiAgICAgKiB7QGxpbmsgTG9jYXRpb259IHNlcnZpY2UgdG8gcmVwcmVzZW50IGl0cyBzdGF0ZSBpbiB0aGVcbiAgICAgKiBbaGFzaCBmcmFnbWVudF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVW5pZm9ybV9SZXNvdXJjZV9Mb2NhdG9yI1N5bnRheClcbiAgICAgKiBvZiB0aGUgYnJvd3NlcidzIFVSTC5cbiAgICAgKlxuICAgICAqIEZvciBpbnN0YW5jZSwgaWYgeW91IGNhbGwgYGxvY2F0aW9uLmdvKCcvZm9vJylgLCB0aGUgYnJvd3NlcidzIFVSTCB3aWxsIGJlY29tZVxuICAgICAqIGBleGFtcGxlLmNvbSMvZm9vYC5cbiAgICAgKlxuICAgICAqICMjIyBFeGFtcGxlXG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiBpbXBvcnQge0NvbXBvbmVudCwgTmdNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuICAgICAqIGltcG9ydCB7XG4gICAgICogICBMb2NhdGlvblN0cmF0ZWd5LFxuICAgICAqICAgSGFzaExvY2F0aW9uU3RyYXRlZ3lcbiAgICAgKiB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG4gICAgICpcbiAgICAgKiBATmdNb2R1bGUoe1xuICAgICAqICAgcHJvdmlkZXJzOiBbe3Byb3ZpZGU6IExvY2F0aW9uU3RyYXRlZ3ksIHVzZUNsYXNzOiBIYXNoTG9jYXRpb25TdHJhdGVneX1dXG4gICAgICogfSlcbiAgICAgKiBjbGFzcyBBcHBNb2R1bGUge31cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgSGFzaExvY2F0aW9uU3RyYXRlZ3kgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMoSGFzaExvY2F0aW9uU3RyYXRlZ3ksIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIEhhc2hMb2NhdGlvblN0cmF0ZWd5KF9wbGF0Zm9ybUxvY2F0aW9uLCBfYmFzZUhyZWYpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5fcGxhdGZvcm1Mb2NhdGlvbiA9IF9wbGF0Zm9ybUxvY2F0aW9uO1xuICAgICAgICAgICAgdGhpcy5fYmFzZUhyZWYgPSAnJztcbiAgICAgICAgICAgIGlmIChpc1ByZXNlbnQoX2Jhc2VIcmVmKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Jhc2VIcmVmID0gX2Jhc2VIcmVmO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIEhhc2hMb2NhdGlvblN0cmF0ZWd5LnByb3RvdHlwZS5vblBvcFN0YXRlID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICB0aGlzLl9wbGF0Zm9ybUxvY2F0aW9uLm9uUG9wU3RhdGUoZm4pO1xuICAgICAgICAgICAgdGhpcy5fcGxhdGZvcm1Mb2NhdGlvbi5vbkhhc2hDaGFuZ2UoZm4pO1xuICAgICAgICB9O1xuICAgICAgICBIYXNoTG9jYXRpb25TdHJhdGVneS5wcm90b3R5cGUuZ2V0QmFzZUhyZWYgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9iYXNlSHJlZjsgfTtcbiAgICAgICAgSGFzaExvY2F0aW9uU3RyYXRlZ3kucHJvdG90eXBlLnBhdGggPSBmdW5jdGlvbiAoaW5jbHVkZUhhc2gpIHtcbiAgICAgICAgICAgIGlmIChpbmNsdWRlSGFzaCA9PT0gdm9pZCAwKSB7IGluY2x1ZGVIYXNoID0gZmFsc2U7IH1cbiAgICAgICAgICAgIC8vIHRoZSBoYXNoIHZhbHVlIGlzIGFsd2F5cyBwcmVmaXhlZCB3aXRoIGEgYCNgXG4gICAgICAgICAgICAvLyBhbmQgaWYgaXQgaXMgZW1wdHkgdGhlbiBpdCB3aWxsIHN0YXkgZW1wdHlcbiAgICAgICAgICAgIHZhciBwYXRoID0gdGhpcy5fcGxhdGZvcm1Mb2NhdGlvbi5oYXNoO1xuICAgICAgICAgICAgaWYgKCFpc1ByZXNlbnQocGF0aCkpXG4gICAgICAgICAgICAgICAgcGF0aCA9ICcjJztcbiAgICAgICAgICAgIHJldHVybiBwYXRoLmxlbmd0aCA+IDAgPyBwYXRoLnN1YnN0cmluZygxKSA6IHBhdGg7XG4gICAgICAgIH07XG4gICAgICAgIEhhc2hMb2NhdGlvblN0cmF0ZWd5LnByb3RvdHlwZS5wcmVwYXJlRXh0ZXJuYWxVcmwgPSBmdW5jdGlvbiAoaW50ZXJuYWwpIHtcbiAgICAgICAgICAgIHZhciB1cmwgPSBMb2NhdGlvbi5qb2luV2l0aFNsYXNoKHRoaXMuX2Jhc2VIcmVmLCBpbnRlcm5hbCk7XG4gICAgICAgICAgICByZXR1cm4gdXJsLmxlbmd0aCA+IDAgPyAoJyMnICsgdXJsKSA6IHVybDtcbiAgICAgICAgfTtcbiAgICAgICAgSGFzaExvY2F0aW9uU3RyYXRlZ3kucHJvdG90eXBlLnB1c2hTdGF0ZSA9IGZ1bmN0aW9uIChzdGF0ZSwgdGl0bGUsIHBhdGgsIHF1ZXJ5UGFyYW1zKSB7XG4gICAgICAgICAgICB2YXIgdXJsID0gdGhpcy5wcmVwYXJlRXh0ZXJuYWxVcmwocGF0aCArIExvY2F0aW9uLm5vcm1hbGl6ZVF1ZXJ5UGFyYW1zKHF1ZXJ5UGFyYW1zKSk7XG4gICAgICAgICAgICBpZiAodXJsLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgdXJsID0gdGhpcy5fcGxhdGZvcm1Mb2NhdGlvbi5wYXRobmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3BsYXRmb3JtTG9jYXRpb24ucHVzaFN0YXRlKHN0YXRlLCB0aXRsZSwgdXJsKTtcbiAgICAgICAgfTtcbiAgICAgICAgSGFzaExvY2F0aW9uU3RyYXRlZ3kucHJvdG90eXBlLnJlcGxhY2VTdGF0ZSA9IGZ1bmN0aW9uIChzdGF0ZSwgdGl0bGUsIHBhdGgsIHF1ZXJ5UGFyYW1zKSB7XG4gICAgICAgICAgICB2YXIgdXJsID0gdGhpcy5wcmVwYXJlRXh0ZXJuYWxVcmwocGF0aCArIExvY2F0aW9uLm5vcm1hbGl6ZVF1ZXJ5UGFyYW1zKHF1ZXJ5UGFyYW1zKSk7XG4gICAgICAgICAgICBpZiAodXJsLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgdXJsID0gdGhpcy5fcGxhdGZvcm1Mb2NhdGlvbi5wYXRobmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3BsYXRmb3JtTG9jYXRpb24ucmVwbGFjZVN0YXRlKHN0YXRlLCB0aXRsZSwgdXJsKTtcbiAgICAgICAgfTtcbiAgICAgICAgSGFzaExvY2F0aW9uU3RyYXRlZ3kucHJvdG90eXBlLmZvcndhcmQgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX3BsYXRmb3JtTG9jYXRpb24uZm9yd2FyZCgpOyB9O1xuICAgICAgICBIYXNoTG9jYXRpb25TdHJhdGVneS5wcm90b3R5cGUuYmFjayA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fcGxhdGZvcm1Mb2NhdGlvbi5iYWNrKCk7IH07XG4gICAgICAgIEhhc2hMb2NhdGlvblN0cmF0ZWd5LmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0YWJsZSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgSGFzaExvY2F0aW9uU3RyYXRlZ3kuY3RvclBhcmFtZXRlcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IFBsYXRmb3JtTG9jYXRpb24sIH0sXG4gICAgICAgICAgICB7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5PcHRpb25hbCB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0LCBhcmdzOiBbQVBQX0JBU0VfSFJFRixdIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gSGFzaExvY2F0aW9uU3RyYXRlZ3k7XG4gICAgfShMb2NhdGlvblN0cmF0ZWd5KSk7XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgdmFyIF9fZXh0ZW5kcyQxID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogYFBhdGhMb2NhdGlvblN0cmF0ZWd5YCBpcyBhIHtAbGluayBMb2NhdGlvblN0cmF0ZWd5fSB1c2VkIHRvIGNvbmZpZ3VyZSB0aGVcbiAgICAgKiB7QGxpbmsgTG9jYXRpb259IHNlcnZpY2UgdG8gcmVwcmVzZW50IGl0cyBzdGF0ZSBpbiB0aGVcbiAgICAgKiBbcGF0aF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVW5pZm9ybV9SZXNvdXJjZV9Mb2NhdG9yI1N5bnRheCkgb2YgdGhlXG4gICAgICogYnJvd3NlcidzIFVSTC5cbiAgICAgKlxuICAgICAqIGBQYXRoTG9jYXRpb25TdHJhdGVneWAgaXMgdGhlIGRlZmF1bHQgYmluZGluZyBmb3Ige0BsaW5rIExvY2F0aW9uU3RyYXRlZ3l9XG4gICAgICogcHJvdmlkZWQgaW4ge0BsaW5rIFJPVVRFUl9QUk9WSURFUlN9LlxuICAgICAqXG4gICAgICogSWYgeW91J3JlIHVzaW5nIGBQYXRoTG9jYXRpb25TdHJhdGVneWAsIHlvdSBtdXN0IHByb3ZpZGUgYSB7QGxpbmsgQVBQX0JBU0VfSFJFRn1cbiAgICAgKiBvciBhZGQgYSBiYXNlIGVsZW1lbnQgdG8gdGhlIGRvY3VtZW50LiBUaGlzIFVSTCBwcmVmaXggdGhhdCB3aWxsIGJlIHByZXNlcnZlZFxuICAgICAqIHdoZW4gZ2VuZXJhdGluZyBhbmQgcmVjb2duaXppbmcgVVJMcy5cbiAgICAgKlxuICAgICAqIEZvciBpbnN0YW5jZSwgaWYgeW91IHByb3ZpZGUgYW4gYEFQUF9CQVNFX0hSRUZgIG9mIGAnL215L2FwcCdgIGFuZCBjYWxsXG4gICAgICogYGxvY2F0aW9uLmdvKCcvZm9vJylgLCB0aGUgYnJvd3NlcidzIFVSTCB3aWxsIGJlY29tZVxuICAgICAqIGBleGFtcGxlLmNvbS9teS9hcHAvZm9vYC5cbiAgICAgKlxuICAgICAqIFNpbWlsYXJseSwgaWYgeW91IGFkZCBgPGJhc2UgaHJlZj0nL215L2FwcCcvPmAgdG8gdGhlIGRvY3VtZW50IGFuZCBjYWxsXG4gICAgICogYGxvY2F0aW9uLmdvKCcvZm9vJylgLCB0aGUgYnJvd3NlcidzIFVSTCB3aWxsIGJlY29tZVxuICAgICAqIGBleGFtcGxlLmNvbS9teS9hcHAvZm9vYC5cbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgUGF0aExvY2F0aW9uU3RyYXRlZ3kgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMkMShQYXRoTG9jYXRpb25TdHJhdGVneSwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gUGF0aExvY2F0aW9uU3RyYXRlZ3koX3BsYXRmb3JtTG9jYXRpb24sIGhyZWYpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5fcGxhdGZvcm1Mb2NhdGlvbiA9IF9wbGF0Zm9ybUxvY2F0aW9uO1xuICAgICAgICAgICAgaWYgKGlzQmxhbmsoaHJlZikpIHtcbiAgICAgICAgICAgICAgICBocmVmID0gdGhpcy5fcGxhdGZvcm1Mb2NhdGlvbi5nZXRCYXNlSHJlZkZyb21ET00oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0JsYW5rKGhyZWYpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gYmFzZSBocmVmIHNldC4gUGxlYXNlIHByb3ZpZGUgYSB2YWx1ZSBmb3IgdGhlIEFQUF9CQVNFX0hSRUYgdG9rZW4gb3IgYWRkIGEgYmFzZSBlbGVtZW50IHRvIHRoZSBkb2N1bWVudC5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9iYXNlSHJlZiA9IGhyZWY7XG4gICAgICAgIH1cbiAgICAgICAgUGF0aExvY2F0aW9uU3RyYXRlZ3kucHJvdG90eXBlLm9uUG9wU3RhdGUgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgIHRoaXMuX3BsYXRmb3JtTG9jYXRpb24ub25Qb3BTdGF0ZShmbik7XG4gICAgICAgICAgICB0aGlzLl9wbGF0Zm9ybUxvY2F0aW9uLm9uSGFzaENoYW5nZShmbik7XG4gICAgICAgIH07XG4gICAgICAgIFBhdGhMb2NhdGlvblN0cmF0ZWd5LnByb3RvdHlwZS5nZXRCYXNlSHJlZiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2Jhc2VIcmVmOyB9O1xuICAgICAgICBQYXRoTG9jYXRpb25TdHJhdGVneS5wcm90b3R5cGUucHJlcGFyZUV4dGVybmFsVXJsID0gZnVuY3Rpb24gKGludGVybmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gTG9jYXRpb24uam9pbldpdGhTbGFzaCh0aGlzLl9iYXNlSHJlZiwgaW50ZXJuYWwpO1xuICAgICAgICB9O1xuICAgICAgICBQYXRoTG9jYXRpb25TdHJhdGVneS5wcm90b3R5cGUucGF0aCA9IGZ1bmN0aW9uIChpbmNsdWRlSGFzaCkge1xuICAgICAgICAgICAgaWYgKGluY2x1ZGVIYXNoID09PSB2b2lkIDApIHsgaW5jbHVkZUhhc2ggPSBmYWxzZTsgfVxuICAgICAgICAgICAgdmFyIHBhdGhuYW1lID0gdGhpcy5fcGxhdGZvcm1Mb2NhdGlvbi5wYXRobmFtZSArXG4gICAgICAgICAgICAgICAgTG9jYXRpb24ubm9ybWFsaXplUXVlcnlQYXJhbXModGhpcy5fcGxhdGZvcm1Mb2NhdGlvbi5zZWFyY2gpO1xuICAgICAgICAgICAgdmFyIGhhc2ggPSB0aGlzLl9wbGF0Zm9ybUxvY2F0aW9uLmhhc2g7XG4gICAgICAgICAgICByZXR1cm4gaGFzaCAmJiBpbmNsdWRlSGFzaCA/IFwiXCIgKyBwYXRobmFtZSArIGhhc2ggOiBwYXRobmFtZTtcbiAgICAgICAgfTtcbiAgICAgICAgUGF0aExvY2F0aW9uU3RyYXRlZ3kucHJvdG90eXBlLnB1c2hTdGF0ZSA9IGZ1bmN0aW9uIChzdGF0ZSwgdGl0bGUsIHVybCwgcXVlcnlQYXJhbXMpIHtcbiAgICAgICAgICAgIHZhciBleHRlcm5hbFVybCA9IHRoaXMucHJlcGFyZUV4dGVybmFsVXJsKHVybCArIExvY2F0aW9uLm5vcm1hbGl6ZVF1ZXJ5UGFyYW1zKHF1ZXJ5UGFyYW1zKSk7XG4gICAgICAgICAgICB0aGlzLl9wbGF0Zm9ybUxvY2F0aW9uLnB1c2hTdGF0ZShzdGF0ZSwgdGl0bGUsIGV4dGVybmFsVXJsKTtcbiAgICAgICAgfTtcbiAgICAgICAgUGF0aExvY2F0aW9uU3RyYXRlZ3kucHJvdG90eXBlLnJlcGxhY2VTdGF0ZSA9IGZ1bmN0aW9uIChzdGF0ZSwgdGl0bGUsIHVybCwgcXVlcnlQYXJhbXMpIHtcbiAgICAgICAgICAgIHZhciBleHRlcm5hbFVybCA9IHRoaXMucHJlcGFyZUV4dGVybmFsVXJsKHVybCArIExvY2F0aW9uLm5vcm1hbGl6ZVF1ZXJ5UGFyYW1zKHF1ZXJ5UGFyYW1zKSk7XG4gICAgICAgICAgICB0aGlzLl9wbGF0Zm9ybUxvY2F0aW9uLnJlcGxhY2VTdGF0ZShzdGF0ZSwgdGl0bGUsIGV4dGVybmFsVXJsKTtcbiAgICAgICAgfTtcbiAgICAgICAgUGF0aExvY2F0aW9uU3RyYXRlZ3kucHJvdG90eXBlLmZvcndhcmQgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX3BsYXRmb3JtTG9jYXRpb24uZm9yd2FyZCgpOyB9O1xuICAgICAgICBQYXRoTG9jYXRpb25TdHJhdGVneS5wcm90b3R5cGUuYmFjayA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fcGxhdGZvcm1Mb2NhdGlvbi5iYWNrKCk7IH07XG4gICAgICAgIFBhdGhMb2NhdGlvblN0cmF0ZWd5LmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0YWJsZSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgUGF0aExvY2F0aW9uU3RyYXRlZ3kuY3RvclBhcmFtZXRlcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IFBsYXRmb3JtTG9jYXRpb24sIH0sXG4gICAgICAgICAgICB7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5PcHRpb25hbCB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0LCBhcmdzOiBbQVBQX0JBU0VfSFJFRixdIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gUGF0aExvY2F0aW9uU3RyYXRlZ3k7XG4gICAgfShMb2NhdGlvblN0cmF0ZWd5KSk7XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgdmFyIF9fZXh0ZW5kcyQyID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIHZhciBOZ0xvY2FsaXphdGlvbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIE5nTG9jYWxpemF0aW9uKCkge1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBOZ0xvY2FsaXphdGlvbjtcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHBsdXJhbCBjYXRlZ29yeSBmb3IgYSBnaXZlbiB2YWx1ZS5cbiAgICAgKiAtIFwiPXZhbHVlXCIgd2hlbiB0aGUgY2FzZSBleGlzdHMsXG4gICAgICogLSB0aGUgcGx1cmFsIGNhdGVnb3J5IG90aGVyd2lzZVxuICAgICAqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0UGx1cmFsQ2F0ZWdvcnkodmFsdWUsIGNhc2VzLCBuZ0xvY2FsaXphdGlvbikge1xuICAgICAgICB2YXIgbmJDYXNlID0gXCI9XCIgKyB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGNhc2VzLmluZGV4T2YobmJDYXNlKSA+IC0xID8gbmJDYXNlIDogbmdMb2NhbGl6YXRpb24uZ2V0UGx1cmFsQ2F0ZWdvcnkodmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBwbHVyYWwgY2FzZSBiYXNlZCBvbiB0aGUgbG9jYWxlXG4gICAgICpcbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgdmFyIE5nTG9jYWxlTG9jYWxpemF0aW9uID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDIoTmdMb2NhbGVMb2NhbGl6YXRpb24sIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIE5nTG9jYWxlTG9jYWxpemF0aW9uKF9sb2NhbGUpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5fbG9jYWxlID0gX2xvY2FsZTtcbiAgICAgICAgfVxuICAgICAgICBOZ0xvY2FsZUxvY2FsaXphdGlvbi5wcm90b3R5cGUuZ2V0UGx1cmFsQ2F0ZWdvcnkgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBwbHVyYWwgPSBnZXRQbHVyYWxDYXNlKHRoaXMuX2xvY2FsZSwgdmFsdWUpO1xuICAgICAgICAgICAgc3dpdGNoIChwbHVyYWwpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFBsdXJhbC5aZXJvOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3plcm8nO1xuICAgICAgICAgICAgICAgIGNhc2UgUGx1cmFsLk9uZTpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdvbmUnO1xuICAgICAgICAgICAgICAgIGNhc2UgUGx1cmFsLlR3bzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICd0d28nO1xuICAgICAgICAgICAgICAgIGNhc2UgUGx1cmFsLkZldzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdmZXcnO1xuICAgICAgICAgICAgICAgIGNhc2UgUGx1cmFsLk1hbnk6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnbWFueSc7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdvdGhlcic7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIE5nTG9jYWxlTG9jYWxpemF0aW9uLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0YWJsZSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgTmdMb2NhbGVMb2NhbGl6YXRpb24uY3RvclBhcmFtZXRlcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3QsIGFyZ3M6IFtfYW5ndWxhcl9jb3JlLkxPQ0FMRV9JRCxdIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gTmdMb2NhbGVMb2NhbGl6YXRpb247XG4gICAgfShOZ0xvY2FsaXphdGlvbikpO1xuICAgIC8vIFRoaXMgaXMgZ2VuZXJhdGVkIGNvZGUgRE8gTk9UIE1PRElGWVxuICAgIC8vIHNlZSBhbmd1bGFyMi9zY3JpcHQvY2xkci9nZW5fcGx1cmFsX3J1bGVzLmpzXG4gICAgLyoqIEBleHBlcmltZW50YWwgKi9cbiAgICB2YXIgUGx1cmFsO1xuICAgIChmdW5jdGlvbiAoUGx1cmFsKSB7XG4gICAgICAgIFBsdXJhbFtQbHVyYWxbXCJaZXJvXCJdID0gMF0gPSBcIlplcm9cIjtcbiAgICAgICAgUGx1cmFsW1BsdXJhbFtcIk9uZVwiXSA9IDFdID0gXCJPbmVcIjtcbiAgICAgICAgUGx1cmFsW1BsdXJhbFtcIlR3b1wiXSA9IDJdID0gXCJUd29cIjtcbiAgICAgICAgUGx1cmFsW1BsdXJhbFtcIkZld1wiXSA9IDNdID0gXCJGZXdcIjtcbiAgICAgICAgUGx1cmFsW1BsdXJhbFtcIk1hbnlcIl0gPSA0XSA9IFwiTWFueVwiO1xuICAgICAgICBQbHVyYWxbUGx1cmFsW1wiT3RoZXJcIl0gPSA1XSA9IFwiT3RoZXJcIjtcbiAgICB9KShQbHVyYWwgfHwgKFBsdXJhbCA9IHt9KSk7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcGx1cmFsIGNhc2UgYmFzZWQgb24gdGhlIGxvY2FsZVxuICAgICAqXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFBsdXJhbENhc2UobG9jYWxlLCBuTGlrZSkge1xuICAgICAgICAvLyBUT0RPKHZpY2IpOiBsYXp5IGNvbXB1dGVcbiAgICAgICAgaWYgKHR5cGVvZiBuTGlrZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIG5MaWtlID0gcGFyc2VJbnQobkxpa2UsIDEwKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbiA9IG5MaWtlO1xuICAgICAgICB2YXIgbkRlY2ltYWwgPSBuLnRvU3RyaW5nKCkucmVwbGFjZSgvXlteLl0qXFwuPy8sICcnKTtcbiAgICAgICAgdmFyIGkgPSBNYXRoLmZsb29yKE1hdGguYWJzKG4pKTtcbiAgICAgICAgdmFyIHYgPSBuRGVjaW1hbC5sZW5ndGg7XG4gICAgICAgIHZhciBmID0gcGFyc2VJbnQobkRlY2ltYWwsIDEwKTtcbiAgICAgICAgdmFyIHQgPSBwYXJzZUludChuLnRvU3RyaW5nKCkucmVwbGFjZSgvXlteLl0qXFwuP3wwKyQvZywgJycpLCAxMCkgfHwgMDtcbiAgICAgICAgdmFyIGxhbmcgPSBsb2NhbGUuc3BsaXQoJy0nKVswXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBzd2l0Y2ggKGxhbmcpIHtcbiAgICAgICAgICAgIGNhc2UgJ2FmJzpcbiAgICAgICAgICAgIGNhc2UgJ2FzYSc6XG4gICAgICAgICAgICBjYXNlICdheic6XG4gICAgICAgICAgICBjYXNlICdiZW0nOlxuICAgICAgICAgICAgY2FzZSAnYmV6JzpcbiAgICAgICAgICAgIGNhc2UgJ2JnJzpcbiAgICAgICAgICAgIGNhc2UgJ2JyeCc6XG4gICAgICAgICAgICBjYXNlICdjZSc6XG4gICAgICAgICAgICBjYXNlICdjZ2cnOlxuICAgICAgICAgICAgY2FzZSAnY2hyJzpcbiAgICAgICAgICAgIGNhc2UgJ2NrYic6XG4gICAgICAgICAgICBjYXNlICdlZSc6XG4gICAgICAgICAgICBjYXNlICdlbCc6XG4gICAgICAgICAgICBjYXNlICdlbyc6XG4gICAgICAgICAgICBjYXNlICdlcyc6XG4gICAgICAgICAgICBjYXNlICdldSc6XG4gICAgICAgICAgICBjYXNlICdmbyc6XG4gICAgICAgICAgICBjYXNlICdmdXInOlxuICAgICAgICAgICAgY2FzZSAnZ3N3JzpcbiAgICAgICAgICAgIGNhc2UgJ2hhJzpcbiAgICAgICAgICAgIGNhc2UgJ2hhdyc6XG4gICAgICAgICAgICBjYXNlICdodSc6XG4gICAgICAgICAgICBjYXNlICdqZ28nOlxuICAgICAgICAgICAgY2FzZSAnam1jJzpcbiAgICAgICAgICAgIGNhc2UgJ2thJzpcbiAgICAgICAgICAgIGNhc2UgJ2trJzpcbiAgICAgICAgICAgIGNhc2UgJ2traic6XG4gICAgICAgICAgICBjYXNlICdrbCc6XG4gICAgICAgICAgICBjYXNlICdrcyc6XG4gICAgICAgICAgICBjYXNlICdrc2InOlxuICAgICAgICAgICAgY2FzZSAna3knOlxuICAgICAgICAgICAgY2FzZSAnbGInOlxuICAgICAgICAgICAgY2FzZSAnbGcnOlxuICAgICAgICAgICAgY2FzZSAnbWFzJzpcbiAgICAgICAgICAgIGNhc2UgJ21nbyc6XG4gICAgICAgICAgICBjYXNlICdtbCc6XG4gICAgICAgICAgICBjYXNlICdtbic6XG4gICAgICAgICAgICBjYXNlICduYic6XG4gICAgICAgICAgICBjYXNlICduZCc6XG4gICAgICAgICAgICBjYXNlICduZSc6XG4gICAgICAgICAgICBjYXNlICdubic6XG4gICAgICAgICAgICBjYXNlICdubmgnOlxuICAgICAgICAgICAgY2FzZSAnbnluJzpcbiAgICAgICAgICAgIGNhc2UgJ29tJzpcbiAgICAgICAgICAgIGNhc2UgJ29yJzpcbiAgICAgICAgICAgIGNhc2UgJ29zJzpcbiAgICAgICAgICAgIGNhc2UgJ3BzJzpcbiAgICAgICAgICAgIGNhc2UgJ3JtJzpcbiAgICAgICAgICAgIGNhc2UgJ3JvZic6XG4gICAgICAgICAgICBjYXNlICdyd2snOlxuICAgICAgICAgICAgY2FzZSAnc2FxJzpcbiAgICAgICAgICAgIGNhc2UgJ3NlaCc6XG4gICAgICAgICAgICBjYXNlICdzbic6XG4gICAgICAgICAgICBjYXNlICdzbyc6XG4gICAgICAgICAgICBjYXNlICdzcSc6XG4gICAgICAgICAgICBjYXNlICd0YSc6XG4gICAgICAgICAgICBjYXNlICd0ZSc6XG4gICAgICAgICAgICBjYXNlICd0ZW8nOlxuICAgICAgICAgICAgY2FzZSAndGsnOlxuICAgICAgICAgICAgY2FzZSAndHInOlxuICAgICAgICAgICAgY2FzZSAndWcnOlxuICAgICAgICAgICAgY2FzZSAndXonOlxuICAgICAgICAgICAgY2FzZSAndm8nOlxuICAgICAgICAgICAgY2FzZSAndnVuJzpcbiAgICAgICAgICAgIGNhc2UgJ3dhZSc6XG4gICAgICAgICAgICBjYXNlICd4b2cnOlxuICAgICAgICAgICAgICAgIGlmIChuID09PSAxKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk9uZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk90aGVyO1xuICAgICAgICAgICAgY2FzZSAnYWdxJzpcbiAgICAgICAgICAgIGNhc2UgJ2Jhcyc6XG4gICAgICAgICAgICBjYXNlICdjdSc6XG4gICAgICAgICAgICBjYXNlICdkYXYnOlxuICAgICAgICAgICAgY2FzZSAnZGplJzpcbiAgICAgICAgICAgIGNhc2UgJ2R1YSc6XG4gICAgICAgICAgICBjYXNlICdkeW8nOlxuICAgICAgICAgICAgY2FzZSAnZWJ1JzpcbiAgICAgICAgICAgIGNhc2UgJ2V3byc6XG4gICAgICAgICAgICBjYXNlICdndXonOlxuICAgICAgICAgICAgY2FzZSAna2FtJzpcbiAgICAgICAgICAgIGNhc2UgJ2tocSc6XG4gICAgICAgICAgICBjYXNlICdraSc6XG4gICAgICAgICAgICBjYXNlICdrbG4nOlxuICAgICAgICAgICAgY2FzZSAna29rJzpcbiAgICAgICAgICAgIGNhc2UgJ2tzZic6XG4gICAgICAgICAgICBjYXNlICdscmMnOlxuICAgICAgICAgICAgY2FzZSAnbHUnOlxuICAgICAgICAgICAgY2FzZSAnbHVvJzpcbiAgICAgICAgICAgIGNhc2UgJ2x1eSc6XG4gICAgICAgICAgICBjYXNlICdtZXInOlxuICAgICAgICAgICAgY2FzZSAnbWZlJzpcbiAgICAgICAgICAgIGNhc2UgJ21naCc6XG4gICAgICAgICAgICBjYXNlICdtdWEnOlxuICAgICAgICAgICAgY2FzZSAnbXpuJzpcbiAgICAgICAgICAgIGNhc2UgJ25tZyc6XG4gICAgICAgICAgICBjYXNlICdudXMnOlxuICAgICAgICAgICAgY2FzZSAncXUnOlxuICAgICAgICAgICAgY2FzZSAncm4nOlxuICAgICAgICAgICAgY2FzZSAncncnOlxuICAgICAgICAgICAgY2FzZSAnc2JwJzpcbiAgICAgICAgICAgIGNhc2UgJ3R3cSc6XG4gICAgICAgICAgICBjYXNlICd2YWknOlxuICAgICAgICAgICAgY2FzZSAneWF2JzpcbiAgICAgICAgICAgIGNhc2UgJ3l1ZSc6XG4gICAgICAgICAgICBjYXNlICd6Z2gnOlxuICAgICAgICAgICAgY2FzZSAnYWsnOlxuICAgICAgICAgICAgY2FzZSAnbG4nOlxuICAgICAgICAgICAgY2FzZSAnbWcnOlxuICAgICAgICAgICAgY2FzZSAncGEnOlxuICAgICAgICAgICAgY2FzZSAndGknOlxuICAgICAgICAgICAgICAgIGlmIChuID09PSBNYXRoLmZsb29yKG4pICYmIG4gPj0gMCAmJiBuIDw9IDEpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuT25lO1xuICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuT3RoZXI7XG4gICAgICAgICAgICBjYXNlICdhbSc6XG4gICAgICAgICAgICBjYXNlICdhcyc6XG4gICAgICAgICAgICBjYXNlICdibic6XG4gICAgICAgICAgICBjYXNlICdmYSc6XG4gICAgICAgICAgICBjYXNlICdndSc6XG4gICAgICAgICAgICBjYXNlICdoaSc6XG4gICAgICAgICAgICBjYXNlICdrbic6XG4gICAgICAgICAgICBjYXNlICdtcic6XG4gICAgICAgICAgICBjYXNlICd6dSc6XG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IDAgfHwgbiA9PT0gMSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PbmU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PdGhlcjtcbiAgICAgICAgICAgIGNhc2UgJ2FyJzpcbiAgICAgICAgICAgICAgICBpZiAobiA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5aZXJvO1xuICAgICAgICAgICAgICAgIGlmIChuID09PSAxKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk9uZTtcbiAgICAgICAgICAgICAgICBpZiAobiA9PT0gMilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5Ud287XG4gICAgICAgICAgICAgICAgaWYgKG4gJSAxMDAgPT09IE1hdGguZmxvb3IobiAlIDEwMCkgJiYgbiAlIDEwMCA+PSAzICYmIG4gJSAxMDAgPD0gMTApXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuRmV3O1xuICAgICAgICAgICAgICAgIGlmIChuICUgMTAwID09PSBNYXRoLmZsb29yKG4gJSAxMDApICYmIG4gJSAxMDAgPj0gMTEgJiYgbiAlIDEwMCA8PSA5OSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5NYW55O1xuICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuT3RoZXI7XG4gICAgICAgICAgICBjYXNlICdhc3QnOlxuICAgICAgICAgICAgY2FzZSAnY2EnOlxuICAgICAgICAgICAgY2FzZSAnZGUnOlxuICAgICAgICAgICAgY2FzZSAnZW4nOlxuICAgICAgICAgICAgY2FzZSAnZXQnOlxuICAgICAgICAgICAgY2FzZSAnZmknOlxuICAgICAgICAgICAgY2FzZSAnZnknOlxuICAgICAgICAgICAgY2FzZSAnZ2wnOlxuICAgICAgICAgICAgY2FzZSAnaXQnOlxuICAgICAgICAgICAgY2FzZSAnbmwnOlxuICAgICAgICAgICAgY2FzZSAnc3YnOlxuICAgICAgICAgICAgY2FzZSAnc3cnOlxuICAgICAgICAgICAgY2FzZSAndXInOlxuICAgICAgICAgICAgY2FzZSAneWknOlxuICAgICAgICAgICAgICAgIGlmIChpID09PSAxICYmIHYgPT09IDApXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuT25lO1xuICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuT3RoZXI7XG4gICAgICAgICAgICBjYXNlICdiZSc6XG4gICAgICAgICAgICAgICAgaWYgKG4gJSAxMCA9PT0gMSAmJiAhKG4gJSAxMDAgPT09IDExKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PbmU7XG4gICAgICAgICAgICAgICAgaWYgKG4gJSAxMCA9PT0gTWF0aC5mbG9vcihuICUgMTApICYmIG4gJSAxMCA+PSAyICYmIG4gJSAxMCA8PSA0ICYmXG4gICAgICAgICAgICAgICAgICAgICEobiAlIDEwMCA+PSAxMiAmJiBuICUgMTAwIDw9IDE0KSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5GZXc7XG4gICAgICAgICAgICAgICAgaWYgKG4gJSAxMCA9PT0gMCB8fCBuICUgMTAgPT09IE1hdGguZmxvb3IobiAlIDEwKSAmJiBuICUgMTAgPj0gNSAmJiBuICUgMTAgPD0gOSB8fFxuICAgICAgICAgICAgICAgICAgICBuICUgMTAwID09PSBNYXRoLmZsb29yKG4gJSAxMDApICYmIG4gJSAxMDAgPj0gMTEgJiYgbiAlIDEwMCA8PSAxNClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5NYW55O1xuICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuT3RoZXI7XG4gICAgICAgICAgICBjYXNlICdicic6XG4gICAgICAgICAgICAgICAgaWYgKG4gJSAxMCA9PT0gMSAmJiAhKG4gJSAxMDAgPT09IDExIHx8IG4gJSAxMDAgPT09IDcxIHx8IG4gJSAxMDAgPT09IDkxKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PbmU7XG4gICAgICAgICAgICAgICAgaWYgKG4gJSAxMCA9PT0gMiAmJiAhKG4gJSAxMDAgPT09IDEyIHx8IG4gJSAxMDAgPT09IDcyIHx8IG4gJSAxMDAgPT09IDkyKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5Ud287XG4gICAgICAgICAgICAgICAgaWYgKG4gJSAxMCA9PT0gTWF0aC5mbG9vcihuICUgMTApICYmIChuICUgMTAgPj0gMyAmJiBuICUgMTAgPD0gNCB8fCBuICUgMTAgPT09IDkpICYmXG4gICAgICAgICAgICAgICAgICAgICEobiAlIDEwMCA+PSAxMCAmJiBuICUgMTAwIDw9IDE5IHx8IG4gJSAxMDAgPj0gNzAgJiYgbiAlIDEwMCA8PSA3OSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgbiAlIDEwMCA+PSA5MCAmJiBuICUgMTAwIDw9IDk5KSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5GZXc7XG4gICAgICAgICAgICAgICAgaWYgKCEobiA9PT0gMCkgJiYgbiAlIDFlNiA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5NYW55O1xuICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuT3RoZXI7XG4gICAgICAgICAgICBjYXNlICdicyc6XG4gICAgICAgICAgICBjYXNlICdocic6XG4gICAgICAgICAgICBjYXNlICdzcic6XG4gICAgICAgICAgICAgICAgaWYgKHYgPT09IDAgJiYgaSAlIDEwID09PSAxICYmICEoaSAlIDEwMCA9PT0gMTEpIHx8IGYgJSAxMCA9PT0gMSAmJiAhKGYgJSAxMDAgPT09IDExKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PbmU7XG4gICAgICAgICAgICAgICAgaWYgKHYgPT09IDAgJiYgaSAlIDEwID09PSBNYXRoLmZsb29yKGkgJSAxMCkgJiYgaSAlIDEwID49IDIgJiYgaSAlIDEwIDw9IDQgJiZcbiAgICAgICAgICAgICAgICAgICAgIShpICUgMTAwID49IDEyICYmIGkgJSAxMDAgPD0gMTQpIHx8XG4gICAgICAgICAgICAgICAgICAgIGYgJSAxMCA9PT0gTWF0aC5mbG9vcihmICUgMTApICYmIGYgJSAxMCA+PSAyICYmIGYgJSAxMCA8PSA0ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAhKGYgJSAxMDAgPj0gMTIgJiYgZiAlIDEwMCA8PSAxNCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuRmV3O1xuICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuT3RoZXI7XG4gICAgICAgICAgICBjYXNlICdjcyc6XG4gICAgICAgICAgICBjYXNlICdzayc6XG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IDEgJiYgdiA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PbmU7XG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IE1hdGguZmxvb3IoaSkgJiYgaSA+PSAyICYmIGkgPD0gNCAmJiB2ID09PSAwKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLkZldztcbiAgICAgICAgICAgICAgICBpZiAoISh2ID09PSAwKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5NYW55O1xuICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuT3RoZXI7XG4gICAgICAgICAgICBjYXNlICdjeSc6XG4gICAgICAgICAgICAgICAgaWYgKG4gPT09IDApXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuWmVybztcbiAgICAgICAgICAgICAgICBpZiAobiA9PT0gMSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PbmU7XG4gICAgICAgICAgICAgICAgaWYgKG4gPT09IDIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuVHdvO1xuICAgICAgICAgICAgICAgIGlmIChuID09PSAzKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLkZldztcbiAgICAgICAgICAgICAgICBpZiAobiA9PT0gNilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5NYW55O1xuICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuT3RoZXI7XG4gICAgICAgICAgICBjYXNlICdkYSc6XG4gICAgICAgICAgICAgICAgaWYgKG4gPT09IDEgfHwgISh0ID09PSAwKSAmJiAoaSA9PT0gMCB8fCBpID09PSAxKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PbmU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PdGhlcjtcbiAgICAgICAgICAgIGNhc2UgJ2RzYic6XG4gICAgICAgICAgICBjYXNlICdoc2InOlxuICAgICAgICAgICAgICAgIGlmICh2ID09PSAwICYmIGkgJSAxMDAgPT09IDEgfHwgZiAlIDEwMCA9PT0gMSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PbmU7XG4gICAgICAgICAgICAgICAgaWYgKHYgPT09IDAgJiYgaSAlIDEwMCA9PT0gMiB8fCBmICUgMTAwID09PSAyKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLlR3bztcbiAgICAgICAgICAgICAgICBpZiAodiA9PT0gMCAmJiBpICUgMTAwID09PSBNYXRoLmZsb29yKGkgJSAxMDApICYmIGkgJSAxMDAgPj0gMyAmJiBpICUgMTAwIDw9IDQgfHxcbiAgICAgICAgICAgICAgICAgICAgZiAlIDEwMCA9PT0gTWF0aC5mbG9vcihmICUgMTAwKSAmJiBmICUgMTAwID49IDMgJiYgZiAlIDEwMCA8PSA0KVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLkZldztcbiAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk90aGVyO1xuICAgICAgICAgICAgY2FzZSAnZmYnOlxuICAgICAgICAgICAgY2FzZSAnZnInOlxuICAgICAgICAgICAgY2FzZSAnaHknOlxuICAgICAgICAgICAgY2FzZSAna2FiJzpcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gMCB8fCBpID09PSAxKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk9uZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk90aGVyO1xuICAgICAgICAgICAgY2FzZSAnZmlsJzpcbiAgICAgICAgICAgICAgICBpZiAodiA9PT0gMCAmJiAoaSA9PT0gMSB8fCBpID09PSAyIHx8IGkgPT09IDMpIHx8XG4gICAgICAgICAgICAgICAgICAgIHYgPT09IDAgJiYgIShpICUgMTAgPT09IDQgfHwgaSAlIDEwID09PSA2IHx8IGkgJSAxMCA9PT0gOSkgfHxcbiAgICAgICAgICAgICAgICAgICAgISh2ID09PSAwKSAmJiAhKGYgJSAxMCA9PT0gNCB8fCBmICUgMTAgPT09IDYgfHwgZiAlIDEwID09PSA5KSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PbmU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PdGhlcjtcbiAgICAgICAgICAgIGNhc2UgJ2dhJzpcbiAgICAgICAgICAgICAgICBpZiAobiA9PT0gMSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PbmU7XG4gICAgICAgICAgICAgICAgaWYgKG4gPT09IDIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuVHdvO1xuICAgICAgICAgICAgICAgIGlmIChuID09PSBNYXRoLmZsb29yKG4pICYmIG4gPj0gMyAmJiBuIDw9IDYpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuRmV3O1xuICAgICAgICAgICAgICAgIGlmIChuID09PSBNYXRoLmZsb29yKG4pICYmIG4gPj0gNyAmJiBuIDw9IDEwKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk1hbnk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PdGhlcjtcbiAgICAgICAgICAgIGNhc2UgJ2dkJzpcbiAgICAgICAgICAgICAgICBpZiAobiA9PT0gMSB8fCBuID09PSAxMSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PbmU7XG4gICAgICAgICAgICAgICAgaWYgKG4gPT09IDIgfHwgbiA9PT0gMTIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuVHdvO1xuICAgICAgICAgICAgICAgIGlmIChuID09PSBNYXRoLmZsb29yKG4pICYmIChuID49IDMgJiYgbiA8PSAxMCB8fCBuID49IDEzICYmIG4gPD0gMTkpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLkZldztcbiAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk90aGVyO1xuICAgICAgICAgICAgY2FzZSAnZ3YnOlxuICAgICAgICAgICAgICAgIGlmICh2ID09PSAwICYmIGkgJSAxMCA9PT0gMSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PbmU7XG4gICAgICAgICAgICAgICAgaWYgKHYgPT09IDAgJiYgaSAlIDEwID09PSAyKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLlR3bztcbiAgICAgICAgICAgICAgICBpZiAodiA9PT0gMCAmJlxuICAgICAgICAgICAgICAgICAgICAoaSAlIDEwMCA9PT0gMCB8fCBpICUgMTAwID09PSAyMCB8fCBpICUgMTAwID09PSA0MCB8fCBpICUgMTAwID09PSA2MCB8fCBpICUgMTAwID09PSA4MCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuRmV3O1xuICAgICAgICAgICAgICAgIGlmICghKHYgPT09IDApKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk1hbnk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PdGhlcjtcbiAgICAgICAgICAgIGNhc2UgJ2hlJzpcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gMSAmJiB2ID09PSAwKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk9uZTtcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gMiAmJiB2ID09PSAwKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLlR3bztcbiAgICAgICAgICAgICAgICBpZiAodiA9PT0gMCAmJiAhKG4gPj0gMCAmJiBuIDw9IDEwKSAmJiBuICUgMTAgPT09IDApXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuTWFueTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk90aGVyO1xuICAgICAgICAgICAgY2FzZSAnaXMnOlxuICAgICAgICAgICAgICAgIGlmICh0ID09PSAwICYmIGkgJSAxMCA9PT0gMSAmJiAhKGkgJSAxMDAgPT09IDExKSB8fCAhKHQgPT09IDApKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk9uZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk90aGVyO1xuICAgICAgICAgICAgY2FzZSAna3NoJzpcbiAgICAgICAgICAgICAgICBpZiAobiA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5aZXJvO1xuICAgICAgICAgICAgICAgIGlmIChuID09PSAxKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk9uZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk90aGVyO1xuICAgICAgICAgICAgY2FzZSAna3cnOlxuICAgICAgICAgICAgY2FzZSAnbmFxJzpcbiAgICAgICAgICAgIGNhc2UgJ3NlJzpcbiAgICAgICAgICAgIGNhc2UgJ3Ntbic6XG4gICAgICAgICAgICAgICAgaWYgKG4gPT09IDEpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuT25lO1xuICAgICAgICAgICAgICAgIGlmIChuID09PSAyKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLlR3bztcbiAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk90aGVyO1xuICAgICAgICAgICAgY2FzZSAnbGFnJzpcbiAgICAgICAgICAgICAgICBpZiAobiA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5aZXJvO1xuICAgICAgICAgICAgICAgIGlmICgoaSA9PT0gMCB8fCBpID09PSAxKSAmJiAhKG4gPT09IDApKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk9uZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk90aGVyO1xuICAgICAgICAgICAgY2FzZSAnbHQnOlxuICAgICAgICAgICAgICAgIGlmIChuICUgMTAgPT09IDEgJiYgIShuICUgMTAwID49IDExICYmIG4gJSAxMDAgPD0gMTkpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk9uZTtcbiAgICAgICAgICAgICAgICBpZiAobiAlIDEwID09PSBNYXRoLmZsb29yKG4gJSAxMCkgJiYgbiAlIDEwID49IDIgJiYgbiAlIDEwIDw9IDkgJiZcbiAgICAgICAgICAgICAgICAgICAgIShuICUgMTAwID49IDExICYmIG4gJSAxMDAgPD0gMTkpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLkZldztcbiAgICAgICAgICAgICAgICBpZiAoIShmID09PSAwKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5NYW55O1xuICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuT3RoZXI7XG4gICAgICAgICAgICBjYXNlICdsdic6XG4gICAgICAgICAgICBjYXNlICdwcmcnOlxuICAgICAgICAgICAgICAgIGlmIChuICUgMTAgPT09IDAgfHwgbiAlIDEwMCA9PT0gTWF0aC5mbG9vcihuICUgMTAwKSAmJiBuICUgMTAwID49IDExICYmIG4gJSAxMDAgPD0gMTkgfHxcbiAgICAgICAgICAgICAgICAgICAgdiA9PT0gMiAmJiBmICUgMTAwID09PSBNYXRoLmZsb29yKGYgJSAxMDApICYmIGYgJSAxMDAgPj0gMTEgJiYgZiAlIDEwMCA8PSAxOSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5aZXJvO1xuICAgICAgICAgICAgICAgIGlmIChuICUgMTAgPT09IDEgJiYgIShuICUgMTAwID09PSAxMSkgfHwgdiA9PT0gMiAmJiBmICUgMTAgPT09IDEgJiYgIShmICUgMTAwID09PSAxMSkgfHxcbiAgICAgICAgICAgICAgICAgICAgISh2ID09PSAyKSAmJiBmICUgMTAgPT09IDEpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuT25lO1xuICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuT3RoZXI7XG4gICAgICAgICAgICBjYXNlICdtayc6XG4gICAgICAgICAgICAgICAgaWYgKHYgPT09IDAgJiYgaSAlIDEwID09PSAxIHx8IGYgJSAxMCA9PT0gMSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PbmU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PdGhlcjtcbiAgICAgICAgICAgIGNhc2UgJ210JzpcbiAgICAgICAgICAgICAgICBpZiAobiA9PT0gMSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PbmU7XG4gICAgICAgICAgICAgICAgaWYgKG4gPT09IDAgfHwgbiAlIDEwMCA9PT0gTWF0aC5mbG9vcihuICUgMTAwKSAmJiBuICUgMTAwID49IDIgJiYgbiAlIDEwMCA8PSAxMClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5GZXc7XG4gICAgICAgICAgICAgICAgaWYgKG4gJSAxMDAgPT09IE1hdGguZmxvb3IobiAlIDEwMCkgJiYgbiAlIDEwMCA+PSAxMSAmJiBuICUgMTAwIDw9IDE5KVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk1hbnk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PdGhlcjtcbiAgICAgICAgICAgIGNhc2UgJ3BsJzpcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gMSAmJiB2ID09PSAwKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk9uZTtcbiAgICAgICAgICAgICAgICBpZiAodiA9PT0gMCAmJiBpICUgMTAgPT09IE1hdGguZmxvb3IoaSAlIDEwKSAmJiBpICUgMTAgPj0gMiAmJiBpICUgMTAgPD0gNCAmJlxuICAgICAgICAgICAgICAgICAgICAhKGkgJSAxMDAgPj0gMTIgJiYgaSAlIDEwMCA8PSAxNCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuRmV3O1xuICAgICAgICAgICAgICAgIGlmICh2ID09PSAwICYmICEoaSA9PT0gMSkgJiYgaSAlIDEwID09PSBNYXRoLmZsb29yKGkgJSAxMCkgJiYgaSAlIDEwID49IDAgJiYgaSAlIDEwIDw9IDEgfHxcbiAgICAgICAgICAgICAgICAgICAgdiA9PT0gMCAmJiBpICUgMTAgPT09IE1hdGguZmxvb3IoaSAlIDEwKSAmJiBpICUgMTAgPj0gNSAmJiBpICUgMTAgPD0gOSB8fFxuICAgICAgICAgICAgICAgICAgICB2ID09PSAwICYmIGkgJSAxMDAgPT09IE1hdGguZmxvb3IoaSAlIDEwMCkgJiYgaSAlIDEwMCA+PSAxMiAmJiBpICUgMTAwIDw9IDE0KVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk1hbnk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PdGhlcjtcbiAgICAgICAgICAgIGNhc2UgJ3B0JzpcbiAgICAgICAgICAgICAgICBpZiAobiA9PT0gTWF0aC5mbG9vcihuKSAmJiBuID49IDAgJiYgbiA8PSAyICYmICEobiA9PT0gMikpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuT25lO1xuICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuT3RoZXI7XG4gICAgICAgICAgICBjYXNlICdybyc6XG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IDEgJiYgdiA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PbmU7XG4gICAgICAgICAgICAgICAgaWYgKCEodiA9PT0gMCkgfHwgbiA9PT0gMCB8fFxuICAgICAgICAgICAgICAgICAgICAhKG4gPT09IDEpICYmIG4gJSAxMDAgPT09IE1hdGguZmxvb3IobiAlIDEwMCkgJiYgbiAlIDEwMCA+PSAxICYmIG4gJSAxMDAgPD0gMTkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuRmV3O1xuICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuT3RoZXI7XG4gICAgICAgICAgICBjYXNlICdydSc6XG4gICAgICAgICAgICBjYXNlICd1ayc6XG4gICAgICAgICAgICAgICAgaWYgKHYgPT09IDAgJiYgaSAlIDEwID09PSAxICYmICEoaSAlIDEwMCA9PT0gMTEpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk9uZTtcbiAgICAgICAgICAgICAgICBpZiAodiA9PT0gMCAmJiBpICUgMTAgPT09IE1hdGguZmxvb3IoaSAlIDEwKSAmJiBpICUgMTAgPj0gMiAmJiBpICUgMTAgPD0gNCAmJlxuICAgICAgICAgICAgICAgICAgICAhKGkgJSAxMDAgPj0gMTIgJiYgaSAlIDEwMCA8PSAxNCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuRmV3O1xuICAgICAgICAgICAgICAgIGlmICh2ID09PSAwICYmIGkgJSAxMCA9PT0gMCB8fFxuICAgICAgICAgICAgICAgICAgICB2ID09PSAwICYmIGkgJSAxMCA9PT0gTWF0aC5mbG9vcihpICUgMTApICYmIGkgJSAxMCA+PSA1ICYmIGkgJSAxMCA8PSA5IHx8XG4gICAgICAgICAgICAgICAgICAgIHYgPT09IDAgJiYgaSAlIDEwMCA9PT0gTWF0aC5mbG9vcihpICUgMTAwKSAmJiBpICUgMTAwID49IDExICYmIGkgJSAxMDAgPD0gMTQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuTWFueTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk90aGVyO1xuICAgICAgICAgICAgY2FzZSAnc2hpJzpcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gMCB8fCBuID09PSAxKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk9uZTtcbiAgICAgICAgICAgICAgICBpZiAobiA9PT0gTWF0aC5mbG9vcihuKSAmJiBuID49IDIgJiYgbiA8PSAxMClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5GZXc7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PdGhlcjtcbiAgICAgICAgICAgIGNhc2UgJ3NpJzpcbiAgICAgICAgICAgICAgICBpZiAobiA9PT0gMCB8fCBuID09PSAxIHx8IGkgPT09IDAgJiYgZiA9PT0gMSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PbmU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PdGhlcjtcbiAgICAgICAgICAgIGNhc2UgJ3NsJzpcbiAgICAgICAgICAgICAgICBpZiAodiA9PT0gMCAmJiBpICUgMTAwID09PSAxKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk9uZTtcbiAgICAgICAgICAgICAgICBpZiAodiA9PT0gMCAmJiBpICUgMTAwID09PSAyKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLlR3bztcbiAgICAgICAgICAgICAgICBpZiAodiA9PT0gMCAmJiBpICUgMTAwID09PSBNYXRoLmZsb29yKGkgJSAxMDApICYmIGkgJSAxMDAgPj0gMyAmJiBpICUgMTAwIDw9IDQgfHwgISh2ID09PSAwKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5GZXc7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PdGhlcjtcbiAgICAgICAgICAgIGNhc2UgJ3R6bSc6XG4gICAgICAgICAgICAgICAgaWYgKG4gPT09IE1hdGguZmxvb3IobikgJiYgbiA+PSAwICYmIG4gPD0gMSB8fCBuID09PSBNYXRoLmZsb29yKG4pICYmIG4gPj0gMTEgJiYgbiA8PSA5OSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PbmU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PdGhlcjtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PdGhlcjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFNhZmFyaSBkb2Vzbid0IGltcGxlbWVudCBNYXBJdGVyYXRvci5uZXh0KCksIHdoaWNoIGlzIHVzZWQgaXMgVHJhY2V1cidzIHBvbHlmaWxsIG9mIEFycmF5LmZyb21cbiAgICAvLyBUT0RPKG1sYXZhbCk6IHJlbW92ZSB0aGUgd29yayBhcm91bmQgb25jZSB3ZSBoYXZlIGEgd29ya2luZyBwb2x5ZmlsbCBvZiBBcnJheS5mcm9tXG4gICAgdmFyIF9hcnJheUZyb21NYXAgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKChuZXcgTWFwKCkpLnZhbHVlcygpLm5leHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlQXJyYXlGcm9tTWFwKG0sIGdldFZhbHVlcykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0VmFsdWVzID8gQXJyYXkuZnJvbShtLnZhbHVlcygpKSA6IEFycmF5LmZyb20obS5rZXlzKCkpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlQXJyYXlGcm9tTWFwV2l0aEZvcmVhY2gobSwgZ2V0VmFsdWVzKSB7XG4gICAgICAgICAgICB2YXIgcmVzID0gbmV3IEFycmF5KG0uc2l6ZSksIGkgPSAwO1xuICAgICAgICAgICAgbS5mb3JFYWNoKGZ1bmN0aW9uICh2LCBrKSB7XG4gICAgICAgICAgICAgICAgcmVzW2ldID0gZ2V0VmFsdWVzID8gdiA6IGs7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9O1xuICAgIH0pKCk7XG4gICAgdmFyIExpc3RXcmFwcGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gTGlzdFdyYXBwZXIoKSB7XG4gICAgICAgIH1cbiAgICAgICAgTGlzdFdyYXBwZXIucmVtb3ZlQWxsID0gZnVuY3Rpb24gKGxpc3QsIGl0ZW1zKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gbGlzdC5pbmRleE9mKGl0ZW1zW2ldKTtcbiAgICAgICAgICAgICAgICBsaXN0LnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIExpc3RXcmFwcGVyLnJlbW92ZSA9IGZ1bmN0aW9uIChsaXN0LCBlbCkge1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gbGlzdC5pbmRleE9mKGVsKTtcbiAgICAgICAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgbGlzdC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgICBMaXN0V3JhcHBlci5lcXVhbHMgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgaWYgKGEubGVuZ3RoICE9IGIubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGlmIChhW2ldICE9PSBiW2ldKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgTGlzdFdyYXBwZXIubWF4aW11bSA9IGZ1bmN0aW9uIChsaXN0LCBwcmVkaWNhdGUpIHtcbiAgICAgICAgICAgIGlmIChsaXN0Lmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc29sdXRpb24gPSBudWxsO1xuICAgICAgICAgICAgdmFyIG1heFZhbHVlID0gLUluZmluaXR5O1xuICAgICAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxpc3QubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IGxpc3RbaW5kZXhdO1xuICAgICAgICAgICAgICAgIGlmIChjYW5kaWRhdGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGNhbmRpZGF0ZVZhbHVlID0gcHJlZGljYXRlKGNhbmRpZGF0ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGNhbmRpZGF0ZVZhbHVlID4gbWF4VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgc29sdXRpb24gPSBjYW5kaWRhdGU7XG4gICAgICAgICAgICAgICAgICAgIG1heFZhbHVlID0gY2FuZGlkYXRlVmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNvbHV0aW9uO1xuICAgICAgICB9O1xuICAgICAgICBMaXN0V3JhcHBlci5mbGF0dGVuID0gZnVuY3Rpb24gKGxpc3QpIHtcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSBbXTtcbiAgICAgICAgICAgIF9mbGF0dGVuQXJyYXkobGlzdCwgdGFyZ2V0KTtcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBMaXN0V3JhcHBlcjtcbiAgICB9KCkpO1xuICAgIGZ1bmN0aW9uIF9mbGF0dGVuQXJyYXkoc291cmNlLCB0YXJnZXQpIHtcbiAgICAgICAgaWYgKGlzUHJlc2VudChzb3VyY2UpKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNvdXJjZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBpdGVtID0gc291cmNlW2ldO1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgICAgIF9mbGF0dGVuQXJyYXkoaXRlbSwgdGFyZ2V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc0xpc3RMaWtlSXRlcmFibGUob2JqKSB7XG4gICAgICAgIGlmICghaXNKc09iamVjdChvYmopKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShvYmopIHx8XG4gICAgICAgICAgICAoIShvYmogaW5zdGFuY2VvZiBNYXApICYmXG4gICAgICAgICAgICAgICAgZ2V0U3ltYm9sSXRlcmF0b3IoKSBpbiBvYmopOyAvLyBKUyBJdGVyYWJsZSBoYXZlIGEgU3ltYm9sLml0ZXJhdG9yIHByb3BcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbmdNb2R1bGUgQ29tbW9uTW9kdWxlXG4gICAgICpcbiAgICAgKiBAd2hhdEl0RG9lcyBBZGRzIGFuZCByZW1vdmVzIENTUyBjbGFzc2VzIG9uIGFuIEhUTUwgZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBob3dUb1VzZVxuICAgICAqIGBgYFxuICAgICAqICAgICA8c29tZS1lbGVtZW50IFtuZ0NsYXNzXT1cIidmaXJzdCBzZWNvbmQnXCI+Li4uPC9zb21lLWVsZW1lbnQ+XG4gICAgICpcbiAgICAgKiAgICAgPHNvbWUtZWxlbWVudCBbbmdDbGFzc109XCJbJ2ZpcnN0JywgJ3NlY29uZCddXCI+Li4uPC9zb21lLWVsZW1lbnQ+XG4gICAgICpcbiAgICAgKiAgICAgPHNvbWUtZWxlbWVudCBbbmdDbGFzc109XCJ7J2ZpcnN0JzogdHJ1ZSwgJ3NlY29uZCc6IHRydWUsICd0aGlyZCc6IGZhbHNlfVwiPi4uLjwvc29tZS1lbGVtZW50PlxuICAgICAqXG4gICAgICogICAgIDxzb21lLWVsZW1lbnQgW25nQ2xhc3NdPVwic3RyaW5nRXhwfGFycmF5RXhwfG9iakV4cFwiPi4uLjwvc29tZS1lbGVtZW50PlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICpcbiAgICAgKiBUaGUgQ1NTIGNsYXNzZXMgYXJlIHVwZGF0ZWQgYXMgZm9sbG93cywgZGVwZW5kaW5nIG9uIHRoZSB0eXBlIG9mIHRoZSBleHByZXNzaW9uIGV2YWx1YXRpb246XG4gICAgICogLSBgc3RyaW5nYCAtIHRoZSBDU1MgY2xhc3NlcyBsaXN0ZWQgaW4gdGhlIHN0cmluZyAoc3BhY2UgZGVsaW1pdGVkKSBhcmUgYWRkZWQsXG4gICAgICogLSBgQXJyYXlgIC0gdGhlIENTUyBjbGFzc2VzIGRlY2xhcmVkIGFzIEFycmF5IGVsZW1lbnRzIGFyZSBhZGRlZCxcbiAgICAgKiAtIGBPYmplY3RgIC0ga2V5cyBhcmUgQ1NTIGNsYXNzZXMgdGhhdCBnZXQgYWRkZWQgd2hlbiB0aGUgZXhwcmVzc2lvbiBnaXZlbiBpbiB0aGUgdmFsdWVcbiAgICAgKiAgICAgICAgICAgICAgZXZhbHVhdGVzIHRvIGEgdHJ1dGh5IHZhbHVlLCBvdGhlcndpc2UgdGhleSBhcmUgcmVtb3ZlZC5cbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgTmdDbGFzcyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIE5nQ2xhc3MoX2l0ZXJhYmxlRGlmZmVycywgX2tleVZhbHVlRGlmZmVycywgX25nRWwsIF9yZW5kZXJlcikge1xuICAgICAgICAgICAgdGhpcy5faXRlcmFibGVEaWZmZXJzID0gX2l0ZXJhYmxlRGlmZmVycztcbiAgICAgICAgICAgIHRoaXMuX2tleVZhbHVlRGlmZmVycyA9IF9rZXlWYWx1ZURpZmZlcnM7XG4gICAgICAgICAgICB0aGlzLl9uZ0VsID0gX25nRWw7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlciA9IF9yZW5kZXJlcjtcbiAgICAgICAgICAgIHRoaXMuX2luaXRpYWxDbGFzc2VzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nQ2xhc3MucHJvdG90eXBlLCBcImtsYXNzXCIsIHtcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hcHBseUluaXRpYWxDbGFzc2VzKHRydWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2luaXRpYWxDbGFzc2VzID0gdHlwZW9mIHYgPT09ICdzdHJpbmcnID8gdi5zcGxpdCgvXFxzKy8pIDogW107XG4gICAgICAgICAgICAgICAgdGhpcy5fYXBwbHlJbml0aWFsQ2xhc3NlcyhmYWxzZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fYXBwbHlDbGFzc2VzKHRoaXMuX3Jhd0NsYXNzLCBmYWxzZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nQ2xhc3MucHJvdG90eXBlLCBcIm5nQ2xhc3NcIiwge1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NsZWFudXBDbGFzc2VzKHRoaXMuX3Jhd0NsYXNzKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9pdGVyYWJsZURpZmZlciA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5fa2V5VmFsdWVEaWZmZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Jhd0NsYXNzID0gdHlwZW9mIHYgPT09ICdzdHJpbmcnID8gdi5zcGxpdCgvXFxzKy8pIDogdjtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fcmF3Q2xhc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTGlzdExpa2VJdGVyYWJsZSh0aGlzLl9yYXdDbGFzcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2l0ZXJhYmxlRGlmZmVyID0gdGhpcy5faXRlcmFibGVEaWZmZXJzLmZpbmQodGhpcy5fcmF3Q2xhc3MpLmNyZWF0ZShudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2tleVZhbHVlRGlmZmVyID0gdGhpcy5fa2V5VmFsdWVEaWZmZXJzLmZpbmQodGhpcy5fcmF3Q2xhc3MpLmNyZWF0ZShudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBOZ0NsYXNzLnByb3RvdHlwZS5uZ0RvQ2hlY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5faXRlcmFibGVEaWZmZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hhbmdlcyA9IHRoaXMuX2l0ZXJhYmxlRGlmZmVyLmRpZmYodGhpcy5fcmF3Q2xhc3MpO1xuICAgICAgICAgICAgICAgIGlmIChjaGFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FwcGx5SXRlcmFibGVDaGFuZ2VzKGNoYW5nZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX2tleVZhbHVlRGlmZmVyKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoYW5nZXMgPSB0aGlzLl9rZXlWYWx1ZURpZmZlci5kaWZmKHRoaXMuX3Jhd0NsYXNzKTtcbiAgICAgICAgICAgICAgICBpZiAoY2hhbmdlcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hcHBseUtleVZhbHVlQ2hhbmdlcyhjaGFuZ2VzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIE5nQ2xhc3MucHJvdG90eXBlLl9jbGVhbnVwQ2xhc3NlcyA9IGZ1bmN0aW9uIChyYXdDbGFzc1ZhbCkge1xuICAgICAgICAgICAgdGhpcy5fYXBwbHlDbGFzc2VzKHJhd0NsYXNzVmFsLCB0cnVlKTtcbiAgICAgICAgICAgIHRoaXMuX2FwcGx5SW5pdGlhbENsYXNzZXMoZmFsc2UpO1xuICAgICAgICB9O1xuICAgICAgICBOZ0NsYXNzLnByb3RvdHlwZS5fYXBwbHlLZXlWYWx1ZUNoYW5nZXMgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIGNoYW5nZXMuZm9yRWFjaEFkZGVkSXRlbShmdW5jdGlvbiAocmVjb3JkKSB7IHJldHVybiBfdGhpcy5fdG9nZ2xlQ2xhc3MocmVjb3JkLmtleSwgcmVjb3JkLmN1cnJlbnRWYWx1ZSk7IH0pO1xuICAgICAgICAgICAgY2hhbmdlcy5mb3JFYWNoQ2hhbmdlZEl0ZW0oZnVuY3Rpb24gKHJlY29yZCkgeyByZXR1cm4gX3RoaXMuX3RvZ2dsZUNsYXNzKHJlY29yZC5rZXksIHJlY29yZC5jdXJyZW50VmFsdWUpOyB9KTtcbiAgICAgICAgICAgIGNoYW5nZXMuZm9yRWFjaFJlbW92ZWRJdGVtKGZ1bmN0aW9uIChyZWNvcmQpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVjb3JkLnByZXZpb3VzVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3RvZ2dsZUNsYXNzKHJlY29yZC5rZXksIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgTmdDbGFzcy5wcm90b3R5cGUuX2FwcGx5SXRlcmFibGVDaGFuZ2VzID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICBjaGFuZ2VzLmZvckVhY2hBZGRlZEl0ZW0oZnVuY3Rpb24gKHJlY29yZCkgeyByZXR1cm4gX3RoaXMuX3RvZ2dsZUNsYXNzKHJlY29yZC5pdGVtLCB0cnVlKTsgfSk7XG4gICAgICAgICAgICBjaGFuZ2VzLmZvckVhY2hSZW1vdmVkSXRlbShmdW5jdGlvbiAocmVjb3JkKSB7IHJldHVybiBfdGhpcy5fdG9nZ2xlQ2xhc3MocmVjb3JkLml0ZW0sIGZhbHNlKTsgfSk7XG4gICAgICAgIH07XG4gICAgICAgIE5nQ2xhc3MucHJvdG90eXBlLl9hcHBseUluaXRpYWxDbGFzc2VzID0gZnVuY3Rpb24gKGlzQ2xlYW51cCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuX2luaXRpYWxDbGFzc2VzLmZvckVhY2goZnVuY3Rpb24gKGtsYXNzKSB7IHJldHVybiBfdGhpcy5fdG9nZ2xlQ2xhc3Moa2xhc3MsICFpc0NsZWFudXApOyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgTmdDbGFzcy5wcm90b3R5cGUuX2FwcGx5Q2xhc3NlcyA9IGZ1bmN0aW9uIChyYXdDbGFzc1ZhbCwgaXNDbGVhbnVwKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgaWYgKHJhd0NsYXNzVmFsKSB7XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmF3Q2xhc3NWYWwpIHx8IHJhd0NsYXNzVmFsIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJhd0NsYXNzVmFsLmZvckVhY2goZnVuY3Rpb24gKGtsYXNzKSB7IHJldHVybiBfdGhpcy5fdG9nZ2xlQ2xhc3Moa2xhc3MsICFpc0NsZWFudXApOyB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHJhd0NsYXNzVmFsKS5mb3JFYWNoKGZ1bmN0aW9uIChrbGFzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzUHJlc2VudChyYXdDbGFzc1ZhbFtrbGFzc10pKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl90b2dnbGVDbGFzcyhrbGFzcywgIWlzQ2xlYW51cCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgTmdDbGFzcy5wcm90b3R5cGUuX3RvZ2dsZUNsYXNzID0gZnVuY3Rpb24gKGtsYXNzLCBlbmFibGVkKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAga2xhc3MgPSBrbGFzcy50cmltKCk7XG4gICAgICAgICAgICBpZiAoa2xhc3MpIHtcbiAgICAgICAgICAgICAgICBrbGFzcy5zcGxpdCgvXFxzKy9nKS5mb3JFYWNoKGZ1bmN0aW9uIChrbGFzcykgeyBfdGhpcy5fcmVuZGVyZXIuc2V0RWxlbWVudENsYXNzKF90aGlzLl9uZ0VsLm5hdGl2ZUVsZW1lbnQsIGtsYXNzLCBlbmFibGVkKTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIE5nQ2xhc3MuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnW25nQ2xhc3NdJyB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIE5nQ2xhc3MuY3RvclBhcmFtZXRlcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSXRlcmFibGVEaWZmZXJzLCB9LFxuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLktleVZhbHVlRGlmZmVycywgfSxcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5FbGVtZW50UmVmLCB9LFxuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlJlbmRlcmVyLCB9LFxuICAgICAgICBdO1xuICAgICAgICBOZ0NsYXNzLnByb3BEZWNvcmF0b3JzID0ge1xuICAgICAgICAgICAgJ2tsYXNzJzogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5JbnB1dCwgYXJnczogWydjbGFzcycsXSB9LF0sXG4gICAgICAgICAgICAnbmdDbGFzcyc6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5wdXQgfSxdLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gTmdDbGFzcztcbiAgICB9KCkpO1xuXG4gICAgdmFyIE5nRm9yUm93ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gTmdGb3JSb3coJGltcGxpY2l0LCBpbmRleCwgY291bnQpIHtcbiAgICAgICAgICAgIHRoaXMuJGltcGxpY2l0ID0gJGltcGxpY2l0O1xuICAgICAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICAgICAgdGhpcy5jb3VudCA9IGNvdW50O1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ0ZvclJvdy5wcm90b3R5cGUsIFwiZmlyc3RcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmluZGV4ID09PSAwOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nRm9yUm93LnByb3RvdHlwZSwgXCJsYXN0XCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5pbmRleCA9PT0gdGhpcy5jb3VudCAtIDE7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdGb3JSb3cucHJvdG90eXBlLCBcImV2ZW5cIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmluZGV4ICUgMiA9PT0gMDsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ0ZvclJvdy5wcm90b3R5cGUsIFwib2RkXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gIXRoaXMuZXZlbjsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBOZ0ZvclJvdztcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIFRoZSBgTmdGb3JgIGRpcmVjdGl2ZSBpbnN0YW50aWF0ZXMgYSB0ZW1wbGF0ZSBvbmNlIHBlciBpdGVtIGZyb20gYW4gaXRlcmFibGUuIFRoZSBjb250ZXh0IGZvclxuICAgICAqIGVhY2ggaW5zdGFudGlhdGVkIHRlbXBsYXRlIGluaGVyaXRzIGZyb20gdGhlIG91dGVyIGNvbnRleHQgd2l0aCB0aGUgZ2l2ZW4gbG9vcCB2YXJpYWJsZSBzZXRcbiAgICAgKiB0byB0aGUgY3VycmVudCBpdGVtIGZyb20gdGhlIGl0ZXJhYmxlLlxuICAgICAqXG4gICAgICogIyMjIExvY2FsIFZhcmlhYmxlc1xuICAgICAqXG4gICAgICogYE5nRm9yYCBwcm92aWRlcyBzZXZlcmFsIGV4cG9ydGVkIHZhbHVlcyB0aGF0IGNhbiBiZSBhbGlhc2VkIHRvIGxvY2FsIHZhcmlhYmxlczpcbiAgICAgKlxuICAgICAqICogYGluZGV4YCB3aWxsIGJlIHNldCB0byB0aGUgY3VycmVudCBsb29wIGl0ZXJhdGlvbiBmb3IgZWFjaCB0ZW1wbGF0ZSBjb250ZXh0LlxuICAgICAqICogYGZpcnN0YCB3aWxsIGJlIHNldCB0byBhIGJvb2xlYW4gdmFsdWUgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBpdGVtIGlzIHRoZSBmaXJzdCBvbmUgaW4gdGhlXG4gICAgICogICBpdGVyYXRpb24uXG4gICAgICogKiBgbGFzdGAgd2lsbCBiZSBzZXQgdG8gYSBib29sZWFuIHZhbHVlIGluZGljYXRpbmcgd2hldGhlciB0aGUgaXRlbSBpcyB0aGUgbGFzdCBvbmUgaW4gdGhlXG4gICAgICogICBpdGVyYXRpb24uXG4gICAgICogKiBgZXZlbmAgd2lsbCBiZSBzZXQgdG8gYSBib29sZWFuIHZhbHVlIGluZGljYXRpbmcgd2hldGhlciB0aGlzIGl0ZW0gaGFzIGFuIGV2ZW4gaW5kZXguXG4gICAgICogKiBgb2RkYCB3aWxsIGJlIHNldCB0byBhIGJvb2xlYW4gdmFsdWUgaW5kaWNhdGluZyB3aGV0aGVyIHRoaXMgaXRlbSBoYXMgYW4gb2RkIGluZGV4LlxuICAgICAqXG4gICAgICogIyMjIENoYW5nZSBQcm9wYWdhdGlvblxuICAgICAqXG4gICAgICogV2hlbiB0aGUgY29udGVudHMgb2YgdGhlIGl0ZXJhdG9yIGNoYW5nZXMsIGBOZ0ZvcmAgbWFrZXMgdGhlIGNvcnJlc3BvbmRpbmcgY2hhbmdlcyB0byB0aGUgRE9NOlxuICAgICAqXG4gICAgICogKiBXaGVuIGFuIGl0ZW0gaXMgYWRkZWQsIGEgbmV3IGluc3RhbmNlIG9mIHRoZSB0ZW1wbGF0ZSBpcyBhZGRlZCB0byB0aGUgRE9NLlxuICAgICAqICogV2hlbiBhbiBpdGVtIGlzIHJlbW92ZWQsIGl0cyB0ZW1wbGF0ZSBpbnN0YW5jZSBpcyByZW1vdmVkIGZyb20gdGhlIERPTS5cbiAgICAgKiAqIFdoZW4gaXRlbXMgYXJlIHJlb3JkZXJlZCwgdGhlaXIgcmVzcGVjdGl2ZSB0ZW1wbGF0ZXMgYXJlIHJlb3JkZXJlZCBpbiB0aGUgRE9NLlxuICAgICAqICogT3RoZXJ3aXNlLCB0aGUgRE9NIGVsZW1lbnQgZm9yIHRoYXQgaXRlbSB3aWxsIHJlbWFpbiB0aGUgc2FtZS5cbiAgICAgKlxuICAgICAqIEFuZ3VsYXIgdXNlcyBvYmplY3QgaWRlbnRpdHkgdG8gdHJhY2sgaW5zZXJ0aW9ucyBhbmQgZGVsZXRpb25zIHdpdGhpbiB0aGUgaXRlcmF0b3IgYW5kIHJlcHJvZHVjZVxuICAgICAqIHRob3NlIGNoYW5nZXMgaW4gdGhlIERPTS4gVGhpcyBoYXMgaW1wb3J0YW50IGltcGxpY2F0aW9ucyBmb3IgYW5pbWF0aW9ucyBhbmQgYW55IHN0YXRlZnVsXG4gICAgICogY29udHJvbHNcbiAgICAgKiAoc3VjaCBhcyBgPGlucHV0PmAgZWxlbWVudHMgd2hpY2ggYWNjZXB0IHVzZXIgaW5wdXQpIHRoYXQgYXJlIHByZXNlbnQuIEluc2VydGVkIHJvd3MgY2FuIGJlXG4gICAgICogYW5pbWF0ZWQgaW4sIGRlbGV0ZWQgcm93cyBjYW4gYmUgYW5pbWF0ZWQgb3V0LCBhbmQgdW5jaGFuZ2VkIHJvd3MgcmV0YWluIGFueSB1bnNhdmVkIHN0YXRlIHN1Y2hcbiAgICAgKiBhcyB1c2VyIGlucHV0LlxuICAgICAqXG4gICAgICogSXQgaXMgcG9zc2libGUgZm9yIHRoZSBpZGVudGl0aWVzIG9mIGVsZW1lbnRzIGluIHRoZSBpdGVyYXRvciB0byBjaGFuZ2Ugd2hpbGUgdGhlIGRhdGEgZG9lcyBub3QuXG4gICAgICogVGhpcyBjYW4gaGFwcGVuLCBmb3IgZXhhbXBsZSwgaWYgdGhlIGl0ZXJhdG9yIHByb2R1Y2VkIGZyb20gYW4gUlBDIHRvIHRoZSBzZXJ2ZXIsIGFuZCB0aGF0XG4gICAgICogUlBDIGlzIHJlLXJ1bi4gRXZlbiBpZiB0aGUgZGF0YSBoYXNuJ3QgY2hhbmdlZCwgdGhlIHNlY29uZCByZXNwb25zZSB3aWxsIHByb2R1Y2Ugb2JqZWN0cyB3aXRoXG4gICAgICogZGlmZmVyZW50IGlkZW50aXRpZXMsIGFuZCBBbmd1bGFyIHdpbGwgdGVhciBkb3duIHRoZSBlbnRpcmUgRE9NIGFuZCByZWJ1aWxkIGl0IChhcyBpZiBhbGwgb2xkXG4gICAgICogZWxlbWVudHMgd2VyZSBkZWxldGVkIGFuZCBhbGwgbmV3IGVsZW1lbnRzIGluc2VydGVkKS4gVGhpcyBpcyBhbiBleHBlbnNpdmUgb3BlcmF0aW9uIGFuZCBzaG91bGRcbiAgICAgKiBiZSBhdm9pZGVkIGlmIHBvc3NpYmxlLlxuICAgICAqXG4gICAgICogVG8gY3VzdG9taXplIHRoZSBkZWZhdWx0IHRyYWNraW5nIGFsZ29yaXRobSwgYE5nRm9yYCBzdXBwb3J0cyBgdHJhY2tCeWAgb3B0aW9uLlxuICAgICAqIGB0cmFja0J5YCB0YWtlcyBhIGZ1bmN0aW9uIHdoaWNoIGhhcyB0d28gYXJndW1lbnRzOiBgaW5kZXhgIGFuZCBgaXRlbWAuXG4gICAgICogSWYgYHRyYWNrQnlgIGlzIGdpdmVuLCBBbmd1bGFyIHRyYWNrcyBjaGFuZ2VzIGJ5IHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogIyMjIFN5bnRheFxuICAgICAqXG4gICAgICogLSBgPGxpICpuZ0Zvcj1cImxldCBpdGVtIG9mIGl0ZW1zOyBsZXQgaSA9IGluZGV4OyB0cmFja0J5OiB0cmFja0J5Rm5cIj4uLi48L2xpPmBcbiAgICAgKiAtIGA8bGkgdGVtcGxhdGU9XCJuZ0ZvciBsZXQgaXRlbSBvZiBpdGVtczsgbGV0IGkgPSBpbmRleDsgdHJhY2tCeTogdHJhY2tCeUZuXCI+Li4uPC9saT5gXG4gICAgICpcbiAgICAgKiBXaXRoIGA8dGVtcGxhdGU+YCBlbGVtZW50OlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogPHRlbXBsYXRlIG5nRm9yIGxldC1pdGVtIFtuZ0Zvck9mXT1cIml0ZW1zXCIgbGV0LWk9XCJpbmRleFwiIFtuZ0ZvclRyYWNrQnldPVwidHJhY2tCeUZuXCI+XG4gICAgICogICA8bGk+Li4uPC9saT5cbiAgICAgKiA8L3RlbXBsYXRlPlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogIyMjIEV4YW1wbGVcbiAgICAgKlxuICAgICAqIFNlZSBhIFtsaXZlIGRlbW9dKGh0dHA6Ly9wbG5rci5jby9lZGl0L0tWdVh4RHAwcWluR0R5bzMwN1FXP3A9cHJldmlldykgZm9yIGEgbW9yZSBkZXRhaWxlZFxuICAgICAqIGV4YW1wbGUuXG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIE5nRm9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gTmdGb3IoX3ZpZXdDb250YWluZXIsIF90ZW1wbGF0ZSwgX2RpZmZlcnMsIF9jZHIpIHtcbiAgICAgICAgICAgIHRoaXMuX3ZpZXdDb250YWluZXIgPSBfdmlld0NvbnRhaW5lcjtcbiAgICAgICAgICAgIHRoaXMuX3RlbXBsYXRlID0gX3RlbXBsYXRlO1xuICAgICAgICAgICAgdGhpcy5fZGlmZmVycyA9IF9kaWZmZXJzO1xuICAgICAgICAgICAgdGhpcy5fY2RyID0gX2NkcjtcbiAgICAgICAgICAgIHRoaXMuX2RpZmZlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nRm9yLnByb3RvdHlwZSwgXCJuZ0ZvclRlbXBsYXRlXCIsIHtcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RlbXBsYXRlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE5nRm9yLnByb3RvdHlwZS5uZ09uQ2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XG4gICAgICAgICAgICBpZiAoJ25nRm9yT2YnIGluIGNoYW5nZXMpIHtcbiAgICAgICAgICAgICAgICAvLyBSZWFjdCBvbiBuZ0Zvck9mIGNoYW5nZXMgb25seSBvbmNlIGFsbCBpbnB1dHMgaGF2ZSBiZWVuIGluaXRpYWxpemVkXG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gY2hhbmdlc1snbmdGb3JPZiddLmN1cnJlbnRWYWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2RpZmZlciAmJiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlmZmVyID0gdGhpcy5fZGlmZmVycy5maW5kKHZhbHVlKS5jcmVhdGUodGhpcy5fY2RyLCB0aGlzLm5nRm9yVHJhY2tCeSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIGEgZGlmZmVyIHN1cHBvcnRpbmcgb2JqZWN0ICdcIiArIHZhbHVlICsgXCInIG9mIHR5cGUgJ1wiICsgZ2V0VHlwZU5hbWVGb3JEZWJ1Z2dpbmcodmFsdWUpICsgXCInLiBOZ0ZvciBvbmx5IHN1cHBvcnRzIGJpbmRpbmcgdG8gSXRlcmFibGVzIHN1Y2ggYXMgQXJyYXlzLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgTmdGb3IucHJvdG90eXBlLm5nRG9DaGVjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9kaWZmZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hhbmdlcyA9IHRoaXMuX2RpZmZlci5kaWZmKHRoaXMubmdGb3JPZik7XG4gICAgICAgICAgICAgICAgaWYgKGNoYW5nZXMpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FwcGx5Q2hhbmdlcyhjaGFuZ2VzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgTmdGb3IucHJvdG90eXBlLl9hcHBseUNoYW5nZXMgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHZhciBpbnNlcnRUdXBsZXMgPSBbXTtcbiAgICAgICAgICAgIGNoYW5nZXMuZm9yRWFjaE9wZXJhdGlvbihmdW5jdGlvbiAoaXRlbSwgYWRqdXN0ZWRQcmV2aW91c0luZGV4LCBjdXJyZW50SW5kZXgpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5wcmV2aW91c0luZGV4ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZpZXcgPSBfdGhpcy5fdmlld0NvbnRhaW5lci5jcmVhdGVFbWJlZGRlZFZpZXcoX3RoaXMuX3RlbXBsYXRlLCBuZXcgTmdGb3JSb3cobnVsbCwgbnVsbCwgbnVsbCksIGN1cnJlbnRJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0dXBsZSA9IG5ldyBSZWNvcmRWaWV3VHVwbGUoaXRlbSwgdmlldyk7XG4gICAgICAgICAgICAgICAgICAgIGluc2VydFR1cGxlcy5wdXNoKHR1cGxlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY3VycmVudEluZGV4ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3ZpZXdDb250YWluZXIucmVtb3ZlKGFkanVzdGVkUHJldmlvdXNJbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmlldyA9IF90aGlzLl92aWV3Q29udGFpbmVyLmdldChhZGp1c3RlZFByZXZpb3VzSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fdmlld0NvbnRhaW5lci5tb3ZlKHZpZXcsIGN1cnJlbnRJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0dXBsZSA9IG5ldyBSZWNvcmRWaWV3VHVwbGUoaXRlbSwgdmlldyk7XG4gICAgICAgICAgICAgICAgICAgIGluc2VydFR1cGxlcy5wdXNoKHR1cGxlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5zZXJ0VHVwbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGVyVmlld0NoYW5nZShpbnNlcnRUdXBsZXNbaV0udmlldywgaW5zZXJ0VHVwbGVzW2ldLnJlY29yZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaWxlbiA9IHRoaXMuX3ZpZXdDb250YWluZXIubGVuZ3RoOyBpIDwgaWxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZpZXdSZWYgPSB0aGlzLl92aWV3Q29udGFpbmVyLmdldChpKTtcbiAgICAgICAgICAgICAgICB2aWV3UmVmLmNvbnRleHQuaW5kZXggPSBpO1xuICAgICAgICAgICAgICAgIHZpZXdSZWYuY29udGV4dC5jb3VudCA9IGlsZW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGFuZ2VzLmZvckVhY2hJZGVudGl0eUNoYW5nZShmdW5jdGlvbiAocmVjb3JkKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZpZXdSZWYgPSBfdGhpcy5fdmlld0NvbnRhaW5lci5nZXQocmVjb3JkLmN1cnJlbnRJbmRleCk7XG4gICAgICAgICAgICAgICAgdmlld1JlZi5jb250ZXh0LiRpbXBsaWNpdCA9IHJlY29yZC5pdGVtO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIE5nRm9yLnByb3RvdHlwZS5fcGVyVmlld0NoYW5nZSA9IGZ1bmN0aW9uICh2aWV3LCByZWNvcmQpIHtcbiAgICAgICAgICAgIHZpZXcuY29udGV4dC4kaW1wbGljaXQgPSByZWNvcmQuaXRlbTtcbiAgICAgICAgfTtcbiAgICAgICAgTmdGb3IuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnW25nRm9yXVtuZ0Zvck9mXScgfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBOZ0Zvci5jdG9yUGFyYW1ldGVycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5WaWV3Q29udGFpbmVyUmVmLCB9LFxuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlRlbXBsYXRlUmVmLCB9LFxuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkl0ZXJhYmxlRGlmZmVycywgfSxcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5DaGFuZ2VEZXRlY3RvclJlZiwgfSxcbiAgICAgICAgXTtcbiAgICAgICAgTmdGb3IucHJvcERlY29yYXRvcnMgPSB7XG4gICAgICAgICAgICAnbmdGb3JPZic6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5wdXQgfSxdLFxuICAgICAgICAgICAgJ25nRm9yVHJhY2tCeSc6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5wdXQgfSxdLFxuICAgICAgICAgICAgJ25nRm9yVGVtcGxhdGUnOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLklucHV0IH0sXSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIE5nRm9yO1xuICAgIH0oKSk7XG4gICAgdmFyIFJlY29yZFZpZXdUdXBsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFJlY29yZFZpZXdUdXBsZShyZWNvcmQsIHZpZXcpIHtcbiAgICAgICAgICAgIHRoaXMucmVjb3JkID0gcmVjb3JkO1xuICAgICAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUmVjb3JkVmlld1R1cGxlO1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIG9yIHJlY3JlYXRlcyBhIHBvcnRpb24gb2YgdGhlIERPTSB0cmVlIGJhc2VkIG9uIGFuIHtleHByZXNzaW9ufS5cbiAgICAgKlxuICAgICAqIElmIHRoZSBleHByZXNzaW9uIGFzc2lnbmVkIHRvIGBuZ0lmYCBldmFsdWF0ZXMgdG8gYSBmYWxzeSB2YWx1ZSB0aGVuIHRoZSBlbGVtZW50XG4gICAgICogaXMgcmVtb3ZlZCBmcm9tIHRoZSBET00sIG90aGVyd2lzZSBhIGNsb25lIG9mIHRoZSBlbGVtZW50IGlzIHJlaW5zZXJ0ZWQgaW50byB0aGUgRE9NLlxuICAgICAqXG4gICAgICogIyMjIEV4YW1wbGUgKFtsaXZlIGRlbW9dKGh0dHA6Ly9wbG5rci5jby9lZGl0L2ZlMGtnZW1GQnRtUU9ZMzFiNHR3P3A9cHJldmlldykpOlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogPGRpdiAqbmdJZj1cImVycm9yQ291bnQgPiAwXCIgY2xhc3M9XCJlcnJvclwiPlxuICAgICAqICAgPCEtLSBFcnJvciBtZXNzYWdlIGRpc3BsYXllZCB3aGVuIHRoZSBlcnJvckNvdW50IHByb3BlcnR5IGluIHRoZSBjdXJyZW50IGNvbnRleHQgaXMgZ3JlYXRlclxuICAgICAqIHRoYW4gMC4gLS0+XG4gICAgICogICB7e2Vycm9yQ291bnR9fSBlcnJvcnMgZGV0ZWN0ZWRcbiAgICAgKiA8L2Rpdj5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqICMjIyBTeW50YXhcbiAgICAgKlxuICAgICAqIC0gYDxkaXYgKm5nSWY9XCJjb25kaXRpb25cIj4uLi48L2Rpdj5gXG4gICAgICogLSBgPGRpdiB0ZW1wbGF0ZT1cIm5nSWYgY29uZGl0aW9uXCI+Li4uPC9kaXY+YFxuICAgICAqIC0gYDx0ZW1wbGF0ZSBbbmdJZl09XCJjb25kaXRpb25cIj48ZGl2Pi4uLjwvZGl2PjwvdGVtcGxhdGU+YFxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBOZ0lmID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gTmdJZihfdmlld0NvbnRhaW5lciwgX3RlbXBsYXRlKSB7XG4gICAgICAgICAgICB0aGlzLl92aWV3Q29udGFpbmVyID0gX3ZpZXdDb250YWluZXI7XG4gICAgICAgICAgICB0aGlzLl90ZW1wbGF0ZSA9IF90ZW1wbGF0ZTtcbiAgICAgICAgICAgIHRoaXMuX2hhc1ZpZXcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdJZi5wcm90b3R5cGUsIFwibmdJZlwiLCB7XG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIChjb25kaXRpb24pIHtcbiAgICAgICAgICAgICAgICBpZiAoY29uZGl0aW9uICYmICF0aGlzLl9oYXNWaWV3KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2hhc1ZpZXcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl92aWV3Q29udGFpbmVyLmNyZWF0ZUVtYmVkZGVkVmlldyh0aGlzLl90ZW1wbGF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFjb25kaXRpb24gJiYgdGhpcy5faGFzVmlldykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9oYXNWaWV3ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3ZpZXdDb250YWluZXIuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgTmdJZi5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSwgYXJnczogW3sgc2VsZWN0b3I6ICdbbmdJZl0nIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgTmdJZi5jdG9yUGFyYW1ldGVycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5WaWV3Q29udGFpbmVyUmVmLCB9LFxuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlRlbXBsYXRlUmVmLCB9LFxuICAgICAgICBdO1xuICAgICAgICBOZ0lmLnByb3BEZWNvcmF0b3JzID0ge1xuICAgICAgICAgICAgJ25nSWYnOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLklucHV0IH0sXSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIE5nSWY7XG4gICAgfSgpKTtcblxuICAgIHZhciBfQ0FTRV9ERUZBVUxUID0ge307XG4gICAgdmFyIFN3aXRjaFZpZXcgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBTd2l0Y2hWaWV3KF92aWV3Q29udGFpbmVyUmVmLCBfdGVtcGxhdGVSZWYpIHtcbiAgICAgICAgICAgIHRoaXMuX3ZpZXdDb250YWluZXJSZWYgPSBfdmlld0NvbnRhaW5lclJlZjtcbiAgICAgICAgICAgIHRoaXMuX3RlbXBsYXRlUmVmID0gX3RlbXBsYXRlUmVmO1xuICAgICAgICB9XG4gICAgICAgIFN3aXRjaFZpZXcucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fdmlld0NvbnRhaW5lclJlZi5jcmVhdGVFbWJlZGRlZFZpZXcodGhpcy5fdGVtcGxhdGVSZWYpOyB9O1xuICAgICAgICBTd2l0Y2hWaWV3LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkgeyB0aGlzLl92aWV3Q29udGFpbmVyUmVmLmNsZWFyKCk7IH07XG4gICAgICAgIHJldHVybiBTd2l0Y2hWaWV3O1xuICAgIH0oKSk7XG4gICAgLyoqXG4gICAgICogQG5nTW9kdWxlIENvbW1vbk1vZHVsZVxuICAgICAqXG4gICAgICogQHdoYXRJdERvZXMgQWRkcyAvIHJlbW92ZXMgRE9NIHN1Yi10cmVlcyB3aGVuIHRoZSBuZXN0IG1hdGNoIGV4cHJlc3Npb25zIG1hdGNoZXMgdGhlIHN3aXRjaFxuICAgICAqICAgICAgICAgICAgIGV4cHJlc3Npb24uXG4gICAgICpcbiAgICAgKiBAaG93VG9Vc2VcbiAgICAgKiBgYGBcbiAgICAgKiAgICAgPGNvbnRhaW5lci1lbGVtZW50IFtuZ1N3aXRjaF09XCJzd2l0Y2hfZXhwcmVzc2lvblwiPlxuICAgICAqICAgICAgIDxzb21lLWVsZW1lbnQgKm5nU3dpdGNoQ2FzZT1cIm1hdGNoX2V4cHJlc3Npb25fMVwiPi4uLjwvc29tZS1lbGVtZW50PlxuICAgICAqICAgICAgIDxzb21lLWVsZW1lbnQgKm5nU3dpdGNoQ2FzZT1cIm1hdGNoX2V4cHJlc3Npb25fMlwiPi4uLjwvc29tZS1lbGVtZW50PlxuICAgICAqICAgICAgIDxzb21lLW90aGVyLWVsZW1lbnQgKm5nU3dpdGNoQ2FzZT1cIm1hdGNoX2V4cHJlc3Npb25fM1wiPi4uLjwvc29tZS1vdGhlci1lbGVtZW50PlxuICAgICAqICAgICAgIDxuZy1jb250YWluZXIgKm5nU3dpdGNoQ2FzZT1cIm1hdGNoX2V4cHJlc3Npb25fM1wiPlxuICAgICAqICAgICAgICAgPCEtLSB1c2UgYSBuZy1jb250YWluZXIgdG8gZ3JvdXAgbXVsdGlwbGUgcm9vdCBub2RlcyAtLT5cbiAgICAgKiAgICAgICAgIDxpbm5lci1lbGVtZW50PjwvaW5uZXItZWxlbWVudD5cbiAgICAgKiAgICAgICAgIDxpbm5lci1vdGhlci1lbGVtZW50PjwvaW5uZXItb3RoZXItZWxlbWVudD5cbiAgICAgKiAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgKiAgICAgICA8c29tZS1lbGVtZW50ICpuZ1N3aXRjaERlZmF1bHQ+Li4uPC9zb21lLWVsZW1lbnQ+XG4gICAgICogICAgIDwvY29udGFpbmVyLWVsZW1lbnQ+XG4gICAgICogYGBgXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICpcbiAgICAgKiBgTmdTd2l0Y2hgIHN0YW1wcyBvdXQgbmVzdGVkIHZpZXdzIHdoZW4gdGhlaXIgbWF0Y2ggZXhwcmVzc2lvbiB2YWx1ZSBtYXRjaGVzIHRoZSB2YWx1ZSBvZiB0aGVcbiAgICAgKiBzd2l0Y2ggZXhwcmVzc2lvbi5cbiAgICAgKlxuICAgICAqIEluIG90aGVyIHdvcmRzOlxuICAgICAqIC0geW91IGRlZmluZSBhIGNvbnRhaW5lciBlbGVtZW50ICh3aGVyZSB5b3UgcGxhY2UgdGhlIGRpcmVjdGl2ZSB3aXRoIGEgc3dpdGNoIGV4cHJlc3Npb24gb24gdGhlXG4gICAgICogYFtuZ1N3aXRjaF09XCIuLi5cImAgYXR0cmlidXRlKVxuICAgICAqIC0geW91IGRlZmluZSBpbm5lciB2aWV3cyBpbnNpZGUgdGhlIGBOZ1N3aXRjaGAgYW5kIHBsYWNlIGEgYCpuZ1N3aXRjaENhc2VgIGF0dHJpYnV0ZSBvbiB0aGUgdmlld1xuICAgICAqIHJvb3QgZWxlbWVudHMuXG4gICAgICpcbiAgICAgKiBFbGVtZW50cyB3aXRoaW4gYE5nU3dpdGNoYCBidXQgb3V0c2lkZSBvZiBhIGBOZ1N3aXRjaENhc2VgIG9yIGBOZ1N3aXRjaERlZmF1bHRgIGRpcmVjdGl2ZXMgd2lsbFxuICAgICAqIGJlIHByZXNlcnZlZCBhdCB0aGUgbG9jYXRpb24uXG4gICAgICpcbiAgICAgKiBUaGUgYG5nU3dpdGNoQ2FzZWAgZGlyZWN0aXZlIGluZm9ybXMgdGhlIHBhcmVudCBgTmdTd2l0Y2hgIG9mIHdoaWNoIHZpZXcgdG8gZGlzcGxheSB3aGVuIHRoZVxuICAgICAqIGV4cHJlc3Npb24gaXMgZXZhbHVhdGVkLlxuICAgICAqIFdoZW4gbm8gbWF0Y2hpbmcgZXhwcmVzc2lvbiBpcyBmb3VuZCBvbiBhIGBuZ1N3aXRjaENhc2VgIHZpZXcsIHRoZSBgbmdTd2l0Y2hEZWZhdWx0YCB2aWV3IGlzXG4gICAgICogc3RhbXBlZCBvdXQuXG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIE5nU3dpdGNoID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gTmdTd2l0Y2goKSB7XG4gICAgICAgICAgICB0aGlzLl91c2VEZWZhdWx0ID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl92YWx1ZVZpZXdzID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgdGhpcy5fYWN0aXZlVmlld3MgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdTd2l0Y2gucHJvdG90eXBlLCBcIm5nU3dpdGNoXCIsIHtcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgLy8gU2V0IG9mIHZpZXdzIHRvIGRpc3BsYXkgZm9yIHRoaXMgdmFsdWVcbiAgICAgICAgICAgICAgICB2YXIgdmlld3MgPSB0aGlzLl92YWx1ZVZpZXdzLmdldCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKHZpZXdzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3VzZURlZmF1bHQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5vIHZpZXcgdG8gZGlzcGxheSBmb3IgdGhlIGN1cnJlbnQgdmFsdWUgLT4gZGVmYXVsdCBjYXNlXG4gICAgICAgICAgICAgICAgICAgIC8vIE5vdGhpbmcgdG8gZG8gaWYgdGhlIGRlZmF1bHQgY2FzZSB3YXMgYWxyZWFkeSBhY3RpdmVcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3VzZURlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl91c2VEZWZhdWx0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdmlld3MgPSB0aGlzLl92YWx1ZVZpZXdzLmdldChfQ0FTRV9ERUZBVUxUKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fZW1wdHlBbGxBY3RpdmVWaWV3cygpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2FjdGl2YXRlVmlld3Modmlld3MpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3N3aXRjaFZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBOZ1N3aXRjaC5wcm90b3R5cGUuX29uQ2FzZVZhbHVlQ2hhbmdlZCA9IGZ1bmN0aW9uIChvbGRDYXNlLCBuZXdDYXNlLCB2aWV3KSB7XG4gICAgICAgICAgICB0aGlzLl9kZXJlZ2lzdGVyVmlldyhvbGRDYXNlLCB2aWV3KTtcbiAgICAgICAgICAgIHRoaXMuX3JlZ2lzdGVyVmlldyhuZXdDYXNlLCB2aWV3KTtcbiAgICAgICAgICAgIGlmIChvbGRDYXNlID09PSB0aGlzLl9zd2l0Y2hWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHZpZXcuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgIExpc3RXcmFwcGVyLnJlbW92ZSh0aGlzLl9hY3RpdmVWaWV3cywgdmlldyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChuZXdDYXNlID09PSB0aGlzLl9zd2l0Y2hWYWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl91c2VEZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3VzZURlZmF1bHQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZW1wdHlBbGxBY3RpdmVWaWV3cygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2aWV3LmNyZWF0ZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2FjdGl2ZVZpZXdzLnB1c2godmlldyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTd2l0Y2ggdG8gZGVmYXVsdCB3aGVuIHRoZXJlIGlzIG5vIG1vcmUgYWN0aXZlIFZpZXdDb250YWluZXJzXG4gICAgICAgICAgICBpZiAodGhpcy5fYWN0aXZlVmlld3MubGVuZ3RoID09PSAwICYmICF0aGlzLl91c2VEZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdXNlRGVmYXVsdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0aXZhdGVWaWV3cyh0aGlzLl92YWx1ZVZpZXdzLmdldChfQ0FTRV9ERUZBVUxUKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIE5nU3dpdGNoLnByb3RvdHlwZS5fZW1wdHlBbGxBY3RpdmVWaWV3cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBhY3RpdmVDb250YWluZXJzID0gdGhpcy5fYWN0aXZlVmlld3M7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFjdGl2ZUNvbnRhaW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBhY3RpdmVDb250YWluZXJzW2ldLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2FjdGl2ZVZpZXdzID0gW107XG4gICAgICAgIH07XG4gICAgICAgIE5nU3dpdGNoLnByb3RvdHlwZS5fYWN0aXZhdGVWaWV3cyA9IGZ1bmN0aW9uICh2aWV3cykge1xuICAgICAgICAgICAgaWYgKHZpZXdzKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2aWV3cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2aWV3c1tpXS5jcmVhdGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0aXZlVmlld3MgPSB2aWV3cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBOZ1N3aXRjaC5wcm90b3R5cGUuX3JlZ2lzdGVyVmlldyA9IGZ1bmN0aW9uICh2YWx1ZSwgdmlldykge1xuICAgICAgICAgICAgdmFyIHZpZXdzID0gdGhpcy5fdmFsdWVWaWV3cy5nZXQodmFsdWUpO1xuICAgICAgICAgICAgaWYgKCF2aWV3cykge1xuICAgICAgICAgICAgICAgIHZpZXdzID0gW107XG4gICAgICAgICAgICAgICAgdGhpcy5fdmFsdWVWaWV3cy5zZXQodmFsdWUsIHZpZXdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZpZXdzLnB1c2godmlldyk7XG4gICAgICAgIH07XG4gICAgICAgIE5nU3dpdGNoLnByb3RvdHlwZS5fZGVyZWdpc3RlclZpZXcgPSBmdW5jdGlvbiAodmFsdWUsIHZpZXcpIHtcbiAgICAgICAgICAgIC8vIGBfQ0FTRV9ERUZBVUxUYCBpcyB1c2VkIGEgbWFya2VyIGZvciBub24tcmVnaXN0ZXJlZCBjYXNlc1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBfQ0FTRV9ERUZBVUxUKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHZhciB2aWV3cyA9IHRoaXMuX3ZhbHVlVmlld3MuZ2V0KHZhbHVlKTtcbiAgICAgICAgICAgIGlmICh2aWV3cy5sZW5ndGggPT0gMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlVmlld3MuZGVsZXRlKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIExpc3RXcmFwcGVyLnJlbW92ZSh2aWV3cywgdmlldyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIE5nU3dpdGNoLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlLCBhcmdzOiBbeyBzZWxlY3RvcjogJ1tuZ1N3aXRjaF0nIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgTmdTd2l0Y2guY3RvclBhcmFtZXRlcnMgPSBbXTtcbiAgICAgICAgTmdTd2l0Y2gucHJvcERlY29yYXRvcnMgPSB7XG4gICAgICAgICAgICAnbmdTd2l0Y2gnOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLklucHV0IH0sXSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIE5nU3dpdGNoO1xuICAgIH0oKSk7XG4gICAgLyoqXG4gICAgICogQG5nTW9kdWxlIENvbW1vbk1vZHVsZVxuICAgICAqXG4gICAgICogQHdoYXRJdERvZXMgQ3JlYXRlcyBhIHZpZXcgdGhhdCB3aWxsIGJlIGFkZGVkL3JlbW92ZWQgZnJvbSB0aGUgcGFyZW50IHtAbGluayBOZ1N3aXRjaH0gd2hlbiB0aGVcbiAgICAgKiAgICAgICAgICAgICBnaXZlbiBleHByZXNzaW9uIGV2YWx1YXRlIHRvIHJlc3BlY3RpdmVseSB0aGUgc2FtZS9kaWZmZXJlbnQgdmFsdWUgYXMgdGhlIHN3aXRjaFxuICAgICAqICAgICAgICAgICAgIGV4cHJlc3Npb24uXG4gICAgICpcbiAgICAgKiBAaG93VG9Vc2VcbiAgICAgKiBgYGBcbiAgICAgKiA8Y29udGFpbmVyLWVsZW1lbnQgW25nU3dpdGNoXT1cInN3aXRjaF9leHByZXNzaW9uXCI+XG4gICAgICogICA8c29tZS1lbGVtZW50ICpuZ1N3aXRjaENhc2U9XCJtYXRjaF9leHByZXNzaW9uXzFcIj4uLi48L3NvbWUtZWxlbWVudD5cbiAgICAgKiA8L2NvbnRhaW5lci1lbGVtZW50PlxuICAgICAqYGBgXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICpcbiAgICAgKiBJbnNlcnQgdGhlIHN1Yi10cmVlIHdoZW4gdGhlIGV4cHJlc3Npb24gZXZhbHVhdGVzIHRvIHRoZSBzYW1lIHZhbHVlIGFzIHRoZSBlbmNsb3Npbmcgc3dpdGNoXG4gICAgICogZXhwcmVzc2lvbi5cbiAgICAgKlxuICAgICAqIElmIG11bHRpcGxlIG1hdGNoIGV4cHJlc3Npb25zIG1hdGNoIHRoZSBzd2l0Y2ggZXhwcmVzc2lvbiB2YWx1ZSwgYWxsIG9mIHRoZW0gYXJlIGRpc3BsYXllZC5cbiAgICAgKlxuICAgICAqIFNlZSB7QGxpbmsgTmdTd2l0Y2h9IGZvciBtb3JlIGRldGFpbHMgYW5kIGV4YW1wbGUuXG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIE5nU3dpdGNoQ2FzZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIE5nU3dpdGNoQ2FzZSh2aWV3Q29udGFpbmVyLCB0ZW1wbGF0ZVJlZiwgbmdTd2l0Y2gpIHtcbiAgICAgICAgICAgIC8vIGBfQ0FTRV9ERUZBVUxUYCBpcyB1c2VkIGFzIGEgbWFya2VyIGZvciBhIG5vdCB5ZXQgaW5pdGlhbGl6ZWQgdmFsdWVcbiAgICAgICAgICAgIHRoaXMuX3ZhbHVlID0gX0NBU0VfREVGQVVMVDtcbiAgICAgICAgICAgIHRoaXMuX3N3aXRjaCA9IG5nU3dpdGNoO1xuICAgICAgICAgICAgdGhpcy5fdmlldyA9IG5ldyBTd2l0Y2hWaWV3KHZpZXdDb250YWluZXIsIHRlbXBsYXRlUmVmKTtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdTd2l0Y2hDYXNlLnByb3RvdHlwZSwgXCJuZ1N3aXRjaENhc2VcIiwge1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zd2l0Y2guX29uQ2FzZVZhbHVlQ2hhbmdlZCh0aGlzLl92YWx1ZSwgdmFsdWUsIHRoaXMuX3ZpZXcpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgTmdTd2l0Y2hDYXNlLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlLCBhcmdzOiBbeyBzZWxlY3RvcjogJ1tuZ1N3aXRjaENhc2VdJyB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIE5nU3dpdGNoQ2FzZS5jdG9yUGFyYW1ldGVycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5WaWV3Q29udGFpbmVyUmVmLCB9LFxuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlRlbXBsYXRlUmVmLCB9LFxuICAgICAgICAgICAgeyB0eXBlOiBOZ1N3aXRjaCwgZGVjb3JhdG9yczogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5Ib3N0IH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICBOZ1N3aXRjaENhc2UucHJvcERlY29yYXRvcnMgPSB7XG4gICAgICAgICAgICAnbmdTd2l0Y2hDYXNlJzogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5JbnB1dCB9LF0sXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBOZ1N3aXRjaENhc2U7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBAbmdNb2R1bGUgQ29tbW9uTW9kdWxlXG4gICAgICogQHdoYXRJdERvZXMgQ3JlYXRlcyBhIHZpZXcgdGhhdCBpcyBhZGRlZCB0byB0aGUgcGFyZW50IHtAbGluayBOZ1N3aXRjaH0gd2hlbiBubyBjYXNlIGV4cHJlc3Npb25zXG4gICAgICogbWF0Y2ggdGhlXG4gICAgICogICAgICAgICAgICAgc3dpdGNoIGV4cHJlc3Npb24uXG4gICAgICpcbiAgICAgKiBAaG93VG9Vc2VcbiAgICAgKiBgYGBcbiAgICAgKiA8Y29udGFpbmVyLWVsZW1lbnQgW25nU3dpdGNoXT1cInN3aXRjaF9leHByZXNzaW9uXCI+XG4gICAgICogICA8c29tZS1lbGVtZW50ICpuZ1N3aXRjaENhc2U9XCJtYXRjaF9leHByZXNzaW9uXzFcIj4uLi48L3NvbWUtZWxlbWVudD5cbiAgICAgKiAgIDxzb21lLW90aGVyLWVsZW1lbnQgKm5nU3dpdGNoRGVmYXVsdD4uLi48L3NvbWUtb3RoZXItZWxlbWVudD5cbiAgICAgKiA8L2NvbnRhaW5lci1lbGVtZW50PlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICpcbiAgICAgKiBJbnNlcnQgdGhlIHN1Yi10cmVlIHdoZW4gbm8gY2FzZSBleHByZXNzaW9ucyBldmFsdWF0ZSB0byB0aGUgc2FtZSB2YWx1ZSBhcyB0aGUgZW5jbG9zaW5nIHN3aXRjaFxuICAgICAqIGV4cHJlc3Npb24uXG4gICAgICpcbiAgICAgKiBTZWUge0BsaW5rIE5nU3dpdGNofSBmb3IgbW9yZSBkZXRhaWxzIGFuZCBleGFtcGxlLlxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBOZ1N3aXRjaERlZmF1bHQgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBOZ1N3aXRjaERlZmF1bHQodmlld0NvbnRhaW5lciwgdGVtcGxhdGVSZWYsIHNzd2l0Y2gpIHtcbiAgICAgICAgICAgIHNzd2l0Y2guX3JlZ2lzdGVyVmlldyhfQ0FTRV9ERUZBVUxULCBuZXcgU3dpdGNoVmlldyh2aWV3Q29udGFpbmVyLCB0ZW1wbGF0ZVJlZikpO1xuICAgICAgICB9XG4gICAgICAgIE5nU3dpdGNoRGVmYXVsdC5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSwgYXJnczogW3sgc2VsZWN0b3I6ICdbbmdTd2l0Y2hEZWZhdWx0XScgfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBOZ1N3aXRjaERlZmF1bHQuY3RvclBhcmFtZXRlcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuVmlld0NvbnRhaW5lclJlZiwgfSxcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5UZW1wbGF0ZVJlZiwgfSxcbiAgICAgICAgICAgIHsgdHlwZTogTmdTd2l0Y2gsIGRlY29yYXRvcnM6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSG9zdCB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIE5nU3dpdGNoRGVmYXVsdDtcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogQG5nTW9kdWxlIENvbW1vbk1vZHVsZVxuICAgICAqXG4gICAgICogQHdoYXRJdERvZXMgQWRkcyAvIHJlbW92ZXMgRE9NIHN1Yi10cmVlcyBiYXNlZCBvbiBhIG51bWVyaWMgdmFsdWUuIFRhaWxvcmVkIGZvciBwbHVyYWxpemF0aW9uLlxuICAgICAqXG4gICAgICogQGhvd1RvVXNlXG4gICAgICogYGBgXG4gICAgICogPHNvbWUtZWxlbWVudCBbbmdQbHVyYWxdPVwidmFsdWVcIj5cbiAgICAgKiAgIDxuZy1jb250YWluZXIgKm5nUGx1cmFsQ2FzZT1cIic9MCdcIj50aGVyZSBpcyBub3RoaW5nPC9uZy1jb250YWluZXI+XG4gICAgICogICA8bmctY29udGFpbmVyICpuZ1BsdXJhbENhc2U9XCInPTEnXCI+dGhlcmUgaXMgb25lPC9uZy1jb250YWluZXI+XG4gICAgICogICA8bmctY29udGFpbmVyICpuZ1BsdXJhbENhc2U9XCInZmV3J1wiPnRoZXJlIGFyZSBhIGZldzwvbmctY29udGFpbmVyPlxuICAgICAqICAgPG5nLWNvbnRhaW5lciAqbmdQbHVyYWxDYXNlPVwiJ290aGVyJ1wiPnRoZXJlIGFyZSBleGFjdGx5ICM8L25nLWNvbnRhaW5lcj5cbiAgICAgKiA8L3NvbWUtZWxlbWVudD5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqXG4gICAgICogRGlzcGxheXMgRE9NIHN1Yi10cmVlcyB0aGF0IG1hdGNoIHRoZSBzd2l0Y2ggZXhwcmVzc2lvbiB2YWx1ZSwgb3IgZmFpbGluZyB0aGF0LCBET00gc3ViLXRyZWVzXG4gICAgICogdGhhdCBtYXRjaCB0aGUgc3dpdGNoIGV4cHJlc3Npb24ncyBwbHVyYWxpemF0aW9uIGNhdGVnb3J5LlxuICAgICAqXG4gICAgICogVG8gdXNlIHRoaXMgZGlyZWN0aXZlIHlvdSBtdXN0IHByb3ZpZGUgYSBjb250YWluZXIgZWxlbWVudCB0aGF0IHNldHMgdGhlIGBbbmdQbHVyYWxdYCBhdHRyaWJ1dGVcbiAgICAgKiB0byBhIHN3aXRjaCBleHByZXNzaW9uLiBJbm5lciBlbGVtZW50cyB3aXRoIGEgYFtuZ1BsdXJhbENhc2VdYCB3aWxsIGRpc3BsYXkgYmFzZWQgb24gdGhlaXJcbiAgICAgKiBleHByZXNzaW9uOlxuICAgICAqIC0gaWYgYFtuZ1BsdXJhbENhc2VdYCBpcyBzZXQgdG8gYSB2YWx1ZSBzdGFydGluZyB3aXRoIGA9YCwgaXQgd2lsbCBvbmx5IGRpc3BsYXkgaWYgdGhlIHZhbHVlXG4gICAgICogICBtYXRjaGVzIHRoZSBzd2l0Y2ggZXhwcmVzc2lvbiBleGFjdGx5LFxuICAgICAqIC0gb3RoZXJ3aXNlLCB0aGUgdmlldyB3aWxsIGJlIHRyZWF0ZWQgYXMgYSBcImNhdGVnb3J5IG1hdGNoXCIsIGFuZCB3aWxsIG9ubHkgZGlzcGxheSBpZiBleGFjdFxuICAgICAqICAgdmFsdWUgbWF0Y2hlcyBhcmVuJ3QgZm91bmQgYW5kIHRoZSB2YWx1ZSBtYXBzIHRvIGl0cyBjYXRlZ29yeSBmb3IgdGhlIGRlZmluZWQgbG9jYWxlLlxuICAgICAqXG4gICAgICogU2VlIGh0dHA6Ly9jbGRyLnVuaWNvZGUub3JnL2luZGV4L2NsZHItc3BlYy9wbHVyYWwtcnVsZXNcbiAgICAgKlxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICB2YXIgTmdQbHVyYWwgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBOZ1BsdXJhbChfbG9jYWxpemF0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLl9sb2NhbGl6YXRpb24gPSBfbG9jYWxpemF0aW9uO1xuICAgICAgICAgICAgdGhpcy5fY2FzZVZpZXdzID0ge307XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nUGx1cmFsLnByb3RvdHlwZSwgXCJuZ1BsdXJhbFwiLCB7XG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3N3aXRjaFZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlVmlldygpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE5nUGx1cmFsLnByb3RvdHlwZS5hZGRDYXNlID0gZnVuY3Rpb24gKHZhbHVlLCBzd2l0Y2hWaWV3KSB7IHRoaXMuX2Nhc2VWaWV3c1t2YWx1ZV0gPSBzd2l0Y2hWaWV3OyB9O1xuICAgICAgICBOZ1BsdXJhbC5wcm90b3R5cGUuX3VwZGF0ZVZpZXcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9jbGVhclZpZXdzKCk7XG4gICAgICAgICAgICB2YXIgY2FzZXMgPSBPYmplY3Qua2V5cyh0aGlzLl9jYXNlVmlld3MpO1xuICAgICAgICAgICAgdmFyIGtleSA9IGdldFBsdXJhbENhdGVnb3J5KHRoaXMuX3N3aXRjaFZhbHVlLCBjYXNlcywgdGhpcy5fbG9jYWxpemF0aW9uKTtcbiAgICAgICAgICAgIHRoaXMuX2FjdGl2YXRlVmlldyh0aGlzLl9jYXNlVmlld3Nba2V5XSk7XG4gICAgICAgIH07XG4gICAgICAgIE5nUGx1cmFsLnByb3RvdHlwZS5fY2xlYXJWaWV3cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9hY3RpdmVWaWV3KVxuICAgICAgICAgICAgICAgIHRoaXMuX2FjdGl2ZVZpZXcuZGVzdHJveSgpO1xuICAgICAgICB9O1xuICAgICAgICBOZ1BsdXJhbC5wcm90b3R5cGUuX2FjdGl2YXRlVmlldyA9IGZ1bmN0aW9uICh2aWV3KSB7XG4gICAgICAgICAgICBpZiAodmlldykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FjdGl2ZVZpZXcgPSB2aWV3O1xuICAgICAgICAgICAgICAgIHRoaXMuX2FjdGl2ZVZpZXcuY3JlYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIE5nUGx1cmFsLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlLCBhcmdzOiBbeyBzZWxlY3RvcjogJ1tuZ1BsdXJhbF0nIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgTmdQbHVyYWwuY3RvclBhcmFtZXRlcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IE5nTG9jYWxpemF0aW9uLCB9LFxuICAgICAgICBdO1xuICAgICAgICBOZ1BsdXJhbC5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAgICAgICAgICduZ1BsdXJhbCc6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5wdXQgfSxdLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gTmdQbHVyYWw7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBAbmdNb2R1bGUgQ29tbW9uTW9kdWxlXG4gICAgICpcbiAgICAgKiBAd2hhdEl0RG9lcyBDcmVhdGVzIGEgdmlldyB0aGF0IHdpbGwgYmUgYWRkZWQvcmVtb3ZlZCBmcm9tIHRoZSBwYXJlbnQge0BsaW5rIE5nUGx1cmFsfSB3aGVuIHRoZVxuICAgICAqICAgICAgICAgICAgIGdpdmVuIGV4cHJlc3Npb24gbWF0Y2hlcyB0aGUgcGx1cmFsIGV4cHJlc3Npb24gYWNjb3JkaW5nIHRvIENMRFIgcnVsZXMuXG4gICAgICpcbiAgICAgKiBAaG93VG9Vc2VcbiAgICAgKiBgYGBcbiAgICAgKiA8c29tZS1lbGVtZW50IFtuZ1BsdXJhbF09XCJ2YWx1ZVwiPlxuICAgICAqICAgPG5nLWNvbnRhaW5lciAqbmdQbHVyYWxDYXNlPVwiJz0wJ1wiPi4uLjwvbmctY29udGFpbmVyPlxuICAgICAqICAgPG5nLWNvbnRhaW5lciAqbmdQbHVyYWxDYXNlPVwiJ290aGVyJ1wiPi4uLjwvbmctY29udGFpbmVyPlxuICAgICAqIDwvc29tZS1lbGVtZW50PlxuICAgICAqYGBgXG4gICAgICpcbiAgICAgKiBTZWUge0BsaW5rIE5nUGx1cmFsfSBmb3IgbW9yZSBkZXRhaWxzIGFuZCBleGFtcGxlLlxuICAgICAqXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIHZhciBOZ1BsdXJhbENhc2UgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBOZ1BsdXJhbENhc2UodmFsdWUsIHRlbXBsYXRlLCB2aWV3Q29udGFpbmVyLCBuZ1BsdXJhbCkge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgbmdQbHVyYWwuYWRkQ2FzZSh2YWx1ZSwgbmV3IFN3aXRjaFZpZXcodmlld0NvbnRhaW5lciwgdGVtcGxhdGUpKTtcbiAgICAgICAgfVxuICAgICAgICBOZ1BsdXJhbENhc2UuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnW25nUGx1cmFsQ2FzZV0nIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgTmdQbHVyYWxDYXNlLmN0b3JQYXJhbWV0ZXJzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuQXR0cmlidXRlLCBhcmdzOiBbJ25nUGx1cmFsQ2FzZScsXSB9LF0gfSxcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5UZW1wbGF0ZVJlZiwgfSxcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5WaWV3Q29udGFpbmVyUmVmLCB9LFxuICAgICAgICAgICAgeyB0eXBlOiBOZ1BsdXJhbCwgZGVjb3JhdG9yczogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5Ib3N0IH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gTmdQbHVyYWxDYXNlO1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBAbmdNb2R1bGUgQ29tbW9uTW9kdWxlXG4gICAgICpcbiAgICAgKiBAd2hhdEl0RG9lcyBVcGRhdGUgYW4gSFRNTCBlbGVtZW50IHN0eWxlcy5cbiAgICAgKlxuICAgICAqIEBob3dUb1VzZVxuICAgICAqIGBgYFxuICAgICAqIDxzb21lLWVsZW1lbnQgW25nU3R5bGVdPVwieydmb250LXN0eWxlJzogc3R5bGVFeHB9XCI+Li4uPC9zb21lLWVsZW1lbnQ+XG4gICAgICpcbiAgICAgKiA8c29tZS1lbGVtZW50IFtuZ1N0eWxlXT1cInsnbWF4LXdpZHRoLnB4Jzogd2lkdGhFeHB9XCI+Li4uPC9zb21lLWVsZW1lbnQ+XG4gICAgICpcbiAgICAgKiA8c29tZS1lbGVtZW50IFtuZ1N0eWxlXT1cIm9iakV4cFwiPi4uLjwvc29tZS1lbGVtZW50PlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICpcbiAgICAgKiBUaGUgc3R5bGVzIGFyZSB1cGRhdGVkIGFjY29yZGluZyB0byB0aGUgdmFsdWUgb2YgdGhlIGV4cHJlc3Npb24gZXZhbHVhdGlvbjpcbiAgICAgKiAtIGtleXMgYXJlIHN0eWxlIG5hbWVzIHdpdGggYW4gb3B0aW9uIGAuPHVuaXQ+YCBzdWZmaXggKGllICd0b3AucHgnLCAnZm9udC1zdHlsZS5lbScpLFxuICAgICAqIC0gdmFsdWVzIGFyZSB0aGUgdmFsdWVzIGFzc2lnbmVkIHRvIHRob3NlIHByb3BlcnRpZXMgKGV4cHJlc3NlZCBpbiB0aGUgZ2l2ZW4gdW5pdCkuXG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIE5nU3R5bGUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBOZ1N0eWxlKF9kaWZmZXJzLCBfbmdFbCwgX3JlbmRlcmVyKSB7XG4gICAgICAgICAgICB0aGlzLl9kaWZmZXJzID0gX2RpZmZlcnM7XG4gICAgICAgICAgICB0aGlzLl9uZ0VsID0gX25nRWw7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlciA9IF9yZW5kZXJlcjtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdTdHlsZS5wcm90b3R5cGUsIFwibmdTdHlsZVwiLCB7XG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbmdTdHlsZSA9IHY7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9kaWZmZXIgJiYgdikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaWZmZXIgPSB0aGlzLl9kaWZmZXJzLmZpbmQodikuY3JlYXRlKG51bGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBOZ1N0eWxlLnByb3RvdHlwZS5uZ0RvQ2hlY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fZGlmZmVyKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoYW5nZXMgPSB0aGlzLl9kaWZmZXIuZGlmZih0aGlzLl9uZ1N0eWxlKTtcbiAgICAgICAgICAgICAgICBpZiAoY2hhbmdlcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hcHBseUNoYW5nZXMoY2hhbmdlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBOZ1N0eWxlLnByb3RvdHlwZS5fYXBwbHlDaGFuZ2VzID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICBjaGFuZ2VzLmZvckVhY2hSZW1vdmVkSXRlbShmdW5jdGlvbiAocmVjb3JkKSB7IHJldHVybiBfdGhpcy5fc2V0U3R5bGUocmVjb3JkLmtleSwgbnVsbCk7IH0pO1xuICAgICAgICAgICAgY2hhbmdlcy5mb3JFYWNoQWRkZWRJdGVtKGZ1bmN0aW9uIChyZWNvcmQpIHsgcmV0dXJuIF90aGlzLl9zZXRTdHlsZShyZWNvcmQua2V5LCByZWNvcmQuY3VycmVudFZhbHVlKTsgfSk7XG4gICAgICAgICAgICBjaGFuZ2VzLmZvckVhY2hDaGFuZ2VkSXRlbShmdW5jdGlvbiAocmVjb3JkKSB7IHJldHVybiBfdGhpcy5fc2V0U3R5bGUocmVjb3JkLmtleSwgcmVjb3JkLmN1cnJlbnRWYWx1ZSk7IH0pO1xuICAgICAgICB9O1xuICAgICAgICBOZ1N0eWxlLnByb3RvdHlwZS5fc2V0U3R5bGUgPSBmdW5jdGlvbiAobmFtZUFuZFVuaXQsIHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSBuYW1lQW5kVW5pdC5zcGxpdCgnLicpLCBuYW1lID0gX2FbMF0sIHVuaXQgPSBfYVsxXTtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgJiYgdW5pdCA/IFwiXCIgKyB2YWx1ZSArIHVuaXQgOiB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldEVsZW1lbnRTdHlsZSh0aGlzLl9uZ0VsLm5hdGl2ZUVsZW1lbnQsIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgTmdTdHlsZS5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSwgYXJnczogW3sgc2VsZWN0b3I6ICdbbmdTdHlsZV0nIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgTmdTdHlsZS5jdG9yUGFyYW1ldGVycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5LZXlWYWx1ZURpZmZlcnMsIH0sXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuRWxlbWVudFJlZiwgfSxcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5SZW5kZXJlciwgfSxcbiAgICAgICAgXTtcbiAgICAgICAgTmdTdHlsZS5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAgICAgICAgICduZ1N0eWxlJzogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5JbnB1dCB9LF0sXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBOZ1N0eWxlO1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBAbmdNb2R1bGUgQ29tbW9uTW9kdWxlXG4gICAgICpcbiAgICAgKiBAd2hhdEl0RG9lcyBJbnNlcnRzIGFuIGVtYmVkZGVkIHZpZXcgZnJvbSBhIHByZXBhcmVkIGBUZW1wbGF0ZVJlZmBcbiAgICAgKlxuICAgICAqIEBob3dUb1VzZVxuICAgICAqIGBgYFxuICAgICAqIDx0ZW1wbGF0ZSBbbmdUZW1wbGF0ZU91dGxldF09XCJ0ZW1wbGF0ZVJlZkV4cHJlc3Npb25cIlxuICAgICAqICAgICAgICAgICBbbmdPdXRsZXRDb250ZXh0XT1cIm9iamVjdEV4cHJlc3Npb25cIj5cbiAgICAgKiA8L3RlbXBsYXRlPlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICpcbiAgICAgKiBZb3UgY2FuIGF0dGFjaCBhIGNvbnRleHQgb2JqZWN0IHRvIHRoZSBgRW1iZWRkZWRWaWV3UmVmYCBieSBzZXR0aW5nIGBbbmdPdXRsZXRDb250ZXh0XWAuXG4gICAgICogYFtuZ091dGxldENvbnRleHRdYCBzaG91bGQgYmUgYW4gb2JqZWN0LCB0aGUgb2JqZWN0J3Mga2V5cyB3aWxsIGJlIHRoZSBsb2NhbCB0ZW1wbGF0ZSB2YXJpYWJsZXNcbiAgICAgKiBhdmFpbGFibGUgd2l0aGluIHRoZSBgVGVtcGxhdGVSZWZgLlxuICAgICAqXG4gICAgICogTm90ZTogdXNpbmcgdGhlIGtleSBgJGltcGxpY2l0YCBpbiB0aGUgY29udGV4dCBvYmplY3Qgd2lsbCBzZXQgaXQncyB2YWx1ZSBhcyBkZWZhdWx0LlxuICAgICAqXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIHZhciBOZ1RlbXBsYXRlT3V0bGV0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gTmdUZW1wbGF0ZU91dGxldChfdmlld0NvbnRhaW5lclJlZikge1xuICAgICAgICAgICAgdGhpcy5fdmlld0NvbnRhaW5lclJlZiA9IF92aWV3Q29udGFpbmVyUmVmO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ1RlbXBsYXRlT3V0bGV0LnByb3RvdHlwZSwgXCJuZ091dGxldENvbnRleHRcIiwge1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAoY29udGV4dCkgeyB0aGlzLl9jb250ZXh0ID0gY29udGV4dDsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ1RlbXBsYXRlT3V0bGV0LnByb3RvdHlwZSwgXCJuZ1RlbXBsYXRlT3V0bGV0XCIsIHtcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHRlbXBsYXRlUmVmKSB7IHRoaXMuX3RlbXBsYXRlUmVmID0gdGVtcGxhdGVSZWY7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBOZ1RlbXBsYXRlT3V0bGV0LnByb3RvdHlwZS5uZ09uQ2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fdmlld1JlZikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3ZpZXdDb250YWluZXJSZWYucmVtb3ZlKHRoaXMuX3ZpZXdDb250YWluZXJSZWYuaW5kZXhPZih0aGlzLl92aWV3UmVmKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fdGVtcGxhdGVSZWYpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl92aWV3UmVmID0gdGhpcy5fdmlld0NvbnRhaW5lclJlZi5jcmVhdGVFbWJlZGRlZFZpZXcodGhpcy5fdGVtcGxhdGVSZWYsIHRoaXMuX2NvbnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBOZ1RlbXBsYXRlT3V0bGV0LmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlLCBhcmdzOiBbeyBzZWxlY3RvcjogJ1tuZ1RlbXBsYXRlT3V0bGV0XScgfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBOZ1RlbXBsYXRlT3V0bGV0LmN0b3JQYXJhbWV0ZXJzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlZpZXdDb250YWluZXJSZWYsIH0sXG4gICAgICAgIF07XG4gICAgICAgIE5nVGVtcGxhdGVPdXRsZXQucHJvcERlY29yYXRvcnMgPSB7XG4gICAgICAgICAgICAnbmdPdXRsZXRDb250ZXh0JzogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5JbnB1dCB9LF0sXG4gICAgICAgICAgICAnbmdUZW1wbGF0ZU91dGxldCc6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5wdXQgfSxdLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gTmdUZW1wbGF0ZU91dGxldDtcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogQSBjb2xsZWN0aW9uIG9mIEFuZ3VsYXIgZGlyZWN0aXZlcyB0aGF0IGFyZSBsaWtlbHkgdG8gYmUgdXNlZCBpbiBlYWNoIGFuZCBldmVyeSBBbmd1bGFyXG4gICAgICogYXBwbGljYXRpb24uXG4gICAgICovXG4gICAgdmFyIENPTU1PTl9ESVJFQ1RJVkVTID0gW1xuICAgICAgICBOZ0NsYXNzLFxuICAgICAgICBOZ0ZvcixcbiAgICAgICAgTmdJZixcbiAgICAgICAgTmdUZW1wbGF0ZU91dGxldCxcbiAgICAgICAgTmdTdHlsZSxcbiAgICAgICAgTmdTd2l0Y2gsXG4gICAgICAgIE5nU3dpdGNoQ2FzZSxcbiAgICAgICAgTmdTd2l0Y2hEZWZhdWx0LFxuICAgICAgICBOZ1BsdXJhbCxcbiAgICAgICAgTmdQbHVyYWxDYXNlLFxuICAgIF07XG5cbiAgICB2YXIgaXNQcm9taXNlID0gX2FuZ3VsYXJfY29yZS5fX2NvcmVfcHJpdmF0ZV9fLmlzUHJvbWlzZTtcblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICB2YXIgX19leHRlbmRzJDQgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIEJhc2VFcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQ0KEJhc2VFcnJvciwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gQmFzZUVycm9yKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIC8vIEVycm9ycyBkb24ndCB1c2UgY3VycmVudCB0aGlzLCBpbnN0ZWFkIHRoZXkgY3JlYXRlIGEgbmV3IGluc3RhbmNlLlxuICAgICAgICAgICAgLy8gV2UgaGF2ZSB0byBkbyBmb3J3YXJkIGFsbCBvZiBvdXIgYXBpIHRvIHRoZSBuYXRpdmVJbnN0YW5jZS5cbiAgICAgICAgICAgIHZhciBuYXRpdmVFcnJvciA9IF9zdXBlci5jYWxsKHRoaXMsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgdGhpcy5fbmF0aXZlRXJyb3IgPSBuYXRpdmVFcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQmFzZUVycm9yLnByb3RvdHlwZSwgXCJtZXNzYWdlXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fbmF0aXZlRXJyb3IubWVzc2FnZTsgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKG1lc3NhZ2UpIHsgdGhpcy5fbmF0aXZlRXJyb3IubWVzc2FnZSA9IG1lc3NhZ2U7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQmFzZUVycm9yLnByb3RvdHlwZSwgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fbmF0aXZlRXJyb3IubmFtZTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCYXNlRXJyb3IucHJvdG90eXBlLCBcInN0YWNrXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fbmF0aXZlRXJyb3Iuc3RhY2s7IH0sXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkgeyB0aGlzLl9uYXRpdmVFcnJvci5zdGFjayA9IHZhbHVlOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgQmFzZUVycm9yLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX25hdGl2ZUVycm9yLnRvU3RyaW5nKCk7IH07XG4gICAgICAgIHJldHVybiBCYXNlRXJyb3I7XG4gICAgfShFcnJvcikpO1xuICAgIC8qKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgV3JhcHBlZEVycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDQoV3JhcHBlZEVycm9yLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBXcmFwcGVkRXJyb3IobWVzc2FnZSwgZXJyb3IpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIG1lc3NhZ2UgKyBcIiBjYXVzZWQgYnk6IFwiICsgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogZXJyb3IpKTtcbiAgICAgICAgICAgIHRoaXMub3JpZ2luYWxFcnJvciA9IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcmFwcGVkRXJyb3IucHJvdG90eXBlLCBcInN0YWNrXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAodGhpcy5vcmlnaW5hbEVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyB0aGlzLm9yaWdpbmFsRXJyb3IgOiB0aGlzLl9uYXRpdmVFcnJvcilcbiAgICAgICAgICAgICAgICAgICAgLnN0YWNrO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBXcmFwcGVkRXJyb3I7XG4gICAgfShCYXNlRXJyb3IpKTtcblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICB2YXIgX19leHRlbmRzJDMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbiAgICB2YXIgSW52YWxpZFBpcGVBcmd1bWVudEVycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDMoSW52YWxpZFBpcGVBcmd1bWVudEVycm9yLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBJbnZhbGlkUGlwZUFyZ3VtZW50RXJyb3IodHlwZSwgdmFsdWUpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIFwiSW52YWxpZCBhcmd1bWVudCAnXCIgKyB2YWx1ZSArIFwiJyBmb3IgcGlwZSAnXCIgKyBzdHJpbmdpZnkodHlwZSkgKyBcIidcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEludmFsaWRQaXBlQXJndW1lbnRFcnJvcjtcbiAgICB9KEJhc2VFcnJvcikpO1xuXG4gICAgdmFyIE9ic2VydmFibGVTdHJhdGVneSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIE9ic2VydmFibGVTdHJhdGVneSgpIHtcbiAgICAgICAgfVxuICAgICAgICBPYnNlcnZhYmxlU3RyYXRlZ3kucHJvdG90eXBlLmNyZWF0ZVN1YnNjcmlwdGlvbiA9IGZ1bmN0aW9uIChhc3luYywgdXBkYXRlTGF0ZXN0VmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBhc3luYy5zdWJzY3JpYmUoeyBuZXh0OiB1cGRhdGVMYXRlc3RWYWx1ZSwgZXJyb3I6IGZ1bmN0aW9uIChlKSB7IHRocm93IGU7IH0gfSk7XG4gICAgICAgIH07XG4gICAgICAgIE9ic2VydmFibGVTdHJhdGVneS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uIChzdWJzY3JpcHRpb24pIHsgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7IH07XG4gICAgICAgIE9ic2VydmFibGVTdHJhdGVneS5wcm90b3R5cGUub25EZXN0cm95ID0gZnVuY3Rpb24gKHN1YnNjcmlwdGlvbikgeyBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTsgfTtcbiAgICAgICAgcmV0dXJuIE9ic2VydmFibGVTdHJhdGVneTtcbiAgICB9KCkpO1xuICAgIHZhciBQcm9taXNlU3RyYXRlZ3kgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBQcm9taXNlU3RyYXRlZ3koKSB7XG4gICAgICAgIH1cbiAgICAgICAgUHJvbWlzZVN0cmF0ZWd5LnByb3RvdHlwZS5jcmVhdGVTdWJzY3JpcHRpb24gPSBmdW5jdGlvbiAoYXN5bmMsIHVwZGF0ZUxhdGVzdFZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gYXN5bmMudGhlbih1cGRhdGVMYXRlc3RWYWx1ZSwgZnVuY3Rpb24gKGUpIHsgdGhyb3cgZTsgfSk7XG4gICAgICAgIH07XG4gICAgICAgIFByb21pc2VTdHJhdGVneS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uIChzdWJzY3JpcHRpb24pIHsgfTtcbiAgICAgICAgUHJvbWlzZVN0cmF0ZWd5LnByb3RvdHlwZS5vbkRlc3Ryb3kgPSBmdW5jdGlvbiAoc3Vic2NyaXB0aW9uKSB7IH07XG4gICAgICAgIHJldHVybiBQcm9taXNlU3RyYXRlZ3k7XG4gICAgfSgpKTtcbiAgICB2YXIgX3Byb21pc2VTdHJhdGVneSA9IG5ldyBQcm9taXNlU3RyYXRlZ3koKTtcbiAgICB2YXIgX29ic2VydmFibGVTdHJhdGVneSA9IG5ldyBPYnNlcnZhYmxlU3RyYXRlZ3koKTtcbiAgICAvKipcbiAgICAgKiBAbmdNb2R1bGUgQ29tbW9uTW9kdWxlXG4gICAgICogQHdoYXRJdERvZXMgVW53cmFwcyBhIHZhbHVlIGZyb20gYW4gYXN5bmNocm9ub3VzIHByaW1pdGl2ZS5cbiAgICAgKiBAaG93VG9Vc2UgYG9ic2VydmFibGVfb3JfcHJvbWlzZV9leHByZXNzaW9uIHwgYXN5bmNgXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogVGhlIGBhc3luY2AgcGlwZSBzdWJzY3JpYmVzIHRvIGFuIGBPYnNlcnZhYmxlYCBvciBgUHJvbWlzZWAgYW5kIHJldHVybnMgdGhlIGxhdGVzdCB2YWx1ZSBpdCBoYXNcbiAgICAgKiBlbWl0dGVkLiBXaGVuIGEgbmV3IHZhbHVlIGlzIGVtaXR0ZWQsIHRoZSBgYXN5bmNgIHBpcGUgbWFya3MgdGhlIGNvbXBvbmVudCB0byBiZSBjaGVja2VkIGZvclxuICAgICAqIGNoYW5nZXMuIFdoZW4gdGhlIGNvbXBvbmVudCBnZXRzIGRlc3Ryb3llZCwgdGhlIGBhc3luY2AgcGlwZSB1bnN1YnNjcmliZXMgYXV0b21hdGljYWxseSB0byBhdm9pZFxuICAgICAqIHBvdGVudGlhbCBtZW1vcnkgbGVha3MuXG4gICAgICpcbiAgICAgKlxuICAgICAqICMjIEV4YW1wbGVzXG4gICAgICpcbiAgICAgKiBUaGlzIGV4YW1wbGUgYmluZHMgYSBgUHJvbWlzZWAgdG8gdGhlIHZpZXcuIENsaWNraW5nIHRoZSBgUmVzb2x2ZWAgYnV0dG9uIHJlc29sdmVzIHRoZVxuICAgICAqIHByb21pc2UuXG4gICAgICpcbiAgICAgKiB7QGV4YW1wbGUgY29tbW9uL3BpcGVzL3RzL2FzeW5jX3BpcGUudHMgcmVnaW9uPSdBc3luY1BpcGVQcm9taXNlJ31cbiAgICAgKlxuICAgICAqIEl0J3MgYWxzbyBwb3NzaWJsZSB0byB1c2UgYGFzeW5jYCB3aXRoIE9ic2VydmFibGVzLiBUaGUgZXhhbXBsZSBiZWxvdyBiaW5kcyB0aGUgYHRpbWVgIE9ic2VydmFibGVcbiAgICAgKiB0byB0aGUgdmlldy4gVGhlIE9ic2VydmFibGUgY29udGludWVzbHkgdXBkYXRlcyB0aGUgdmlldyB3aXRoIHRoZSBjdXJyZW50IHRpbWUuXG4gICAgICpcbiAgICAgKiB7QGV4YW1wbGUgY29tbW9uL3BpcGVzL3RzL2FzeW5jX3BpcGUudHMgcmVnaW9uPSdBc3luY1BpcGVPYnNlcnZhYmxlJ31cbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgQXN5bmNQaXBlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gQXN5bmNQaXBlKF9yZWYpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlZiA9IF9yZWY7XG4gICAgICAgICAgICB0aGlzLl9sYXRlc3RWYWx1ZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9sYXRlc3RSZXR1cm5lZFZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbiA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9vYmogPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fc3RyYXRlZ3kgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIEFzeW5jUGlwZS5wcm90b3R5cGUubmdPbkRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGlzcG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBBc3luY1BpcGUucHJvdG90eXBlLnRyYW5zZm9ybSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fb2JqKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9iaikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdWJzY3JpYmUob2JqKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fbGF0ZXN0UmV0dXJuZWRWYWx1ZSA9IHRoaXMuX2xhdGVzdFZhbHVlO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9sYXRlc3RWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvYmogIT09IHRoaXMuX29iaikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0ob2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9sYXRlc3RWYWx1ZSA9PT0gdGhpcy5fbGF0ZXN0UmV0dXJuZWRWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9sYXRlc3RSZXR1cm5lZFZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fbGF0ZXN0UmV0dXJuZWRWYWx1ZSA9IHRoaXMuX2xhdGVzdFZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIF9hbmd1bGFyX2NvcmUuV3JhcHBlZFZhbHVlLndyYXAodGhpcy5fbGF0ZXN0VmFsdWUpO1xuICAgICAgICB9O1xuICAgICAgICBBc3luY1BpcGUucHJvdG90eXBlLl9zdWJzY3JpYmUgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5fb2JqID0gb2JqO1xuICAgICAgICAgICAgdGhpcy5fc3RyYXRlZ3kgPSB0aGlzLl9zZWxlY3RTdHJhdGVneShvYmopO1xuICAgICAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uID0gdGhpcy5fc3RyYXRlZ3kuY3JlYXRlU3Vic2NyaXB0aW9uKG9iaiwgZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBfdGhpcy5fdXBkYXRlTGF0ZXN0VmFsdWUob2JqLCB2YWx1ZSk7IH0pO1xuICAgICAgICB9O1xuICAgICAgICBBc3luY1BpcGUucHJvdG90eXBlLl9zZWxlY3RTdHJhdGVneSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgIGlmIChpc1Byb21pc2Uob2JqKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfcHJvbWlzZVN0cmF0ZWd5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9iai5zdWJzY3JpYmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX29ic2VydmFibGVTdHJhdGVneTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkUGlwZUFyZ3VtZW50RXJyb3IoQXN5bmNQaXBlLCBvYmopO1xuICAgICAgICB9O1xuICAgICAgICBBc3luY1BpcGUucHJvdG90eXBlLl9kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fc3RyYXRlZ3kuZGlzcG9zZSh0aGlzLl9zdWJzY3JpcHRpb24pO1xuICAgICAgICAgICAgdGhpcy5fbGF0ZXN0VmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fbGF0ZXN0UmV0dXJuZWRWYWx1ZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb24gPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fb2JqID0gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgQXN5bmNQaXBlLnByb3RvdHlwZS5fdXBkYXRlTGF0ZXN0VmFsdWUgPSBmdW5jdGlvbiAoYXN5bmMsIHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoYXN5bmMgPT09IHRoaXMuX29iaikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xhdGVzdFZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVmLm1hcmtGb3JDaGVjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBBc3luY1BpcGUuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5QaXBlLCBhcmdzOiBbeyBuYW1lOiAnYXN5bmMnLCBwdXJlOiBmYWxzZSB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIEFzeW5jUGlwZS5jdG9yUGFyYW1ldGVycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5DaGFuZ2VEZXRlY3RvclJlZiwgfSxcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIEFzeW5jUGlwZTtcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIHZhciBOdW1iZXJGb3JtYXRTdHlsZTtcbiAgICAoZnVuY3Rpb24gKE51bWJlckZvcm1hdFN0eWxlKSB7XG4gICAgICAgIE51bWJlckZvcm1hdFN0eWxlW051bWJlckZvcm1hdFN0eWxlW1wiRGVjaW1hbFwiXSA9IDBdID0gXCJEZWNpbWFsXCI7XG4gICAgICAgIE51bWJlckZvcm1hdFN0eWxlW051bWJlckZvcm1hdFN0eWxlW1wiUGVyY2VudFwiXSA9IDFdID0gXCJQZXJjZW50XCI7XG4gICAgICAgIE51bWJlckZvcm1hdFN0eWxlW051bWJlckZvcm1hdFN0eWxlW1wiQ3VycmVuY3lcIl0gPSAyXSA9IFwiQ3VycmVuY3lcIjtcbiAgICB9KShOdW1iZXJGb3JtYXRTdHlsZSB8fCAoTnVtYmVyRm9ybWF0U3R5bGUgPSB7fSkpO1xuICAgIHZhciBOdW1iZXJGb3JtYXR0ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBOdW1iZXJGb3JtYXR0ZXIoKSB7XG4gICAgICAgIH1cbiAgICAgICAgTnVtYmVyRm9ybWF0dGVyLmZvcm1hdCA9IGZ1bmN0aW9uIChudW0sIGxvY2FsZSwgc3R5bGUsIF9hKSB7XG4gICAgICAgICAgICB2YXIgX2IgPSBfYSA9PT0gdm9pZCAwID8ge30gOiBfYSwgbWluaW11bUludGVnZXJEaWdpdHMgPSBfYi5taW5pbXVtSW50ZWdlckRpZ2l0cywgbWluaW11bUZyYWN0aW9uRGlnaXRzID0gX2IubWluaW11bUZyYWN0aW9uRGlnaXRzLCBtYXhpbXVtRnJhY3Rpb25EaWdpdHMgPSBfYi5tYXhpbXVtRnJhY3Rpb25EaWdpdHMsIGN1cnJlbmN5ID0gX2IuY3VycmVuY3ksIF9jID0gX2IuY3VycmVuY3lBc1N5bWJvbCwgY3VycmVuY3lBc1N5bWJvbCA9IF9jID09PSB2b2lkIDAgPyBmYWxzZSA6IF9jO1xuICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgbWluaW11bUludGVnZXJEaWdpdHM6IG1pbmltdW1JbnRlZ2VyRGlnaXRzLFxuICAgICAgICAgICAgICAgIG1pbmltdW1GcmFjdGlvbkRpZ2l0czogbWluaW11bUZyYWN0aW9uRGlnaXRzLFxuICAgICAgICAgICAgICAgIG1heGltdW1GcmFjdGlvbkRpZ2l0czogbWF4aW11bUZyYWN0aW9uRGlnaXRzLFxuICAgICAgICAgICAgICAgIHN0eWxlOiBOdW1iZXJGb3JtYXRTdHlsZVtzdHlsZV0udG9Mb3dlckNhc2UoKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChzdHlsZSA9PSBOdW1iZXJGb3JtYXRTdHlsZS5DdXJyZW5jeSkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuY3VycmVuY3kgPSBjdXJyZW5jeTtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmN1cnJlbmN5RGlzcGxheSA9IGN1cnJlbmN5QXNTeW1ib2wgPyAnc3ltYm9sJyA6ICdjb2RlJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgSW50bC5OdW1iZXJGb3JtYXQobG9jYWxlLCBvcHRpb25zKS5mb3JtYXQobnVtKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIE51bWJlckZvcm1hdHRlcjtcbiAgICB9KCkpO1xuICAgIHZhciBEQVRFX0ZPUk1BVFNfU1BMSVQgPSAvKCg/OlteeU1MZEhobXNhelpFd0dqSiddKyl8KD86Jyg/OlteJ118JycpKicpfCg/OkUrfHkrfE0rfEwrfGQrfEgrfGgrfEorfGorfG0rfHMrfGF8enxafEcrfHcrKSkoLiopLztcbiAgICB2YXIgUEFUVEVSTl9BTElBU0VTID0ge1xuICAgICAgICB5TU1NZGptczogZGF0ZVBhcnRHZXR0ZXJGYWN0b3J5KGNvbWJpbmUoW1xuICAgICAgICAgICAgZGlnaXRDb25kaXRpb24oJ3llYXInLCAxKSxcbiAgICAgICAgICAgIG5hbWVDb25kaXRpb24oJ21vbnRoJywgMyksXG4gICAgICAgICAgICBkaWdpdENvbmRpdGlvbignZGF5JywgMSksXG4gICAgICAgICAgICBkaWdpdENvbmRpdGlvbignaG91cicsIDEpLFxuICAgICAgICAgICAgZGlnaXRDb25kaXRpb24oJ21pbnV0ZScsIDEpLFxuICAgICAgICAgICAgZGlnaXRDb25kaXRpb24oJ3NlY29uZCcsIDEpLFxuICAgICAgICBdKSksXG4gICAgICAgIHlNZGptOiBkYXRlUGFydEdldHRlckZhY3RvcnkoY29tYmluZShbXG4gICAgICAgICAgICBkaWdpdENvbmRpdGlvbigneWVhcicsIDEpLCBkaWdpdENvbmRpdGlvbignbW9udGgnLCAxKSwgZGlnaXRDb25kaXRpb24oJ2RheScsIDEpLFxuICAgICAgICAgICAgZGlnaXRDb25kaXRpb24oJ2hvdXInLCAxKSwgZGlnaXRDb25kaXRpb24oJ21pbnV0ZScsIDEpXG4gICAgICAgIF0pKSxcbiAgICAgICAgeU1NTU1FRUVFZDogZGF0ZVBhcnRHZXR0ZXJGYWN0b3J5KGNvbWJpbmUoW1xuICAgICAgICAgICAgZGlnaXRDb25kaXRpb24oJ3llYXInLCAxKSwgbmFtZUNvbmRpdGlvbignbW9udGgnLCA0KSwgbmFtZUNvbmRpdGlvbignd2Vla2RheScsIDQpLFxuICAgICAgICAgICAgZGlnaXRDb25kaXRpb24oJ2RheScsIDEpXG4gICAgICAgIF0pKSxcbiAgICAgICAgeU1NTU1kOiBkYXRlUGFydEdldHRlckZhY3RvcnkoY29tYmluZShbZGlnaXRDb25kaXRpb24oJ3llYXInLCAxKSwgbmFtZUNvbmRpdGlvbignbW9udGgnLCA0KSwgZGlnaXRDb25kaXRpb24oJ2RheScsIDEpXSkpLFxuICAgICAgICB5TU1NZDogZGF0ZVBhcnRHZXR0ZXJGYWN0b3J5KGNvbWJpbmUoW2RpZ2l0Q29uZGl0aW9uKCd5ZWFyJywgMSksIG5hbWVDb25kaXRpb24oJ21vbnRoJywgMyksIGRpZ2l0Q29uZGl0aW9uKCdkYXknLCAxKV0pKSxcbiAgICAgICAgeU1kOiBkYXRlUGFydEdldHRlckZhY3RvcnkoY29tYmluZShbZGlnaXRDb25kaXRpb24oJ3llYXInLCAxKSwgZGlnaXRDb25kaXRpb24oJ21vbnRoJywgMSksIGRpZ2l0Q29uZGl0aW9uKCdkYXknLCAxKV0pKSxcbiAgICAgICAgam1zOiBkYXRlUGFydEdldHRlckZhY3RvcnkoY29tYmluZShbZGlnaXRDb25kaXRpb24oJ2hvdXInLCAxKSwgZGlnaXRDb25kaXRpb24oJ3NlY29uZCcsIDEpLCBkaWdpdENvbmRpdGlvbignbWludXRlJywgMSldKSksXG4gICAgICAgIGptOiBkYXRlUGFydEdldHRlckZhY3RvcnkoY29tYmluZShbZGlnaXRDb25kaXRpb24oJ2hvdXInLCAxKSwgZGlnaXRDb25kaXRpb24oJ21pbnV0ZScsIDEpXSkpXG4gICAgfTtcbiAgICB2YXIgREFURV9GT1JNQVRTID0ge1xuICAgICAgICB5eXl5OiBkYXRlUGFydEdldHRlckZhY3RvcnkoZGlnaXRDb25kaXRpb24oJ3llYXInLCA0KSksXG4gICAgICAgIHl5OiBkYXRlUGFydEdldHRlckZhY3RvcnkoZGlnaXRDb25kaXRpb24oJ3llYXInLCAyKSksXG4gICAgICAgIHk6IGRhdGVQYXJ0R2V0dGVyRmFjdG9yeShkaWdpdENvbmRpdGlvbigneWVhcicsIDEpKSxcbiAgICAgICAgTU1NTTogZGF0ZVBhcnRHZXR0ZXJGYWN0b3J5KG5hbWVDb25kaXRpb24oJ21vbnRoJywgNCkpLFxuICAgICAgICBNTU06IGRhdGVQYXJ0R2V0dGVyRmFjdG9yeShuYW1lQ29uZGl0aW9uKCdtb250aCcsIDMpKSxcbiAgICAgICAgTU06IGRhdGVQYXJ0R2V0dGVyRmFjdG9yeShkaWdpdENvbmRpdGlvbignbW9udGgnLCAyKSksXG4gICAgICAgIE06IGRhdGVQYXJ0R2V0dGVyRmFjdG9yeShkaWdpdENvbmRpdGlvbignbW9udGgnLCAxKSksXG4gICAgICAgIExMTEw6IGRhdGVQYXJ0R2V0dGVyRmFjdG9yeShuYW1lQ29uZGl0aW9uKCdtb250aCcsIDQpKSxcbiAgICAgICAgZGQ6IGRhdGVQYXJ0R2V0dGVyRmFjdG9yeShkaWdpdENvbmRpdGlvbignZGF5JywgMikpLFxuICAgICAgICBkOiBkYXRlUGFydEdldHRlckZhY3RvcnkoZGlnaXRDb25kaXRpb24oJ2RheScsIDEpKSxcbiAgICAgICAgSEg6IGRpZ2l0TW9kaWZpZXIoaG91ckV4dHJhY3RlcihkYXRlUGFydEdldHRlckZhY3RvcnkoaG91cjEyTW9kaWZ5KGRpZ2l0Q29uZGl0aW9uKCdob3VyJywgMiksIGZhbHNlKSkpKSxcbiAgICAgICAgSDogaG91ckV4dHJhY3RlcihkYXRlUGFydEdldHRlckZhY3RvcnkoaG91cjEyTW9kaWZ5KGRpZ2l0Q29uZGl0aW9uKCdob3VyJywgMSksIGZhbHNlKSkpLFxuICAgICAgICBoaDogZGlnaXRNb2RpZmllcihob3VyRXh0cmFjdGVyKGRhdGVQYXJ0R2V0dGVyRmFjdG9yeShob3VyMTJNb2RpZnkoZGlnaXRDb25kaXRpb24oJ2hvdXInLCAyKSwgdHJ1ZSkpKSksXG4gICAgICAgIGg6IGhvdXJFeHRyYWN0ZXIoZGF0ZVBhcnRHZXR0ZXJGYWN0b3J5KGhvdXIxMk1vZGlmeShkaWdpdENvbmRpdGlvbignaG91cicsIDEpLCB0cnVlKSkpLFxuICAgICAgICBqajogZGF0ZVBhcnRHZXR0ZXJGYWN0b3J5KGRpZ2l0Q29uZGl0aW9uKCdob3VyJywgMikpLFxuICAgICAgICBqOiBkYXRlUGFydEdldHRlckZhY3RvcnkoZGlnaXRDb25kaXRpb24oJ2hvdXInLCAxKSksXG4gICAgICAgIG1tOiBkaWdpdE1vZGlmaWVyKGRhdGVQYXJ0R2V0dGVyRmFjdG9yeShkaWdpdENvbmRpdGlvbignbWludXRlJywgMikpKSxcbiAgICAgICAgbTogZGF0ZVBhcnRHZXR0ZXJGYWN0b3J5KGRpZ2l0Q29uZGl0aW9uKCdtaW51dGUnLCAxKSksXG4gICAgICAgIHNzOiBkaWdpdE1vZGlmaWVyKGRhdGVQYXJ0R2V0dGVyRmFjdG9yeShkaWdpdENvbmRpdGlvbignc2Vjb25kJywgMikpKSxcbiAgICAgICAgczogZGF0ZVBhcnRHZXR0ZXJGYWN0b3J5KGRpZ2l0Q29uZGl0aW9uKCdzZWNvbmQnLCAxKSksXG4gICAgICAgIC8vIHdoaWxlIElTTyA4NjAxIHJlcXVpcmVzIGZyYWN0aW9ucyB0byBiZSBwcmVmaXhlZCB3aXRoIGAuYCBvciBgLGBcbiAgICAgICAgLy8gd2UgY2FuIGJlIGp1c3Qgc2FmZWx5IHJlbHkgb24gdXNpbmcgYHNzc2Agc2luY2Ugd2UgY3VycmVudGx5IGRvbid0IHN1cHBvcnQgc2luZ2xlIG9yIHR3byBkaWdpdFxuICAgICAgICAvLyBmcmFjdGlvbnNcbiAgICAgICAgc3NzOiBkYXRlUGFydEdldHRlckZhY3RvcnkoZGlnaXRDb25kaXRpb24oJ3NlY29uZCcsIDMpKSxcbiAgICAgICAgRUVFRTogZGF0ZVBhcnRHZXR0ZXJGYWN0b3J5KG5hbWVDb25kaXRpb24oJ3dlZWtkYXknLCA0KSksXG4gICAgICAgIEVFRTogZGF0ZVBhcnRHZXR0ZXJGYWN0b3J5KG5hbWVDb25kaXRpb24oJ3dlZWtkYXknLCAzKSksXG4gICAgICAgIEVFOiBkYXRlUGFydEdldHRlckZhY3RvcnkobmFtZUNvbmRpdGlvbignd2Vla2RheScsIDIpKSxcbiAgICAgICAgRTogZGF0ZVBhcnRHZXR0ZXJGYWN0b3J5KG5hbWVDb25kaXRpb24oJ3dlZWtkYXknLCAxKSksXG4gICAgICAgIGE6IGhvdXJDbG9ja0V4dHJhY3RlcihkYXRlUGFydEdldHRlckZhY3RvcnkoaG91cjEyTW9kaWZ5KGRpZ2l0Q29uZGl0aW9uKCdob3VyJywgMSksIHRydWUpKSksXG4gICAgICAgIFo6IHRpbWVab25lR2V0dGVyKCdzaG9ydCcpLFxuICAgICAgICB6OiB0aW1lWm9uZUdldHRlcignbG9uZycpLFxuICAgICAgICB3dzogZGF0ZVBhcnRHZXR0ZXJGYWN0b3J5KHt9KSxcbiAgICAgICAgLy8gZmlyc3QgVGh1cnNkYXkgb2YgdGhlIHllYXIuIG5vdCBzdXBwb3J0ID9cbiAgICAgICAgdzogZGF0ZVBhcnRHZXR0ZXJGYWN0b3J5KHt9KSxcbiAgICAgICAgLy8gb2YgdGhlIHllYXIgbm90IHN1cHBvcnQgP1xuICAgICAgICBHOiBkYXRlUGFydEdldHRlckZhY3RvcnkobmFtZUNvbmRpdGlvbignZXJhJywgMSkpLFxuICAgICAgICBHRzogZGF0ZVBhcnRHZXR0ZXJGYWN0b3J5KG5hbWVDb25kaXRpb24oJ2VyYScsIDIpKSxcbiAgICAgICAgR0dHOiBkYXRlUGFydEdldHRlckZhY3RvcnkobmFtZUNvbmRpdGlvbignZXJhJywgMykpLFxuICAgICAgICBHR0dHOiBkYXRlUGFydEdldHRlckZhY3RvcnkobmFtZUNvbmRpdGlvbignZXJhJywgNCkpXG4gICAgfTtcbiAgICBmdW5jdGlvbiBkaWdpdE1vZGlmaWVyKGlubmVyKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZGF0ZSwgbG9jYWxlKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gaW5uZXIoZGF0ZSwgbG9jYWxlKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQubGVuZ3RoID09IDEgPyAnMCcgKyByZXN1bHQgOiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhvdXJDbG9ja0V4dHJhY3Rlcihpbm5lcikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGRhdGUsIGxvY2FsZSkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGlubmVyKGRhdGUsIGxvY2FsZSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LnNwbGl0KCcgJylbMV07XG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhvdXJFeHRyYWN0ZXIoaW5uZXIpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkYXRlLCBsb2NhbGUpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBpbm5lcihkYXRlLCBsb2NhbGUpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5zcGxpdCgnICcpWzBdO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbnRsRGF0ZUZvcm1hdChkYXRlLCBsb2NhbGUsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGxvY2FsZSwgb3B0aW9ucykuZm9ybWF0KGRhdGUpLnJlcGxhY2UoL1tcXHUyMDBlXFx1MjAwZl0vZywgJycpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0aW1lWm9uZUdldHRlcih0aW1lem9uZSkge1xuICAgICAgICAvLyBUbyB3b3JrYXJvdW5kIGBJbnRsYCBBUEkgcmVzdHJpY3Rpb24gZm9yIHNpbmdsZSB0aW1lem9uZSBsZXQgZm9ybWF0IHdpdGggMjQgaG91cnNcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7IGhvdXI6ICcyLWRpZ2l0JywgaG91cjEyOiBmYWxzZSwgdGltZVpvbmVOYW1lOiB0aW1lem9uZSB9O1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGRhdGUsIGxvY2FsZSkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGludGxEYXRlRm9ybWF0KGRhdGUsIGxvY2FsZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAvLyBUaGVuIGV4dHJhY3QgZmlyc3QgMyBsZXR0ZXJzIHRoYXQgcmVsYXRlZCB0byBob3Vyc1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCA/IHJlc3VsdC5zdWJzdHJpbmcoMykgOiAnJztcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaG91cjEyTW9kaWZ5KG9wdGlvbnMsIHZhbHVlKSB7XG4gICAgICAgIG9wdGlvbnMuaG91cjEyID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBvcHRpb25zO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkaWdpdENvbmRpdGlvbihwcm9wLCBsZW4pIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgICByZXN1bHRbcHJvcF0gPSBsZW4gPT0gMiA/ICcyLWRpZ2l0JyA6ICdudW1lcmljJztcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZnVuY3Rpb24gbmFtZUNvbmRpdGlvbihwcm9wLCBsZW4pIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgICByZXN1bHRbcHJvcF0gPSBsZW4gPCA0ID8gJ3Nob3J0JyA6ICdsb25nJztcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tYmluZShvcHRpb25zKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgb3B0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChvcHRpb24pIHsgT2JqZWN0LmFzc2lnbihyZXN1bHQsIG9wdGlvbik7IH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBkYXRlUGFydEdldHRlckZhY3RvcnkocmV0KSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZGF0ZSwgbG9jYWxlKSB7IHJldHVybiBpbnRsRGF0ZUZvcm1hdChkYXRlLCBsb2NhbGUsIHJldCk7IH07XG4gICAgfVxuICAgIHZhciBkYXRlUGFydHNGb3JtYXR0ZXJDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICBmdW5jdGlvbiBkYXRlRm9ybWF0dGVyKGZvcm1hdCwgZGF0ZSwgbG9jYWxlKSB7XG4gICAgICAgIHZhciB0ZXh0ID0gJyc7XG4gICAgICAgIHZhciBtYXRjaDtcbiAgICAgICAgdmFyIGZuO1xuICAgICAgICB2YXIgcGFydHMgPSBbXTtcbiAgICAgICAgaWYgKFBBVFRFUk5fQUxJQVNFU1tmb3JtYXRdKSB7XG4gICAgICAgICAgICByZXR1cm4gUEFUVEVSTl9BTElBU0VTW2Zvcm1hdF0oZGF0ZSwgbG9jYWxlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0ZVBhcnRzRm9ybWF0dGVyQ2FjaGUuaGFzKGZvcm1hdCkpIHtcbiAgICAgICAgICAgIHBhcnRzID0gZGF0ZVBhcnRzRm9ybWF0dGVyQ2FjaGUuZ2V0KGZvcm1hdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgbWF0Y2hlcyA9IERBVEVfRk9STUFUU19TUExJVC5leGVjKGZvcm1hdCk7XG4gICAgICAgICAgICB3aGlsZSAoZm9ybWF0KSB7XG4gICAgICAgICAgICAgICAgbWF0Y2ggPSBEQVRFX0ZPUk1BVFNfU1BMSVQuZXhlYyhmb3JtYXQpO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICBwYXJ0cyA9IGNvbmNhdChwYXJ0cywgbWF0Y2gsIDEpO1xuICAgICAgICAgICAgICAgICAgICBmb3JtYXQgPSBwYXJ0cy5wb3AoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnRzLnB1c2goZm9ybWF0KTtcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkYXRlUGFydHNGb3JtYXR0ZXJDYWNoZS5zZXQoZm9ybWF0LCBwYXJ0cyk7XG4gICAgICAgIH1cbiAgICAgICAgcGFydHMuZm9yRWFjaChmdW5jdGlvbiAocGFydCkge1xuICAgICAgICAgICAgZm4gPSBEQVRFX0ZPUk1BVFNbcGFydF07XG4gICAgICAgICAgICB0ZXh0ICs9IGZuID8gZm4oZGF0ZSwgbG9jYWxlKSA6XG4gICAgICAgICAgICAgICAgcGFydCA9PT0gJ1xcJ1xcJycgPyAnXFwnJyA6IHBhcnQucmVwbGFjZSgvKF4nfCckKS9nLCAnJykucmVwbGFjZSgvJycvZywgJ1xcJycpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxuICAgIHZhciBzbGljZSA9IFtdLnNsaWNlO1xuICAgIGZ1bmN0aW9uIGNvbmNhdChhcnJheTEgLyoqIFRPRE8gIzkxMDAgKi8sIGFycmF5MiAvKiogVE9ETyAjOTEwMCAqLywgaW5kZXggLyoqIFRPRE8gIzkxMDAgKi8pIHtcbiAgICAgICAgcmV0dXJuIGFycmF5MS5jb25jYXQoc2xpY2UuY2FsbChhcnJheTIsIGluZGV4KSk7XG4gICAgfVxuICAgIHZhciBEYXRlRm9ybWF0dGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gRGF0ZUZvcm1hdHRlcigpIHtcbiAgICAgICAgfVxuICAgICAgICBEYXRlRm9ybWF0dGVyLmZvcm1hdCA9IGZ1bmN0aW9uIChkYXRlLCBsb2NhbGUsIHBhdHRlcm4pIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRlRm9ybWF0dGVyKHBhdHRlcm4sIGRhdGUsIGxvY2FsZSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBEYXRlRm9ybWF0dGVyO1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBAbmdNb2R1bGUgQ29tbW9uTW9kdWxlXG4gICAgICogQHdoYXRJdERvZXMgRm9ybWF0cyBhIGRhdGUgYWNjb3JkaW5nIHRvIGxvY2FsZSBydWxlcy5cbiAgICAgKiBAaG93VG9Vc2UgYGRhdGVfZXhwcmVzc2lvbiB8IGRhdGVbOmZvcm1hdF1gXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICpcbiAgICAgKiBXaGVyZTpcbiAgICAgKiAtIGBleHByZXNzaW9uYCBpcyBhIGRhdGUgb2JqZWN0IG9yIGEgbnVtYmVyIChtaWxsaXNlY29uZHMgc2luY2UgVVRDIGVwb2NoKSBvciBhbiBJU08gc3RyaW5nXG4gICAgICogKGh0dHBzOi8vd3d3LnczLm9yZy9UUi9OT1RFLWRhdGV0aW1lKS5cbiAgICAgKiAtIGBmb3JtYXRgIGluZGljYXRlcyB3aGljaCBkYXRlL3RpbWUgY29tcG9uZW50cyB0byBpbmNsdWRlLiBUaGUgZm9ybWF0IGNhbiBiZSBwcmVkaWZpbmVkIGFzXG4gICAgICogICBzaG93biBiZWxvdyBvciBjdXN0b20gYXMgc2hvd24gaW4gdGhlIHRhYmxlLlxuICAgICAqICAgLSBgJ21lZGl1bSdgOiBlcXVpdmFsZW50IHRvIGAneU1NTWRqbXMnYCAoZS5nLiBgU2VwIDMsIDIwMTAsIDEyOjA1OjA4IFBNYCBmb3IgYGVuLVVTYClcbiAgICAgKiAgIC0gYCdzaG9ydCdgOiBlcXVpdmFsZW50IHRvIGAneU1kam0nYCAoZS5nLiBgOS8zLzIwMTAsIDEyOjA1IFBNYCBmb3IgYGVuLVVTYClcbiAgICAgKiAgIC0gYCdmdWxsRGF0ZSdgOiBlcXVpdmFsZW50IHRvIGAneU1NTU1FRUVFZCdgIChlLmcuIGBGcmlkYXksIFNlcHRlbWJlciAzLCAyMDEwYCBmb3IgYGVuLVVTYClcbiAgICAgKiAgIC0gYCdsb25nRGF0ZSdgOiBlcXVpdmFsZW50IHRvIGAneU1NTU1kJ2AgKGUuZy4gYFNlcHRlbWJlciAzLCAyMDEwYCBmb3IgYGVuLVVTYClcbiAgICAgKiAgIC0gYCdtZWRpdW1EYXRlJ2A6IGVxdWl2YWxlbnQgdG8gYCd5TU1NZCdgIChlLmcuIGBTZXAgMywgMjAxMGAgZm9yIGBlbi1VU2ApXG4gICAgICogICAtIGAnc2hvcnREYXRlJ2A6IGVxdWl2YWxlbnQgdG8gYCd5TWQnYCAoZS5nLiBgOS8zLzIwMTBgIGZvciBgZW4tVVNgKVxuICAgICAqICAgLSBgJ21lZGl1bVRpbWUnYDogZXF1aXZhbGVudCB0byBgJ2ptcydgIChlLmcuIGAxMjowNTowOCBQTWAgZm9yIGBlbi1VU2ApXG4gICAgICogICAtIGAnc2hvcnRUaW1lJ2A6IGVxdWl2YWxlbnQgdG8gYCdqbSdgIChlLmcuIGAxMjowNSBQTWAgZm9yIGBlbi1VU2ApXG4gICAgICpcbiAgICAgKlxuICAgICAqICB8IENvbXBvbmVudCB8IFN5bWJvbCB8IFNob3J0IEZvcm0gICB8IExvbmcgRm9ybSAgICAgICAgIHwgTnVtZXJpYyAgIHwgMi1kaWdpdCAgIHxcbiAgICAgKiAgfC0tLS0tLS0tLS0tfDotLS0tLS06fC0tLS0tLS0tLS0tLS0tfC0tLS0tLS0tLS0tLS0tLS0tLS18LS0tLS0tLS0tLS18LS0tLS0tLS0tLS18XG4gICAgICogIHwgZXJhICAgICAgIHwgICBHICAgIHwgRyAoQUQpICAgICAgIHwgR0dHRyAoQW5ubyBEb21pbmkpfCAtICAgICAgICAgfCAtICAgICAgICAgfFxuICAgICAqICB8IHllYXIgICAgICB8ICAgeSAgICB8IC0gICAgICAgICAgICB8IC0gICAgICAgICAgICAgICAgIHwgeSAoMjAxNSkgIHwgeXkgKDE1KSAgIHxcbiAgICAgKiAgfCBtb250aCAgICAgfCAgIE0gICAgfCBNTU0gKFNlcCkgICAgfCBNTU1NIChTZXB0ZW1iZXIpICB8IE0gKDkpICAgICB8IE1NICgwOSkgICB8XG4gICAgICogIHwgZGF5ICAgICAgIHwgICBkICAgIHwgLSAgICAgICAgICAgIHwgLSAgICAgICAgICAgICAgICAgfCBkICgzKSAgICAgfCBkZCAoMDMpICAgfFxuICAgICAqICB8IHdlZWtkYXkgICB8ICAgRSAgICB8IEVFRSAoU3VuKSAgICB8IEVFRUUgKFN1bmRheSkgICAgIHwgLSAgICAgICAgIHwgLSAgICAgICAgIHxcbiAgICAgKiAgfCBob3VyICAgICAgfCAgIGogICAgfCAtICAgICAgICAgICAgfCAtICAgICAgICAgICAgICAgICB8IGogKDEzKSAgICB8IGpqICgxMykgICB8XG4gICAgICogIHwgaG91cjEyICAgIHwgICBoICAgIHwgLSAgICAgICAgICAgIHwgLSAgICAgICAgICAgICAgICAgfCBoICgxIFBNKSAgfCBoaCAoMDEgUE0pfFxuICAgICAqICB8IGhvdXIyNCAgICB8ICAgSCAgICB8IC0gICAgICAgICAgICB8IC0gICAgICAgICAgICAgICAgIHwgSCAoMTMpICAgIHwgSEggKDEzKSAgIHxcbiAgICAgKiAgfCBtaW51dGUgICAgfCAgIG0gICAgfCAtICAgICAgICAgICAgfCAtICAgICAgICAgICAgICAgICB8IG0gKDUpICAgICB8IG1tICgwNSkgICB8XG4gICAgICogIHwgc2Vjb25kICAgIHwgICBzICAgIHwgLSAgICAgICAgICAgIHwgLSAgICAgICAgICAgICAgICAgfCBzICg5KSAgICAgfCBzcyAoMDkpICAgfFxuICAgICAqICB8IHRpbWV6b25lICB8ICAgeiAgICB8IC0gICAgICAgICAgICB8IHogKFBhY2lmaWMgU3RhbmRhcmQgVGltZSl8IC0gIHwgLSAgICAgICAgIHxcbiAgICAgKiAgfCB0aW1lem9uZSAgfCAgIFogICAgfCBaIChHTVQtODowMCkgfCAtICAgICAgICAgICAgICAgICB8IC0gICAgICAgICB8IC0gICAgICAgICB8XG4gICAgICogIHwgdGltZXpvbmUgIHwgICBhICAgIHwgYSAoUE0pICAgICAgIHwgLSAgICAgICAgICAgICAgICAgfCAtICAgICAgICAgfCAtICAgICAgICAgfFxuICAgICAqXG4gICAgICogSW4gamF2YXNjcmlwdCwgb25seSB0aGUgY29tcG9uZW50cyBzcGVjaWZpZWQgd2lsbCBiZSByZXNwZWN0ZWQgKG5vdCB0aGUgb3JkZXJpbmcsXG4gICAgICogcHVuY3R1YXRpb25zLCAuLi4pIGFuZCBkZXRhaWxzIG9mIHRoZSBmb3JtYXR0aW5nIHdpbGwgYmUgZGVwZW5kZW50IG9uIHRoZSBsb2NhbGUuXG4gICAgICpcbiAgICAgKiBUaW1lem9uZSBvZiB0aGUgZm9ybWF0dGVkIHRleHQgd2lsbCBiZSB0aGUgbG9jYWwgc3lzdGVtIHRpbWV6b25lIG9mIHRoZSBlbmQtdXNlcidzIG1hY2hpbmUuXG4gICAgICpcbiAgICAgKiBXQVJOSU5HUzpcbiAgICAgKiAtIHRoaXMgcGlwZSBpcyBtYXJrZWQgYXMgcHVyZSBoZW5jZSBpdCB3aWxsIG5vdCBiZSByZS1ldmFsdWF0ZWQgd2hlbiB0aGUgaW5wdXQgaXMgbXV0YXRlZC5cbiAgICAgKiAgIEluc3RlYWQgdXNlcnMgc2hvdWxkIHRyZWF0IHRoZSBkYXRlIGFzIGFuIGltbXV0YWJsZSBvYmplY3QgYW5kIGNoYW5nZSB0aGUgcmVmZXJlbmNlIHdoZW4gdGhlXG4gICAgICogICBwaXBlIG5lZWRzIHRvIHJlLXJ1biAodGhpcyBpcyB0byBhdm9pZCByZWZvcm1hdHRpbmcgdGhlIGRhdGUgb24gZXZlcnkgY2hhbmdlIGRldGVjdGlvbiBydW5cbiAgICAgKiAgIHdoaWNoIHdvdWxkIGJlIGFuIGV4cGVuc2l2ZSBvcGVyYXRpb24pLlxuICAgICAqIC0gdGhpcyBwaXBlIHVzZXMgdGhlIEludGVybmF0aW9uYWxpemF0aW9uIEFQSS4gVGhlcmVmb3JlIGl0IGlzIG9ubHkgcmVsaWFibGUgaW4gQ2hyb21lIGFuZCBPcGVyYVxuICAgICAqICAgYnJvd3NlcnMuXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZXNcbiAgICAgKlxuICAgICAqIEFzc3VtaW5nIGBkYXRlT2JqYCBpcyAoeWVhcjogMjAxNSwgbW9udGg6IDYsIGRheTogMTUsIGhvdXI6IDIxLCBtaW51dGU6IDQzLCBzZWNvbmQ6IDExKVxuICAgICAqIGluIHRoZSBfbG9jYWxfIHRpbWUgYW5kIGxvY2FsZSBpcyAnZW4tVVMnOlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogICAgIHt7IGRhdGVPYmogfCBkYXRlIH19ICAgICAgICAgICAgICAgLy8gb3V0cHV0IGlzICdKdW4gMTUsIDIwMTUnXG4gICAgICogICAgIHt7IGRhdGVPYmogfCBkYXRlOidtZWRpdW0nIH19ICAgICAgLy8gb3V0cHV0IGlzICdKdW4gMTUsIDIwMTUsIDk6NDM6MTEgUE0nXG4gICAgICogICAgIHt7IGRhdGVPYmogfCBkYXRlOidzaG9ydFRpbWUnIH19ICAgLy8gb3V0cHV0IGlzICc5OjQzIFBNJ1xuICAgICAqICAgICB7eyBkYXRlT2JqIHwgZGF0ZTonbW1zcycgfX0gICAgICAgIC8vIG91dHB1dCBpcyAnNDM6MTEnXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiB7QGV4YW1wbGUgY29tbW9uL3BpcGVzL3RzL2RhdGVfcGlwZS50cyByZWdpb249J0RhdGVQaXBlJ31cbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgRGF0ZVBpcGUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBEYXRlUGlwZShfbG9jYWxlKSB7XG4gICAgICAgICAgICB0aGlzLl9sb2NhbGUgPSBfbG9jYWxlO1xuICAgICAgICB9XG4gICAgICAgIERhdGVQaXBlLnByb3RvdHlwZS50cmFuc2Zvcm0gPSBmdW5jdGlvbiAodmFsdWUsIHBhdHRlcm4pIHtcbiAgICAgICAgICAgIGlmIChwYXR0ZXJuID09PSB2b2lkIDApIHsgcGF0dGVybiA9ICdtZWRpdW1EYXRlJzsgfVxuICAgICAgICAgICAgaWYgKGlzQmxhbmsodmFsdWUpKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnN1cHBvcnRzKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkUGlwZUFyZ3VtZW50RXJyb3IoRGF0ZVBpcGUsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChOdW1iZXJXcmFwcGVyLmlzTnVtZXJpYyh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHBhcnNlRmxvYXQodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIERhdGVGb3JtYXR0ZXIuZm9ybWF0KG5ldyBEYXRlKHZhbHVlKSwgdGhpcy5fbG9jYWxlLCBEYXRlUGlwZS5fQUxJQVNFU1twYXR0ZXJuXSB8fCBwYXR0ZXJuKTtcbiAgICAgICAgfTtcbiAgICAgICAgRGF0ZVBpcGUucHJvdG90eXBlLnN1cHBvcnRzID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgcmV0dXJuIGlzRGF0ZShvYmopIHx8IE51bWJlcldyYXBwZXIuaXNOdW1lcmljKG9iaikgfHxcbiAgICAgICAgICAgICAgICAodHlwZW9mIG9iaiA9PT0gJ3N0cmluZycgJiYgaXNEYXRlKG5ldyBEYXRlKG9iaikpKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBEYXRlUGlwZS5fQUxJQVNFUyA9IHtcbiAgICAgICAgICAgICdtZWRpdW0nOiAneU1NTWRqbXMnLFxuICAgICAgICAgICAgJ3Nob3J0JzogJ3lNZGptJyxcbiAgICAgICAgICAgICdmdWxsRGF0ZSc6ICd5TU1NTUVFRUVkJyxcbiAgICAgICAgICAgICdsb25nRGF0ZSc6ICd5TU1NTWQnLFxuICAgICAgICAgICAgJ21lZGl1bURhdGUnOiAneU1NTWQnLFxuICAgICAgICAgICAgJ3Nob3J0RGF0ZSc6ICd5TWQnLFxuICAgICAgICAgICAgJ21lZGl1bVRpbWUnOiAnam1zJyxcbiAgICAgICAgICAgICdzaG9ydFRpbWUnOiAnam0nXG4gICAgICAgIH07XG4gICAgICAgIERhdGVQaXBlLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuUGlwZSwgYXJnczogW3sgbmFtZTogJ2RhdGUnLCBwdXJlOiB0cnVlIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgRGF0ZVBpcGUuY3RvclBhcmFtZXRlcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3QsIGFyZ3M6IFtfYW5ndWxhcl9jb3JlLkxPQ0FMRV9JRCxdIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gRGF0ZVBpcGU7XG4gICAgfSgpKTtcblxuICAgIHZhciBfSU5URVJQT0xBVElPTl9SRUdFWFAgPSAvIy9nO1xuICAgIC8qKlxuICAgICAqIEBuZ01vZHVsZSBDb21tb25Nb2R1bGVcbiAgICAgKiBAd2hhdEl0RG9lcyBNYXBzIGEgdmFsdWUgdG8gYSBzdHJpbmcgdGhhdCBwbHVyYWxpemVzIHRoZSB2YWx1ZSBhY2NvcmRpbmcgdG8gbG9jYWxlIHJ1bGVzLlxuICAgICAqIEBob3dUb1VzZSBgZXhwcmVzc2lvbiB8IGkxOG5QbHVyYWw6bWFwcGluZ2BcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKlxuICAgICAqICBXaGVyZTpcbiAgICAgKiAgLSBgZXhwcmVzc2lvbmAgaXMgYSBudW1iZXIuXG4gICAgICogIC0gYG1hcHBpbmdgIGlzIGFuIG9iamVjdCB0aGF0IG1pbWljcyB0aGUgSUNVIGZvcm1hdCwgc2VlXG4gICAgICogICAgaHR0cDovL3VzZXJndWlkZS5pY3UtcHJvamVjdC5vcmcvZm9ybWF0cGFyc2UvbWVzc2FnZXNcbiAgICAgKlxuICAgICAqICAjIyBFeGFtcGxlXG4gICAgICpcbiAgICAgKiB7QGV4YW1wbGUgY29tbW9uL3BpcGVzL3RzL2kxOG5fcGlwZS50cyByZWdpb249J0kxOG5QbHVyYWxQaXBlQ29tcG9uZW50J31cbiAgICAgKlxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICB2YXIgSTE4blBsdXJhbFBpcGUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBJMThuUGx1cmFsUGlwZShfbG9jYWxpemF0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLl9sb2NhbGl6YXRpb24gPSBfbG9jYWxpemF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIEkxOG5QbHVyYWxQaXBlLnByb3RvdHlwZS50cmFuc2Zvcm0gPSBmdW5jdGlvbiAodmFsdWUsIHBsdXJhbE1hcCkge1xuICAgICAgICAgICAgaWYgKGlzQmxhbmsodmFsdWUpKVxuICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGx1cmFsTWFwICE9PSAnb2JqZWN0JyB8fCBwbHVyYWxNYXAgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFBpcGVBcmd1bWVudEVycm9yKEkxOG5QbHVyYWxQaXBlLCBwbHVyYWxNYXApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGtleSA9IGdldFBsdXJhbENhdGVnb3J5KHZhbHVlLCBPYmplY3Qua2V5cyhwbHVyYWxNYXApLCB0aGlzLl9sb2NhbGl6YXRpb24pO1xuICAgICAgICAgICAgcmV0dXJuIHBsdXJhbE1hcFtrZXldLnJlcGxhY2UoX0lOVEVSUE9MQVRJT05fUkVHRVhQLCB2YWx1ZS50b1N0cmluZygpKTtcbiAgICAgICAgfTtcbiAgICAgICAgSTE4blBsdXJhbFBpcGUuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5QaXBlLCBhcmdzOiBbeyBuYW1lOiAnaTE4blBsdXJhbCcsIHB1cmU6IHRydWUgfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBJMThuUGx1cmFsUGlwZS5jdG9yUGFyYW1ldGVycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogTmdMb2NhbGl6YXRpb24sIH0sXG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiBJMThuUGx1cmFsUGlwZTtcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogQG5nTW9kdWxlIENvbW1vbk1vZHVsZVxuICAgICAqIEB3aGF0SXREb2VzIEdlbmVyaWMgc2VsZWN0b3IgdGhhdCBkaXNwbGF5cyB0aGUgc3RyaW5nIHRoYXQgbWF0Y2hlcyB0aGUgY3VycmVudCB2YWx1ZS5cbiAgICAgKiBAaG93VG9Vc2UgYGV4cHJlc3Npb24gfCBpMThuU2VsZWN0Om1hcHBpbmdgXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICpcbiAgICAgKiAgV2hlcmU6XG4gICAgICogIC0gYG1hcHBpbmdgOiBpcyBhbiBvYmplY3QgdGhhdCBpbmRpY2F0ZXMgdGhlIHRleHQgdGhhdCBzaG91bGQgYmUgZGlzcGxheWVkXG4gICAgICogIGZvciBkaWZmZXJlbnQgdmFsdWVzIG9mIHRoZSBwcm92aWRlZCBgZXhwcmVzc2lvbmAuXG4gICAgICpcbiAgICAgKiAgIyMgRXhhbXBsZVxuICAgICAqXG4gICAgICoge0BleGFtcGxlIGNvbW1vbi9waXBlcy90cy9pMThuX3BpcGUudHMgcmVnaW9uPSdJMThuU2VsZWN0UGlwZUNvbXBvbmVudCd9XG4gICAgICpcbiAgICAgKiAgQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIHZhciBJMThuU2VsZWN0UGlwZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEkxOG5TZWxlY3RQaXBlKCkge1xuICAgICAgICB9XG4gICAgICAgIEkxOG5TZWxlY3RQaXBlLnByb3RvdHlwZS50cmFuc2Zvcm0gPSBmdW5jdGlvbiAodmFsdWUsIG1hcHBpbmcpIHtcbiAgICAgICAgICAgIGlmIChpc0JsYW5rKHZhbHVlKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1hcHBpbmcgIT09ICdvYmplY3QnIHx8IG1hcHBpbmcgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFBpcGVBcmd1bWVudEVycm9yKEkxOG5TZWxlY3RQaXBlLCBtYXBwaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtYXBwaW5nW3ZhbHVlXSB8fCAnJztcbiAgICAgICAgfTtcbiAgICAgICAgSTE4blNlbGVjdFBpcGUuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5QaXBlLCBhcmdzOiBbeyBuYW1lOiAnaTE4blNlbGVjdCcsIHB1cmU6IHRydWUgfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBJMThuU2VsZWN0UGlwZS5jdG9yUGFyYW1ldGVycyA9IFtdO1xuICAgICAgICByZXR1cm4gSTE4blNlbGVjdFBpcGU7XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIEBuZ01vZHVsZSBDb21tb25Nb2R1bGVcbiAgICAgKiBAd2hhdEl0RG9lcyBDb252ZXJ0cyB2YWx1ZSBpbnRvIEpTT04gc3RyaW5nLlxuICAgICAqIEBob3dUb1VzZSBgZXhwcmVzc2lvbiB8IGpzb25gXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICpcbiAgICAgKiBDb252ZXJ0cyB2YWx1ZSBpbnRvIHN0cmluZyB1c2luZyBgSlNPTi5zdHJpbmdpZnlgLiBVc2VmdWwgZm9yIGRlYnVnZ2luZy5cbiAgICAgKlxuICAgICAqICMjIyBFeGFtcGxlXG4gICAgICoge0BleGFtcGxlIGNvbW1vbi9waXBlcy90cy9qc29uX3BpcGUudHMgcmVnaW9uPSdKc29uUGlwZSd9XG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIEpzb25QaXBlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gSnNvblBpcGUoKSB7XG4gICAgICAgIH1cbiAgICAgICAgSnNvblBpcGUucHJvdG90eXBlLnRyYW5zZm9ybSA9IGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUsIG51bGwsIDIpOyB9O1xuICAgICAgICBKc29uUGlwZS5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlBpcGUsIGFyZ3M6IFt7IG5hbWU6ICdqc29uJywgcHVyZTogZmFsc2UgfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBKc29uUGlwZS5jdG9yUGFyYW1ldGVycyA9IFtdO1xuICAgICAgICByZXR1cm4gSnNvblBpcGU7XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIEBuZ01vZHVsZSBDb21tb25Nb2R1bGVcbiAgICAgKiBAd2hhdEl0RG9lcyBUcmFuc2Zvcm1zIHN0cmluZyB0byBsb3dlcmNhc2UuXG4gICAgICogQGhvd1RvVXNlIGBleHByZXNzaW9uIHwgbG93ZXJjYXNlYFxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqXG4gICAgICogQ29udmVydHMgdmFsdWUgaW50byBsb3dlcmNhc2Ugc3RyaW5nIHVzaW5nIGBTdHJpbmcucHJvdG90eXBlLnRvTG93ZXJDYXNlKClgLlxuICAgICAqXG4gICAgICogIyMjIEV4YW1wbGVcbiAgICAgKlxuICAgICAqIHtAZXhhbXBsZSBjb21tb24vcGlwZXMvdHMvbG93ZXJ1cHBlcl9waXBlLnRzIHJlZ2lvbj0nTG93ZXJVcHBlclBpcGUnfVxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBMb3dlckNhc2VQaXBlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gTG93ZXJDYXNlUGlwZSgpIHtcbiAgICAgICAgfVxuICAgICAgICBMb3dlckNhc2VQaXBlLnByb3RvdHlwZS50cmFuc2Zvcm0gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChpc0JsYW5rKHZhbHVlKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkUGlwZUFyZ3VtZW50RXJyb3IoTG93ZXJDYXNlUGlwZSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH07XG4gICAgICAgIExvd2VyQ2FzZVBpcGUuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5QaXBlLCBhcmdzOiBbeyBuYW1lOiAnbG93ZXJjYXNlJyB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIExvd2VyQ2FzZVBpcGUuY3RvclBhcmFtZXRlcnMgPSBbXTtcbiAgICAgICAgcmV0dXJuIExvd2VyQ2FzZVBpcGU7XG4gICAgfSgpKTtcblxuICAgIHZhciBfTlVNQkVSX0ZPUk1BVF9SRUdFWFAgPSAvXihcXGQrKT9cXC4oKFxcZCspKC0oXFxkKykpPyk/JC87XG4gICAgZnVuY3Rpb24gZm9ybWF0TnVtYmVyKHBpcGUsIGxvY2FsZSwgdmFsdWUsIHN0eWxlLCBkaWdpdHMsIGN1cnJlbmN5LCBjdXJyZW5jeUFzU3ltYm9sKSB7XG4gICAgICAgIGlmIChjdXJyZW5jeSA9PT0gdm9pZCAwKSB7IGN1cnJlbmN5ID0gbnVsbDsgfVxuICAgICAgICBpZiAoY3VycmVuY3lBc1N5bWJvbCA9PT0gdm9pZCAwKSB7IGN1cnJlbmN5QXNTeW1ib2wgPSBmYWxzZTsgfVxuICAgICAgICBpZiAoaXNCbGFuayh2YWx1ZSkpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgLy8gQ29udmVydCBzdHJpbmdzIHRvIG51bWJlcnNcbiAgICAgICAgdmFsdWUgPSB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIE51bWJlcldyYXBwZXIuaXNOdW1lcmljKHZhbHVlKSA/ICt2YWx1ZSA6IHZhbHVlO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRQaXBlQXJndW1lbnRFcnJvcihwaXBlLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1pbkludDtcbiAgICAgICAgdmFyIG1pbkZyYWN0aW9uO1xuICAgICAgICB2YXIgbWF4RnJhY3Rpb247XG4gICAgICAgIGlmIChzdHlsZSAhPT0gTnVtYmVyRm9ybWF0U3R5bGUuQ3VycmVuY3kpIHtcbiAgICAgICAgICAgIC8vIHJlbHkgb24gSW50bCBkZWZhdWx0IGZvciBjdXJyZW5jeVxuICAgICAgICAgICAgbWluSW50ID0gMTtcbiAgICAgICAgICAgIG1pbkZyYWN0aW9uID0gMDtcbiAgICAgICAgICAgIG1heEZyYWN0aW9uID0gMztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGlnaXRzKSB7XG4gICAgICAgICAgICB2YXIgcGFydHMgPSBkaWdpdHMubWF0Y2goX05VTUJFUl9GT1JNQVRfUkVHRVhQKTtcbiAgICAgICAgICAgIGlmIChwYXJ0cyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihkaWdpdHMgKyBcIiBpcyBub3QgYSB2YWxpZCBkaWdpdCBpbmZvIGZvciBudW1iZXIgcGlwZXNcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNQcmVzZW50KHBhcnRzWzFdKSkge1xuICAgICAgICAgICAgICAgIG1pbkludCA9IE51bWJlcldyYXBwZXIucGFyc2VJbnRBdXRvUmFkaXgocGFydHNbMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzUHJlc2VudChwYXJ0c1szXSkpIHtcbiAgICAgICAgICAgICAgICBtaW5GcmFjdGlvbiA9IE51bWJlcldyYXBwZXIucGFyc2VJbnRBdXRvUmFkaXgocGFydHNbM10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzUHJlc2VudChwYXJ0c1s1XSkpIHtcbiAgICAgICAgICAgICAgICBtYXhGcmFjdGlvbiA9IE51bWJlcldyYXBwZXIucGFyc2VJbnRBdXRvUmFkaXgocGFydHNbNV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBOdW1iZXJGb3JtYXR0ZXIuZm9ybWF0KHZhbHVlLCBsb2NhbGUsIHN0eWxlLCB7XG4gICAgICAgICAgICBtaW5pbXVtSW50ZWdlckRpZ2l0czogbWluSW50LFxuICAgICAgICAgICAgbWluaW11bUZyYWN0aW9uRGlnaXRzOiBtaW5GcmFjdGlvbixcbiAgICAgICAgICAgIG1heGltdW1GcmFjdGlvbkRpZ2l0czogbWF4RnJhY3Rpb24sXG4gICAgICAgICAgICBjdXJyZW5jeTogY3VycmVuY3ksXG4gICAgICAgICAgICBjdXJyZW5jeUFzU3ltYm9sOiBjdXJyZW5jeUFzU3ltYm9sLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQG5nTW9kdWxlIENvbW1vbk1vZHVsZVxuICAgICAqIEB3aGF0SXREb2VzIEZvcm1hdHMgYSBudW1iZXIgYWNjb3JkaW5nIHRvIGxvY2FsZSBydWxlcy5cbiAgICAgKiBAaG93VG9Vc2UgYG51bWJlcl9leHByZXNzaW9uIHwgbnVtYmVyWzpkaWdpdEluZm9dYFxuICAgICAqXG4gICAgICogRm9ybWF0cyBhIG51bWJlciBhcyB0ZXh0LiBHcm91cCBzaXppbmcgYW5kIHNlcGFyYXRvciBhbmQgb3RoZXIgbG9jYWxlLXNwZWNpZmljXG4gICAgICogY29uZmlndXJhdGlvbnMgYXJlIGJhc2VkIG9uIHRoZSBhY3RpdmUgbG9jYWxlLlxuICAgICAqXG4gICAgICogd2hlcmUgYGV4cHJlc3Npb25gIGlzIGEgbnVtYmVyOlxuICAgICAqICAtIGBkaWdpdEluZm9gIGlzIGEgYHN0cmluZ2Agd2hpY2ggaGFzIGEgZm9sbG93aW5nIGZvcm1hdDogPGJyPlxuICAgICAqICAgICA8Y29kZT57bWluSW50ZWdlckRpZ2l0c30ue21pbkZyYWN0aW9uRGlnaXRzfS17bWF4RnJhY3Rpb25EaWdpdHN9PC9jb2RlPlxuICAgICAqICAgLSBgbWluSW50ZWdlckRpZ2l0c2AgaXMgdGhlIG1pbmltdW0gbnVtYmVyIG9mIGludGVnZXIgZGlnaXRzIHRvIHVzZS4gRGVmYXVsdHMgdG8gYDFgLlxuICAgICAqICAgLSBgbWluRnJhY3Rpb25EaWdpdHNgIGlzIHRoZSBtaW5pbXVtIG51bWJlciBvZiBkaWdpdHMgYWZ0ZXIgZnJhY3Rpb24uIERlZmF1bHRzIHRvIGAwYC5cbiAgICAgKiAgIC0gYG1heEZyYWN0aW9uRGlnaXRzYCBpcyB0aGUgbWF4aW11bSBudW1iZXIgb2YgZGlnaXRzIGFmdGVyIGZyYWN0aW9uLiBEZWZhdWx0cyB0byBgM2AuXG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiB0aGUgYWNjZXB0YWJsZSByYW5nZSBmb3IgZWFjaCBvZiB0aGVzZSBudW1iZXJzIGFuZCBvdGhlclxuICAgICAqIGRldGFpbHMgc2VlIHlvdXIgbmF0aXZlIGludGVybmF0aW9uYWxpemF0aW9uIGxpYnJhcnkuXG4gICAgICpcbiAgICAgKiBXQVJOSU5HOiB0aGlzIHBpcGUgdXNlcyB0aGUgSW50ZXJuYXRpb25hbGl6YXRpb24gQVBJIHdoaWNoIGlzIG5vdCB5ZXQgYXZhaWxhYmxlIGluIGFsbCBicm93c2Vyc1xuICAgICAqIGFuZCBtYXkgcmVxdWlyZSBhIHBvbHlmaWxsLiBTZWUge0BsaW5rRG9jcyBndWlkZS9icm93c2VyLXN1cHBvcnR9IGZvciBkZXRhaWxzLlxuICAgICAqXG4gICAgICogIyMjIEV4YW1wbGVcbiAgICAgKlxuICAgICAqIHtAZXhhbXBsZSBjb21tb24vcGlwZXMvdHMvbnVtYmVyX3BpcGUudHMgcmVnaW9uPSdOdW1iZXJQaXBlJ31cbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgRGVjaW1hbFBpcGUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBEZWNpbWFsUGlwZShfbG9jYWxlKSB7XG4gICAgICAgICAgICB0aGlzLl9sb2NhbGUgPSBfbG9jYWxlO1xuICAgICAgICB9XG4gICAgICAgIERlY2ltYWxQaXBlLnByb3RvdHlwZS50cmFuc2Zvcm0gPSBmdW5jdGlvbiAodmFsdWUsIGRpZ2l0cykge1xuICAgICAgICAgICAgaWYgKGRpZ2l0cyA9PT0gdm9pZCAwKSB7IGRpZ2l0cyA9IG51bGw7IH1cbiAgICAgICAgICAgIHJldHVybiBmb3JtYXROdW1iZXIoRGVjaW1hbFBpcGUsIHRoaXMuX2xvY2FsZSwgdmFsdWUsIE51bWJlckZvcm1hdFN0eWxlLkRlY2ltYWwsIGRpZ2l0cyk7XG4gICAgICAgIH07XG4gICAgICAgIERlY2ltYWxQaXBlLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuUGlwZSwgYXJnczogW3sgbmFtZTogJ251bWJlcicgfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBEZWNpbWFsUGlwZS5jdG9yUGFyYW1ldGVycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdCwgYXJnczogW19hbmd1bGFyX2NvcmUuTE9DQUxFX0lELF0gfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiBEZWNpbWFsUGlwZTtcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIEBuZ01vZHVsZSBDb21tb25Nb2R1bGVcbiAgICAgKiBAd2hhdEl0RG9lcyBGb3JtYXRzIGEgbnVtYmVyIGFzIGEgcGVyY2VudGFnZSBhY2NvcmRpbmcgdG8gbG9jYWxlIHJ1bGVzLlxuICAgICAqIEBob3dUb1VzZSBgbnVtYmVyX2V4cHJlc3Npb24gfCBwZXJjZW50WzpkaWdpdEluZm9dYFxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICpcbiAgICAgKiBGb3JtYXRzIGEgbnVtYmVyIGFzIHBlcmNlbnRhZ2UuXG4gICAgICpcbiAgICAgKiAtIGBkaWdpdEluZm9gIFNlZSB7QGxpbmsgRGVjaW1hbFBpcGV9IGZvciBkZXRhaWxlZCBkZXNjcmlwdGlvbi5cbiAgICAgKlxuICAgICAqIFdBUk5JTkc6IHRoaXMgcGlwZSB1c2VzIHRoZSBJbnRlcm5hdGlvbmFsaXphdGlvbiBBUEkgd2hpY2ggaXMgbm90IHlldCBhdmFpbGFibGUgaW4gYWxsIGJyb3dzZXJzXG4gICAgICogYW5kIG1heSByZXF1aXJlIGEgcG9seWZpbGwuIFNlZSB7QGxpbmtEb2NzIGd1aWRlL2Jyb3dzZXItc3VwcG9ydH0gZm9yIGRldGFpbHMuXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZVxuICAgICAqXG4gICAgICoge0BleGFtcGxlIGNvbW1vbi9waXBlcy90cy9udW1iZXJfcGlwZS50cyByZWdpb249J1BlcmNlbnRQaXBlJ31cbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgUGVyY2VudFBpcGUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBQZXJjZW50UGlwZShfbG9jYWxlKSB7XG4gICAgICAgICAgICB0aGlzLl9sb2NhbGUgPSBfbG9jYWxlO1xuICAgICAgICB9XG4gICAgICAgIFBlcmNlbnRQaXBlLnByb3RvdHlwZS50cmFuc2Zvcm0gPSBmdW5jdGlvbiAodmFsdWUsIGRpZ2l0cykge1xuICAgICAgICAgICAgaWYgKGRpZ2l0cyA9PT0gdm9pZCAwKSB7IGRpZ2l0cyA9IG51bGw7IH1cbiAgICAgICAgICAgIHJldHVybiBmb3JtYXROdW1iZXIoUGVyY2VudFBpcGUsIHRoaXMuX2xvY2FsZSwgdmFsdWUsIE51bWJlckZvcm1hdFN0eWxlLlBlcmNlbnQsIGRpZ2l0cyk7XG4gICAgICAgIH07XG4gICAgICAgIFBlcmNlbnRQaXBlLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuUGlwZSwgYXJnczogW3sgbmFtZTogJ3BlcmNlbnQnIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgUGVyY2VudFBpcGUuY3RvclBhcmFtZXRlcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3QsIGFyZ3M6IFtfYW5ndWxhcl9jb3JlLkxPQ0FMRV9JRCxdIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gUGVyY2VudFBpcGU7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBAbmdNb2R1bGUgQ29tbW9uTW9kdWxlXG4gICAgICogQHdoYXRJdERvZXMgRm9ybWF0cyBhIG51bWJlciBhcyBjdXJyZW5jeSB1c2luZyBsb2NhbGUgcnVsZXMuXG4gICAgICogQGhvd1RvVXNlIGBudW1iZXJfZXhwcmVzc2lvbiB8IGN1cnJlbmN5WzpjdXJyZW5jeUNvZGVbOnN5bWJvbERpc3BsYXlbOmRpZ2l0SW5mb11dXWBcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKlxuICAgICAqIFVzZSBgY3VycmVuY3lgIHRvIGZvcm1hdCBhIG51bWJlciBhcyBjdXJyZW5jeS5cbiAgICAgKlxuICAgICAqIC0gYGN1cnJlbmN5Q29kZWAgaXMgdGhlIFtJU08gNDIxN10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPXzQyMTcpIGN1cnJlbmN5IGNvZGUsIHN1Y2hcbiAgICAgKiAgICBhcyBgVVNEYCBmb3IgdGhlIFVTIGRvbGxhciBhbmQgYEVVUmAgZm9yIHRoZSBldXJvLlxuICAgICAqIC0gYHN5bWJvbERpc3BsYXlgIGlzIGEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdG8gdXNlIHRoZSBjdXJyZW5jeSBzeW1ib2wgb3IgY29kZS5cbiAgICAgKiAgIC0gYHRydWVgOiB1c2Ugc3ltYm9sIChlLmcuIGAkYCkuXG4gICAgICogICAtIGBmYWxzZWAoZGVmYXVsdCk6IHVzZSBjb2RlIChlLmcuIGBVU0RgKS5cbiAgICAgKiAtIGBkaWdpdEluZm9gIFNlZSB7QGxpbmsgRGVjaW1hbFBpcGV9IGZvciBkZXRhaWxlZCBkZXNjcmlwdGlvbi5cbiAgICAgKlxuICAgICAqIFdBUk5JTkc6IHRoaXMgcGlwZSB1c2VzIHRoZSBJbnRlcm5hdGlvbmFsaXphdGlvbiBBUEkgd2hpY2ggaXMgbm90IHlldCBhdmFpbGFibGUgaW4gYWxsIGJyb3dzZXJzXG4gICAgICogYW5kIG1heSByZXF1aXJlIGEgcG9seWZpbGwuIFNlZSB7QGxpbmtEb2NzIGd1aWRlL2Jyb3dzZXItc3VwcG9ydH0gZm9yIGRldGFpbHMuXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZVxuICAgICAqXG4gICAgICoge0BleGFtcGxlIGNvbW1vbi9waXBlcy90cy9udW1iZXJfcGlwZS50cyByZWdpb249J0N1cnJlbmN5UGlwZSd9XG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIEN1cnJlbmN5UGlwZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEN1cnJlbmN5UGlwZShfbG9jYWxlKSB7XG4gICAgICAgICAgICB0aGlzLl9sb2NhbGUgPSBfbG9jYWxlO1xuICAgICAgICB9XG4gICAgICAgIEN1cnJlbmN5UGlwZS5wcm90b3R5cGUudHJhbnNmb3JtID0gZnVuY3Rpb24gKHZhbHVlLCBjdXJyZW5jeUNvZGUsIHN5bWJvbERpc3BsYXksIGRpZ2l0cykge1xuICAgICAgICAgICAgaWYgKGN1cnJlbmN5Q29kZSA9PT0gdm9pZCAwKSB7IGN1cnJlbmN5Q29kZSA9ICdVU0QnOyB9XG4gICAgICAgICAgICBpZiAoc3ltYm9sRGlzcGxheSA9PT0gdm9pZCAwKSB7IHN5bWJvbERpc3BsYXkgPSBmYWxzZTsgfVxuICAgICAgICAgICAgaWYgKGRpZ2l0cyA9PT0gdm9pZCAwKSB7IGRpZ2l0cyA9IG51bGw7IH1cbiAgICAgICAgICAgIHJldHVybiBmb3JtYXROdW1iZXIoQ3VycmVuY3lQaXBlLCB0aGlzLl9sb2NhbGUsIHZhbHVlLCBOdW1iZXJGb3JtYXRTdHlsZS5DdXJyZW5jeSwgZGlnaXRzLCBjdXJyZW5jeUNvZGUsIHN5bWJvbERpc3BsYXkpO1xuICAgICAgICB9O1xuICAgICAgICBDdXJyZW5jeVBpcGUuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5QaXBlLCBhcmdzOiBbeyBuYW1lOiAnY3VycmVuY3knIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgQ3VycmVuY3lQaXBlLmN0b3JQYXJhbWV0ZXJzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0LCBhcmdzOiBbX2FuZ3VsYXJfY29yZS5MT0NBTEVfSUQsXSB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIEN1cnJlbmN5UGlwZTtcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogQG5nTW9kdWxlIENvbW1vbk1vZHVsZVxuICAgICAqIEB3aGF0SXREb2VzIENyZWF0ZXMgYSBuZXcgTGlzdCBvciBTdHJpbmcgY29udGFpbmluZyBhIHN1YnNldCAoc2xpY2UpIG9mIHRoZSBlbGVtZW50cy5cbiAgICAgKiBAaG93VG9Vc2UgYGFycmF5X29yX3N0cmluZ19leHByZXNzaW9uIHwgc2xpY2U6c3RhcnRbOmVuZF1gXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICpcbiAgICAgKiBXaGVyZSB0aGUgaW5wdXQgZXhwcmVzc2lvbiBpcyBhIGBMaXN0YCBvciBgU3RyaW5nYCwgYW5kOlxuICAgICAqIC0gYHN0YXJ0YDogVGhlIHN0YXJ0aW5nIGluZGV4IG9mIHRoZSBzdWJzZXQgdG8gcmV0dXJuLlxuICAgICAqICAgLSAqKmEgcG9zaXRpdmUgaW50ZWdlcioqOiByZXR1cm4gdGhlIGl0ZW0gYXQgYHN0YXJ0YCBpbmRleCBhbmQgYWxsIGl0ZW1zIGFmdGVyXG4gICAgICogICAgIGluIHRoZSBsaXN0IG9yIHN0cmluZyBleHByZXNzaW9uLlxuICAgICAqICAgLSAqKmEgbmVnYXRpdmUgaW50ZWdlcioqOiByZXR1cm4gdGhlIGl0ZW0gYXQgYHN0YXJ0YCBpbmRleCBmcm9tIHRoZSBlbmQgYW5kIGFsbCBpdGVtcyBhZnRlclxuICAgICAqICAgICBpbiB0aGUgbGlzdCBvciBzdHJpbmcgZXhwcmVzc2lvbi5cbiAgICAgKiAgIC0gKippZiBwb3NpdGl2ZSBhbmQgZ3JlYXRlciB0aGFuIHRoZSBzaXplIG9mIHRoZSBleHByZXNzaW9uKio6IHJldHVybiBhbiBlbXB0eSBsaXN0IG9yIHN0cmluZy5cbiAgICAgKiAgIC0gKippZiBuZWdhdGl2ZSBhbmQgZ3JlYXRlciB0aGFuIHRoZSBzaXplIG9mIHRoZSBleHByZXNzaW9uKio6IHJldHVybiBlbnRpcmUgbGlzdCBvciBzdHJpbmcuXG4gICAgICogLSBgZW5kYDogVGhlIGVuZGluZyBpbmRleCBvZiB0aGUgc3Vic2V0IHRvIHJldHVybi5cbiAgICAgKiAgIC0gKipvbWl0dGVkKio6IHJldHVybiBhbGwgaXRlbXMgdW50aWwgdGhlIGVuZC5cbiAgICAgKiAgIC0gKippZiBwb3NpdGl2ZSoqOiByZXR1cm4gYWxsIGl0ZW1zIGJlZm9yZSBgZW5kYCBpbmRleCBvZiB0aGUgbGlzdCBvciBzdHJpbmcuXG4gICAgICogICAtICoqaWYgbmVnYXRpdmUqKjogcmV0dXJuIGFsbCBpdGVtcyBiZWZvcmUgYGVuZGAgaW5kZXggZnJvbSB0aGUgZW5kIG9mIHRoZSBsaXN0IG9yIHN0cmluZy5cbiAgICAgKlxuICAgICAqIEFsbCBiZWhhdmlvciBpcyBiYXNlZCBvbiB0aGUgZXhwZWN0ZWQgYmVoYXZpb3Igb2YgdGhlIEphdmFTY3JpcHQgQVBJIGBBcnJheS5wcm90b3R5cGUuc2xpY2UoKWBcbiAgICAgKiBhbmQgYFN0cmluZy5wcm90b3R5cGUuc2xpY2UoKWAuXG4gICAgICpcbiAgICAgKiBXaGVuIG9wZXJhdGluZyBvbiBhIFtMaXN0XSwgdGhlIHJldHVybmVkIGxpc3QgaXMgYWx3YXlzIGEgY29weSBldmVuIHdoZW4gYWxsXG4gICAgICogdGhlIGVsZW1lbnRzIGFyZSBiZWluZyByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIFdoZW4gb3BlcmF0aW5nIG9uIGEgYmxhbmsgdmFsdWUsIHRoZSBwaXBlIHJldHVybnMgdGhlIGJsYW5rIHZhbHVlLlxuICAgICAqXG4gICAgICogIyMgTGlzdCBFeGFtcGxlXG4gICAgICpcbiAgICAgKiBUaGlzIGBuZ0ZvcmAgZXhhbXBsZTpcbiAgICAgKlxuICAgICAqIHtAZXhhbXBsZSBjb21tb24vcGlwZXMvdHMvc2xpY2VfcGlwZS50cyByZWdpb249J1NsaWNlUGlwZV9saXN0J31cbiAgICAgKlxuICAgICAqIHByb2R1Y2VzIHRoZSBmb2xsb3dpbmc6XG4gICAgICpcbiAgICAgKiAgICAgPGxpPmI8L2xpPlxuICAgICAqICAgICA8bGk+YzwvbGk+XG4gICAgICpcbiAgICAgKiAjIyBTdHJpbmcgRXhhbXBsZXNcbiAgICAgKlxuICAgICAqIHtAZXhhbXBsZSBjb21tb24vcGlwZXMvdHMvc2xpY2VfcGlwZS50cyByZWdpb249J1NsaWNlUGlwZV9zdHJpbmcnfVxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBTbGljZVBpcGUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBTbGljZVBpcGUoKSB7XG4gICAgICAgIH1cbiAgICAgICAgU2xpY2VQaXBlLnByb3RvdHlwZS50cmFuc2Zvcm0gPSBmdW5jdGlvbiAodmFsdWUsIHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgICAgIGlmIChpc0JsYW5rKHZhbHVlKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICBpZiAoIXRoaXMuc3VwcG9ydHModmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRQaXBlQXJndW1lbnRFcnJvcihTbGljZVBpcGUsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS5zbGljZShzdGFydCwgZW5kKTtcbiAgICAgICAgfTtcbiAgICAgICAgU2xpY2VQaXBlLnByb3RvdHlwZS5zdXBwb3J0cyA9IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmogPT09ICdzdHJpbmcnIHx8IEFycmF5LmlzQXJyYXkob2JqKTsgfTtcbiAgICAgICAgU2xpY2VQaXBlLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuUGlwZSwgYXJnczogW3sgbmFtZTogJ3NsaWNlJywgcHVyZTogZmFsc2UgfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBTbGljZVBpcGUuY3RvclBhcmFtZXRlcnMgPSBbXTtcbiAgICAgICAgcmV0dXJuIFNsaWNlUGlwZTtcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogQG5nTW9kdWxlIENvbW1vbk1vZHVsZVxuICAgICAqIEB3aGF0SXREb2VzIFRyYW5zZm9ybXMgc3RyaW5nIHRvIHVwcGVyY2FzZS5cbiAgICAgKiBAaG93VG9Vc2UgYGV4cHJlc3Npb24gfCB1cHBlcmNhc2VgXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICpcbiAgICAgKiBDb252ZXJ0cyB2YWx1ZSBpbnRvIGxvd2VyY2FzZSBzdHJpbmcgdXNpbmcgYFN0cmluZy5wcm90b3R5cGUudG9VcHBlckNhc2UoKWAuXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZVxuICAgICAqXG4gICAgICoge0BleGFtcGxlIGNvbW1vbi9waXBlcy90cy9sb3dlcnVwcGVyX3BpcGUudHMgcmVnaW9uPSdMb3dlclVwcGVyUGlwZSd9XG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIFVwcGVyQ2FzZVBpcGUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBVcHBlckNhc2VQaXBlKCkge1xuICAgICAgICB9XG4gICAgICAgIFVwcGVyQ2FzZVBpcGUucHJvdG90eXBlLnRyYW5zZm9ybSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKGlzQmxhbmsodmFsdWUpKVxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRQaXBlQXJndW1lbnRFcnJvcihVcHBlckNhc2VQaXBlLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUudG9VcHBlckNhc2UoKTtcbiAgICAgICAgfTtcbiAgICAgICAgVXBwZXJDYXNlUGlwZS5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlBpcGUsIGFyZ3M6IFt7IG5hbWU6ICd1cHBlcmNhc2UnIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgVXBwZXJDYXNlUGlwZS5jdG9yUGFyYW1ldGVycyA9IFtdO1xuICAgICAgICByZXR1cm4gVXBwZXJDYXNlUGlwZTtcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogQSBjb2xsZWN0aW9uIG9mIEFuZ3VsYXIgcGlwZXMgdGhhdCBhcmUgbGlrZWx5IHRvIGJlIHVzZWQgaW4gZWFjaCBhbmQgZXZlcnkgYXBwbGljYXRpb24uXG4gICAgICovXG4gICAgdmFyIENPTU1PTl9QSVBFUyA9IFtcbiAgICAgICAgQXN5bmNQaXBlLFxuICAgICAgICBVcHBlckNhc2VQaXBlLFxuICAgICAgICBMb3dlckNhc2VQaXBlLFxuICAgICAgICBKc29uUGlwZSxcbiAgICAgICAgU2xpY2VQaXBlLFxuICAgICAgICBEZWNpbWFsUGlwZSxcbiAgICAgICAgUGVyY2VudFBpcGUsXG4gICAgICAgIEN1cnJlbmN5UGlwZSxcbiAgICAgICAgRGF0ZVBpcGUsXG4gICAgICAgIEkxOG5QbHVyYWxQaXBlLFxuICAgICAgICBJMThuU2VsZWN0UGlwZSxcbiAgICBdO1xuXG4gICAgLy8gTm90ZTogVGhpcyBkb2VzIG5vdCBjb250YWluIHRoZSBsb2NhdGlvbiBwcm92aWRlcnMsXG4gICAgLy8gYXMgdGhleSBuZWVkIHNvbWUgcGxhdGZvcm0gc3BlY2lmaWMgaW1wbGVtZW50YXRpb25zIHRvIHdvcmsuXG4gICAgLyoqXG4gICAgICogVGhlIG1vZHVsZSB0aGF0IGluY2x1ZGVzIGFsbCB0aGUgYmFzaWMgQW5ndWxhciBkaXJlY3RpdmVzIGxpa2Uge0BsaW5rIE5nSWZ9LCB7QGxpbmsgTmdGb3J9LCAuLi5cbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgQ29tbW9uTW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gQ29tbW9uTW9kdWxlKCkge1xuICAgICAgICB9XG4gICAgICAgIENvbW1vbk1vZHVsZS5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLk5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbQ09NTU9OX0RJUkVDVElWRVMsIENPTU1PTl9QSVBFU10sXG4gICAgICAgICAgICAgICAgICAgICAgICBleHBvcnRzOiBbQ09NTU9OX0RJUkVDVElWRVMsIENPTU1PTl9QSVBFU10sXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IHByb3ZpZGU6IE5nTG9jYWxpemF0aW9uLCB1c2VDbGFzczogTmdMb2NhbGVMb2NhbGl6YXRpb24gfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgQ29tbW9uTW9kdWxlLmN0b3JQYXJhbWV0ZXJzID0gW107XG4gICAgICAgIHJldHVybiBDb21tb25Nb2R1bGU7XG4gICAgfSgpKTtcblxuICAgIGV4cG9ydHMuTmdMb2NhbGl6YXRpb24gPSBOZ0xvY2FsaXphdGlvbjtcbiAgICBleHBvcnRzLkNvbW1vbk1vZHVsZSA9IENvbW1vbk1vZHVsZTtcbiAgICBleHBvcnRzLk5nQ2xhc3MgPSBOZ0NsYXNzO1xuICAgIGV4cG9ydHMuTmdGb3IgPSBOZ0ZvcjtcbiAgICBleHBvcnRzLk5nSWYgPSBOZ0lmO1xuICAgIGV4cG9ydHMuTmdQbHVyYWwgPSBOZ1BsdXJhbDtcbiAgICBleHBvcnRzLk5nUGx1cmFsQ2FzZSA9IE5nUGx1cmFsQ2FzZTtcbiAgICBleHBvcnRzLk5nU3R5bGUgPSBOZ1N0eWxlO1xuICAgIGV4cG9ydHMuTmdTd2l0Y2ggPSBOZ1N3aXRjaDtcbiAgICBleHBvcnRzLk5nU3dpdGNoQ2FzZSA9IE5nU3dpdGNoQ2FzZTtcbiAgICBleHBvcnRzLk5nU3dpdGNoRGVmYXVsdCA9IE5nU3dpdGNoRGVmYXVsdDtcbiAgICBleHBvcnRzLk5nVGVtcGxhdGVPdXRsZXQgPSBOZ1RlbXBsYXRlT3V0bGV0O1xuICAgIGV4cG9ydHMuQXN5bmNQaXBlID0gQXN5bmNQaXBlO1xuICAgIGV4cG9ydHMuRGF0ZVBpcGUgPSBEYXRlUGlwZTtcbiAgICBleHBvcnRzLkkxOG5QbHVyYWxQaXBlID0gSTE4blBsdXJhbFBpcGU7XG4gICAgZXhwb3J0cy5JMThuU2VsZWN0UGlwZSA9IEkxOG5TZWxlY3RQaXBlO1xuICAgIGV4cG9ydHMuSnNvblBpcGUgPSBKc29uUGlwZTtcbiAgICBleHBvcnRzLkxvd2VyQ2FzZVBpcGUgPSBMb3dlckNhc2VQaXBlO1xuICAgIGV4cG9ydHMuQ3VycmVuY3lQaXBlID0gQ3VycmVuY3lQaXBlO1xuICAgIGV4cG9ydHMuRGVjaW1hbFBpcGUgPSBEZWNpbWFsUGlwZTtcbiAgICBleHBvcnRzLlBlcmNlbnRQaXBlID0gUGVyY2VudFBpcGU7XG4gICAgZXhwb3J0cy5TbGljZVBpcGUgPSBTbGljZVBpcGU7XG4gICAgZXhwb3J0cy5VcHBlckNhc2VQaXBlID0gVXBwZXJDYXNlUGlwZTtcbiAgICBleHBvcnRzLlBsYXRmb3JtTG9jYXRpb24gPSBQbGF0Zm9ybUxvY2F0aW9uO1xuICAgIGV4cG9ydHMuTG9jYXRpb25TdHJhdGVneSA9IExvY2F0aW9uU3RyYXRlZ3k7XG4gICAgZXhwb3J0cy5BUFBfQkFTRV9IUkVGID0gQVBQX0JBU0VfSFJFRjtcbiAgICBleHBvcnRzLkhhc2hMb2NhdGlvblN0cmF0ZWd5ID0gSGFzaExvY2F0aW9uU3RyYXRlZ3k7XG4gICAgZXhwb3J0cy5QYXRoTG9jYXRpb25TdHJhdGVneSA9IFBhdGhMb2NhdGlvblN0cmF0ZWd5O1xuICAgIGV4cG9ydHMuTG9jYXRpb24gPSBMb2NhdGlvbjtcblxufSkpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L0Bhbmd1bGFyL2NvbW1vbi9idW5kbGVzL2NvbW1vbi51bWQuanNcbi8vIG1vZHVsZSBpZCA9IDIyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7IE5nTW9kdWxlIH0gICAgICBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgQnJvd3Nlck1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXInO1xyXG5pbXBvcnQgeyBBcHBDb21wb25lbnQgfSAgIGZyb20gJy4vYXBwLmNvbXBvbmVudCc7XHJcblxyXG5ATmdNb2R1bGUoe1xyXG4gIGltcG9ydHM6ICAgICAgWyBCcm93c2VyTW9kdWxlIF0sXHJcbiAgZGVjbGFyYXRpb25zOiBbIEFwcENvbXBvbmVudCBdLFxyXG4gIGJvb3RzdHJhcDogICAgWyBBcHBDb21wb25lbnQgXVxyXG59KVxyXG5cclxuZXhwb3J0IGNsYXNzIEFwcE1vZHVsZSB7IH1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9hcHAvYXBwLm1vZHVsZS50cyIsImltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5cclxuQENvbXBvbmVudCh7XHJcbiAgc2VsZWN0b3I6ICdteS1hcHAnLFxyXG4gIHRlbXBsYXRlOiAnPGgxPk15IHt7bmFtZX19IEFuZ3VsYXIgQXBwPC9oMT4nXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBBcHBDb21wb25lbnQge1xyXG4gIG5hbWU6IHN0cmluZztcclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHRoaXMubmFtZSA9ICdUaGlyZCc7XHJcbiAgfVxyXG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYXBwL2FwcC5jb21wb25lbnQudHMiXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQ3RDQTtBQUNBO0FBQUE7QUFDQTtBQUNBOzs7Ozs7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDbktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDN25qQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ2g3U0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQy9KQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUMzSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUN4UEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ3hKQTtBQUNBO0FBQ0E7Ozs7OztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDbHBGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQy84RkE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUFPQTs7QUFOQTtBQUNBO0FBQ0E7QUFDQTtBQUhBOzs7Ozs7Ozs7Ozs7Ozs7QUNKQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQU9BOzs7QUFDQTtBQUNBO0FBUkE7QUFDQTtBQUNBO0FBRkE7OzsiLCJzb3VyY2VSb290IjoiIn0=